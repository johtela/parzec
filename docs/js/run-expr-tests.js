/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/dagre/index.js":
/*!*************************************!*\
  !*** ./node_modules/dagre/index.js ***!
  \*************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/*
Copyright (c) 2012-2014 Chris Pettitt

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
*/

module.exports = {
  graphlib: __webpack_require__(/*! ./lib/graphlib */ "./node_modules/dagre/lib/graphlib.js"),

  layout: __webpack_require__(/*! ./lib/layout */ "./node_modules/dagre/lib/layout.js"),
  debug: __webpack_require__(/*! ./lib/debug */ "./node_modules/dagre/lib/debug.js"),
  util: {
    time: __webpack_require__(/*! ./lib/util */ "./node_modules/dagre/lib/util.js").time,
    notime: __webpack_require__(/*! ./lib/util */ "./node_modules/dagre/lib/util.js").notime
  },
  version: __webpack_require__(/*! ./lib/version */ "./node_modules/dagre/lib/version.js")
};


/***/ }),

/***/ "./node_modules/dagre/lib/acyclic.js":
/*!*******************************************!*\
  !*** ./node_modules/dagre/lib/acyclic.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var _ = __webpack_require__(/*! ./lodash */ "./node_modules/dagre/lib/lodash.js");
var greedyFAS = __webpack_require__(/*! ./greedy-fas */ "./node_modules/dagre/lib/greedy-fas.js");

module.exports = {
  run: run,
  undo: undo
};

function run(g) {
  var fas = (g.graph().acyclicer === "greedy"
    ? greedyFAS(g, weightFn(g))
    : dfsFAS(g));
  _.forEach(fas, function(e) {
    var label = g.edge(e);
    g.removeEdge(e);
    label.forwardName = e.name;
    label.reversed = true;
    g.setEdge(e.w, e.v, label, _.uniqueId("rev"));
  });

  function weightFn(g) {
    return function(e) {
      return g.edge(e).weight;
    };
  }
}

function dfsFAS(g) {
  var fas = [];
  var stack = {};
  var visited = {};

  function dfs(v) {
    if (_.has(visited, v)) {
      return;
    }
    visited[v] = true;
    stack[v] = true;
    _.forEach(g.outEdges(v), function(e) {
      if (_.has(stack, e.w)) {
        fas.push(e);
      } else {
        dfs(e.w);
      }
    });
    delete stack[v];
  }

  _.forEach(g.nodes(), dfs);
  return fas;
}

function undo(g) {
  _.forEach(g.edges(), function(e) {
    var label = g.edge(e);
    if (label.reversed) {
      g.removeEdge(e);

      var forwardName = label.forwardName;
      delete label.reversed;
      delete label.forwardName;
      g.setEdge(e.w, e.v, label, forwardName);
    }
  });
}


/***/ }),

/***/ "./node_modules/dagre/lib/add-border-segments.js":
/*!*******************************************************!*\
  !*** ./node_modules/dagre/lib/add-border-segments.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var _ = __webpack_require__(/*! ./lodash */ "./node_modules/dagre/lib/lodash.js");
var util = __webpack_require__(/*! ./util */ "./node_modules/dagre/lib/util.js");

module.exports = addBorderSegments;

function addBorderSegments(g) {
  function dfs(v) {
    var children = g.children(v);
    var node = g.node(v);
    if (children.length) {
      _.forEach(children, dfs);
    }

    if (_.has(node, "minRank")) {
      node.borderLeft = [];
      node.borderRight = [];
      for (var rank = node.minRank, maxRank = node.maxRank + 1;
        rank < maxRank;
        ++rank) {
        addBorderNode(g, "borderLeft", "_bl", v, node, rank);
        addBorderNode(g, "borderRight", "_br", v, node, rank);
      }
    }
  }

  _.forEach(g.children(), dfs);
}

function addBorderNode(g, prop, prefix, sg, sgNode, rank) {
  var label = { width: 0, height: 0, rank: rank, borderType: prop };
  var prev = sgNode[prop][rank - 1];
  var curr = util.addDummyNode(g, "border", label, prefix);
  sgNode[prop][rank] = curr;
  g.setParent(curr, sg);
  if (prev) {
    g.setEdge(prev, curr, { weight: 1 });
  }
}


/***/ }),

/***/ "./node_modules/dagre/lib/coordinate-system.js":
/*!*****************************************************!*\
  !*** ./node_modules/dagre/lib/coordinate-system.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var _ = __webpack_require__(/*! ./lodash */ "./node_modules/dagre/lib/lodash.js");

module.exports = {
  adjust: adjust,
  undo: undo
};

function adjust(g) {
  var rankDir = g.graph().rankdir.toLowerCase();
  if (rankDir === "lr" || rankDir === "rl") {
    swapWidthHeight(g);
  }
}

function undo(g) {
  var rankDir = g.graph().rankdir.toLowerCase();
  if (rankDir === "bt" || rankDir === "rl") {
    reverseY(g);
  }

  if (rankDir === "lr" || rankDir === "rl") {
    swapXY(g);
    swapWidthHeight(g);
  }
}

function swapWidthHeight(g) {
  _.forEach(g.nodes(), function(v) { swapWidthHeightOne(g.node(v)); });
  _.forEach(g.edges(), function(e) { swapWidthHeightOne(g.edge(e)); });
}

function swapWidthHeightOne(attrs) {
  var w = attrs.width;
  attrs.width = attrs.height;
  attrs.height = w;
}

function reverseY(g) {
  _.forEach(g.nodes(), function(v) { reverseYOne(g.node(v)); });

  _.forEach(g.edges(), function(e) {
    var edge = g.edge(e);
    _.forEach(edge.points, reverseYOne);
    if (_.has(edge, "y")) {
      reverseYOne(edge);
    }
  });
}

function reverseYOne(attrs) {
  attrs.y = -attrs.y;
}

function swapXY(g) {
  _.forEach(g.nodes(), function(v) { swapXYOne(g.node(v)); });

  _.forEach(g.edges(), function(e) {
    var edge = g.edge(e);
    _.forEach(edge.points, swapXYOne);
    if (_.has(edge, "x")) {
      swapXYOne(edge);
    }
  });
}

function swapXYOne(attrs) {
  var x = attrs.x;
  attrs.x = attrs.y;
  attrs.y = x;
}


/***/ }),

/***/ "./node_modules/dagre/lib/data/list.js":
/*!*********************************************!*\
  !*** ./node_modules/dagre/lib/data/list.js ***!
  \*********************************************/
/***/ ((module) => {

/*
 * Simple doubly linked list implementation derived from Cormen, et al.,
 * "Introduction to Algorithms".
 */

module.exports = List;

function List() {
  var sentinel = {};
  sentinel._next = sentinel._prev = sentinel;
  this._sentinel = sentinel;
}

List.prototype.dequeue = function() {
  var sentinel = this._sentinel;
  var entry = sentinel._prev;
  if (entry !== sentinel) {
    unlink(entry);
    return entry;
  }
};

List.prototype.enqueue = function(entry) {
  var sentinel = this._sentinel;
  if (entry._prev && entry._next) {
    unlink(entry);
  }
  entry._next = sentinel._next;
  sentinel._next._prev = entry;
  sentinel._next = entry;
  entry._prev = sentinel;
};

List.prototype.toString = function() {
  var strs = [];
  var sentinel = this._sentinel;
  var curr = sentinel._prev;
  while (curr !== sentinel) {
    strs.push(JSON.stringify(curr, filterOutLinks));
    curr = curr._prev;
  }
  return "[" + strs.join(", ") + "]";
};

function unlink(entry) {
  entry._prev._next = entry._next;
  entry._next._prev = entry._prev;
  delete entry._next;
  delete entry._prev;
}

function filterOutLinks(k, v) {
  if (k !== "_next" && k !== "_prev") {
    return v;
  }
}


/***/ }),

/***/ "./node_modules/dagre/lib/debug.js":
/*!*****************************************!*\
  !*** ./node_modules/dagre/lib/debug.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var _ = __webpack_require__(/*! ./lodash */ "./node_modules/dagre/lib/lodash.js");
var util = __webpack_require__(/*! ./util */ "./node_modules/dagre/lib/util.js");
var Graph = __webpack_require__(/*! ./graphlib */ "./node_modules/dagre/lib/graphlib.js").Graph;

module.exports = {
  debugOrdering: debugOrdering
};

/* istanbul ignore next */
function debugOrdering(g) {
  var layerMatrix = util.buildLayerMatrix(g);

  var h = new Graph({ compound: true, multigraph: true }).setGraph({});

  _.forEach(g.nodes(), function(v) {
    h.setNode(v, { label: v });
    h.setParent(v, "layer" + g.node(v).rank);
  });

  _.forEach(g.edges(), function(e) {
    h.setEdge(e.v, e.w, {}, e.name);
  });

  _.forEach(layerMatrix, function(layer, i) {
    var layerV = "layer" + i;
    h.setNode(layerV, { rank: "same" });
    _.reduce(layer, function(u, v) {
      h.setEdge(u, v, { style: "invis" });
      return v;
    });
  });

  return h;
}


/***/ }),

/***/ "./node_modules/dagre/lib/graphlib.js":
/*!********************************************!*\
  !*** ./node_modules/dagre/lib/graphlib.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/* global window */

var graphlib;

if (true) {
  try {
    graphlib = __webpack_require__(/*! graphlib */ "./node_modules/graphlib/index.js");
  } catch (e) {
    // continue regardless of error
  }
}

if (!graphlib) {
  graphlib = window.graphlib;
}

module.exports = graphlib;


/***/ }),

/***/ "./node_modules/dagre/lib/greedy-fas.js":
/*!**********************************************!*\
  !*** ./node_modules/dagre/lib/greedy-fas.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var _ = __webpack_require__(/*! ./lodash */ "./node_modules/dagre/lib/lodash.js");
var Graph = __webpack_require__(/*! ./graphlib */ "./node_modules/dagre/lib/graphlib.js").Graph;
var List = __webpack_require__(/*! ./data/list */ "./node_modules/dagre/lib/data/list.js");

/*
 * A greedy heuristic for finding a feedback arc set for a graph. A feedback
 * arc set is a set of edges that can be removed to make a graph acyclic.
 * The algorithm comes from: P. Eades, X. Lin, and W. F. Smyth, "A fast and
 * effective heuristic for the feedback arc set problem." This implementation
 * adjusts that from the paper to allow for weighted edges.
 */
module.exports = greedyFAS;

var DEFAULT_WEIGHT_FN = _.constant(1);

function greedyFAS(g, weightFn) {
  if (g.nodeCount() <= 1) {
    return [];
  }
  var state = buildState(g, weightFn || DEFAULT_WEIGHT_FN);
  var results = doGreedyFAS(state.graph, state.buckets, state.zeroIdx);

  // Expand multi-edges
  return _.flatten(_.map(results, function(e) {
    return g.outEdges(e.v, e.w);
  }), true);
}

function doGreedyFAS(g, buckets, zeroIdx) {
  var results = [];
  var sources = buckets[buckets.length - 1];
  var sinks = buckets[0];

  var entry;
  while (g.nodeCount()) {
    while ((entry = sinks.dequeue()))   { removeNode(g, buckets, zeroIdx, entry); }
    while ((entry = sources.dequeue())) { removeNode(g, buckets, zeroIdx, entry); }
    if (g.nodeCount()) {
      for (var i = buckets.length - 2; i > 0; --i) {
        entry = buckets[i].dequeue();
        if (entry) {
          results = results.concat(removeNode(g, buckets, zeroIdx, entry, true));
          break;
        }
      }
    }
  }

  return results;
}

function removeNode(g, buckets, zeroIdx, entry, collectPredecessors) {
  var results = collectPredecessors ? [] : undefined;

  _.forEach(g.inEdges(entry.v), function(edge) {
    var weight = g.edge(edge);
    var uEntry = g.node(edge.v);

    if (collectPredecessors) {
      results.push({ v: edge.v, w: edge.w });
    }

    uEntry.out -= weight;
    assignBucket(buckets, zeroIdx, uEntry);
  });

  _.forEach(g.outEdges(entry.v), function(edge) {
    var weight = g.edge(edge);
    var w = edge.w;
    var wEntry = g.node(w);
    wEntry["in"] -= weight;
    assignBucket(buckets, zeroIdx, wEntry);
  });

  g.removeNode(entry.v);

  return results;
}

function buildState(g, weightFn) {
  var fasGraph = new Graph();
  var maxIn = 0;
  var maxOut = 0;

  _.forEach(g.nodes(), function(v) {
    fasGraph.setNode(v, { v: v, "in": 0, out: 0 });
  });

  // Aggregate weights on nodes, but also sum the weights across multi-edges
  // into a single edge for the fasGraph.
  _.forEach(g.edges(), function(e) {
    var prevWeight = fasGraph.edge(e.v, e.w) || 0;
    var weight = weightFn(e);
    var edgeWeight = prevWeight + weight;
    fasGraph.setEdge(e.v, e.w, edgeWeight);
    maxOut = Math.max(maxOut, fasGraph.node(e.v).out += weight);
    maxIn  = Math.max(maxIn,  fasGraph.node(e.w)["in"]  += weight);
  });

  var buckets = _.range(maxOut + maxIn + 3).map(function() { return new List(); });
  var zeroIdx = maxIn + 1;

  _.forEach(fasGraph.nodes(), function(v) {
    assignBucket(buckets, zeroIdx, fasGraph.node(v));
  });

  return { graph: fasGraph, buckets: buckets, zeroIdx: zeroIdx };
}

function assignBucket(buckets, zeroIdx, entry) {
  if (!entry.out) {
    buckets[0].enqueue(entry);
  } else if (!entry["in"]) {
    buckets[buckets.length - 1].enqueue(entry);
  } else {
    buckets[entry.out - entry["in"] + zeroIdx].enqueue(entry);
  }
}


/***/ }),

/***/ "./node_modules/dagre/lib/layout.js":
/*!******************************************!*\
  !*** ./node_modules/dagre/lib/layout.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var _ = __webpack_require__(/*! ./lodash */ "./node_modules/dagre/lib/lodash.js");
var acyclic = __webpack_require__(/*! ./acyclic */ "./node_modules/dagre/lib/acyclic.js");
var normalize = __webpack_require__(/*! ./normalize */ "./node_modules/dagre/lib/normalize.js");
var rank = __webpack_require__(/*! ./rank */ "./node_modules/dagre/lib/rank/index.js");
var normalizeRanks = __webpack_require__(/*! ./util */ "./node_modules/dagre/lib/util.js").normalizeRanks;
var parentDummyChains = __webpack_require__(/*! ./parent-dummy-chains */ "./node_modules/dagre/lib/parent-dummy-chains.js");
var removeEmptyRanks = __webpack_require__(/*! ./util */ "./node_modules/dagre/lib/util.js").removeEmptyRanks;
var nestingGraph = __webpack_require__(/*! ./nesting-graph */ "./node_modules/dagre/lib/nesting-graph.js");
var addBorderSegments = __webpack_require__(/*! ./add-border-segments */ "./node_modules/dagre/lib/add-border-segments.js");
var coordinateSystem = __webpack_require__(/*! ./coordinate-system */ "./node_modules/dagre/lib/coordinate-system.js");
var order = __webpack_require__(/*! ./order */ "./node_modules/dagre/lib/order/index.js");
var position = __webpack_require__(/*! ./position */ "./node_modules/dagre/lib/position/index.js");
var util = __webpack_require__(/*! ./util */ "./node_modules/dagre/lib/util.js");
var Graph = __webpack_require__(/*! ./graphlib */ "./node_modules/dagre/lib/graphlib.js").Graph;

module.exports = layout;

function layout(g, opts) {
  var time = opts && opts.debugTiming ? util.time : util.notime;
  time("layout", function() {
    var layoutGraph = 
      time("  buildLayoutGraph", function() { return buildLayoutGraph(g); });
    time("  runLayout",        function() { runLayout(layoutGraph, time); });
    time("  updateInputGraph", function() { updateInputGraph(g, layoutGraph); });
  });
}

function runLayout(g, time) {
  time("    makeSpaceForEdgeLabels", function() { makeSpaceForEdgeLabels(g); });
  time("    removeSelfEdges",        function() { removeSelfEdges(g); });
  time("    acyclic",                function() { acyclic.run(g); });
  time("    nestingGraph.run",       function() { nestingGraph.run(g); });
  time("    rank",                   function() { rank(util.asNonCompoundGraph(g)); });
  time("    injectEdgeLabelProxies", function() { injectEdgeLabelProxies(g); });
  time("    removeEmptyRanks",       function() { removeEmptyRanks(g); });
  time("    nestingGraph.cleanup",   function() { nestingGraph.cleanup(g); });
  time("    normalizeRanks",         function() { normalizeRanks(g); });
  time("    assignRankMinMax",       function() { assignRankMinMax(g); });
  time("    removeEdgeLabelProxies", function() { removeEdgeLabelProxies(g); });
  time("    normalize.run",          function() { normalize.run(g); });
  time("    parentDummyChains",      function() { parentDummyChains(g); });
  time("    addBorderSegments",      function() { addBorderSegments(g); });
  time("    order",                  function() { order(g); });
  time("    insertSelfEdges",        function() { insertSelfEdges(g); });
  time("    adjustCoordinateSystem", function() { coordinateSystem.adjust(g); });
  time("    position",               function() { position(g); });
  time("    positionSelfEdges",      function() { positionSelfEdges(g); });
  time("    removeBorderNodes",      function() { removeBorderNodes(g); });
  time("    normalize.undo",         function() { normalize.undo(g); });
  time("    fixupEdgeLabelCoords",   function() { fixupEdgeLabelCoords(g); });
  time("    undoCoordinateSystem",   function() { coordinateSystem.undo(g); });
  time("    translateGraph",         function() { translateGraph(g); });
  time("    assignNodeIntersects",   function() { assignNodeIntersects(g); });
  time("    reversePoints",          function() { reversePointsForReversedEdges(g); });
  time("    acyclic.undo",           function() { acyclic.undo(g); });
}

/*
 * Copies final layout information from the layout graph back to the input
 * graph. This process only copies whitelisted attributes from the layout graph
 * to the input graph, so it serves as a good place to determine what
 * attributes can influence layout.
 */
function updateInputGraph(inputGraph, layoutGraph) {
  _.forEach(inputGraph.nodes(), function(v) {
    var inputLabel = inputGraph.node(v);
    var layoutLabel = layoutGraph.node(v);

    if (inputLabel) {
      inputLabel.x = layoutLabel.x;
      inputLabel.y = layoutLabel.y;

      if (layoutGraph.children(v).length) {
        inputLabel.width = layoutLabel.width;
        inputLabel.height = layoutLabel.height;
      }
    }
  });

  _.forEach(inputGraph.edges(), function(e) {
    var inputLabel = inputGraph.edge(e);
    var layoutLabel = layoutGraph.edge(e);

    inputLabel.points = layoutLabel.points;
    if (_.has(layoutLabel, "x")) {
      inputLabel.x = layoutLabel.x;
      inputLabel.y = layoutLabel.y;
    }
  });

  inputGraph.graph().width = layoutGraph.graph().width;
  inputGraph.graph().height = layoutGraph.graph().height;
}

var graphNumAttrs = ["nodesep", "edgesep", "ranksep", "marginx", "marginy"];
var graphDefaults = { ranksep: 50, edgesep: 20, nodesep: 50, rankdir: "tb" };
var graphAttrs = ["acyclicer", "ranker", "rankdir", "align"];
var nodeNumAttrs = ["width", "height"];
var nodeDefaults = { width: 0, height: 0 };
var edgeNumAttrs = ["minlen", "weight", "width", "height", "labeloffset"];
var edgeDefaults = {
  minlen: 1, weight: 1, width: 0, height: 0,
  labeloffset: 10, labelpos: "r"
};
var edgeAttrs = ["labelpos"];

/*
 * Constructs a new graph from the input graph, which can be used for layout.
 * This process copies only whitelisted attributes from the input graph to the
 * layout graph. Thus this function serves as a good place to determine what
 * attributes can influence layout.
 */
function buildLayoutGraph(inputGraph) {
  var g = new Graph({ multigraph: true, compound: true });
  var graph = canonicalize(inputGraph.graph());

  g.setGraph(_.merge({},
    graphDefaults,
    selectNumberAttrs(graph, graphNumAttrs),
    _.pick(graph, graphAttrs)));

  _.forEach(inputGraph.nodes(), function(v) {
    var node = canonicalize(inputGraph.node(v));
    g.setNode(v, _.defaults(selectNumberAttrs(node, nodeNumAttrs), nodeDefaults));
    g.setParent(v, inputGraph.parent(v));
  });

  _.forEach(inputGraph.edges(), function(e) {
    var edge = canonicalize(inputGraph.edge(e));
    g.setEdge(e, _.merge({},
      edgeDefaults,
      selectNumberAttrs(edge, edgeNumAttrs),
      _.pick(edge, edgeAttrs)));
  });

  return g;
}

/*
 * This idea comes from the Gansner paper: to account for edge labels in our
 * layout we split each rank in half by doubling minlen and halving ranksep.
 * Then we can place labels at these mid-points between nodes.
 *
 * We also add some minimal padding to the width to push the label for the edge
 * away from the edge itself a bit.
 */
function makeSpaceForEdgeLabels(g) {
  var graph = g.graph();
  graph.ranksep /= 2;
  _.forEach(g.edges(), function(e) {
    var edge = g.edge(e);
    edge.minlen *= 2;
    if (edge.labelpos.toLowerCase() !== "c") {
      if (graph.rankdir === "TB" || graph.rankdir === "BT") {
        edge.width += edge.labeloffset;
      } else {
        edge.height += edge.labeloffset;
      }
    }
  });
}

/*
 * Creates temporary dummy nodes that capture the rank in which each edge's
 * label is going to, if it has one of non-zero width and height. We do this
 * so that we can safely remove empty ranks while preserving balance for the
 * label's position.
 */
function injectEdgeLabelProxies(g) {
  _.forEach(g.edges(), function(e) {
    var edge = g.edge(e);
    if (edge.width && edge.height) {
      var v = g.node(e.v);
      var w = g.node(e.w);
      var label = { rank: (w.rank - v.rank) / 2 + v.rank, e: e };
      util.addDummyNode(g, "edge-proxy", label, "_ep");
    }
  });
}

function assignRankMinMax(g) {
  var maxRank = 0;
  _.forEach(g.nodes(), function(v) {
    var node = g.node(v);
    if (node.borderTop) {
      node.minRank = g.node(node.borderTop).rank;
      node.maxRank = g.node(node.borderBottom).rank;
      maxRank = _.max(maxRank, node.maxRank);
    }
  });
  g.graph().maxRank = maxRank;
}

function removeEdgeLabelProxies(g) {
  _.forEach(g.nodes(), function(v) {
    var node = g.node(v);
    if (node.dummy === "edge-proxy") {
      g.edge(node.e).labelRank = node.rank;
      g.removeNode(v);
    }
  });
}

function translateGraph(g) {
  var minX = Number.POSITIVE_INFINITY;
  var maxX = 0;
  var minY = Number.POSITIVE_INFINITY;
  var maxY = 0;
  var graphLabel = g.graph();
  var marginX = graphLabel.marginx || 0;
  var marginY = graphLabel.marginy || 0;

  function getExtremes(attrs) {
    var x = attrs.x;
    var y = attrs.y;
    var w = attrs.width;
    var h = attrs.height;
    minX = Math.min(minX, x - w / 2);
    maxX = Math.max(maxX, x + w / 2);
    minY = Math.min(minY, y - h / 2);
    maxY = Math.max(maxY, y + h / 2);
  }

  _.forEach(g.nodes(), function(v) { getExtremes(g.node(v)); });
  _.forEach(g.edges(), function(e) {
    var edge = g.edge(e);
    if (_.has(edge, "x")) {
      getExtremes(edge);
    }
  });

  minX -= marginX;
  minY -= marginY;

  _.forEach(g.nodes(), function(v) {
    var node = g.node(v);
    node.x -= minX;
    node.y -= minY;
  });

  _.forEach(g.edges(), function(e) {
    var edge = g.edge(e);
    _.forEach(edge.points, function(p) {
      p.x -= minX;
      p.y -= minY;
    });
    if (_.has(edge, "x")) { edge.x -= minX; }
    if (_.has(edge, "y")) { edge.y -= minY; }
  });

  graphLabel.width = maxX - minX + marginX;
  graphLabel.height = maxY - minY + marginY;
}

function assignNodeIntersects(g) {
  _.forEach(g.edges(), function(e) {
    var edge = g.edge(e);
    var nodeV = g.node(e.v);
    var nodeW = g.node(e.w);
    var p1, p2;
    if (!edge.points) {
      edge.points = [];
      p1 = nodeW;
      p2 = nodeV;
    } else {
      p1 = edge.points[0];
      p2 = edge.points[edge.points.length - 1];
    }
    edge.points.unshift(util.intersectRect(nodeV, p1));
    edge.points.push(util.intersectRect(nodeW, p2));
  });
}

function fixupEdgeLabelCoords(g) {
  _.forEach(g.edges(), function(e) {
    var edge = g.edge(e);
    if (_.has(edge, "x")) {
      if (edge.labelpos === "l" || edge.labelpos === "r") {
        edge.width -= edge.labeloffset;
      }
      switch (edge.labelpos) {
      case "l": edge.x -= edge.width / 2 + edge.labeloffset; break;
      case "r": edge.x += edge.width / 2 + edge.labeloffset; break;
      }
    }
  });
}

function reversePointsForReversedEdges(g) {
  _.forEach(g.edges(), function(e) {
    var edge = g.edge(e);
    if (edge.reversed) {
      edge.points.reverse();
    }
  });
}

function removeBorderNodes(g) {
  _.forEach(g.nodes(), function(v) {
    if (g.children(v).length) {
      var node = g.node(v);
      var t = g.node(node.borderTop);
      var b = g.node(node.borderBottom);
      var l = g.node(_.last(node.borderLeft));
      var r = g.node(_.last(node.borderRight));

      node.width = Math.abs(r.x - l.x);
      node.height = Math.abs(b.y - t.y);
      node.x = l.x + node.width / 2;
      node.y = t.y + node.height / 2;
    }
  });

  _.forEach(g.nodes(), function(v) {
    if (g.node(v).dummy === "border") {
      g.removeNode(v);
    }
  });
}

function removeSelfEdges(g) {
  _.forEach(g.edges(), function(e) {
    if (e.v === e.w) {
      var node = g.node(e.v);
      if (!node.selfEdges) {
        node.selfEdges = [];
      }
      node.selfEdges.push({ e: e, label: g.edge(e) });
      g.removeEdge(e);
    }
  });
}

function insertSelfEdges(g) {
  var layers = util.buildLayerMatrix(g);
  _.forEach(layers, function(layer) {
    var orderShift = 0;
    _.forEach(layer, function(v, i) {
      var node = g.node(v);
      node.order = i + orderShift;
      _.forEach(node.selfEdges, function(selfEdge) {
        util.addDummyNode(g, "selfedge", {
          width: selfEdge.label.width,
          height: selfEdge.label.height,
          rank: node.rank,
          order: i + (++orderShift),
          e: selfEdge.e,
          label: selfEdge.label
        }, "_se");
      });
      delete node.selfEdges;
    });
  });
}

function positionSelfEdges(g) {
  _.forEach(g.nodes(), function(v) {
    var node = g.node(v);
    if (node.dummy === "selfedge") {
      var selfNode = g.node(node.e.v);
      var x = selfNode.x + selfNode.width / 2;
      var y = selfNode.y;
      var dx = node.x - x;
      var dy = selfNode.height / 2;
      g.setEdge(node.e, node.label);
      g.removeNode(v);
      node.label.points = [
        { x: x + 2 * dx / 3, y: y - dy },
        { x: x + 5 * dx / 6, y: y - dy },
        { x: x +     dx    , y: y },
        { x: x + 5 * dx / 6, y: y + dy },
        { x: x + 2 * dx / 3, y: y + dy }
      ];
      node.label.x = node.x;
      node.label.y = node.y;
    }
  });
}

function selectNumberAttrs(obj, attrs) {
  return _.mapValues(_.pick(obj, attrs), Number);
}

function canonicalize(attrs) {
  var newAttrs = {};
  _.forEach(attrs, function(v, k) {
    newAttrs[k.toLowerCase()] = v;
  });
  return newAttrs;
}


/***/ }),

/***/ "./node_modules/dagre/lib/lodash.js":
/*!******************************************!*\
  !*** ./node_modules/dagre/lib/lodash.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/* global window */

var lodash;

if (true) {
  try {
    lodash = {
      cloneDeep: __webpack_require__(/*! lodash/cloneDeep */ "./node_modules/lodash/cloneDeep.js"),
      constant: __webpack_require__(/*! lodash/constant */ "./node_modules/lodash/constant.js"),
      defaults: __webpack_require__(/*! lodash/defaults */ "./node_modules/lodash/defaults.js"),
      each: __webpack_require__(/*! lodash/each */ "./node_modules/lodash/each.js"),
      filter: __webpack_require__(/*! lodash/filter */ "./node_modules/lodash/filter.js"),
      find: __webpack_require__(/*! lodash/find */ "./node_modules/lodash/find.js"),
      flatten: __webpack_require__(/*! lodash/flatten */ "./node_modules/lodash/flatten.js"),
      forEach: __webpack_require__(/*! lodash/forEach */ "./node_modules/lodash/forEach.js"),
      forIn: __webpack_require__(/*! lodash/forIn */ "./node_modules/lodash/forIn.js"),
      has:  __webpack_require__(/*! lodash/has */ "./node_modules/lodash/has.js"),
      isUndefined: __webpack_require__(/*! lodash/isUndefined */ "./node_modules/lodash/isUndefined.js"),
      last: __webpack_require__(/*! lodash/last */ "./node_modules/lodash/last.js"),
      map: __webpack_require__(/*! lodash/map */ "./node_modules/lodash/map.js"),
      mapValues: __webpack_require__(/*! lodash/mapValues */ "./node_modules/lodash/mapValues.js"),
      max: __webpack_require__(/*! lodash/max */ "./node_modules/lodash/max.js"),
      merge: __webpack_require__(/*! lodash/merge */ "./node_modules/lodash/merge.js"),
      min: __webpack_require__(/*! lodash/min */ "./node_modules/lodash/min.js"),
      minBy: __webpack_require__(/*! lodash/minBy */ "./node_modules/lodash/minBy.js"),
      now: __webpack_require__(/*! lodash/now */ "./node_modules/lodash/now.js"),
      pick: __webpack_require__(/*! lodash/pick */ "./node_modules/lodash/pick.js"),
      range: __webpack_require__(/*! lodash/range */ "./node_modules/lodash/range.js"),
      reduce: __webpack_require__(/*! lodash/reduce */ "./node_modules/lodash/reduce.js"),
      sortBy: __webpack_require__(/*! lodash/sortBy */ "./node_modules/lodash/sortBy.js"),
      uniqueId: __webpack_require__(/*! lodash/uniqueId */ "./node_modules/lodash/uniqueId.js"),
      values: __webpack_require__(/*! lodash/values */ "./node_modules/lodash/values.js"),
      zipObject: __webpack_require__(/*! lodash/zipObject */ "./node_modules/lodash/zipObject.js"),
    };
  } catch (e) {
    // continue regardless of error
  }
}

if (!lodash) {
  lodash = window._;
}

module.exports = lodash;


/***/ }),

/***/ "./node_modules/dagre/lib/nesting-graph.js":
/*!*************************************************!*\
  !*** ./node_modules/dagre/lib/nesting-graph.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var _ = __webpack_require__(/*! ./lodash */ "./node_modules/dagre/lib/lodash.js");
var util = __webpack_require__(/*! ./util */ "./node_modules/dagre/lib/util.js");

module.exports = {
  run: run,
  cleanup: cleanup
};

/*
 * A nesting graph creates dummy nodes for the tops and bottoms of subgraphs,
 * adds appropriate edges to ensure that all cluster nodes are placed between
 * these boundries, and ensures that the graph is connected.
 *
 * In addition we ensure, through the use of the minlen property, that nodes
 * and subgraph border nodes to not end up on the same rank.
 *
 * Preconditions:
 *
 *    1. Input graph is a DAG
 *    2. Nodes in the input graph has a minlen attribute
 *
 * Postconditions:
 *
 *    1. Input graph is connected.
 *    2. Dummy nodes are added for the tops and bottoms of subgraphs.
 *    3. The minlen attribute for nodes is adjusted to ensure nodes do not
 *       get placed on the same rank as subgraph border nodes.
 *
 * The nesting graph idea comes from Sander, "Layout of Compound Directed
 * Graphs."
 */
function run(g) {
  var root = util.addDummyNode(g, "root", {}, "_root");
  var depths = treeDepths(g);
  var height = _.max(_.values(depths)) - 1; // Note: depths is an Object not an array
  var nodeSep = 2 * height + 1;

  g.graph().nestingRoot = root;

  // Multiply minlen by nodeSep to align nodes on non-border ranks.
  _.forEach(g.edges(), function(e) { g.edge(e).minlen *= nodeSep; });

  // Calculate a weight that is sufficient to keep subgraphs vertically compact
  var weight = sumWeights(g) + 1;

  // Create border nodes and link them up
  _.forEach(g.children(), function(child) {
    dfs(g, root, nodeSep, weight, height, depths, child);
  });

  // Save the multiplier for node layers for later removal of empty border
  // layers.
  g.graph().nodeRankFactor = nodeSep;
}

function dfs(g, root, nodeSep, weight, height, depths, v) {
  var children = g.children(v);
  if (!children.length) {
    if (v !== root) {
      g.setEdge(root, v, { weight: 0, minlen: nodeSep });
    }
    return;
  }

  var top = util.addBorderNode(g, "_bt");
  var bottom = util.addBorderNode(g, "_bb");
  var label = g.node(v);

  g.setParent(top, v);
  label.borderTop = top;
  g.setParent(bottom, v);
  label.borderBottom = bottom;

  _.forEach(children, function(child) {
    dfs(g, root, nodeSep, weight, height, depths, child);

    var childNode = g.node(child);
    var childTop = childNode.borderTop ? childNode.borderTop : child;
    var childBottom = childNode.borderBottom ? childNode.borderBottom : child;
    var thisWeight = childNode.borderTop ? weight : 2 * weight;
    var minlen = childTop !== childBottom ? 1 : height - depths[v] + 1;

    g.setEdge(top, childTop, {
      weight: thisWeight,
      minlen: minlen,
      nestingEdge: true
    });

    g.setEdge(childBottom, bottom, {
      weight: thisWeight,
      minlen: minlen,
      nestingEdge: true
    });
  });

  if (!g.parent(v)) {
    g.setEdge(root, top, { weight: 0, minlen: height + depths[v] });
  }
}

function treeDepths(g) {
  var depths = {};
  function dfs(v, depth) {
    var children = g.children(v);
    if (children && children.length) {
      _.forEach(children, function(child) {
        dfs(child, depth + 1);
      });
    }
    depths[v] = depth;
  }
  _.forEach(g.children(), function(v) { dfs(v, 1); });
  return depths;
}

function sumWeights(g) {
  return _.reduce(g.edges(), function(acc, e) {
    return acc + g.edge(e).weight;
  }, 0);
}

function cleanup(g) {
  var graphLabel = g.graph();
  g.removeNode(graphLabel.nestingRoot);
  delete graphLabel.nestingRoot;
  _.forEach(g.edges(), function(e) {
    var edge = g.edge(e);
    if (edge.nestingEdge) {
      g.removeEdge(e);
    }
  });
}


/***/ }),

/***/ "./node_modules/dagre/lib/normalize.js":
/*!*********************************************!*\
  !*** ./node_modules/dagre/lib/normalize.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var _ = __webpack_require__(/*! ./lodash */ "./node_modules/dagre/lib/lodash.js");
var util = __webpack_require__(/*! ./util */ "./node_modules/dagre/lib/util.js");

module.exports = {
  run: run,
  undo: undo
};

/*
 * Breaks any long edges in the graph into short segments that span 1 layer
 * each. This operation is undoable with the denormalize function.
 *
 * Pre-conditions:
 *
 *    1. The input graph is a DAG.
 *    2. Each node in the graph has a "rank" property.
 *
 * Post-condition:
 *
 *    1. All edges in the graph have a length of 1.
 *    2. Dummy nodes are added where edges have been split into segments.
 *    3. The graph is augmented with a "dummyChains" attribute which contains
 *       the first dummy in each chain of dummy nodes produced.
 */
function run(g) {
  g.graph().dummyChains = [];
  _.forEach(g.edges(), function(edge) { normalizeEdge(g, edge); });
}

function normalizeEdge(g, e) {
  var v = e.v;
  var vRank = g.node(v).rank;
  var w = e.w;
  var wRank = g.node(w).rank;
  var name = e.name;
  var edgeLabel = g.edge(e);
  var labelRank = edgeLabel.labelRank;

  if (wRank === vRank + 1) return;

  g.removeEdge(e);

  var dummy, attrs, i;
  for (i = 0, ++vRank; vRank < wRank; ++i, ++vRank) {
    edgeLabel.points = [];
    attrs = {
      width: 0, height: 0,
      edgeLabel: edgeLabel, edgeObj: e,
      rank: vRank
    };
    dummy = util.addDummyNode(g, "edge", attrs, "_d");
    if (vRank === labelRank) {
      attrs.width = edgeLabel.width;
      attrs.height = edgeLabel.height;
      attrs.dummy = "edge-label";
      attrs.labelpos = edgeLabel.labelpos;
    }
    g.setEdge(v, dummy, { weight: edgeLabel.weight }, name);
    if (i === 0) {
      g.graph().dummyChains.push(dummy);
    }
    v = dummy;
  }

  g.setEdge(v, w, { weight: edgeLabel.weight }, name);
}

function undo(g) {
  _.forEach(g.graph().dummyChains, function(v) {
    var node = g.node(v);
    var origLabel = node.edgeLabel;
    var w;
    g.setEdge(node.edgeObj, origLabel);
    while (node.dummy) {
      w = g.successors(v)[0];
      g.removeNode(v);
      origLabel.points.push({ x: node.x, y: node.y });
      if (node.dummy === "edge-label") {
        origLabel.x = node.x;
        origLabel.y = node.y;
        origLabel.width = node.width;
        origLabel.height = node.height;
      }
      v = w;
      node = g.node(v);
    }
  });
}


/***/ }),

/***/ "./node_modules/dagre/lib/order/add-subgraph-constraints.js":
/*!******************************************************************!*\
  !*** ./node_modules/dagre/lib/order/add-subgraph-constraints.js ***!
  \******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var _ = __webpack_require__(/*! ../lodash */ "./node_modules/dagre/lib/lodash.js");

module.exports = addSubgraphConstraints;

function addSubgraphConstraints(g, cg, vs) {
  var prev = {},
    rootPrev;

  _.forEach(vs, function(v) {
    var child = g.parent(v),
      parent,
      prevChild;
    while (child) {
      parent = g.parent(child);
      if (parent) {
        prevChild = prev[parent];
        prev[parent] = child;
      } else {
        prevChild = rootPrev;
        rootPrev = child;
      }
      if (prevChild && prevChild !== child) {
        cg.setEdge(prevChild, child);
        return;
      }
      child = parent;
    }
  });

  /*
  function dfs(v) {
    var children = v ? g.children(v) : g.children();
    if (children.length) {
      var min = Number.POSITIVE_INFINITY,
          subgraphs = [];
      _.each(children, function(child) {
        var childMin = dfs(child);
        if (g.children(child).length) {
          subgraphs.push({ v: child, order: childMin });
        }
        min = Math.min(min, childMin);
      });
      _.reduce(_.sortBy(subgraphs, "order"), function(prev, curr) {
        cg.setEdge(prev.v, curr.v);
        return curr;
      });
      return min;
    }
    return g.node(v).order;
  }
  dfs(undefined);
  */
}


/***/ }),

/***/ "./node_modules/dagre/lib/order/barycenter.js":
/*!****************************************************!*\
  !*** ./node_modules/dagre/lib/order/barycenter.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var _ = __webpack_require__(/*! ../lodash */ "./node_modules/dagre/lib/lodash.js");

module.exports = barycenter;

function barycenter(g, movable) {
  return _.map(movable, function(v) {
    var inV = g.inEdges(v);
    if (!inV.length) {
      return { v: v };
    } else {
      var result = _.reduce(inV, function(acc, e) {
        var edge = g.edge(e),
          nodeU = g.node(e.v);
        return {
          sum: acc.sum + (edge.weight * nodeU.order),
          weight: acc.weight + edge.weight
        };
      }, { sum: 0, weight: 0 });

      return {
        v: v,
        barycenter: result.sum / result.weight,
        weight: result.weight
      };
    }
  });
}



/***/ }),

/***/ "./node_modules/dagre/lib/order/build-layer-graph.js":
/*!***********************************************************!*\
  !*** ./node_modules/dagre/lib/order/build-layer-graph.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var _ = __webpack_require__(/*! ../lodash */ "./node_modules/dagre/lib/lodash.js");
var Graph = __webpack_require__(/*! ../graphlib */ "./node_modules/dagre/lib/graphlib.js").Graph;

module.exports = buildLayerGraph;

/*
 * Constructs a graph that can be used to sort a layer of nodes. The graph will
 * contain all base and subgraph nodes from the request layer in their original
 * hierarchy and any edges that are incident on these nodes and are of the type
 * requested by the "relationship" parameter.
 *
 * Nodes from the requested rank that do not have parents are assigned a root
 * node in the output graph, which is set in the root graph attribute. This
 * makes it easy to walk the hierarchy of movable nodes during ordering.
 *
 * Pre-conditions:
 *
 *    1. Input graph is a DAG
 *    2. Base nodes in the input graph have a rank attribute
 *    3. Subgraph nodes in the input graph has minRank and maxRank attributes
 *    4. Edges have an assigned weight
 *
 * Post-conditions:
 *
 *    1. Output graph has all nodes in the movable rank with preserved
 *       hierarchy.
 *    2. Root nodes in the movable layer are made children of the node
 *       indicated by the root attribute of the graph.
 *    3. Non-movable nodes incident on movable nodes, selected by the
 *       relationship parameter, are included in the graph (without hierarchy).
 *    4. Edges incident on movable nodes, selected by the relationship
 *       parameter, are added to the output graph.
 *    5. The weights for copied edges are aggregated as need, since the output
 *       graph is not a multi-graph.
 */
function buildLayerGraph(g, rank, relationship) {
  var root = createRootNode(g),
    result = new Graph({ compound: true }).setGraph({ root: root })
      .setDefaultNodeLabel(function(v) { return g.node(v); });

  _.forEach(g.nodes(), function(v) {
    var node = g.node(v),
      parent = g.parent(v);

    if (node.rank === rank || node.minRank <= rank && rank <= node.maxRank) {
      result.setNode(v);
      result.setParent(v, parent || root);

      // This assumes we have only short edges!
      _.forEach(g[relationship](v), function(e) {
        var u = e.v === v ? e.w : e.v,
          edge = result.edge(u, v),
          weight = !_.isUndefined(edge) ? edge.weight : 0;
        result.setEdge(u, v, { weight: g.edge(e).weight + weight });
      });

      if (_.has(node, "minRank")) {
        result.setNode(v, {
          borderLeft: node.borderLeft[rank],
          borderRight: node.borderRight[rank]
        });
      }
    }
  });

  return result;
}

function createRootNode(g) {
  var v;
  while (g.hasNode((v = _.uniqueId("_root"))));
  return v;
}


/***/ }),

/***/ "./node_modules/dagre/lib/order/cross-count.js":
/*!*****************************************************!*\
  !*** ./node_modules/dagre/lib/order/cross-count.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var _ = __webpack_require__(/*! ../lodash */ "./node_modules/dagre/lib/lodash.js");

module.exports = crossCount;

/*
 * A function that takes a layering (an array of layers, each with an array of
 * ordererd nodes) and a graph and returns a weighted crossing count.
 *
 * Pre-conditions:
 *
 *    1. Input graph must be simple (not a multigraph), directed, and include
 *       only simple edges.
 *    2. Edges in the input graph must have assigned weights.
 *
 * Post-conditions:
 *
 *    1. The graph and layering matrix are left unchanged.
 *
 * This algorithm is derived from Barth, et al., "Bilayer Cross Counting."
 */
function crossCount(g, layering) {
  var cc = 0;
  for (var i = 1; i < layering.length; ++i) {
    cc += twoLayerCrossCount(g, layering[i-1], layering[i]);
  }
  return cc;
}

function twoLayerCrossCount(g, northLayer, southLayer) {
  // Sort all of the edges between the north and south layers by their position
  // in the north layer and then the south. Map these edges to the position of
  // their head in the south layer.
  var southPos = _.zipObject(southLayer,
    _.map(southLayer, function (v, i) { return i; }));
  var southEntries = _.flatten(_.map(northLayer, function(v) {
    return _.sortBy(_.map(g.outEdges(v), function(e) {
      return { pos: southPos[e.w], weight: g.edge(e).weight };
    }), "pos");
  }), true);

  // Build the accumulator tree
  var firstIndex = 1;
  while (firstIndex < southLayer.length) firstIndex <<= 1;
  var treeSize = 2 * firstIndex - 1;
  firstIndex -= 1;
  var tree = _.map(new Array(treeSize), function() { return 0; });

  // Calculate the weighted crossings
  var cc = 0;
  _.forEach(southEntries.forEach(function(entry) {
    var index = entry.pos + firstIndex;
    tree[index] += entry.weight;
    var weightSum = 0;
    while (index > 0) {
      if (index % 2) {
        weightSum += tree[index + 1];
      }
      index = (index - 1) >> 1;
      tree[index] += entry.weight;
    }
    cc += entry.weight * weightSum;
  }));

  return cc;
}


/***/ }),

/***/ "./node_modules/dagre/lib/order/index.js":
/*!***********************************************!*\
  !*** ./node_modules/dagre/lib/order/index.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var _ = __webpack_require__(/*! ../lodash */ "./node_modules/dagre/lib/lodash.js");
var initOrder = __webpack_require__(/*! ./init-order */ "./node_modules/dagre/lib/order/init-order.js");
var crossCount = __webpack_require__(/*! ./cross-count */ "./node_modules/dagre/lib/order/cross-count.js");
var sortSubgraph = __webpack_require__(/*! ./sort-subgraph */ "./node_modules/dagre/lib/order/sort-subgraph.js");
var buildLayerGraph = __webpack_require__(/*! ./build-layer-graph */ "./node_modules/dagre/lib/order/build-layer-graph.js");
var addSubgraphConstraints = __webpack_require__(/*! ./add-subgraph-constraints */ "./node_modules/dagre/lib/order/add-subgraph-constraints.js");
var Graph = __webpack_require__(/*! ../graphlib */ "./node_modules/dagre/lib/graphlib.js").Graph;
var util = __webpack_require__(/*! ../util */ "./node_modules/dagre/lib/util.js");

module.exports = order;

/*
 * Applies heuristics to minimize edge crossings in the graph and sets the best
 * order solution as an order attribute on each node.
 *
 * Pre-conditions:
 *
 *    1. Graph must be DAG
 *    2. Graph nodes must be objects with a "rank" attribute
 *    3. Graph edges must have the "weight" attribute
 *
 * Post-conditions:
 *
 *    1. Graph nodes will have an "order" attribute based on the results of the
 *       algorithm.
 */
function order(g) {
  var maxRank = util.maxRank(g),
    downLayerGraphs = buildLayerGraphs(g, _.range(1, maxRank + 1), "inEdges"),
    upLayerGraphs = buildLayerGraphs(g, _.range(maxRank - 1, -1, -1), "outEdges");

  var layering = initOrder(g);
  assignOrder(g, layering);

  var bestCC = Number.POSITIVE_INFINITY,
    best;

  for (var i = 0, lastBest = 0; lastBest < 4; ++i, ++lastBest) {
    sweepLayerGraphs(i % 2 ? downLayerGraphs : upLayerGraphs, i % 4 >= 2);

    layering = util.buildLayerMatrix(g);
    var cc = crossCount(g, layering);
    if (cc < bestCC) {
      lastBest = 0;
      best = _.cloneDeep(layering);
      bestCC = cc;
    }
  }

  assignOrder(g, best);
}

function buildLayerGraphs(g, ranks, relationship) {
  return _.map(ranks, function(rank) {
    return buildLayerGraph(g, rank, relationship);
  });
}

function sweepLayerGraphs(layerGraphs, biasRight) {
  var cg = new Graph();
  _.forEach(layerGraphs, function(lg) {
    var root = lg.graph().root;
    var sorted = sortSubgraph(lg, root, cg, biasRight);
    _.forEach(sorted.vs, function(v, i) {
      lg.node(v).order = i;
    });
    addSubgraphConstraints(lg, cg, sorted.vs);
  });
}

function assignOrder(g, layering) {
  _.forEach(layering, function(layer) {
    _.forEach(layer, function(v, i) {
      g.node(v).order = i;
    });
  });
}


/***/ }),

/***/ "./node_modules/dagre/lib/order/init-order.js":
/*!****************************************************!*\
  !*** ./node_modules/dagre/lib/order/init-order.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var _ = __webpack_require__(/*! ../lodash */ "./node_modules/dagre/lib/lodash.js");

module.exports = initOrder;

/*
 * Assigns an initial order value for each node by performing a DFS search
 * starting from nodes in the first rank. Nodes are assigned an order in their
 * rank as they are first visited.
 *
 * This approach comes from Gansner, et al., "A Technique for Drawing Directed
 * Graphs."
 *
 * Returns a layering matrix with an array per layer and each layer sorted by
 * the order of its nodes.
 */
function initOrder(g) {
  var visited = {};
  var simpleNodes = _.filter(g.nodes(), function(v) {
    return !g.children(v).length;
  });
  var maxRank = _.max(_.map(simpleNodes, function(v) { return g.node(v).rank; }));
  var layers = _.map(_.range(maxRank + 1), function() { return []; });

  function dfs(v) {
    if (_.has(visited, v)) return;
    visited[v] = true;
    var node = g.node(v);
    layers[node.rank].push(v);
    _.forEach(g.successors(v), dfs);
  }

  var orderedVs = _.sortBy(simpleNodes, function(v) { return g.node(v).rank; });
  _.forEach(orderedVs, dfs);

  return layers;
}


/***/ }),

/***/ "./node_modules/dagre/lib/order/resolve-conflicts.js":
/*!***********************************************************!*\
  !*** ./node_modules/dagre/lib/order/resolve-conflicts.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var _ = __webpack_require__(/*! ../lodash */ "./node_modules/dagre/lib/lodash.js");

module.exports = resolveConflicts;

/*
 * Given a list of entries of the form {v, barycenter, weight} and a
 * constraint graph this function will resolve any conflicts between the
 * constraint graph and the barycenters for the entries. If the barycenters for
 * an entry would violate a constraint in the constraint graph then we coalesce
 * the nodes in the conflict into a new node that respects the contraint and
 * aggregates barycenter and weight information.
 *
 * This implementation is based on the description in Forster, "A Fast and
 * Simple Hueristic for Constrained Two-Level Crossing Reduction," thought it
 * differs in some specific details.
 *
 * Pre-conditions:
 *
 *    1. Each entry has the form {v, barycenter, weight}, or if the node has
 *       no barycenter, then {v}.
 *
 * Returns:
 *
 *    A new list of entries of the form {vs, i, barycenter, weight}. The list
 *    `vs` may either be a singleton or it may be an aggregation of nodes
 *    ordered such that they do not violate constraints from the constraint
 *    graph. The property `i` is the lowest original index of any of the
 *    elements in `vs`.
 */
function resolveConflicts(entries, cg) {
  var mappedEntries = {};
  _.forEach(entries, function(entry, i) {
    var tmp = mappedEntries[entry.v] = {
      indegree: 0,
      "in": [],
      out: [],
      vs: [entry.v],
      i: i
    };
    if (!_.isUndefined(entry.barycenter)) {
      tmp.barycenter = entry.barycenter;
      tmp.weight = entry.weight;
    }
  });

  _.forEach(cg.edges(), function(e) {
    var entryV = mappedEntries[e.v];
    var entryW = mappedEntries[e.w];
    if (!_.isUndefined(entryV) && !_.isUndefined(entryW)) {
      entryW.indegree++;
      entryV.out.push(mappedEntries[e.w]);
    }
  });

  var sourceSet = _.filter(mappedEntries, function(entry) {
    return !entry.indegree;
  });

  return doResolveConflicts(sourceSet);
}

function doResolveConflicts(sourceSet) {
  var entries = [];

  function handleIn(vEntry) {
    return function(uEntry) {
      if (uEntry.merged) {
        return;
      }
      if (_.isUndefined(uEntry.barycenter) ||
          _.isUndefined(vEntry.barycenter) ||
          uEntry.barycenter >= vEntry.barycenter) {
        mergeEntries(vEntry, uEntry);
      }
    };
  }

  function handleOut(vEntry) {
    return function(wEntry) {
      wEntry["in"].push(vEntry);
      if (--wEntry.indegree === 0) {
        sourceSet.push(wEntry);
      }
    };
  }

  while (sourceSet.length) {
    var entry = sourceSet.pop();
    entries.push(entry);
    _.forEach(entry["in"].reverse(), handleIn(entry));
    _.forEach(entry.out, handleOut(entry));
  }

  return _.map(_.filter(entries, function(entry) { return !entry.merged; }),
    function(entry) {
      return _.pick(entry, ["vs", "i", "barycenter", "weight"]);
    });

}

function mergeEntries(target, source) {
  var sum = 0;
  var weight = 0;

  if (target.weight) {
    sum += target.barycenter * target.weight;
    weight += target.weight;
  }

  if (source.weight) {
    sum += source.barycenter * source.weight;
    weight += source.weight;
  }

  target.vs = source.vs.concat(target.vs);
  target.barycenter = sum / weight;
  target.weight = weight;
  target.i = Math.min(source.i, target.i);
  source.merged = true;
}


/***/ }),

/***/ "./node_modules/dagre/lib/order/sort-subgraph.js":
/*!*******************************************************!*\
  !*** ./node_modules/dagre/lib/order/sort-subgraph.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var _ = __webpack_require__(/*! ../lodash */ "./node_modules/dagre/lib/lodash.js");
var barycenter = __webpack_require__(/*! ./barycenter */ "./node_modules/dagre/lib/order/barycenter.js");
var resolveConflicts = __webpack_require__(/*! ./resolve-conflicts */ "./node_modules/dagre/lib/order/resolve-conflicts.js");
var sort = __webpack_require__(/*! ./sort */ "./node_modules/dagre/lib/order/sort.js");

module.exports = sortSubgraph;

function sortSubgraph(g, v, cg, biasRight) {
  var movable = g.children(v);
  var node = g.node(v);
  var bl = node ? node.borderLeft : undefined;
  var br = node ? node.borderRight: undefined;
  var subgraphs = {};

  if (bl) {
    movable = _.filter(movable, function(w) {
      return w !== bl && w !== br;
    });
  }

  var barycenters = barycenter(g, movable);
  _.forEach(barycenters, function(entry) {
    if (g.children(entry.v).length) {
      var subgraphResult = sortSubgraph(g, entry.v, cg, biasRight);
      subgraphs[entry.v] = subgraphResult;
      if (_.has(subgraphResult, "barycenter")) {
        mergeBarycenters(entry, subgraphResult);
      }
    }
  });

  var entries = resolveConflicts(barycenters, cg);
  expandSubgraphs(entries, subgraphs);

  var result = sort(entries, biasRight);

  if (bl) {
    result.vs = _.flatten([bl, result.vs, br], true);
    if (g.predecessors(bl).length) {
      var blPred = g.node(g.predecessors(bl)[0]),
        brPred = g.node(g.predecessors(br)[0]);
      if (!_.has(result, "barycenter")) {
        result.barycenter = 0;
        result.weight = 0;
      }
      result.barycenter = (result.barycenter * result.weight +
                           blPred.order + brPred.order) / (result.weight + 2);
      result.weight += 2;
    }
  }

  return result;
}

function expandSubgraphs(entries, subgraphs) {
  _.forEach(entries, function(entry) {
    entry.vs = _.flatten(entry.vs.map(function(v) {
      if (subgraphs[v]) {
        return subgraphs[v].vs;
      }
      return v;
    }), true);
  });
}

function mergeBarycenters(target, other) {
  if (!_.isUndefined(target.barycenter)) {
    target.barycenter = (target.barycenter * target.weight +
                         other.barycenter * other.weight) /
                        (target.weight + other.weight);
    target.weight += other.weight;
  } else {
    target.barycenter = other.barycenter;
    target.weight = other.weight;
  }
}


/***/ }),

/***/ "./node_modules/dagre/lib/order/sort.js":
/*!**********************************************!*\
  !*** ./node_modules/dagre/lib/order/sort.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var _ = __webpack_require__(/*! ../lodash */ "./node_modules/dagre/lib/lodash.js");
var util = __webpack_require__(/*! ../util */ "./node_modules/dagre/lib/util.js");

module.exports = sort;

function sort(entries, biasRight) {
  var parts = util.partition(entries, function(entry) {
    return _.has(entry, "barycenter");
  });
  var sortable = parts.lhs,
    unsortable = _.sortBy(parts.rhs, function(entry) { return -entry.i; }),
    vs = [],
    sum = 0,
    weight = 0,
    vsIndex = 0;

  sortable.sort(compareWithBias(!!biasRight));

  vsIndex = consumeUnsortable(vs, unsortable, vsIndex);

  _.forEach(sortable, function (entry) {
    vsIndex += entry.vs.length;
    vs.push(entry.vs);
    sum += entry.barycenter * entry.weight;
    weight += entry.weight;
    vsIndex = consumeUnsortable(vs, unsortable, vsIndex);
  });

  var result = { vs: _.flatten(vs, true) };
  if (weight) {
    result.barycenter = sum / weight;
    result.weight = weight;
  }
  return result;
}

function consumeUnsortable(vs, unsortable, index) {
  var last;
  while (unsortable.length && (last = _.last(unsortable)).i <= index) {
    unsortable.pop();
    vs.push(last.vs);
    index++;
  }
  return index;
}

function compareWithBias(bias) {
  return function(entryV, entryW) {
    if (entryV.barycenter < entryW.barycenter) {
      return -1;
    } else if (entryV.barycenter > entryW.barycenter) {
      return 1;
    }

    return !bias ? entryV.i - entryW.i : entryW.i - entryV.i;
  };
}


/***/ }),

/***/ "./node_modules/dagre/lib/parent-dummy-chains.js":
/*!*******************************************************!*\
  !*** ./node_modules/dagre/lib/parent-dummy-chains.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var _ = __webpack_require__(/*! ./lodash */ "./node_modules/dagre/lib/lodash.js");

module.exports = parentDummyChains;

function parentDummyChains(g) {
  var postorderNums = postorder(g);

  _.forEach(g.graph().dummyChains, function(v) {
    var node = g.node(v);
    var edgeObj = node.edgeObj;
    var pathData = findPath(g, postorderNums, edgeObj.v, edgeObj.w);
    var path = pathData.path;
    var lca = pathData.lca;
    var pathIdx = 0;
    var pathV = path[pathIdx];
    var ascending = true;

    while (v !== edgeObj.w) {
      node = g.node(v);

      if (ascending) {
        while ((pathV = path[pathIdx]) !== lca &&
               g.node(pathV).maxRank < node.rank) {
          pathIdx++;
        }

        if (pathV === lca) {
          ascending = false;
        }
      }

      if (!ascending) {
        while (pathIdx < path.length - 1 &&
               g.node(pathV = path[pathIdx + 1]).minRank <= node.rank) {
          pathIdx++;
        }
        pathV = path[pathIdx];
      }

      g.setParent(v, pathV);
      v = g.successors(v)[0];
    }
  });
}

// Find a path from v to w through the lowest common ancestor (LCA). Return the
// full path and the LCA.
function findPath(g, postorderNums, v, w) {
  var vPath = [];
  var wPath = [];
  var low = Math.min(postorderNums[v].low, postorderNums[w].low);
  var lim = Math.max(postorderNums[v].lim, postorderNums[w].lim);
  var parent;
  var lca;

  // Traverse up from v to find the LCA
  parent = v;
  do {
    parent = g.parent(parent);
    vPath.push(parent);
  } while (parent &&
           (postorderNums[parent].low > low || lim > postorderNums[parent].lim));
  lca = parent;

  // Traverse from w to LCA
  parent = w;
  while ((parent = g.parent(parent)) !== lca) {
    wPath.push(parent);
  }

  return { path: vPath.concat(wPath.reverse()), lca: lca };
}

function postorder(g) {
  var result = {};
  var lim = 0;

  function dfs(v) {
    var low = lim;
    _.forEach(g.children(v), dfs);
    result[v] = { low: low, lim: lim++ };
  }
  _.forEach(g.children(), dfs);

  return result;
}


/***/ }),

/***/ "./node_modules/dagre/lib/position/bk.js":
/*!***********************************************!*\
  !*** ./node_modules/dagre/lib/position/bk.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var _ = __webpack_require__(/*! ../lodash */ "./node_modules/dagre/lib/lodash.js");
var Graph = __webpack_require__(/*! ../graphlib */ "./node_modules/dagre/lib/graphlib.js").Graph;
var util = __webpack_require__(/*! ../util */ "./node_modules/dagre/lib/util.js");

/*
 * This module provides coordinate assignment based on Brandes and Kpf, "Fast
 * and Simple Horizontal Coordinate Assignment."
 */

module.exports = {
  positionX: positionX,
  findType1Conflicts: findType1Conflicts,
  findType2Conflicts: findType2Conflicts,
  addConflict: addConflict,
  hasConflict: hasConflict,
  verticalAlignment: verticalAlignment,
  horizontalCompaction: horizontalCompaction,
  alignCoordinates: alignCoordinates,
  findSmallestWidthAlignment: findSmallestWidthAlignment,
  balance: balance
};

/*
 * Marks all edges in the graph with a type-1 conflict with the "type1Conflict"
 * property. A type-1 conflict is one where a non-inner segment crosses an
 * inner segment. An inner segment is an edge with both incident nodes marked
 * with the "dummy" property.
 *
 * This algorithm scans layer by layer, starting with the second, for type-1
 * conflicts between the current layer and the previous layer. For each layer
 * it scans the nodes from left to right until it reaches one that is incident
 * on an inner segment. It then scans predecessors to determine if they have
 * edges that cross that inner segment. At the end a final scan is done for all
 * nodes on the current rank to see if they cross the last visited inner
 * segment.
 *
 * This algorithm (safely) assumes that a dummy node will only be incident on a
 * single node in the layers being scanned.
 */
function findType1Conflicts(g, layering) {
  var conflicts = {};

  function visitLayer(prevLayer, layer) {
    var
      // last visited node in the previous layer that is incident on an inner
      // segment.
      k0 = 0,
      // Tracks the last node in this layer scanned for crossings with a type-1
      // segment.
      scanPos = 0,
      prevLayerLength = prevLayer.length,
      lastNode = _.last(layer);

    _.forEach(layer, function(v, i) {
      var w = findOtherInnerSegmentNode(g, v),
        k1 = w ? g.node(w).order : prevLayerLength;

      if (w || v === lastNode) {
        _.forEach(layer.slice(scanPos, i +1), function(scanNode) {
          _.forEach(g.predecessors(scanNode), function(u) {
            var uLabel = g.node(u),
              uPos = uLabel.order;
            if ((uPos < k0 || k1 < uPos) &&
                !(uLabel.dummy && g.node(scanNode).dummy)) {
              addConflict(conflicts, u, scanNode);
            }
          });
        });
        scanPos = i + 1;
        k0 = k1;
      }
    });

    return layer;
  }

  _.reduce(layering, visitLayer);
  return conflicts;
}

function findType2Conflicts(g, layering) {
  var conflicts = {};

  function scan(south, southPos, southEnd, prevNorthBorder, nextNorthBorder) {
    var v;
    _.forEach(_.range(southPos, southEnd), function(i) {
      v = south[i];
      if (g.node(v).dummy) {
        _.forEach(g.predecessors(v), function(u) {
          var uNode = g.node(u);
          if (uNode.dummy &&
              (uNode.order < prevNorthBorder || uNode.order > nextNorthBorder)) {
            addConflict(conflicts, u, v);
          }
        });
      }
    });
  }


  function visitLayer(north, south) {
    var prevNorthPos = -1,
      nextNorthPos,
      southPos = 0;

    _.forEach(south, function(v, southLookahead) {
      if (g.node(v).dummy === "border") {
        var predecessors = g.predecessors(v);
        if (predecessors.length) {
          nextNorthPos = g.node(predecessors[0]).order;
          scan(south, southPos, southLookahead, prevNorthPos, nextNorthPos);
          southPos = southLookahead;
          prevNorthPos = nextNorthPos;
        }
      }
      scan(south, southPos, south.length, nextNorthPos, north.length);
    });

    return south;
  }

  _.reduce(layering, visitLayer);
  return conflicts;
}

function findOtherInnerSegmentNode(g, v) {
  if (g.node(v).dummy) {
    return _.find(g.predecessors(v), function(u) {
      return g.node(u).dummy;
    });
  }
}

function addConflict(conflicts, v, w) {
  if (v > w) {
    var tmp = v;
    v = w;
    w = tmp;
  }

  var conflictsV = conflicts[v];
  if (!conflictsV) {
    conflicts[v] = conflictsV = {};
  }
  conflictsV[w] = true;
}

function hasConflict(conflicts, v, w) {
  if (v > w) {
    var tmp = v;
    v = w;
    w = tmp;
  }
  return _.has(conflicts[v], w);
}

/*
 * Try to align nodes into vertical "blocks" where possible. This algorithm
 * attempts to align a node with one of its median neighbors. If the edge
 * connecting a neighbor is a type-1 conflict then we ignore that possibility.
 * If a previous node has already formed a block with a node after the node
 * we're trying to form a block with, we also ignore that possibility - our
 * blocks would be split in that scenario.
 */
function verticalAlignment(g, layering, conflicts, neighborFn) {
  var root = {},
    align = {},
    pos = {};

  // We cache the position here based on the layering because the graph and
  // layering may be out of sync. The layering matrix is manipulated to
  // generate different extreme alignments.
  _.forEach(layering, function(layer) {
    _.forEach(layer, function(v, order) {
      root[v] = v;
      align[v] = v;
      pos[v] = order;
    });
  });

  _.forEach(layering, function(layer) {
    var prevIdx = -1;
    _.forEach(layer, function(v) {
      var ws = neighborFn(v);
      if (ws.length) {
        ws = _.sortBy(ws, function(w) { return pos[w]; });
        var mp = (ws.length - 1) / 2;
        for (var i = Math.floor(mp), il = Math.ceil(mp); i <= il; ++i) {
          var w = ws[i];
          if (align[v] === v &&
              prevIdx < pos[w] &&
              !hasConflict(conflicts, v, w)) {
            align[w] = v;
            align[v] = root[v] = root[w];
            prevIdx = pos[w];
          }
        }
      }
    });
  });

  return { root: root, align: align };
}

function horizontalCompaction(g, layering, root, align, reverseSep) {
  // This portion of the algorithm differs from BK due to a number of problems.
  // Instead of their algorithm we construct a new block graph and do two
  // sweeps. The first sweep places blocks with the smallest possible
  // coordinates. The second sweep removes unused space by moving blocks to the
  // greatest coordinates without violating separation.
  var xs = {},
    blockG = buildBlockGraph(g, layering, root, reverseSep),
    borderType = reverseSep ? "borderLeft" : "borderRight";

  function iterate(setXsFunc, nextNodesFunc) {
    var stack = blockG.nodes();
    var elem = stack.pop();
    var visited = {};
    while (elem) {
      if (visited[elem]) {
        setXsFunc(elem);
      } else {
        visited[elem] = true;
        stack.push(elem);
        stack = stack.concat(nextNodesFunc(elem));
      }

      elem = stack.pop();
    }
  }

  // First pass, assign smallest coordinates
  function pass1(elem) {
    xs[elem] = blockG.inEdges(elem).reduce(function(acc, e) {
      return Math.max(acc, xs[e.v] + blockG.edge(e));
    }, 0);
  }

  // Second pass, assign greatest coordinates
  function pass2(elem) {
    var min = blockG.outEdges(elem).reduce(function(acc, e) {
      return Math.min(acc, xs[e.w] - blockG.edge(e));
    }, Number.POSITIVE_INFINITY);

    var node = g.node(elem);
    if (min !== Number.POSITIVE_INFINITY && node.borderType !== borderType) {
      xs[elem] = Math.max(xs[elem], min);
    }
  }

  iterate(pass1, blockG.predecessors.bind(blockG));
  iterate(pass2, blockG.successors.bind(blockG));

  // Assign x coordinates to all nodes
  _.forEach(align, function(v) {
    xs[v] = xs[root[v]];
  });

  return xs;
}


function buildBlockGraph(g, layering, root, reverseSep) {
  var blockGraph = new Graph(),
    graphLabel = g.graph(),
    sepFn = sep(graphLabel.nodesep, graphLabel.edgesep, reverseSep);

  _.forEach(layering, function(layer) {
    var u;
    _.forEach(layer, function(v) {
      var vRoot = root[v];
      blockGraph.setNode(vRoot);
      if (u) {
        var uRoot = root[u],
          prevMax = blockGraph.edge(uRoot, vRoot);
        blockGraph.setEdge(uRoot, vRoot, Math.max(sepFn(g, v, u), prevMax || 0));
      }
      u = v;
    });
  });

  return blockGraph;
}

/*
 * Returns the alignment that has the smallest width of the given alignments.
 */
function findSmallestWidthAlignment(g, xss) {
  return _.minBy(_.values(xss), function (xs) {
    var max = Number.NEGATIVE_INFINITY;
    var min = Number.POSITIVE_INFINITY;

    _.forIn(xs, function (x, v) {
      var halfWidth = width(g, v) / 2;

      max = Math.max(x + halfWidth, max);
      min = Math.min(x - halfWidth, min);
    });

    return max - min;
  });
}

/*
 * Align the coordinates of each of the layout alignments such that
 * left-biased alignments have their minimum coordinate at the same point as
 * the minimum coordinate of the smallest width alignment and right-biased
 * alignments have their maximum coordinate at the same point as the maximum
 * coordinate of the smallest width alignment.
 */
function alignCoordinates(xss, alignTo) {
  var alignToVals = _.values(alignTo),
    alignToMin = _.min(alignToVals),
    alignToMax = _.max(alignToVals);

  _.forEach(["u", "d"], function(vert) {
    _.forEach(["l", "r"], function(horiz) {
      var alignment = vert + horiz,
        xs = xss[alignment],
        delta;
      if (xs === alignTo) return;

      var xsVals = _.values(xs);
      delta = horiz === "l" ? alignToMin - _.min(xsVals) : alignToMax - _.max(xsVals);

      if (delta) {
        xss[alignment] = _.mapValues(xs, function(x) { return x + delta; });
      }
    });
  });
}

function balance(xss, align) {
  return _.mapValues(xss.ul, function(ignore, v) {
    if (align) {
      return xss[align.toLowerCase()][v];
    } else {
      var xs = _.sortBy(_.map(xss, v));
      return (xs[1] + xs[2]) / 2;
    }
  });
}

function positionX(g) {
  var layering = util.buildLayerMatrix(g);
  var conflicts = _.merge(
    findType1Conflicts(g, layering),
    findType2Conflicts(g, layering));

  var xss = {};
  var adjustedLayering;
  _.forEach(["u", "d"], function(vert) {
    adjustedLayering = vert === "u" ? layering : _.values(layering).reverse();
    _.forEach(["l", "r"], function(horiz) {
      if (horiz === "r") {
        adjustedLayering = _.map(adjustedLayering, function(inner) {
          return _.values(inner).reverse();
        });
      }

      var neighborFn = (vert === "u" ? g.predecessors : g.successors).bind(g);
      var align = verticalAlignment(g, adjustedLayering, conflicts, neighborFn);
      var xs = horizontalCompaction(g, adjustedLayering,
        align.root, align.align, horiz === "r");
      if (horiz === "r") {
        xs = _.mapValues(xs, function(x) { return -x; });
      }
      xss[vert + horiz] = xs;
    });
  });

  var smallestWidth = findSmallestWidthAlignment(g, xss);
  alignCoordinates(xss, smallestWidth);
  return balance(xss, g.graph().align);
}

function sep(nodeSep, edgeSep, reverseSep) {
  return function(g, v, w) {
    var vLabel = g.node(v);
    var wLabel = g.node(w);
    var sum = 0;
    var delta;

    sum += vLabel.width / 2;
    if (_.has(vLabel, "labelpos")) {
      switch (vLabel.labelpos.toLowerCase()) {
      case "l": delta = -vLabel.width / 2; break;
      case "r": delta = vLabel.width / 2; break;
      }
    }
    if (delta) {
      sum += reverseSep ? delta : -delta;
    }
    delta = 0;

    sum += (vLabel.dummy ? edgeSep : nodeSep) / 2;
    sum += (wLabel.dummy ? edgeSep : nodeSep) / 2;

    sum += wLabel.width / 2;
    if (_.has(wLabel, "labelpos")) {
      switch (wLabel.labelpos.toLowerCase()) {
      case "l": delta = wLabel.width / 2; break;
      case "r": delta = -wLabel.width / 2; break;
      }
    }
    if (delta) {
      sum += reverseSep ? delta : -delta;
    }
    delta = 0;

    return sum;
  };
}

function width(g, v) {
  return g.node(v).width;
}


/***/ }),

/***/ "./node_modules/dagre/lib/position/index.js":
/*!**************************************************!*\
  !*** ./node_modules/dagre/lib/position/index.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var _ = __webpack_require__(/*! ../lodash */ "./node_modules/dagre/lib/lodash.js");
var util = __webpack_require__(/*! ../util */ "./node_modules/dagre/lib/util.js");
var positionX = __webpack_require__(/*! ./bk */ "./node_modules/dagre/lib/position/bk.js").positionX;

module.exports = position;

function position(g) {
  g = util.asNonCompoundGraph(g);

  positionY(g);
  _.forEach(positionX(g), function(x, v) {
    g.node(v).x = x;
  });
}

function positionY(g) {
  var layering = util.buildLayerMatrix(g);
  var rankSep = g.graph().ranksep;
  var prevY = 0;
  _.forEach(layering, function(layer) {
    var maxHeight = _.max(_.map(layer, function(v) { return g.node(v).height; }));
    _.forEach(layer, function(v) {
      g.node(v).y = prevY + maxHeight / 2;
    });
    prevY += maxHeight + rankSep;
  });
}



/***/ }),

/***/ "./node_modules/dagre/lib/rank/feasible-tree.js":
/*!******************************************************!*\
  !*** ./node_modules/dagre/lib/rank/feasible-tree.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var _ = __webpack_require__(/*! ../lodash */ "./node_modules/dagre/lib/lodash.js");
var Graph = __webpack_require__(/*! ../graphlib */ "./node_modules/dagre/lib/graphlib.js").Graph;
var slack = __webpack_require__(/*! ./util */ "./node_modules/dagre/lib/rank/util.js").slack;

module.exports = feasibleTree;

/*
 * Constructs a spanning tree with tight edges and adjusted the input node's
 * ranks to achieve this. A tight edge is one that is has a length that matches
 * its "minlen" attribute.
 *
 * The basic structure for this function is derived from Gansner, et al., "A
 * Technique for Drawing Directed Graphs."
 *
 * Pre-conditions:
 *
 *    1. Graph must be a DAG.
 *    2. Graph must be connected.
 *    3. Graph must have at least one node.
 *    5. Graph nodes must have been previously assigned a "rank" property that
 *       respects the "minlen" property of incident edges.
 *    6. Graph edges must have a "minlen" property.
 *
 * Post-conditions:
 *
 *    - Graph nodes will have their rank adjusted to ensure that all edges are
 *      tight.
 *
 * Returns a tree (undirected graph) that is constructed using only "tight"
 * edges.
 */
function feasibleTree(g) {
  var t = new Graph({ directed: false });

  // Choose arbitrary node from which to start our tree
  var start = g.nodes()[0];
  var size = g.nodeCount();
  t.setNode(start, {});

  var edge, delta;
  while (tightTree(t, g) < size) {
    edge = findMinSlackEdge(t, g);
    delta = t.hasNode(edge.v) ? slack(g, edge) : -slack(g, edge);
    shiftRanks(t, g, delta);
  }

  return t;
}

/*
 * Finds a maximal tree of tight edges and returns the number of nodes in the
 * tree.
 */
function tightTree(t, g) {
  function dfs(v) {
    _.forEach(g.nodeEdges(v), function(e) {
      var edgeV = e.v,
        w = (v === edgeV) ? e.w : edgeV;
      if (!t.hasNode(w) && !slack(g, e)) {
        t.setNode(w, {});
        t.setEdge(v, w, {});
        dfs(w);
      }
    });
  }

  _.forEach(t.nodes(), dfs);
  return t.nodeCount();
}

/*
 * Finds the edge with the smallest slack that is incident on tree and returns
 * it.
 */
function findMinSlackEdge(t, g) {
  return _.minBy(g.edges(), function(e) {
    if (t.hasNode(e.v) !== t.hasNode(e.w)) {
      return slack(g, e);
    }
  });
}

function shiftRanks(t, g, delta) {
  _.forEach(t.nodes(), function(v) {
    g.node(v).rank += delta;
  });
}


/***/ }),

/***/ "./node_modules/dagre/lib/rank/index.js":
/*!**********************************************!*\
  !*** ./node_modules/dagre/lib/rank/index.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var rankUtil = __webpack_require__(/*! ./util */ "./node_modules/dagre/lib/rank/util.js");
var longestPath = rankUtil.longestPath;
var feasibleTree = __webpack_require__(/*! ./feasible-tree */ "./node_modules/dagre/lib/rank/feasible-tree.js");
var networkSimplex = __webpack_require__(/*! ./network-simplex */ "./node_modules/dagre/lib/rank/network-simplex.js");

module.exports = rank;

/*
 * Assigns a rank to each node in the input graph that respects the "minlen"
 * constraint specified on edges between nodes.
 *
 * This basic structure is derived from Gansner, et al., "A Technique for
 * Drawing Directed Graphs."
 *
 * Pre-conditions:
 *
 *    1. Graph must be a connected DAG
 *    2. Graph nodes must be objects
 *    3. Graph edges must have "weight" and "minlen" attributes
 *
 * Post-conditions:
 *
 *    1. Graph nodes will have a "rank" attribute based on the results of the
 *       algorithm. Ranks can start at any index (including negative), we'll
 *       fix them up later.
 */
function rank(g) {
  switch(g.graph().ranker) {
  case "network-simplex": networkSimplexRanker(g); break;
  case "tight-tree": tightTreeRanker(g); break;
  case "longest-path": longestPathRanker(g); break;
  default: networkSimplexRanker(g);
  }
}

// A fast and simple ranker, but results are far from optimal.
var longestPathRanker = longestPath;

function tightTreeRanker(g) {
  longestPath(g);
  feasibleTree(g);
}

function networkSimplexRanker(g) {
  networkSimplex(g);
}


/***/ }),

/***/ "./node_modules/dagre/lib/rank/network-simplex.js":
/*!********************************************************!*\
  !*** ./node_modules/dagre/lib/rank/network-simplex.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var _ = __webpack_require__(/*! ../lodash */ "./node_modules/dagre/lib/lodash.js");
var feasibleTree = __webpack_require__(/*! ./feasible-tree */ "./node_modules/dagre/lib/rank/feasible-tree.js");
var slack = __webpack_require__(/*! ./util */ "./node_modules/dagre/lib/rank/util.js").slack;
var initRank = __webpack_require__(/*! ./util */ "./node_modules/dagre/lib/rank/util.js").longestPath;
var preorder = __webpack_require__(/*! ../graphlib */ "./node_modules/dagre/lib/graphlib.js").alg.preorder;
var postorder = __webpack_require__(/*! ../graphlib */ "./node_modules/dagre/lib/graphlib.js").alg.postorder;
var simplify = __webpack_require__(/*! ../util */ "./node_modules/dagre/lib/util.js").simplify;

module.exports = networkSimplex;

// Expose some internals for testing purposes
networkSimplex.initLowLimValues = initLowLimValues;
networkSimplex.initCutValues = initCutValues;
networkSimplex.calcCutValue = calcCutValue;
networkSimplex.leaveEdge = leaveEdge;
networkSimplex.enterEdge = enterEdge;
networkSimplex.exchangeEdges = exchangeEdges;

/*
 * The network simplex algorithm assigns ranks to each node in the input graph
 * and iteratively improves the ranking to reduce the length of edges.
 *
 * Preconditions:
 *
 *    1. The input graph must be a DAG.
 *    2. All nodes in the graph must have an object value.
 *    3. All edges in the graph must have "minlen" and "weight" attributes.
 *
 * Postconditions:
 *
 *    1. All nodes in the graph will have an assigned "rank" attribute that has
 *       been optimized by the network simplex algorithm. Ranks start at 0.
 *
 *
 * A rough sketch of the algorithm is as follows:
 *
 *    1. Assign initial ranks to each node. We use the longest path algorithm,
 *       which assigns ranks to the lowest position possible. In general this
 *       leads to very wide bottom ranks and unnecessarily long edges.
 *    2. Construct a feasible tight tree. A tight tree is one such that all
 *       edges in the tree have no slack (difference between length of edge
 *       and minlen for the edge). This by itself greatly improves the assigned
 *       rankings by shorting edges.
 *    3. Iteratively find edges that have negative cut values. Generally a
 *       negative cut value indicates that the edge could be removed and a new
 *       tree edge could be added to produce a more compact graph.
 *
 * Much of the algorithms here are derived from Gansner, et al., "A Technique
 * for Drawing Directed Graphs." The structure of the file roughly follows the
 * structure of the overall algorithm.
 */
function networkSimplex(g) {
  g = simplify(g);
  initRank(g);
  var t = feasibleTree(g);
  initLowLimValues(t);
  initCutValues(t, g);

  var e, f;
  while ((e = leaveEdge(t))) {
    f = enterEdge(t, g, e);
    exchangeEdges(t, g, e, f);
  }
}

/*
 * Initializes cut values for all edges in the tree.
 */
function initCutValues(t, g) {
  var vs = postorder(t, t.nodes());
  vs = vs.slice(0, vs.length - 1);
  _.forEach(vs, function(v) {
    assignCutValue(t, g, v);
  });
}

function assignCutValue(t, g, child) {
  var childLab = t.node(child);
  var parent = childLab.parent;
  t.edge(child, parent).cutvalue = calcCutValue(t, g, child);
}

/*
 * Given the tight tree, its graph, and a child in the graph calculate and
 * return the cut value for the edge between the child and its parent.
 */
function calcCutValue(t, g, child) {
  var childLab = t.node(child);
  var parent = childLab.parent;
  // True if the child is on the tail end of the edge in the directed graph
  var childIsTail = true;
  // The graph's view of the tree edge we're inspecting
  var graphEdge = g.edge(child, parent);
  // The accumulated cut value for the edge between this node and its parent
  var cutValue = 0;

  if (!graphEdge) {
    childIsTail = false;
    graphEdge = g.edge(parent, child);
  }

  cutValue = graphEdge.weight;

  _.forEach(g.nodeEdges(child), function(e) {
    var isOutEdge = e.v === child,
      other = isOutEdge ? e.w : e.v;

    if (other !== parent) {
      var pointsToHead = isOutEdge === childIsTail,
        otherWeight = g.edge(e).weight;

      cutValue += pointsToHead ? otherWeight : -otherWeight;
      if (isTreeEdge(t, child, other)) {
        var otherCutValue = t.edge(child, other).cutvalue;
        cutValue += pointsToHead ? -otherCutValue : otherCutValue;
      }
    }
  });

  return cutValue;
}

function initLowLimValues(tree, root) {
  if (arguments.length < 2) {
    root = tree.nodes()[0];
  }
  dfsAssignLowLim(tree, {}, 1, root);
}

function dfsAssignLowLim(tree, visited, nextLim, v, parent) {
  var low = nextLim;
  var label = tree.node(v);

  visited[v] = true;
  _.forEach(tree.neighbors(v), function(w) {
    if (!_.has(visited, w)) {
      nextLim = dfsAssignLowLim(tree, visited, nextLim, w, v);
    }
  });

  label.low = low;
  label.lim = nextLim++;
  if (parent) {
    label.parent = parent;
  } else {
    // TODO should be able to remove this when we incrementally update low lim
    delete label.parent;
  }

  return nextLim;
}

function leaveEdge(tree) {
  return _.find(tree.edges(), function(e) {
    return tree.edge(e).cutvalue < 0;
  });
}

function enterEdge(t, g, edge) {
  var v = edge.v;
  var w = edge.w;

  // For the rest of this function we assume that v is the tail and w is the
  // head, so if we don't have this edge in the graph we should flip it to
  // match the correct orientation.
  if (!g.hasEdge(v, w)) {
    v = edge.w;
    w = edge.v;
  }

  var vLabel = t.node(v);
  var wLabel = t.node(w);
  var tailLabel = vLabel;
  var flip = false;

  // If the root is in the tail of the edge then we need to flip the logic that
  // checks for the head and tail nodes in the candidates function below.
  if (vLabel.lim > wLabel.lim) {
    tailLabel = wLabel;
    flip = true;
  }

  var candidates = _.filter(g.edges(), function(edge) {
    return flip === isDescendant(t, t.node(edge.v), tailLabel) &&
           flip !== isDescendant(t, t.node(edge.w), tailLabel);
  });

  return _.minBy(candidates, function(edge) { return slack(g, edge); });
}

function exchangeEdges(t, g, e, f) {
  var v = e.v;
  var w = e.w;
  t.removeEdge(v, w);
  t.setEdge(f.v, f.w, {});
  initLowLimValues(t);
  initCutValues(t, g);
  updateRanks(t, g);
}

function updateRanks(t, g) {
  var root = _.find(t.nodes(), function(v) { return !g.node(v).parent; });
  var vs = preorder(t, root);
  vs = vs.slice(1);
  _.forEach(vs, function(v) {
    var parent = t.node(v).parent,
      edge = g.edge(v, parent),
      flipped = false;

    if (!edge) {
      edge = g.edge(parent, v);
      flipped = true;
    }

    g.node(v).rank = g.node(parent).rank + (flipped ? edge.minlen : -edge.minlen);
  });
}

/*
 * Returns true if the edge is in the tree.
 */
function isTreeEdge(tree, u, v) {
  return tree.hasEdge(u, v);
}

/*
 * Returns true if the specified node is descendant of the root node per the
 * assigned low and lim attributes in the tree.
 */
function isDescendant(tree, vLabel, rootLabel) {
  return rootLabel.low <= vLabel.lim && vLabel.lim <= rootLabel.lim;
}


/***/ }),

/***/ "./node_modules/dagre/lib/rank/util.js":
/*!*********************************************!*\
  !*** ./node_modules/dagre/lib/rank/util.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var _ = __webpack_require__(/*! ../lodash */ "./node_modules/dagre/lib/lodash.js");

module.exports = {
  longestPath: longestPath,
  slack: slack
};

/*
 * Initializes ranks for the input graph using the longest path algorithm. This
 * algorithm scales well and is fast in practice, it yields rather poor
 * solutions. Nodes are pushed to the lowest layer possible, leaving the bottom
 * ranks wide and leaving edges longer than necessary. However, due to its
 * speed, this algorithm is good for getting an initial ranking that can be fed
 * into other algorithms.
 *
 * This algorithm does not normalize layers because it will be used by other
 * algorithms in most cases. If using this algorithm directly, be sure to
 * run normalize at the end.
 *
 * Pre-conditions:
 *
 *    1. Input graph is a DAG.
 *    2. Input graph node labels can be assigned properties.
 *
 * Post-conditions:
 *
 *    1. Each node will be assign an (unnormalized) "rank" property.
 */
function longestPath(g) {
  var visited = {};

  function dfs(v) {
    var label = g.node(v);
    if (_.has(visited, v)) {
      return label.rank;
    }
    visited[v] = true;

    var rank = _.min(_.map(g.outEdges(v), function(e) {
      return dfs(e.w) - g.edge(e).minlen;
    }));

    if (rank === Number.POSITIVE_INFINITY || // return value of _.map([]) for Lodash 3
        rank === undefined || // return value of _.map([]) for Lodash 4
        rank === null) { // return value of _.map([null])
      rank = 0;
    }

    return (label.rank = rank);
  }

  _.forEach(g.sources(), dfs);
}

/*
 * Returns the amount of slack for the given edge. The slack is defined as the
 * difference between the length of the edge and its minimum length.
 */
function slack(g, e) {
  return g.node(e.w).rank - g.node(e.v).rank - g.edge(e).minlen;
}


/***/ }),

/***/ "./node_modules/dagre/lib/util.js":
/*!****************************************!*\
  !*** ./node_modules/dagre/lib/util.js ***!
  \****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/* eslint "no-console": off */



var _ = __webpack_require__(/*! ./lodash */ "./node_modules/dagre/lib/lodash.js");
var Graph = __webpack_require__(/*! ./graphlib */ "./node_modules/dagre/lib/graphlib.js").Graph;

module.exports = {
  addDummyNode: addDummyNode,
  simplify: simplify,
  asNonCompoundGraph: asNonCompoundGraph,
  successorWeights: successorWeights,
  predecessorWeights: predecessorWeights,
  intersectRect: intersectRect,
  buildLayerMatrix: buildLayerMatrix,
  normalizeRanks: normalizeRanks,
  removeEmptyRanks: removeEmptyRanks,
  addBorderNode: addBorderNode,
  maxRank: maxRank,
  partition: partition,
  time: time,
  notime: notime
};

/*
 * Adds a dummy node to the graph and return v.
 */
function addDummyNode(g, type, attrs, name) {
  var v;
  do {
    v = _.uniqueId(name);
  } while (g.hasNode(v));

  attrs.dummy = type;
  g.setNode(v, attrs);
  return v;
}

/*
 * Returns a new graph with only simple edges. Handles aggregation of data
 * associated with multi-edges.
 */
function simplify(g) {
  var simplified = new Graph().setGraph(g.graph());
  _.forEach(g.nodes(), function(v) { simplified.setNode(v, g.node(v)); });
  _.forEach(g.edges(), function(e) {
    var simpleLabel = simplified.edge(e.v, e.w) || { weight: 0, minlen: 1 };
    var label = g.edge(e);
    simplified.setEdge(e.v, e.w, {
      weight: simpleLabel.weight + label.weight,
      minlen: Math.max(simpleLabel.minlen, label.minlen)
    });
  });
  return simplified;
}

function asNonCompoundGraph(g) {
  var simplified = new Graph({ multigraph: g.isMultigraph() }).setGraph(g.graph());
  _.forEach(g.nodes(), function(v) {
    if (!g.children(v).length) {
      simplified.setNode(v, g.node(v));
    }
  });
  _.forEach(g.edges(), function(e) {
    simplified.setEdge(e, g.edge(e));
  });
  return simplified;
}

function successorWeights(g) {
  var weightMap = _.map(g.nodes(), function(v) {
    var sucs = {};
    _.forEach(g.outEdges(v), function(e) {
      sucs[e.w] = (sucs[e.w] || 0) + g.edge(e).weight;
    });
    return sucs;
  });
  return _.zipObject(g.nodes(), weightMap);
}

function predecessorWeights(g) {
  var weightMap = _.map(g.nodes(), function(v) {
    var preds = {};
    _.forEach(g.inEdges(v), function(e) {
      preds[e.v] = (preds[e.v] || 0) + g.edge(e).weight;
    });
    return preds;
  });
  return _.zipObject(g.nodes(), weightMap);
}

/*
 * Finds where a line starting at point ({x, y}) would intersect a rectangle
 * ({x, y, width, height}) if it were pointing at the rectangle's center.
 */
function intersectRect(rect, point) {
  var x = rect.x;
  var y = rect.y;

  // Rectangle intersection algorithm from:
  // http://math.stackexchange.com/questions/108113/find-edge-between-two-boxes
  var dx = point.x - x;
  var dy = point.y - y;
  var w = rect.width / 2;
  var h = rect.height / 2;

  if (!dx && !dy) {
    throw new Error("Not possible to find intersection inside of the rectangle");
  }

  var sx, sy;
  if (Math.abs(dy) * w > Math.abs(dx) * h) {
    // Intersection is top or bottom of rect.
    if (dy < 0) {
      h = -h;
    }
    sx = h * dx / dy;
    sy = h;
  } else {
    // Intersection is left or right of rect.
    if (dx < 0) {
      w = -w;
    }
    sx = w;
    sy = w * dy / dx;
  }

  return { x: x + sx, y: y + sy };
}

/*
 * Given a DAG with each node assigned "rank" and "order" properties, this
 * function will produce a matrix with the ids of each node.
 */
function buildLayerMatrix(g) {
  var layering = _.map(_.range(maxRank(g) + 1), function() { return []; });
  _.forEach(g.nodes(), function(v) {
    var node = g.node(v);
    var rank = node.rank;
    if (!_.isUndefined(rank)) {
      layering[rank][node.order] = v;
    }
  });
  return layering;
}

/*
 * Adjusts the ranks for all nodes in the graph such that all nodes v have
 * rank(v) >= 0 and at least one node w has rank(w) = 0.
 */
function normalizeRanks(g) {
  var min = _.min(_.map(g.nodes(), function(v) { return g.node(v).rank; }));
  _.forEach(g.nodes(), function(v) {
    var node = g.node(v);
    if (_.has(node, "rank")) {
      node.rank -= min;
    }
  });
}

function removeEmptyRanks(g) {
  // Ranks may not start at 0, so we need to offset them
  var offset = _.min(_.map(g.nodes(), function(v) { return g.node(v).rank; }));

  var layers = [];
  _.forEach(g.nodes(), function(v) {
    var rank = g.node(v).rank - offset;
    if (!layers[rank]) {
      layers[rank] = [];
    }
    layers[rank].push(v);
  });

  var delta = 0;
  var nodeRankFactor = g.graph().nodeRankFactor;
  _.forEach(layers, function(vs, i) {
    if (_.isUndefined(vs) && i % nodeRankFactor !== 0) {
      --delta;
    } else if (delta) {
      _.forEach(vs, function(v) { g.node(v).rank += delta; });
    }
  });
}

function addBorderNode(g, prefix, rank, order) {
  var node = {
    width: 0,
    height: 0
  };
  if (arguments.length >= 4) {
    node.rank = rank;
    node.order = order;
  }
  return addDummyNode(g, "border", node, prefix);
}

function maxRank(g) {
  return _.max(_.map(g.nodes(), function(v) {
    var rank = g.node(v).rank;
    if (!_.isUndefined(rank)) {
      return rank;
    }
  }));
}

/*
 * Partition a collection into two groups: `lhs` and `rhs`. If the supplied
 * function returns true for an entry it goes into `lhs`. Otherwise it goes
 * into `rhs.
 */
function partition(collection, fn) {
  var result = { lhs: [], rhs: [] };
  _.forEach(collection, function(value) {
    if (fn(value)) {
      result.lhs.push(value);
    } else {
      result.rhs.push(value);
    }
  });
  return result;
}

/*
 * Returns a new function that wraps `fn` with a timer. The wrapper logs the
 * time it takes to execute the function.
 */
function time(name, fn) {
  var start = _.now();
  try {
    return fn();
  } finally {
    console.log(name + " time: " + (_.now() - start) + "ms");
  }
}

function notime(name, fn) {
  return fn();
}


/***/ }),

/***/ "./node_modules/dagre/lib/version.js":
/*!*******************************************!*\
  !*** ./node_modules/dagre/lib/version.js ***!
  \*******************************************/
/***/ ((module) => {

module.exports = "0.8.5";


/***/ }),

/***/ "./node_modules/graphlib/index.js":
/*!****************************************!*\
  !*** ./node_modules/graphlib/index.js ***!
  \****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/**
 * Copyright (c) 2014, Chris Pettitt
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 * list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 * this list of conditions and the following disclaimer in the documentation
 * and/or other materials provided with the distribution.
 *
 * 3. Neither the name of the copyright holder nor the names of its contributors
 * may be used to endorse or promote products derived from this software without
 * specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

var lib = __webpack_require__(/*! ./lib */ "./node_modules/graphlib/lib/index.js");

module.exports = {
  Graph: lib.Graph,
  json: __webpack_require__(/*! ./lib/json */ "./node_modules/graphlib/lib/json.js"),
  alg: __webpack_require__(/*! ./lib/alg */ "./node_modules/graphlib/lib/alg/index.js"),
  version: lib.version
};


/***/ }),

/***/ "./node_modules/graphlib/lib/alg/components.js":
/*!*****************************************************!*\
  !*** ./node_modules/graphlib/lib/alg/components.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var _ = __webpack_require__(/*! ../lodash */ "./node_modules/graphlib/lib/lodash.js");

module.exports = components;

function components(g) {
  var visited = {};
  var cmpts = [];
  var cmpt;

  function dfs(v) {
    if (_.has(visited, v)) return;
    visited[v] = true;
    cmpt.push(v);
    _.each(g.successors(v), dfs);
    _.each(g.predecessors(v), dfs);
  }

  _.each(g.nodes(), function(v) {
    cmpt = [];
    dfs(v);
    if (cmpt.length) {
      cmpts.push(cmpt);
    }
  });

  return cmpts;
}


/***/ }),

/***/ "./node_modules/graphlib/lib/alg/dfs.js":
/*!**********************************************!*\
  !*** ./node_modules/graphlib/lib/alg/dfs.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var _ = __webpack_require__(/*! ../lodash */ "./node_modules/graphlib/lib/lodash.js");

module.exports = dfs;

/*
 * A helper that preforms a pre- or post-order traversal on the input graph
 * and returns the nodes in the order they were visited. If the graph is
 * undirected then this algorithm will navigate using neighbors. If the graph
 * is directed then this algorithm will navigate using successors.
 *
 * Order must be one of "pre" or "post".
 */
function dfs(g, vs, order) {
  if (!_.isArray(vs)) {
    vs = [vs];
  }

  var navigation = (g.isDirected() ? g.successors : g.neighbors).bind(g);

  var acc = [];
  var visited = {};
  _.each(vs, function(v) {
    if (!g.hasNode(v)) {
      throw new Error("Graph does not have node: " + v);
    }

    doDfs(g, v, order === "post", visited, navigation, acc);
  });
  return acc;
}

function doDfs(g, v, postorder, visited, navigation, acc) {
  if (!_.has(visited, v)) {
    visited[v] = true;

    if (!postorder) { acc.push(v); }
    _.each(navigation(v), function(w) {
      doDfs(g, w, postorder, visited, navigation, acc);
    });
    if (postorder) { acc.push(v); }
  }
}


/***/ }),

/***/ "./node_modules/graphlib/lib/alg/dijkstra-all.js":
/*!*******************************************************!*\
  !*** ./node_modules/graphlib/lib/alg/dijkstra-all.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var dijkstra = __webpack_require__(/*! ./dijkstra */ "./node_modules/graphlib/lib/alg/dijkstra.js");
var _ = __webpack_require__(/*! ../lodash */ "./node_modules/graphlib/lib/lodash.js");

module.exports = dijkstraAll;

function dijkstraAll(g, weightFunc, edgeFunc) {
  return _.transform(g.nodes(), function(acc, v) {
    acc[v] = dijkstra(g, v, weightFunc, edgeFunc);
  }, {});
}


/***/ }),

/***/ "./node_modules/graphlib/lib/alg/dijkstra.js":
/*!***************************************************!*\
  !*** ./node_modules/graphlib/lib/alg/dijkstra.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var _ = __webpack_require__(/*! ../lodash */ "./node_modules/graphlib/lib/lodash.js");
var PriorityQueue = __webpack_require__(/*! ../data/priority-queue */ "./node_modules/graphlib/lib/data/priority-queue.js");

module.exports = dijkstra;

var DEFAULT_WEIGHT_FUNC = _.constant(1);

function dijkstra(g, source, weightFn, edgeFn) {
  return runDijkstra(g, String(source),
    weightFn || DEFAULT_WEIGHT_FUNC,
    edgeFn || function(v) { return g.outEdges(v); });
}

function runDijkstra(g, source, weightFn, edgeFn) {
  var results = {};
  var pq = new PriorityQueue();
  var v, vEntry;

  var updateNeighbors = function(edge) {
    var w = edge.v !== v ? edge.v : edge.w;
    var wEntry = results[w];
    var weight = weightFn(edge);
    var distance = vEntry.distance + weight;

    if (weight < 0) {
      throw new Error("dijkstra does not allow negative edge weights. " +
                      "Bad edge: " + edge + " Weight: " + weight);
    }

    if (distance < wEntry.distance) {
      wEntry.distance = distance;
      wEntry.predecessor = v;
      pq.decrease(w, distance);
    }
  };

  g.nodes().forEach(function(v) {
    var distance = v === source ? 0 : Number.POSITIVE_INFINITY;
    results[v] = { distance: distance };
    pq.add(v, distance);
  });

  while (pq.size() > 0) {
    v = pq.removeMin();
    vEntry = results[v];
    if (vEntry.distance === Number.POSITIVE_INFINITY) {
      break;
    }

    edgeFn(v).forEach(updateNeighbors);
  }

  return results;
}


/***/ }),

/***/ "./node_modules/graphlib/lib/alg/find-cycles.js":
/*!******************************************************!*\
  !*** ./node_modules/graphlib/lib/alg/find-cycles.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var _ = __webpack_require__(/*! ../lodash */ "./node_modules/graphlib/lib/lodash.js");
var tarjan = __webpack_require__(/*! ./tarjan */ "./node_modules/graphlib/lib/alg/tarjan.js");

module.exports = findCycles;

function findCycles(g) {
  return _.filter(tarjan(g), function(cmpt) {
    return cmpt.length > 1 || (cmpt.length === 1 && g.hasEdge(cmpt[0], cmpt[0]));
  });
}


/***/ }),

/***/ "./node_modules/graphlib/lib/alg/floyd-warshall.js":
/*!*********************************************************!*\
  !*** ./node_modules/graphlib/lib/alg/floyd-warshall.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var _ = __webpack_require__(/*! ../lodash */ "./node_modules/graphlib/lib/lodash.js");

module.exports = floydWarshall;

var DEFAULT_WEIGHT_FUNC = _.constant(1);

function floydWarshall(g, weightFn, edgeFn) {
  return runFloydWarshall(g,
    weightFn || DEFAULT_WEIGHT_FUNC,
    edgeFn || function(v) { return g.outEdges(v); });
}

function runFloydWarshall(g, weightFn, edgeFn) {
  var results = {};
  var nodes = g.nodes();

  nodes.forEach(function(v) {
    results[v] = {};
    results[v][v] = { distance: 0 };
    nodes.forEach(function(w) {
      if (v !== w) {
        results[v][w] = { distance: Number.POSITIVE_INFINITY };
      }
    });
    edgeFn(v).forEach(function(edge) {
      var w = edge.v === v ? edge.w : edge.v;
      var d = weightFn(edge);
      results[v][w] = { distance: d, predecessor: v };
    });
  });

  nodes.forEach(function(k) {
    var rowK = results[k];
    nodes.forEach(function(i) {
      var rowI = results[i];
      nodes.forEach(function(j) {
        var ik = rowI[k];
        var kj = rowK[j];
        var ij = rowI[j];
        var altDistance = ik.distance + kj.distance;
        if (altDistance < ij.distance) {
          ij.distance = altDistance;
          ij.predecessor = kj.predecessor;
        }
      });
    });
  });

  return results;
}


/***/ }),

/***/ "./node_modules/graphlib/lib/alg/index.js":
/*!************************************************!*\
  !*** ./node_modules/graphlib/lib/alg/index.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = {
  components: __webpack_require__(/*! ./components */ "./node_modules/graphlib/lib/alg/components.js"),
  dijkstra: __webpack_require__(/*! ./dijkstra */ "./node_modules/graphlib/lib/alg/dijkstra.js"),
  dijkstraAll: __webpack_require__(/*! ./dijkstra-all */ "./node_modules/graphlib/lib/alg/dijkstra-all.js"),
  findCycles: __webpack_require__(/*! ./find-cycles */ "./node_modules/graphlib/lib/alg/find-cycles.js"),
  floydWarshall: __webpack_require__(/*! ./floyd-warshall */ "./node_modules/graphlib/lib/alg/floyd-warshall.js"),
  isAcyclic: __webpack_require__(/*! ./is-acyclic */ "./node_modules/graphlib/lib/alg/is-acyclic.js"),
  postorder: __webpack_require__(/*! ./postorder */ "./node_modules/graphlib/lib/alg/postorder.js"),
  preorder: __webpack_require__(/*! ./preorder */ "./node_modules/graphlib/lib/alg/preorder.js"),
  prim: __webpack_require__(/*! ./prim */ "./node_modules/graphlib/lib/alg/prim.js"),
  tarjan: __webpack_require__(/*! ./tarjan */ "./node_modules/graphlib/lib/alg/tarjan.js"),
  topsort: __webpack_require__(/*! ./topsort */ "./node_modules/graphlib/lib/alg/topsort.js")
};


/***/ }),

/***/ "./node_modules/graphlib/lib/alg/is-acyclic.js":
/*!*****************************************************!*\
  !*** ./node_modules/graphlib/lib/alg/is-acyclic.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var topsort = __webpack_require__(/*! ./topsort */ "./node_modules/graphlib/lib/alg/topsort.js");

module.exports = isAcyclic;

function isAcyclic(g) {
  try {
    topsort(g);
  } catch (e) {
    if (e instanceof topsort.CycleException) {
      return false;
    }
    throw e;
  }
  return true;
}


/***/ }),

/***/ "./node_modules/graphlib/lib/alg/postorder.js":
/*!****************************************************!*\
  !*** ./node_modules/graphlib/lib/alg/postorder.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var dfs = __webpack_require__(/*! ./dfs */ "./node_modules/graphlib/lib/alg/dfs.js");

module.exports = postorder;

function postorder(g, vs) {
  return dfs(g, vs, "post");
}


/***/ }),

/***/ "./node_modules/graphlib/lib/alg/preorder.js":
/*!***************************************************!*\
  !*** ./node_modules/graphlib/lib/alg/preorder.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var dfs = __webpack_require__(/*! ./dfs */ "./node_modules/graphlib/lib/alg/dfs.js");

module.exports = preorder;

function preorder(g, vs) {
  return dfs(g, vs, "pre");
}


/***/ }),

/***/ "./node_modules/graphlib/lib/alg/prim.js":
/*!***********************************************!*\
  !*** ./node_modules/graphlib/lib/alg/prim.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var _ = __webpack_require__(/*! ../lodash */ "./node_modules/graphlib/lib/lodash.js");
var Graph = __webpack_require__(/*! ../graph */ "./node_modules/graphlib/lib/graph.js");
var PriorityQueue = __webpack_require__(/*! ../data/priority-queue */ "./node_modules/graphlib/lib/data/priority-queue.js");

module.exports = prim;

function prim(g, weightFunc) {
  var result = new Graph();
  var parents = {};
  var pq = new PriorityQueue();
  var v;

  function updateNeighbors(edge) {
    var w = edge.v === v ? edge.w : edge.v;
    var pri = pq.priority(w);
    if (pri !== undefined) {
      var edgeWeight = weightFunc(edge);
      if (edgeWeight < pri) {
        parents[w] = v;
        pq.decrease(w, edgeWeight);
      }
    }
  }

  if (g.nodeCount() === 0) {
    return result;
  }

  _.each(g.nodes(), function(v) {
    pq.add(v, Number.POSITIVE_INFINITY);
    result.setNode(v);
  });

  // Start from an arbitrary node
  pq.decrease(g.nodes()[0], 0);

  var init = false;
  while (pq.size() > 0) {
    v = pq.removeMin();
    if (_.has(parents, v)) {
      result.setEdge(v, parents[v]);
    } else if (init) {
      throw new Error("Input graph is not connected: " + g);
    } else {
      init = true;
    }

    g.nodeEdges(v).forEach(updateNeighbors);
  }

  return result;
}


/***/ }),

/***/ "./node_modules/graphlib/lib/alg/tarjan.js":
/*!*************************************************!*\
  !*** ./node_modules/graphlib/lib/alg/tarjan.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var _ = __webpack_require__(/*! ../lodash */ "./node_modules/graphlib/lib/lodash.js");

module.exports = tarjan;

function tarjan(g) {
  var index = 0;
  var stack = [];
  var visited = {}; // node id -> { onStack, lowlink, index }
  var results = [];

  function dfs(v) {
    var entry = visited[v] = {
      onStack: true,
      lowlink: index,
      index: index++
    };
    stack.push(v);

    g.successors(v).forEach(function(w) {
      if (!_.has(visited, w)) {
        dfs(w);
        entry.lowlink = Math.min(entry.lowlink, visited[w].lowlink);
      } else if (visited[w].onStack) {
        entry.lowlink = Math.min(entry.lowlink, visited[w].index);
      }
    });

    if (entry.lowlink === entry.index) {
      var cmpt = [];
      var w;
      do {
        w = stack.pop();
        visited[w].onStack = false;
        cmpt.push(w);
      } while (v !== w);
      results.push(cmpt);
    }
  }

  g.nodes().forEach(function(v) {
    if (!_.has(visited, v)) {
      dfs(v);
    }
  });

  return results;
}


/***/ }),

/***/ "./node_modules/graphlib/lib/alg/topsort.js":
/*!**************************************************!*\
  !*** ./node_modules/graphlib/lib/alg/topsort.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var _ = __webpack_require__(/*! ../lodash */ "./node_modules/graphlib/lib/lodash.js");

module.exports = topsort;
topsort.CycleException = CycleException;

function topsort(g) {
  var visited = {};
  var stack = {};
  var results = [];

  function visit(node) {
    if (_.has(stack, node)) {
      throw new CycleException();
    }

    if (!_.has(visited, node)) {
      stack[node] = true;
      visited[node] = true;
      _.each(g.predecessors(node), visit);
      delete stack[node];
      results.push(node);
    }
  }

  _.each(g.sinks(), visit);

  if (_.size(visited) !== g.nodeCount()) {
    throw new CycleException();
  }

  return results;
}

function CycleException() {}
CycleException.prototype = new Error(); // must be an instance of Error to pass testing

/***/ }),

/***/ "./node_modules/graphlib/lib/data/priority-queue.js":
/*!**********************************************************!*\
  !*** ./node_modules/graphlib/lib/data/priority-queue.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var _ = __webpack_require__(/*! ../lodash */ "./node_modules/graphlib/lib/lodash.js");

module.exports = PriorityQueue;

/**
 * A min-priority queue data structure. This algorithm is derived from Cormen,
 * et al., "Introduction to Algorithms". The basic idea of a min-priority
 * queue is that you can efficiently (in O(1) time) get the smallest key in
 * the queue. Adding and removing elements takes O(log n) time. A key can
 * have its priority decreased in O(log n) time.
 */
function PriorityQueue() {
  this._arr = [];
  this._keyIndices = {};
}

/**
 * Returns the number of elements in the queue. Takes `O(1)` time.
 */
PriorityQueue.prototype.size = function() {
  return this._arr.length;
};

/**
 * Returns the keys that are in the queue. Takes `O(n)` time.
 */
PriorityQueue.prototype.keys = function() {
  return this._arr.map(function(x) { return x.key; });
};

/**
 * Returns `true` if **key** is in the queue and `false` if not.
 */
PriorityQueue.prototype.has = function(key) {
  return _.has(this._keyIndices, key);
};

/**
 * Returns the priority for **key**. If **key** is not present in the queue
 * then this function returns `undefined`. Takes `O(1)` time.
 *
 * @param {Object} key
 */
PriorityQueue.prototype.priority = function(key) {
  var index = this._keyIndices[key];
  if (index !== undefined) {
    return this._arr[index].priority;
  }
};

/**
 * Returns the key for the minimum element in this queue. If the queue is
 * empty this function throws an Error. Takes `O(1)` time.
 */
PriorityQueue.prototype.min = function() {
  if (this.size() === 0) {
    throw new Error("Queue underflow");
  }
  return this._arr[0].key;
};

/**
 * Inserts a new key into the priority queue. If the key already exists in
 * the queue this function returns `false`; otherwise it will return `true`.
 * Takes `O(n)` time.
 *
 * @param {Object} key the key to add
 * @param {Number} priority the initial priority for the key
 */
PriorityQueue.prototype.add = function(key, priority) {
  var keyIndices = this._keyIndices;
  key = String(key);
  if (!_.has(keyIndices, key)) {
    var arr = this._arr;
    var index = arr.length;
    keyIndices[key] = index;
    arr.push({key: key, priority: priority});
    this._decrease(index);
    return true;
  }
  return false;
};

/**
 * Removes and returns the smallest key in the queue. Takes `O(log n)` time.
 */
PriorityQueue.prototype.removeMin = function() {
  this._swap(0, this._arr.length - 1);
  var min = this._arr.pop();
  delete this._keyIndices[min.key];
  this._heapify(0);
  return min.key;
};

/**
 * Decreases the priority for **key** to **priority**. If the new priority is
 * greater than the previous priority, this function will throw an Error.
 *
 * @param {Object} key the key for which to raise priority
 * @param {Number} priority the new priority for the key
 */
PriorityQueue.prototype.decrease = function(key, priority) {
  var index = this._keyIndices[key];
  if (priority > this._arr[index].priority) {
    throw new Error("New priority is greater than current priority. " +
        "Key: " + key + " Old: " + this._arr[index].priority + " New: " + priority);
  }
  this._arr[index].priority = priority;
  this._decrease(index);
};

PriorityQueue.prototype._heapify = function(i) {
  var arr = this._arr;
  var l = 2 * i;
  var r = l + 1;
  var largest = i;
  if (l < arr.length) {
    largest = arr[l].priority < arr[largest].priority ? l : largest;
    if (r < arr.length) {
      largest = arr[r].priority < arr[largest].priority ? r : largest;
    }
    if (largest !== i) {
      this._swap(i, largest);
      this._heapify(largest);
    }
  }
};

PriorityQueue.prototype._decrease = function(index) {
  var arr = this._arr;
  var priority = arr[index].priority;
  var parent;
  while (index !== 0) {
    parent = index >> 1;
    if (arr[parent].priority < priority) {
      break;
    }
    this._swap(index, parent);
    index = parent;
  }
};

PriorityQueue.prototype._swap = function(i, j) {
  var arr = this._arr;
  var keyIndices = this._keyIndices;
  var origArrI = arr[i];
  var origArrJ = arr[j];
  arr[i] = origArrJ;
  arr[j] = origArrI;
  keyIndices[origArrJ.key] = i;
  keyIndices[origArrI.key] = j;
};


/***/ }),

/***/ "./node_modules/graphlib/lib/graph.js":
/*!********************************************!*\
  !*** ./node_modules/graphlib/lib/graph.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var _ = __webpack_require__(/*! ./lodash */ "./node_modules/graphlib/lib/lodash.js");

module.exports = Graph;

var DEFAULT_EDGE_NAME = "\x00";
var GRAPH_NODE = "\x00";
var EDGE_KEY_DELIM = "\x01";

// Implementation notes:
//
//  * Node id query functions should return string ids for the nodes
//  * Edge id query functions should return an "edgeObj", edge object, that is
//    composed of enough information to uniquely identify an edge: {v, w, name}.
//  * Internally we use an "edgeId", a stringified form of the edgeObj, to
//    reference edges. This is because we need a performant way to look these
//    edges up and, object properties, which have string keys, are the closest
//    we're going to get to a performant hashtable in JavaScript.

function Graph(opts) {
  this._isDirected = _.has(opts, "directed") ? opts.directed : true;
  this._isMultigraph = _.has(opts, "multigraph") ? opts.multigraph : false;
  this._isCompound = _.has(opts, "compound") ? opts.compound : false;

  // Label for the graph itself
  this._label = undefined;

  // Defaults to be set when creating a new node
  this._defaultNodeLabelFn = _.constant(undefined);

  // Defaults to be set when creating a new edge
  this._defaultEdgeLabelFn = _.constant(undefined);

  // v -> label
  this._nodes = {};

  if (this._isCompound) {
    // v -> parent
    this._parent = {};

    // v -> children
    this._children = {};
    this._children[GRAPH_NODE] = {};
  }

  // v -> edgeObj
  this._in = {};

  // u -> v -> Number
  this._preds = {};

  // v -> edgeObj
  this._out = {};

  // v -> w -> Number
  this._sucs = {};

  // e -> edgeObj
  this._edgeObjs = {};

  // e -> label
  this._edgeLabels = {};
}

/* Number of nodes in the graph. Should only be changed by the implementation. */
Graph.prototype._nodeCount = 0;

/* Number of edges in the graph. Should only be changed by the implementation. */
Graph.prototype._edgeCount = 0;


/* === Graph functions ========= */

Graph.prototype.isDirected = function() {
  return this._isDirected;
};

Graph.prototype.isMultigraph = function() {
  return this._isMultigraph;
};

Graph.prototype.isCompound = function() {
  return this._isCompound;
};

Graph.prototype.setGraph = function(label) {
  this._label = label;
  return this;
};

Graph.prototype.graph = function() {
  return this._label;
};


/* === Node functions ========== */

Graph.prototype.setDefaultNodeLabel = function(newDefault) {
  if (!_.isFunction(newDefault)) {
    newDefault = _.constant(newDefault);
  }
  this._defaultNodeLabelFn = newDefault;
  return this;
};

Graph.prototype.nodeCount = function() {
  return this._nodeCount;
};

Graph.prototype.nodes = function() {
  return _.keys(this._nodes);
};

Graph.prototype.sources = function() {
  var self = this;
  return _.filter(this.nodes(), function(v) {
    return _.isEmpty(self._in[v]);
  });
};

Graph.prototype.sinks = function() {
  var self = this;
  return _.filter(this.nodes(), function(v) {
    return _.isEmpty(self._out[v]);
  });
};

Graph.prototype.setNodes = function(vs, value) {
  var args = arguments;
  var self = this;
  _.each(vs, function(v) {
    if (args.length > 1) {
      self.setNode(v, value);
    } else {
      self.setNode(v);
    }
  });
  return this;
};

Graph.prototype.setNode = function(v, value) {
  if (_.has(this._nodes, v)) {
    if (arguments.length > 1) {
      this._nodes[v] = value;
    }
    return this;
  }

  this._nodes[v] = arguments.length > 1 ? value : this._defaultNodeLabelFn(v);
  if (this._isCompound) {
    this._parent[v] = GRAPH_NODE;
    this._children[v] = {};
    this._children[GRAPH_NODE][v] = true;
  }
  this._in[v] = {};
  this._preds[v] = {};
  this._out[v] = {};
  this._sucs[v] = {};
  ++this._nodeCount;
  return this;
};

Graph.prototype.node = function(v) {
  return this._nodes[v];
};

Graph.prototype.hasNode = function(v) {
  return _.has(this._nodes, v);
};

Graph.prototype.removeNode =  function(v) {
  var self = this;
  if (_.has(this._nodes, v)) {
    var removeEdge = function(e) { self.removeEdge(self._edgeObjs[e]); };
    delete this._nodes[v];
    if (this._isCompound) {
      this._removeFromParentsChildList(v);
      delete this._parent[v];
      _.each(this.children(v), function(child) {
        self.setParent(child);
      });
      delete this._children[v];
    }
    _.each(_.keys(this._in[v]), removeEdge);
    delete this._in[v];
    delete this._preds[v];
    _.each(_.keys(this._out[v]), removeEdge);
    delete this._out[v];
    delete this._sucs[v];
    --this._nodeCount;
  }
  return this;
};

Graph.prototype.setParent = function(v, parent) {
  if (!this._isCompound) {
    throw new Error("Cannot set parent in a non-compound graph");
  }

  if (_.isUndefined(parent)) {
    parent = GRAPH_NODE;
  } else {
    // Coerce parent to string
    parent += "";
    for (var ancestor = parent;
      !_.isUndefined(ancestor);
      ancestor = this.parent(ancestor)) {
      if (ancestor === v) {
        throw new Error("Setting " + parent+ " as parent of " + v +
                        " would create a cycle");
      }
    }

    this.setNode(parent);
  }

  this.setNode(v);
  this._removeFromParentsChildList(v);
  this._parent[v] = parent;
  this._children[parent][v] = true;
  return this;
};

Graph.prototype._removeFromParentsChildList = function(v) {
  delete this._children[this._parent[v]][v];
};

Graph.prototype.parent = function(v) {
  if (this._isCompound) {
    var parent = this._parent[v];
    if (parent !== GRAPH_NODE) {
      return parent;
    }
  }
};

Graph.prototype.children = function(v) {
  if (_.isUndefined(v)) {
    v = GRAPH_NODE;
  }

  if (this._isCompound) {
    var children = this._children[v];
    if (children) {
      return _.keys(children);
    }
  } else if (v === GRAPH_NODE) {
    return this.nodes();
  } else if (this.hasNode(v)) {
    return [];
  }
};

Graph.prototype.predecessors = function(v) {
  var predsV = this._preds[v];
  if (predsV) {
    return _.keys(predsV);
  }
};

Graph.prototype.successors = function(v) {
  var sucsV = this._sucs[v];
  if (sucsV) {
    return _.keys(sucsV);
  }
};

Graph.prototype.neighbors = function(v) {
  var preds = this.predecessors(v);
  if (preds) {
    return _.union(preds, this.successors(v));
  }
};

Graph.prototype.isLeaf = function (v) {
  var neighbors;
  if (this.isDirected()) {
    neighbors = this.successors(v);
  } else {
    neighbors = this.neighbors(v);
  }
  return neighbors.length === 0;
};

Graph.prototype.filterNodes = function(filter) {
  var copy = new this.constructor({
    directed: this._isDirected,
    multigraph: this._isMultigraph,
    compound: this._isCompound
  });

  copy.setGraph(this.graph());

  var self = this;
  _.each(this._nodes, function(value, v) {
    if (filter(v)) {
      copy.setNode(v, value);
    }
  });

  _.each(this._edgeObjs, function(e) {
    if (copy.hasNode(e.v) && copy.hasNode(e.w)) {
      copy.setEdge(e, self.edge(e));
    }
  });

  var parents = {};
  function findParent(v) {
    var parent = self.parent(v);
    if (parent === undefined || copy.hasNode(parent)) {
      parents[v] = parent;
      return parent;
    } else if (parent in parents) {
      return parents[parent];
    } else {
      return findParent(parent);
    }
  }

  if (this._isCompound) {
    _.each(copy.nodes(), function(v) {
      copy.setParent(v, findParent(v));
    });
  }

  return copy;
};

/* === Edge functions ========== */

Graph.prototype.setDefaultEdgeLabel = function(newDefault) {
  if (!_.isFunction(newDefault)) {
    newDefault = _.constant(newDefault);
  }
  this._defaultEdgeLabelFn = newDefault;
  return this;
};

Graph.prototype.edgeCount = function() {
  return this._edgeCount;
};

Graph.prototype.edges = function() {
  return _.values(this._edgeObjs);
};

Graph.prototype.setPath = function(vs, value) {
  var self = this;
  var args = arguments;
  _.reduce(vs, function(v, w) {
    if (args.length > 1) {
      self.setEdge(v, w, value);
    } else {
      self.setEdge(v, w);
    }
    return w;
  });
  return this;
};

/*
 * setEdge(v, w, [value, [name]])
 * setEdge({ v, w, [name] }, [value])
 */
Graph.prototype.setEdge = function() {
  var v, w, name, value;
  var valueSpecified = false;
  var arg0 = arguments[0];

  if (typeof arg0 === "object" && arg0 !== null && "v" in arg0) {
    v = arg0.v;
    w = arg0.w;
    name = arg0.name;
    if (arguments.length === 2) {
      value = arguments[1];
      valueSpecified = true;
    }
  } else {
    v = arg0;
    w = arguments[1];
    name = arguments[3];
    if (arguments.length > 2) {
      value = arguments[2];
      valueSpecified = true;
    }
  }

  v = "" + v;
  w = "" + w;
  if (!_.isUndefined(name)) {
    name = "" + name;
  }

  var e = edgeArgsToId(this._isDirected, v, w, name);
  if (_.has(this._edgeLabels, e)) {
    if (valueSpecified) {
      this._edgeLabels[e] = value;
    }
    return this;
  }

  if (!_.isUndefined(name) && !this._isMultigraph) {
    throw new Error("Cannot set a named edge when isMultigraph = false");
  }

  // It didn't exist, so we need to create it.
  // First ensure the nodes exist.
  this.setNode(v);
  this.setNode(w);

  this._edgeLabels[e] = valueSpecified ? value : this._defaultEdgeLabelFn(v, w, name);

  var edgeObj = edgeArgsToObj(this._isDirected, v, w, name);
  // Ensure we add undirected edges in a consistent way.
  v = edgeObj.v;
  w = edgeObj.w;

  Object.freeze(edgeObj);
  this._edgeObjs[e] = edgeObj;
  incrementOrInitEntry(this._preds[w], v);
  incrementOrInitEntry(this._sucs[v], w);
  this._in[w][e] = edgeObj;
  this._out[v][e] = edgeObj;
  this._edgeCount++;
  return this;
};

Graph.prototype.edge = function(v, w, name) {
  var e = (arguments.length === 1
    ? edgeObjToId(this._isDirected, arguments[0])
    : edgeArgsToId(this._isDirected, v, w, name));
  return this._edgeLabels[e];
};

Graph.prototype.hasEdge = function(v, w, name) {
  var e = (arguments.length === 1
    ? edgeObjToId(this._isDirected, arguments[0])
    : edgeArgsToId(this._isDirected, v, w, name));
  return _.has(this._edgeLabels, e);
};

Graph.prototype.removeEdge = function(v, w, name) {
  var e = (arguments.length === 1
    ? edgeObjToId(this._isDirected, arguments[0])
    : edgeArgsToId(this._isDirected, v, w, name));
  var edge = this._edgeObjs[e];
  if (edge) {
    v = edge.v;
    w = edge.w;
    delete this._edgeLabels[e];
    delete this._edgeObjs[e];
    decrementOrRemoveEntry(this._preds[w], v);
    decrementOrRemoveEntry(this._sucs[v], w);
    delete this._in[w][e];
    delete this._out[v][e];
    this._edgeCount--;
  }
  return this;
};

Graph.prototype.inEdges = function(v, u) {
  var inV = this._in[v];
  if (inV) {
    var edges = _.values(inV);
    if (!u) {
      return edges;
    }
    return _.filter(edges, function(edge) { return edge.v === u; });
  }
};

Graph.prototype.outEdges = function(v, w) {
  var outV = this._out[v];
  if (outV) {
    var edges = _.values(outV);
    if (!w) {
      return edges;
    }
    return _.filter(edges, function(edge) { return edge.w === w; });
  }
};

Graph.prototype.nodeEdges = function(v, w) {
  var inEdges = this.inEdges(v, w);
  if (inEdges) {
    return inEdges.concat(this.outEdges(v, w));
  }
};

function incrementOrInitEntry(map, k) {
  if (map[k]) {
    map[k]++;
  } else {
    map[k] = 1;
  }
}

function decrementOrRemoveEntry(map, k) {
  if (!--map[k]) { delete map[k]; }
}

function edgeArgsToId(isDirected, v_, w_, name) {
  var v = "" + v_;
  var w = "" + w_;
  if (!isDirected && v > w) {
    var tmp = v;
    v = w;
    w = tmp;
  }
  return v + EDGE_KEY_DELIM + w + EDGE_KEY_DELIM +
             (_.isUndefined(name) ? DEFAULT_EDGE_NAME : name);
}

function edgeArgsToObj(isDirected, v_, w_, name) {
  var v = "" + v_;
  var w = "" + w_;
  if (!isDirected && v > w) {
    var tmp = v;
    v = w;
    w = tmp;
  }
  var edgeObj =  { v: v, w: w };
  if (name) {
    edgeObj.name = name;
  }
  return edgeObj;
}

function edgeObjToId(isDirected, edgeObj) {
  return edgeArgsToId(isDirected, edgeObj.v, edgeObj.w, edgeObj.name);
}


/***/ }),

/***/ "./node_modules/graphlib/lib/index.js":
/*!********************************************!*\
  !*** ./node_modules/graphlib/lib/index.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// Includes only the "core" of graphlib
module.exports = {
  Graph: __webpack_require__(/*! ./graph */ "./node_modules/graphlib/lib/graph.js"),
  version: __webpack_require__(/*! ./version */ "./node_modules/graphlib/lib/version.js")
};


/***/ }),

/***/ "./node_modules/graphlib/lib/json.js":
/*!*******************************************!*\
  !*** ./node_modules/graphlib/lib/json.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var _ = __webpack_require__(/*! ./lodash */ "./node_modules/graphlib/lib/lodash.js");
var Graph = __webpack_require__(/*! ./graph */ "./node_modules/graphlib/lib/graph.js");

module.exports = {
  write: write,
  read: read
};

function write(g) {
  var json = {
    options: {
      directed: g.isDirected(),
      multigraph: g.isMultigraph(),
      compound: g.isCompound()
    },
    nodes: writeNodes(g),
    edges: writeEdges(g)
  };
  if (!_.isUndefined(g.graph())) {
    json.value = _.clone(g.graph());
  }
  return json;
}

function writeNodes(g) {
  return _.map(g.nodes(), function(v) {
    var nodeValue = g.node(v);
    var parent = g.parent(v);
    var node = { v: v };
    if (!_.isUndefined(nodeValue)) {
      node.value = nodeValue;
    }
    if (!_.isUndefined(parent)) {
      node.parent = parent;
    }
    return node;
  });
}

function writeEdges(g) {
  return _.map(g.edges(), function(e) {
    var edgeValue = g.edge(e);
    var edge = { v: e.v, w: e.w };
    if (!_.isUndefined(e.name)) {
      edge.name = e.name;
    }
    if (!_.isUndefined(edgeValue)) {
      edge.value = edgeValue;
    }
    return edge;
  });
}

function read(json) {
  var g = new Graph(json.options).setGraph(json.value);
  _.each(json.nodes, function(entry) {
    g.setNode(entry.v, entry.value);
    if (entry.parent) {
      g.setParent(entry.v, entry.parent);
    }
  });
  _.each(json.edges, function(entry) {
    g.setEdge({ v: entry.v, w: entry.w, name: entry.name }, entry.value);
  });
  return g;
}


/***/ }),

/***/ "./node_modules/graphlib/lib/lodash.js":
/*!*********************************************!*\
  !*** ./node_modules/graphlib/lib/lodash.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/* global window */

var lodash;

if (true) {
  try {
    lodash = {
      clone: __webpack_require__(/*! lodash/clone */ "./node_modules/lodash/clone.js"),
      constant: __webpack_require__(/*! lodash/constant */ "./node_modules/lodash/constant.js"),
      each: __webpack_require__(/*! lodash/each */ "./node_modules/lodash/each.js"),
      filter: __webpack_require__(/*! lodash/filter */ "./node_modules/lodash/filter.js"),
      has:  __webpack_require__(/*! lodash/has */ "./node_modules/lodash/has.js"),
      isArray: __webpack_require__(/*! lodash/isArray */ "./node_modules/lodash/isArray.js"),
      isEmpty: __webpack_require__(/*! lodash/isEmpty */ "./node_modules/lodash/isEmpty.js"),
      isFunction: __webpack_require__(/*! lodash/isFunction */ "./node_modules/lodash/isFunction.js"),
      isUndefined: __webpack_require__(/*! lodash/isUndefined */ "./node_modules/lodash/isUndefined.js"),
      keys: __webpack_require__(/*! lodash/keys */ "./node_modules/lodash/keys.js"),
      map: __webpack_require__(/*! lodash/map */ "./node_modules/lodash/map.js"),
      reduce: __webpack_require__(/*! lodash/reduce */ "./node_modules/lodash/reduce.js"),
      size: __webpack_require__(/*! lodash/size */ "./node_modules/lodash/size.js"),
      transform: __webpack_require__(/*! lodash/transform */ "./node_modules/lodash/transform.js"),
      union: __webpack_require__(/*! lodash/union */ "./node_modules/lodash/union.js"),
      values: __webpack_require__(/*! lodash/values */ "./node_modules/lodash/values.js")
    };
  } catch (e) {
    // continue regardless of error
  }
}

if (!lodash) {
  lodash = window._;
}

module.exports = lodash;


/***/ }),

/***/ "./node_modules/graphlib/lib/version.js":
/*!**********************************************!*\
  !*** ./node_modules/graphlib/lib/version.js ***!
  \**********************************************/
/***/ ((module) => {

module.exports = '2.1.8';


/***/ }),

/***/ "./node_modules/lits-extras/lib/dependency-diag.js":
/*!*********************************************************!*\
  !*** ./node_modules/lits-extras/lib/dependency-diag.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.createDependencyDiagram = void 0;
const tt = __webpack_require__(/*! taitto */ "./node_modules/taitto/lib/index.js");
let svg = tt.svg;
let arrow = {
    closed: false,
    className: "arrow",
    positions: [tt.ArrowPos.Destination],
    width: 5,
    length: 5
};
async function loadDependencies(url) {
    let resp = await fetch(url);
    return resp.ok ? JSON.parse(await resp.text()) : null;
}
async function createDependencyDiagram(params, parent) {
    let pars = params.split(/\s+/);
    let url = pars[0];
    let filter = pars[1] && new RegExp(pars[1]);
    let redir = url.substr(0, url.lastIndexOf("/"));
    let dgraph = await loadDependencies(url);
    if (!dgraph)
        throw Error(`Could not load dependency graph from "${url}"`);
    else {
        let modules = Object.getOwnPropertyNames(dgraph)
            .filter(n => !filter || n.match(filter));
        let nodes = modules.map(name => {
            let module = dgraph[name];
            let node = {
                name,
                label: name,
                link: module.url ? redir + "/" + module.url : undefined,
                shape: (p, x, y, w, h) => svg.rect(p, x, y, w, h, 8, 8)
            };
            module.node = node;
            return node;
        });
        let edges = tt.edges(modules.map(name => dgraph[name].dependencies.filter(dep => dgraph[dep].node)
            .map(dep => [dgraph[name].node, dgraph[dep].node]))
            .reduce((a, b) => a.concat(b)), arrow);
        tt.digraph({
            nodes,
            edges,
            direction: 'LR',
            curvedEdges: true,
            ranksep: 16,
            nodesep: 32
        }, parent);
    }
}
exports.createDependencyDiagram = createDependencyDiagram;
//# sourceMappingURL=dependency-diag.js.map

/***/ }),

/***/ "./node_modules/lits-extras/lib/index.js":
/*!***********************************************!*\
  !*** ./node_modules/lits-extras/lib/index.js ***!
  \***********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
__exportStar(__webpack_require__(/*! ./dependency-diag */ "./node_modules/lits-extras/lib/dependency-diag.js"), exports);
__exportStar(__webpack_require__(/*! ./test-visualizer */ "./node_modules/lits-extras/lib/test-visualizer.js"), exports);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/lits-extras/lib/test-reporter.js":
/*!*******************************************************!*\
  !*** ./node_modules/lits-extras/lib/test-reporter.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.createReporter = void 0;
function createTest(name) {
    return {
        name,
        passes: 0,
        fails: 0,
        duration: 0,
        tests: [],
        assertions: []
    };
}
function createReporter(name, render) {
    let rootTest = createTest(name);
    let teststack = [rootTest];
    return async (stream) => {
        for await (let message of stream) {
            switch (message.type) {
                case "TEST_START" /* TEST_START */:
                    let newtest = createTest(message
                        .data.description);
                    teststack[teststack.length - 1].tests.push(newtest);
                    teststack.push(newtest);
                    break;
                case "TEST_END" /* TEST_END */:
                    let ztest = message.data;
                    let test = teststack.pop();
                    test.pass = ztest.pass;
                    test.passes = ztest.successCount;
                    test.fails = ztest.failureCount;
                    test.error = ztest.error;
                    test.duration = ztest.executionTime;
                    render(rootTest);
                    break;
                case "ASSERTION" /* ASSERTION */:
                    let zass = message.data;
                    teststack[teststack.length - 1].assertions.push({
                        name: zass.description,
                        pass: zass.pass
                    });
                    break;
                case "BAIL_OUT" /* BAIL_OUT */:
                    teststack[teststack.length - 1].error =
                        message.data;
                    render(rootTest);
                    break;
            }
        }
    };
}
exports.createReporter = createReporter;
//# sourceMappingURL=test-reporter.js.map

/***/ }),

/***/ "./node_modules/lits-extras/lib/test-visualizer.js":
/*!*********************************************************!*\
  !*** ./node_modules/lits-extras/lib/test-visualizer.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.runTests = void 0;
const tr = __webpack_require__(/*! ./test-reporter */ "./node_modules/lits-extras/lib/test-reporter.js");
const tester = __webpack_require__(/*! ./tester */ "./node_modules/lits-extras/lib/tester.js");
function runTests(params, parent) {
    window.addEventListener('load', () => tester.getHarness().report(tr.createReporter(params, status => {
        while (parent.firstChild)
            parent.firstChild.remove();
        parent.appendChild(testStatus(status));
    })));
}
exports.runTests = runTests;
function elem(tagName, cls, text) {
    let res = document.createElement(tagName);
    if (cls)
        res.classList.add(cls);
    if (text)
        res.innerText = text;
    return res;
}
function statusIcon(assertion) {
    return assertion.pass ? "" : "";
}
function testStyle(test) {
    return test.pass ? '#f8fff8' : '#fff8f8';
}
function testStatus(rootTest) {
    let vis = elem("div", "test-visualizer");
    vis.style.backgroundColor = testStyle(rootTest);
    let sum = elem("div", "summary", `${statusIcon(rootTest)} ${rootTest.name}`);
    sum.appendChild(elem("span", "count", `Pass: ${rootTest.passes}`));
    sum.appendChild(elem("span", "count", `Fail: ${rootTest.fails}`));
    vis.appendChild(sum);
    vis.appendChild(testList(rootTest.tests));
    return vis;
}
function testList(tests) {
    let lst = elem("ol", "test-list");
    for (let i = 0; i < tests.length; i++)
        lst.appendChild(test(tests[i]));
    return lst;
}
function assertion(assertion) {
    return elem("li", undefined, `${statusIcon(assertion)} ${assertion.name}`);
}
function assertions(assertions) {
    let det = elem("details");
    det.appendChild(elem("summary", undefined, `${assertions.length} assertions`));
    let ol = elem("ol");
    for (let i = 0; i < assertions.length; i++)
        ol.appendChild(assertion(assertions[i]));
    det.appendChild(ol);
    return det;
}
function test(test) {
    if (test.error)
        return bailedOutTest(test);
    let li = elem("li", undefined, `${statusIcon(test)} ${test.name} in ${test.duration}ms`);
    if (test.assertions)
        li.appendChild(assertions(test.assertions));
    if (test.tests)
        li.appendChild(testList(test.tests));
    return li;
}
function bailedOutTest(test) {
    let res = document.createElement("li");
    res.innerHTML =
        `${statusIcon(test)} ${test.name} threw <b>${test.error.name}</b> exception:
        <br/><b>${test.error.message}</b>
        <pre>${test.error.stack}</pre>`;
    return res;
}
//# sourceMappingURL=test-visualizer.js.map

/***/ }),

/***/ "./node_modules/lits-extras/lib/tester.js":
/*!************************************************!*\
  !*** ./node_modules/lits-extras/lib/tester.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.test = exports.getHarness = void 0;
const zora = __webpack_require__(/*! zora */ "./node_modules/zora/dist/bundle/index.js");
let harness = zora.createHarness();
if (typeof window === 'undefined')
    setTimeout(runTests, 0);
function getHarness() {
    return harness;
}
exports.getHarness = getHarness;
async function runTests() {
    try {
        await harness.report(zora.mochaTapLike);
    }
    catch (e) {
        harness.pass = false;
        if (e instanceof Error) {
            console.error(e.name + " exception thrown: " + e.message);
            console.error(e.stack);
        }
    }
    if (harness.pass)
        console.log('Tests PASSED');
    else
        console.log('Tests FAILED');
    process.exit(harness.pass ? 0 : 1);
}
function test(description, spec, options) {
    return harness.test(description, spec, options);
}
exports.test = test;
//# sourceMappingURL=tester.js.map

/***/ }),

/***/ "./node_modules/litscript/lib/visualizer.js":
/*!**************************************************!*\
  !*** ./node_modules/litscript/lib/visualizer.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.error = exports.console = exports.html = exports.registerVisualizer = void 0;
const visualizers = {};
/**
 * ## Registering Visualizers
 *
 * Before you can use a visualizer you need to register it using the function
 * below. Another step that is required is to specify the file where the
 * visualizer resides in the `codeFile` setting of the front matter. The code
 * file can import other modules and it might be written in JavaScript or
 * TypeScript. The bundler transpiles TS modules to JS and packs them to a
 * single file.
 */
function registerVisualizer(name, visual) {
    if (name.match(/\s/))
        throw SyntaxError(`Visualizer name "${name}" contains whitespace.`);
    visualizers[name] = visual;
}
exports.registerVisualizer = registerVisualizer;
/**
 * ## Creating Visualizers
 *
 * It is possible to create your visualizers from scratch by defining a
 * function that implements the signature defined above. However, usually
 * it is easier to use some of the helper functions defined below.
 *
 * The first helper creates a new HTML elemenent and places it under the
 * parent element. You can specify the type of the element, its attributes,
 * and a function that returns the content inside the element. The content
 * is assumed to contain a valid HTML string.
 */
function html(render, tag, attrs) {
    return (input, parent) => {
        let res = document.createElement(tag);
        for (let attr in attrs)
            if (attrs.hasOwnProperty(attr))
                res.setAttribute(attr, attrs[attr]);
        res.innerHTML = render(input);
        parent.appendChild(res);
    };
}
exports.html = html;
/**
 * Armed with the `html` function we can define more helpers that output
 * the result of a function in a specific element with a specific style.
 * The first one shows the result inside a `<pre>` tag which is styled
 * as console ouput.
 */
function console(output) {
    return html(output, 'pre', { class: "console" });
}
exports.console = console;
/**
 * The second function shows a styled error message. The style used here
 * is defined in the default template. It is possible also to import your
 * own style sheets (Less or CSS) in the code files you include. They are
 * separated, compiled and packed by the bundler.
 */
function error(message) {
    return html(_ => message, 'div', { class: "error" });
}
exports.error = error;
/**
 * ## Running Visualizers
 *
 * The `runVisualizer` function is exported as a property of the `window`
 * object. It runs the named visualizer with the given parameters. LiTScript
 * generates code that calls this function from a HTML page.
 */
async function runVisualizer(name, params, parentId) {
    let parent = document.getElementById(parentId);
    if (!parent)
        throw Error(`Visualizer parent id "${parentId}" not found.`);
    let visualize = visualizers[name] ||
        error(`Visualizer "${name}" is not registered.`);
    try {
        await visualize(params, parent);
    }
    catch (e) {
        error(`Exception thrown by visualizer "${name}".<BR/>
        ${e.toString()}`)("", parent);
    }
}
if (typeof window !== 'undefined')
    window["runVisualizer"] = runVisualizer;
//# sourceMappingURL=visualizer.js.map

/***/ }),

/***/ "./node_modules/lodash/_DataView.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/_DataView.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var getNative = __webpack_require__(/*! ./_getNative */ "./node_modules/lodash/_getNative.js"),
    root = __webpack_require__(/*! ./_root */ "./node_modules/lodash/_root.js");

/* Built-in method references that are verified to be native. */
var DataView = getNative(root, 'DataView');

module.exports = DataView;


/***/ }),

/***/ "./node_modules/lodash/_Hash.js":
/*!**************************************!*\
  !*** ./node_modules/lodash/_Hash.js ***!
  \**************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var hashClear = __webpack_require__(/*! ./_hashClear */ "./node_modules/lodash/_hashClear.js"),
    hashDelete = __webpack_require__(/*! ./_hashDelete */ "./node_modules/lodash/_hashDelete.js"),
    hashGet = __webpack_require__(/*! ./_hashGet */ "./node_modules/lodash/_hashGet.js"),
    hashHas = __webpack_require__(/*! ./_hashHas */ "./node_modules/lodash/_hashHas.js"),
    hashSet = __webpack_require__(/*! ./_hashSet */ "./node_modules/lodash/_hashSet.js");

/**
 * Creates a hash object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Hash(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

// Add methods to `Hash`.
Hash.prototype.clear = hashClear;
Hash.prototype['delete'] = hashDelete;
Hash.prototype.get = hashGet;
Hash.prototype.has = hashHas;
Hash.prototype.set = hashSet;

module.exports = Hash;


/***/ }),

/***/ "./node_modules/lodash/_ListCache.js":
/*!*******************************************!*\
  !*** ./node_modules/lodash/_ListCache.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var listCacheClear = __webpack_require__(/*! ./_listCacheClear */ "./node_modules/lodash/_listCacheClear.js"),
    listCacheDelete = __webpack_require__(/*! ./_listCacheDelete */ "./node_modules/lodash/_listCacheDelete.js"),
    listCacheGet = __webpack_require__(/*! ./_listCacheGet */ "./node_modules/lodash/_listCacheGet.js"),
    listCacheHas = __webpack_require__(/*! ./_listCacheHas */ "./node_modules/lodash/_listCacheHas.js"),
    listCacheSet = __webpack_require__(/*! ./_listCacheSet */ "./node_modules/lodash/_listCacheSet.js");

/**
 * Creates an list cache object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function ListCache(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

// Add methods to `ListCache`.
ListCache.prototype.clear = listCacheClear;
ListCache.prototype['delete'] = listCacheDelete;
ListCache.prototype.get = listCacheGet;
ListCache.prototype.has = listCacheHas;
ListCache.prototype.set = listCacheSet;

module.exports = ListCache;


/***/ }),

/***/ "./node_modules/lodash/_Map.js":
/*!*************************************!*\
  !*** ./node_modules/lodash/_Map.js ***!
  \*************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var getNative = __webpack_require__(/*! ./_getNative */ "./node_modules/lodash/_getNative.js"),
    root = __webpack_require__(/*! ./_root */ "./node_modules/lodash/_root.js");

/* Built-in method references that are verified to be native. */
var Map = getNative(root, 'Map');

module.exports = Map;


/***/ }),

/***/ "./node_modules/lodash/_MapCache.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/_MapCache.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var mapCacheClear = __webpack_require__(/*! ./_mapCacheClear */ "./node_modules/lodash/_mapCacheClear.js"),
    mapCacheDelete = __webpack_require__(/*! ./_mapCacheDelete */ "./node_modules/lodash/_mapCacheDelete.js"),
    mapCacheGet = __webpack_require__(/*! ./_mapCacheGet */ "./node_modules/lodash/_mapCacheGet.js"),
    mapCacheHas = __webpack_require__(/*! ./_mapCacheHas */ "./node_modules/lodash/_mapCacheHas.js"),
    mapCacheSet = __webpack_require__(/*! ./_mapCacheSet */ "./node_modules/lodash/_mapCacheSet.js");

/**
 * Creates a map cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function MapCache(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

// Add methods to `MapCache`.
MapCache.prototype.clear = mapCacheClear;
MapCache.prototype['delete'] = mapCacheDelete;
MapCache.prototype.get = mapCacheGet;
MapCache.prototype.has = mapCacheHas;
MapCache.prototype.set = mapCacheSet;

module.exports = MapCache;


/***/ }),

/***/ "./node_modules/lodash/_Promise.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/_Promise.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var getNative = __webpack_require__(/*! ./_getNative */ "./node_modules/lodash/_getNative.js"),
    root = __webpack_require__(/*! ./_root */ "./node_modules/lodash/_root.js");

/* Built-in method references that are verified to be native. */
var Promise = getNative(root, 'Promise');

module.exports = Promise;


/***/ }),

/***/ "./node_modules/lodash/_Set.js":
/*!*************************************!*\
  !*** ./node_modules/lodash/_Set.js ***!
  \*************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var getNative = __webpack_require__(/*! ./_getNative */ "./node_modules/lodash/_getNative.js"),
    root = __webpack_require__(/*! ./_root */ "./node_modules/lodash/_root.js");

/* Built-in method references that are verified to be native. */
var Set = getNative(root, 'Set');

module.exports = Set;


/***/ }),

/***/ "./node_modules/lodash/_SetCache.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/_SetCache.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var MapCache = __webpack_require__(/*! ./_MapCache */ "./node_modules/lodash/_MapCache.js"),
    setCacheAdd = __webpack_require__(/*! ./_setCacheAdd */ "./node_modules/lodash/_setCacheAdd.js"),
    setCacheHas = __webpack_require__(/*! ./_setCacheHas */ "./node_modules/lodash/_setCacheHas.js");

/**
 *
 * Creates an array cache object to store unique values.
 *
 * @private
 * @constructor
 * @param {Array} [values] The values to cache.
 */
function SetCache(values) {
  var index = -1,
      length = values == null ? 0 : values.length;

  this.__data__ = new MapCache;
  while (++index < length) {
    this.add(values[index]);
  }
}

// Add methods to `SetCache`.
SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
SetCache.prototype.has = setCacheHas;

module.exports = SetCache;


/***/ }),

/***/ "./node_modules/lodash/_Stack.js":
/*!***************************************!*\
  !*** ./node_modules/lodash/_Stack.js ***!
  \***************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var ListCache = __webpack_require__(/*! ./_ListCache */ "./node_modules/lodash/_ListCache.js"),
    stackClear = __webpack_require__(/*! ./_stackClear */ "./node_modules/lodash/_stackClear.js"),
    stackDelete = __webpack_require__(/*! ./_stackDelete */ "./node_modules/lodash/_stackDelete.js"),
    stackGet = __webpack_require__(/*! ./_stackGet */ "./node_modules/lodash/_stackGet.js"),
    stackHas = __webpack_require__(/*! ./_stackHas */ "./node_modules/lodash/_stackHas.js"),
    stackSet = __webpack_require__(/*! ./_stackSet */ "./node_modules/lodash/_stackSet.js");

/**
 * Creates a stack cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Stack(entries) {
  var data = this.__data__ = new ListCache(entries);
  this.size = data.size;
}

// Add methods to `Stack`.
Stack.prototype.clear = stackClear;
Stack.prototype['delete'] = stackDelete;
Stack.prototype.get = stackGet;
Stack.prototype.has = stackHas;
Stack.prototype.set = stackSet;

module.exports = Stack;


/***/ }),

/***/ "./node_modules/lodash/_Symbol.js":
/*!****************************************!*\
  !*** ./node_modules/lodash/_Symbol.js ***!
  \****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var root = __webpack_require__(/*! ./_root */ "./node_modules/lodash/_root.js");

/** Built-in value references. */
var Symbol = root.Symbol;

module.exports = Symbol;


/***/ }),

/***/ "./node_modules/lodash/_Uint8Array.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_Uint8Array.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var root = __webpack_require__(/*! ./_root */ "./node_modules/lodash/_root.js");

/** Built-in value references. */
var Uint8Array = root.Uint8Array;

module.exports = Uint8Array;


/***/ }),

/***/ "./node_modules/lodash/_WeakMap.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/_WeakMap.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var getNative = __webpack_require__(/*! ./_getNative */ "./node_modules/lodash/_getNative.js"),
    root = __webpack_require__(/*! ./_root */ "./node_modules/lodash/_root.js");

/* Built-in method references that are verified to be native. */
var WeakMap = getNative(root, 'WeakMap');

module.exports = WeakMap;


/***/ }),

/***/ "./node_modules/lodash/_apply.js":
/*!***************************************!*\
  !*** ./node_modules/lodash/_apply.js ***!
  \***************************************/
/***/ ((module) => {

/**
 * A faster alternative to `Function#apply`, this function invokes `func`
 * with the `this` binding of `thisArg` and the arguments of `args`.
 *
 * @private
 * @param {Function} func The function to invoke.
 * @param {*} thisArg The `this` binding of `func`.
 * @param {Array} args The arguments to invoke `func` with.
 * @returns {*} Returns the result of `func`.
 */
function apply(func, thisArg, args) {
  switch (args.length) {
    case 0: return func.call(thisArg);
    case 1: return func.call(thisArg, args[0]);
    case 2: return func.call(thisArg, args[0], args[1]);
    case 3: return func.call(thisArg, args[0], args[1], args[2]);
  }
  return func.apply(thisArg, args);
}

module.exports = apply;


/***/ }),

/***/ "./node_modules/lodash/_arrayEach.js":
/*!*******************************************!*\
  !*** ./node_modules/lodash/_arrayEach.js ***!
  \*******************************************/
/***/ ((module) => {

/**
 * A specialized version of `_.forEach` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns `array`.
 */
function arrayEach(array, iteratee) {
  var index = -1,
      length = array == null ? 0 : array.length;

  while (++index < length) {
    if (iteratee(array[index], index, array) === false) {
      break;
    }
  }
  return array;
}

module.exports = arrayEach;


/***/ }),

/***/ "./node_modules/lodash/_arrayFilter.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash/_arrayFilter.js ***!
  \*********************************************/
/***/ ((module) => {

/**
 * A specialized version of `_.filter` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} predicate The function invoked per iteration.
 * @returns {Array} Returns the new filtered array.
 */
function arrayFilter(array, predicate) {
  var index = -1,
      length = array == null ? 0 : array.length,
      resIndex = 0,
      result = [];

  while (++index < length) {
    var value = array[index];
    if (predicate(value, index, array)) {
      result[resIndex++] = value;
    }
  }
  return result;
}

module.exports = arrayFilter;


/***/ }),

/***/ "./node_modules/lodash/_arrayIncludes.js":
/*!***********************************************!*\
  !*** ./node_modules/lodash/_arrayIncludes.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseIndexOf = __webpack_require__(/*! ./_baseIndexOf */ "./node_modules/lodash/_baseIndexOf.js");

/**
 * A specialized version of `_.includes` for arrays without support for
 * specifying an index to search from.
 *
 * @private
 * @param {Array} [array] The array to inspect.
 * @param {*} target The value to search for.
 * @returns {boolean} Returns `true` if `target` is found, else `false`.
 */
function arrayIncludes(array, value) {
  var length = array == null ? 0 : array.length;
  return !!length && baseIndexOf(array, value, 0) > -1;
}

module.exports = arrayIncludes;


/***/ }),

/***/ "./node_modules/lodash/_arrayIncludesWith.js":
/*!***************************************************!*\
  !*** ./node_modules/lodash/_arrayIncludesWith.js ***!
  \***************************************************/
/***/ ((module) => {

/**
 * This function is like `arrayIncludes` except that it accepts a comparator.
 *
 * @private
 * @param {Array} [array] The array to inspect.
 * @param {*} target The value to search for.
 * @param {Function} comparator The comparator invoked per element.
 * @returns {boolean} Returns `true` if `target` is found, else `false`.
 */
function arrayIncludesWith(array, value, comparator) {
  var index = -1,
      length = array == null ? 0 : array.length;

  while (++index < length) {
    if (comparator(value, array[index])) {
      return true;
    }
  }
  return false;
}

module.exports = arrayIncludesWith;


/***/ }),

/***/ "./node_modules/lodash/_arrayLikeKeys.js":
/*!***********************************************!*\
  !*** ./node_modules/lodash/_arrayLikeKeys.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseTimes = __webpack_require__(/*! ./_baseTimes */ "./node_modules/lodash/_baseTimes.js"),
    isArguments = __webpack_require__(/*! ./isArguments */ "./node_modules/lodash/isArguments.js"),
    isArray = __webpack_require__(/*! ./isArray */ "./node_modules/lodash/isArray.js"),
    isBuffer = __webpack_require__(/*! ./isBuffer */ "./node_modules/lodash/isBuffer.js"),
    isIndex = __webpack_require__(/*! ./_isIndex */ "./node_modules/lodash/_isIndex.js"),
    isTypedArray = __webpack_require__(/*! ./isTypedArray */ "./node_modules/lodash/isTypedArray.js");

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Creates an array of the enumerable property names of the array-like `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @param {boolean} inherited Specify returning inherited property names.
 * @returns {Array} Returns the array of property names.
 */
function arrayLikeKeys(value, inherited) {
  var isArr = isArray(value),
      isArg = !isArr && isArguments(value),
      isBuff = !isArr && !isArg && isBuffer(value),
      isType = !isArr && !isArg && !isBuff && isTypedArray(value),
      skipIndexes = isArr || isArg || isBuff || isType,
      result = skipIndexes ? baseTimes(value.length, String) : [],
      length = result.length;

  for (var key in value) {
    if ((inherited || hasOwnProperty.call(value, key)) &&
        !(skipIndexes && (
           // Safari 9 has enumerable `arguments.length` in strict mode.
           key == 'length' ||
           // Node.js 0.10 has enumerable non-index properties on buffers.
           (isBuff && (key == 'offset' || key == 'parent')) ||
           // PhantomJS 2 has enumerable non-index properties on typed arrays.
           (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||
           // Skip index properties.
           isIndex(key, length)
        ))) {
      result.push(key);
    }
  }
  return result;
}

module.exports = arrayLikeKeys;


/***/ }),

/***/ "./node_modules/lodash/_arrayMap.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/_arrayMap.js ***!
  \******************************************/
/***/ ((module) => {

/**
 * A specialized version of `_.map` for arrays without support for iteratee
 * shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the new mapped array.
 */
function arrayMap(array, iteratee) {
  var index = -1,
      length = array == null ? 0 : array.length,
      result = Array(length);

  while (++index < length) {
    result[index] = iteratee(array[index], index, array);
  }
  return result;
}

module.exports = arrayMap;


/***/ }),

/***/ "./node_modules/lodash/_arrayPush.js":
/*!*******************************************!*\
  !*** ./node_modules/lodash/_arrayPush.js ***!
  \*******************************************/
/***/ ((module) => {

/**
 * Appends the elements of `values` to `array`.
 *
 * @private
 * @param {Array} array The array to modify.
 * @param {Array} values The values to append.
 * @returns {Array} Returns `array`.
 */
function arrayPush(array, values) {
  var index = -1,
      length = values.length,
      offset = array.length;

  while (++index < length) {
    array[offset + index] = values[index];
  }
  return array;
}

module.exports = arrayPush;


/***/ }),

/***/ "./node_modules/lodash/_arrayReduce.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash/_arrayReduce.js ***!
  \*********************************************/
/***/ ((module) => {

/**
 * A specialized version of `_.reduce` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @param {*} [accumulator] The initial value.
 * @param {boolean} [initAccum] Specify using the first element of `array` as
 *  the initial value.
 * @returns {*} Returns the accumulated value.
 */
function arrayReduce(array, iteratee, accumulator, initAccum) {
  var index = -1,
      length = array == null ? 0 : array.length;

  if (initAccum && length) {
    accumulator = array[++index];
  }
  while (++index < length) {
    accumulator = iteratee(accumulator, array[index], index, array);
  }
  return accumulator;
}

module.exports = arrayReduce;


/***/ }),

/***/ "./node_modules/lodash/_arraySome.js":
/*!*******************************************!*\
  !*** ./node_modules/lodash/_arraySome.js ***!
  \*******************************************/
/***/ ((module) => {

/**
 * A specialized version of `_.some` for arrays without support for iteratee
 * shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} predicate The function invoked per iteration.
 * @returns {boolean} Returns `true` if any element passes the predicate check,
 *  else `false`.
 */
function arraySome(array, predicate) {
  var index = -1,
      length = array == null ? 0 : array.length;

  while (++index < length) {
    if (predicate(array[index], index, array)) {
      return true;
    }
  }
  return false;
}

module.exports = arraySome;


/***/ }),

/***/ "./node_modules/lodash/_asciiSize.js":
/*!*******************************************!*\
  !*** ./node_modules/lodash/_asciiSize.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseProperty = __webpack_require__(/*! ./_baseProperty */ "./node_modules/lodash/_baseProperty.js");

/**
 * Gets the size of an ASCII `string`.
 *
 * @private
 * @param {string} string The string inspect.
 * @returns {number} Returns the string size.
 */
var asciiSize = baseProperty('length');

module.exports = asciiSize;


/***/ }),

/***/ "./node_modules/lodash/_assignMergeValue.js":
/*!**************************************************!*\
  !*** ./node_modules/lodash/_assignMergeValue.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseAssignValue = __webpack_require__(/*! ./_baseAssignValue */ "./node_modules/lodash/_baseAssignValue.js"),
    eq = __webpack_require__(/*! ./eq */ "./node_modules/lodash/eq.js");

/**
 * This function is like `assignValue` except that it doesn't assign
 * `undefined` values.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */
function assignMergeValue(object, key, value) {
  if ((value !== undefined && !eq(object[key], value)) ||
      (value === undefined && !(key in object))) {
    baseAssignValue(object, key, value);
  }
}

module.exports = assignMergeValue;


/***/ }),

/***/ "./node_modules/lodash/_assignValue.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash/_assignValue.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseAssignValue = __webpack_require__(/*! ./_baseAssignValue */ "./node_modules/lodash/_baseAssignValue.js"),
    eq = __webpack_require__(/*! ./eq */ "./node_modules/lodash/eq.js");

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Assigns `value` to `key` of `object` if the existing value is not equivalent
 * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * for equality comparisons.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */
function assignValue(object, key, value) {
  var objValue = object[key];
  if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) ||
      (value === undefined && !(key in object))) {
    baseAssignValue(object, key, value);
  }
}

module.exports = assignValue;


/***/ }),

/***/ "./node_modules/lodash/_assocIndexOf.js":
/*!**********************************************!*\
  !*** ./node_modules/lodash/_assocIndexOf.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var eq = __webpack_require__(/*! ./eq */ "./node_modules/lodash/eq.js");

/**
 * Gets the index at which the `key` is found in `array` of key-value pairs.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} key The key to search for.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function assocIndexOf(array, key) {
  var length = array.length;
  while (length--) {
    if (eq(array[length][0], key)) {
      return length;
    }
  }
  return -1;
}

module.exports = assocIndexOf;


/***/ }),

/***/ "./node_modules/lodash/_baseAssign.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_baseAssign.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var copyObject = __webpack_require__(/*! ./_copyObject */ "./node_modules/lodash/_copyObject.js"),
    keys = __webpack_require__(/*! ./keys */ "./node_modules/lodash/keys.js");

/**
 * The base implementation of `_.assign` without support for multiple sources
 * or `customizer` functions.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @returns {Object} Returns `object`.
 */
function baseAssign(object, source) {
  return object && copyObject(source, keys(source), object);
}

module.exports = baseAssign;


/***/ }),

/***/ "./node_modules/lodash/_baseAssignIn.js":
/*!**********************************************!*\
  !*** ./node_modules/lodash/_baseAssignIn.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var copyObject = __webpack_require__(/*! ./_copyObject */ "./node_modules/lodash/_copyObject.js"),
    keysIn = __webpack_require__(/*! ./keysIn */ "./node_modules/lodash/keysIn.js");

/**
 * The base implementation of `_.assignIn` without support for multiple sources
 * or `customizer` functions.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @returns {Object} Returns `object`.
 */
function baseAssignIn(object, source) {
  return object && copyObject(source, keysIn(source), object);
}

module.exports = baseAssignIn;


/***/ }),

/***/ "./node_modules/lodash/_baseAssignValue.js":
/*!*************************************************!*\
  !*** ./node_modules/lodash/_baseAssignValue.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var defineProperty = __webpack_require__(/*! ./_defineProperty */ "./node_modules/lodash/_defineProperty.js");

/**
 * The base implementation of `assignValue` and `assignMergeValue` without
 * value checks.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */
function baseAssignValue(object, key, value) {
  if (key == '__proto__' && defineProperty) {
    defineProperty(object, key, {
      'configurable': true,
      'enumerable': true,
      'value': value,
      'writable': true
    });
  } else {
    object[key] = value;
  }
}

module.exports = baseAssignValue;


/***/ }),

/***/ "./node_modules/lodash/_baseClone.js":
/*!*******************************************!*\
  !*** ./node_modules/lodash/_baseClone.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var Stack = __webpack_require__(/*! ./_Stack */ "./node_modules/lodash/_Stack.js"),
    arrayEach = __webpack_require__(/*! ./_arrayEach */ "./node_modules/lodash/_arrayEach.js"),
    assignValue = __webpack_require__(/*! ./_assignValue */ "./node_modules/lodash/_assignValue.js"),
    baseAssign = __webpack_require__(/*! ./_baseAssign */ "./node_modules/lodash/_baseAssign.js"),
    baseAssignIn = __webpack_require__(/*! ./_baseAssignIn */ "./node_modules/lodash/_baseAssignIn.js"),
    cloneBuffer = __webpack_require__(/*! ./_cloneBuffer */ "./node_modules/lodash/_cloneBuffer.js"),
    copyArray = __webpack_require__(/*! ./_copyArray */ "./node_modules/lodash/_copyArray.js"),
    copySymbols = __webpack_require__(/*! ./_copySymbols */ "./node_modules/lodash/_copySymbols.js"),
    copySymbolsIn = __webpack_require__(/*! ./_copySymbolsIn */ "./node_modules/lodash/_copySymbolsIn.js"),
    getAllKeys = __webpack_require__(/*! ./_getAllKeys */ "./node_modules/lodash/_getAllKeys.js"),
    getAllKeysIn = __webpack_require__(/*! ./_getAllKeysIn */ "./node_modules/lodash/_getAllKeysIn.js"),
    getTag = __webpack_require__(/*! ./_getTag */ "./node_modules/lodash/_getTag.js"),
    initCloneArray = __webpack_require__(/*! ./_initCloneArray */ "./node_modules/lodash/_initCloneArray.js"),
    initCloneByTag = __webpack_require__(/*! ./_initCloneByTag */ "./node_modules/lodash/_initCloneByTag.js"),
    initCloneObject = __webpack_require__(/*! ./_initCloneObject */ "./node_modules/lodash/_initCloneObject.js"),
    isArray = __webpack_require__(/*! ./isArray */ "./node_modules/lodash/isArray.js"),
    isBuffer = __webpack_require__(/*! ./isBuffer */ "./node_modules/lodash/isBuffer.js"),
    isMap = __webpack_require__(/*! ./isMap */ "./node_modules/lodash/isMap.js"),
    isObject = __webpack_require__(/*! ./isObject */ "./node_modules/lodash/isObject.js"),
    isSet = __webpack_require__(/*! ./isSet */ "./node_modules/lodash/isSet.js"),
    keys = __webpack_require__(/*! ./keys */ "./node_modules/lodash/keys.js"),
    keysIn = __webpack_require__(/*! ./keysIn */ "./node_modules/lodash/keysIn.js");

/** Used to compose bitmasks for cloning. */
var CLONE_DEEP_FLAG = 1,
    CLONE_FLAT_FLAG = 2,
    CLONE_SYMBOLS_FLAG = 4;

/** `Object#toString` result references. */
var argsTag = '[object Arguments]',
    arrayTag = '[object Array]',
    boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    errorTag = '[object Error]',
    funcTag = '[object Function]',
    genTag = '[object GeneratorFunction]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    objectTag = '[object Object]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    symbolTag = '[object Symbol]',
    weakMapTag = '[object WeakMap]';

var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]',
    float32Tag = '[object Float32Array]',
    float64Tag = '[object Float64Array]',
    int8Tag = '[object Int8Array]',
    int16Tag = '[object Int16Array]',
    int32Tag = '[object Int32Array]',
    uint8Tag = '[object Uint8Array]',
    uint8ClampedTag = '[object Uint8ClampedArray]',
    uint16Tag = '[object Uint16Array]',
    uint32Tag = '[object Uint32Array]';

/** Used to identify `toStringTag` values supported by `_.clone`. */
var cloneableTags = {};
cloneableTags[argsTag] = cloneableTags[arrayTag] =
cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] =
cloneableTags[boolTag] = cloneableTags[dateTag] =
cloneableTags[float32Tag] = cloneableTags[float64Tag] =
cloneableTags[int8Tag] = cloneableTags[int16Tag] =
cloneableTags[int32Tag] = cloneableTags[mapTag] =
cloneableTags[numberTag] = cloneableTags[objectTag] =
cloneableTags[regexpTag] = cloneableTags[setTag] =
cloneableTags[stringTag] = cloneableTags[symbolTag] =
cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] =
cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
cloneableTags[errorTag] = cloneableTags[funcTag] =
cloneableTags[weakMapTag] = false;

/**
 * The base implementation of `_.clone` and `_.cloneDeep` which tracks
 * traversed objects.
 *
 * @private
 * @param {*} value The value to clone.
 * @param {boolean} bitmask The bitmask flags.
 *  1 - Deep clone
 *  2 - Flatten inherited properties
 *  4 - Clone symbols
 * @param {Function} [customizer] The function to customize cloning.
 * @param {string} [key] The key of `value`.
 * @param {Object} [object] The parent object of `value`.
 * @param {Object} [stack] Tracks traversed objects and their clone counterparts.
 * @returns {*} Returns the cloned value.
 */
function baseClone(value, bitmask, customizer, key, object, stack) {
  var result,
      isDeep = bitmask & CLONE_DEEP_FLAG,
      isFlat = bitmask & CLONE_FLAT_FLAG,
      isFull = bitmask & CLONE_SYMBOLS_FLAG;

  if (customizer) {
    result = object ? customizer(value, key, object, stack) : customizer(value);
  }
  if (result !== undefined) {
    return result;
  }
  if (!isObject(value)) {
    return value;
  }
  var isArr = isArray(value);
  if (isArr) {
    result = initCloneArray(value);
    if (!isDeep) {
      return copyArray(value, result);
    }
  } else {
    var tag = getTag(value),
        isFunc = tag == funcTag || tag == genTag;

    if (isBuffer(value)) {
      return cloneBuffer(value, isDeep);
    }
    if (tag == objectTag || tag == argsTag || (isFunc && !object)) {
      result = (isFlat || isFunc) ? {} : initCloneObject(value);
      if (!isDeep) {
        return isFlat
          ? copySymbolsIn(value, baseAssignIn(result, value))
          : copySymbols(value, baseAssign(result, value));
      }
    } else {
      if (!cloneableTags[tag]) {
        return object ? value : {};
      }
      result = initCloneByTag(value, tag, isDeep);
    }
  }
  // Check for circular references and return its corresponding clone.
  stack || (stack = new Stack);
  var stacked = stack.get(value);
  if (stacked) {
    return stacked;
  }
  stack.set(value, result);

  if (isSet(value)) {
    value.forEach(function(subValue) {
      result.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
    });
  } else if (isMap(value)) {
    value.forEach(function(subValue, key) {
      result.set(key, baseClone(subValue, bitmask, customizer, key, value, stack));
    });
  }

  var keysFunc = isFull
    ? (isFlat ? getAllKeysIn : getAllKeys)
    : (isFlat ? keysIn : keys);

  var props = isArr ? undefined : keysFunc(value);
  arrayEach(props || value, function(subValue, key) {
    if (props) {
      key = subValue;
      subValue = value[key];
    }
    // Recursively populate clone (susceptible to call stack limits).
    assignValue(result, key, baseClone(subValue, bitmask, customizer, key, value, stack));
  });
  return result;
}

module.exports = baseClone;


/***/ }),

/***/ "./node_modules/lodash/_baseCreate.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_baseCreate.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var isObject = __webpack_require__(/*! ./isObject */ "./node_modules/lodash/isObject.js");

/** Built-in value references. */
var objectCreate = Object.create;

/**
 * The base implementation of `_.create` without support for assigning
 * properties to the created object.
 *
 * @private
 * @param {Object} proto The object to inherit from.
 * @returns {Object} Returns the new object.
 */
var baseCreate = (function() {
  function object() {}
  return function(proto) {
    if (!isObject(proto)) {
      return {};
    }
    if (objectCreate) {
      return objectCreate(proto);
    }
    object.prototype = proto;
    var result = new object;
    object.prototype = undefined;
    return result;
  };
}());

module.exports = baseCreate;


/***/ }),

/***/ "./node_modules/lodash/_baseEach.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/_baseEach.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseForOwn = __webpack_require__(/*! ./_baseForOwn */ "./node_modules/lodash/_baseForOwn.js"),
    createBaseEach = __webpack_require__(/*! ./_createBaseEach */ "./node_modules/lodash/_createBaseEach.js");

/**
 * The base implementation of `_.forEach` without support for iteratee shorthands.
 *
 * @private
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array|Object} Returns `collection`.
 */
var baseEach = createBaseEach(baseForOwn);

module.exports = baseEach;


/***/ }),

/***/ "./node_modules/lodash/_baseExtremum.js":
/*!**********************************************!*\
  !*** ./node_modules/lodash/_baseExtremum.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var isSymbol = __webpack_require__(/*! ./isSymbol */ "./node_modules/lodash/isSymbol.js");

/**
 * The base implementation of methods like `_.max` and `_.min` which accepts a
 * `comparator` to determine the extremum value.
 *
 * @private
 * @param {Array} array The array to iterate over.
 * @param {Function} iteratee The iteratee invoked per iteration.
 * @param {Function} comparator The comparator used to compare values.
 * @returns {*} Returns the extremum value.
 */
function baseExtremum(array, iteratee, comparator) {
  var index = -1,
      length = array.length;

  while (++index < length) {
    var value = array[index],
        current = iteratee(value);

    if (current != null && (computed === undefined
          ? (current === current && !isSymbol(current))
          : comparator(current, computed)
        )) {
      var computed = current,
          result = value;
    }
  }
  return result;
}

module.exports = baseExtremum;


/***/ }),

/***/ "./node_modules/lodash/_baseFilter.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_baseFilter.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseEach = __webpack_require__(/*! ./_baseEach */ "./node_modules/lodash/_baseEach.js");

/**
 * The base implementation of `_.filter` without support for iteratee shorthands.
 *
 * @private
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} predicate The function invoked per iteration.
 * @returns {Array} Returns the new filtered array.
 */
function baseFilter(collection, predicate) {
  var result = [];
  baseEach(collection, function(value, index, collection) {
    if (predicate(value, index, collection)) {
      result.push(value);
    }
  });
  return result;
}

module.exports = baseFilter;


/***/ }),

/***/ "./node_modules/lodash/_baseFindIndex.js":
/*!***********************************************!*\
  !*** ./node_modules/lodash/_baseFindIndex.js ***!
  \***********************************************/
/***/ ((module) => {

/**
 * The base implementation of `_.findIndex` and `_.findLastIndex` without
 * support for iteratee shorthands.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {Function} predicate The function invoked per iteration.
 * @param {number} fromIndex The index to search from.
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function baseFindIndex(array, predicate, fromIndex, fromRight) {
  var length = array.length,
      index = fromIndex + (fromRight ? 1 : -1);

  while ((fromRight ? index-- : ++index < length)) {
    if (predicate(array[index], index, array)) {
      return index;
    }
  }
  return -1;
}

module.exports = baseFindIndex;


/***/ }),

/***/ "./node_modules/lodash/_baseFlatten.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash/_baseFlatten.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var arrayPush = __webpack_require__(/*! ./_arrayPush */ "./node_modules/lodash/_arrayPush.js"),
    isFlattenable = __webpack_require__(/*! ./_isFlattenable */ "./node_modules/lodash/_isFlattenable.js");

/**
 * The base implementation of `_.flatten` with support for restricting flattening.
 *
 * @private
 * @param {Array} array The array to flatten.
 * @param {number} depth The maximum recursion depth.
 * @param {boolean} [predicate=isFlattenable] The function invoked per iteration.
 * @param {boolean} [isStrict] Restrict to values that pass `predicate` checks.
 * @param {Array} [result=[]] The initial result value.
 * @returns {Array} Returns the new flattened array.
 */
function baseFlatten(array, depth, predicate, isStrict, result) {
  var index = -1,
      length = array.length;

  predicate || (predicate = isFlattenable);
  result || (result = []);

  while (++index < length) {
    var value = array[index];
    if (depth > 0 && predicate(value)) {
      if (depth > 1) {
        // Recursively flatten arrays (susceptible to call stack limits).
        baseFlatten(value, depth - 1, predicate, isStrict, result);
      } else {
        arrayPush(result, value);
      }
    } else if (!isStrict) {
      result[result.length] = value;
    }
  }
  return result;
}

module.exports = baseFlatten;


/***/ }),

/***/ "./node_modules/lodash/_baseFor.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/_baseFor.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var createBaseFor = __webpack_require__(/*! ./_createBaseFor */ "./node_modules/lodash/_createBaseFor.js");

/**
 * The base implementation of `baseForOwn` which iterates over `object`
 * properties returned by `keysFunc` and invokes `iteratee` for each property.
 * Iteratee functions may exit iteration early by explicitly returning `false`.
 *
 * @private
 * @param {Object} object The object to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @param {Function} keysFunc The function to get the keys of `object`.
 * @returns {Object} Returns `object`.
 */
var baseFor = createBaseFor();

module.exports = baseFor;


/***/ }),

/***/ "./node_modules/lodash/_baseForOwn.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_baseForOwn.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseFor = __webpack_require__(/*! ./_baseFor */ "./node_modules/lodash/_baseFor.js"),
    keys = __webpack_require__(/*! ./keys */ "./node_modules/lodash/keys.js");

/**
 * The base implementation of `_.forOwn` without support for iteratee shorthands.
 *
 * @private
 * @param {Object} object The object to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Object} Returns `object`.
 */
function baseForOwn(object, iteratee) {
  return object && baseFor(object, iteratee, keys);
}

module.exports = baseForOwn;


/***/ }),

/***/ "./node_modules/lodash/_baseGet.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/_baseGet.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var castPath = __webpack_require__(/*! ./_castPath */ "./node_modules/lodash/_castPath.js"),
    toKey = __webpack_require__(/*! ./_toKey */ "./node_modules/lodash/_toKey.js");

/**
 * The base implementation of `_.get` without support for default values.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array|string} path The path of the property to get.
 * @returns {*} Returns the resolved value.
 */
function baseGet(object, path) {
  path = castPath(path, object);

  var index = 0,
      length = path.length;

  while (object != null && index < length) {
    object = object[toKey(path[index++])];
  }
  return (index && index == length) ? object : undefined;
}

module.exports = baseGet;


/***/ }),

/***/ "./node_modules/lodash/_baseGetAllKeys.js":
/*!************************************************!*\
  !*** ./node_modules/lodash/_baseGetAllKeys.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var arrayPush = __webpack_require__(/*! ./_arrayPush */ "./node_modules/lodash/_arrayPush.js"),
    isArray = __webpack_require__(/*! ./isArray */ "./node_modules/lodash/isArray.js");

/**
 * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
 * `keysFunc` and `symbolsFunc` to get the enumerable property names and
 * symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Function} keysFunc The function to get the keys of `object`.
 * @param {Function} symbolsFunc The function to get the symbols of `object`.
 * @returns {Array} Returns the array of property names and symbols.
 */
function baseGetAllKeys(object, keysFunc, symbolsFunc) {
  var result = keysFunc(object);
  return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
}

module.exports = baseGetAllKeys;


/***/ }),

/***/ "./node_modules/lodash/_baseGetTag.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_baseGetTag.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var Symbol = __webpack_require__(/*! ./_Symbol */ "./node_modules/lodash/_Symbol.js"),
    getRawTag = __webpack_require__(/*! ./_getRawTag */ "./node_modules/lodash/_getRawTag.js"),
    objectToString = __webpack_require__(/*! ./_objectToString */ "./node_modules/lodash/_objectToString.js");

/** `Object#toString` result references. */
var nullTag = '[object Null]',
    undefinedTag = '[object Undefined]';

/** Built-in value references. */
var symToStringTag = Symbol ? Symbol.toStringTag : undefined;

/**
 * The base implementation of `getTag` without fallbacks for buggy environments.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
function baseGetTag(value) {
  if (value == null) {
    return value === undefined ? undefinedTag : nullTag;
  }
  return (symToStringTag && symToStringTag in Object(value))
    ? getRawTag(value)
    : objectToString(value);
}

module.exports = baseGetTag;


/***/ }),

/***/ "./node_modules/lodash/_baseGt.js":
/*!****************************************!*\
  !*** ./node_modules/lodash/_baseGt.js ***!
  \****************************************/
/***/ ((module) => {

/**
 * The base implementation of `_.gt` which doesn't coerce arguments.
 *
 * @private
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if `value` is greater than `other`,
 *  else `false`.
 */
function baseGt(value, other) {
  return value > other;
}

module.exports = baseGt;


/***/ }),

/***/ "./node_modules/lodash/_baseHas.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/_baseHas.js ***!
  \*****************************************/
/***/ ((module) => {

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * The base implementation of `_.has` without support for deep paths.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {Array|string} key The key to check.
 * @returns {boolean} Returns `true` if `key` exists, else `false`.
 */
function baseHas(object, key) {
  return object != null && hasOwnProperty.call(object, key);
}

module.exports = baseHas;


/***/ }),

/***/ "./node_modules/lodash/_baseHasIn.js":
/*!*******************************************!*\
  !*** ./node_modules/lodash/_baseHasIn.js ***!
  \*******************************************/
/***/ ((module) => {

/**
 * The base implementation of `_.hasIn` without support for deep paths.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {Array|string} key The key to check.
 * @returns {boolean} Returns `true` if `key` exists, else `false`.
 */
function baseHasIn(object, key) {
  return object != null && key in Object(object);
}

module.exports = baseHasIn;


/***/ }),

/***/ "./node_modules/lodash/_baseIndexOf.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash/_baseIndexOf.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseFindIndex = __webpack_require__(/*! ./_baseFindIndex */ "./node_modules/lodash/_baseFindIndex.js"),
    baseIsNaN = __webpack_require__(/*! ./_baseIsNaN */ "./node_modules/lodash/_baseIsNaN.js"),
    strictIndexOf = __webpack_require__(/*! ./_strictIndexOf */ "./node_modules/lodash/_strictIndexOf.js");

/**
 * The base implementation of `_.indexOf` without `fromIndex` bounds checks.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} value The value to search for.
 * @param {number} fromIndex The index to search from.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function baseIndexOf(array, value, fromIndex) {
  return value === value
    ? strictIndexOf(array, value, fromIndex)
    : baseFindIndex(array, baseIsNaN, fromIndex);
}

module.exports = baseIndexOf;


/***/ }),

/***/ "./node_modules/lodash/_baseIsArguments.js":
/*!*************************************************!*\
  !*** ./node_modules/lodash/_baseIsArguments.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseGetTag = __webpack_require__(/*! ./_baseGetTag */ "./node_modules/lodash/_baseGetTag.js"),
    isObjectLike = __webpack_require__(/*! ./isObjectLike */ "./node_modules/lodash/isObjectLike.js");

/** `Object#toString` result references. */
var argsTag = '[object Arguments]';

/**
 * The base implementation of `_.isArguments`.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 */
function baseIsArguments(value) {
  return isObjectLike(value) && baseGetTag(value) == argsTag;
}

module.exports = baseIsArguments;


/***/ }),

/***/ "./node_modules/lodash/_baseIsEqual.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash/_baseIsEqual.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseIsEqualDeep = __webpack_require__(/*! ./_baseIsEqualDeep */ "./node_modules/lodash/_baseIsEqualDeep.js"),
    isObjectLike = __webpack_require__(/*! ./isObjectLike */ "./node_modules/lodash/isObjectLike.js");

/**
 * The base implementation of `_.isEqual` which supports partial comparisons
 * and tracks traversed objects.
 *
 * @private
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @param {boolean} bitmask The bitmask flags.
 *  1 - Unordered comparison
 *  2 - Partial comparison
 * @param {Function} [customizer] The function to customize comparisons.
 * @param {Object} [stack] Tracks traversed `value` and `other` objects.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 */
function baseIsEqual(value, other, bitmask, customizer, stack) {
  if (value === other) {
    return true;
  }
  if (value == null || other == null || (!isObjectLike(value) && !isObjectLike(other))) {
    return value !== value && other !== other;
  }
  return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
}

module.exports = baseIsEqual;


/***/ }),

/***/ "./node_modules/lodash/_baseIsEqualDeep.js":
/*!*************************************************!*\
  !*** ./node_modules/lodash/_baseIsEqualDeep.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var Stack = __webpack_require__(/*! ./_Stack */ "./node_modules/lodash/_Stack.js"),
    equalArrays = __webpack_require__(/*! ./_equalArrays */ "./node_modules/lodash/_equalArrays.js"),
    equalByTag = __webpack_require__(/*! ./_equalByTag */ "./node_modules/lodash/_equalByTag.js"),
    equalObjects = __webpack_require__(/*! ./_equalObjects */ "./node_modules/lodash/_equalObjects.js"),
    getTag = __webpack_require__(/*! ./_getTag */ "./node_modules/lodash/_getTag.js"),
    isArray = __webpack_require__(/*! ./isArray */ "./node_modules/lodash/isArray.js"),
    isBuffer = __webpack_require__(/*! ./isBuffer */ "./node_modules/lodash/isBuffer.js"),
    isTypedArray = __webpack_require__(/*! ./isTypedArray */ "./node_modules/lodash/isTypedArray.js");

/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG = 1;

/** `Object#toString` result references. */
var argsTag = '[object Arguments]',
    arrayTag = '[object Array]',
    objectTag = '[object Object]';

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * A specialized version of `baseIsEqual` for arrays and objects which performs
 * deep comparisons and tracks traversed objects enabling objects with circular
 * references to be compared.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} [stack] Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */
function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
  var objIsArr = isArray(object),
      othIsArr = isArray(other),
      objTag = objIsArr ? arrayTag : getTag(object),
      othTag = othIsArr ? arrayTag : getTag(other);

  objTag = objTag == argsTag ? objectTag : objTag;
  othTag = othTag == argsTag ? objectTag : othTag;

  var objIsObj = objTag == objectTag,
      othIsObj = othTag == objectTag,
      isSameTag = objTag == othTag;

  if (isSameTag && isBuffer(object)) {
    if (!isBuffer(other)) {
      return false;
    }
    objIsArr = true;
    objIsObj = false;
  }
  if (isSameTag && !objIsObj) {
    stack || (stack = new Stack);
    return (objIsArr || isTypedArray(object))
      ? equalArrays(object, other, bitmask, customizer, equalFunc, stack)
      : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
  }
  if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
    var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),
        othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');

    if (objIsWrapped || othIsWrapped) {
      var objUnwrapped = objIsWrapped ? object.value() : object,
          othUnwrapped = othIsWrapped ? other.value() : other;

      stack || (stack = new Stack);
      return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
    }
  }
  if (!isSameTag) {
    return false;
  }
  stack || (stack = new Stack);
  return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
}

module.exports = baseIsEqualDeep;


/***/ }),

/***/ "./node_modules/lodash/_baseIsMap.js":
/*!*******************************************!*\
  !*** ./node_modules/lodash/_baseIsMap.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var getTag = __webpack_require__(/*! ./_getTag */ "./node_modules/lodash/_getTag.js"),
    isObjectLike = __webpack_require__(/*! ./isObjectLike */ "./node_modules/lodash/isObjectLike.js");

/** `Object#toString` result references. */
var mapTag = '[object Map]';

/**
 * The base implementation of `_.isMap` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a map, else `false`.
 */
function baseIsMap(value) {
  return isObjectLike(value) && getTag(value) == mapTag;
}

module.exports = baseIsMap;


/***/ }),

/***/ "./node_modules/lodash/_baseIsMatch.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash/_baseIsMatch.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var Stack = __webpack_require__(/*! ./_Stack */ "./node_modules/lodash/_Stack.js"),
    baseIsEqual = __webpack_require__(/*! ./_baseIsEqual */ "./node_modules/lodash/_baseIsEqual.js");

/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG = 1,
    COMPARE_UNORDERED_FLAG = 2;

/**
 * The base implementation of `_.isMatch` without support for iteratee shorthands.
 *
 * @private
 * @param {Object} object The object to inspect.
 * @param {Object} source The object of property values to match.
 * @param {Array} matchData The property names, values, and compare flags to match.
 * @param {Function} [customizer] The function to customize comparisons.
 * @returns {boolean} Returns `true` if `object` is a match, else `false`.
 */
function baseIsMatch(object, source, matchData, customizer) {
  var index = matchData.length,
      length = index,
      noCustomizer = !customizer;

  if (object == null) {
    return !length;
  }
  object = Object(object);
  while (index--) {
    var data = matchData[index];
    if ((noCustomizer && data[2])
          ? data[1] !== object[data[0]]
          : !(data[0] in object)
        ) {
      return false;
    }
  }
  while (++index < length) {
    data = matchData[index];
    var key = data[0],
        objValue = object[key],
        srcValue = data[1];

    if (noCustomizer && data[2]) {
      if (objValue === undefined && !(key in object)) {
        return false;
      }
    } else {
      var stack = new Stack;
      if (customizer) {
        var result = customizer(objValue, srcValue, key, object, source, stack);
      }
      if (!(result === undefined
            ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack)
            : result
          )) {
        return false;
      }
    }
  }
  return true;
}

module.exports = baseIsMatch;


/***/ }),

/***/ "./node_modules/lodash/_baseIsNaN.js":
/*!*******************************************!*\
  !*** ./node_modules/lodash/_baseIsNaN.js ***!
  \*******************************************/
/***/ ((module) => {

/**
 * The base implementation of `_.isNaN` without support for number objects.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
 */
function baseIsNaN(value) {
  return value !== value;
}

module.exports = baseIsNaN;


/***/ }),

/***/ "./node_modules/lodash/_baseIsNative.js":
/*!**********************************************!*\
  !*** ./node_modules/lodash/_baseIsNative.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var isFunction = __webpack_require__(/*! ./isFunction */ "./node_modules/lodash/isFunction.js"),
    isMasked = __webpack_require__(/*! ./_isMasked */ "./node_modules/lodash/_isMasked.js"),
    isObject = __webpack_require__(/*! ./isObject */ "./node_modules/lodash/isObject.js"),
    toSource = __webpack_require__(/*! ./_toSource */ "./node_modules/lodash/_toSource.js");

/**
 * Used to match `RegExp`
 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
 */
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;

/** Used to detect host constructors (Safari). */
var reIsHostCtor = /^\[object .+?Constructor\]$/;

/** Used for built-in method references. */
var funcProto = Function.prototype,
    objectProto = Object.prototype;

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/** Used to detect if a method is native. */
var reIsNative = RegExp('^' +
  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&')
  .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
);

/**
 * The base implementation of `_.isNative` without bad shim checks.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a native function,
 *  else `false`.
 */
function baseIsNative(value) {
  if (!isObject(value) || isMasked(value)) {
    return false;
  }
  var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
  return pattern.test(toSource(value));
}

module.exports = baseIsNative;


/***/ }),

/***/ "./node_modules/lodash/_baseIsSet.js":
/*!*******************************************!*\
  !*** ./node_modules/lodash/_baseIsSet.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var getTag = __webpack_require__(/*! ./_getTag */ "./node_modules/lodash/_getTag.js"),
    isObjectLike = __webpack_require__(/*! ./isObjectLike */ "./node_modules/lodash/isObjectLike.js");

/** `Object#toString` result references. */
var setTag = '[object Set]';

/**
 * The base implementation of `_.isSet` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a set, else `false`.
 */
function baseIsSet(value) {
  return isObjectLike(value) && getTag(value) == setTag;
}

module.exports = baseIsSet;


/***/ }),

/***/ "./node_modules/lodash/_baseIsTypedArray.js":
/*!**************************************************!*\
  !*** ./node_modules/lodash/_baseIsTypedArray.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseGetTag = __webpack_require__(/*! ./_baseGetTag */ "./node_modules/lodash/_baseGetTag.js"),
    isLength = __webpack_require__(/*! ./isLength */ "./node_modules/lodash/isLength.js"),
    isObjectLike = __webpack_require__(/*! ./isObjectLike */ "./node_modules/lodash/isObjectLike.js");

/** `Object#toString` result references. */
var argsTag = '[object Arguments]',
    arrayTag = '[object Array]',
    boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    errorTag = '[object Error]',
    funcTag = '[object Function]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    objectTag = '[object Object]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    weakMapTag = '[object WeakMap]';

var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]',
    float32Tag = '[object Float32Array]',
    float64Tag = '[object Float64Array]',
    int8Tag = '[object Int8Array]',
    int16Tag = '[object Int16Array]',
    int32Tag = '[object Int32Array]',
    uint8Tag = '[object Uint8Array]',
    uint8ClampedTag = '[object Uint8ClampedArray]',
    uint16Tag = '[object Uint16Array]',
    uint32Tag = '[object Uint32Array]';

/** Used to identify `toStringTag` values of typed arrays. */
var typedArrayTags = {};
typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =
typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =
typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =
typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =
typedArrayTags[uint32Tag] = true;
typedArrayTags[argsTag] = typedArrayTags[arrayTag] =
typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =
typedArrayTags[dataViewTag] = typedArrayTags[dateTag] =
typedArrayTags[errorTag] = typedArrayTags[funcTag] =
typedArrayTags[mapTag] = typedArrayTags[numberTag] =
typedArrayTags[objectTag] = typedArrayTags[regexpTag] =
typedArrayTags[setTag] = typedArrayTags[stringTag] =
typedArrayTags[weakMapTag] = false;

/**
 * The base implementation of `_.isTypedArray` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 */
function baseIsTypedArray(value) {
  return isObjectLike(value) &&
    isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
}

module.exports = baseIsTypedArray;


/***/ }),

/***/ "./node_modules/lodash/_baseIteratee.js":
/*!**********************************************!*\
  !*** ./node_modules/lodash/_baseIteratee.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseMatches = __webpack_require__(/*! ./_baseMatches */ "./node_modules/lodash/_baseMatches.js"),
    baseMatchesProperty = __webpack_require__(/*! ./_baseMatchesProperty */ "./node_modules/lodash/_baseMatchesProperty.js"),
    identity = __webpack_require__(/*! ./identity */ "./node_modules/lodash/identity.js"),
    isArray = __webpack_require__(/*! ./isArray */ "./node_modules/lodash/isArray.js"),
    property = __webpack_require__(/*! ./property */ "./node_modules/lodash/property.js");

/**
 * The base implementation of `_.iteratee`.
 *
 * @private
 * @param {*} [value=_.identity] The value to convert to an iteratee.
 * @returns {Function} Returns the iteratee.
 */
function baseIteratee(value) {
  // Don't store the `typeof` result in a variable to avoid a JIT bug in Safari 9.
  // See https://bugs.webkit.org/show_bug.cgi?id=156034 for more details.
  if (typeof value == 'function') {
    return value;
  }
  if (value == null) {
    return identity;
  }
  if (typeof value == 'object') {
    return isArray(value)
      ? baseMatchesProperty(value[0], value[1])
      : baseMatches(value);
  }
  return property(value);
}

module.exports = baseIteratee;


/***/ }),

/***/ "./node_modules/lodash/_baseKeys.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/_baseKeys.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var isPrototype = __webpack_require__(/*! ./_isPrototype */ "./node_modules/lodash/_isPrototype.js"),
    nativeKeys = __webpack_require__(/*! ./_nativeKeys */ "./node_modules/lodash/_nativeKeys.js");

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function baseKeys(object) {
  if (!isPrototype(object)) {
    return nativeKeys(object);
  }
  var result = [];
  for (var key in Object(object)) {
    if (hasOwnProperty.call(object, key) && key != 'constructor') {
      result.push(key);
    }
  }
  return result;
}

module.exports = baseKeys;


/***/ }),

/***/ "./node_modules/lodash/_baseKeysIn.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_baseKeysIn.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var isObject = __webpack_require__(/*! ./isObject */ "./node_modules/lodash/isObject.js"),
    isPrototype = __webpack_require__(/*! ./_isPrototype */ "./node_modules/lodash/_isPrototype.js"),
    nativeKeysIn = __webpack_require__(/*! ./_nativeKeysIn */ "./node_modules/lodash/_nativeKeysIn.js");

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function baseKeysIn(object) {
  if (!isObject(object)) {
    return nativeKeysIn(object);
  }
  var isProto = isPrototype(object),
      result = [];

  for (var key in object) {
    if (!(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {
      result.push(key);
    }
  }
  return result;
}

module.exports = baseKeysIn;


/***/ }),

/***/ "./node_modules/lodash/_baseLt.js":
/*!****************************************!*\
  !*** ./node_modules/lodash/_baseLt.js ***!
  \****************************************/
/***/ ((module) => {

/**
 * The base implementation of `_.lt` which doesn't coerce arguments.
 *
 * @private
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if `value` is less than `other`,
 *  else `false`.
 */
function baseLt(value, other) {
  return value < other;
}

module.exports = baseLt;


/***/ }),

/***/ "./node_modules/lodash/_baseMap.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/_baseMap.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseEach = __webpack_require__(/*! ./_baseEach */ "./node_modules/lodash/_baseEach.js"),
    isArrayLike = __webpack_require__(/*! ./isArrayLike */ "./node_modules/lodash/isArrayLike.js");

/**
 * The base implementation of `_.map` without support for iteratee shorthands.
 *
 * @private
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the new mapped array.
 */
function baseMap(collection, iteratee) {
  var index = -1,
      result = isArrayLike(collection) ? Array(collection.length) : [];

  baseEach(collection, function(value, key, collection) {
    result[++index] = iteratee(value, key, collection);
  });
  return result;
}

module.exports = baseMap;


/***/ }),

/***/ "./node_modules/lodash/_baseMatches.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash/_baseMatches.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseIsMatch = __webpack_require__(/*! ./_baseIsMatch */ "./node_modules/lodash/_baseIsMatch.js"),
    getMatchData = __webpack_require__(/*! ./_getMatchData */ "./node_modules/lodash/_getMatchData.js"),
    matchesStrictComparable = __webpack_require__(/*! ./_matchesStrictComparable */ "./node_modules/lodash/_matchesStrictComparable.js");

/**
 * The base implementation of `_.matches` which doesn't clone `source`.
 *
 * @private
 * @param {Object} source The object of property values to match.
 * @returns {Function} Returns the new spec function.
 */
function baseMatches(source) {
  var matchData = getMatchData(source);
  if (matchData.length == 1 && matchData[0][2]) {
    return matchesStrictComparable(matchData[0][0], matchData[0][1]);
  }
  return function(object) {
    return object === source || baseIsMatch(object, source, matchData);
  };
}

module.exports = baseMatches;


/***/ }),

/***/ "./node_modules/lodash/_baseMatchesProperty.js":
/*!*****************************************************!*\
  !*** ./node_modules/lodash/_baseMatchesProperty.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseIsEqual = __webpack_require__(/*! ./_baseIsEqual */ "./node_modules/lodash/_baseIsEqual.js"),
    get = __webpack_require__(/*! ./get */ "./node_modules/lodash/get.js"),
    hasIn = __webpack_require__(/*! ./hasIn */ "./node_modules/lodash/hasIn.js"),
    isKey = __webpack_require__(/*! ./_isKey */ "./node_modules/lodash/_isKey.js"),
    isStrictComparable = __webpack_require__(/*! ./_isStrictComparable */ "./node_modules/lodash/_isStrictComparable.js"),
    matchesStrictComparable = __webpack_require__(/*! ./_matchesStrictComparable */ "./node_modules/lodash/_matchesStrictComparable.js"),
    toKey = __webpack_require__(/*! ./_toKey */ "./node_modules/lodash/_toKey.js");

/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG = 1,
    COMPARE_UNORDERED_FLAG = 2;

/**
 * The base implementation of `_.matchesProperty` which doesn't clone `srcValue`.
 *
 * @private
 * @param {string} path The path of the property to get.
 * @param {*} srcValue The value to match.
 * @returns {Function} Returns the new spec function.
 */
function baseMatchesProperty(path, srcValue) {
  if (isKey(path) && isStrictComparable(srcValue)) {
    return matchesStrictComparable(toKey(path), srcValue);
  }
  return function(object) {
    var objValue = get(object, path);
    return (objValue === undefined && objValue === srcValue)
      ? hasIn(object, path)
      : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
  };
}

module.exports = baseMatchesProperty;


/***/ }),

/***/ "./node_modules/lodash/_baseMerge.js":
/*!*******************************************!*\
  !*** ./node_modules/lodash/_baseMerge.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var Stack = __webpack_require__(/*! ./_Stack */ "./node_modules/lodash/_Stack.js"),
    assignMergeValue = __webpack_require__(/*! ./_assignMergeValue */ "./node_modules/lodash/_assignMergeValue.js"),
    baseFor = __webpack_require__(/*! ./_baseFor */ "./node_modules/lodash/_baseFor.js"),
    baseMergeDeep = __webpack_require__(/*! ./_baseMergeDeep */ "./node_modules/lodash/_baseMergeDeep.js"),
    isObject = __webpack_require__(/*! ./isObject */ "./node_modules/lodash/isObject.js"),
    keysIn = __webpack_require__(/*! ./keysIn */ "./node_modules/lodash/keysIn.js"),
    safeGet = __webpack_require__(/*! ./_safeGet */ "./node_modules/lodash/_safeGet.js");

/**
 * The base implementation of `_.merge` without support for multiple sources.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @param {number} srcIndex The index of `source`.
 * @param {Function} [customizer] The function to customize merged values.
 * @param {Object} [stack] Tracks traversed source values and their merged
 *  counterparts.
 */
function baseMerge(object, source, srcIndex, customizer, stack) {
  if (object === source) {
    return;
  }
  baseFor(source, function(srcValue, key) {
    stack || (stack = new Stack);
    if (isObject(srcValue)) {
      baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
    }
    else {
      var newValue = customizer
        ? customizer(safeGet(object, key), srcValue, (key + ''), object, source, stack)
        : undefined;

      if (newValue === undefined) {
        newValue = srcValue;
      }
      assignMergeValue(object, key, newValue);
    }
  }, keysIn);
}

module.exports = baseMerge;


/***/ }),

/***/ "./node_modules/lodash/_baseMergeDeep.js":
/*!***********************************************!*\
  !*** ./node_modules/lodash/_baseMergeDeep.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var assignMergeValue = __webpack_require__(/*! ./_assignMergeValue */ "./node_modules/lodash/_assignMergeValue.js"),
    cloneBuffer = __webpack_require__(/*! ./_cloneBuffer */ "./node_modules/lodash/_cloneBuffer.js"),
    cloneTypedArray = __webpack_require__(/*! ./_cloneTypedArray */ "./node_modules/lodash/_cloneTypedArray.js"),
    copyArray = __webpack_require__(/*! ./_copyArray */ "./node_modules/lodash/_copyArray.js"),
    initCloneObject = __webpack_require__(/*! ./_initCloneObject */ "./node_modules/lodash/_initCloneObject.js"),
    isArguments = __webpack_require__(/*! ./isArguments */ "./node_modules/lodash/isArguments.js"),
    isArray = __webpack_require__(/*! ./isArray */ "./node_modules/lodash/isArray.js"),
    isArrayLikeObject = __webpack_require__(/*! ./isArrayLikeObject */ "./node_modules/lodash/isArrayLikeObject.js"),
    isBuffer = __webpack_require__(/*! ./isBuffer */ "./node_modules/lodash/isBuffer.js"),
    isFunction = __webpack_require__(/*! ./isFunction */ "./node_modules/lodash/isFunction.js"),
    isObject = __webpack_require__(/*! ./isObject */ "./node_modules/lodash/isObject.js"),
    isPlainObject = __webpack_require__(/*! ./isPlainObject */ "./node_modules/lodash/isPlainObject.js"),
    isTypedArray = __webpack_require__(/*! ./isTypedArray */ "./node_modules/lodash/isTypedArray.js"),
    safeGet = __webpack_require__(/*! ./_safeGet */ "./node_modules/lodash/_safeGet.js"),
    toPlainObject = __webpack_require__(/*! ./toPlainObject */ "./node_modules/lodash/toPlainObject.js");

/**
 * A specialized version of `baseMerge` for arrays and objects which performs
 * deep merges and tracks traversed objects enabling objects with circular
 * references to be merged.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @param {string} key The key of the value to merge.
 * @param {number} srcIndex The index of `source`.
 * @param {Function} mergeFunc The function to merge values.
 * @param {Function} [customizer] The function to customize assigned values.
 * @param {Object} [stack] Tracks traversed source values and their merged
 *  counterparts.
 */
function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
  var objValue = safeGet(object, key),
      srcValue = safeGet(source, key),
      stacked = stack.get(srcValue);

  if (stacked) {
    assignMergeValue(object, key, stacked);
    return;
  }
  var newValue = customizer
    ? customizer(objValue, srcValue, (key + ''), object, source, stack)
    : undefined;

  var isCommon = newValue === undefined;

  if (isCommon) {
    var isArr = isArray(srcValue),
        isBuff = !isArr && isBuffer(srcValue),
        isTyped = !isArr && !isBuff && isTypedArray(srcValue);

    newValue = srcValue;
    if (isArr || isBuff || isTyped) {
      if (isArray(objValue)) {
        newValue = objValue;
      }
      else if (isArrayLikeObject(objValue)) {
        newValue = copyArray(objValue);
      }
      else if (isBuff) {
        isCommon = false;
        newValue = cloneBuffer(srcValue, true);
      }
      else if (isTyped) {
        isCommon = false;
        newValue = cloneTypedArray(srcValue, true);
      }
      else {
        newValue = [];
      }
    }
    else if (isPlainObject(srcValue) || isArguments(srcValue)) {
      newValue = objValue;
      if (isArguments(objValue)) {
        newValue = toPlainObject(objValue);
      }
      else if (!isObject(objValue) || isFunction(objValue)) {
        newValue = initCloneObject(srcValue);
      }
    }
    else {
      isCommon = false;
    }
  }
  if (isCommon) {
    // Recursively merge objects and arrays (susceptible to call stack limits).
    stack.set(srcValue, newValue);
    mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
    stack['delete'](srcValue);
  }
  assignMergeValue(object, key, newValue);
}

module.exports = baseMergeDeep;


/***/ }),

/***/ "./node_modules/lodash/_baseOrderBy.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash/_baseOrderBy.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var arrayMap = __webpack_require__(/*! ./_arrayMap */ "./node_modules/lodash/_arrayMap.js"),
    baseGet = __webpack_require__(/*! ./_baseGet */ "./node_modules/lodash/_baseGet.js"),
    baseIteratee = __webpack_require__(/*! ./_baseIteratee */ "./node_modules/lodash/_baseIteratee.js"),
    baseMap = __webpack_require__(/*! ./_baseMap */ "./node_modules/lodash/_baseMap.js"),
    baseSortBy = __webpack_require__(/*! ./_baseSortBy */ "./node_modules/lodash/_baseSortBy.js"),
    baseUnary = __webpack_require__(/*! ./_baseUnary */ "./node_modules/lodash/_baseUnary.js"),
    compareMultiple = __webpack_require__(/*! ./_compareMultiple */ "./node_modules/lodash/_compareMultiple.js"),
    identity = __webpack_require__(/*! ./identity */ "./node_modules/lodash/identity.js"),
    isArray = __webpack_require__(/*! ./isArray */ "./node_modules/lodash/isArray.js");

/**
 * The base implementation of `_.orderBy` without param guards.
 *
 * @private
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function[]|Object[]|string[]} iteratees The iteratees to sort by.
 * @param {string[]} orders The sort orders of `iteratees`.
 * @returns {Array} Returns the new sorted array.
 */
function baseOrderBy(collection, iteratees, orders) {
  if (iteratees.length) {
    iteratees = arrayMap(iteratees, function(iteratee) {
      if (isArray(iteratee)) {
        return function(value) {
          return baseGet(value, iteratee.length === 1 ? iteratee[0] : iteratee);
        }
      }
      return iteratee;
    });
  } else {
    iteratees = [identity];
  }

  var index = -1;
  iteratees = arrayMap(iteratees, baseUnary(baseIteratee));

  var result = baseMap(collection, function(value, key, collection) {
    var criteria = arrayMap(iteratees, function(iteratee) {
      return iteratee(value);
    });
    return { 'criteria': criteria, 'index': ++index, 'value': value };
  });

  return baseSortBy(result, function(object, other) {
    return compareMultiple(object, other, orders);
  });
}

module.exports = baseOrderBy;


/***/ }),

/***/ "./node_modules/lodash/_basePick.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/_basePick.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var basePickBy = __webpack_require__(/*! ./_basePickBy */ "./node_modules/lodash/_basePickBy.js"),
    hasIn = __webpack_require__(/*! ./hasIn */ "./node_modules/lodash/hasIn.js");

/**
 * The base implementation of `_.pick` without support for individual
 * property identifiers.
 *
 * @private
 * @param {Object} object The source object.
 * @param {string[]} paths The property paths to pick.
 * @returns {Object} Returns the new object.
 */
function basePick(object, paths) {
  return basePickBy(object, paths, function(value, path) {
    return hasIn(object, path);
  });
}

module.exports = basePick;


/***/ }),

/***/ "./node_modules/lodash/_basePickBy.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_basePickBy.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseGet = __webpack_require__(/*! ./_baseGet */ "./node_modules/lodash/_baseGet.js"),
    baseSet = __webpack_require__(/*! ./_baseSet */ "./node_modules/lodash/_baseSet.js"),
    castPath = __webpack_require__(/*! ./_castPath */ "./node_modules/lodash/_castPath.js");

/**
 * The base implementation of  `_.pickBy` without support for iteratee shorthands.
 *
 * @private
 * @param {Object} object The source object.
 * @param {string[]} paths The property paths to pick.
 * @param {Function} predicate The function invoked per property.
 * @returns {Object} Returns the new object.
 */
function basePickBy(object, paths, predicate) {
  var index = -1,
      length = paths.length,
      result = {};

  while (++index < length) {
    var path = paths[index],
        value = baseGet(object, path);

    if (predicate(value, path)) {
      baseSet(result, castPath(path, object), value);
    }
  }
  return result;
}

module.exports = basePickBy;


/***/ }),

/***/ "./node_modules/lodash/_baseProperty.js":
/*!**********************************************!*\
  !*** ./node_modules/lodash/_baseProperty.js ***!
  \**********************************************/
/***/ ((module) => {

/**
 * The base implementation of `_.property` without support for deep paths.
 *
 * @private
 * @param {string} key The key of the property to get.
 * @returns {Function} Returns the new accessor function.
 */
function baseProperty(key) {
  return function(object) {
    return object == null ? undefined : object[key];
  };
}

module.exports = baseProperty;


/***/ }),

/***/ "./node_modules/lodash/_basePropertyDeep.js":
/*!**************************************************!*\
  !*** ./node_modules/lodash/_basePropertyDeep.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseGet = __webpack_require__(/*! ./_baseGet */ "./node_modules/lodash/_baseGet.js");

/**
 * A specialized version of `baseProperty` which supports deep paths.
 *
 * @private
 * @param {Array|string} path The path of the property to get.
 * @returns {Function} Returns the new accessor function.
 */
function basePropertyDeep(path) {
  return function(object) {
    return baseGet(object, path);
  };
}

module.exports = basePropertyDeep;


/***/ }),

/***/ "./node_modules/lodash/_baseRange.js":
/*!*******************************************!*\
  !*** ./node_modules/lodash/_baseRange.js ***!
  \*******************************************/
/***/ ((module) => {

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeCeil = Math.ceil,
    nativeMax = Math.max;

/**
 * The base implementation of `_.range` and `_.rangeRight` which doesn't
 * coerce arguments.
 *
 * @private
 * @param {number} start The start of the range.
 * @param {number} end The end of the range.
 * @param {number} step The value to increment or decrement by.
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {Array} Returns the range of numbers.
 */
function baseRange(start, end, step, fromRight) {
  var index = -1,
      length = nativeMax(nativeCeil((end - start) / (step || 1)), 0),
      result = Array(length);

  while (length--) {
    result[fromRight ? length : ++index] = start;
    start += step;
  }
  return result;
}

module.exports = baseRange;


/***/ }),

/***/ "./node_modules/lodash/_baseReduce.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_baseReduce.js ***!
  \********************************************/
/***/ ((module) => {

/**
 * The base implementation of `_.reduce` and `_.reduceRight`, without support
 * for iteratee shorthands, which iterates over `collection` using `eachFunc`.
 *
 * @private
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @param {*} accumulator The initial value.
 * @param {boolean} initAccum Specify using the first or last element of
 *  `collection` as the initial value.
 * @param {Function} eachFunc The function to iterate over `collection`.
 * @returns {*} Returns the accumulated value.
 */
function baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) {
  eachFunc(collection, function(value, index, collection) {
    accumulator = initAccum
      ? (initAccum = false, value)
      : iteratee(accumulator, value, index, collection);
  });
  return accumulator;
}

module.exports = baseReduce;


/***/ }),

/***/ "./node_modules/lodash/_baseRest.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/_baseRest.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var identity = __webpack_require__(/*! ./identity */ "./node_modules/lodash/identity.js"),
    overRest = __webpack_require__(/*! ./_overRest */ "./node_modules/lodash/_overRest.js"),
    setToString = __webpack_require__(/*! ./_setToString */ "./node_modules/lodash/_setToString.js");

/**
 * The base implementation of `_.rest` which doesn't validate or coerce arguments.
 *
 * @private
 * @param {Function} func The function to apply a rest parameter to.
 * @param {number} [start=func.length-1] The start position of the rest parameter.
 * @returns {Function} Returns the new function.
 */
function baseRest(func, start) {
  return setToString(overRest(func, start, identity), func + '');
}

module.exports = baseRest;


/***/ }),

/***/ "./node_modules/lodash/_baseSet.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/_baseSet.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var assignValue = __webpack_require__(/*! ./_assignValue */ "./node_modules/lodash/_assignValue.js"),
    castPath = __webpack_require__(/*! ./_castPath */ "./node_modules/lodash/_castPath.js"),
    isIndex = __webpack_require__(/*! ./_isIndex */ "./node_modules/lodash/_isIndex.js"),
    isObject = __webpack_require__(/*! ./isObject */ "./node_modules/lodash/isObject.js"),
    toKey = __webpack_require__(/*! ./_toKey */ "./node_modules/lodash/_toKey.js");

/**
 * The base implementation of `_.set`.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {Array|string} path The path of the property to set.
 * @param {*} value The value to set.
 * @param {Function} [customizer] The function to customize path creation.
 * @returns {Object} Returns `object`.
 */
function baseSet(object, path, value, customizer) {
  if (!isObject(object)) {
    return object;
  }
  path = castPath(path, object);

  var index = -1,
      length = path.length,
      lastIndex = length - 1,
      nested = object;

  while (nested != null && ++index < length) {
    var key = toKey(path[index]),
        newValue = value;

    if (key === '__proto__' || key === 'constructor' || key === 'prototype') {
      return object;
    }

    if (index != lastIndex) {
      var objValue = nested[key];
      newValue = customizer ? customizer(objValue, key, nested) : undefined;
      if (newValue === undefined) {
        newValue = isObject(objValue)
          ? objValue
          : (isIndex(path[index + 1]) ? [] : {});
      }
    }
    assignValue(nested, key, newValue);
    nested = nested[key];
  }
  return object;
}

module.exports = baseSet;


/***/ }),

/***/ "./node_modules/lodash/_baseSetToString.js":
/*!*************************************************!*\
  !*** ./node_modules/lodash/_baseSetToString.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var constant = __webpack_require__(/*! ./constant */ "./node_modules/lodash/constant.js"),
    defineProperty = __webpack_require__(/*! ./_defineProperty */ "./node_modules/lodash/_defineProperty.js"),
    identity = __webpack_require__(/*! ./identity */ "./node_modules/lodash/identity.js");

/**
 * The base implementation of `setToString` without support for hot loop shorting.
 *
 * @private
 * @param {Function} func The function to modify.
 * @param {Function} string The `toString` result.
 * @returns {Function} Returns `func`.
 */
var baseSetToString = !defineProperty ? identity : function(func, string) {
  return defineProperty(func, 'toString', {
    'configurable': true,
    'enumerable': false,
    'value': constant(string),
    'writable': true
  });
};

module.exports = baseSetToString;


/***/ }),

/***/ "./node_modules/lodash/_baseSortBy.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_baseSortBy.js ***!
  \********************************************/
/***/ ((module) => {

/**
 * The base implementation of `_.sortBy` which uses `comparer` to define the
 * sort order of `array` and replaces criteria objects with their corresponding
 * values.
 *
 * @private
 * @param {Array} array The array to sort.
 * @param {Function} comparer The function to define sort order.
 * @returns {Array} Returns `array`.
 */
function baseSortBy(array, comparer) {
  var length = array.length;

  array.sort(comparer);
  while (length--) {
    array[length] = array[length].value;
  }
  return array;
}

module.exports = baseSortBy;


/***/ }),

/***/ "./node_modules/lodash/_baseTimes.js":
/*!*******************************************!*\
  !*** ./node_modules/lodash/_baseTimes.js ***!
  \*******************************************/
/***/ ((module) => {

/**
 * The base implementation of `_.times` without support for iteratee shorthands
 * or max array length checks.
 *
 * @private
 * @param {number} n The number of times to invoke `iteratee`.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the array of results.
 */
function baseTimes(n, iteratee) {
  var index = -1,
      result = Array(n);

  while (++index < n) {
    result[index] = iteratee(index);
  }
  return result;
}

module.exports = baseTimes;


/***/ }),

/***/ "./node_modules/lodash/_baseToString.js":
/*!**********************************************!*\
  !*** ./node_modules/lodash/_baseToString.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var Symbol = __webpack_require__(/*! ./_Symbol */ "./node_modules/lodash/_Symbol.js"),
    arrayMap = __webpack_require__(/*! ./_arrayMap */ "./node_modules/lodash/_arrayMap.js"),
    isArray = __webpack_require__(/*! ./isArray */ "./node_modules/lodash/isArray.js"),
    isSymbol = __webpack_require__(/*! ./isSymbol */ "./node_modules/lodash/isSymbol.js");

/** Used as references for various `Number` constants. */
var INFINITY = 1 / 0;

/** Used to convert symbols to primitives and strings. */
var symbolProto = Symbol ? Symbol.prototype : undefined,
    symbolToString = symbolProto ? symbolProto.toString : undefined;

/**
 * The base implementation of `_.toString` which doesn't convert nullish
 * values to empty strings.
 *
 * @private
 * @param {*} value The value to process.
 * @returns {string} Returns the string.
 */
function baseToString(value) {
  // Exit early for strings to avoid a performance hit in some environments.
  if (typeof value == 'string') {
    return value;
  }
  if (isArray(value)) {
    // Recursively convert values (susceptible to call stack limits).
    return arrayMap(value, baseToString) + '';
  }
  if (isSymbol(value)) {
    return symbolToString ? symbolToString.call(value) : '';
  }
  var result = (value + '');
  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
}

module.exports = baseToString;


/***/ }),

/***/ "./node_modules/lodash/_baseTrim.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/_baseTrim.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var trimmedEndIndex = __webpack_require__(/*! ./_trimmedEndIndex */ "./node_modules/lodash/_trimmedEndIndex.js");

/** Used to match leading whitespace. */
var reTrimStart = /^\s+/;

/**
 * The base implementation of `_.trim`.
 *
 * @private
 * @param {string} string The string to trim.
 * @returns {string} Returns the trimmed string.
 */
function baseTrim(string) {
  return string
    ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, '')
    : string;
}

module.exports = baseTrim;


/***/ }),

/***/ "./node_modules/lodash/_baseUnary.js":
/*!*******************************************!*\
  !*** ./node_modules/lodash/_baseUnary.js ***!
  \*******************************************/
/***/ ((module) => {

/**
 * The base implementation of `_.unary` without support for storing metadata.
 *
 * @private
 * @param {Function} func The function to cap arguments for.
 * @returns {Function} Returns the new capped function.
 */
function baseUnary(func) {
  return function(value) {
    return func(value);
  };
}

module.exports = baseUnary;


/***/ }),

/***/ "./node_modules/lodash/_baseUniq.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/_baseUniq.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var SetCache = __webpack_require__(/*! ./_SetCache */ "./node_modules/lodash/_SetCache.js"),
    arrayIncludes = __webpack_require__(/*! ./_arrayIncludes */ "./node_modules/lodash/_arrayIncludes.js"),
    arrayIncludesWith = __webpack_require__(/*! ./_arrayIncludesWith */ "./node_modules/lodash/_arrayIncludesWith.js"),
    cacheHas = __webpack_require__(/*! ./_cacheHas */ "./node_modules/lodash/_cacheHas.js"),
    createSet = __webpack_require__(/*! ./_createSet */ "./node_modules/lodash/_createSet.js"),
    setToArray = __webpack_require__(/*! ./_setToArray */ "./node_modules/lodash/_setToArray.js");

/** Used as the size to enable large array optimizations. */
var LARGE_ARRAY_SIZE = 200;

/**
 * The base implementation of `_.uniqBy` without support for iteratee shorthands.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {Function} [iteratee] The iteratee invoked per element.
 * @param {Function} [comparator] The comparator invoked per element.
 * @returns {Array} Returns the new duplicate free array.
 */
function baseUniq(array, iteratee, comparator) {
  var index = -1,
      includes = arrayIncludes,
      length = array.length,
      isCommon = true,
      result = [],
      seen = result;

  if (comparator) {
    isCommon = false;
    includes = arrayIncludesWith;
  }
  else if (length >= LARGE_ARRAY_SIZE) {
    var set = iteratee ? null : createSet(array);
    if (set) {
      return setToArray(set);
    }
    isCommon = false;
    includes = cacheHas;
    seen = new SetCache;
  }
  else {
    seen = iteratee ? [] : result;
  }
  outer:
  while (++index < length) {
    var value = array[index],
        computed = iteratee ? iteratee(value) : value;

    value = (comparator || value !== 0) ? value : 0;
    if (isCommon && computed === computed) {
      var seenIndex = seen.length;
      while (seenIndex--) {
        if (seen[seenIndex] === computed) {
          continue outer;
        }
      }
      if (iteratee) {
        seen.push(computed);
      }
      result.push(value);
    }
    else if (!includes(seen, computed, comparator)) {
      if (seen !== result) {
        seen.push(computed);
      }
      result.push(value);
    }
  }
  return result;
}

module.exports = baseUniq;


/***/ }),

/***/ "./node_modules/lodash/_baseValues.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_baseValues.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var arrayMap = __webpack_require__(/*! ./_arrayMap */ "./node_modules/lodash/_arrayMap.js");

/**
 * The base implementation of `_.values` and `_.valuesIn` which creates an
 * array of `object` property values corresponding to the property names
 * of `props`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array} props The property names to get values for.
 * @returns {Object} Returns the array of property values.
 */
function baseValues(object, props) {
  return arrayMap(props, function(key) {
    return object[key];
  });
}

module.exports = baseValues;


/***/ }),

/***/ "./node_modules/lodash/_baseZipObject.js":
/*!***********************************************!*\
  !*** ./node_modules/lodash/_baseZipObject.js ***!
  \***********************************************/
/***/ ((module) => {

/**
 * This base implementation of `_.zipObject` which assigns values using `assignFunc`.
 *
 * @private
 * @param {Array} props The property identifiers.
 * @param {Array} values The property values.
 * @param {Function} assignFunc The function to assign values.
 * @returns {Object} Returns the new object.
 */
function baseZipObject(props, values, assignFunc) {
  var index = -1,
      length = props.length,
      valsLength = values.length,
      result = {};

  while (++index < length) {
    var value = index < valsLength ? values[index] : undefined;
    assignFunc(result, props[index], value);
  }
  return result;
}

module.exports = baseZipObject;


/***/ }),

/***/ "./node_modules/lodash/_cacheHas.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/_cacheHas.js ***!
  \******************************************/
/***/ ((module) => {

/**
 * Checks if a `cache` value for `key` exists.
 *
 * @private
 * @param {Object} cache The cache to query.
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function cacheHas(cache, key) {
  return cache.has(key);
}

module.exports = cacheHas;


/***/ }),

/***/ "./node_modules/lodash/_castFunction.js":
/*!**********************************************!*\
  !*** ./node_modules/lodash/_castFunction.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var identity = __webpack_require__(/*! ./identity */ "./node_modules/lodash/identity.js");

/**
 * Casts `value` to `identity` if it's not a function.
 *
 * @private
 * @param {*} value The value to inspect.
 * @returns {Function} Returns cast function.
 */
function castFunction(value) {
  return typeof value == 'function' ? value : identity;
}

module.exports = castFunction;


/***/ }),

/***/ "./node_modules/lodash/_castPath.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/_castPath.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var isArray = __webpack_require__(/*! ./isArray */ "./node_modules/lodash/isArray.js"),
    isKey = __webpack_require__(/*! ./_isKey */ "./node_modules/lodash/_isKey.js"),
    stringToPath = __webpack_require__(/*! ./_stringToPath */ "./node_modules/lodash/_stringToPath.js"),
    toString = __webpack_require__(/*! ./toString */ "./node_modules/lodash/toString.js");

/**
 * Casts `value` to a path array if it's not one.
 *
 * @private
 * @param {*} value The value to inspect.
 * @param {Object} [object] The object to query keys on.
 * @returns {Array} Returns the cast property path array.
 */
function castPath(value, object) {
  if (isArray(value)) {
    return value;
  }
  return isKey(value, object) ? [value] : stringToPath(toString(value));
}

module.exports = castPath;


/***/ }),

/***/ "./node_modules/lodash/_cloneArrayBuffer.js":
/*!**************************************************!*\
  !*** ./node_modules/lodash/_cloneArrayBuffer.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var Uint8Array = __webpack_require__(/*! ./_Uint8Array */ "./node_modules/lodash/_Uint8Array.js");

/**
 * Creates a clone of `arrayBuffer`.
 *
 * @private
 * @param {ArrayBuffer} arrayBuffer The array buffer to clone.
 * @returns {ArrayBuffer} Returns the cloned array buffer.
 */
function cloneArrayBuffer(arrayBuffer) {
  var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
  new Uint8Array(result).set(new Uint8Array(arrayBuffer));
  return result;
}

module.exports = cloneArrayBuffer;


/***/ }),

/***/ "./node_modules/lodash/_cloneBuffer.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash/_cloneBuffer.js ***!
  \*********************************************/
/***/ ((module, exports, __webpack_require__) => {

/* module decorator */ module = __webpack_require__.nmd(module);
var root = __webpack_require__(/*! ./_root */ "./node_modules/lodash/_root.js");

/** Detect free variable `exports`. */
var freeExports =  true && exports && !exports.nodeType && exports;

/** Detect free variable `module`. */
var freeModule = freeExports && "object" == 'object' && module && !module.nodeType && module;

/** Detect the popular CommonJS extension `module.exports`. */
var moduleExports = freeModule && freeModule.exports === freeExports;

/** Built-in value references. */
var Buffer = moduleExports ? root.Buffer : undefined,
    allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined;

/**
 * Creates a clone of  `buffer`.
 *
 * @private
 * @param {Buffer} buffer The buffer to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Buffer} Returns the cloned buffer.
 */
function cloneBuffer(buffer, isDeep) {
  if (isDeep) {
    return buffer.slice();
  }
  var length = buffer.length,
      result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);

  buffer.copy(result);
  return result;
}

module.exports = cloneBuffer;


/***/ }),

/***/ "./node_modules/lodash/_cloneDataView.js":
/*!***********************************************!*\
  !*** ./node_modules/lodash/_cloneDataView.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var cloneArrayBuffer = __webpack_require__(/*! ./_cloneArrayBuffer */ "./node_modules/lodash/_cloneArrayBuffer.js");

/**
 * Creates a clone of `dataView`.
 *
 * @private
 * @param {Object} dataView The data view to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the cloned data view.
 */
function cloneDataView(dataView, isDeep) {
  var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
  return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
}

module.exports = cloneDataView;


/***/ }),

/***/ "./node_modules/lodash/_cloneRegExp.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash/_cloneRegExp.js ***!
  \*********************************************/
/***/ ((module) => {

/** Used to match `RegExp` flags from their coerced string values. */
var reFlags = /\w*$/;

/**
 * Creates a clone of `regexp`.
 *
 * @private
 * @param {Object} regexp The regexp to clone.
 * @returns {Object} Returns the cloned regexp.
 */
function cloneRegExp(regexp) {
  var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
  result.lastIndex = regexp.lastIndex;
  return result;
}

module.exports = cloneRegExp;


/***/ }),

/***/ "./node_modules/lodash/_cloneSymbol.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash/_cloneSymbol.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var Symbol = __webpack_require__(/*! ./_Symbol */ "./node_modules/lodash/_Symbol.js");

/** Used to convert symbols to primitives and strings. */
var symbolProto = Symbol ? Symbol.prototype : undefined,
    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;

/**
 * Creates a clone of the `symbol` object.
 *
 * @private
 * @param {Object} symbol The symbol object to clone.
 * @returns {Object} Returns the cloned symbol object.
 */
function cloneSymbol(symbol) {
  return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
}

module.exports = cloneSymbol;


/***/ }),

/***/ "./node_modules/lodash/_cloneTypedArray.js":
/*!*************************************************!*\
  !*** ./node_modules/lodash/_cloneTypedArray.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var cloneArrayBuffer = __webpack_require__(/*! ./_cloneArrayBuffer */ "./node_modules/lodash/_cloneArrayBuffer.js");

/**
 * Creates a clone of `typedArray`.
 *
 * @private
 * @param {Object} typedArray The typed array to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the cloned typed array.
 */
function cloneTypedArray(typedArray, isDeep) {
  var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
  return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
}

module.exports = cloneTypedArray;


/***/ }),

/***/ "./node_modules/lodash/_compareAscending.js":
/*!**************************************************!*\
  !*** ./node_modules/lodash/_compareAscending.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var isSymbol = __webpack_require__(/*! ./isSymbol */ "./node_modules/lodash/isSymbol.js");

/**
 * Compares values to sort them in ascending order.
 *
 * @private
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {number} Returns the sort order indicator for `value`.
 */
function compareAscending(value, other) {
  if (value !== other) {
    var valIsDefined = value !== undefined,
        valIsNull = value === null,
        valIsReflexive = value === value,
        valIsSymbol = isSymbol(value);

    var othIsDefined = other !== undefined,
        othIsNull = other === null,
        othIsReflexive = other === other,
        othIsSymbol = isSymbol(other);

    if ((!othIsNull && !othIsSymbol && !valIsSymbol && value > other) ||
        (valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol) ||
        (valIsNull && othIsDefined && othIsReflexive) ||
        (!valIsDefined && othIsReflexive) ||
        !valIsReflexive) {
      return 1;
    }
    if ((!valIsNull && !valIsSymbol && !othIsSymbol && value < other) ||
        (othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol) ||
        (othIsNull && valIsDefined && valIsReflexive) ||
        (!othIsDefined && valIsReflexive) ||
        !othIsReflexive) {
      return -1;
    }
  }
  return 0;
}

module.exports = compareAscending;


/***/ }),

/***/ "./node_modules/lodash/_compareMultiple.js":
/*!*************************************************!*\
  !*** ./node_modules/lodash/_compareMultiple.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var compareAscending = __webpack_require__(/*! ./_compareAscending */ "./node_modules/lodash/_compareAscending.js");

/**
 * Used by `_.orderBy` to compare multiple properties of a value to another
 * and stable sort them.
 *
 * If `orders` is unspecified, all values are sorted in ascending order. Otherwise,
 * specify an order of "desc" for descending or "asc" for ascending sort order
 * of corresponding values.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {boolean[]|string[]} orders The order to sort by for each property.
 * @returns {number} Returns the sort order indicator for `object`.
 */
function compareMultiple(object, other, orders) {
  var index = -1,
      objCriteria = object.criteria,
      othCriteria = other.criteria,
      length = objCriteria.length,
      ordersLength = orders.length;

  while (++index < length) {
    var result = compareAscending(objCriteria[index], othCriteria[index]);
    if (result) {
      if (index >= ordersLength) {
        return result;
      }
      var order = orders[index];
      return result * (order == 'desc' ? -1 : 1);
    }
  }
  // Fixes an `Array#sort` bug in the JS engine embedded in Adobe applications
  // that causes it, under certain circumstances, to provide the same value for
  // `object` and `other`. See https://github.com/jashkenas/underscore/pull/1247
  // for more details.
  //
  // This also ensures a stable sort in V8 and other engines.
  // See https://bugs.chromium.org/p/v8/issues/detail?id=90 for more details.
  return object.index - other.index;
}

module.exports = compareMultiple;


/***/ }),

/***/ "./node_modules/lodash/_copyArray.js":
/*!*******************************************!*\
  !*** ./node_modules/lodash/_copyArray.js ***!
  \*******************************************/
/***/ ((module) => {

/**
 * Copies the values of `source` to `array`.
 *
 * @private
 * @param {Array} source The array to copy values from.
 * @param {Array} [array=[]] The array to copy values to.
 * @returns {Array} Returns `array`.
 */
function copyArray(source, array) {
  var index = -1,
      length = source.length;

  array || (array = Array(length));
  while (++index < length) {
    array[index] = source[index];
  }
  return array;
}

module.exports = copyArray;


/***/ }),

/***/ "./node_modules/lodash/_copyObject.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_copyObject.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var assignValue = __webpack_require__(/*! ./_assignValue */ "./node_modules/lodash/_assignValue.js"),
    baseAssignValue = __webpack_require__(/*! ./_baseAssignValue */ "./node_modules/lodash/_baseAssignValue.js");

/**
 * Copies properties of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy properties from.
 * @param {Array} props The property identifiers to copy.
 * @param {Object} [object={}] The object to copy properties to.
 * @param {Function} [customizer] The function to customize copied values.
 * @returns {Object} Returns `object`.
 */
function copyObject(source, props, object, customizer) {
  var isNew = !object;
  object || (object = {});

  var index = -1,
      length = props.length;

  while (++index < length) {
    var key = props[index];

    var newValue = customizer
      ? customizer(object[key], source[key], key, object, source)
      : undefined;

    if (newValue === undefined) {
      newValue = source[key];
    }
    if (isNew) {
      baseAssignValue(object, key, newValue);
    } else {
      assignValue(object, key, newValue);
    }
  }
  return object;
}

module.exports = copyObject;


/***/ }),

/***/ "./node_modules/lodash/_copySymbols.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash/_copySymbols.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var copyObject = __webpack_require__(/*! ./_copyObject */ "./node_modules/lodash/_copyObject.js"),
    getSymbols = __webpack_require__(/*! ./_getSymbols */ "./node_modules/lodash/_getSymbols.js");

/**
 * Copies own symbols of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy symbols from.
 * @param {Object} [object={}] The object to copy symbols to.
 * @returns {Object} Returns `object`.
 */
function copySymbols(source, object) {
  return copyObject(source, getSymbols(source), object);
}

module.exports = copySymbols;


/***/ }),

/***/ "./node_modules/lodash/_copySymbolsIn.js":
/*!***********************************************!*\
  !*** ./node_modules/lodash/_copySymbolsIn.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var copyObject = __webpack_require__(/*! ./_copyObject */ "./node_modules/lodash/_copyObject.js"),
    getSymbolsIn = __webpack_require__(/*! ./_getSymbolsIn */ "./node_modules/lodash/_getSymbolsIn.js");

/**
 * Copies own and inherited symbols of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy symbols from.
 * @param {Object} [object={}] The object to copy symbols to.
 * @returns {Object} Returns `object`.
 */
function copySymbolsIn(source, object) {
  return copyObject(source, getSymbolsIn(source), object);
}

module.exports = copySymbolsIn;


/***/ }),

/***/ "./node_modules/lodash/_coreJsData.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_coreJsData.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var root = __webpack_require__(/*! ./_root */ "./node_modules/lodash/_root.js");

/** Used to detect overreaching core-js shims. */
var coreJsData = root['__core-js_shared__'];

module.exports = coreJsData;


/***/ }),

/***/ "./node_modules/lodash/_createAssigner.js":
/*!************************************************!*\
  !*** ./node_modules/lodash/_createAssigner.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseRest = __webpack_require__(/*! ./_baseRest */ "./node_modules/lodash/_baseRest.js"),
    isIterateeCall = __webpack_require__(/*! ./_isIterateeCall */ "./node_modules/lodash/_isIterateeCall.js");

/**
 * Creates a function like `_.assign`.
 *
 * @private
 * @param {Function} assigner The function to assign values.
 * @returns {Function} Returns the new assigner function.
 */
function createAssigner(assigner) {
  return baseRest(function(object, sources) {
    var index = -1,
        length = sources.length,
        customizer = length > 1 ? sources[length - 1] : undefined,
        guard = length > 2 ? sources[2] : undefined;

    customizer = (assigner.length > 3 && typeof customizer == 'function')
      ? (length--, customizer)
      : undefined;

    if (guard && isIterateeCall(sources[0], sources[1], guard)) {
      customizer = length < 3 ? undefined : customizer;
      length = 1;
    }
    object = Object(object);
    while (++index < length) {
      var source = sources[index];
      if (source) {
        assigner(object, source, index, customizer);
      }
    }
    return object;
  });
}

module.exports = createAssigner;


/***/ }),

/***/ "./node_modules/lodash/_createBaseEach.js":
/*!************************************************!*\
  !*** ./node_modules/lodash/_createBaseEach.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var isArrayLike = __webpack_require__(/*! ./isArrayLike */ "./node_modules/lodash/isArrayLike.js");

/**
 * Creates a `baseEach` or `baseEachRight` function.
 *
 * @private
 * @param {Function} eachFunc The function to iterate over a collection.
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {Function} Returns the new base function.
 */
function createBaseEach(eachFunc, fromRight) {
  return function(collection, iteratee) {
    if (collection == null) {
      return collection;
    }
    if (!isArrayLike(collection)) {
      return eachFunc(collection, iteratee);
    }
    var length = collection.length,
        index = fromRight ? length : -1,
        iterable = Object(collection);

    while ((fromRight ? index-- : ++index < length)) {
      if (iteratee(iterable[index], index, iterable) === false) {
        break;
      }
    }
    return collection;
  };
}

module.exports = createBaseEach;


/***/ }),

/***/ "./node_modules/lodash/_createBaseFor.js":
/*!***********************************************!*\
  !*** ./node_modules/lodash/_createBaseFor.js ***!
  \***********************************************/
/***/ ((module) => {

/**
 * Creates a base function for methods like `_.forIn` and `_.forOwn`.
 *
 * @private
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {Function} Returns the new base function.
 */
function createBaseFor(fromRight) {
  return function(object, iteratee, keysFunc) {
    var index = -1,
        iterable = Object(object),
        props = keysFunc(object),
        length = props.length;

    while (length--) {
      var key = props[fromRight ? length : ++index];
      if (iteratee(iterable[key], key, iterable) === false) {
        break;
      }
    }
    return object;
  };
}

module.exports = createBaseFor;


/***/ }),

/***/ "./node_modules/lodash/_createFind.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_createFind.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseIteratee = __webpack_require__(/*! ./_baseIteratee */ "./node_modules/lodash/_baseIteratee.js"),
    isArrayLike = __webpack_require__(/*! ./isArrayLike */ "./node_modules/lodash/isArrayLike.js"),
    keys = __webpack_require__(/*! ./keys */ "./node_modules/lodash/keys.js");

/**
 * Creates a `_.find` or `_.findLast` function.
 *
 * @private
 * @param {Function} findIndexFunc The function to find the collection index.
 * @returns {Function} Returns the new find function.
 */
function createFind(findIndexFunc) {
  return function(collection, predicate, fromIndex) {
    var iterable = Object(collection);
    if (!isArrayLike(collection)) {
      var iteratee = baseIteratee(predicate, 3);
      collection = keys(collection);
      predicate = function(key) { return iteratee(iterable[key], key, iterable); };
    }
    var index = findIndexFunc(collection, predicate, fromIndex);
    return index > -1 ? iterable[iteratee ? collection[index] : index] : undefined;
  };
}

module.exports = createFind;


/***/ }),

/***/ "./node_modules/lodash/_createRange.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash/_createRange.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseRange = __webpack_require__(/*! ./_baseRange */ "./node_modules/lodash/_baseRange.js"),
    isIterateeCall = __webpack_require__(/*! ./_isIterateeCall */ "./node_modules/lodash/_isIterateeCall.js"),
    toFinite = __webpack_require__(/*! ./toFinite */ "./node_modules/lodash/toFinite.js");

/**
 * Creates a `_.range` or `_.rangeRight` function.
 *
 * @private
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {Function} Returns the new range function.
 */
function createRange(fromRight) {
  return function(start, end, step) {
    if (step && typeof step != 'number' && isIterateeCall(start, end, step)) {
      end = step = undefined;
    }
    // Ensure the sign of `-0` is preserved.
    start = toFinite(start);
    if (end === undefined) {
      end = start;
      start = 0;
    } else {
      end = toFinite(end);
    }
    step = step === undefined ? (start < end ? 1 : -1) : toFinite(step);
    return baseRange(start, end, step, fromRight);
  };
}

module.exports = createRange;


/***/ }),

/***/ "./node_modules/lodash/_createSet.js":
/*!*******************************************!*\
  !*** ./node_modules/lodash/_createSet.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var Set = __webpack_require__(/*! ./_Set */ "./node_modules/lodash/_Set.js"),
    noop = __webpack_require__(/*! ./noop */ "./node_modules/lodash/noop.js"),
    setToArray = __webpack_require__(/*! ./_setToArray */ "./node_modules/lodash/_setToArray.js");

/** Used as references for various `Number` constants. */
var INFINITY = 1 / 0;

/**
 * Creates a set object of `values`.
 *
 * @private
 * @param {Array} values The values to add to the set.
 * @returns {Object} Returns the new set.
 */
var createSet = !(Set && (1 / setToArray(new Set([,-0]))[1]) == INFINITY) ? noop : function(values) {
  return new Set(values);
};

module.exports = createSet;


/***/ }),

/***/ "./node_modules/lodash/_defineProperty.js":
/*!************************************************!*\
  !*** ./node_modules/lodash/_defineProperty.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var getNative = __webpack_require__(/*! ./_getNative */ "./node_modules/lodash/_getNative.js");

var defineProperty = (function() {
  try {
    var func = getNative(Object, 'defineProperty');
    func({}, '', {});
    return func;
  } catch (e) {}
}());

module.exports = defineProperty;


/***/ }),

/***/ "./node_modules/lodash/_equalArrays.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash/_equalArrays.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var SetCache = __webpack_require__(/*! ./_SetCache */ "./node_modules/lodash/_SetCache.js"),
    arraySome = __webpack_require__(/*! ./_arraySome */ "./node_modules/lodash/_arraySome.js"),
    cacheHas = __webpack_require__(/*! ./_cacheHas */ "./node_modules/lodash/_cacheHas.js");

/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG = 1,
    COMPARE_UNORDERED_FLAG = 2;

/**
 * A specialized version of `baseIsEqualDeep` for arrays with support for
 * partial deep comparisons.
 *
 * @private
 * @param {Array} array The array to compare.
 * @param {Array} other The other array to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} stack Tracks traversed `array` and `other` objects.
 * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
 */
function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
      arrLength = array.length,
      othLength = other.length;

  if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
    return false;
  }
  // Check that cyclic values are equal.
  var arrStacked = stack.get(array);
  var othStacked = stack.get(other);
  if (arrStacked && othStacked) {
    return arrStacked == other && othStacked == array;
  }
  var index = -1,
      result = true,
      seen = (bitmask & COMPARE_UNORDERED_FLAG) ? new SetCache : undefined;

  stack.set(array, other);
  stack.set(other, array);

  // Ignore non-index properties.
  while (++index < arrLength) {
    var arrValue = array[index],
        othValue = other[index];

    if (customizer) {
      var compared = isPartial
        ? customizer(othValue, arrValue, index, other, array, stack)
        : customizer(arrValue, othValue, index, array, other, stack);
    }
    if (compared !== undefined) {
      if (compared) {
        continue;
      }
      result = false;
      break;
    }
    // Recursively compare arrays (susceptible to call stack limits).
    if (seen) {
      if (!arraySome(other, function(othValue, othIndex) {
            if (!cacheHas(seen, othIndex) &&
                (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
              return seen.push(othIndex);
            }
          })) {
        result = false;
        break;
      }
    } else if (!(
          arrValue === othValue ||
            equalFunc(arrValue, othValue, bitmask, customizer, stack)
        )) {
      result = false;
      break;
    }
  }
  stack['delete'](array);
  stack['delete'](other);
  return result;
}

module.exports = equalArrays;


/***/ }),

/***/ "./node_modules/lodash/_equalByTag.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_equalByTag.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var Symbol = __webpack_require__(/*! ./_Symbol */ "./node_modules/lodash/_Symbol.js"),
    Uint8Array = __webpack_require__(/*! ./_Uint8Array */ "./node_modules/lodash/_Uint8Array.js"),
    eq = __webpack_require__(/*! ./eq */ "./node_modules/lodash/eq.js"),
    equalArrays = __webpack_require__(/*! ./_equalArrays */ "./node_modules/lodash/_equalArrays.js"),
    mapToArray = __webpack_require__(/*! ./_mapToArray */ "./node_modules/lodash/_mapToArray.js"),
    setToArray = __webpack_require__(/*! ./_setToArray */ "./node_modules/lodash/_setToArray.js");

/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG = 1,
    COMPARE_UNORDERED_FLAG = 2;

/** `Object#toString` result references. */
var boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    errorTag = '[object Error]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    symbolTag = '[object Symbol]';

var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]';

/** Used to convert symbols to primitives and strings. */
var symbolProto = Symbol ? Symbol.prototype : undefined,
    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;

/**
 * A specialized version of `baseIsEqualDeep` for comparing objects of
 * the same `toStringTag`.
 *
 * **Note:** This function only supports comparing values with tags of
 * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {string} tag The `toStringTag` of the objects to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} stack Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */
function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
  switch (tag) {
    case dataViewTag:
      if ((object.byteLength != other.byteLength) ||
          (object.byteOffset != other.byteOffset)) {
        return false;
      }
      object = object.buffer;
      other = other.buffer;

    case arrayBufferTag:
      if ((object.byteLength != other.byteLength) ||
          !equalFunc(new Uint8Array(object), new Uint8Array(other))) {
        return false;
      }
      return true;

    case boolTag:
    case dateTag:
    case numberTag:
      // Coerce booleans to `1` or `0` and dates to milliseconds.
      // Invalid dates are coerced to `NaN`.
      return eq(+object, +other);

    case errorTag:
      return object.name == other.name && object.message == other.message;

    case regexpTag:
    case stringTag:
      // Coerce regexes to strings and treat strings, primitives and objects,
      // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring
      // for more details.
      return object == (other + '');

    case mapTag:
      var convert = mapToArray;

    case setTag:
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
      convert || (convert = setToArray);

      if (object.size != other.size && !isPartial) {
        return false;
      }
      // Assume cyclic values are equal.
      var stacked = stack.get(object);
      if (stacked) {
        return stacked == other;
      }
      bitmask |= COMPARE_UNORDERED_FLAG;

      // Recursively compare objects (susceptible to call stack limits).
      stack.set(object, other);
      var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
      stack['delete'](object);
      return result;

    case symbolTag:
      if (symbolValueOf) {
        return symbolValueOf.call(object) == symbolValueOf.call(other);
      }
  }
  return false;
}

module.exports = equalByTag;


/***/ }),

/***/ "./node_modules/lodash/_equalObjects.js":
/*!**********************************************!*\
  !*** ./node_modules/lodash/_equalObjects.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var getAllKeys = __webpack_require__(/*! ./_getAllKeys */ "./node_modules/lodash/_getAllKeys.js");

/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG = 1;

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * A specialized version of `baseIsEqualDeep` for objects with support for
 * partial deep comparisons.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} stack Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */
function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
      objProps = getAllKeys(object),
      objLength = objProps.length,
      othProps = getAllKeys(other),
      othLength = othProps.length;

  if (objLength != othLength && !isPartial) {
    return false;
  }
  var index = objLength;
  while (index--) {
    var key = objProps[index];
    if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
      return false;
    }
  }
  // Check that cyclic values are equal.
  var objStacked = stack.get(object);
  var othStacked = stack.get(other);
  if (objStacked && othStacked) {
    return objStacked == other && othStacked == object;
  }
  var result = true;
  stack.set(object, other);
  stack.set(other, object);

  var skipCtor = isPartial;
  while (++index < objLength) {
    key = objProps[index];
    var objValue = object[key],
        othValue = other[key];

    if (customizer) {
      var compared = isPartial
        ? customizer(othValue, objValue, key, other, object, stack)
        : customizer(objValue, othValue, key, object, other, stack);
    }
    // Recursively compare objects (susceptible to call stack limits).
    if (!(compared === undefined
          ? (objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack))
          : compared
        )) {
      result = false;
      break;
    }
    skipCtor || (skipCtor = key == 'constructor');
  }
  if (result && !skipCtor) {
    var objCtor = object.constructor,
        othCtor = other.constructor;

    // Non `Object` object instances with different constructors are not equal.
    if (objCtor != othCtor &&
        ('constructor' in object && 'constructor' in other) &&
        !(typeof objCtor == 'function' && objCtor instanceof objCtor &&
          typeof othCtor == 'function' && othCtor instanceof othCtor)) {
      result = false;
    }
  }
  stack['delete'](object);
  stack['delete'](other);
  return result;
}

module.exports = equalObjects;


/***/ }),

/***/ "./node_modules/lodash/_flatRest.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/_flatRest.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var flatten = __webpack_require__(/*! ./flatten */ "./node_modules/lodash/flatten.js"),
    overRest = __webpack_require__(/*! ./_overRest */ "./node_modules/lodash/_overRest.js"),
    setToString = __webpack_require__(/*! ./_setToString */ "./node_modules/lodash/_setToString.js");

/**
 * A specialized version of `baseRest` which flattens the rest array.
 *
 * @private
 * @param {Function} func The function to apply a rest parameter to.
 * @returns {Function} Returns the new function.
 */
function flatRest(func) {
  return setToString(overRest(func, undefined, flatten), func + '');
}

module.exports = flatRest;


/***/ }),

/***/ "./node_modules/lodash/_freeGlobal.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_freeGlobal.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/** Detect free variable `global` from Node.js. */
var freeGlobal = typeof __webpack_require__.g == 'object' && __webpack_require__.g && __webpack_require__.g.Object === Object && __webpack_require__.g;

module.exports = freeGlobal;


/***/ }),

/***/ "./node_modules/lodash/_getAllKeys.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_getAllKeys.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseGetAllKeys = __webpack_require__(/*! ./_baseGetAllKeys */ "./node_modules/lodash/_baseGetAllKeys.js"),
    getSymbols = __webpack_require__(/*! ./_getSymbols */ "./node_modules/lodash/_getSymbols.js"),
    keys = __webpack_require__(/*! ./keys */ "./node_modules/lodash/keys.js");

/**
 * Creates an array of own enumerable property names and symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names and symbols.
 */
function getAllKeys(object) {
  return baseGetAllKeys(object, keys, getSymbols);
}

module.exports = getAllKeys;


/***/ }),

/***/ "./node_modules/lodash/_getAllKeysIn.js":
/*!**********************************************!*\
  !*** ./node_modules/lodash/_getAllKeysIn.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseGetAllKeys = __webpack_require__(/*! ./_baseGetAllKeys */ "./node_modules/lodash/_baseGetAllKeys.js"),
    getSymbolsIn = __webpack_require__(/*! ./_getSymbolsIn */ "./node_modules/lodash/_getSymbolsIn.js"),
    keysIn = __webpack_require__(/*! ./keysIn */ "./node_modules/lodash/keysIn.js");

/**
 * Creates an array of own and inherited enumerable property names and
 * symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names and symbols.
 */
function getAllKeysIn(object) {
  return baseGetAllKeys(object, keysIn, getSymbolsIn);
}

module.exports = getAllKeysIn;


/***/ }),

/***/ "./node_modules/lodash/_getMapData.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_getMapData.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var isKeyable = __webpack_require__(/*! ./_isKeyable */ "./node_modules/lodash/_isKeyable.js");

/**
 * Gets the data for `map`.
 *
 * @private
 * @param {Object} map The map to query.
 * @param {string} key The reference key.
 * @returns {*} Returns the map data.
 */
function getMapData(map, key) {
  var data = map.__data__;
  return isKeyable(key)
    ? data[typeof key == 'string' ? 'string' : 'hash']
    : data.map;
}

module.exports = getMapData;


/***/ }),

/***/ "./node_modules/lodash/_getMatchData.js":
/*!**********************************************!*\
  !*** ./node_modules/lodash/_getMatchData.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var isStrictComparable = __webpack_require__(/*! ./_isStrictComparable */ "./node_modules/lodash/_isStrictComparable.js"),
    keys = __webpack_require__(/*! ./keys */ "./node_modules/lodash/keys.js");

/**
 * Gets the property names, values, and compare flags of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the match data of `object`.
 */
function getMatchData(object) {
  var result = keys(object),
      length = result.length;

  while (length--) {
    var key = result[length],
        value = object[key];

    result[length] = [key, value, isStrictComparable(value)];
  }
  return result;
}

module.exports = getMatchData;


/***/ }),

/***/ "./node_modules/lodash/_getNative.js":
/*!*******************************************!*\
  !*** ./node_modules/lodash/_getNative.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseIsNative = __webpack_require__(/*! ./_baseIsNative */ "./node_modules/lodash/_baseIsNative.js"),
    getValue = __webpack_require__(/*! ./_getValue */ "./node_modules/lodash/_getValue.js");

/**
 * Gets the native function at `key` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the method to get.
 * @returns {*} Returns the function if it's native, else `undefined`.
 */
function getNative(object, key) {
  var value = getValue(object, key);
  return baseIsNative(value) ? value : undefined;
}

module.exports = getNative;


/***/ }),

/***/ "./node_modules/lodash/_getPrototype.js":
/*!**********************************************!*\
  !*** ./node_modules/lodash/_getPrototype.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var overArg = __webpack_require__(/*! ./_overArg */ "./node_modules/lodash/_overArg.js");

/** Built-in value references. */
var getPrototype = overArg(Object.getPrototypeOf, Object);

module.exports = getPrototype;


/***/ }),

/***/ "./node_modules/lodash/_getRawTag.js":
/*!*******************************************!*\
  !*** ./node_modules/lodash/_getRawTag.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var Symbol = __webpack_require__(/*! ./_Symbol */ "./node_modules/lodash/_Symbol.js");

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var nativeObjectToString = objectProto.toString;

/** Built-in value references. */
var symToStringTag = Symbol ? Symbol.toStringTag : undefined;

/**
 * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the raw `toStringTag`.
 */
function getRawTag(value) {
  var isOwn = hasOwnProperty.call(value, symToStringTag),
      tag = value[symToStringTag];

  try {
    value[symToStringTag] = undefined;
    var unmasked = true;
  } catch (e) {}

  var result = nativeObjectToString.call(value);
  if (unmasked) {
    if (isOwn) {
      value[symToStringTag] = tag;
    } else {
      delete value[symToStringTag];
    }
  }
  return result;
}

module.exports = getRawTag;


/***/ }),

/***/ "./node_modules/lodash/_getSymbols.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_getSymbols.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var arrayFilter = __webpack_require__(/*! ./_arrayFilter */ "./node_modules/lodash/_arrayFilter.js"),
    stubArray = __webpack_require__(/*! ./stubArray */ "./node_modules/lodash/stubArray.js");

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Built-in value references. */
var propertyIsEnumerable = objectProto.propertyIsEnumerable;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeGetSymbols = Object.getOwnPropertySymbols;

/**
 * Creates an array of the own enumerable symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of symbols.
 */
var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
  if (object == null) {
    return [];
  }
  object = Object(object);
  return arrayFilter(nativeGetSymbols(object), function(symbol) {
    return propertyIsEnumerable.call(object, symbol);
  });
};

module.exports = getSymbols;


/***/ }),

/***/ "./node_modules/lodash/_getSymbolsIn.js":
/*!**********************************************!*\
  !*** ./node_modules/lodash/_getSymbolsIn.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var arrayPush = __webpack_require__(/*! ./_arrayPush */ "./node_modules/lodash/_arrayPush.js"),
    getPrototype = __webpack_require__(/*! ./_getPrototype */ "./node_modules/lodash/_getPrototype.js"),
    getSymbols = __webpack_require__(/*! ./_getSymbols */ "./node_modules/lodash/_getSymbols.js"),
    stubArray = __webpack_require__(/*! ./stubArray */ "./node_modules/lodash/stubArray.js");

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeGetSymbols = Object.getOwnPropertySymbols;

/**
 * Creates an array of the own and inherited enumerable symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of symbols.
 */
var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {
  var result = [];
  while (object) {
    arrayPush(result, getSymbols(object));
    object = getPrototype(object);
  }
  return result;
};

module.exports = getSymbolsIn;


/***/ }),

/***/ "./node_modules/lodash/_getTag.js":
/*!****************************************!*\
  !*** ./node_modules/lodash/_getTag.js ***!
  \****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var DataView = __webpack_require__(/*! ./_DataView */ "./node_modules/lodash/_DataView.js"),
    Map = __webpack_require__(/*! ./_Map */ "./node_modules/lodash/_Map.js"),
    Promise = __webpack_require__(/*! ./_Promise */ "./node_modules/lodash/_Promise.js"),
    Set = __webpack_require__(/*! ./_Set */ "./node_modules/lodash/_Set.js"),
    WeakMap = __webpack_require__(/*! ./_WeakMap */ "./node_modules/lodash/_WeakMap.js"),
    baseGetTag = __webpack_require__(/*! ./_baseGetTag */ "./node_modules/lodash/_baseGetTag.js"),
    toSource = __webpack_require__(/*! ./_toSource */ "./node_modules/lodash/_toSource.js");

/** `Object#toString` result references. */
var mapTag = '[object Map]',
    objectTag = '[object Object]',
    promiseTag = '[object Promise]',
    setTag = '[object Set]',
    weakMapTag = '[object WeakMap]';

var dataViewTag = '[object DataView]';

/** Used to detect maps, sets, and weakmaps. */
var dataViewCtorString = toSource(DataView),
    mapCtorString = toSource(Map),
    promiseCtorString = toSource(Promise),
    setCtorString = toSource(Set),
    weakMapCtorString = toSource(WeakMap);

/**
 * Gets the `toStringTag` of `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
var getTag = baseGetTag;

// Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.
if ((DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag) ||
    (Map && getTag(new Map) != mapTag) ||
    (Promise && getTag(Promise.resolve()) != promiseTag) ||
    (Set && getTag(new Set) != setTag) ||
    (WeakMap && getTag(new WeakMap) != weakMapTag)) {
  getTag = function(value) {
    var result = baseGetTag(value),
        Ctor = result == objectTag ? value.constructor : undefined,
        ctorString = Ctor ? toSource(Ctor) : '';

    if (ctorString) {
      switch (ctorString) {
        case dataViewCtorString: return dataViewTag;
        case mapCtorString: return mapTag;
        case promiseCtorString: return promiseTag;
        case setCtorString: return setTag;
        case weakMapCtorString: return weakMapTag;
      }
    }
    return result;
  };
}

module.exports = getTag;


/***/ }),

/***/ "./node_modules/lodash/_getValue.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/_getValue.js ***!
  \******************************************/
/***/ ((module) => {

/**
 * Gets the value at `key` of `object`.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */
function getValue(object, key) {
  return object == null ? undefined : object[key];
}

module.exports = getValue;


/***/ }),

/***/ "./node_modules/lodash/_hasPath.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/_hasPath.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var castPath = __webpack_require__(/*! ./_castPath */ "./node_modules/lodash/_castPath.js"),
    isArguments = __webpack_require__(/*! ./isArguments */ "./node_modules/lodash/isArguments.js"),
    isArray = __webpack_require__(/*! ./isArray */ "./node_modules/lodash/isArray.js"),
    isIndex = __webpack_require__(/*! ./_isIndex */ "./node_modules/lodash/_isIndex.js"),
    isLength = __webpack_require__(/*! ./isLength */ "./node_modules/lodash/isLength.js"),
    toKey = __webpack_require__(/*! ./_toKey */ "./node_modules/lodash/_toKey.js");

/**
 * Checks if `path` exists on `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array|string} path The path to check.
 * @param {Function} hasFunc The function to check properties.
 * @returns {boolean} Returns `true` if `path` exists, else `false`.
 */
function hasPath(object, path, hasFunc) {
  path = castPath(path, object);

  var index = -1,
      length = path.length,
      result = false;

  while (++index < length) {
    var key = toKey(path[index]);
    if (!(result = object != null && hasFunc(object, key))) {
      break;
    }
    object = object[key];
  }
  if (result || ++index != length) {
    return result;
  }
  length = object == null ? 0 : object.length;
  return !!length && isLength(length) && isIndex(key, length) &&
    (isArray(object) || isArguments(object));
}

module.exports = hasPath;


/***/ }),

/***/ "./node_modules/lodash/_hasUnicode.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_hasUnicode.js ***!
  \********************************************/
/***/ ((module) => {

/** Used to compose unicode character classes. */
var rsAstralRange = '\\ud800-\\udfff',
    rsComboMarksRange = '\\u0300-\\u036f',
    reComboHalfMarksRange = '\\ufe20-\\ufe2f',
    rsComboSymbolsRange = '\\u20d0-\\u20ff',
    rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange,
    rsVarRange = '\\ufe0e\\ufe0f';

/** Used to compose unicode capture groups. */
var rsZWJ = '\\u200d';

/** Used to detect strings with [zero-width joiners or code points from the astral planes](http://eev.ee/blog/2015/09/12/dark-corners-of-unicode/). */
var reHasUnicode = RegExp('[' + rsZWJ + rsAstralRange  + rsComboRange + rsVarRange + ']');

/**
 * Checks if `string` contains Unicode symbols.
 *
 * @private
 * @param {string} string The string to inspect.
 * @returns {boolean} Returns `true` if a symbol is found, else `false`.
 */
function hasUnicode(string) {
  return reHasUnicode.test(string);
}

module.exports = hasUnicode;


/***/ }),

/***/ "./node_modules/lodash/_hashClear.js":
/*!*******************************************!*\
  !*** ./node_modules/lodash/_hashClear.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var nativeCreate = __webpack_require__(/*! ./_nativeCreate */ "./node_modules/lodash/_nativeCreate.js");

/**
 * Removes all key-value entries from the hash.
 *
 * @private
 * @name clear
 * @memberOf Hash
 */
function hashClear() {
  this.__data__ = nativeCreate ? nativeCreate(null) : {};
  this.size = 0;
}

module.exports = hashClear;


/***/ }),

/***/ "./node_modules/lodash/_hashDelete.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_hashDelete.js ***!
  \********************************************/
/***/ ((module) => {

/**
 * Removes `key` and its value from the hash.
 *
 * @private
 * @name delete
 * @memberOf Hash
 * @param {Object} hash The hash to modify.
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function hashDelete(key) {
  var result = this.has(key) && delete this.__data__[key];
  this.size -= result ? 1 : 0;
  return result;
}

module.exports = hashDelete;


/***/ }),

/***/ "./node_modules/lodash/_hashGet.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/_hashGet.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var nativeCreate = __webpack_require__(/*! ./_nativeCreate */ "./node_modules/lodash/_nativeCreate.js");

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED = '__lodash_hash_undefined__';

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Gets the hash value for `key`.
 *
 * @private
 * @name get
 * @memberOf Hash
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function hashGet(key) {
  var data = this.__data__;
  if (nativeCreate) {
    var result = data[key];
    return result === HASH_UNDEFINED ? undefined : result;
  }
  return hasOwnProperty.call(data, key) ? data[key] : undefined;
}

module.exports = hashGet;


/***/ }),

/***/ "./node_modules/lodash/_hashHas.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/_hashHas.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var nativeCreate = __webpack_require__(/*! ./_nativeCreate */ "./node_modules/lodash/_nativeCreate.js");

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Checks if a hash value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Hash
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function hashHas(key) {
  var data = this.__data__;
  return nativeCreate ? (data[key] !== undefined) : hasOwnProperty.call(data, key);
}

module.exports = hashHas;


/***/ }),

/***/ "./node_modules/lodash/_hashSet.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/_hashSet.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var nativeCreate = __webpack_require__(/*! ./_nativeCreate */ "./node_modules/lodash/_nativeCreate.js");

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED = '__lodash_hash_undefined__';

/**
 * Sets the hash `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Hash
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the hash instance.
 */
function hashSet(key, value) {
  var data = this.__data__;
  this.size += this.has(key) ? 0 : 1;
  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;
  return this;
}

module.exports = hashSet;


/***/ }),

/***/ "./node_modules/lodash/_initCloneArray.js":
/*!************************************************!*\
  !*** ./node_modules/lodash/_initCloneArray.js ***!
  \************************************************/
/***/ ((module) => {

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Initializes an array clone.
 *
 * @private
 * @param {Array} array The array to clone.
 * @returns {Array} Returns the initialized clone.
 */
function initCloneArray(array) {
  var length = array.length,
      result = new array.constructor(length);

  // Add properties assigned by `RegExp#exec`.
  if (length && typeof array[0] == 'string' && hasOwnProperty.call(array, 'index')) {
    result.index = array.index;
    result.input = array.input;
  }
  return result;
}

module.exports = initCloneArray;


/***/ }),

/***/ "./node_modules/lodash/_initCloneByTag.js":
/*!************************************************!*\
  !*** ./node_modules/lodash/_initCloneByTag.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var cloneArrayBuffer = __webpack_require__(/*! ./_cloneArrayBuffer */ "./node_modules/lodash/_cloneArrayBuffer.js"),
    cloneDataView = __webpack_require__(/*! ./_cloneDataView */ "./node_modules/lodash/_cloneDataView.js"),
    cloneRegExp = __webpack_require__(/*! ./_cloneRegExp */ "./node_modules/lodash/_cloneRegExp.js"),
    cloneSymbol = __webpack_require__(/*! ./_cloneSymbol */ "./node_modules/lodash/_cloneSymbol.js"),
    cloneTypedArray = __webpack_require__(/*! ./_cloneTypedArray */ "./node_modules/lodash/_cloneTypedArray.js");

/** `Object#toString` result references. */
var boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    symbolTag = '[object Symbol]';

var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]',
    float32Tag = '[object Float32Array]',
    float64Tag = '[object Float64Array]',
    int8Tag = '[object Int8Array]',
    int16Tag = '[object Int16Array]',
    int32Tag = '[object Int32Array]',
    uint8Tag = '[object Uint8Array]',
    uint8ClampedTag = '[object Uint8ClampedArray]',
    uint16Tag = '[object Uint16Array]',
    uint32Tag = '[object Uint32Array]';

/**
 * Initializes an object clone based on its `toStringTag`.
 *
 * **Note:** This function only supports cloning values with tags of
 * `Boolean`, `Date`, `Error`, `Map`, `Number`, `RegExp`, `Set`, or `String`.
 *
 * @private
 * @param {Object} object The object to clone.
 * @param {string} tag The `toStringTag` of the object to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the initialized clone.
 */
function initCloneByTag(object, tag, isDeep) {
  var Ctor = object.constructor;
  switch (tag) {
    case arrayBufferTag:
      return cloneArrayBuffer(object);

    case boolTag:
    case dateTag:
      return new Ctor(+object);

    case dataViewTag:
      return cloneDataView(object, isDeep);

    case float32Tag: case float64Tag:
    case int8Tag: case int16Tag: case int32Tag:
    case uint8Tag: case uint8ClampedTag: case uint16Tag: case uint32Tag:
      return cloneTypedArray(object, isDeep);

    case mapTag:
      return new Ctor;

    case numberTag:
    case stringTag:
      return new Ctor(object);

    case regexpTag:
      return cloneRegExp(object);

    case setTag:
      return new Ctor;

    case symbolTag:
      return cloneSymbol(object);
  }
}

module.exports = initCloneByTag;


/***/ }),

/***/ "./node_modules/lodash/_initCloneObject.js":
/*!*************************************************!*\
  !*** ./node_modules/lodash/_initCloneObject.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseCreate = __webpack_require__(/*! ./_baseCreate */ "./node_modules/lodash/_baseCreate.js"),
    getPrototype = __webpack_require__(/*! ./_getPrototype */ "./node_modules/lodash/_getPrototype.js"),
    isPrototype = __webpack_require__(/*! ./_isPrototype */ "./node_modules/lodash/_isPrototype.js");

/**
 * Initializes an object clone.
 *
 * @private
 * @param {Object} object The object to clone.
 * @returns {Object} Returns the initialized clone.
 */
function initCloneObject(object) {
  return (typeof object.constructor == 'function' && !isPrototype(object))
    ? baseCreate(getPrototype(object))
    : {};
}

module.exports = initCloneObject;


/***/ }),

/***/ "./node_modules/lodash/_isFlattenable.js":
/*!***********************************************!*\
  !*** ./node_modules/lodash/_isFlattenable.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var Symbol = __webpack_require__(/*! ./_Symbol */ "./node_modules/lodash/_Symbol.js"),
    isArguments = __webpack_require__(/*! ./isArguments */ "./node_modules/lodash/isArguments.js"),
    isArray = __webpack_require__(/*! ./isArray */ "./node_modules/lodash/isArray.js");

/** Built-in value references. */
var spreadableSymbol = Symbol ? Symbol.isConcatSpreadable : undefined;

/**
 * Checks if `value` is a flattenable `arguments` object or array.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is flattenable, else `false`.
 */
function isFlattenable(value) {
  return isArray(value) || isArguments(value) ||
    !!(spreadableSymbol && value && value[spreadableSymbol]);
}

module.exports = isFlattenable;


/***/ }),

/***/ "./node_modules/lodash/_isIndex.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/_isIndex.js ***!
  \*****************************************/
/***/ ((module) => {

/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER = 9007199254740991;

/** Used to detect unsigned integer values. */
var reIsUint = /^(?:0|[1-9]\d*)$/;

/**
 * Checks if `value` is a valid array-like index.
 *
 * @private
 * @param {*} value The value to check.
 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
 */
function isIndex(value, length) {
  var type = typeof value;
  length = length == null ? MAX_SAFE_INTEGER : length;

  return !!length &&
    (type == 'number' ||
      (type != 'symbol' && reIsUint.test(value))) &&
        (value > -1 && value % 1 == 0 && value < length);
}

module.exports = isIndex;


/***/ }),

/***/ "./node_modules/lodash/_isIterateeCall.js":
/*!************************************************!*\
  !*** ./node_modules/lodash/_isIterateeCall.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var eq = __webpack_require__(/*! ./eq */ "./node_modules/lodash/eq.js"),
    isArrayLike = __webpack_require__(/*! ./isArrayLike */ "./node_modules/lodash/isArrayLike.js"),
    isIndex = __webpack_require__(/*! ./_isIndex */ "./node_modules/lodash/_isIndex.js"),
    isObject = __webpack_require__(/*! ./isObject */ "./node_modules/lodash/isObject.js");

/**
 * Checks if the given arguments are from an iteratee call.
 *
 * @private
 * @param {*} value The potential iteratee value argument.
 * @param {*} index The potential iteratee index or key argument.
 * @param {*} object The potential iteratee object argument.
 * @returns {boolean} Returns `true` if the arguments are from an iteratee call,
 *  else `false`.
 */
function isIterateeCall(value, index, object) {
  if (!isObject(object)) {
    return false;
  }
  var type = typeof index;
  if (type == 'number'
        ? (isArrayLike(object) && isIndex(index, object.length))
        : (type == 'string' && index in object)
      ) {
    return eq(object[index], value);
  }
  return false;
}

module.exports = isIterateeCall;


/***/ }),

/***/ "./node_modules/lodash/_isKey.js":
/*!***************************************!*\
  !*** ./node_modules/lodash/_isKey.js ***!
  \***************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var isArray = __webpack_require__(/*! ./isArray */ "./node_modules/lodash/isArray.js"),
    isSymbol = __webpack_require__(/*! ./isSymbol */ "./node_modules/lodash/isSymbol.js");

/** Used to match property names within property paths. */
var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
    reIsPlainProp = /^\w*$/;

/**
 * Checks if `value` is a property name and not a property path.
 *
 * @private
 * @param {*} value The value to check.
 * @param {Object} [object] The object to query keys on.
 * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
 */
function isKey(value, object) {
  if (isArray(value)) {
    return false;
  }
  var type = typeof value;
  if (type == 'number' || type == 'symbol' || type == 'boolean' ||
      value == null || isSymbol(value)) {
    return true;
  }
  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||
    (object != null && value in Object(object));
}

module.exports = isKey;


/***/ }),

/***/ "./node_modules/lodash/_isKeyable.js":
/*!*******************************************!*\
  !*** ./node_modules/lodash/_isKeyable.js ***!
  \*******************************************/
/***/ ((module) => {

/**
 * Checks if `value` is suitable for use as unique object key.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
 */
function isKeyable(value) {
  var type = typeof value;
  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
    ? (value !== '__proto__')
    : (value === null);
}

module.exports = isKeyable;


/***/ }),

/***/ "./node_modules/lodash/_isMasked.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/_isMasked.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var coreJsData = __webpack_require__(/*! ./_coreJsData */ "./node_modules/lodash/_coreJsData.js");

/** Used to detect methods masquerading as native. */
var maskSrcKey = (function() {
  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
  return uid ? ('Symbol(src)_1.' + uid) : '';
}());

/**
 * Checks if `func` has its source masked.
 *
 * @private
 * @param {Function} func The function to check.
 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
 */
function isMasked(func) {
  return !!maskSrcKey && (maskSrcKey in func);
}

module.exports = isMasked;


/***/ }),

/***/ "./node_modules/lodash/_isPrototype.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash/_isPrototype.js ***!
  \*********************************************/
/***/ ((module) => {

/** Used for built-in method references. */
var objectProto = Object.prototype;

/**
 * Checks if `value` is likely a prototype object.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
 */
function isPrototype(value) {
  var Ctor = value && value.constructor,
      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;

  return value === proto;
}

module.exports = isPrototype;


/***/ }),

/***/ "./node_modules/lodash/_isStrictComparable.js":
/*!****************************************************!*\
  !*** ./node_modules/lodash/_isStrictComparable.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var isObject = __webpack_require__(/*! ./isObject */ "./node_modules/lodash/isObject.js");

/**
 * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` if suitable for strict
 *  equality comparisons, else `false`.
 */
function isStrictComparable(value) {
  return value === value && !isObject(value);
}

module.exports = isStrictComparable;


/***/ }),

/***/ "./node_modules/lodash/_listCacheClear.js":
/*!************************************************!*\
  !*** ./node_modules/lodash/_listCacheClear.js ***!
  \************************************************/
/***/ ((module) => {

/**
 * Removes all key-value entries from the list cache.
 *
 * @private
 * @name clear
 * @memberOf ListCache
 */
function listCacheClear() {
  this.__data__ = [];
  this.size = 0;
}

module.exports = listCacheClear;


/***/ }),

/***/ "./node_modules/lodash/_listCacheDelete.js":
/*!*************************************************!*\
  !*** ./node_modules/lodash/_listCacheDelete.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var assocIndexOf = __webpack_require__(/*! ./_assocIndexOf */ "./node_modules/lodash/_assocIndexOf.js");

/** Used for built-in method references. */
var arrayProto = Array.prototype;

/** Built-in value references. */
var splice = arrayProto.splice;

/**
 * Removes `key` and its value from the list cache.
 *
 * @private
 * @name delete
 * @memberOf ListCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function listCacheDelete(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    return false;
  }
  var lastIndex = data.length - 1;
  if (index == lastIndex) {
    data.pop();
  } else {
    splice.call(data, index, 1);
  }
  --this.size;
  return true;
}

module.exports = listCacheDelete;


/***/ }),

/***/ "./node_modules/lodash/_listCacheGet.js":
/*!**********************************************!*\
  !*** ./node_modules/lodash/_listCacheGet.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var assocIndexOf = __webpack_require__(/*! ./_assocIndexOf */ "./node_modules/lodash/_assocIndexOf.js");

/**
 * Gets the list cache value for `key`.
 *
 * @private
 * @name get
 * @memberOf ListCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function listCacheGet(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  return index < 0 ? undefined : data[index][1];
}

module.exports = listCacheGet;


/***/ }),

/***/ "./node_modules/lodash/_listCacheHas.js":
/*!**********************************************!*\
  !*** ./node_modules/lodash/_listCacheHas.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var assocIndexOf = __webpack_require__(/*! ./_assocIndexOf */ "./node_modules/lodash/_assocIndexOf.js");

/**
 * Checks if a list cache value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf ListCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function listCacheHas(key) {
  return assocIndexOf(this.__data__, key) > -1;
}

module.exports = listCacheHas;


/***/ }),

/***/ "./node_modules/lodash/_listCacheSet.js":
/*!**********************************************!*\
  !*** ./node_modules/lodash/_listCacheSet.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var assocIndexOf = __webpack_require__(/*! ./_assocIndexOf */ "./node_modules/lodash/_assocIndexOf.js");

/**
 * Sets the list cache `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf ListCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the list cache instance.
 */
function listCacheSet(key, value) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    ++this.size;
    data.push([key, value]);
  } else {
    data[index][1] = value;
  }
  return this;
}

module.exports = listCacheSet;


/***/ }),

/***/ "./node_modules/lodash/_mapCacheClear.js":
/*!***********************************************!*\
  !*** ./node_modules/lodash/_mapCacheClear.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var Hash = __webpack_require__(/*! ./_Hash */ "./node_modules/lodash/_Hash.js"),
    ListCache = __webpack_require__(/*! ./_ListCache */ "./node_modules/lodash/_ListCache.js"),
    Map = __webpack_require__(/*! ./_Map */ "./node_modules/lodash/_Map.js");

/**
 * Removes all key-value entries from the map.
 *
 * @private
 * @name clear
 * @memberOf MapCache
 */
function mapCacheClear() {
  this.size = 0;
  this.__data__ = {
    'hash': new Hash,
    'map': new (Map || ListCache),
    'string': new Hash
  };
}

module.exports = mapCacheClear;


/***/ }),

/***/ "./node_modules/lodash/_mapCacheDelete.js":
/*!************************************************!*\
  !*** ./node_modules/lodash/_mapCacheDelete.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var getMapData = __webpack_require__(/*! ./_getMapData */ "./node_modules/lodash/_getMapData.js");

/**
 * Removes `key` and its value from the map.
 *
 * @private
 * @name delete
 * @memberOf MapCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function mapCacheDelete(key) {
  var result = getMapData(this, key)['delete'](key);
  this.size -= result ? 1 : 0;
  return result;
}

module.exports = mapCacheDelete;


/***/ }),

/***/ "./node_modules/lodash/_mapCacheGet.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash/_mapCacheGet.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var getMapData = __webpack_require__(/*! ./_getMapData */ "./node_modules/lodash/_getMapData.js");

/**
 * Gets the map value for `key`.
 *
 * @private
 * @name get
 * @memberOf MapCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function mapCacheGet(key) {
  return getMapData(this, key).get(key);
}

module.exports = mapCacheGet;


/***/ }),

/***/ "./node_modules/lodash/_mapCacheHas.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash/_mapCacheHas.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var getMapData = __webpack_require__(/*! ./_getMapData */ "./node_modules/lodash/_getMapData.js");

/**
 * Checks if a map value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf MapCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function mapCacheHas(key) {
  return getMapData(this, key).has(key);
}

module.exports = mapCacheHas;


/***/ }),

/***/ "./node_modules/lodash/_mapCacheSet.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash/_mapCacheSet.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var getMapData = __webpack_require__(/*! ./_getMapData */ "./node_modules/lodash/_getMapData.js");

/**
 * Sets the map `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf MapCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the map cache instance.
 */
function mapCacheSet(key, value) {
  var data = getMapData(this, key),
      size = data.size;

  data.set(key, value);
  this.size += data.size == size ? 0 : 1;
  return this;
}

module.exports = mapCacheSet;


/***/ }),

/***/ "./node_modules/lodash/_mapToArray.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_mapToArray.js ***!
  \********************************************/
/***/ ((module) => {

/**
 * Converts `map` to its key-value pairs.
 *
 * @private
 * @param {Object} map The map to convert.
 * @returns {Array} Returns the key-value pairs.
 */
function mapToArray(map) {
  var index = -1,
      result = Array(map.size);

  map.forEach(function(value, key) {
    result[++index] = [key, value];
  });
  return result;
}

module.exports = mapToArray;


/***/ }),

/***/ "./node_modules/lodash/_matchesStrictComparable.js":
/*!*********************************************************!*\
  !*** ./node_modules/lodash/_matchesStrictComparable.js ***!
  \*********************************************************/
/***/ ((module) => {

/**
 * A specialized version of `matchesProperty` for source values suitable
 * for strict equality comparisons, i.e. `===`.
 *
 * @private
 * @param {string} key The key of the property to get.
 * @param {*} srcValue The value to match.
 * @returns {Function} Returns the new spec function.
 */
function matchesStrictComparable(key, srcValue) {
  return function(object) {
    if (object == null) {
      return false;
    }
    return object[key] === srcValue &&
      (srcValue !== undefined || (key in Object(object)));
  };
}

module.exports = matchesStrictComparable;


/***/ }),

/***/ "./node_modules/lodash/_memoizeCapped.js":
/*!***********************************************!*\
  !*** ./node_modules/lodash/_memoizeCapped.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var memoize = __webpack_require__(/*! ./memoize */ "./node_modules/lodash/memoize.js");

/** Used as the maximum memoize cache size. */
var MAX_MEMOIZE_SIZE = 500;

/**
 * A specialized version of `_.memoize` which clears the memoized function's
 * cache when it exceeds `MAX_MEMOIZE_SIZE`.
 *
 * @private
 * @param {Function} func The function to have its output memoized.
 * @returns {Function} Returns the new memoized function.
 */
function memoizeCapped(func) {
  var result = memoize(func, function(key) {
    if (cache.size === MAX_MEMOIZE_SIZE) {
      cache.clear();
    }
    return key;
  });

  var cache = result.cache;
  return result;
}

module.exports = memoizeCapped;


/***/ }),

/***/ "./node_modules/lodash/_nativeCreate.js":
/*!**********************************************!*\
  !*** ./node_modules/lodash/_nativeCreate.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var getNative = __webpack_require__(/*! ./_getNative */ "./node_modules/lodash/_getNative.js");

/* Built-in method references that are verified to be native. */
var nativeCreate = getNative(Object, 'create');

module.exports = nativeCreate;


/***/ }),

/***/ "./node_modules/lodash/_nativeKeys.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_nativeKeys.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var overArg = __webpack_require__(/*! ./_overArg */ "./node_modules/lodash/_overArg.js");

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeKeys = overArg(Object.keys, Object);

module.exports = nativeKeys;


/***/ }),

/***/ "./node_modules/lodash/_nativeKeysIn.js":
/*!**********************************************!*\
  !*** ./node_modules/lodash/_nativeKeysIn.js ***!
  \**********************************************/
/***/ ((module) => {

/**
 * This function is like
 * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * except that it includes inherited enumerable properties.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function nativeKeysIn(object) {
  var result = [];
  if (object != null) {
    for (var key in Object(object)) {
      result.push(key);
    }
  }
  return result;
}

module.exports = nativeKeysIn;


/***/ }),

/***/ "./node_modules/lodash/_nodeUtil.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/_nodeUtil.js ***!
  \******************************************/
/***/ ((module, exports, __webpack_require__) => {

/* module decorator */ module = __webpack_require__.nmd(module);
var freeGlobal = __webpack_require__(/*! ./_freeGlobal */ "./node_modules/lodash/_freeGlobal.js");

/** Detect free variable `exports`. */
var freeExports =  true && exports && !exports.nodeType && exports;

/** Detect free variable `module`. */
var freeModule = freeExports && "object" == 'object' && module && !module.nodeType && module;

/** Detect the popular CommonJS extension `module.exports`. */
var moduleExports = freeModule && freeModule.exports === freeExports;

/** Detect free variable `process` from Node.js. */
var freeProcess = moduleExports && freeGlobal.process;

/** Used to access faster Node.js helpers. */
var nodeUtil = (function() {
  try {
    // Use `util.types` for Node.js 10+.
    var types = freeModule && freeModule.require && freeModule.require('util').types;

    if (types) {
      return types;
    }

    // Legacy `process.binding('util')` for Node.js < 10.
    return freeProcess && freeProcess.binding && freeProcess.binding('util');
  } catch (e) {}
}());

module.exports = nodeUtil;


/***/ }),

/***/ "./node_modules/lodash/_objectToString.js":
/*!************************************************!*\
  !*** ./node_modules/lodash/_objectToString.js ***!
  \************************************************/
/***/ ((module) => {

/** Used for built-in method references. */
var objectProto = Object.prototype;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var nativeObjectToString = objectProto.toString;

/**
 * Converts `value` to a string using `Object.prototype.toString`.
 *
 * @private
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 */
function objectToString(value) {
  return nativeObjectToString.call(value);
}

module.exports = objectToString;


/***/ }),

/***/ "./node_modules/lodash/_overArg.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/_overArg.js ***!
  \*****************************************/
/***/ ((module) => {

/**
 * Creates a unary function that invokes `func` with its argument transformed.
 *
 * @private
 * @param {Function} func The function to wrap.
 * @param {Function} transform The argument transform.
 * @returns {Function} Returns the new function.
 */
function overArg(func, transform) {
  return function(arg) {
    return func(transform(arg));
  };
}

module.exports = overArg;


/***/ }),

/***/ "./node_modules/lodash/_overRest.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/_overRest.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var apply = __webpack_require__(/*! ./_apply */ "./node_modules/lodash/_apply.js");

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMax = Math.max;

/**
 * A specialized version of `baseRest` which transforms the rest array.
 *
 * @private
 * @param {Function} func The function to apply a rest parameter to.
 * @param {number} [start=func.length-1] The start position of the rest parameter.
 * @param {Function} transform The rest array transform.
 * @returns {Function} Returns the new function.
 */
function overRest(func, start, transform) {
  start = nativeMax(start === undefined ? (func.length - 1) : start, 0);
  return function() {
    var args = arguments,
        index = -1,
        length = nativeMax(args.length - start, 0),
        array = Array(length);

    while (++index < length) {
      array[index] = args[start + index];
    }
    index = -1;
    var otherArgs = Array(start + 1);
    while (++index < start) {
      otherArgs[index] = args[index];
    }
    otherArgs[start] = transform(array);
    return apply(func, this, otherArgs);
  };
}

module.exports = overRest;


/***/ }),

/***/ "./node_modules/lodash/_root.js":
/*!**************************************!*\
  !*** ./node_modules/lodash/_root.js ***!
  \**************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var freeGlobal = __webpack_require__(/*! ./_freeGlobal */ "./node_modules/lodash/_freeGlobal.js");

/** Detect free variable `self`. */
var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

/** Used as a reference to the global object. */
var root = freeGlobal || freeSelf || Function('return this')();

module.exports = root;


/***/ }),

/***/ "./node_modules/lodash/_safeGet.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/_safeGet.js ***!
  \*****************************************/
/***/ ((module) => {

/**
 * Gets the value at `key`, unless `key` is "__proto__" or "constructor".
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */
function safeGet(object, key) {
  if (key === 'constructor' && typeof object[key] === 'function') {
    return;
  }

  if (key == '__proto__') {
    return;
  }

  return object[key];
}

module.exports = safeGet;


/***/ }),

/***/ "./node_modules/lodash/_setCacheAdd.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash/_setCacheAdd.js ***!
  \*********************************************/
/***/ ((module) => {

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED = '__lodash_hash_undefined__';

/**
 * Adds `value` to the array cache.
 *
 * @private
 * @name add
 * @memberOf SetCache
 * @alias push
 * @param {*} value The value to cache.
 * @returns {Object} Returns the cache instance.
 */
function setCacheAdd(value) {
  this.__data__.set(value, HASH_UNDEFINED);
  return this;
}

module.exports = setCacheAdd;


/***/ }),

/***/ "./node_modules/lodash/_setCacheHas.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash/_setCacheHas.js ***!
  \*********************************************/
/***/ ((module) => {

/**
 * Checks if `value` is in the array cache.
 *
 * @private
 * @name has
 * @memberOf SetCache
 * @param {*} value The value to search for.
 * @returns {number} Returns `true` if `value` is found, else `false`.
 */
function setCacheHas(value) {
  return this.__data__.has(value);
}

module.exports = setCacheHas;


/***/ }),

/***/ "./node_modules/lodash/_setToArray.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_setToArray.js ***!
  \********************************************/
/***/ ((module) => {

/**
 * Converts `set` to an array of its values.
 *
 * @private
 * @param {Object} set The set to convert.
 * @returns {Array} Returns the values.
 */
function setToArray(set) {
  var index = -1,
      result = Array(set.size);

  set.forEach(function(value) {
    result[++index] = value;
  });
  return result;
}

module.exports = setToArray;


/***/ }),

/***/ "./node_modules/lodash/_setToString.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash/_setToString.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseSetToString = __webpack_require__(/*! ./_baseSetToString */ "./node_modules/lodash/_baseSetToString.js"),
    shortOut = __webpack_require__(/*! ./_shortOut */ "./node_modules/lodash/_shortOut.js");

/**
 * Sets the `toString` method of `func` to return `string`.
 *
 * @private
 * @param {Function} func The function to modify.
 * @param {Function} string The `toString` result.
 * @returns {Function} Returns `func`.
 */
var setToString = shortOut(baseSetToString);

module.exports = setToString;


/***/ }),

/***/ "./node_modules/lodash/_shortOut.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/_shortOut.js ***!
  \******************************************/
/***/ ((module) => {

/** Used to detect hot functions by number of calls within a span of milliseconds. */
var HOT_COUNT = 800,
    HOT_SPAN = 16;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeNow = Date.now;

/**
 * Creates a function that'll short out and invoke `identity` instead
 * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`
 * milliseconds.
 *
 * @private
 * @param {Function} func The function to restrict.
 * @returns {Function} Returns the new shortable function.
 */
function shortOut(func) {
  var count = 0,
      lastCalled = 0;

  return function() {
    var stamp = nativeNow(),
        remaining = HOT_SPAN - (stamp - lastCalled);

    lastCalled = stamp;
    if (remaining > 0) {
      if (++count >= HOT_COUNT) {
        return arguments[0];
      }
    } else {
      count = 0;
    }
    return func.apply(undefined, arguments);
  };
}

module.exports = shortOut;


/***/ }),

/***/ "./node_modules/lodash/_stackClear.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_stackClear.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var ListCache = __webpack_require__(/*! ./_ListCache */ "./node_modules/lodash/_ListCache.js");

/**
 * Removes all key-value entries from the stack.
 *
 * @private
 * @name clear
 * @memberOf Stack
 */
function stackClear() {
  this.__data__ = new ListCache;
  this.size = 0;
}

module.exports = stackClear;


/***/ }),

/***/ "./node_modules/lodash/_stackDelete.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash/_stackDelete.js ***!
  \*********************************************/
/***/ ((module) => {

/**
 * Removes `key` and its value from the stack.
 *
 * @private
 * @name delete
 * @memberOf Stack
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function stackDelete(key) {
  var data = this.__data__,
      result = data['delete'](key);

  this.size = data.size;
  return result;
}

module.exports = stackDelete;


/***/ }),

/***/ "./node_modules/lodash/_stackGet.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/_stackGet.js ***!
  \******************************************/
/***/ ((module) => {

/**
 * Gets the stack value for `key`.
 *
 * @private
 * @name get
 * @memberOf Stack
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function stackGet(key) {
  return this.__data__.get(key);
}

module.exports = stackGet;


/***/ }),

/***/ "./node_modules/lodash/_stackHas.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/_stackHas.js ***!
  \******************************************/
/***/ ((module) => {

/**
 * Checks if a stack value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Stack
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function stackHas(key) {
  return this.__data__.has(key);
}

module.exports = stackHas;


/***/ }),

/***/ "./node_modules/lodash/_stackSet.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/_stackSet.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var ListCache = __webpack_require__(/*! ./_ListCache */ "./node_modules/lodash/_ListCache.js"),
    Map = __webpack_require__(/*! ./_Map */ "./node_modules/lodash/_Map.js"),
    MapCache = __webpack_require__(/*! ./_MapCache */ "./node_modules/lodash/_MapCache.js");

/** Used as the size to enable large array optimizations. */
var LARGE_ARRAY_SIZE = 200;

/**
 * Sets the stack `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Stack
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the stack cache instance.
 */
function stackSet(key, value) {
  var data = this.__data__;
  if (data instanceof ListCache) {
    var pairs = data.__data__;
    if (!Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {
      pairs.push([key, value]);
      this.size = ++data.size;
      return this;
    }
    data = this.__data__ = new MapCache(pairs);
  }
  data.set(key, value);
  this.size = data.size;
  return this;
}

module.exports = stackSet;


/***/ }),

/***/ "./node_modules/lodash/_strictIndexOf.js":
/*!***********************************************!*\
  !*** ./node_modules/lodash/_strictIndexOf.js ***!
  \***********************************************/
/***/ ((module) => {

/**
 * A specialized version of `_.indexOf` which performs strict equality
 * comparisons of values, i.e. `===`.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} value The value to search for.
 * @param {number} fromIndex The index to search from.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function strictIndexOf(array, value, fromIndex) {
  var index = fromIndex - 1,
      length = array.length;

  while (++index < length) {
    if (array[index] === value) {
      return index;
    }
  }
  return -1;
}

module.exports = strictIndexOf;


/***/ }),

/***/ "./node_modules/lodash/_stringSize.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_stringSize.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var asciiSize = __webpack_require__(/*! ./_asciiSize */ "./node_modules/lodash/_asciiSize.js"),
    hasUnicode = __webpack_require__(/*! ./_hasUnicode */ "./node_modules/lodash/_hasUnicode.js"),
    unicodeSize = __webpack_require__(/*! ./_unicodeSize */ "./node_modules/lodash/_unicodeSize.js");

/**
 * Gets the number of symbols in `string`.
 *
 * @private
 * @param {string} string The string to inspect.
 * @returns {number} Returns the string size.
 */
function stringSize(string) {
  return hasUnicode(string)
    ? unicodeSize(string)
    : asciiSize(string);
}

module.exports = stringSize;


/***/ }),

/***/ "./node_modules/lodash/_stringToPath.js":
/*!**********************************************!*\
  !*** ./node_modules/lodash/_stringToPath.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var memoizeCapped = __webpack_require__(/*! ./_memoizeCapped */ "./node_modules/lodash/_memoizeCapped.js");

/** Used to match property names within property paths. */
var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;

/** Used to match backslashes in property paths. */
var reEscapeChar = /\\(\\)?/g;

/**
 * Converts `string` to a property path array.
 *
 * @private
 * @param {string} string The string to convert.
 * @returns {Array} Returns the property path array.
 */
var stringToPath = memoizeCapped(function(string) {
  var result = [];
  if (string.charCodeAt(0) === 46 /* . */) {
    result.push('');
  }
  string.replace(rePropName, function(match, number, quote, subString) {
    result.push(quote ? subString.replace(reEscapeChar, '$1') : (number || match));
  });
  return result;
});

module.exports = stringToPath;


/***/ }),

/***/ "./node_modules/lodash/_toKey.js":
/*!***************************************!*\
  !*** ./node_modules/lodash/_toKey.js ***!
  \***************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var isSymbol = __webpack_require__(/*! ./isSymbol */ "./node_modules/lodash/isSymbol.js");

/** Used as references for various `Number` constants. */
var INFINITY = 1 / 0;

/**
 * Converts `value` to a string key if it's not a string or symbol.
 *
 * @private
 * @param {*} value The value to inspect.
 * @returns {string|symbol} Returns the key.
 */
function toKey(value) {
  if (typeof value == 'string' || isSymbol(value)) {
    return value;
  }
  var result = (value + '');
  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
}

module.exports = toKey;


/***/ }),

/***/ "./node_modules/lodash/_toSource.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/_toSource.js ***!
  \******************************************/
/***/ ((module) => {

/** Used for built-in method references. */
var funcProto = Function.prototype;

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/**
 * Converts `func` to its source code.
 *
 * @private
 * @param {Function} func The function to convert.
 * @returns {string} Returns the source code.
 */
function toSource(func) {
  if (func != null) {
    try {
      return funcToString.call(func);
    } catch (e) {}
    try {
      return (func + '');
    } catch (e) {}
  }
  return '';
}

module.exports = toSource;


/***/ }),

/***/ "./node_modules/lodash/_trimmedEndIndex.js":
/*!*************************************************!*\
  !*** ./node_modules/lodash/_trimmedEndIndex.js ***!
  \*************************************************/
/***/ ((module) => {

/** Used to match a single whitespace character. */
var reWhitespace = /\s/;

/**
 * Used by `_.trim` and `_.trimEnd` to get the index of the last non-whitespace
 * character of `string`.
 *
 * @private
 * @param {string} string The string to inspect.
 * @returns {number} Returns the index of the last non-whitespace character.
 */
function trimmedEndIndex(string) {
  var index = string.length;

  while (index-- && reWhitespace.test(string.charAt(index))) {}
  return index;
}

module.exports = trimmedEndIndex;


/***/ }),

/***/ "./node_modules/lodash/_unicodeSize.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash/_unicodeSize.js ***!
  \*********************************************/
/***/ ((module) => {

/** Used to compose unicode character classes. */
var rsAstralRange = '\\ud800-\\udfff',
    rsComboMarksRange = '\\u0300-\\u036f',
    reComboHalfMarksRange = '\\ufe20-\\ufe2f',
    rsComboSymbolsRange = '\\u20d0-\\u20ff',
    rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange,
    rsVarRange = '\\ufe0e\\ufe0f';

/** Used to compose unicode capture groups. */
var rsAstral = '[' + rsAstralRange + ']',
    rsCombo = '[' + rsComboRange + ']',
    rsFitz = '\\ud83c[\\udffb-\\udfff]',
    rsModifier = '(?:' + rsCombo + '|' + rsFitz + ')',
    rsNonAstral = '[^' + rsAstralRange + ']',
    rsRegional = '(?:\\ud83c[\\udde6-\\uddff]){2}',
    rsSurrPair = '[\\ud800-\\udbff][\\udc00-\\udfff]',
    rsZWJ = '\\u200d';

/** Used to compose unicode regexes. */
var reOptMod = rsModifier + '?',
    rsOptVar = '[' + rsVarRange + ']?',
    rsOptJoin = '(?:' + rsZWJ + '(?:' + [rsNonAstral, rsRegional, rsSurrPair].join('|') + ')' + rsOptVar + reOptMod + ')*',
    rsSeq = rsOptVar + reOptMod + rsOptJoin,
    rsSymbol = '(?:' + [rsNonAstral + rsCombo + '?', rsCombo, rsRegional, rsSurrPair, rsAstral].join('|') + ')';

/** Used to match [string symbols](https://mathiasbynens.be/notes/javascript-unicode). */
var reUnicode = RegExp(rsFitz + '(?=' + rsFitz + ')|' + rsSymbol + rsSeq, 'g');

/**
 * Gets the size of a Unicode `string`.
 *
 * @private
 * @param {string} string The string inspect.
 * @returns {number} Returns the string size.
 */
function unicodeSize(string) {
  var result = reUnicode.lastIndex = 0;
  while (reUnicode.test(string)) {
    ++result;
  }
  return result;
}

module.exports = unicodeSize;


/***/ }),

/***/ "./node_modules/lodash/clone.js":
/*!**************************************!*\
  !*** ./node_modules/lodash/clone.js ***!
  \**************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseClone = __webpack_require__(/*! ./_baseClone */ "./node_modules/lodash/_baseClone.js");

/** Used to compose bitmasks for cloning. */
var CLONE_SYMBOLS_FLAG = 4;

/**
 * Creates a shallow clone of `value`.
 *
 * **Note:** This method is loosely based on the
 * [structured clone algorithm](https://mdn.io/Structured_clone_algorithm)
 * and supports cloning arrays, array buffers, booleans, date objects, maps,
 * numbers, `Object` objects, regexes, sets, strings, symbols, and typed
 * arrays. The own enumerable properties of `arguments` objects are cloned
 * as plain objects. An empty object is returned for uncloneable values such
 * as error objects, functions, DOM nodes, and WeakMaps.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to clone.
 * @returns {*} Returns the cloned value.
 * @see _.cloneDeep
 * @example
 *
 * var objects = [{ 'a': 1 }, { 'b': 2 }];
 *
 * var shallow = _.clone(objects);
 * console.log(shallow[0] === objects[0]);
 * // => true
 */
function clone(value) {
  return baseClone(value, CLONE_SYMBOLS_FLAG);
}

module.exports = clone;


/***/ }),

/***/ "./node_modules/lodash/cloneDeep.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/cloneDeep.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseClone = __webpack_require__(/*! ./_baseClone */ "./node_modules/lodash/_baseClone.js");

/** Used to compose bitmasks for cloning. */
var CLONE_DEEP_FLAG = 1,
    CLONE_SYMBOLS_FLAG = 4;

/**
 * This method is like `_.clone` except that it recursively clones `value`.
 *
 * @static
 * @memberOf _
 * @since 1.0.0
 * @category Lang
 * @param {*} value The value to recursively clone.
 * @returns {*} Returns the deep cloned value.
 * @see _.clone
 * @example
 *
 * var objects = [{ 'a': 1 }, { 'b': 2 }];
 *
 * var deep = _.cloneDeep(objects);
 * console.log(deep[0] === objects[0]);
 * // => false
 */
function cloneDeep(value) {
  return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
}

module.exports = cloneDeep;


/***/ }),

/***/ "./node_modules/lodash/constant.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/constant.js ***!
  \*****************************************/
/***/ ((module) => {

/**
 * Creates a function that returns `value`.
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Util
 * @param {*} value The value to return from the new function.
 * @returns {Function} Returns the new constant function.
 * @example
 *
 * var objects = _.times(2, _.constant({ 'a': 1 }));
 *
 * console.log(objects);
 * // => [{ 'a': 1 }, { 'a': 1 }]
 *
 * console.log(objects[0] === objects[1]);
 * // => true
 */
function constant(value) {
  return function() {
    return value;
  };
}

module.exports = constant;


/***/ }),

/***/ "./node_modules/lodash/defaults.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/defaults.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseRest = __webpack_require__(/*! ./_baseRest */ "./node_modules/lodash/_baseRest.js"),
    eq = __webpack_require__(/*! ./eq */ "./node_modules/lodash/eq.js"),
    isIterateeCall = __webpack_require__(/*! ./_isIterateeCall */ "./node_modules/lodash/_isIterateeCall.js"),
    keysIn = __webpack_require__(/*! ./keysIn */ "./node_modules/lodash/keysIn.js");

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Assigns own and inherited enumerable string keyed properties of source
 * objects to the destination object for all destination properties that
 * resolve to `undefined`. Source objects are applied from left to right.
 * Once a property is set, additional values of the same property are ignored.
 *
 * **Note:** This method mutates `object`.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The destination object.
 * @param {...Object} [sources] The source objects.
 * @returns {Object} Returns `object`.
 * @see _.defaultsDeep
 * @example
 *
 * _.defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
 * // => { 'a': 1, 'b': 2 }
 */
var defaults = baseRest(function(object, sources) {
  object = Object(object);

  var index = -1;
  var length = sources.length;
  var guard = length > 2 ? sources[2] : undefined;

  if (guard && isIterateeCall(sources[0], sources[1], guard)) {
    length = 1;
  }

  while (++index < length) {
    var source = sources[index];
    var props = keysIn(source);
    var propsIndex = -1;
    var propsLength = props.length;

    while (++propsIndex < propsLength) {
      var key = props[propsIndex];
      var value = object[key];

      if (value === undefined ||
          (eq(value, objectProto[key]) && !hasOwnProperty.call(object, key))) {
        object[key] = source[key];
      }
    }
  }

  return object;
});

module.exports = defaults;


/***/ }),

/***/ "./node_modules/lodash/each.js":
/*!*************************************!*\
  !*** ./node_modules/lodash/each.js ***!
  \*************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = __webpack_require__(/*! ./forEach */ "./node_modules/lodash/forEach.js");


/***/ }),

/***/ "./node_modules/lodash/eq.js":
/*!***********************************!*\
  !*** ./node_modules/lodash/eq.js ***!
  \***********************************/
/***/ ((module) => {

/**
 * Performs a
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * comparison between two values to determine if they are equivalent.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.eq(object, object);
 * // => true
 *
 * _.eq(object, other);
 * // => false
 *
 * _.eq('a', 'a');
 * // => true
 *
 * _.eq('a', Object('a'));
 * // => false
 *
 * _.eq(NaN, NaN);
 * // => true
 */
function eq(value, other) {
  return value === other || (value !== value && other !== other);
}

module.exports = eq;


/***/ }),

/***/ "./node_modules/lodash/filter.js":
/*!***************************************!*\
  !*** ./node_modules/lodash/filter.js ***!
  \***************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var arrayFilter = __webpack_require__(/*! ./_arrayFilter */ "./node_modules/lodash/_arrayFilter.js"),
    baseFilter = __webpack_require__(/*! ./_baseFilter */ "./node_modules/lodash/_baseFilter.js"),
    baseIteratee = __webpack_require__(/*! ./_baseIteratee */ "./node_modules/lodash/_baseIteratee.js"),
    isArray = __webpack_require__(/*! ./isArray */ "./node_modules/lodash/isArray.js");

/**
 * Iterates over elements of `collection`, returning an array of all elements
 * `predicate` returns truthy for. The predicate is invoked with three
 * arguments: (value, index|key, collection).
 *
 * **Note:** Unlike `_.remove`, this method returns a new array.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Collection
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} [predicate=_.identity] The function invoked per iteration.
 * @returns {Array} Returns the new filtered array.
 * @see _.reject
 * @example
 *
 * var users = [
 *   { 'user': 'barney', 'age': 36, 'active': true },
 *   { 'user': 'fred',   'age': 40, 'active': false }
 * ];
 *
 * _.filter(users, function(o) { return !o.active; });
 * // => objects for ['fred']
 *
 * // The `_.matches` iteratee shorthand.
 * _.filter(users, { 'age': 36, 'active': true });
 * // => objects for ['barney']
 *
 * // The `_.matchesProperty` iteratee shorthand.
 * _.filter(users, ['active', false]);
 * // => objects for ['fred']
 *
 * // The `_.property` iteratee shorthand.
 * _.filter(users, 'active');
 * // => objects for ['barney']
 *
 * // Combining several predicates using `_.overEvery` or `_.overSome`.
 * _.filter(users, _.overSome([{ 'age': 36 }, ['age', 40]]));
 * // => objects for ['fred', 'barney']
 */
function filter(collection, predicate) {
  var func = isArray(collection) ? arrayFilter : baseFilter;
  return func(collection, baseIteratee(predicate, 3));
}

module.exports = filter;


/***/ }),

/***/ "./node_modules/lodash/find.js":
/*!*************************************!*\
  !*** ./node_modules/lodash/find.js ***!
  \*************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var createFind = __webpack_require__(/*! ./_createFind */ "./node_modules/lodash/_createFind.js"),
    findIndex = __webpack_require__(/*! ./findIndex */ "./node_modules/lodash/findIndex.js");

/**
 * Iterates over elements of `collection`, returning the first element
 * `predicate` returns truthy for. The predicate is invoked with three
 * arguments: (value, index|key, collection).
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Collection
 * @param {Array|Object} collection The collection to inspect.
 * @param {Function} [predicate=_.identity] The function invoked per iteration.
 * @param {number} [fromIndex=0] The index to search from.
 * @returns {*} Returns the matched element, else `undefined`.
 * @example
 *
 * var users = [
 *   { 'user': 'barney',  'age': 36, 'active': true },
 *   { 'user': 'fred',    'age': 40, 'active': false },
 *   { 'user': 'pebbles', 'age': 1,  'active': true }
 * ];
 *
 * _.find(users, function(o) { return o.age < 40; });
 * // => object for 'barney'
 *
 * // The `_.matches` iteratee shorthand.
 * _.find(users, { 'age': 1, 'active': true });
 * // => object for 'pebbles'
 *
 * // The `_.matchesProperty` iteratee shorthand.
 * _.find(users, ['active', false]);
 * // => object for 'fred'
 *
 * // The `_.property` iteratee shorthand.
 * _.find(users, 'active');
 * // => object for 'barney'
 */
var find = createFind(findIndex);

module.exports = find;


/***/ }),

/***/ "./node_modules/lodash/findIndex.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/findIndex.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseFindIndex = __webpack_require__(/*! ./_baseFindIndex */ "./node_modules/lodash/_baseFindIndex.js"),
    baseIteratee = __webpack_require__(/*! ./_baseIteratee */ "./node_modules/lodash/_baseIteratee.js"),
    toInteger = __webpack_require__(/*! ./toInteger */ "./node_modules/lodash/toInteger.js");

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMax = Math.max;

/**
 * This method is like `_.find` except that it returns the index of the first
 * element `predicate` returns truthy for instead of the element itself.
 *
 * @static
 * @memberOf _
 * @since 1.1.0
 * @category Array
 * @param {Array} array The array to inspect.
 * @param {Function} [predicate=_.identity] The function invoked per iteration.
 * @param {number} [fromIndex=0] The index to search from.
 * @returns {number} Returns the index of the found element, else `-1`.
 * @example
 *
 * var users = [
 *   { 'user': 'barney',  'active': false },
 *   { 'user': 'fred',    'active': false },
 *   { 'user': 'pebbles', 'active': true }
 * ];
 *
 * _.findIndex(users, function(o) { return o.user == 'barney'; });
 * // => 0
 *
 * // The `_.matches` iteratee shorthand.
 * _.findIndex(users, { 'user': 'fred', 'active': false });
 * // => 1
 *
 * // The `_.matchesProperty` iteratee shorthand.
 * _.findIndex(users, ['active', false]);
 * // => 0
 *
 * // The `_.property` iteratee shorthand.
 * _.findIndex(users, 'active');
 * // => 2
 */
function findIndex(array, predicate, fromIndex) {
  var length = array == null ? 0 : array.length;
  if (!length) {
    return -1;
  }
  var index = fromIndex == null ? 0 : toInteger(fromIndex);
  if (index < 0) {
    index = nativeMax(length + index, 0);
  }
  return baseFindIndex(array, baseIteratee(predicate, 3), index);
}

module.exports = findIndex;


/***/ }),

/***/ "./node_modules/lodash/flatten.js":
/*!****************************************!*\
  !*** ./node_modules/lodash/flatten.js ***!
  \****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseFlatten = __webpack_require__(/*! ./_baseFlatten */ "./node_modules/lodash/_baseFlatten.js");

/**
 * Flattens `array` a single level deep.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Array
 * @param {Array} array The array to flatten.
 * @returns {Array} Returns the new flattened array.
 * @example
 *
 * _.flatten([1, [2, [3, [4]], 5]]);
 * // => [1, 2, [3, [4]], 5]
 */
function flatten(array) {
  var length = array == null ? 0 : array.length;
  return length ? baseFlatten(array, 1) : [];
}

module.exports = flatten;


/***/ }),

/***/ "./node_modules/lodash/forEach.js":
/*!****************************************!*\
  !*** ./node_modules/lodash/forEach.js ***!
  \****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var arrayEach = __webpack_require__(/*! ./_arrayEach */ "./node_modules/lodash/_arrayEach.js"),
    baseEach = __webpack_require__(/*! ./_baseEach */ "./node_modules/lodash/_baseEach.js"),
    castFunction = __webpack_require__(/*! ./_castFunction */ "./node_modules/lodash/_castFunction.js"),
    isArray = __webpack_require__(/*! ./isArray */ "./node_modules/lodash/isArray.js");

/**
 * Iterates over elements of `collection` and invokes `iteratee` for each element.
 * The iteratee is invoked with three arguments: (value, index|key, collection).
 * Iteratee functions may exit iteration early by explicitly returning `false`.
 *
 * **Note:** As with other "Collections" methods, objects with a "length"
 * property are iterated like arrays. To avoid this behavior use `_.forIn`
 * or `_.forOwn` for object iteration.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @alias each
 * @category Collection
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} [iteratee=_.identity] The function invoked per iteration.
 * @returns {Array|Object} Returns `collection`.
 * @see _.forEachRight
 * @example
 *
 * _.forEach([1, 2], function(value) {
 *   console.log(value);
 * });
 * // => Logs `1` then `2`.
 *
 * _.forEach({ 'a': 1, 'b': 2 }, function(value, key) {
 *   console.log(key);
 * });
 * // => Logs 'a' then 'b' (iteration order is not guaranteed).
 */
function forEach(collection, iteratee) {
  var func = isArray(collection) ? arrayEach : baseEach;
  return func(collection, castFunction(iteratee));
}

module.exports = forEach;


/***/ }),

/***/ "./node_modules/lodash/forIn.js":
/*!**************************************!*\
  !*** ./node_modules/lodash/forIn.js ***!
  \**************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseFor = __webpack_require__(/*! ./_baseFor */ "./node_modules/lodash/_baseFor.js"),
    castFunction = __webpack_require__(/*! ./_castFunction */ "./node_modules/lodash/_castFunction.js"),
    keysIn = __webpack_require__(/*! ./keysIn */ "./node_modules/lodash/keysIn.js");

/**
 * Iterates over own and inherited enumerable string keyed properties of an
 * object and invokes `iteratee` for each property. The iteratee is invoked
 * with three arguments: (value, key, object). Iteratee functions may exit
 * iteration early by explicitly returning `false`.
 *
 * @static
 * @memberOf _
 * @since 0.3.0
 * @category Object
 * @param {Object} object The object to iterate over.
 * @param {Function} [iteratee=_.identity] The function invoked per iteration.
 * @returns {Object} Returns `object`.
 * @see _.forInRight
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.forIn(new Foo, function(value, key) {
 *   console.log(key);
 * });
 * // => Logs 'a', 'b', then 'c' (iteration order is not guaranteed).
 */
function forIn(object, iteratee) {
  return object == null
    ? object
    : baseFor(object, castFunction(iteratee), keysIn);
}

module.exports = forIn;


/***/ }),

/***/ "./node_modules/lodash/get.js":
/*!************************************!*\
  !*** ./node_modules/lodash/get.js ***!
  \************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseGet = __webpack_require__(/*! ./_baseGet */ "./node_modules/lodash/_baseGet.js");

/**
 * Gets the value at `path` of `object`. If the resolved value is
 * `undefined`, the `defaultValue` is returned in its place.
 *
 * @static
 * @memberOf _
 * @since 3.7.0
 * @category Object
 * @param {Object} object The object to query.
 * @param {Array|string} path The path of the property to get.
 * @param {*} [defaultValue] The value returned for `undefined` resolved values.
 * @returns {*} Returns the resolved value.
 * @example
 *
 * var object = { 'a': [{ 'b': { 'c': 3 } }] };
 *
 * _.get(object, 'a[0].b.c');
 * // => 3
 *
 * _.get(object, ['a', '0', 'b', 'c']);
 * // => 3
 *
 * _.get(object, 'a.b.c', 'default');
 * // => 'default'
 */
function get(object, path, defaultValue) {
  var result = object == null ? undefined : baseGet(object, path);
  return result === undefined ? defaultValue : result;
}

module.exports = get;


/***/ }),

/***/ "./node_modules/lodash/has.js":
/*!************************************!*\
  !*** ./node_modules/lodash/has.js ***!
  \************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseHas = __webpack_require__(/*! ./_baseHas */ "./node_modules/lodash/_baseHas.js"),
    hasPath = __webpack_require__(/*! ./_hasPath */ "./node_modules/lodash/_hasPath.js");

/**
 * Checks if `path` is a direct property of `object`.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The object to query.
 * @param {Array|string} path The path to check.
 * @returns {boolean} Returns `true` if `path` exists, else `false`.
 * @example
 *
 * var object = { 'a': { 'b': 2 } };
 * var other = _.create({ 'a': _.create({ 'b': 2 }) });
 *
 * _.has(object, 'a');
 * // => true
 *
 * _.has(object, 'a.b');
 * // => true
 *
 * _.has(object, ['a', 'b']);
 * // => true
 *
 * _.has(other, 'a');
 * // => false
 */
function has(object, path) {
  return object != null && hasPath(object, path, baseHas);
}

module.exports = has;


/***/ }),

/***/ "./node_modules/lodash/hasIn.js":
/*!**************************************!*\
  !*** ./node_modules/lodash/hasIn.js ***!
  \**************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseHasIn = __webpack_require__(/*! ./_baseHasIn */ "./node_modules/lodash/_baseHasIn.js"),
    hasPath = __webpack_require__(/*! ./_hasPath */ "./node_modules/lodash/_hasPath.js");

/**
 * Checks if `path` is a direct or inherited property of `object`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Object
 * @param {Object} object The object to query.
 * @param {Array|string} path The path to check.
 * @returns {boolean} Returns `true` if `path` exists, else `false`.
 * @example
 *
 * var object = _.create({ 'a': _.create({ 'b': 2 }) });
 *
 * _.hasIn(object, 'a');
 * // => true
 *
 * _.hasIn(object, 'a.b');
 * // => true
 *
 * _.hasIn(object, ['a', 'b']);
 * // => true
 *
 * _.hasIn(object, 'b');
 * // => false
 */
function hasIn(object, path) {
  return object != null && hasPath(object, path, baseHasIn);
}

module.exports = hasIn;


/***/ }),

/***/ "./node_modules/lodash/identity.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/identity.js ***!
  \*****************************************/
/***/ ((module) => {

/**
 * This method returns the first argument it receives.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Util
 * @param {*} value Any value.
 * @returns {*} Returns `value`.
 * @example
 *
 * var object = { 'a': 1 };
 *
 * console.log(_.identity(object) === object);
 * // => true
 */
function identity(value) {
  return value;
}

module.exports = identity;


/***/ }),

/***/ "./node_modules/lodash/isArguments.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/isArguments.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseIsArguments = __webpack_require__(/*! ./_baseIsArguments */ "./node_modules/lodash/_baseIsArguments.js"),
    isObjectLike = __webpack_require__(/*! ./isObjectLike */ "./node_modules/lodash/isObjectLike.js");

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/** Built-in value references. */
var propertyIsEnumerable = objectProto.propertyIsEnumerable;

/**
 * Checks if `value` is likely an `arguments` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 *  else `false`.
 * @example
 *
 * _.isArguments(function() { return arguments; }());
 * // => true
 *
 * _.isArguments([1, 2, 3]);
 * // => false
 */
var isArguments = baseIsArguments(function() { return arguments; }()) ? baseIsArguments : function(value) {
  return isObjectLike(value) && hasOwnProperty.call(value, 'callee') &&
    !propertyIsEnumerable.call(value, 'callee');
};

module.exports = isArguments;


/***/ }),

/***/ "./node_modules/lodash/isArray.js":
/*!****************************************!*\
  !*** ./node_modules/lodash/isArray.js ***!
  \****************************************/
/***/ ((module) => {

/**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(document.body.children);
 * // => false
 *
 * _.isArray('abc');
 * // => false
 *
 * _.isArray(_.noop);
 * // => false
 */
var isArray = Array.isArray;

module.exports = isArray;


/***/ }),

/***/ "./node_modules/lodash/isArrayLike.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/isArrayLike.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var isFunction = __webpack_require__(/*! ./isFunction */ "./node_modules/lodash/isFunction.js"),
    isLength = __webpack_require__(/*! ./isLength */ "./node_modules/lodash/isLength.js");

/**
 * Checks if `value` is array-like. A value is considered array-like if it's
 * not a function and has a `value.length` that's an integer greater than or
 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
 * @example
 *
 * _.isArrayLike([1, 2, 3]);
 * // => true
 *
 * _.isArrayLike(document.body.children);
 * // => true
 *
 * _.isArrayLike('abc');
 * // => true
 *
 * _.isArrayLike(_.noop);
 * // => false
 */
function isArrayLike(value) {
  return value != null && isLength(value.length) && !isFunction(value);
}

module.exports = isArrayLike;


/***/ }),

/***/ "./node_modules/lodash/isArrayLikeObject.js":
/*!**************************************************!*\
  !*** ./node_modules/lodash/isArrayLikeObject.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var isArrayLike = __webpack_require__(/*! ./isArrayLike */ "./node_modules/lodash/isArrayLike.js"),
    isObjectLike = __webpack_require__(/*! ./isObjectLike */ "./node_modules/lodash/isObjectLike.js");

/**
 * This method is like `_.isArrayLike` except that it also checks if `value`
 * is an object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array-like object,
 *  else `false`.
 * @example
 *
 * _.isArrayLikeObject([1, 2, 3]);
 * // => true
 *
 * _.isArrayLikeObject(document.body.children);
 * // => true
 *
 * _.isArrayLikeObject('abc');
 * // => false
 *
 * _.isArrayLikeObject(_.noop);
 * // => false
 */
function isArrayLikeObject(value) {
  return isObjectLike(value) && isArrayLike(value);
}

module.exports = isArrayLikeObject;


/***/ }),

/***/ "./node_modules/lodash/isBuffer.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/isBuffer.js ***!
  \*****************************************/
/***/ ((module, exports, __webpack_require__) => {

/* module decorator */ module = __webpack_require__.nmd(module);
var root = __webpack_require__(/*! ./_root */ "./node_modules/lodash/_root.js"),
    stubFalse = __webpack_require__(/*! ./stubFalse */ "./node_modules/lodash/stubFalse.js");

/** Detect free variable `exports`. */
var freeExports =  true && exports && !exports.nodeType && exports;

/** Detect free variable `module`. */
var freeModule = freeExports && "object" == 'object' && module && !module.nodeType && module;

/** Detect the popular CommonJS extension `module.exports`. */
var moduleExports = freeModule && freeModule.exports === freeExports;

/** Built-in value references. */
var Buffer = moduleExports ? root.Buffer : undefined;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined;

/**
 * Checks if `value` is a buffer.
 *
 * @static
 * @memberOf _
 * @since 4.3.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
 * @example
 *
 * _.isBuffer(new Buffer(2));
 * // => true
 *
 * _.isBuffer(new Uint8Array(2));
 * // => false
 */
var isBuffer = nativeIsBuffer || stubFalse;

module.exports = isBuffer;


/***/ }),

/***/ "./node_modules/lodash/isEmpty.js":
/*!****************************************!*\
  !*** ./node_modules/lodash/isEmpty.js ***!
  \****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseKeys = __webpack_require__(/*! ./_baseKeys */ "./node_modules/lodash/_baseKeys.js"),
    getTag = __webpack_require__(/*! ./_getTag */ "./node_modules/lodash/_getTag.js"),
    isArguments = __webpack_require__(/*! ./isArguments */ "./node_modules/lodash/isArguments.js"),
    isArray = __webpack_require__(/*! ./isArray */ "./node_modules/lodash/isArray.js"),
    isArrayLike = __webpack_require__(/*! ./isArrayLike */ "./node_modules/lodash/isArrayLike.js"),
    isBuffer = __webpack_require__(/*! ./isBuffer */ "./node_modules/lodash/isBuffer.js"),
    isPrototype = __webpack_require__(/*! ./_isPrototype */ "./node_modules/lodash/_isPrototype.js"),
    isTypedArray = __webpack_require__(/*! ./isTypedArray */ "./node_modules/lodash/isTypedArray.js");

/** `Object#toString` result references. */
var mapTag = '[object Map]',
    setTag = '[object Set]';

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Checks if `value` is an empty object, collection, map, or set.
 *
 * Objects are considered empty if they have no own enumerable string keyed
 * properties.
 *
 * Array-like values such as `arguments` objects, arrays, buffers, strings, or
 * jQuery-like collections are considered empty if they have a `length` of `0`.
 * Similarly, maps and sets are considered empty if they have a `size` of `0`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is empty, else `false`.
 * @example
 *
 * _.isEmpty(null);
 * // => true
 *
 * _.isEmpty(true);
 * // => true
 *
 * _.isEmpty(1);
 * // => true
 *
 * _.isEmpty([1, 2, 3]);
 * // => false
 *
 * _.isEmpty({ 'a': 1 });
 * // => false
 */
function isEmpty(value) {
  if (value == null) {
    return true;
  }
  if (isArrayLike(value) &&
      (isArray(value) || typeof value == 'string' || typeof value.splice == 'function' ||
        isBuffer(value) || isTypedArray(value) || isArguments(value))) {
    return !value.length;
  }
  var tag = getTag(value);
  if (tag == mapTag || tag == setTag) {
    return !value.size;
  }
  if (isPrototype(value)) {
    return !baseKeys(value).length;
  }
  for (var key in value) {
    if (hasOwnProperty.call(value, key)) {
      return false;
    }
  }
  return true;
}

module.exports = isEmpty;


/***/ }),

/***/ "./node_modules/lodash/isFunction.js":
/*!*******************************************!*\
  !*** ./node_modules/lodash/isFunction.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseGetTag = __webpack_require__(/*! ./_baseGetTag */ "./node_modules/lodash/_baseGetTag.js"),
    isObject = __webpack_require__(/*! ./isObject */ "./node_modules/lodash/isObject.js");

/** `Object#toString` result references. */
var asyncTag = '[object AsyncFunction]',
    funcTag = '[object Function]',
    genTag = '[object GeneratorFunction]',
    proxyTag = '[object Proxy]';

/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */
function isFunction(value) {
  if (!isObject(value)) {
    return false;
  }
  // The use of `Object#toString` avoids issues with the `typeof` operator
  // in Safari 9 which returns 'object' for typed arrays and other constructors.
  var tag = baseGetTag(value);
  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
}

module.exports = isFunction;


/***/ }),

/***/ "./node_modules/lodash/isLength.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/isLength.js ***!
  \*****************************************/
/***/ ((module) => {

/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER = 9007199254740991;

/**
 * Checks if `value` is a valid array-like length.
 *
 * **Note:** This method is loosely based on
 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
 * @example
 *
 * _.isLength(3);
 * // => true
 *
 * _.isLength(Number.MIN_VALUE);
 * // => false
 *
 * _.isLength(Infinity);
 * // => false
 *
 * _.isLength('3');
 * // => false
 */
function isLength(value) {
  return typeof value == 'number' &&
    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}

module.exports = isLength;


/***/ }),

/***/ "./node_modules/lodash/isMap.js":
/*!**************************************!*\
  !*** ./node_modules/lodash/isMap.js ***!
  \**************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseIsMap = __webpack_require__(/*! ./_baseIsMap */ "./node_modules/lodash/_baseIsMap.js"),
    baseUnary = __webpack_require__(/*! ./_baseUnary */ "./node_modules/lodash/_baseUnary.js"),
    nodeUtil = __webpack_require__(/*! ./_nodeUtil */ "./node_modules/lodash/_nodeUtil.js");

/* Node.js helper references. */
var nodeIsMap = nodeUtil && nodeUtil.isMap;

/**
 * Checks if `value` is classified as a `Map` object.
 *
 * @static
 * @memberOf _
 * @since 4.3.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a map, else `false`.
 * @example
 *
 * _.isMap(new Map);
 * // => true
 *
 * _.isMap(new WeakMap);
 * // => false
 */
var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;

module.exports = isMap;


/***/ }),

/***/ "./node_modules/lodash/isObject.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/isObject.js ***!
  \*****************************************/
/***/ ((module) => {

/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject(value) {
  var type = typeof value;
  return value != null && (type == 'object' || type == 'function');
}

module.exports = isObject;


/***/ }),

/***/ "./node_modules/lodash/isObjectLike.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash/isObjectLike.js ***!
  \*********************************************/
/***/ ((module) => {

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return value != null && typeof value == 'object';
}

module.exports = isObjectLike;


/***/ }),

/***/ "./node_modules/lodash/isPlainObject.js":
/*!**********************************************!*\
  !*** ./node_modules/lodash/isPlainObject.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseGetTag = __webpack_require__(/*! ./_baseGetTag */ "./node_modules/lodash/_baseGetTag.js"),
    getPrototype = __webpack_require__(/*! ./_getPrototype */ "./node_modules/lodash/_getPrototype.js"),
    isObjectLike = __webpack_require__(/*! ./isObjectLike */ "./node_modules/lodash/isObjectLike.js");

/** `Object#toString` result references. */
var objectTag = '[object Object]';

/** Used for built-in method references. */
var funcProto = Function.prototype,
    objectProto = Object.prototype;

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/** Used to infer the `Object` constructor. */
var objectCtorString = funcToString.call(Object);

/**
 * Checks if `value` is a plain object, that is, an object created by the
 * `Object` constructor or one with a `[[Prototype]]` of `null`.
 *
 * @static
 * @memberOf _
 * @since 0.8.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 * }
 *
 * _.isPlainObject(new Foo);
 * // => false
 *
 * _.isPlainObject([1, 2, 3]);
 * // => false
 *
 * _.isPlainObject({ 'x': 0, 'y': 0 });
 * // => true
 *
 * _.isPlainObject(Object.create(null));
 * // => true
 */
function isPlainObject(value) {
  if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
    return false;
  }
  var proto = getPrototype(value);
  if (proto === null) {
    return true;
  }
  var Ctor = hasOwnProperty.call(proto, 'constructor') && proto.constructor;
  return typeof Ctor == 'function' && Ctor instanceof Ctor &&
    funcToString.call(Ctor) == objectCtorString;
}

module.exports = isPlainObject;


/***/ }),

/***/ "./node_modules/lodash/isSet.js":
/*!**************************************!*\
  !*** ./node_modules/lodash/isSet.js ***!
  \**************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseIsSet = __webpack_require__(/*! ./_baseIsSet */ "./node_modules/lodash/_baseIsSet.js"),
    baseUnary = __webpack_require__(/*! ./_baseUnary */ "./node_modules/lodash/_baseUnary.js"),
    nodeUtil = __webpack_require__(/*! ./_nodeUtil */ "./node_modules/lodash/_nodeUtil.js");

/* Node.js helper references. */
var nodeIsSet = nodeUtil && nodeUtil.isSet;

/**
 * Checks if `value` is classified as a `Set` object.
 *
 * @static
 * @memberOf _
 * @since 4.3.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a set, else `false`.
 * @example
 *
 * _.isSet(new Set);
 * // => true
 *
 * _.isSet(new WeakSet);
 * // => false
 */
var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;

module.exports = isSet;


/***/ }),

/***/ "./node_modules/lodash/isString.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/isString.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseGetTag = __webpack_require__(/*! ./_baseGetTag */ "./node_modules/lodash/_baseGetTag.js"),
    isArray = __webpack_require__(/*! ./isArray */ "./node_modules/lodash/isArray.js"),
    isObjectLike = __webpack_require__(/*! ./isObjectLike */ "./node_modules/lodash/isObjectLike.js");

/** `Object#toString` result references. */
var stringTag = '[object String]';

/**
 * Checks if `value` is classified as a `String` primitive or object.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a string, else `false`.
 * @example
 *
 * _.isString('abc');
 * // => true
 *
 * _.isString(1);
 * // => false
 */
function isString(value) {
  return typeof value == 'string' ||
    (!isArray(value) && isObjectLike(value) && baseGetTag(value) == stringTag);
}

module.exports = isString;


/***/ }),

/***/ "./node_modules/lodash/isSymbol.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/isSymbol.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseGetTag = __webpack_require__(/*! ./_baseGetTag */ "./node_modules/lodash/_baseGetTag.js"),
    isObjectLike = __webpack_require__(/*! ./isObjectLike */ "./node_modules/lodash/isObjectLike.js");

/** `Object#toString` result references. */
var symbolTag = '[object Symbol]';

/**
 * Checks if `value` is classified as a `Symbol` primitive or object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
 * @example
 *
 * _.isSymbol(Symbol.iterator);
 * // => true
 *
 * _.isSymbol('abc');
 * // => false
 */
function isSymbol(value) {
  return typeof value == 'symbol' ||
    (isObjectLike(value) && baseGetTag(value) == symbolTag);
}

module.exports = isSymbol;


/***/ }),

/***/ "./node_modules/lodash/isTypedArray.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash/isTypedArray.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseIsTypedArray = __webpack_require__(/*! ./_baseIsTypedArray */ "./node_modules/lodash/_baseIsTypedArray.js"),
    baseUnary = __webpack_require__(/*! ./_baseUnary */ "./node_modules/lodash/_baseUnary.js"),
    nodeUtil = __webpack_require__(/*! ./_nodeUtil */ "./node_modules/lodash/_nodeUtil.js");

/* Node.js helper references. */
var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;

/**
 * Checks if `value` is classified as a typed array.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 * @example
 *
 * _.isTypedArray(new Uint8Array);
 * // => true
 *
 * _.isTypedArray([]);
 * // => false
 */
var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;

module.exports = isTypedArray;


/***/ }),

/***/ "./node_modules/lodash/isUndefined.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/isUndefined.js ***!
  \********************************************/
/***/ ((module) => {

/**
 * Checks if `value` is `undefined`.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is `undefined`, else `false`.
 * @example
 *
 * _.isUndefined(void 0);
 * // => true
 *
 * _.isUndefined(null);
 * // => false
 */
function isUndefined(value) {
  return value === undefined;
}

module.exports = isUndefined;


/***/ }),

/***/ "./node_modules/lodash/keys.js":
/*!*************************************!*\
  !*** ./node_modules/lodash/keys.js ***!
  \*************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var arrayLikeKeys = __webpack_require__(/*! ./_arrayLikeKeys */ "./node_modules/lodash/_arrayLikeKeys.js"),
    baseKeys = __webpack_require__(/*! ./_baseKeys */ "./node_modules/lodash/_baseKeys.js"),
    isArrayLike = __webpack_require__(/*! ./isArrayLike */ "./node_modules/lodash/isArrayLike.js");

/**
 * Creates an array of the own enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects. See the
 * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * for more details.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keys(new Foo);
 * // => ['a', 'b'] (iteration order is not guaranteed)
 *
 * _.keys('hi');
 * // => ['0', '1']
 */
function keys(object) {
  return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
}

module.exports = keys;


/***/ }),

/***/ "./node_modules/lodash/keysIn.js":
/*!***************************************!*\
  !*** ./node_modules/lodash/keysIn.js ***!
  \***************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var arrayLikeKeys = __webpack_require__(/*! ./_arrayLikeKeys */ "./node_modules/lodash/_arrayLikeKeys.js"),
    baseKeysIn = __webpack_require__(/*! ./_baseKeysIn */ "./node_modules/lodash/_baseKeysIn.js"),
    isArrayLike = __webpack_require__(/*! ./isArrayLike */ "./node_modules/lodash/isArrayLike.js");

/**
 * Creates an array of the own and inherited enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keysIn(new Foo);
 * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
 */
function keysIn(object) {
  return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
}

module.exports = keysIn;


/***/ }),

/***/ "./node_modules/lodash/last.js":
/*!*************************************!*\
  !*** ./node_modules/lodash/last.js ***!
  \*************************************/
/***/ ((module) => {

/**
 * Gets the last element of `array`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Array
 * @param {Array} array The array to query.
 * @returns {*} Returns the last element of `array`.
 * @example
 *
 * _.last([1, 2, 3]);
 * // => 3
 */
function last(array) {
  var length = array == null ? 0 : array.length;
  return length ? array[length - 1] : undefined;
}

module.exports = last;


/***/ }),

/***/ "./node_modules/lodash/map.js":
/*!************************************!*\
  !*** ./node_modules/lodash/map.js ***!
  \************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var arrayMap = __webpack_require__(/*! ./_arrayMap */ "./node_modules/lodash/_arrayMap.js"),
    baseIteratee = __webpack_require__(/*! ./_baseIteratee */ "./node_modules/lodash/_baseIteratee.js"),
    baseMap = __webpack_require__(/*! ./_baseMap */ "./node_modules/lodash/_baseMap.js"),
    isArray = __webpack_require__(/*! ./isArray */ "./node_modules/lodash/isArray.js");

/**
 * Creates an array of values by running each element in `collection` thru
 * `iteratee`. The iteratee is invoked with three arguments:
 * (value, index|key, collection).
 *
 * Many lodash methods are guarded to work as iteratees for methods like
 * `_.every`, `_.filter`, `_.map`, `_.mapValues`, `_.reject`, and `_.some`.
 *
 * The guarded methods are:
 * `ary`, `chunk`, `curry`, `curryRight`, `drop`, `dropRight`, `every`,
 * `fill`, `invert`, `parseInt`, `random`, `range`, `rangeRight`, `repeat`,
 * `sampleSize`, `slice`, `some`, `sortBy`, `split`, `take`, `takeRight`,
 * `template`, `trim`, `trimEnd`, `trimStart`, and `words`
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Collection
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} [iteratee=_.identity] The function invoked per iteration.
 * @returns {Array} Returns the new mapped array.
 * @example
 *
 * function square(n) {
 *   return n * n;
 * }
 *
 * _.map([4, 8], square);
 * // => [16, 64]
 *
 * _.map({ 'a': 4, 'b': 8 }, square);
 * // => [16, 64] (iteration order is not guaranteed)
 *
 * var users = [
 *   { 'user': 'barney' },
 *   { 'user': 'fred' }
 * ];
 *
 * // The `_.property` iteratee shorthand.
 * _.map(users, 'user');
 * // => ['barney', 'fred']
 */
function map(collection, iteratee) {
  var func = isArray(collection) ? arrayMap : baseMap;
  return func(collection, baseIteratee(iteratee, 3));
}

module.exports = map;


/***/ }),

/***/ "./node_modules/lodash/mapValues.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/mapValues.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseAssignValue = __webpack_require__(/*! ./_baseAssignValue */ "./node_modules/lodash/_baseAssignValue.js"),
    baseForOwn = __webpack_require__(/*! ./_baseForOwn */ "./node_modules/lodash/_baseForOwn.js"),
    baseIteratee = __webpack_require__(/*! ./_baseIteratee */ "./node_modules/lodash/_baseIteratee.js");

/**
 * Creates an object with the same keys as `object` and values generated
 * by running each own enumerable string keyed property of `object` thru
 * `iteratee`. The iteratee is invoked with three arguments:
 * (value, key, object).
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Object
 * @param {Object} object The object to iterate over.
 * @param {Function} [iteratee=_.identity] The function invoked per iteration.
 * @returns {Object} Returns the new mapped object.
 * @see _.mapKeys
 * @example
 *
 * var users = {
 *   'fred':    { 'user': 'fred',    'age': 40 },
 *   'pebbles': { 'user': 'pebbles', 'age': 1 }
 * };
 *
 * _.mapValues(users, function(o) { return o.age; });
 * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)
 *
 * // The `_.property` iteratee shorthand.
 * _.mapValues(users, 'age');
 * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)
 */
function mapValues(object, iteratee) {
  var result = {};
  iteratee = baseIteratee(iteratee, 3);

  baseForOwn(object, function(value, key, object) {
    baseAssignValue(result, key, iteratee(value, key, object));
  });
  return result;
}

module.exports = mapValues;


/***/ }),

/***/ "./node_modules/lodash/max.js":
/*!************************************!*\
  !*** ./node_modules/lodash/max.js ***!
  \************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseExtremum = __webpack_require__(/*! ./_baseExtremum */ "./node_modules/lodash/_baseExtremum.js"),
    baseGt = __webpack_require__(/*! ./_baseGt */ "./node_modules/lodash/_baseGt.js"),
    identity = __webpack_require__(/*! ./identity */ "./node_modules/lodash/identity.js");

/**
 * Computes the maximum value of `array`. If `array` is empty or falsey,
 * `undefined` is returned.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Math
 * @param {Array} array The array to iterate over.
 * @returns {*} Returns the maximum value.
 * @example
 *
 * _.max([4, 2, 8, 6]);
 * // => 8
 *
 * _.max([]);
 * // => undefined
 */
function max(array) {
  return (array && array.length)
    ? baseExtremum(array, identity, baseGt)
    : undefined;
}

module.exports = max;


/***/ }),

/***/ "./node_modules/lodash/memoize.js":
/*!****************************************!*\
  !*** ./node_modules/lodash/memoize.js ***!
  \****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var MapCache = __webpack_require__(/*! ./_MapCache */ "./node_modules/lodash/_MapCache.js");

/** Error message constants. */
var FUNC_ERROR_TEXT = 'Expected a function';

/**
 * Creates a function that memoizes the result of `func`. If `resolver` is
 * provided, it determines the cache key for storing the result based on the
 * arguments provided to the memoized function. By default, the first argument
 * provided to the memoized function is used as the map cache key. The `func`
 * is invoked with the `this` binding of the memoized function.
 *
 * **Note:** The cache is exposed as the `cache` property on the memoized
 * function. Its creation may be customized by replacing the `_.memoize.Cache`
 * constructor with one whose instances implement the
 * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
 * method interface of `clear`, `delete`, `get`, `has`, and `set`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to have its output memoized.
 * @param {Function} [resolver] The function to resolve the cache key.
 * @returns {Function} Returns the new memoized function.
 * @example
 *
 * var object = { 'a': 1, 'b': 2 };
 * var other = { 'c': 3, 'd': 4 };
 *
 * var values = _.memoize(_.values);
 * values(object);
 * // => [1, 2]
 *
 * values(other);
 * // => [3, 4]
 *
 * object.a = 2;
 * values(object);
 * // => [1, 2]
 *
 * // Modify the result cache.
 * values.cache.set(object, ['a', 'b']);
 * values(object);
 * // => ['a', 'b']
 *
 * // Replace `_.memoize.Cache`.
 * _.memoize.Cache = WeakMap;
 */
function memoize(func, resolver) {
  if (typeof func != 'function' || (resolver != null && typeof resolver != 'function')) {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  var memoized = function() {
    var args = arguments,
        key = resolver ? resolver.apply(this, args) : args[0],
        cache = memoized.cache;

    if (cache.has(key)) {
      return cache.get(key);
    }
    var result = func.apply(this, args);
    memoized.cache = cache.set(key, result) || cache;
    return result;
  };
  memoized.cache = new (memoize.Cache || MapCache);
  return memoized;
}

// Expose `MapCache`.
memoize.Cache = MapCache;

module.exports = memoize;


/***/ }),

/***/ "./node_modules/lodash/merge.js":
/*!**************************************!*\
  !*** ./node_modules/lodash/merge.js ***!
  \**************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseMerge = __webpack_require__(/*! ./_baseMerge */ "./node_modules/lodash/_baseMerge.js"),
    createAssigner = __webpack_require__(/*! ./_createAssigner */ "./node_modules/lodash/_createAssigner.js");

/**
 * This method is like `_.assign` except that it recursively merges own and
 * inherited enumerable string keyed properties of source objects into the
 * destination object. Source properties that resolve to `undefined` are
 * skipped if a destination value exists. Array and plain object properties
 * are merged recursively. Other objects and value types are overridden by
 * assignment. Source objects are applied from left to right. Subsequent
 * sources overwrite property assignments of previous sources.
 *
 * **Note:** This method mutates `object`.
 *
 * @static
 * @memberOf _
 * @since 0.5.0
 * @category Object
 * @param {Object} object The destination object.
 * @param {...Object} [sources] The source objects.
 * @returns {Object} Returns `object`.
 * @example
 *
 * var object = {
 *   'a': [{ 'b': 2 }, { 'd': 4 }]
 * };
 *
 * var other = {
 *   'a': [{ 'c': 3 }, { 'e': 5 }]
 * };
 *
 * _.merge(object, other);
 * // => { 'a': [{ 'b': 2, 'c': 3 }, { 'd': 4, 'e': 5 }] }
 */
var merge = createAssigner(function(object, source, srcIndex) {
  baseMerge(object, source, srcIndex);
});

module.exports = merge;


/***/ }),

/***/ "./node_modules/lodash/min.js":
/*!************************************!*\
  !*** ./node_modules/lodash/min.js ***!
  \************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseExtremum = __webpack_require__(/*! ./_baseExtremum */ "./node_modules/lodash/_baseExtremum.js"),
    baseLt = __webpack_require__(/*! ./_baseLt */ "./node_modules/lodash/_baseLt.js"),
    identity = __webpack_require__(/*! ./identity */ "./node_modules/lodash/identity.js");

/**
 * Computes the minimum value of `array`. If `array` is empty or falsey,
 * `undefined` is returned.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Math
 * @param {Array} array The array to iterate over.
 * @returns {*} Returns the minimum value.
 * @example
 *
 * _.min([4, 2, 8, 6]);
 * // => 2
 *
 * _.min([]);
 * // => undefined
 */
function min(array) {
  return (array && array.length)
    ? baseExtremum(array, identity, baseLt)
    : undefined;
}

module.exports = min;


/***/ }),

/***/ "./node_modules/lodash/minBy.js":
/*!**************************************!*\
  !*** ./node_modules/lodash/minBy.js ***!
  \**************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseExtremum = __webpack_require__(/*! ./_baseExtremum */ "./node_modules/lodash/_baseExtremum.js"),
    baseIteratee = __webpack_require__(/*! ./_baseIteratee */ "./node_modules/lodash/_baseIteratee.js"),
    baseLt = __webpack_require__(/*! ./_baseLt */ "./node_modules/lodash/_baseLt.js");

/**
 * This method is like `_.min` except that it accepts `iteratee` which is
 * invoked for each element in `array` to generate the criterion by which
 * the value is ranked. The iteratee is invoked with one argument: (value).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Math
 * @param {Array} array The array to iterate over.
 * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
 * @returns {*} Returns the minimum value.
 * @example
 *
 * var objects = [{ 'n': 1 }, { 'n': 2 }];
 *
 * _.minBy(objects, function(o) { return o.n; });
 * // => { 'n': 1 }
 *
 * // The `_.property` iteratee shorthand.
 * _.minBy(objects, 'n');
 * // => { 'n': 1 }
 */
function minBy(array, iteratee) {
  return (array && array.length)
    ? baseExtremum(array, baseIteratee(iteratee, 2), baseLt)
    : undefined;
}

module.exports = minBy;


/***/ }),

/***/ "./node_modules/lodash/noop.js":
/*!*************************************!*\
  !*** ./node_modules/lodash/noop.js ***!
  \*************************************/
/***/ ((module) => {

/**
 * This method returns `undefined`.
 *
 * @static
 * @memberOf _
 * @since 2.3.0
 * @category Util
 * @example
 *
 * _.times(2, _.noop);
 * // => [undefined, undefined]
 */
function noop() {
  // No operation performed.
}

module.exports = noop;


/***/ }),

/***/ "./node_modules/lodash/now.js":
/*!************************************!*\
  !*** ./node_modules/lodash/now.js ***!
  \************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var root = __webpack_require__(/*! ./_root */ "./node_modules/lodash/_root.js");

/**
 * Gets the timestamp of the number of milliseconds that have elapsed since
 * the Unix epoch (1 January 1970 00:00:00 UTC).
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Date
 * @returns {number} Returns the timestamp.
 * @example
 *
 * _.defer(function(stamp) {
 *   console.log(_.now() - stamp);
 * }, _.now());
 * // => Logs the number of milliseconds it took for the deferred invocation.
 */
var now = function() {
  return root.Date.now();
};

module.exports = now;


/***/ }),

/***/ "./node_modules/lodash/pick.js":
/*!*************************************!*\
  !*** ./node_modules/lodash/pick.js ***!
  \*************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var basePick = __webpack_require__(/*! ./_basePick */ "./node_modules/lodash/_basePick.js"),
    flatRest = __webpack_require__(/*! ./_flatRest */ "./node_modules/lodash/_flatRest.js");

/**
 * Creates an object composed of the picked `object` properties.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The source object.
 * @param {...(string|string[])} [paths] The property paths to pick.
 * @returns {Object} Returns the new object.
 * @example
 *
 * var object = { 'a': 1, 'b': '2', 'c': 3 };
 *
 * _.pick(object, ['a', 'c']);
 * // => { 'a': 1, 'c': 3 }
 */
var pick = flatRest(function(object, paths) {
  return object == null ? {} : basePick(object, paths);
});

module.exports = pick;


/***/ }),

/***/ "./node_modules/lodash/property.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/property.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseProperty = __webpack_require__(/*! ./_baseProperty */ "./node_modules/lodash/_baseProperty.js"),
    basePropertyDeep = __webpack_require__(/*! ./_basePropertyDeep */ "./node_modules/lodash/_basePropertyDeep.js"),
    isKey = __webpack_require__(/*! ./_isKey */ "./node_modules/lodash/_isKey.js"),
    toKey = __webpack_require__(/*! ./_toKey */ "./node_modules/lodash/_toKey.js");

/**
 * Creates a function that returns the value at `path` of a given object.
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Util
 * @param {Array|string} path The path of the property to get.
 * @returns {Function} Returns the new accessor function.
 * @example
 *
 * var objects = [
 *   { 'a': { 'b': 2 } },
 *   { 'a': { 'b': 1 } }
 * ];
 *
 * _.map(objects, _.property('a.b'));
 * // => [2, 1]
 *
 * _.map(_.sortBy(objects, _.property(['a', 'b'])), 'a.b');
 * // => [1, 2]
 */
function property(path) {
  return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
}

module.exports = property;


/***/ }),

/***/ "./node_modules/lodash/range.js":
/*!**************************************!*\
  !*** ./node_modules/lodash/range.js ***!
  \**************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var createRange = __webpack_require__(/*! ./_createRange */ "./node_modules/lodash/_createRange.js");

/**
 * Creates an array of numbers (positive and/or negative) progressing from
 * `start` up to, but not including, `end`. A step of `-1` is used if a negative
 * `start` is specified without an `end` or `step`. If `end` is not specified,
 * it's set to `start` with `start` then set to `0`.
 *
 * **Note:** JavaScript follows the IEEE-754 standard for resolving
 * floating-point values which can produce unexpected results.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Util
 * @param {number} [start=0] The start of the range.
 * @param {number} end The end of the range.
 * @param {number} [step=1] The value to increment or decrement by.
 * @returns {Array} Returns the range of numbers.
 * @see _.inRange, _.rangeRight
 * @example
 *
 * _.range(4);
 * // => [0, 1, 2, 3]
 *
 * _.range(-4);
 * // => [0, -1, -2, -3]
 *
 * _.range(1, 5);
 * // => [1, 2, 3, 4]
 *
 * _.range(0, 20, 5);
 * // => [0, 5, 10, 15]
 *
 * _.range(0, -4, -1);
 * // => [0, -1, -2, -3]
 *
 * _.range(1, 4, 0);
 * // => [1, 1, 1]
 *
 * _.range(0);
 * // => []
 */
var range = createRange();

module.exports = range;


/***/ }),

/***/ "./node_modules/lodash/reduce.js":
/*!***************************************!*\
  !*** ./node_modules/lodash/reduce.js ***!
  \***************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var arrayReduce = __webpack_require__(/*! ./_arrayReduce */ "./node_modules/lodash/_arrayReduce.js"),
    baseEach = __webpack_require__(/*! ./_baseEach */ "./node_modules/lodash/_baseEach.js"),
    baseIteratee = __webpack_require__(/*! ./_baseIteratee */ "./node_modules/lodash/_baseIteratee.js"),
    baseReduce = __webpack_require__(/*! ./_baseReduce */ "./node_modules/lodash/_baseReduce.js"),
    isArray = __webpack_require__(/*! ./isArray */ "./node_modules/lodash/isArray.js");

/**
 * Reduces `collection` to a value which is the accumulated result of running
 * each element in `collection` thru `iteratee`, where each successive
 * invocation is supplied the return value of the previous. If `accumulator`
 * is not given, the first element of `collection` is used as the initial
 * value. The iteratee is invoked with four arguments:
 * (accumulator, value, index|key, collection).
 *
 * Many lodash methods are guarded to work as iteratees for methods like
 * `_.reduce`, `_.reduceRight`, and `_.transform`.
 *
 * The guarded methods are:
 * `assign`, `defaults`, `defaultsDeep`, `includes`, `merge`, `orderBy`,
 * and `sortBy`
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Collection
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} [iteratee=_.identity] The function invoked per iteration.
 * @param {*} [accumulator] The initial value.
 * @returns {*} Returns the accumulated value.
 * @see _.reduceRight
 * @example
 *
 * _.reduce([1, 2], function(sum, n) {
 *   return sum + n;
 * }, 0);
 * // => 3
 *
 * _.reduce({ 'a': 1, 'b': 2, 'c': 1 }, function(result, value, key) {
 *   (result[value] || (result[value] = [])).push(key);
 *   return result;
 * }, {});
 * // => { '1': ['a', 'c'], '2': ['b'] } (iteration order is not guaranteed)
 */
function reduce(collection, iteratee, accumulator) {
  var func = isArray(collection) ? arrayReduce : baseReduce,
      initAccum = arguments.length < 3;

  return func(collection, baseIteratee(iteratee, 4), accumulator, initAccum, baseEach);
}

module.exports = reduce;


/***/ }),

/***/ "./node_modules/lodash/size.js":
/*!*************************************!*\
  !*** ./node_modules/lodash/size.js ***!
  \*************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseKeys = __webpack_require__(/*! ./_baseKeys */ "./node_modules/lodash/_baseKeys.js"),
    getTag = __webpack_require__(/*! ./_getTag */ "./node_modules/lodash/_getTag.js"),
    isArrayLike = __webpack_require__(/*! ./isArrayLike */ "./node_modules/lodash/isArrayLike.js"),
    isString = __webpack_require__(/*! ./isString */ "./node_modules/lodash/isString.js"),
    stringSize = __webpack_require__(/*! ./_stringSize */ "./node_modules/lodash/_stringSize.js");

/** `Object#toString` result references. */
var mapTag = '[object Map]',
    setTag = '[object Set]';

/**
 * Gets the size of `collection` by returning its length for array-like
 * values or the number of own enumerable string keyed properties for objects.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Collection
 * @param {Array|Object|string} collection The collection to inspect.
 * @returns {number} Returns the collection size.
 * @example
 *
 * _.size([1, 2, 3]);
 * // => 3
 *
 * _.size({ 'a': 1, 'b': 2 });
 * // => 2
 *
 * _.size('pebbles');
 * // => 7
 */
function size(collection) {
  if (collection == null) {
    return 0;
  }
  if (isArrayLike(collection)) {
    return isString(collection) ? stringSize(collection) : collection.length;
  }
  var tag = getTag(collection);
  if (tag == mapTag || tag == setTag) {
    return collection.size;
  }
  return baseKeys(collection).length;
}

module.exports = size;


/***/ }),

/***/ "./node_modules/lodash/sortBy.js":
/*!***************************************!*\
  !*** ./node_modules/lodash/sortBy.js ***!
  \***************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseFlatten = __webpack_require__(/*! ./_baseFlatten */ "./node_modules/lodash/_baseFlatten.js"),
    baseOrderBy = __webpack_require__(/*! ./_baseOrderBy */ "./node_modules/lodash/_baseOrderBy.js"),
    baseRest = __webpack_require__(/*! ./_baseRest */ "./node_modules/lodash/_baseRest.js"),
    isIterateeCall = __webpack_require__(/*! ./_isIterateeCall */ "./node_modules/lodash/_isIterateeCall.js");

/**
 * Creates an array of elements, sorted in ascending order by the results of
 * running each element in a collection thru each iteratee. This method
 * performs a stable sort, that is, it preserves the original sort order of
 * equal elements. The iteratees are invoked with one argument: (value).
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Collection
 * @param {Array|Object} collection The collection to iterate over.
 * @param {...(Function|Function[])} [iteratees=[_.identity]]
 *  The iteratees to sort by.
 * @returns {Array} Returns the new sorted array.
 * @example
 *
 * var users = [
 *   { 'user': 'fred',   'age': 48 },
 *   { 'user': 'barney', 'age': 36 },
 *   { 'user': 'fred',   'age': 30 },
 *   { 'user': 'barney', 'age': 34 }
 * ];
 *
 * _.sortBy(users, [function(o) { return o.user; }]);
 * // => objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 30]]
 *
 * _.sortBy(users, ['user', 'age']);
 * // => objects for [['barney', 34], ['barney', 36], ['fred', 30], ['fred', 48]]
 */
var sortBy = baseRest(function(collection, iteratees) {
  if (collection == null) {
    return [];
  }
  var length = iteratees.length;
  if (length > 1 && isIterateeCall(collection, iteratees[0], iteratees[1])) {
    iteratees = [];
  } else if (length > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) {
    iteratees = [iteratees[0]];
  }
  return baseOrderBy(collection, baseFlatten(iteratees, 1), []);
});

module.exports = sortBy;


/***/ }),

/***/ "./node_modules/lodash/stubArray.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/stubArray.js ***!
  \******************************************/
/***/ ((module) => {

/**
 * This method returns a new empty array.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {Array} Returns the new empty array.
 * @example
 *
 * var arrays = _.times(2, _.stubArray);
 *
 * console.log(arrays);
 * // => [[], []]
 *
 * console.log(arrays[0] === arrays[1]);
 * // => false
 */
function stubArray() {
  return [];
}

module.exports = stubArray;


/***/ }),

/***/ "./node_modules/lodash/stubFalse.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/stubFalse.js ***!
  \******************************************/
/***/ ((module) => {

/**
 * This method returns `false`.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {boolean} Returns `false`.
 * @example
 *
 * _.times(2, _.stubFalse);
 * // => [false, false]
 */
function stubFalse() {
  return false;
}

module.exports = stubFalse;


/***/ }),

/***/ "./node_modules/lodash/toFinite.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/toFinite.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var toNumber = __webpack_require__(/*! ./toNumber */ "./node_modules/lodash/toNumber.js");

/** Used as references for various `Number` constants. */
var INFINITY = 1 / 0,
    MAX_INTEGER = 1.7976931348623157e+308;

/**
 * Converts `value` to a finite number.
 *
 * @static
 * @memberOf _
 * @since 4.12.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {number} Returns the converted number.
 * @example
 *
 * _.toFinite(3.2);
 * // => 3.2
 *
 * _.toFinite(Number.MIN_VALUE);
 * // => 5e-324
 *
 * _.toFinite(Infinity);
 * // => 1.7976931348623157e+308
 *
 * _.toFinite('3.2');
 * // => 3.2
 */
function toFinite(value) {
  if (!value) {
    return value === 0 ? value : 0;
  }
  value = toNumber(value);
  if (value === INFINITY || value === -INFINITY) {
    var sign = (value < 0 ? -1 : 1);
    return sign * MAX_INTEGER;
  }
  return value === value ? value : 0;
}

module.exports = toFinite;


/***/ }),

/***/ "./node_modules/lodash/toInteger.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/toInteger.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var toFinite = __webpack_require__(/*! ./toFinite */ "./node_modules/lodash/toFinite.js");

/**
 * Converts `value` to an integer.
 *
 * **Note:** This method is loosely based on
 * [`ToInteger`](http://www.ecma-international.org/ecma-262/7.0/#sec-tointeger).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {number} Returns the converted integer.
 * @example
 *
 * _.toInteger(3.2);
 * // => 3
 *
 * _.toInteger(Number.MIN_VALUE);
 * // => 0
 *
 * _.toInteger(Infinity);
 * // => 1.7976931348623157e+308
 *
 * _.toInteger('3.2');
 * // => 3
 */
function toInteger(value) {
  var result = toFinite(value),
      remainder = result % 1;

  return result === result ? (remainder ? result - remainder : result) : 0;
}

module.exports = toInteger;


/***/ }),

/***/ "./node_modules/lodash/toNumber.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/toNumber.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseTrim = __webpack_require__(/*! ./_baseTrim */ "./node_modules/lodash/_baseTrim.js"),
    isObject = __webpack_require__(/*! ./isObject */ "./node_modules/lodash/isObject.js"),
    isSymbol = __webpack_require__(/*! ./isSymbol */ "./node_modules/lodash/isSymbol.js");

/** Used as references for various `Number` constants. */
var NAN = 0 / 0;

/** Used to detect bad signed hexadecimal string values. */
var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;

/** Used to detect binary string values. */
var reIsBinary = /^0b[01]+$/i;

/** Used to detect octal string values. */
var reIsOctal = /^0o[0-7]+$/i;

/** Built-in method references without a dependency on `root`. */
var freeParseInt = parseInt;

/**
 * Converts `value` to a number.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to process.
 * @returns {number} Returns the number.
 * @example
 *
 * _.toNumber(3.2);
 * // => 3.2
 *
 * _.toNumber(Number.MIN_VALUE);
 * // => 5e-324
 *
 * _.toNumber(Infinity);
 * // => Infinity
 *
 * _.toNumber('3.2');
 * // => 3.2
 */
function toNumber(value) {
  if (typeof value == 'number') {
    return value;
  }
  if (isSymbol(value)) {
    return NAN;
  }
  if (isObject(value)) {
    var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
    value = isObject(other) ? (other + '') : other;
  }
  if (typeof value != 'string') {
    return value === 0 ? value : +value;
  }
  value = baseTrim(value);
  var isBinary = reIsBinary.test(value);
  return (isBinary || reIsOctal.test(value))
    ? freeParseInt(value.slice(2), isBinary ? 2 : 8)
    : (reIsBadHex.test(value) ? NAN : +value);
}

module.exports = toNumber;


/***/ }),

/***/ "./node_modules/lodash/toPlainObject.js":
/*!**********************************************!*\
  !*** ./node_modules/lodash/toPlainObject.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var copyObject = __webpack_require__(/*! ./_copyObject */ "./node_modules/lodash/_copyObject.js"),
    keysIn = __webpack_require__(/*! ./keysIn */ "./node_modules/lodash/keysIn.js");

/**
 * Converts `value` to a plain object flattening inherited enumerable string
 * keyed properties of `value` to own properties of the plain object.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {Object} Returns the converted plain object.
 * @example
 *
 * function Foo() {
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.assign({ 'a': 1 }, new Foo);
 * // => { 'a': 1, 'b': 2 }
 *
 * _.assign({ 'a': 1 }, _.toPlainObject(new Foo));
 * // => { 'a': 1, 'b': 2, 'c': 3 }
 */
function toPlainObject(value) {
  return copyObject(value, keysIn(value));
}

module.exports = toPlainObject;


/***/ }),

/***/ "./node_modules/lodash/toString.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/toString.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseToString = __webpack_require__(/*! ./_baseToString */ "./node_modules/lodash/_baseToString.js");

/**
 * Converts `value` to a string. An empty string is returned for `null`
 * and `undefined` values. The sign of `-0` is preserved.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 * @example
 *
 * _.toString(null);
 * // => ''
 *
 * _.toString(-0);
 * // => '-0'
 *
 * _.toString([1, 2, 3]);
 * // => '1,2,3'
 */
function toString(value) {
  return value == null ? '' : baseToString(value);
}

module.exports = toString;


/***/ }),

/***/ "./node_modules/lodash/transform.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/transform.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var arrayEach = __webpack_require__(/*! ./_arrayEach */ "./node_modules/lodash/_arrayEach.js"),
    baseCreate = __webpack_require__(/*! ./_baseCreate */ "./node_modules/lodash/_baseCreate.js"),
    baseForOwn = __webpack_require__(/*! ./_baseForOwn */ "./node_modules/lodash/_baseForOwn.js"),
    baseIteratee = __webpack_require__(/*! ./_baseIteratee */ "./node_modules/lodash/_baseIteratee.js"),
    getPrototype = __webpack_require__(/*! ./_getPrototype */ "./node_modules/lodash/_getPrototype.js"),
    isArray = __webpack_require__(/*! ./isArray */ "./node_modules/lodash/isArray.js"),
    isBuffer = __webpack_require__(/*! ./isBuffer */ "./node_modules/lodash/isBuffer.js"),
    isFunction = __webpack_require__(/*! ./isFunction */ "./node_modules/lodash/isFunction.js"),
    isObject = __webpack_require__(/*! ./isObject */ "./node_modules/lodash/isObject.js"),
    isTypedArray = __webpack_require__(/*! ./isTypedArray */ "./node_modules/lodash/isTypedArray.js");

/**
 * An alternative to `_.reduce`; this method transforms `object` to a new
 * `accumulator` object which is the result of running each of its own
 * enumerable string keyed properties thru `iteratee`, with each invocation
 * potentially mutating the `accumulator` object. If `accumulator` is not
 * provided, a new object with the same `[[Prototype]]` will be used. The
 * iteratee is invoked with four arguments: (accumulator, value, key, object).
 * Iteratee functions may exit iteration early by explicitly returning `false`.
 *
 * @static
 * @memberOf _
 * @since 1.3.0
 * @category Object
 * @param {Object} object The object to iterate over.
 * @param {Function} [iteratee=_.identity] The function invoked per iteration.
 * @param {*} [accumulator] The custom accumulator value.
 * @returns {*} Returns the accumulated value.
 * @example
 *
 * _.transform([2, 3, 4], function(result, n) {
 *   result.push(n *= n);
 *   return n % 2 == 0;
 * }, []);
 * // => [4, 9]
 *
 * _.transform({ 'a': 1, 'b': 2, 'c': 1 }, function(result, value, key) {
 *   (result[value] || (result[value] = [])).push(key);
 * }, {});
 * // => { '1': ['a', 'c'], '2': ['b'] }
 */
function transform(object, iteratee, accumulator) {
  var isArr = isArray(object),
      isArrLike = isArr || isBuffer(object) || isTypedArray(object);

  iteratee = baseIteratee(iteratee, 4);
  if (accumulator == null) {
    var Ctor = object && object.constructor;
    if (isArrLike) {
      accumulator = isArr ? new Ctor : [];
    }
    else if (isObject(object)) {
      accumulator = isFunction(Ctor) ? baseCreate(getPrototype(object)) : {};
    }
    else {
      accumulator = {};
    }
  }
  (isArrLike ? arrayEach : baseForOwn)(object, function(value, index, object) {
    return iteratee(accumulator, value, index, object);
  });
  return accumulator;
}

module.exports = transform;


/***/ }),

/***/ "./node_modules/lodash/union.js":
/*!**************************************!*\
  !*** ./node_modules/lodash/union.js ***!
  \**************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseFlatten = __webpack_require__(/*! ./_baseFlatten */ "./node_modules/lodash/_baseFlatten.js"),
    baseRest = __webpack_require__(/*! ./_baseRest */ "./node_modules/lodash/_baseRest.js"),
    baseUniq = __webpack_require__(/*! ./_baseUniq */ "./node_modules/lodash/_baseUniq.js"),
    isArrayLikeObject = __webpack_require__(/*! ./isArrayLikeObject */ "./node_modules/lodash/isArrayLikeObject.js");

/**
 * Creates an array of unique values, in order, from all given arrays using
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * for equality comparisons.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Array
 * @param {...Array} [arrays] The arrays to inspect.
 * @returns {Array} Returns the new array of combined values.
 * @example
 *
 * _.union([2], [1, 2]);
 * // => [2, 1]
 */
var union = baseRest(function(arrays) {
  return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true));
});

module.exports = union;


/***/ }),

/***/ "./node_modules/lodash/uniqueId.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/uniqueId.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var toString = __webpack_require__(/*! ./toString */ "./node_modules/lodash/toString.js");

/** Used to generate unique IDs. */
var idCounter = 0;

/**
 * Generates a unique ID. If `prefix` is given, the ID is appended to it.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Util
 * @param {string} [prefix=''] The value to prefix the ID with.
 * @returns {string} Returns the unique ID.
 * @example
 *
 * _.uniqueId('contact_');
 * // => 'contact_104'
 *
 * _.uniqueId();
 * // => '105'
 */
function uniqueId(prefix) {
  var id = ++idCounter;
  return toString(prefix) + id;
}

module.exports = uniqueId;


/***/ }),

/***/ "./node_modules/lodash/values.js":
/*!***************************************!*\
  !*** ./node_modules/lodash/values.js ***!
  \***************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseValues = __webpack_require__(/*! ./_baseValues */ "./node_modules/lodash/_baseValues.js"),
    keys = __webpack_require__(/*! ./keys */ "./node_modules/lodash/keys.js");

/**
 * Creates an array of the own enumerable string keyed property values of `object`.
 *
 * **Note:** Non-object values are coerced to objects.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property values.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.values(new Foo);
 * // => [1, 2] (iteration order is not guaranteed)
 *
 * _.values('hi');
 * // => ['h', 'i']
 */
function values(object) {
  return object == null ? [] : baseValues(object, keys(object));
}

module.exports = values;


/***/ }),

/***/ "./node_modules/lodash/zipObject.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/zipObject.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var assignValue = __webpack_require__(/*! ./_assignValue */ "./node_modules/lodash/_assignValue.js"),
    baseZipObject = __webpack_require__(/*! ./_baseZipObject */ "./node_modules/lodash/_baseZipObject.js");

/**
 * This method is like `_.fromPairs` except that it accepts two arrays,
 * one of property identifiers and one of corresponding values.
 *
 * @static
 * @memberOf _
 * @since 0.4.0
 * @category Array
 * @param {Array} [props=[]] The property identifiers.
 * @param {Array} [values=[]] The property values.
 * @returns {Object} Returns the new object.
 * @example
 *
 * _.zipObject(['a', 'b'], [1, 2]);
 * // => { 'a': 1, 'b': 2 }
 */
function zipObject(props, values) {
  return baseZipObject(props || [], values || [], assignValue);
}

module.exports = zipObject;


/***/ }),

/***/ "./src/visualizers/run-expr-tests.less":
/*!*********************************************!*\
  !*** ./src/visualizers/run-expr-tests.less ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin


/***/ }),

/***/ "./node_modules/taitto/lib/anim/anim.js":
/*!**********************************************!*\
  !*** ./node_modules/taitto/lib/anim/anim.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AnimSequence = exports.Anim = void 0;
class Anim {
    constructor(target, duration = 1000) {
        this.target = target;
        this.duration = duration;
        this.start = 0;
    }
    get stop() {
        return this.start + this.duration;
    }
    play() {
        return new Promise(resolve => this.start != 0 ?
            setTimeout(() => this.run(resolve), this.start) :
            this.run(resolve));
    }
}
exports.Anim = Anim;
class AnimSequence {
    constructor() {
        this.anims = [];
    }
    play() {
        return Promise.all(this.anims.map(a => a.play()));
    }
    add(anim, start) {
        anim.start = start;
        let i = this.anims.findIndex(a => a.start > start);
        if (i < 0)
            this.anims.push(anim);
        else
            this.anims.splice(i, 0, anim);
    }
    addAt(anim, start) {
        if (Array.isArray(anim))
            anim.forEach(a => this.add(a, start));
        else
            this.add(anim, start);
        return this;
    }
    addAfter(anim, after, delay = 0) {
        if (typeof after === "number")
            after = this.anims[after];
        this.addAt(anim, after.stop + delay);
        return this;
    }
    addToEnd(anim, delay = 0) {
        let maxstop = this.anims.length == 0 ? 0 :
            Math.max(...this.anims.map(a => a.stop));
        this.addAt(anim, maxstop + delay);
        return this;
    }
    addToEndStaggered(anims, gap, delay = 0) {
        let maxstop = this.anims.length == 0 ? 0 :
            Math.max(...this.anims.map(a => a.stop));
        for (let i = 0; i < anims.length; ++i)
            this.addAt(anims[i], maxstop + delay + (i * gap));
        return this;
    }
}
exports.AnimSequence = AnimSequence;
//# sourceMappingURL=anim.js.map

/***/ }),

/***/ "./node_modules/taitto/lib/anim/animated-view.js":
/*!*******************************************************!*\
  !*** ./node_modules/taitto/lib/anim/animated-view.js ***!
  \*******************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.animatedView = exports.AnimatedView = void 0;
const el = __importStar(__webpack_require__(/*! ../svg/elem */ "./node_modules/taitto/lib/svg/elem.js"));
const ad = __importStar(__webpack_require__(/*! ./animated */ "./node_modules/taitto/lib/anim/animated.js"));
const kfa = __importStar(__webpack_require__(/*! ./keyframe-anim */ "./node_modules/taitto/lib/anim/keyframe-anim.js"));
class AnimatedView extends ad.Animated {
    constructor(parent) {
        super(parent.element);
        this.svgparent = parent;
    }
    get parentVBox() {
        return el.getViewBox(this.svgparent);
    }
    zoom(to, duration = 1000) {
        let vbox = this.parentVBox;
        let scale = Math.min(vbox.width / to.width, vbox.height / to.height);
        let x = vbox.left - to.left;
        let y = vbox.top - to.top;
        return new kfa.KeyframeAnim(this, [ad.current, a => a.state.scale(scale, scale).move(x, y)], duration);
    }
    zoomFactor(scale, x, y, duration = 1000) {
        let vbox = this.parentVBox;
        let sx = vbox.centerX - x;
        let sy = vbox.centerY - y;
        return new kfa.KeyframeAnim(this, [ad.current, a => a.state.scale(scale, scale).move(sx, sy)], duration);
    }
    zoomHome(duration = 1000) {
        return new kfa.KeyframeAnim(this, [ad.current, a => a.state.scale(1, 1).move(0, 0)], duration);
    }
    pan(x, y, duration = 1000) {
        return new kfa.KeyframeAnim(this, [ad.current,
            ad.moveRelative(-x, -y)], duration);
    }
    panTo(x, y, duration = 1000) {
        return new kfa.KeyframeAnim(this, [ad.current, ad.move(x, y)], duration);
    }
}
exports.AnimatedView = AnimatedView;
function animatedView(parent) {
    return new AnimatedView(parent);
}
exports.animatedView = animatedView;
//# sourceMappingURL=animated-view.js.map

/***/ }),

/***/ "./node_modules/taitto/lib/anim/animated.js":
/*!**************************************************!*\
  !*** ./node_modules/taitto/lib/anim/animated.js ***!
  \**************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.bounceDown = exports.bounceUp = exports.bounceRight = exports.bounceLeft = exports.wobbleXY = exports.wobbleY = exports.wobbleX = exports.scaleXY = exports.scaleY = exports.scaleX = exports.shiftDown = exports.shiftUp = exports.shiftRight = exports.shiftLeft = exports.shift = exports.moveRelative = exports.move = exports.normalSize = exports.zeroSize = exports.current = exports.reset = exports.offset = exports.animated = exports.Animated = exports.AnimState = void 0;
/**
 * # Animating SVG Elements
 */
const el = __importStar(__webpack_require__(/*! ../svg/elem */ "./node_modules/taitto/lib/svg/elem.js"));
const vec = __importStar(__webpack_require__(/*! ../svg/vector */ "./node_modules/taitto/lib/svg/vector.js"));
class AnimState {
    constructor(scaling, rotation, position, shift) {
        this.scaling = scaling;
        this.rotation = rotation;
        this.position = position;
        this.shift = shift;
    }
    scale(x, y) {
        return new AnimState([x, y], this.rotation, this.position, this.shift);
    }
    rotate(angle) {
        return new AnimState(this.scaling, angle, this.position, this.shift);
    }
    move(x, y) {
        return new AnimState(this.scaling, this.rotation, [x, y], this.shift);
    }
    moveRelative(dx, dy) {
        let [x, y] = this.position;
        return new AnimState(this.scaling, this.rotation, [x + dx, y + dy], this.shift);
    }
    shiftPosition(x, y) {
        return new AnimState(this.scaling, this.rotation, this.position, [x, y]);
    }
    get matrix() {
        let [sx, sy] = this.scaling;
        let [x, y] = vec.addVec(this.position, this.shift);
        return new DOMMatrix()
            .scale(sx, sy)
            .rotate(0, 0, this.rotation)
            .translate(x, y);
    }
    toKeyframe() {
        let [sx, sy] = this.scaling;
        let [x, y] = vec.addVec(this.position, this.shift);
        return {
            transform: `rotateZ(${this.rotation}deg) ` +
                `translate3d(${x}px, ${y}px, 0) ` +
                `scale3d(${sx}, ${sy}, 1)`,
            offset: this.offset
        };
    }
}
exports.AnimState = AnimState;
AnimState.zero = new AnimState(vec.oneVector, 0, vec.zeroVector, vec.zeroVector);
class Animated extends el.GraphElem {
    constructor(parent) {
        super(document.createElementNS(el.ns, 'g'), parent);
        this.state = AnimState.zero;
        this.styles({
            transformOrigin: 'center',
            transformBox: 'fill-box'
        });
    }
    get animatedBBox() {
        return this.bbox.transform(this.state.matrix);
    }
    position(pos) {
        let [x, y] = pos;
        this.state = this.state.move(x, y);
        return this;
    }
}
exports.Animated = Animated;
function animated(parent) {
    return new Animated(parent instanceof el.Elem ? parent.element : parent);
}
exports.animated = animated;
function offset(getState, offset) {
    return a => {
        let state = getState(a);
        state.offset = offset;
        return state;
    };
}
exports.offset = offset;
const reset = a => new AnimState([1, 1], 0, [0, 0], [0, 0]);
exports.reset = reset;
const current = a => a.state;
exports.current = current;
const zeroSize = a => a.state.scale(0, 0);
exports.zeroSize = zeroSize;
const normalSize = a => a.state.scale(1, 1);
exports.normalSize = normalSize;
function move(x, y) {
    return a => a.state.move(x, y);
}
exports.move = move;
function moveRelative(x, y) {
    return a => a.state.moveRelative(x, y);
}
exports.moveRelative = moveRelative;
function shift(x, y) {
    return a => a.state.shiftPosition(x, y);
}
exports.shift = shift;
function shiftLeft(dist) {
    return a => a.state.shiftPosition(-dist * 100, 0);
}
exports.shiftLeft = shiftLeft;
function shiftRight(dist) {
    return a => a.state.shiftPosition(dist * 100, 0);
}
exports.shiftRight = shiftRight;
function shiftUp(dist) {
    return a => a.state.shiftPosition(0, -dist * 100);
}
exports.shiftUp = shiftUp;
function shiftDown(dist) {
    return a => a.state.shiftPosition(0, dist * 100);
}
exports.shiftDown = shiftDown;
function scaleX(scale) {
    return a => a.state.scale(scale, 1);
}
exports.scaleX = scaleX;
function scaleY(scale) {
    return a => a.state.scale(1, scale);
}
exports.scaleY = scaleY;
function scaleXY(scale) {
    return a => a.state.scale(scale, scale);
}
exports.scaleXY = scaleXY;
function* pulsate(times, amplitude) {
    times *= 2;
    for (let i = 0; i < times; i++)
        yield i % 2 == 1 ? 1 : (1 - amplitude) + ((i / times) * amplitude);
}
function pulsateTransform(times, amplitude, transform) {
    return Array.from(pulsate(times, amplitude)).map(transform);
}
function oneMinus(transform) {
    return scale => transform(1 - scale);
}
function createPulsator(transform) {
    return (times = 5, amplitude = times / 10) => pulsateTransform(times, amplitude, transform);
}
exports.wobbleX = createPulsator(scaleX);
exports.wobbleY = createPulsator(scaleY);
exports.wobbleXY = createPulsator(scaleXY);
exports.bounceLeft = createPulsator(oneMinus(shiftLeft));
exports.bounceRight = createPulsator(oneMinus(shiftRight));
exports.bounceUp = createPulsator(oneMinus(shiftUp));
exports.bounceDown = createPulsator(oneMinus(shiftDown));
//# sourceMappingURL=animated.js.map

/***/ }),

/***/ "./node_modules/taitto/lib/anim/custom-anim.js":
/*!*****************************************************!*\
  !*** ./node_modules/taitto/lib/anim/custom-anim.js ***!
  \*****************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.customAnim = exports.CustomAnim = void 0;
const an = __importStar(__webpack_require__(/*! ./anim */ "./node_modules/taitto/lib/anim/anim.js"));
class CustomAnim extends an.Anim {
    constructor(target, action, duration = 1000) {
        super(target, duration);
        this.action = action;
    }
    run(resolve) {
        this.action(this);
        resolve(this);
    }
}
exports.CustomAnim = CustomAnim;
function customAnim(target, action, duration = 1000) {
    return new CustomAnim(target, action, duration);
}
exports.customAnim = customAnim;
//# sourceMappingURL=custom-anim.js.map

/***/ }),

/***/ "./node_modules/taitto/lib/anim/index.js":
/*!***********************************************!*\
  !*** ./node_modules/taitto/lib/anim/index.js ***!
  \***********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
__exportStar(__webpack_require__(/*! ./animated */ "./node_modules/taitto/lib/anim/animated.js"), exports);
__exportStar(__webpack_require__(/*! ./anim */ "./node_modules/taitto/lib/anim/anim.js"), exports);
__exportStar(__webpack_require__(/*! ./keyframe-anim */ "./node_modules/taitto/lib/anim/keyframe-anim.js"), exports);
__exportStar(__webpack_require__(/*! ./custom-anim */ "./node_modules/taitto/lib/anim/custom-anim.js"), exports);
__exportStar(__webpack_require__(/*! ./animated-view */ "./node_modules/taitto/lib/anim/animated-view.js"), exports);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/taitto/lib/anim/keyframe-anim.js":
/*!*******************************************************!*\
  !*** ./node_modules/taitto/lib/anim/keyframe-anim.js ***!
  \*******************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.spreadAround = exports.fadeInOut = exports.fadeOut = exports.fadeIn = exports.zoomIn = exports.slideOutBottom = exports.slideOutTop = exports.slideOutRight = exports.slideOutLeft = exports.slideInBottom = exports.slideInTop = exports.slideInRight = exports.slideInLeft = exports.slideTo = exports.visible = exports.invisible = exports.KeyframeAnim = void 0;
const ad = __importStar(__webpack_require__(/*! ./animated */ "./node_modules/taitto/lib/anim/animated.js"));
const an = __importStar(__webpack_require__(/*! ./anim */ "./node_modules/taitto/lib/anim/anim.js"));
class KeyframeAnim extends an.Anim {
    constructor(target, keyframes, duration = 1000, fill = "both", direction = "normal", iterations = 1) {
        super(target, duration);
        this.keyframes = keyframes;
        this.fill = fill;
        this.direction = direction;
        this.iterations = iterations;
    }
    stopOn(event) {
        this.stopEvent = event;
        return this;
    }
    getKeyframe(kf) {
        if (typeof kf === 'function') {
            if (!(this.target instanceof ad.Animated))
                throw Error("Target not of type Animated");
            let state = kf(this.target);
            this.target.state = state;
            return state.toKeyframe();
        }
        return kf;
    }
    run(resolve) {
        let a = this.target.element.animate(this.keyframes.map(kf => this.getKeyframe(kf)), {
            duration: this.duration,
            fill: this.fill,
            direction: this.direction,
            iterations: this.iterations
        });
        a.onfinish = () => resolve(this);
        a.oncancel = () => resolve(this);
        if (this.stopEvent)
            this.target.element.addEventListener(this.stopEvent, () => a.cancel());
    }
}
exports.KeyframeAnim = KeyframeAnim;
function invisible() { return { opacity: 0 }; }
exports.invisible = invisible;
function visible() { return { opacity: 1 }; }
exports.visible = visible;
function slideTo(elem, pos, duration = 1000) {
    let [x, y] = pos;
    return new KeyframeAnim(elem, [ad.current, ad.move(x, y)], duration);
}
exports.slideTo = slideTo;
function createSlideIn(move, bounce) {
    return (elem, distance = 1, duration = 1000) => {
        let kfs = [move(distance), move(0)].concat(bounce(2));
        kfs[1] = ad.offset(kfs[1], 0.5 + Math.min(duration / 10000, 0.5));
        return new KeyframeAnim(elem, kfs, duration);
    };
}
function createSlideOut(move) {
    return (elem, distance = 1, duration = 1000) => {
        let kfs = ([move(0), move(-distance / 20), move(distance)]);
        kfs[1] = ad.offset(kfs[1], 0.2);
        return new KeyframeAnim(elem, kfs, duration);
    };
}
exports.slideInLeft = createSlideIn(ad.shiftLeft, ad.bounceLeft);
exports.slideInRight = createSlideIn(ad.shiftRight, ad.bounceRight);
exports.slideInTop = createSlideIn(ad.shiftUp, ad.bounceUp);
exports.slideInBottom = createSlideIn(ad.shiftDown, ad.bounceDown);
exports.slideOutLeft = createSlideOut(ad.shiftLeft);
exports.slideOutRight = createSlideOut(ad.shiftRight);
exports.slideOutTop = createSlideOut(ad.shiftUp);
exports.slideOutBottom = createSlideOut(ad.shiftDown);
function zoomIn(elem, duration = 1000) {
    let kfs = [ad.scaleXY(0), ad.scaleXY(1)].concat(ad.wobbleXY(2));
    kfs[1] = ad.offset(kfs[1], 0.5 + Math.min(duration / 10000, 0.5));
    return new KeyframeAnim(elem, kfs, duration);
}
exports.zoomIn = zoomIn;
function fadeIn(elem, duration = 1000) {
    return new KeyframeAnim(elem, [invisible(), visible()], duration);
}
exports.fadeIn = fadeIn;
function fadeOut(elem, duration = 1000) {
    return new KeyframeAnim(elem, [visible(), invisible()], duration);
}
exports.fadeOut = fadeOut;
function fadeInOut(elem, duration = 1000, iterations = 1) {
    return new KeyframeAnim(elem, [invisible(), visible()], duration, "auto", "alternate", iterations * 2);
}
exports.fadeInOut = fadeInOut;
function semiCirclePositions(count, radius) {
    let res = new Array(count);
    let angle = Math.PI / (count + 1);
    for (let i = 0; i < count; i++) {
        let x = -Math.cos((i + 1) * angle) * radius;
        let y = -Math.sin((i + 1) * angle) * radius;
        res[i] = [x, y];
    }
    return res;
}
function spreadAround(elems, radius, duration) {
    let pos = semiCirclePositions(elems.length, radius);
    return elems.map((e, i) => {
        let [x, y] = pos[i];
        return new KeyframeAnim(e, [ad.moveRelative(0, 0), ad.moveRelative(x, y)], duration);
    });
}
exports.spreadAround = spreadAround;
//# sourceMappingURL=keyframe-anim.js.map

/***/ }),

/***/ "./node_modules/taitto/lib/digraph.js":
/*!********************************************!*\
  !*** ./node_modules/taitto/lib/digraph.js ***!
  \********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.digraph = exports.edges = exports.nodes = exports.ArrowPos = void 0;
const svg = __importStar(__webpack_require__(/*! ./svg */ "./node_modules/taitto/lib/svg/index.js"));
const anim = __importStar(__webpack_require__(/*! ./anim */ "./node_modules/taitto/lib/anim/index.js"));
const dagre = __importStar(__webpack_require__(/*! dagre */ "./node_modules/dagre/index.js"));
var ArrowPos;
(function (ArrowPos) {
    ArrowPos[ArrowPos["Source"] = 0] = "Source";
    ArrowPos[ArrowPos["Destination"] = 1] = "Destination";
})(ArrowPos = exports.ArrowPos || (exports.ArrowPos = {}));
const defaultNodesep = 16;
const defaultRanksep = 16;
function nodes(...nodes) {
    return nodes.map(n => {
        return typeof (n) == 'string' ?
            { name: n, label: n } :
            { name: n[0], label: n[1] };
    });
}
exports.nodes = nodes;
function edges(edges, arrow) {
    return edges.map(e => {
        return e.length < 3 ?
            { arrow, source: e[0], destination: e[1] } :
            { arrow, source: e[0], destination: e[1], label: e[2] };
    });
}
exports.edges = edges;
function drawNode(node, parent, margin = 10) {
    let group = svg.group(parent);
    let p = node.link ? svg.link(group, node.link) : group;
    let text = svg.text(p, node.label);
    let bb = text.bbox.inflate(margin, margin);
    let shape = node.shape || svg.rect;
    shape(p, bb.left, bb.top, bb.width, bb.height).moveToBack();
    group.translate(svg.RectPos.Center);
    node.elem = group.addClass("node");
}
function drawEdgeLabel(edge, parent) {
    let text = svg.text(parent, edge.label);
    text.translate(svg.RectPos.Center);
    edge.elem = text.addClass("edgelabel");
}
function addArrow(arrow, svgroot, path) {
    if (!arrow.elem)
        arrow.elem = svg.arrow(svgroot.child('defs'), arrow.width, arrow.length, arrow.closed).addClass(arrow.className);
    if (arrow.positions.includes(ArrowPos.Source))
        svg.setMarker(path, arrow.elem, svg.MarkerPos.Start);
    if (arrow.positions.includes(ArrowPos.Destination))
        svg.setMarker(path, arrow.elem, svg.MarkerPos.End);
}
function dist(pt1, pt2) {
    let dx = pt1.x - pt2.x;
    let dy = pt1.y - pt2.y;
    return Math.sqrt(dx * dx + dy * dy);
}
function drawEdge(edge, svgroot, parent, arrow, curvedEdges, ranksep) {
    let p = edge.points;
    let cmds = [new svg.MoveTo('M', p[0].x, p[0].y)];
    let len = p.length;
    let i = 1;
    while (i < len)
        if (!curvedEdges ||
            (len <= 3 && (i == len - 1 || dist(p[i], p[i + 1]) < ranksep))) {
            cmds.push(new svg.LineTo('L', p[i].x, p[i].y));
            i++;
        }
        else if (i < len - 1) {
            cmds.push(new svg.ContCubicCurveTo('S', p[i].x, p[i].y, p[i + 1].x, p[i + 1].y));
            i += 2;
        }
        else {
            cmds.push(new svg.ContQuadCurveTo('T', p[i].x, p[i].y));
            i++;
        }
    let res = svg.path(parent, cmds).addClass("edge");
    if (arrow)
        addArrow(arrow, svgroot, res);
    return res.moveToBack();
}
function defineDigraph(digraph, svgroot, viewport, dg) {
    digraph.nodes.forEach(node => {
        drawNode(node, viewport, digraph.nodeMargin);
        let bbox = node.elem.bbox;
        dg.setNode(node.name, {
            label: node.label,
            width: bbox.width,
            height: bbox.height
        });
    });
    digraph.edges.forEach(edge => {
        if (edge.label) {
            drawEdgeLabel(edge, viewport);
            let { width, height } = edge.elem.bbox;
            dg.setEdge(edge.source.name, edge.destination.name, {
                label: edge.label,
                labelpos: digraph.edgeLabelPos || 'r',
                width, height
            });
        }
        else
            dg.setEdge(edge.source.name, edge.destination.name);
    });
}
function layoutDigraph(digraph, svgroot, viewport, dg) {
    digraph.nodes.forEach(node => {
        let dn = dg.node(node.name);
        let e = node.elem;
        e.transform = e.transform.translate(dn.x, dn.y);
    });
    digraph.edges.forEach(edge => {
        let de = dg.edge(edge.source.name, edge.destination.name);
        drawEdge(de, svgroot, viewport, edge.arrow, digraph.curvedEdges, digraph.ranksep || defaultRanksep);
        let e = edge.elem;
        if (e)
            e.transform = e.transform.translate(de.x, de.y);
    });
}
function createDigraph(digraph, parent) {
    let svgroot = svg.create('svg', parent).addClass("digraph")
        .styles({ cursor: "zoom-in" });
    svg.defs(svgroot);
    let graph = new dagre.graphlib.Graph();
    graph.setGraph({
        rankdir: digraph.direction || 'TB',
        nodesep: digraph.nodesep || defaultNodesep,
        ranksep: digraph.ranksep || defaultRanksep
    });
    graph.setDefaultEdgeLabel((v, w) => { return {}; });
    let viewport = anim.animatedView(svgroot).styles({ cursor: "zoom-in" });
    defineDigraph(digraph, svgroot, viewport, graph);
    dagre.layout(graph);
    layoutDigraph(digraph, svgroot, viewport, graph);
    svg.setBounds(svgroot, digraph.margin || 10);
    return svgroot.clicked(e => zoomInOut(svgroot, viewport, e));
}
let zoomed = false;
const zoomSpeed = 300;
function zoomInOut(svgroot, viewport, event) {
    let zoomAnim = null;
    if (!zoomed) {
        let s = svgroot.element;
        let pt = s.createSVGPoint();
        pt.x = event.clientX;
        pt.y = event.clientY;
        let { x, y } = pt.matrixTransform(s.getScreenCTM().inverse());
        zoomAnim = viewport.zoomFactor(2, x, y, zoomSpeed);
    }
    else
        zoomAnim = viewport.zoomHome(zoomSpeed);
    zoomed = !zoomed;
    svgroot.styles({ cursor: zoomed ? "zoom-out" : "zoom-in" });
    new anim.AnimSequence().addAt(zoomAnim, 0).play();
}
function digraph(dg, parent) {
    let svgroot = null;
    if (!document.fonts || document.fonts.status == "loaded")
        svgroot = createDigraph(dg, parent);
    else
        document.fonts.onloadingdone = () => {
            if (svgroot)
                svgroot.delete();
            svgroot = createDigraph(dg, parent);
        };
}
exports.digraph = digraph;
//# sourceMappingURL=digraph.js.map

/***/ }),

/***/ "./node_modules/taitto/lib/file-diagram.js":
/*!*************************************************!*\
  !*** ./node_modules/taitto/lib/file-diagram.js ***!
  \*************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.fileDiagram = exports.terminal = exports.file = exports.folder = exports.terminalDimensions = exports.fileDimensions = exports.folderDimensions = void 0;
const svg = __importStar(__webpack_require__(/*! ./svg */ "./node_modules/taitto/lib/svg/index.js"));
const anim = __importStar(__webpack_require__(/*! ./anim */ "./node_modules/taitto/lib/anim/index.js"));
exports.folderDimensions = {
    width: 80,
    height: 60,
    radius: 4
};
exports.fileDimensions = {
    width: 60,
    height: 80,
    radius: 4
};
exports.terminalDimensions = {
    width: 100,
    height: 80,
    radius: 4
};
function container3D(parent) {
    return svg.group(parent).addClass("container3D");
}
function iconRect(parent, dims) {
    let x = dims.width / 2;
    let y = dims.height / 2;
    return svg.rect(parent, -x, -y, dims.width, dims.height, dims.radius);
}
function folder(parent, caption, dims = exports.folderDimensions) {
    let res = container3D(parent);
    let back = svg.group(res).addClass("folder-back");
    iconRect(back, dims);
    let x = dims.width / 2;
    let y = dims.height / 2;
    let tw = 0.30 * dims.width;
    let th = 0.25 * dims.height;
    svg.rect(back, -x, -y - (th / 2), tw, th, dims.radius);
    let front = svg.group(res).addClass("folder-front")
        .styles({
        transformOrigin: `${x}px ${y}px`
    });
    iconRect(front, dims);
    svg.text(front, caption).translate(svg.RectPos.Center);
    let kfs = [
        { transform: 'rotateX(0deg)' },
        { transform: 'rotateX(30deg)' }
    ];
    res.open = new anim.KeyframeAnim(front, kfs, 200);
    res.close = new anim.KeyframeAnim(front, kfs.slice().reverse(), 200);
    return res;
}
exports.folder = folder;
function docLines(dims) {
    let w = dims.width - 20;
    let h = dims.height - 20;
    let res = [];
    for (let y = 0; y < h; y += 5) {
        if (Math.random() > 0.2) {
            res.push(new svg.MoveTo("M", 0, y));
            res.push(new svg.HLineTo("h", w - (Math.random() * 5)));
        }
    }
    return res;
}
function file(parent, typeStr, caption, dims = exports.fileDimensions) {
    let container = container3D(parent);
    let doc = svg.group(container).addClass("document");
    let mask = svg.mask(doc);
    iconRect(mask, dims).attrs({
        fill: "white",
        stroke: "white"
    });
    let mw = dims.width / 2;
    let mh = dims.height / 2;
    let fsize = mw / 2;
    svg.path(mask, `M0 -1 h${mw} v${mw} z`).attrs({
        transform: `translate(${fsize} ${-mh})`,
        fill: "black",
        stroke: "black"
    });
    let group = svg.group(doc).attrs({
        mask: `url(#${mask.id})`
    });
    iconRect(group, dims);
    svg.path(group, docLines(dims)).attrs({
        "stroke-width": 2
    })
        .translate(svg.RectPos.Center);
    svg.text(group, typeStr).addClass("doc-bg");
    svg.rect(group, fsize, -mh, fsize, fsize, dims.radius / 2);
    svg.text(doc, caption).addClass("doc-text")
        .translate(svg.RectPos.Center, [0, fsize]);
    return container;
}
exports.file = file;
function titleButton(parent, x, y, th) {
    let bd = th / 2;
    let br = th / 4;
    return svg.ellipse(parent, x - bd, -y + bd, br, br);
}
function terminal(parent, caption, dims = exports.terminalDimensions) {
    let container = container3D(parent);
    let term = svg.group(container).addClass("terminal");
    iconRect(term, dims);
    let x = dims.width / 2;
    let y = dims.height / 2;
    let th = dims.height / 8;
    svg.rect(term, -x, -y, dims.width, th, dims.radius / 2)
        .addClass("title-bar");
    let sp = th * 0.75;
    titleButton(term, x, y, th);
    titleButton(term, x - sp, y, th);
    titleButton(term, x - (sp * 2), y, th);
    caption = ">" + caption + "_";
    let text = svg.text(term, caption).addClass("terminal-text")
        .translate(svg.RectPos.Center);
    container.setCaption = value => Array.from({ length: value.length + 1 })
        .map((_, i) => anim.customAnim(text, a => a.target.text = ">" + value.slice(0, i) + "_", 0));
    return container;
}
exports.terminal = terminal;
function fileDiagram(parent, width, height) {
    let vb = new svg.Rect(0, 0, width, height);
    let res = svg.create('svg', parent).addClass("file-diagram").attrs({ width: vb.width, height: vb.height });
    svg.setViewBox(res, vb);
    return res;
}
exports.fileDiagram = fileDiagram;
//# sourceMappingURL=file-diagram.js.map

/***/ }),

/***/ "./node_modules/taitto/lib/index.js":
/*!******************************************!*\
  !*** ./node_modules/taitto/lib/index.js ***!
  \******************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.anim = exports.svg = void 0;
const svg = __importStar(__webpack_require__(/*! ./svg */ "./node_modules/taitto/lib/svg/index.js"));
exports.svg = svg;
const anim = __importStar(__webpack_require__(/*! ./anim */ "./node_modules/taitto/lib/anim/index.js"));
exports.anim = anim;
__exportStar(__webpack_require__(/*! ./digraph */ "./node_modules/taitto/lib/digraph.js"), exports);
__exportStar(__webpack_require__(/*! ./file-diagram */ "./node_modules/taitto/lib/file-diagram.js"), exports);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/taitto/lib/svg/elem.js":
/*!*********************************************!*\
  !*** ./node_modules/taitto/lib/svg/elem.js ***!
  \*********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.link = exports.mask = exports.polygon = exports.polyline = exports.path = exports.ellipse = exports.circle = exports.rect = exports.tspan = exports.text = exports.group = exports.css = exports.setViewBox = exports.getViewBox = exports.setBounds = exports.defs = exports.create = exports.GraphElem = exports.Elem = exports.xlink = exports.ns = void 0;
const rt = __importStar(__webpack_require__(/*! ./rect */ "./node_modules/taitto/lib/svg/rect.js"));
exports.ns = 'http://www.w3.org/2000/svg';
exports.xlink = 'http://www.w3.org/1999/xlink';
var lastGenId = 0;
class Elem {
    constructor(elem, parent) {
        this.elem = elem;
        parent.appendChild(this.elem);
    }
    get element() {
        return this.elem;
    }
    get id() {
        return this.elem.id;
    }
    set id(value) {
        this.elem.id = value;
    }
    get parent() {
        return this.elem.parentElement;
    }
    get classes() {
        return this.elem.classList;
    }
    get style() {
        return this.elem.style;
    }
    get text() {
        return this.elem.textContent;
    }
    set text(content) {
        this.elem.textContent = content;
    }
    addClass(name) {
        this.elem.classList.add(name);
        return this;
    }
    removeClass(name) {
        this.elem.classList.remove(name);
        return this;
    }
    toggleClass(name) {
        this.elem.classList.toggle(name);
        return this;
    }
    attr(name) {
        return this.elem.getAttribute(name);
    }
    attrs(obj, namespace = null) {
        for (const key in obj)
            if (obj.hasOwnProperty(key)) {
                let val = obj[key];
                if (val instanceof Array)
                    val = val.join(" ");
                this.elem.setAttributeNS(namespace, key, val);
            }
        return this;
    }
    child(tag) {
        let el = this.elem.querySelector(tag);
        return (el instanceof SVGGraphicsElement ? new GraphElem(el, this.elem) :
            el instanceof SVGElement ? new Elem(el, this.elem) :
                null);
    }
    styles(obj) {
        for (const key in obj)
            if (obj.hasOwnProperty(key))
                this.elem.style[key] = obj[key];
        return this;
    }
    delete() {
        this.elem.parentElement.removeChild(this.elem);
    }
    deleteChildren() {
        while (this.elem.firstChild)
            this.elem.removeChild(this.elem.firstChild);
    }
    moveUnder(parent) {
        parent.elem.appendChild(this.elem);
    }
    moveToBack() {
        let parent = this.elem.parentElement;
        parent.insertBefore(this.elem, parent.children[0]);
        return this;
    }
    moveToFront() {
        this.elem.parentElement.appendChild(this.elem);
        return this;
    }
}
exports.Elem = Elem;
class GraphElem extends Elem {
    get bbox() {
        return rt.Rect.fromDOMRect(this.elem.getBBox({ stroke: true }));
    }
    get transform() {
        return this.elem.getCTM();
    }
    set transform(mat) {
        let tr = this.elem.ownerSVGElement.createSVGTransformFromMatrix(mat);
        this.elem.transform.baseVal.initialize(tr);
    }
    hide() {
        this.styles({ opacity: '0' });
        return this;
    }
    show() {
        this.styles({ opacity: '1' });
        return this;
    }
    translate(pos, to = [0, 0]) {
        this.transform = this.bbox.translateTo(this.transform, pos, to);
        return this;
    }
    clicked(handler) {
        this.elem.onclick = handler;
        return this;
    }
    mouseover(handler) {
        this.elem.onmouseover = handler;
        return this;
    }
    mousemove(handler) {
        this.elem.onmousemove = handler;
        return this;
    }
}
exports.GraphElem = GraphElem;
function create(tag, parent) {
    let e = document.createElementNS(exports.ns, tag);
    let p = parent instanceof Elem ? parent.element : parent;
    return (e instanceof SVGGraphicsElement ?
        new GraphElem(e, p) : new Elem(e, p));
}
exports.create = create;
function defs(svgroot) {
    return create('defs', svgroot);
}
exports.defs = defs;
function setBounds(svgroot, hmargin, vmargin = hmargin) {
    let vb = svgroot.bbox.inflate(hmargin, vmargin);
    setViewBox(svgroot, vb);
    svgroot.attrs({ width: vb.width, height: vb.height });
}
exports.setBounds = setBounds;
function getViewBox(elem) {
    return rt.Rect.fromDOMRect(elem.element.viewBox.baseVal);
}
exports.getViewBox = getViewBox;
function setViewBox(elem, viewBox) {
    let { left, top, width, height } = viewBox;
    elem.attrs({ viewBox: `${left} ${top} ${width} ${height}` });
}
exports.setViewBox = setViewBox;
function css(parent) {
    return parent.child('style') || create('style', parent);
}
exports.css = css;
function group(parent) {
    return create('g', parent);
}
exports.group = group;
function text(parent, caption) {
    let res = create('text', parent);
    if (caption)
        res.text = caption;
    return res;
}
exports.text = text;
function tspan(parent, caption) {
    let res = create('tspan', parent);
    if (caption)
        res.text = caption;
    return res;
}
exports.tspan = tspan;
function rect(parent, x, y, width, height, rx = 0, ry = rx) {
    return create('rect', parent).attrs({ x, y, width, height, rx, ry });
}
exports.rect = rect;
function circle(parent, cx, cy, r) {
    return create('circle', parent).attrs({ cx, cy, r });
}
exports.circle = circle;
function ellipse(parent, cx, cy, rx, ry) {
    return create('ellipse', parent).attrs({ cx, cy, rx, ry });
}
exports.ellipse = ellipse;
function path(parent, commands) {
    return create('path', parent).attrs({
        d: typeof commands === 'string' ? commands : commands.join(' ')
    });
}
exports.path = path;
function polyline(parent, points) {
    return create('polyline', parent).attrs({ points: points.join(' ') });
}
exports.polyline = polyline;
function polygon(parent, points) {
    return create('polygon', parent).attrs({ points: points.join(' ') });
}
exports.polygon = polygon;
function mask(parent) {
    let res = create("mask", parent);
    res.id = "mask" + (++lastGenId);
    return res;
}
exports.mask = mask;
function link(parent, href) {
    return create('a', parent).attrs({ href }, exports.xlink);
}
exports.link = link;
//# sourceMappingURL=elem.js.map

/***/ }),

/***/ "./node_modules/taitto/lib/svg/filter.js":
/*!***********************************************!*\
  !*** ./node_modules/taitto/lib/svg/filter.js ***!
  \***********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.shadow = exports.setFilter = exports.filter = void 0;
const el = __importStar(__webpack_require__(/*! ./elem */ "./node_modules/taitto/lib/svg/elem.js"));
var lastId = 0;
function filter(parent, id) {
    return el.create('filter', parent).attrs({ id });
}
exports.filter = filter;
function setFilter(elem, filter) {
    elem.attrs({ filter: `url(#${typeof filter === 'string' ?
            filter : filter.id})` });
    return elem;
}
exports.setFilter = setFilter;
function shadow(parent, dx, dy = dx, stdDeviation = dx) {
    let res = filter(parent, "filter" + ++lastId);
    el.create('feOffset', res).attrs({
        result: 'offOut', in: 'sourceGraphic', dx: 4, dy: 4
    });
    el.create('feBlend', res).attrs({
        in: 'sourceGraphic', in2: 'offOut', mode: 'normal'
    });
    return res;
}
exports.shadow = shadow;
//# sourceMappingURL=filter.js.map

/***/ }),

/***/ "./node_modules/taitto/lib/svg/index.js":
/*!**********************************************!*\
  !*** ./node_modules/taitto/lib/svg/index.js ***!
  \**********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
__exportStar(__webpack_require__(/*! ./vector */ "./node_modules/taitto/lib/svg/vector.js"), exports);
__exportStar(__webpack_require__(/*! ./rect */ "./node_modules/taitto/lib/svg/rect.js"), exports);
__exportStar(__webpack_require__(/*! ./path */ "./node_modules/taitto/lib/svg/path.js"), exports);
__exportStar(__webpack_require__(/*! ./elem */ "./node_modules/taitto/lib/svg/elem.js"), exports);
__exportStar(__webpack_require__(/*! ./marker */ "./node_modules/taitto/lib/svg/marker.js"), exports);
__exportStar(__webpack_require__(/*! ./filter */ "./node_modules/taitto/lib/svg/filter.js"), exports);
__exportStar(__webpack_require__(/*! ./text */ "./node_modules/taitto/lib/svg/text.js"), exports);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/taitto/lib/svg/marker.js":
/*!***********************************************!*\
  !*** ./node_modules/taitto/lib/svg/marker.js ***!
  \***********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.arrow = exports.setMarker = exports.marker = exports.MarkerPos = void 0;
const el = __importStar(__webpack_require__(/*! ./elem */ "./node_modules/taitto/lib/svg/elem.js"));
var MarkerPos;
(function (MarkerPos) {
    MarkerPos[MarkerPos["Start"] = 0] = "Start";
    MarkerPos[MarkerPos["Mid"] = 1] = "Mid";
    MarkerPos[MarkerPos["End"] = 2] = "End";
})(MarkerPos = exports.MarkerPos || (exports.MarkerPos = {}));
var lastId = 0;
function marker(parent, id) {
    return el.create('marker', parent).attrs({ id });
}
exports.marker = marker;
function setMarker(elem, marker, pos) {
    let markerUrl = `url(#${typeof marker === 'string' ? marker : marker.id})`;
    switch (pos) {
        case MarkerPos.Start:
            return elem.attrs({ "marker-start": markerUrl });
        case MarkerPos.Mid:
            return elem.attrs({ "marker-mid": markerUrl });
        case MarkerPos.End:
            return elem.attrs({ "marker-end": markerUrl });
    }
    return elem;
}
exports.setMarker = setMarker;
function arrow(parent, width, length = width, closed = true) {
    let res = marker(parent, "arrow" + ++lastId).attrs({
        viewBox: "-1 -1 12 12",
        refX: 10, refY: 5,
        orient: "auto-start-reverse",
        markerWidth: length, markerHeight: width,
        preserveAspectRatio: "none"
    });
    el.path(res, "M 0 0 L 10 5 L 0 10" + (closed ? " z" : ""));
    return res;
}
exports.arrow = arrow;
//# sourceMappingURL=marker.js.map

/***/ }),

/***/ "./node_modules/taitto/lib/svg/path.js":
/*!*********************************************!*\
  !*** ./node_modules/taitto/lib/svg/path.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ClosePath = exports.ArcTo = exports.Sweep = exports.Arc = exports.ContQuadCurveTo = exports.QuadCurveTo = exports.ContCubicCurveTo = exports.CubicCurveTo = exports.VLineTo = exports.HLineTo = exports.LineTo = exports.MoveTo = void 0;
class MoveTo {
    constructor(command, x, y) {
        this.command = command;
        this.x = x;
        this.y = y;
        this.toString = () => `${this.command}${this.x} ${this.y}`;
    }
}
exports.MoveTo = MoveTo;
class LineTo {
    constructor(command, x, y) {
        this.command = command;
        this.x = x;
        this.y = y;
        this.toString = () => `${this.command}${this.x} ${this.y}`;
    }
}
exports.LineTo = LineTo;
class HLineTo {
    constructor(command, x) {
        this.command = command;
        this.x = x;
        this.toString = () => `${this.command}${this.x}`;
    }
}
exports.HLineTo = HLineTo;
class VLineTo {
    constructor(command, y) {
        this.command = command;
        this.y = y;
        this.toString = () => `${this.command}${this.y}`;
    }
}
exports.VLineTo = VLineTo;
class CubicCurveTo {
    constructor(command, x1, y1, x2, y2, x, y) {
        this.command = command;
        this.x1 = x1;
        this.y1 = y1;
        this.x2 = x2;
        this.y2 = y2;
        this.x = x;
        this.y = y;
        this.toString = () => `${this.command}${this.x1} ${this.y1} ${this.x2} ${this.y2} ${this.x} ${this.y}`;
    }
}
exports.CubicCurveTo = CubicCurveTo;
class ContCubicCurveTo {
    constructor(command, x2, y2, x, y) {
        this.command = command;
        this.x2 = x2;
        this.y2 = y2;
        this.x = x;
        this.y = y;
        this.toString = () => `${this.command}${this.x2} ${this.y2} ${this.x} ${this.y}`;
    }
}
exports.ContCubicCurveTo = ContCubicCurveTo;
class QuadCurveTo {
    constructor(command, x1, y1, x, y) {
        this.command = command;
        this.x1 = x1;
        this.y1 = y1;
        this.x = x;
        this.y = y;
        this.toString = () => `${this.command}${this.x1} ${this.y1} ${this.x} ${this.y}`;
    }
}
exports.QuadCurveTo = QuadCurveTo;
class ContQuadCurveTo {
    constructor(command, x, y) {
        this.command = command;
        this.x = x;
        this.y = y;
        this.toString = () => `${this.command}${this.x} ${this.y}`;
    }
}
exports.ContQuadCurveTo = ContQuadCurveTo;
var Arc;
(function (Arc) {
    Arc[Arc["Small"] = 0] = "Small";
    Arc[Arc["Large"] = 1] = "Large";
})(Arc = exports.Arc || (exports.Arc = {}));
var Sweep;
(function (Sweep) {
    Sweep[Sweep["CW"] = 0] = "CW";
    Sweep[Sweep["CCW"] = 1] = "CCW";
})(Sweep = exports.Sweep || (exports.Sweep = {}));
class ArcTo {
    constructor(command, rx, ry, rot, arc, sweep, x, y) {
        this.command = command;
        this.rx = rx;
        this.ry = ry;
        this.rot = rot;
        this.arc = arc;
        this.sweep = sweep;
        this.x = x;
        this.y = y;
        this.toString = () => `${this.command}${this.rx} ${this.ry} ${this.rot} ${this.arc} ${this.sweep} ${this.x} ${this.y}`;
    }
}
exports.ArcTo = ArcTo;
class ClosePath {
    constructor() {
        this.toString = () => this.command;
    }
}
exports.ClosePath = ClosePath;
//# sourceMappingURL=path.js.map

/***/ }),

/***/ "./node_modules/taitto/lib/svg/rect.js":
/*!*********************************************!*\
  !*** ./node_modules/taitto/lib/svg/rect.js ***!
  \*********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Rect = exports.RectPos = void 0;
const vec = __importStar(__webpack_require__(/*! ./vector */ "./node_modules/taitto/lib/svg/vector.js"));
var RectPos;
(function (RectPos) {
    RectPos[RectPos["Center"] = 0] = "Center";
    RectPos[RectPos["TopLeft"] = 1] = "TopLeft";
    RectPos[RectPos["TopRight"] = 2] = "TopRight";
    RectPos[RectPos["BottomLeft"] = 3] = "BottomLeft";
    RectPos[RectPos["BottomRight"] = 4] = "BottomRight";
})(RectPos = exports.RectPos || (exports.RectPos = {}));
/**
 * Defines a rectangle which covers area [left, right) along x-axis
 * and [top, bottom) along y-axis.
 */
class Rect {
    constructor(left, top, right, bottom) {
        this.left = left;
        this.top = top;
        this.right = right;
        this.bottom = bottom;
    }
    get width() {
        return this.right - this.left;
    }
    get height() {
        return this.bottom - this.top;
    }
    get centerX() {
        return this.left + (this.width / 2);
    }
    get centerY() {
        return this.top + (this.height / 2);
    }
    get isEmpty() {
        return this.width <= 0 || this.height <= 0;
    }
    containsPoint(x, y) {
        return x >= this.left && x < this.right &&
            y >= this.top && y < this.bottom;
    }
    rectPos(pos) {
        switch (pos) {
            case RectPos.Center: return [this.centerX, this.centerY];
            case RectPos.TopLeft: return [this.left, this.top];
            case RectPos.TopRight: return [this.right, this.top];
            case RectPos.BottomLeft: return [this.left, this.bottom];
            case RectPos.BottomRight: return [this.right, this.bottom];
        }
    }
    cornerPoints(closeLoop = false) {
        let res = [
            this.rectPos(RectPos.TopLeft),
            this.rectPos(RectPos.TopRight),
            this.rectPos(RectPos.BottomRight),
            this.rectPos(RectPos.BottomLeft)
        ];
        if (closeLoop)
            res.push(res[0]);
        return res;
    }
    containsRect(other) {
        return other.left >= this.left && other.right <= this.right &&
            other.top >= this.top && other.bottom <= this.bottom;
    }
    equals(other) {
        return this.left == other.left && this.top == other.top &&
            this.width == other.width && this.height == other.height;
    }
    inflate(dx, dy) {
        return new Rect(this.left - dx, this.top - dy, this.right + dx, this.bottom + dy);
    }
    intersect(other) {
        return new Rect(Math.max(this.left, other.left), Math.max(this.top, other.top), Math.min(this.right, other.right), Math.min(this.bottom, other.bottom));
    }
    intersectsWith(other) {
        return !this.intersect(other).isEmpty;
    }
    offset(dx, dy) {
        return new Rect(this.left + dx, this.top + dy, this.right + dx, this.bottom + dy);
    }
    translateTo(mat, pos, to = [0, 0]) {
        let [sx, sy] = pos instanceof Array ? pos : this.rectPos(pos);
        let [tx, ty] = to;
        return mat.translate(tx - sx, ty - sy);
    }
    transform(mat) {
        return Rect.fromPoints(this.cornerPoints().map(pt => {
            let [x, y] = pt;
            let tp = mat.transformPoint({ x, y });
            return [tp.x, tp.y];
        }));
    }
    union(other) {
        return new Rect(Math.min(this.left, other.left), Math.min(this.top, other.top), Math.max(this.right, other.right), Math.max(this.bottom, other.bottom));
    }
    static fromDOMRect(domRect) {
        return new Rect(domRect.x, domRect.y, domRect.x + domRect.width, domRect.y + domRect.height);
    }
    static fromPoints(points) {
        return new Rect(Math.min(...points.map(vec.vecX)), Math.min(...points.map(vec.vecY)), Math.max(...points.map(vec.vecX)), Math.max(...points.map(vec.vecY)));
    }
    static fromRects(rects) {
        return rects.reduce((r, c) => c.union(r));
    }
    static fromString(value) {
        let [left, top, width, height] = value.split(" ").map(Number);
        return new Rect(left, top, left + width, top + height);
    }
}
exports.Rect = Rect;
//# sourceMappingURL=rect.js.map

/***/ }),

/***/ "./node_modules/taitto/lib/svg/text.js":
/*!*********************************************!*\
  !*** ./node_modules/taitto/lib/svg/text.js ***!
  \*********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.changeWordWrapText = exports.wordWrapText = void 0;
const el = __importStar(__webpack_require__(/*! ./elem */ "./node_modules/taitto/lib/svg/elem.js"));
function wordWrapText(parent, x, y, wrapAfter, caption) {
    let text = el.text(parent).attrs({ x, y, "data-wrapAfter": wrapAfter });
    changeWordWrapText(text, caption);
    return text;
}
exports.wordWrapText = wordWrapText;
function changeWordWrapText(text, caption, x, wrapAfter) {
    text.deleteChildren();
    let words = caption.split(" ");
    if (x)
        text.attrs({ x });
    else
        x = Number(text.attr("x"));
    if (wrapAfter)
        text.attrs({ "data-wrapAfter": wrapAfter });
    else
        wrapAfter = Number(text.attr("data-wrapAfter") || 100);
    let i = 0;
    let bb = null;
    while (i < words.length) {
        let ts = el.tspan(text, words[i]);
        let w = ts.element.getComputedTextLength();
        while (++i < words.length && w < wrapAfter) {
            ts.text = ts.text + " " + words[i];
            w = ts.element.getComputedTextLength();
        }
        if (!bb)
            bb = text.bbox;
        else
            ts.attrs({ x, dy: bb.height });
    }
}
exports.changeWordWrapText = changeWordWrapText;
//# sourceMappingURL=text.js.map

/***/ }),

/***/ "./node_modules/taitto/lib/svg/vector.js":
/*!***********************************************!*\
  !*** ./node_modules/taitto/lib/svg/vector.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.divVec = exports.mulVec = exports.subVec = exports.addVec = exports.vecY = exports.vecX = exports.oneVector = exports.zeroVector = void 0;
exports.zeroVector = [0, 0];
exports.oneVector = [1, 1];
function vecX(vec) {
    return vec[0];
}
exports.vecX = vecX;
function vecY(vec) {
    return vec[1];
}
exports.vecY = vecY;
function addVec(vec1, vec2) {
    return vec1.map((a, i) => a + vec2[i]);
}
exports.addVec = addVec;
function subVec(vec1, vec2) {
    return vec1.map((a, i) => a - vec2[i]);
}
exports.subVec = subVec;
function mulVec(vec1, vec2) {
    return vec1.map((a, i) => a * vec2[i]);
}
exports.mulVec = mulVec;
function divVec(vec1, vec2) {
    return vec1.map((a, i) => a / vec2[i]);
}
exports.divVec = divVec;
//# sourceMappingURL=vector.js.map

/***/ }),

/***/ "./src/arrayparsers.ts":
/*!*****************************!*\
  !*** ./src/arrayparsers.ts ***!
  \*****************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.operators = void 0;
/**
 * # Combinators for Parsing Arrays and Expressions
 *
 * This module contains additional combinators that are useful when parsing
 * sequences or expressions. They are adapted from the original
 * [Parsec](http://hackage.haskell.org/package/parsec-3.1.13.0/docs/Text-Parsec-Combinator.html)
 * library.
 */
const par = __webpack_require__(/*! ./parser */ "./src/parser.ts");
/**
 * ## Parsing Separated Lists
 *
 * Parse an array containing at least one element. The items of the array are
 * recognized by `parser`. The items are separated by input recognized by
 * `separator`. The function returns an array of parsed elements.
 */
par.Parser.prototype.oneOrMoreSeparatedBy = function (separator) {
    return this.bind(x => separator.seq(this).zeroOrMore().bind(xs => par.mret([x].concat(xs))));
};
/**
 * Parse a potentially empty array. The items of the array are recognized by
 * `parser`. The items are separated by input recognized by `separator`.
 */
par.Parser.prototype.zeroOrMoreSeparatedBy = function (separator) {
    return this.oneOrMoreSeparatedBy(separator).or(par.mret([]));
};
/**
 * ## Terminators & Brackets
 *
 * Parse item(s) followed by a terminator given in the `after` parser. The
 * result of `parser` is returned, and result of `after` is ignored.
 */
par.Parser.prototype.followedBy = function (after) {
    return this.bind(p => after.bind(_ => par.mret(p)));
};
/**
 * Parse item(s) surrounded by input recognized by the `surround` parser. The
 * result of `parser` is returned.
 */
par.Parser.prototype.surroundedBy = function (surround) {
    return surround.bind(o => this.bind(p => surround.bind(c => par.mret(p))));
};
/**
 * Parse item(s) surrounded by an open and closing bracket. The result `parser`
 * is returned.
 */
par.Parser.prototype.bracketedBy = function (open, close) {
    return open.bind(o => this.bind(p => close.bind(c => par.mret(p))));
};
/**
 * ## Parsing Expressions
 *
 * Parse one or more occurrences of `parser`, separated by `operation`.
 * Return a value obtained by a left associative application of all functions
 * returned by `operation` to the values returned by `parser`. This parser can
 * for example be used to eliminate left recursion which typically occurs in
 * expression grammars.
 */
par.Parser.prototype.chainOneOrMore = function (operation) {
    return this.bind(x => operation.bind(f => this.bind(y => par.mret([f, y]))).zeroOrMore().bind(fys => par.mret(fys.reduce((z, [f, y]) => f(z, y), x))));
};
/**
 * Parse zero or more occurrences of `parser`, separated by `operation`.
 * Return a value obtained by a left associative application of all functions
 * returned by `operation` to the values returned by `parser`. If there are
 * zero occurrences of `parser`, the `value` is returned.
 */
par.Parser.prototype.chainZeroOrMore = function (operation, value) {
    return this.chainOneOrMore(operation).or(par.mret(value));
};
/**
 * Construct a parser for operator selection. Used typically in conjunction
 * with `chain*` functions.
 */
function operators(...ops) {
    return par.any(...ops.map(([p, o]) => p.map(_ => o)));
}
exports.operators = operators;


/***/ }),

/***/ "./src/error.ts":
/*!**********************!*\
  !*** ./src/error.ts ***!
  \**********************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ParseError = exports.ErrorSource = void 0;
/**
 * # Error Reporting
 *
 * We define a custom Error class for parsing errors.
 *
 * The possible sources of errors are defined in the enumeration below.
 */
var ErrorSource;
(function (ErrorSource) {
    ErrorSource["Input"] = "Input";
    ErrorSource["Lexer"] = "Lexer";
    ErrorSource["Parser"] = "Parsing";
})(ErrorSource = exports.ErrorSource || (exports.ErrorSource = {}));
/**
 * The ParseError class contains information about the parsing error in
 * an easily accessible form.
 */
class ParseError extends Error {
    constructor(
    /**
     * The source of the error.
     */
    source, 
    /**
     * The position where the error happened.
     */
    position, 
    /**
     * Input found at `position`.
     */
    found, 
    /**
     * Input expected at `position`. There can be multiple terminals.
     */
    expected = []) {
        /**
         * Constructor formats the error message using the parameters provided.
         */
        super(`${source} error at position ${position + 1}.\n` +
            `\tFound: "${found}"\n` +
            `\tExpected: ${expected.map(s => `"${s}"`).join(", ")}`);
        this.source = source;
        this.position = position;
        this.found = found;
        this.expected = expected;
    }
}
exports.ParseError = ParseError;


/***/ }),

/***/ "./src/index.ts":
/*!**********************!*\
  !*** ./src/index.ts ***!
  \**********************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
/**
 * ---
 * {
 *  "visualizers": [
 *      {
 *          "path": "./src/visualizers/dependency-diag.ts",
 *          "includeStyles": true
 *      }
 *  ]
 * }
 * ---
 * # Library Structure
 *
 * Below is the dependency graph showing the module hierarchy. Note that it
 * shows also the testing modules which are not included in the published
 * package. You can jump to a module by clicking it in the diagram.
 *
 * <<v:dependency-diag ../dependencies.json src\/(?!extras)>>
 *
 * ## Exports
 *
 * Parzec library consists of following modules. All of them are exported
 * outside the library.
 */
__exportStar(__webpack_require__(/*! ./ref */ "./src/ref.ts"), exports);
__exportStar(__webpack_require__(/*! ./error */ "./src/error.ts"), exports);
__exportStar(__webpack_require__(/*! ./input */ "./src/input.ts"), exports);
__exportStar(__webpack_require__(/*! ./result */ "./src/result.ts"), exports);
__exportStar(__webpack_require__(/*! ./error */ "./src/error.ts"), exports);
__exportStar(__webpack_require__(/*! ./lexer */ "./src/lexer.ts"), exports);
__exportStar(__webpack_require__(/*! ./parser */ "./src/parser.ts"), exports);
__exportStar(__webpack_require__(/*! ./arrayparsers */ "./src/arrayparsers.ts"), exports);
__exportStar(__webpack_require__(/*! ./utils */ "./src/utils.ts"), exports);


/***/ }),

/***/ "./src/input.ts":
/*!**********************!*\
  !*** ./src/input.ts ***!
  \**********************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.arrayInput = void 0;
/**
 * ## Array Input
 *
 * Arrays are the most common input data type. Therefore we provide a generic
 * implementation for them. Array items may have any type `S`. The class is
 * not exported outside the module. Users can create it using the `arrayInput`
 * function.
 */
class ArrayInput {
    /**
     * We set the position initially to -1 to indicate that no input has been
     * consumed. The current item is `undefined`.
     */
    constructor(array, eof) {
        this.array = array;
        this.position = -1;
        this.current = undefined;
        this.eof = eof;
    }
    /**
     * Return the next item in the array. Update `position` and
     * `current` fields.
     */
    next() {
        let pos = this.position + 1;
        if (pos >= this.array.length)
            return this.eof;
        this.position = pos;
        this.current = this.array[pos];
        return this.current;
    }
}
/**
 * ## Exported Functions
 *
 * Create a ParserInput wrapper for an array.
 */
function arrayInput(array, eof) {
    return new ArrayInput(array, eof);
}
exports.arrayInput = arrayInput;


/***/ }),

/***/ "./src/lexer.ts":
/*!**********************!*\
  !*** ./src/lexer.ts ***!
  \**********************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.lexerInput = exports.Lexer = exports.Token = void 0;
const utils = __webpack_require__(/*! ./utils */ "./src/utils.ts");
const err = __webpack_require__(/*! ./error */ "./src/error.ts");
/**
 * ## Representing a Token
 *
 * When a token is recognized it is wrapped in a `Token<S>` object. This
 * contains also the recognized string for error reporting and diagnostics.
 */
class Token {
    constructor(token, text) {
        this.token = token;
        this.text = text;
    }
    /**
     * We override the `toString` function so we can output a token
     * to screen.
     */
    toString() {
        return this.text ? utils.escapeWhitespace(this.text) : this.token;
    }
}
exports.Token = Token;
/**
 * ## Lexer
 *
 * The lexer itself is a simple class that contains all the TokenMatchers and
 * recognizes the next token in a string.
 */
class Lexer {
    /**
     * The constructor adds two flags to the regular expressions given as
     * arguments. The `y` flag makes the search sticky so that it scans the
     * input string from the position indicated by the `lastIndex` property.
     * The `u` flag makes the search support unicode characters.
     */
    constructor(...tokens) {
        this.matchers = tokens.map(t => ({
            regex: new RegExp(t[0], "yu"),
            token: t[1]
        }));
    }
    /**
     * We check matchers one-by-one in the order they were given to
     * recognize the token in the given position. If none of the matchers
     * succeed, we return `null`.
     */
    matchToken(input, pos) {
        for (let i = 0; i < this.matchers.length; i++) {
            let matcher = this.matchers[i];
            matcher.regex.lastIndex = pos;
            let match = matcher.regex.exec(input);
            if (match != null)
                return new Token(matcher.token, match[0]);
        }
        return null;
    }
}
exports.Lexer = Lexer;
/**
 * ## Lexer as Input
 *
 * We can integrate lexing directly into the parsing process by implementing
 * the `ParserInput` interface for any token. We don't expose `LexerInput`
 * class outside the module. It can be created with the `lexerInput` function.
 */
class LexerInput {
    /**
     * Create an input stream for given string and lexer. Initialize the
     * instance variables.
     */
    constructor(input, lexer, eof) {
        this.input = input;
        this.lexer = lexer;
        this.tokens = new Array(input.length);
        this.position = -1;
        this.eof = eof;
        this.current = this.eof;
    }
    /**
     * The iterator implementation is fairly straightforward. We need to make
     * sure that the state variables `position` and `current` are kept in sync
     * while we advance in the input string. We must also do a lookup in the
     * cach before calling the lexer to recognize the token. If the lexer finds
     * a match, we update the cach. If the lexer cannot recognize the next
     * token, we throw a `ParseError`.
     */
    next() {
        let pos = this.position;
        pos += this.tokens[pos] ? this.tokens[pos].text.length : 1;
        if (pos >= this.input.length)
            return this.eof;
        this.position = pos;
        let match = this.tokens[pos] || this.lexer.matchToken(this.input, pos);
        if (!match)
            throw new err.ParseError(err.ErrorSource.Lexer, pos, this.input.substr(pos, 10) + "...", ["<valid token>"]);
        this.tokens[pos] = match;
        this.current = match;
        return match;
    }
}
/**
 * Create an input stream for given `text` string using the given `lexer`.
 */
function lexerInput(text, lexer, eof) {
    return new LexerInput(text, lexer, eof);
}
exports.lexerInput = lexerInput;


/***/ }),

/***/ "./src/parser.ts":
/*!***********************!*\
  !*** ./src/parser.ts ***!
  \***********************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.terminal = exports.token = exports.is = exports.anything = exports.forwardRef = exports.cleanupState = exports.checkState = exports.mutateState = exports.setState = exports.getState = exports.position = exports.choose = exports.peek = exports.any = exports.notSatisfy = exports.satisfy = exports.fail = exports.mret = exports.parse = exports.tryParse = exports.parserDebug = exports.Parser = void 0;
const pr = __webpack_require__(/*! ./result */ "./src/result.ts");
const utils = __webpack_require__(/*! ./utils */ "./src/utils.ts");
const err = __webpack_require__(/*! ./error */ "./src/error.ts");
/**
 * ## Parser Class
 *
 * The central type in the Parzec library is the `Parser<T, S>` class. It wraps
 * a parsing function and provides the core combinators to combine parsers in
 * various ways.
 */
class Parser {
    /**
     * Constructor wraps the parsing function.
     */
    constructor(parse) {
        this.parse = parse;
    }
    /**
     * The monadic bind that corresponds to Haskell's `>>=` operator. Runs
     * `this` parser, and if it succeeds, feeds its result to the `binder`
     * function that returns a new Parser. This is the basic operation that is
     * used in other combinators to glue parsers together.
     */
    bind(binder) {
        return new Parser(input => {
            let pos = input.position;
            let res1 = this.parse(input);
            if (res1.kind == "ok") {
                let res2 = binder(res1.result).parse(input);
                if (res2.kind == "fail" && pos !== input.position)
                    input.position = pos; // backtrack
                return res2;
            }
            return res1;
        });
    }
    /**
     * The sequence operator. Runs `this` parser, and if it succeeds, runs the
     * `other` parser ignoring the result of `this` one.
     */
    seq(other) {
        return this.bind(_ => other);
    }
    /**
     * Map result of the parser to another value. This function implements a
     * [_functor_](https://en.wikipedia.org/wiki/Functor) which is a superclass
     * of monad.
     */
    map(mapper) {
        return this.bind(x => mret(mapper(x)));
    }
    /**
     * ## Conditional Parsing
     *
     * The ordered choice operation. Creates a parser that first runs `this`
     * parser, and if that fails, runs the `other` one. Corresponds to the `/`
     * operation in [PEG grammars](https://en.wikipedia.org/wiki/Parsing_expression_grammar).
     */
    or(other) {
        return new Parser(input => {
            let pos = input.position;
            let res1 = this.parse(input);
            if (res1.kind == "ok")
                return res1;
            if (res1.position > pos)
                return res1;
            let res2 = other.parse(input);
            if (res2.kind == "ok")
                return res2;
            pr.joinExpected(res2, res1);
            return res2;
        });
    }
    /**
     * Parse an optional value, if the parser fails then the default value is
     * returned.
     */
    optional(defaultValue) {
        return this.or(mret(defaultValue));
    }
    /**
     * Parse an optional reference value, if the parser fails then null is
     * returned.
     */
    optionalRef() {
        return this.or(mret(null));
    }
    /**
     * Runs parser and checks that it succeeds and that the result it returns
     * satisfies a given predicate.
     */
    where(predicate) {
        return this.bind(x => predicate(x) ? mret(x) : fail(`${x}`, "predicate"));
    }
    /**
     * ## Parsing Multiple Items
     *
     * Creates a parser that will run `this` parser zero or more times. The
     * results of the input parser are added to an array.
     */
    zeroOrMore() {
        return new Parser(input => {
            let list = [];
            while (true) {
                let pos = input.position;
                let res = this.parse(input);
                if (res.kind == "fail")
                    return res.position > pos ?
                        res : pr.succeeded(res.position, list);
                list.push(res.result);
            }
        });
    }
    /**
     * Creates a parser that runs `this` parser one or more times.
     */
    oneOrMore() {
        return new Parser(input => {
            let res = this.parse(input);
            if (res.kind == "fail")
                return res;
            let list = [res.result];
            while (true) {
                let pos = input.position;
                res = this.parse(input);
                if (res.kind == "fail")
                    return res.position > pos ?
                        res : pr.succeeded(res.position, list);
                list.push(res.result);
            }
        });
    }
    /**
     * Parsing succeeds if `this` parser succeeds from `min` to `max` times.
     */
    occurrences(min, max) {
        return this.zeroOrMore().bind(list => {
            let cnt = list.length;
            return cnt >= min && cnt <= max ?
                mret(list) :
                fail(`${cnt} occurrences`, `${min}-${max} occurrences`);
        });
    }
    /**
     * ## Lookahead & Backtracking
     *
     * Check that `this` parser succeeds without consuming any input.
     * Corresponds to the `&` operator in PEG grammars.
     */
    and() {
        return new Parser(input => {
            let pos = input.position;
            let res = this.parse(input);
            input.position = pos;
            return res;
        });
    }
    /**
     * Check that `this` parser fails without consuming any input. Corresponds
     * to the `!` operator in PEG grammars.
     */
    not() {
        return new Parser(input => {
            let pos = input.position;
            let res = this.parse(input);
            input.position = pos;
            if (res.kind == "ok") {
                let found = `${res.result}`;
                return pr.failed(res.position, found, ["not " + found]);
            }
            return pr.succeeded(res.position, undefined);
        });
    }
    /**
     * Bactrack to the current input position, even if the given parser fails
     * and has advanced the input position. Normally we do not bactrack when a
     * parser has advanced in the input. Doing so would loose the position where
     * the parsing failed and make error messages more vague. Sometimes,
     * however, we need more input lookahead. In these cases, you can use the
     * backtrack operation to retry the next rule.
     */
    backtrack() {
        return new Parser(input => {
            let pos = input.position;
            let res = this.parse(input);
            if (res.kind == "fail" && res.position > pos)
                res.position = pos;
            return res;
        });
    }
    /**
     * ## Error Reporting and Debugging
     *
     * Give a human-readable name to the "thing" that the given parser matches.
     * This name is reported as expected value, if the parsing fails.
     */
    expect(expected) {
        if (!exports.parserDebug.errorMessages)
            return this;
        let resParser = new Parser((input) => {
            let res = this.parse(input);
            if (res.kind == "fail")
                res.expected.push(expected);
            return res;
        });
        return exports.parserDebug.debugging ? resParser.trace(expected) : resParser;
    }
    /**
     * Attach debugging information to a parser. To trace which rules are
     * triggered during parsing, you can add debugging info to any parser. This
     * combinator produces a hierarchical tree of parser invocations which
     * includes information about input symbol and its position. If debugging
     * is disabled, this function does nothing.
     */
    trace(ruleName) {
        if (!exports.parserDebug.debugging)
            return this;
        return new Parser(input => {
            exports.parserDebug.write(`${ruleName} called with input '${input.current}'.`);
            exports.parserDebug.indent();
            let res = this.parse(input);
            exports.parserDebug.rulesEvaluated++;
            exports.parserDebug.unindent();
            exports.parserDebug.write((res.kind == "ok" ?
                `${ruleName} SUCCEEDED with value '${utils.escapeWhitespace(`${res.result}`)}'` :
                `${ruleName} FAILED with value '${utils.escapeWhitespace(`${res.found}`)}'. Expected values: ${pr.expectedAsCsv(res)}`) +
                ` at position ${res.position}`);
            return res;
        });
    }
}
exports.Parser = Parser;
/**
 * ## Debugging Options
 *
 * The following object contains the global settings that control the parser
 * reporting.
 */
exports.parserDebug = {
    /**
     * When `debugging` flag is on parsers count the number of rules evaluated
     * during their operation. The `rulesEvaluated` field contains this
     * information.
     */
    debugging: false,
    rulesEvaluated: 0,
    /**
     * If errorMessages flag is turned off, the expected information will not be
     * available in parse errors. This speeds up the parsing nominally.
     */
    errorMessages: true,
    /**
     * The current indentation level in the debugging output is stored in this
     * field.
     */
    indentation: 0,
    /**
     * Indent the debug output by one level.
     */
    indent() {
        this.indentation++;
    },
    /**
     * Unndent the debug output by one level.
     */
    unindent() {
        this.indentation--;
    },
    /**
     * Write a string to the debug output.
     */
    write(text) {
        let tabs = "  ".repeat(this.indentation);
        console.log(tabs + text);
    }
};
/**
 * ## Main Functions
 *
 * Attempt to parse an input with a given parser. Takes a Parser and a
 * ParserInput as arguments and return a ParseResult.
 */
function tryParse(parser, input) {
    exports.parserDebug.rulesEvaluated = 0;
    let res = parser.parse(input);
    if (exports.parserDebug.debugging)
        console.info("Number of rules evaluated: " + exports.parserDebug.rulesEvaluated);
    return res;
}
exports.tryParse = tryParse;
/**
 * Parse an input using a given parser, or throw an exception, if parsing fails.
 */
function parse(parser, input) {
    var res = tryParse(parser, input);
    if (res.kind == "fail")
        throw new err.ParseError(err.ErrorSource.Parser, res.position, res.found, res.expected);
    return res.result;
}
exports.parse = parse;
/**
 * ## Monadic Returns
 *
 * Create a parser that always succeeds and returns the given value without
 * consuming any input. This function implements the monadic return, that is,
 * it lifts a value to the parser monad.
 */
function mret(value) {
    return new Parser(input => pr.succeeded(input.position, value));
}
exports.mret = mret;
/**
 * Create a parser that always fails. The terminals reported as
 * found or expected are given as an argument.
 */
function fail(found, ...expected) {
    return new Parser(input => pr.failed(input.position, found, expected));
}
exports.fail = fail;
/**
 * ## Parsing Terminals
 *
 * Creates a parser that reads one terminal from the input and returns it, if it
 * satisfies the given predicate; otherwise the parser fails.
 */
function satisfy(predicate) {
    return new Parser(input => {
        let pos = input.position;
        let item = input.next();
        if (predicate(item))
            return pr.succeeded(input.position, item);
        input.position = pos;
        return pr.failed(input.position, `${item}`);
    });
}
exports.satisfy = satisfy;
/**
 * Creates a parser that reads one terminal from the input and returns it, if it
 * does **not** satisfy a given predicate.
 */
function notSatisfy(predicate) {
    return satisfy(x => !predicate(x));
}
exports.notSatisfy = notSatisfy;
/**
 * Any of the given parsers must succeed. The operation is the same
 * as the `or` combinator generalized to arbitrary number of choices.
 */
function any(...parsers) {
    if (parsers.length == 0)
        throw Error("At least one parser must be given.");
    return new Parser(input => {
        let res = null;
        let i = 0;
        let pos = input.position;
        do {
            let r = parsers[i++].parse(input);
            if (r.kind == "ok")
                return r;
            if (r.position > pos)
                return r;
            if (res == null)
                res = r;
            else
                pr.joinExpected(res, r);
        } while (i < parsers.length);
        return res;
    });
}
exports.any = any;
/**
 * Peek next symbol in the input stream without changing the position.
 */
function peek() {
    return new Parser(input => {
        let pos = input.position;
        let next = input.next();
        input.position = pos;
        return pr.succeeded(pos, next);
    });
}
exports.peek = peek;
/**
 * Select a parser to be used based on the next symbol in the input. This
 * function is an alternative to the the "any" combinator. It reduces
 * backtracking when the parser to be applied can be deduced from the next
 * symbol.
 */
function choose(selector) {
    return peek().bind(selector);
}
exports.choose = choose;
/**
 * ## Getting Current Position
 *
 * A parser that returns the current position of the input. This is useful
 * when binding parsers together and you want to know the position where you
 * currently are. The position can be also used for backtracking.
 */
function position() {
    return new Parser(input => pr.succeeded(input.position, input.position));
}
exports.position = position;
/**
 * ## User-Managed State
 *
 * Get the current satellite state stored in the input.
 */
function getState() {
    return new Parser(input => pr.succeeded(input.position, input.state));
}
exports.getState = getState;
/**
 * Set the current satellite state stored in the input. The new state
 * is not given explicitly. Rather, a funcion which returns the new
 * state is specified.
 */
function setState(newValue) {
    return new Parser(input => pr.succeeded(input.position, input.state = newValue()));
}
exports.setState = setState;
/**
 * Mutate the satellite state stored in the input. The mutation is done
 * with a function given as an argument.
 */
function mutateState(mutate) {
    return new Parser(input => {
        mutate(input.state);
        return pr.succeeded(input.position, input.state);
    });
}
exports.mutateState = mutateState;
/**
 * Check that the current state matches a predicate. If not, the result parser
 * fails.
 */
function checkState(predicate) {
    return new Parser(input => predicate(input.state) ?
        pr.succeeded(input.position, input.state) :
        pr.failed(input.position, "Matching predicate."));
}
exports.checkState = checkState;
/**
 * Clean up the current state after a parser has been executed. The clean-up
 * function is run regardless of whether the parser succeeds or fails.
 */
function cleanupState(parser, cleanup) {
    return new Parser(input => {
        let res = parser.parse(input);
        cleanup(input.state);
        return res;
    });
}
exports.cleanupState = cleanupState;
/**
 * ## Defining Mutually Recursive Parsers
 *
 * Often grammar rules are mutually recursive, which means that there is no way
 * to write them in an order where all the dependent rules are defined. In these
 * occasions, you can just create a _reference_ to a parser and set its
 * implementation later. To refer to the parser that is not yet defined, you can
 * use this function.
 */
function forwardRef(parser) {
    return new Parser(input => parser.target.parse(input));
}
exports.forwardRef = forwardRef;
/**
 * ## General Parsers
 *
 * The catch-all parser that will match any symbol read from the input.
 */
function anything() {
    return satisfy(_ => true);
}
exports.anything = anything;
/**
 * Parser that succeeds if the symbol read from the input is equal (===) to
 * given parameter; otherwise parsing fails.
 */
function is(value) {
    return satisfy(x => x === value);
}
exports.is = is;
/**
 * Parse a specific token from the lexer input stream.
 */
function token(token) {
    return satisfy(t => t.token === token);
}
exports.token = token;
/**
 * Helper function to create a terminal parser.
 */
function terminal(tok, name) {
    return token(tok).expect(name);
}
exports.terminal = terminal;


/***/ }),

/***/ "./src/ref.ts":
/*!********************!*\
  !*** ./src/ref.ts ***!
  \********************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Ref = void 0;
/**
 * # Reference Cells
 *
 * `Ref<T>` class provides a simple reference cell, which can be used
 * as a surrogate for a parser that is defined later on. We can define
 * a _reference_ to parser, but we don't have to give the target right
 * away. When composing parsers we can use the `forwardRef` function
 * to pass a reference to any combinator expecting a `Parser<T, S>`.
 * Of course, we have to eventually assign a real parser as the target
 * of the reference before running the parser.
 */
class Ref {
    /**
     * Constructing a reference. The target value is optional.
     */
    constructor(value) {
        this._target = null;
        if (value)
            this._target = value;
    }
    /**
     * Get the target of the reference. If no target is set, a
     * `ReferenceError` is thrown.
     */
    get target() {
        if (this._target)
            return this._target;
        throw ReferenceError("Target not set.");
    }
    /**
     * Set the target.
     */
    set target(value) {
        this._target = value;
    }
}
exports.Ref = Ref;


/***/ }),

/***/ "./src/result.ts":
/*!***********************!*\
  !*** ./src/result.ts ***!
  \***********************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.failed = exports.succeeded = exports.expectedAsCsv = exports.joinExpected = void 0;
/**
 * ## Helper Functions
 *
 * The `joinExpected` function concatenates the list of expected
 * inputs from the `other` failed parse result into the `expected`
 * array of the first one.
 */
function joinExpected(result, other) {
    if (other.expected.length > 0)
        result.expected = result.expected.concat(other.expected);
}
exports.joinExpected = joinExpected;
/**
 * This function formats the array of expected inputs as a string for
 * printing.
 */
function expectedAsCsv(result) {
    return result.expected.map(s => `"${s}"`).join(", ");
}
exports.expectedAsCsv = expectedAsCsv;
/**
 * ## Constructor Functions
 *
 * The following function is used to construct an `Ok<T>` result.
 */
function succeeded(pos, res) {
    return {
        kind: "ok",
        position: pos,
        result: res
    };
}
exports.succeeded = succeeded;
/**
 * The next one constructs a `Fail` result.
 */
function failed(pos, fnd, exp = []) {
    return {
        kind: "fail",
        position: pos,
        found: fnd,
        expected: exp
    };
}
exports.failed = failed;


/***/ }),

/***/ "./src/test/exprparser.ts":
/*!********************************!*\
  !*** ./src/test/exprparser.ts ***!
  \********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.evaluateExpression = exports.ExprToken = void 0;
/**
 * # Parsing Arithmetic Expressions
 *
 * A common way to demonstrate parser construction is to use a grammar that
 * represents arithmetic expressions. We build a parser for simple expressions
 * that consist of addition, subtraction, multiplication, and division
 * operations.
 */
const pz = __webpack_require__(/*! ../ */ "./src/index.ts");
/**
 * ## Tokens
 *
 * Tokens include numbers, parenthesis, operators, and whitespace.
 */
var ExprToken;
(function (ExprToken) {
    ExprToken[ExprToken["Number"] = 0] = "Number";
    ExprToken[ExprToken["OpenParen"] = 1] = "OpenParen";
    ExprToken[ExprToken["CloseParen"] = 2] = "CloseParen";
    ExprToken[ExprToken["Plus"] = 3] = "Plus";
    ExprToken[ExprToken["Minus"] = 4] = "Minus";
    ExprToken[ExprToken["Multiply"] = 5] = "Multiply";
    ExprToken[ExprToken["Divide"] = 6] = "Divide";
    ExprToken[ExprToken["Whitespace"] = 7] = "Whitespace";
    ExprToken[ExprToken["EOF"] = 8] = "EOF";
})(ExprToken = exports.ExprToken || (exports.ExprToken = {}));
/**
 * To turn on debugging, set on the following flag. It outputs evaluated
 * parsing rules, which helps understanding the operation.
 */
pz.parserDebug.debugging = false;
/**
 * ## Lexer
 *
 * The lexer can be constructed with a single expression. We specify the
 * regular expression that accepts a given token, and associate it to the
 * member of the enumeration defined above.
 */
const lexer = new pz.Lexer([/-?\d+(?:\.\d+)?(?:[eE][+-]?\d+)?/, ExprToken.Number], [/\(/, ExprToken.OpenParen], [/\)/, ExprToken.CloseParen], [/\+/, ExprToken.Plus], [/-/, ExprToken.Minus], [/\*/, ExprToken.Multiply], [/\//, ExprToken.Divide], [/[\t\n\r ]+/, ExprToken.Whitespace]);
/**
 * ## Parser
 *
 * Parser is built from two kinds of parsing rules: ones that recognize
 * _terminals_ and others that recognize _nonterminals_.
 *
 * ### Terminals
 *
 * Terminal parsers recognize the tokens returned by the lexer. They are
 * straightforward to define.
 *
 * First we define a parser that skips any whitespace between the tokens.
 */
const optws = pz.terminal(ExprToken.Whitespace, "<whitespace>").optionalRef();
/**
 * Next we define parser for numbers. We convert the recognized text to `number`
 * type. We skip the trailing whitespace with the `followedBy` combinator.
 */
const number = pz.terminal(ExprToken.Number, "<number>")
    .map(t => Number(t.text)).followedBy(optws);
/**
 * Parenthesis and operators are all recognized the same way. Again, we skip the
 * trailing whitespace to keep the other rules simple.
 */
const openParen = pz.terminal(ExprToken.OpenParen, "(").followedBy(optws);
const closeParen = pz.terminal(ExprToken.CloseParen, ")").followedBy(optws);
const plus = pz.terminal(ExprToken.Plus, "+").followedBy(optws);
const minus = pz.terminal(ExprToken.Minus, "-").followedBy(optws);
const multiply = pz.terminal(ExprToken.Multiply, "*").followedBy(optws);
const divide = pz.terminal(ExprToken.Divide, "/").followedBy(optws);
/**
 * `eof` is a special terminal parser that recognizes end of input.
 */
const eof = pz.terminal(ExprToken.EOF, "<end of input>");
/**
 * ### Nonterminals
 *
 * The abstract nodes in a syntax tree are called nonterminals. We define a
 * parser for each nonterminal. Since expressions can theoretically be
 * infinitely long, the parsers are recursive.
 *
 * First we define parsers for operators. We utilize the `operators` combinator
 * which is designed just for this purpose. These parsers calculate the result
 * of the operation, and return it to the parent parser.
 */
const addop = pz.operators([plus, (a, b) => a + b], [minus, (a, b) => a - b]);
const mulop = pz.operators([multiply, (a, b) => a * b], [divide, (a, b) => a / b]);
/**
 * Terms are the results of multiplication or division operators. We define
 * the term parser as a reference as we need the factor parser in its
 * definition.
 */
const term = new pz.Ref();
/**
 * Expressions consist of terms that are added or subtracted together. Note how
 * the grammar implicitly defines the precedence order as terms are recognized
 * before the expressions.
 */
const expr = pz.forwardRef(term).chainOneOrMore(addop);
/**
 * To change the precedence order we uses parenthesis as usual. When an
 * expression is surrounded by parentehesis it becomes a factor which is
 * recognized before terms. So, a factor is either a number or an expression
 * in parenthesis.
 */
const factor = expr.bracketedBy(openParen, closeParen).or(number);
/**
 * Now we can define the term as sequence of factors separated by multiplication
 * or division operators.
 */
term.target = factor.chainOneOrMore(mulop);
/**
 * Last we define the root parser, which just skips any leading whitespace
 * before calling the expression parser. Whitespace in-between tokens is
 * skipped by terminal parsers.
 */
const rootExpr = optws.seq(expr).followedBy(eof);
/**
 * ## Exported Parsing Function
 *
 * Now we can define the helper functions which parses an expression string and
 * calculates its value. To get a `ParserInput<ExprToken>` interface required
 * by the parser, we call the `lexerInput` function, which takes the lexer and
 * input expression as arguments.
 *
 * After that we can call the `parse` function which takes the root grammar
 * rule and the input as parameters.
  */
function evaluateExpression(expression) {
    return pz.parse(rootExpr, pz.lexerInput(expression, lexer, new pz.Token(ExprToken.EOF, "<end of input>")));
}
exports.evaluateExpression = evaluateExpression;


/***/ }),

/***/ "./src/test/exprtests.ts":
/*!*******************************!*\
  !*** ./src/test/exprtests.ts ***!
  \*******************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
/**
 * ---
 * {
 *  "visualizers": [
 *      {
 *          "path": "./src/visualizers/run-expr-tests.ts",
 *          "includeStyles": true
 *      }
 *  ]
 * }
 * ---
 *
 * # Testing the Expression Parser
 *
 * The easiest way to test our parser is to manually input some expressions
 * (press `Enter` to calculate).
 *
 * <<v:calculator>>
 *
 * But this becomes tedious soon, so let's write some automatic tests as well.
 * We use the `test` function from the **lits-extras** package.
 */
const tester_1 = __webpack_require__(/*! lits-extras/lib/tester */ "./node_modules/lits-extras/lib/tester.js");
const ep = __webpack_require__(/*! ./exprparser */ "./src/test/exprparser.ts");
const fc = __webpack_require__(/*! fast-check */ "./node_modules/fast-check/lib/fast-check.js");
const pz = __webpack_require__(/*! .. */ "./src/index.ts");
/**
 * First, let's test some valid expressions. Since our expressions are valid
 * in JavaScript too, we can use the `eval` function as the baseline.
 */
tester_1.test("Test parsing of predefined expressions", (t) => __awaiter(void 0, void 0, void 0, function* () {
    let testset = [
        "1 + -1",
        "2 + 3 * 3",
        "1 - 1 / 2",
        "(1 - 1) / 2",
        "(1) + (((2)) + 3)"
    ];
    for (let i = 0; i < testset.length; i++) {
        let expr = testset[i];
        let res = eval(expr);
        let calcres = ep.evaluateExpression(expr);
        t.equal(calcres, res, `expression '${expr}' should evaluate to ${res}`);
    }
}));
/**
 * Then we test expression that should not be valid.
 */
tester_1.test("Test failing expressions", (t) => __awaiter(void 0, void 0, void 0, function* () {
    let testset = [
        "1 + ",
        "2 ++ 3 * 3",
        "- 1 - 1",
        "",
        "a + 1"
    ];
    for (let i = 0; i < testset.length; i++) {
        let expr = testset[i];
        t.throws(() => ep.evaluateExpression(expr), pz.ParseError, `expression '${expr}' should not parse`);
    }
}));
/**
 * ## Property Based Tests
 *
 * Coming up with test cases also becomes tedious quickly, so let's automate
 * test case generation with [fast-check][] library. This kind of approach is
 * called _property based testing_, and it helps us get confidence that our
 * implementation works correctly.
 *
 * [fast-check]: https://github.com/dubzzz/fast-check
 *
 * ### Running Tests
 *
 * When we run the tests, we can see how crazy input data we get when we
 * generate it with fast-check. It produces test cases we would very unlikely
 * come up with ourselves. You can press `F5` to rerun the tests.
 *
 * <<v:run-expr-tests Expression tests>>
 *
 * ### Generating Arbitrary Expressions
 *
 * So, how do we generate these arbitrary input expressions? We construct them
 * bottom-up starting from numbers and operators. Numbers we select randomly
 * from range [-1000, 1000].
 */
const arbNum = fc.integer(-1000, 1000).map(n => n.toString());
/**
 * Operators are randomly selected from a predefined list.
 */
const arbOper = fc.constantFrom("+", "-", "*", "/");
/**
 * Since expression is a tree-like structure, we need to use a combinator that
 * constructs data recursively. In fast-check this combinator is called
 * `letrec`. It takes a recursive function that returns an object which
 * properties generate arbitrary element of different types. We can descend to
 * the next level in the expression tree by calling the `tie` function we get
 * as an argument.
 */
const arbExpr = fc.letrec(tie => ({
    num: arbNum,
    oper: fc.tuple(tie('expr'), arbOper, tie('expr')).map(t => `${t[0]} ${t[1]} ${t[2]}`),
    par: tie('expr').map(e => "(" + e + ")"),
    expr: fc.oneof(tie('num'), tie('oper'), tie('par'))
}));
/**
 * ### Defining Properties
 *
 * Armed with our arbitrary combinators, we can define the properties that our
 * data should have (hence the name "property based testing"). We do that simply
 * by checking that JS `eval` and our `evaluateExpression` functions return the
 * same result for all input data.
 */
tester_1.test("Test arbitrary expressions", (t) => __awaiter(void 0, void 0, void 0, function* () {
    return fc.assert(fc.property(arbExpr.expr, e => {
        let res1 = eval(e);
        let res2 = ep.evaluateExpression(e);
        t.equal(res1, res2, `expression '${e}' should evaluate to ${res1}`);
    }));
}));


/***/ }),

/***/ "./src/utils.ts":
/*!**********************!*\
  !*** ./src/utils.ts ***!
  \**********************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.escapeWhitespace = exports.initObject = void 0;
/**
 * # Utility Functions
 *
 * This module contains general functions used elsewhere in the library.
 *
 * The first function initializes an object from an array of `[string, any]`
 * pairs. It is used to populate an object dynamically.
 */
function initObject(members) {
    let res = {};
    for (let i = 0; i < members.length; i++) {
        let [m, v] = members[i];
        res[m] = v;
    }
    return res;
}
exports.initObject = initObject;
/**
 * The `escapeWhitespace` function helps printing strings containing whitespace
 * characters. It replaces them with their escape codes.
 */
function escapeWhitespace(text) {
    return text.replace("\n", "\\n").replace("\r", "\\r").replace("\t", "\\t");
}
exports.escapeWhitespace = escapeWhitespace;


/***/ }),

/***/ "./node_modules/zora/dist/bundle/index.js":
/*!************************************************!*\
  !*** ./node_modules/zora/dist/bundle/index.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

const startTestMessage = (test, offset) => ({
    type: "TEST_START" /* TEST_START */,
    data: test,
    offset
});
const assertionMessage = (assertion, offset) => ({
    type: "ASSERTION" /* ASSERTION */,
    data: assertion,
    offset
});
const endTestMessage = (test, offset) => ({
    type: "TEST_END" /* TEST_END */,
    data: test,
    offset
});
const bailout = (error, offset) => ({
    type: "BAIL_OUT" /* BAIL_OUT */,
    data: error,
    offset
});

const delegateToCounter = (counter) => (target) => Object.defineProperties(target, {
    skipCount: {
        get() {
            return counter.skipCount;
        }
    },
    failureCount: {
        get() {
            return counter.failureCount;
        }
    },
    successCount: {
        get() {
            return counter.successCount;
        }
    },
    count: {
        get() {
            return counter.count;
        }
    }
});
const counter = () => {
    let success = 0;
    let failure = 0;
    let skip = 0;
    return Object.defineProperties({
        update(assertion) {
            const { pass, skip: isSkipped } = assertion;
            if (isSkipped) {
                skip++;
            }
            else if (!isAssertionResult(assertion)) {
                skip += assertion.skipCount;
                success += assertion.successCount;
                failure += assertion.failureCount;
            }
            else if (pass) {
                success++;
            }
            else {
                failure++;
            }
        }
    }, {
        successCount: {
            get() {
                return success;
            }
        },
        failureCount: {
            get() {
                return failure;
            }
        },
        skipCount: {
            get() {
                return skip;
            }
        },
        count: {
            get() {
                return skip + success + failure;
            }
        }
    });
};

const defaultTestOptions = Object.freeze({
    offset: 0,
    skip: false,
    runOnly: false
});
const noop = () => {
};
const TesterPrototype = {
    [Symbol.asyncIterator]: async function* () {
        await this.routine;
        for (const assertion of this.assertions) {
            if (assertion[Symbol.asyncIterator]) {
                // Sub test
                yield startTestMessage({ description: assertion.description }, this.offset);
                yield* assertion;
                if (assertion.error !== null) {
                    // Bubble up the error and return
                    this.error = assertion.error;
                    this.pass = false;
                    return;
                }
            }
            yield assertionMessage(assertion, this.offset);
            this.pass = this.pass && assertion.pass;
            this.counter.update(assertion);
        }
        return this.error !== null ?
            yield bailout(this.error, this.offset) :
            yield endTestMessage(this, this.offset);
    }
};
const testerLikeProvider = (BaseProto = TesterPrototype) => (assertions, routine, offset) => {
    const testCounter = counter();
    const withTestCounter = delegateToCounter(testCounter);
    let pass = true;
    return withTestCounter(Object.create(BaseProto, {
        routine: {
            value: routine
        },
        assertions: {
            value: assertions
        },
        offset: {
            value: offset
        },
        counter: {
            value: testCounter
        },
        length: {
            get() {
                return assertions.length;
            }
        },
        pass: {
            enumerable: true,
            get() {
                return pass;
            },
            set(val) {
                pass = val;
            }
        }
    }));
};
const testerFactory = testerLikeProvider();

const tester = (description, spec, { offset = 0, skip = false, runOnly = false } = defaultTestOptions) => {
    let executionTime = 0;
    let error = null;
    let done = false;
    const assertions = [];
    const collect = item => {
        if (done) {
            throw new Error(`test "${description}" 
tried to collect an assertion after it has run to its completion. 
You might have forgotten to wait for an asynchronous task to complete
------
${spec.toString()}
`);
        }
        assertions.push(item);
    };
    const specFunction = skip === true ? noop : function zora_spec_fn() {
        return spec(assert(collect, offset, runOnly));
    };
    const testRoutine = (async function () {
        try {
            const start = Date.now();
            const result = await specFunction();
            executionTime = Date.now() - start;
            return result;
        }
        catch (e) {
            error = e;
        }
        finally {
            done = true;
        }
    })();
    return Object.defineProperties(testerFactory(assertions, testRoutine, offset), {
        error: {
            get() {
                return error;
            },
            set(val) {
                error = val;
            }
        },
        executionTime: {
            enumerable: true,
            get() {
                return executionTime;
            }
        },
        skip: {
            value: skip
        },
        description: {
            enumerable: true,
            value: description
        }
    });
};

// do not edit .js files directly - edit src/index.jst



var fastDeepEqual = function equal(a, b) {
  if (a === b) return true;

  if (a && b && typeof a == 'object' && typeof b == 'object') {
    if (a.constructor !== b.constructor) return false;

    var length, i, keys;
    if (Array.isArray(a)) {
      length = a.length;
      if (length != b.length) return false;
      for (i = length; i-- !== 0;)
        if (!equal(a[i], b[i])) return false;
      return true;
    }



    if (a.constructor === RegExp) return a.source === b.source && a.flags === b.flags;
    if (a.valueOf !== Object.prototype.valueOf) return a.valueOf() === b.valueOf();
    if (a.toString !== Object.prototype.toString) return a.toString() === b.toString();

    keys = Object.keys(a);
    length = keys.length;
    if (length !== Object.keys(b).length) return false;

    for (i = length; i-- !== 0;)
      if (!Object.prototype.hasOwnProperty.call(b, keys[i])) return false;

    for (i = length; i-- !== 0;) {
      var key = keys[i];

      if (!equal(a[key], b[key])) return false;
    }

    return true;
  }

  // true if both NaN, false otherwise
  return a!==a && b!==b;
};

const isAssertionResult = (result) => {
    return 'operator' in result;
};
const specFnRegexp = /zora_spec_fn/;
const zoraInternal = /zora\/dist\/bundle/;
const filterStackLine = l => (l && !zoraInternal.test(l) && !l.startsWith('Error') || specFnRegexp.test(l));
const getAssertionLocation = () => {
    const err = new Error();
    const stack = (err.stack || '')
        .split('\n')
        .map(l => l.trim())
        .filter(filterStackLine);
    const userLandIndex = stack.findIndex(l => specFnRegexp.test(l));
    const stackline = userLandIndex >= 1 ? stack[userLandIndex - 1] : (stack[0] || 'N/A');
    return stackline
        .replace(/^at|^@/, '');
};
const assertMethodHook = (fn) => function (...args) {
    // @ts-ignore
    return this.collect(fn(...args));
};
const aliasMethodHook = (methodName) => function (...args) {
    return this[methodName](...args);
};
const unbindAssert = (target) => Object.fromEntries([...Object.keys(AssertPrototype), 'collect']
    .map((methodName) => [methodName, (...args) => target[methodName](...args)]));
const AssertPrototype = {
    equal: assertMethodHook((actual, expected, description = 'should be equivalent') => ({
        pass: fastDeepEqual(actual, expected),
        actual,
        expected,
        description,
        operator: "equal" /* EQUAL */
    })),
    equals: aliasMethodHook('equal'),
    eq: aliasMethodHook('equal'),
    deepEqual: aliasMethodHook('equal'),
    same: aliasMethodHook('equal'),
    notEqual: assertMethodHook((actual, expected, description = 'should not be equivalent') => ({
        pass: !fastDeepEqual(actual, expected),
        actual,
        expected,
        description,
        operator: "notEqual" /* NOT_EQUAL */
    })),
    notEquals: aliasMethodHook('notEqual'),
    notEq: aliasMethodHook('notEqual'),
    notDeepEqual: aliasMethodHook('notEqual'),
    is: assertMethodHook((actual, expected, description = 'should be the same') => ({
        pass: Object.is(actual, expected),
        actual,
        expected,
        description,
        operator: "is" /* IS */
    })),
    isNot: assertMethodHook((actual, expected, description = 'should not be the same') => ({
        pass: !Object.is(actual, expected),
        actual,
        expected,
        description,
        operator: "isNot" /* IS_NOT */
    })),
    notSame: aliasMethodHook('isNot'),
    ok: assertMethodHook((actual, description = 'should be truthy') => ({
        pass: Boolean(actual),
        actual,
        expected: 'truthy value',
        description,
        operator: "ok" /* OK */
    })),
    truthy: aliasMethodHook('ok'),
    notOk: assertMethodHook((actual, description = 'should be falsy') => ({
        pass: !Boolean(actual),
        actual,
        expected: 'falsy value',
        description,
        operator: "notOk" /* NOT_OK */
    })),
    falsy: aliasMethodHook('notOk'),
    fail: assertMethodHook((description = 'fail called') => ({
        pass: false,
        actual: 'fail called',
        expected: 'fail not called',
        description,
        operator: "fail" /* FAIL */
    })),
    throws: assertMethodHook((func, expected, description) => {
        let caught;
        let pass;
        let actual;
        if (typeof expected === 'string') {
            [expected, description] = [description, expected];
        }
        try {
            func();
        }
        catch (err) {
            caught = { error: err };
        }
        pass = caught !== undefined;
        actual = caught && caught.error;
        if (expected instanceof RegExp) {
            pass = expected.test(actual) || expected.test(actual && actual.message);
            actual = actual && actual.message || actual;
            expected = String(expected);
        }
        else if (typeof expected === 'function' && caught) {
            pass = actual instanceof expected;
            actual = actual.constructor;
        }
        return {
            pass,
            actual,
            expected,
            description: description || 'should throw',
            operator: "throws" /* THROWS */
        };
    }),
    doesNotThrow: assertMethodHook((func, expected, description) => {
        let caught;
        if (typeof expected === 'string') {
            [expected, description] = [description, expected];
        }
        try {
            func();
        }
        catch (err) {
            caught = { error: err };
        }
        return {
            pass: caught === undefined,
            expected: 'no thrown error',
            actual: caught && caught.error,
            operator: "doesNotThrow" /* DOES_NOT_THROW */,
            description: description || 'should not throw'
        };
    })
};
const assert = (collect, offset, runOnly = false) => {
    const actualCollect = item => {
        if (!item.pass) {
            item.at = getAssertionLocation();
        }
        collect(item);
        return item;
    };
    const test = (description, spec, opts) => {
        const options = Object.assign({}, defaultTestOptions, opts, { offset: offset + 1, runOnly });
        const subTest = tester(description, spec, options);
        collect(subTest);
        return subTest.routine;
    };
    const skip = (description, spec, opts) => {
        return test(description, spec, Object.assign({}, opts, { skip: true }));
    };
    // @ts-ignore
    return {
        ...unbindAssert(Object.create(AssertPrototype, { collect: { value: actualCollect } })),
        test(description, spec, opts = {}) {
            if (runOnly) {
                return skip(description, spec, opts);
            }
            return test(description, spec, opts);
        },
        skip(description, spec = noop, opts = {}) {
            return skip(description, spec, opts);
        },
        only(description, spec, opts = {}) {
            const specFn = runOnly === false ? _ => {
                throw new Error(`Can not use "only" method when not in run only mode`);
            } : spec;
            return test(description, specFn, opts);
        }
    };
};

const map = (fn) => async function* (stream) {
    for await (const m of stream) {
        yield fn(m);
    }
};
// ! it mutates the underlying structure yet it is more efficient regarding performances
const flatten = map((m) => {
    m.offset = 0;
    return m;
});
const isAssertionResult$1 = (result) => {
    return 'operator' in result;
};
const stringifySymbol = (key, value) => {
    if (typeof value === 'symbol') {
        return value.toString();
    }
    return value;
};

// @ts-ignore
const flatDiagnostic = ({ pass, description, ...rest }) => rest;
const Tap = {
    print(message, offset = 0) {
        this.log(message.padStart(message.length + (offset * 4))); // 4 white space used as indent (see tap-parser)
    },
    printYAML(obj, offset = 0) {
        const YAMLOffset = offset + 0.5;
        this.print('---', YAMLOffset);
        for (const [prop, value] of Object.entries(obj)) {
            this.print(`${prop}: ${JSON.stringify(value, stringifySymbol)}`, YAMLOffset + 0.5);
        }
        this.print('...', YAMLOffset);
    },
    printComment(comment, offset = 0) {
        this.print(`# ${comment}`, offset);
    },
    printBailOut(message) {
        this.print('Bail out! Unhandled error.');
    },
    printTestStart(message) {
        const { data: { description }, offset } = message;
        this.printComment(description, offset);
    },
    printTestEnd(message) {
        // do nothing
    },
    printAssertion(message) {
        const { data, offset } = message;
        const { pass, description } = data;
        const label = pass === true ? 'ok' : 'not ok';
        if (isAssertionResult$1(data)) {
            const id = this.nextId();
            this.print(`${label} ${id} - ${description}`, offset);
            if (pass === false) {
                this.printYAML(flatDiagnostic(data), offset);
            }
        }
        else if (data.skip) {
            const id = this.nextId();
            this.print(`${pass ? 'ok' : 'not ok'} ${id} - ${description} # SKIP`, offset);
        }
    },
    printSummary(endMessage) {
        this.print('', 0);
        this.printComment(endMessage.data.pass ? 'ok' : 'not ok', 0);
        this.printComment(`success: ${endMessage.data.successCount}`, 0);
        this.printComment(`skipped: ${endMessage.data.skipCount}`, 0);
        this.printComment(`failure: ${endMessage.data.failureCount}`, 0);
    },
    async report(stream) {
        const src = flatten(stream);
        let lastMessage = null;
        this.print('TAP version 13');
        for await (const message of src) {
            lastMessage = message;
            switch (message.type) {
                case "TEST_START" /* TEST_START */:
                    this.printTestStart(message);
                    break;
                case "ASSERTION" /* ASSERTION */:
                    this.printAssertion(message);
                    break;
                case "BAIL_OUT" /* BAIL_OUT */:
                    this.printBailOut(message);
                    throw message.data;
            }
        }
        this.print(`1..${lastMessage.data.count}`, 0);
        this.printSummary(lastMessage);
    }
};
const factory = (log) => {
    let i = 0;
    return Object.create(Tap, {
        nextId: {
            enumerable: true,
            value: () => {
                return ++i;
            }
        },
        log: { value: log }
    });
};

const indentedDiagnostic = ({ expected, pass, description, actual, operator, at = 'N/A', ...rest }) => ({
    wanted: expected,
    found: actual,
    at,
    operator,
    ...rest
});
const id = function* () {
    let i = 0;
    while (true) {
        yield ++i;
    }
};
const idGen = () => {
    let stack = [id()];
    return {
        [Symbol.iterator]() {
            return this;
        },
        next() {
            return stack[0].next();
        },
        fork() {
            stack.unshift(id());
        },
        merge() {
            stack.shift();
        }
    };
};
const IndentedTap = Object.assign({}, Tap, {
    printTestStart(message) {
        const { data: { description }, offset } = message;
        this.printComment(`Subtest: ${description}`, offset);
    },
    printAssertion(message) {
        const { data, offset } = message;
        const { pass, description } = data;
        const label = pass === true ? 'ok' : 'not ok';
        const id = this.nextId();
        if (isAssertionResult$1(data)) {
            this.print(`${label} ${id} - ${description}`, offset);
            if (pass === false) {
                this.printYAML(indentedDiagnostic(data), offset);
            }
        }
        else {
            const comment = data.skip === true ? 'SKIP' : `${data.executionTime}ms`;
            this.print(`${pass ? 'ok' : 'not ok'} ${id} - ${description} # ${comment}`, message.offset);
        }
    },
    printTestEnd(message) {
        const length = message.data.length;
        const { offset } = message;
        this.print(`1..${length}`, offset);
    }
});
const factory$1 = (log) => {
    const id = idGen();
    return Object.create(IndentedTap, {
        nextId: {
            enumerable: true,
            value: () => {
                return id.next().value;
            }
        },
        report: {
            enumerable: true,
            value: async function (stream) {
                this.print('TAP version 13');
                let lastMessage = null;
                for await (const message of stream) {
                    lastMessage = message;
                    switch (message.type) {
                        case "TEST_START" /* TEST_START */:
                            id.fork();
                            this.printTestStart(message);
                            break;
                        case "ASSERTION" /* ASSERTION */:
                            this.printAssertion(message);
                            break;
                        case "TEST_END" /* TEST_END */:
                            id.merge();
                            this.printTestEnd(message);
                            break;
                        case "BAIL_OUT" /* BAIL_OUT */:
                            this.printBailOut(message);
                            throw message.data;
                    }
                }
                this.printSummary(lastMessage);
            }
        },
        log: { value: log }
    });
};

const report = (factory) => (logger = console) => {
    const log = logger.log.bind(logger);
    return async (stream) => factory(log).report(stream);
};
const tapReporter = report(factory);
const indentedTapReporter = report(factory$1);

//@ts-ignore
const mochaTapLike = indentedTapReporter();
//@ts-ignore
const tapeTapLike = tapReporter();

const harnessFactory = ({ runOnly = false, indent = false } = {
    runOnly: false,
    indent: false
}) => {
    const tests = [];
    const rootOffset = 0;
    const collect = item => tests.push(item);
    const api = assert(collect, rootOffset, runOnly);
    let error = null;
    const factory = testerLikeProvider(Object.assign(api, TesterPrototype, {
        report: async function (reporter) {
            const rep = reporter || (indent ? mochaTapLike : tapeTapLike);
            return rep(this);
        }
    }));
    return Object.defineProperties(factory(tests, Promise.resolve(), rootOffset), {
        error: {
            get() {
                return error;
            },
            set(val) {
                error = val;
            }
        }
    });
};

const findConfigurationFlag = (name) => {
    if (typeof process !== 'undefined') {
        return process.env[name] === 'true';
        // @ts-ignore
    }
    else if (typeof Deno !== 'undefined') {
        // @ts-ignore
        return Deno.env.get(name) === 'true';
        // @ts-ignore
    }
    else if (typeof window !== 'undefined') {
        // @ts-ignore
        return Boolean(window[name]);
    }
    return false;
};
const defaultTestHarness = harnessFactory({
    runOnly: findConfigurationFlag('RUN_ONLY')
});
let autoStart = true;
let indent = findConfigurationFlag('INDENT');
const rootTest = defaultTestHarness.test.bind(defaultTestHarness);
rootTest.indent = () => {
    console.warn('indent function is deprecated, use "INDENT" configuration flag instead');
    indent = true;
};
const test = rootTest;
const skip = defaultTestHarness.skip.bind(defaultTestHarness);
const only = defaultTestHarness.only.bind(defaultTestHarness);
rootTest.skip = skip;
const equal = defaultTestHarness.equal.bind(defaultTestHarness);
const equals = equal;
const eq = equal;
const deepEqual = equal;
const notEqual = defaultTestHarness.notEqual.bind(defaultTestHarness);
const notEquals = notEqual;
const notEq = notEqual;
const notDeepEqual = notEqual;
const is = defaultTestHarness.is.bind(defaultTestHarness);
const same = is;
const isNot = defaultTestHarness.isNot.bind(defaultTestHarness);
const notSame = isNot;
const ok = defaultTestHarness.ok.bind(defaultTestHarness);
const truthy = ok;
const notOk = defaultTestHarness.notOk.bind(defaultTestHarness);
const falsy = notOk;
const fail = defaultTestHarness.fail.bind(defaultTestHarness);
const throws = defaultTestHarness.throws.bind(defaultTestHarness);
const doesNotThrow = defaultTestHarness.doesNotThrow.bind(defaultTestHarness);
const createHarness = (opts = {}) => {
    autoStart = false;
    return harnessFactory(opts);
};
const start = () => {
    if (autoStart) {
        defaultTestHarness.report(indent ? mochaTapLike : tapeTapLike);
    }
};
// on next tick start reporting
// @ts-ignore
if (typeof window === 'undefined') {
    setTimeout(start, 0);
}
else {
    // @ts-ignore
    window.addEventListener('load', start);
}

exports.AssertPrototype = AssertPrototype;
exports.createHarness = createHarness;
exports.deepEqual = deepEqual;
exports.doesNotThrow = doesNotThrow;
exports.eq = eq;
exports.equal = equal;
exports.equals = equals;
exports.fail = fail;
exports.falsy = falsy;
exports.is = is;
exports.isNot = isNot;
exports.mochaTapLike = mochaTapLike;
exports.notDeepEqual = notDeepEqual;
exports.notEq = notEq;
exports.notEqual = notEqual;
exports.notEquals = notEquals;
exports.notOk = notOk;
exports.notSame = notSame;
exports.ok = ok;
exports.only = only;
exports.same = same;
exports.skip = skip;
exports.tapeTapLike = tapeTapLike;
exports.test = test;
exports.throws = throws;
exports.truthy = truthy;


/***/ }),

/***/ "./node_modules/fast-check/lib/arbitrary/_internals/ArrayArbitrary.js":
/*!****************************************************************************!*\
  !*** ./node_modules/fast-check/lib/arbitrary/_internals/ArrayArbitrary.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ArrayArbitrary = void 0;
const Stream_1 = __webpack_require__(/*! ../../stream/Stream */ "./node_modules/fast-check/lib/stream/Stream.js");
const symbols_1 = __webpack_require__(/*! ../../check/symbols */ "./node_modules/fast-check/lib/check/symbols.js");
const integer_1 = __webpack_require__(/*! ../integer */ "./node_modules/fast-check/lib/arbitrary/integer.js");
const LazyIterableIterator_1 = __webpack_require__(/*! ../../stream/LazyIterableIterator */ "./node_modules/fast-check/lib/stream/LazyIterableIterator.js");
const BuildCompareFilter_1 = __webpack_require__(/*! ./helpers/BuildCompareFilter */ "./node_modules/fast-check/lib/arbitrary/_internals/helpers/BuildCompareFilter.js");
const NextArbitrary_1 = __webpack_require__(/*! ../../check/arbitrary/definition/NextArbitrary */ "./node_modules/fast-check/lib/check/arbitrary/definition/NextArbitrary.js");
const Converters_1 = __webpack_require__(/*! ../../check/arbitrary/definition/Converters */ "./node_modules/fast-check/lib/check/arbitrary/definition/Converters.js");
const NextValue_1 = __webpack_require__(/*! ../../check/arbitrary/definition/NextValue */ "./node_modules/fast-check/lib/check/arbitrary/definition/NextValue.js");
class ArrayArbitrary extends NextArbitrary_1.NextArbitrary {
    constructor(arb, minLength, maxLength, isEqual) {
        super();
        this.arb = arb;
        this.minLength = minLength;
        this.maxLength = maxLength;
        this.isEqual = isEqual;
        this.lengthArb = Converters_1.convertToNext(integer_1.integer(minLength, maxLength));
        this.preFilter = this.isEqual !== undefined ? BuildCompareFilter_1.buildCompareFilter(this.isEqual) : (tab) => tab;
    }
    static makeItCloneable(vs, shrinkables) {
        vs[symbols_1.cloneMethod] = () => {
            const cloned = [];
            for (let idx = 0; idx !== shrinkables.length; ++idx) {
                cloned.push(shrinkables[idx].value);
            }
            this.makeItCloneable(cloned, shrinkables);
            return cloned;
        };
        return vs;
    }
    static canAppendItem(items, newItem, isEqual) {
        for (let idx = 0; idx !== items.length; ++idx) {
            if (isEqual(items[idx].value_, newItem.value_)) {
                return false;
            }
        }
        return true;
    }
    generateNItemsNoDuplicates(N, mrng, biasFactorItems) {
        let numSkippedInRow = 0;
        const items = [];
        while (items.length < N && numSkippedInRow < this.maxLength) {
            const current = this.arb.generate(mrng, biasFactorItems);
            if (this.isEqual === undefined || ArrayArbitrary.canAppendItem(items, current, this.isEqual)) {
                numSkippedInRow = 0;
                items.push(current);
            }
            else {
                numSkippedInRow += 1;
            }
        }
        return items;
    }
    generateNItems(N, mrng, biasFactorItems) {
        const items = [];
        for (let index = 0; index !== N; ++index) {
            const current = this.arb.generate(mrng, biasFactorItems);
            items.push(current);
        }
        return items;
    }
    wrapper(itemsRaw, shrunkOnce, itemsRawLengthContext) {
        const items = shrunkOnce ? this.preFilter(itemsRaw) : itemsRaw;
        let cloneable = false;
        const vs = [];
        const itemsContexts = [];
        for (let idx = 0; idx !== items.length; ++idx) {
            const s = items[idx];
            cloneable = cloneable || s.hasToBeCloned;
            vs.push(s.value);
            itemsContexts.push(s.context);
        }
        if (cloneable) {
            ArrayArbitrary.makeItCloneable(vs, items);
        }
        const context = {
            shrunkOnce,
            lengthContext: itemsRaw.length === items.length && itemsRawLengthContext !== undefined
                ? itemsRawLengthContext
                : undefined,
            itemsContexts,
        };
        return new NextValue_1.NextValue(vs, context);
    }
    generate(mrng, biasFactor) {
        const biasMeta = this.applyBias(mrng, biasFactor);
        const targetSize = biasMeta.size;
        const items = this.isEqual !== undefined
            ? this.generateNItemsNoDuplicates(targetSize, mrng, biasMeta.biasFactorItems)
            : this.generateNItems(targetSize, mrng, biasMeta.biasFactorItems);
        return this.wrapper(items, false, undefined);
    }
    applyBias(mrng, biasFactor) {
        if (biasFactor === undefined || mrng.nextInt(1, biasFactor) !== 1) {
            return { size: this.lengthArb.generate(mrng, undefined).value };
        }
        if (mrng.nextInt(1, biasFactor) !== 1 || this.minLength === this.maxLength) {
            return { size: this.lengthArb.generate(mrng, undefined).value, biasFactorItems: biasFactor };
        }
        const maxBiasedLength = this.minLength + Math.floor(Math.log(this.maxLength - this.minLength) / Math.log(2));
        const targetSizeValue = Converters_1.convertToNext(integer_1.integer(this.minLength, maxBiasedLength)).generate(mrng, undefined);
        return { size: targetSizeValue.value, biasFactorItems: biasFactor };
    }
    canShrinkWithoutContext(value) {
        if (!Array.isArray(value) || this.minLength > value.length || value.length > this.maxLength) {
            return false;
        }
        for (let index = 0; index !== value.length; ++index) {
            if (!(index in value)) {
                return false;
            }
            if (!this.arb.canShrinkWithoutContext(value[index])) {
                return false;
            }
        }
        const filtered = this.preFilter(value.map((item) => new NextValue_1.NextValue(item, undefined)));
        return filtered.length === value.length;
    }
    shrinkImpl(value, context) {
        if (value.length === 0) {
            return Stream_1.Stream.nil();
        }
        const safeContext = context !== undefined
            ? context
            : { shrunkOnce: false, lengthContext: undefined, itemsContexts: [] };
        return (this.lengthArb
            .shrink(value.length, safeContext.lengthContext)
            .drop(safeContext.shrunkOnce && safeContext.lengthContext === undefined && value.length > this.minLength + 1 ? 1 : 0)
            .map((lengthValue) => {
            const sliceStart = value.length - lengthValue.value;
            return [
                value
                    .slice(sliceStart)
                    .map((v, index) => new NextValue_1.NextValue(symbols_1.cloneIfNeeded(v), safeContext.itemsContexts[index + sliceStart])),
                lengthValue.context,
            ];
        })
            .join(this.arb.shrink(value[0], safeContext.itemsContexts[0]).map((v) => {
            return [
                [v].concat(value.slice(1).map((v, index) => new NextValue_1.NextValue(symbols_1.cloneIfNeeded(v), safeContext.itemsContexts[index + 1]))),
                undefined,
            ];
        }))
            .join(value.length > this.minLength
            ? LazyIterableIterator_1.makeLazy(() => this.shrinkImpl(value.slice(1), {
                shrunkOnce: false,
                lengthContext: undefined,
                itemsContexts: safeContext.itemsContexts.slice(1),
            })
                .filter((v) => this.minLength <= v[0].length + 1)
                .map((v) => {
                return [
                    [new NextValue_1.NextValue(symbols_1.cloneIfNeeded(value[0]), safeContext.itemsContexts[0])].concat(v[0]),
                    undefined,
                ];
            }))
            : Stream_1.Stream.nil()));
    }
    shrink(value, context) {
        return this.shrinkImpl(value, context).map((contextualValue) => this.wrapper(contextualValue[0], true, contextualValue[1]));
    }
}
exports.ArrayArbitrary = ArrayArbitrary;


/***/ }),

/***/ "./node_modules/fast-check/lib/arbitrary/_internals/BigIntArbitrary.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/fast-check/lib/arbitrary/_internals/BigIntArbitrary.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BigIntArbitrary = void 0;
const Stream_1 = __webpack_require__(/*! ../../stream/Stream */ "./node_modules/fast-check/lib/stream/Stream.js");
const NextArbitrary_1 = __webpack_require__(/*! ../../check/arbitrary/definition/NextArbitrary */ "./node_modules/fast-check/lib/check/arbitrary/definition/NextArbitrary.js");
const NextValue_1 = __webpack_require__(/*! ../../check/arbitrary/definition/NextValue */ "./node_modules/fast-check/lib/check/arbitrary/definition/NextValue.js");
const BiasNumericRange_1 = __webpack_require__(/*! ./helpers/BiasNumericRange */ "./node_modules/fast-check/lib/arbitrary/_internals/helpers/BiasNumericRange.js");
const ShrinkBigInt_1 = __webpack_require__(/*! ./helpers/ShrinkBigInt */ "./node_modules/fast-check/lib/arbitrary/_internals/helpers/ShrinkBigInt.js");
class BigIntArbitrary extends NextArbitrary_1.NextArbitrary {
    constructor(min, max) {
        super();
        this.min = min;
        this.max = max;
    }
    generate(mrng, biasFactor) {
        const range = this.computeGenerateRange(mrng, biasFactor);
        return new NextValue_1.NextValue(mrng.nextBigInt(range.min, range.max), undefined);
    }
    computeGenerateRange(mrng, biasFactor) {
        if (biasFactor === undefined || mrng.nextInt(1, biasFactor) !== 1) {
            return { min: this.min, max: this.max };
        }
        const ranges = BiasNumericRange_1.biasNumericRange(this.min, this.max, BiasNumericRange_1.bigIntLogLike);
        if (ranges.length === 1) {
            return ranges[0];
        }
        const id = mrng.nextInt(-2 * (ranges.length - 1), ranges.length - 2);
        return id < 0 ? ranges[0] : ranges[id + 1];
    }
    canShrinkWithoutContext(value) {
        return typeof value === 'bigint' && this.min <= value && value <= this.max;
    }
    shrink(current, context) {
        if (!BigIntArbitrary.isValidContext(current, context)) {
            const target = this.defaultTarget();
            return ShrinkBigInt_1.shrinkBigInt(current, target, true);
        }
        if (this.isLastChanceTry(current, context)) {
            return Stream_1.Stream.of(new NextValue_1.NextValue(context, undefined));
        }
        return ShrinkBigInt_1.shrinkBigInt(current, context, false);
    }
    defaultTarget() {
        if (this.min <= 0 && this.max >= 0) {
            return BigInt(0);
        }
        return this.min < 0 ? this.max : this.min;
    }
    isLastChanceTry(current, context) {
        if (current > 0)
            return current === context + BigInt(1) && current > this.min;
        if (current < 0)
            return current === context - BigInt(1) && current < this.max;
        return false;
    }
    static isValidContext(current, context) {
        if (context === undefined) {
            return false;
        }
        if (typeof context !== 'bigint') {
            throw new Error(`Invalid context type passed to BigIntArbitrary (#1)`);
        }
        const differentSigns = (current > 0 && context < 0) || (current < 0 && context > 0);
        if (context !== BigInt(0) && differentSigns) {
            throw new Error(`Invalid context value passed to BigIntArbitrary (#2)`);
        }
        return true;
    }
}
exports.BigIntArbitrary = BigIntArbitrary;


/***/ }),

/***/ "./node_modules/fast-check/lib/arbitrary/_internals/CloneArbitrary.js":
/*!****************************************************************************!*\
  !*** ./node_modules/fast-check/lib/arbitrary/_internals/CloneArbitrary.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CloneArbitrary = void 0;
const NextArbitrary_1 = __webpack_require__(/*! ../../check/arbitrary/definition/NextArbitrary */ "./node_modules/fast-check/lib/check/arbitrary/definition/NextArbitrary.js");
const NextValue_1 = __webpack_require__(/*! ../../check/arbitrary/definition/NextValue */ "./node_modules/fast-check/lib/check/arbitrary/definition/NextValue.js");
const symbols_1 = __webpack_require__(/*! ../../check/symbols */ "./node_modules/fast-check/lib/check/symbols.js");
const Stream_1 = __webpack_require__(/*! ../../stream/Stream */ "./node_modules/fast-check/lib/stream/Stream.js");
class CloneArbitrary extends NextArbitrary_1.NextArbitrary {
    constructor(arb, numValues) {
        super();
        this.arb = arb;
        this.numValues = numValues;
    }
    generate(mrng, biasFactor) {
        const items = [];
        if (this.numValues <= 0) {
            return this.wrapper(items);
        }
        for (let idx = 0; idx !== this.numValues - 1; ++idx) {
            items.push(this.arb.generate(mrng.clone(), biasFactor));
        }
        items.push(this.arb.generate(mrng, biasFactor));
        return this.wrapper(items);
    }
    canShrinkWithoutContext(value) {
        if (!Array.isArray(value) || value.length !== this.numValues) {
            return false;
        }
        if (value.length === 0) {
            return true;
        }
        for (let index = 1; index < value.length; ++index) {
            if (!Object.is(value[0], value[index])) {
                return false;
            }
        }
        return this.arb.canShrinkWithoutContext(value[0]);
    }
    shrink(value, context) {
        if (value.length === 0) {
            return Stream_1.Stream.nil();
        }
        return new Stream_1.Stream(this.shrinkImpl(value, context !== undefined ? context : [])).map((v) => this.wrapper(v));
    }
    *shrinkImpl(value, contexts) {
        const its = value.map((v, idx) => this.arb.shrink(v, contexts[idx])[Symbol.iterator]());
        let cur = its.map((it) => it.next());
        while (!cur[0].done) {
            yield cur.map((c) => c.value);
            cur = its.map((it) => it.next());
        }
    }
    static makeItCloneable(vs, shrinkables) {
        vs[symbols_1.cloneMethod] = () => {
            const cloned = [];
            for (let idx = 0; idx !== shrinkables.length; ++idx) {
                cloned.push(shrinkables[idx].value);
            }
            this.makeItCloneable(cloned, shrinkables);
            return cloned;
        };
        return vs;
    }
    wrapper(items) {
        let cloneable = false;
        const vs = [];
        const contexts = [];
        for (let idx = 0; idx !== items.length; ++idx) {
            const s = items[idx];
            cloneable = cloneable || s.hasToBeCloned;
            vs.push(s.value);
            contexts.push(s.context);
        }
        if (cloneable) {
            CloneArbitrary.makeItCloneable(vs, items);
        }
        return new NextValue_1.NextValue(vs, contexts);
    }
}
exports.CloneArbitrary = CloneArbitrary;


/***/ }),

/***/ "./node_modules/fast-check/lib/arbitrary/_internals/ConstantArbitrary.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/fast-check/lib/arbitrary/_internals/ConstantArbitrary.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ConstantArbitrary = void 0;
const Stream_1 = __webpack_require__(/*! ../../stream/Stream */ "./node_modules/fast-check/lib/stream/Stream.js");
const NextArbitrary_1 = __webpack_require__(/*! ../../check/arbitrary/definition/NextArbitrary */ "./node_modules/fast-check/lib/check/arbitrary/definition/NextArbitrary.js");
const NextValue_1 = __webpack_require__(/*! ../../check/arbitrary/definition/NextValue */ "./node_modules/fast-check/lib/check/arbitrary/definition/NextValue.js");
const symbols_1 = __webpack_require__(/*! ../../check/symbols */ "./node_modules/fast-check/lib/check/symbols.js");
class ConstantArbitrary extends NextArbitrary_1.NextArbitrary {
    constructor(values) {
        super();
        this.values = values;
    }
    generate(mrng, _biasFactor) {
        const idx = this.values.length === 1 ? 0 : mrng.nextInt(0, this.values.length - 1);
        const value = this.values[idx];
        if (!symbols_1.hasCloneMethod(value)) {
            return new NextValue_1.NextValue(value, idx);
        }
        return new NextValue_1.NextValue(value, idx, () => value[symbols_1.cloneMethod]());
    }
    canShrinkWithoutContext(value) {
        for (let idx = 0; idx !== this.values.length; ++idx) {
            if (Object.is(this.values[idx], value)) {
                return true;
            }
        }
        return false;
    }
    shrink(value, context) {
        if (context === 0 || Object.is(value, this.values[0])) {
            return Stream_1.Stream.nil();
        }
        return Stream_1.Stream.of(new NextValue_1.NextValue(this.values[0], 0));
    }
}
exports.ConstantArbitrary = ConstantArbitrary;


/***/ }),

/***/ "./node_modules/fast-check/lib/arbitrary/_internals/FrequencyArbitrary.js":
/*!********************************************************************************!*\
  !*** ./node_modules/fast-check/lib/arbitrary/_internals/FrequencyArbitrary.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FrequencyArbitrary = void 0;
const Stream_1 = __webpack_require__(/*! ../../stream/Stream */ "./node_modules/fast-check/lib/stream/Stream.js");
const Converters_1 = __webpack_require__(/*! ../../check/arbitrary/definition/Converters */ "./node_modules/fast-check/lib/check/arbitrary/definition/Converters.js");
const NextArbitrary_1 = __webpack_require__(/*! ../../check/arbitrary/definition/NextArbitrary */ "./node_modules/fast-check/lib/check/arbitrary/definition/NextArbitrary.js");
const NextValue_1 = __webpack_require__(/*! ../../check/arbitrary/definition/NextValue */ "./node_modules/fast-check/lib/check/arbitrary/definition/NextValue.js");
const DepthContext_1 = __webpack_require__(/*! ./helpers/DepthContext */ "./node_modules/fast-check/lib/arbitrary/_internals/helpers/DepthContext.js");
class FrequencyArbitrary extends NextArbitrary_1.NextArbitrary {
    constructor(warbs, constraints, context) {
        super();
        this.warbs = warbs;
        this.constraints = constraints;
        this.context = context;
        let currentWeight = 0;
        this.cumulatedWeights = [];
        for (let idx = 0; idx !== warbs.length; ++idx) {
            currentWeight += warbs[idx].weight;
            this.cumulatedWeights.push(currentWeight);
        }
        this.totalWeight = currentWeight;
    }
    static fromOld(warbs, constraints, label) {
        return Converters_1.convertFromNext(FrequencyArbitrary.from(warbs.map((w) => (Object.assign(Object.assign({}, w), { arbitrary: Converters_1.convertToNext(w.arbitrary) }))), constraints, label));
    }
    static from(warbs, constraints, label) {
        if (warbs.length === 0) {
            throw new Error(`${label} expects at least one weigthed arbitrary`);
        }
        let totalWeight = 0;
        for (let idx = 0; idx !== warbs.length; ++idx) {
            const currentArbitrary = warbs[idx].arbitrary;
            if (currentArbitrary === undefined) {
                throw new Error(`${label} expects arbitraries to be specified`);
            }
            const currentWeight = warbs[idx].weight;
            totalWeight += currentWeight;
            if (!Number.isInteger(currentWeight)) {
                throw new Error(`${label} expects weights to be integer values`);
            }
            if (currentWeight < 0) {
                throw new Error(`${label} expects weights to be superior or equal to 0`);
            }
        }
        if (totalWeight <= 0) {
            throw new Error(`${label} expects the sum of weights to be strictly superior to 0`);
        }
        return new FrequencyArbitrary(warbs, constraints, DepthContext_1.getDepthContextFor(constraints.depthIdentifier));
    }
    generate(mrng, biasFactor) {
        if (this.mustGenerateFirst()) {
            return this.safeGenerateForIndex(mrng, 0, biasFactor);
        }
        const selected = mrng.nextInt(this.computeNegDepthBenefit(), this.totalWeight - 1);
        for (let idx = 0; idx !== this.cumulatedWeights.length; ++idx) {
            if (selected < this.cumulatedWeights[idx]) {
                return this.safeGenerateForIndex(mrng, idx, biasFactor);
            }
        }
        throw new Error(`Unable to generate from fc.frequency`);
    }
    canShrinkWithoutContext(value) {
        return this.canShrinkWithoutContextIndex(value) !== -1;
    }
    shrink(value, context) {
        if (context !== undefined) {
            const safeContext = context;
            const selectedIndex = safeContext.selectedIndex;
            const originalBias = safeContext.originalBias;
            const originalArbitrary = this.warbs[selectedIndex].arbitrary;
            const originalShrinks = originalArbitrary
                .shrink(value, safeContext.originalContext)
                .map((v) => this.mapIntoNextValue(selectedIndex, v, null, originalBias));
            if (safeContext.clonedMrngForFallbackFirst !== null) {
                if (safeContext.cachedGeneratedForFirst === undefined) {
                    safeContext.cachedGeneratedForFirst = this.safeGenerateForIndex(safeContext.clonedMrngForFallbackFirst, 0, originalBias);
                }
                const valueFromFirst = safeContext.cachedGeneratedForFirst;
                return Stream_1.Stream.of(valueFromFirst).join(originalShrinks);
            }
            return originalShrinks;
        }
        const potentialSelectedIndex = this.canShrinkWithoutContextIndex(value);
        if (potentialSelectedIndex === -1) {
            return Stream_1.Stream.nil();
        }
        return this.defaultShrinkForFirst(potentialSelectedIndex).join(this.warbs[potentialSelectedIndex].arbitrary
            .shrink(value, undefined)
            .map((v) => this.mapIntoNextValue(potentialSelectedIndex, v, null, undefined)));
    }
    defaultShrinkForFirst(selectedIndex) {
        ++this.context.depth;
        try {
            if (!this.mustFallbackToFirstInShrink(selectedIndex) || this.warbs[0].fallbackValue === undefined) {
                return Stream_1.Stream.nil();
            }
        }
        finally {
            --this.context.depth;
        }
        const rawShrinkValue = new NextValue_1.NextValue(this.warbs[0].fallbackValue.default, undefined);
        return Stream_1.Stream.of(this.mapIntoNextValue(0, rawShrinkValue, null, undefined));
    }
    canShrinkWithoutContextIndex(value) {
        if (this.mustGenerateFirst()) {
            return this.warbs[0].arbitrary.canShrinkWithoutContext(value) ? 0 : -1;
        }
        try {
            ++this.context.depth;
            for (let idx = 0; idx !== this.warbs.length; ++idx) {
                const warb = this.warbs[idx];
                if (warb.weight !== 0 && warb.arbitrary.canShrinkWithoutContext(value)) {
                    return idx;
                }
            }
            return -1;
        }
        finally {
            --this.context.depth;
        }
    }
    mapIntoNextValue(idx, value, clonedMrngForFallbackFirst, biasFactor) {
        const context = {
            selectedIndex: idx,
            originalBias: biasFactor,
            originalContext: value.context,
            clonedMrngForFallbackFirst,
        };
        return new NextValue_1.NextValue(value.value, context);
    }
    safeGenerateForIndex(mrng, idx, biasFactor) {
        ++this.context.depth;
        try {
            const value = this.warbs[idx].arbitrary.generate(mrng, biasFactor);
            const clonedMrngForFallbackFirst = this.mustFallbackToFirstInShrink(idx) ? mrng.clone() : null;
            return this.mapIntoNextValue(idx, value, clonedMrngForFallbackFirst, biasFactor);
        }
        finally {
            --this.context.depth;
        }
    }
    mustGenerateFirst() {
        return this.constraints.maxDepth !== undefined && this.constraints.maxDepth <= this.context.depth;
    }
    mustFallbackToFirstInShrink(idx) {
        return idx !== 0 && !!this.constraints.withCrossShrink && this.warbs[0].weight !== 0;
    }
    computeNegDepthBenefit() {
        const depthFactor = this.constraints.depthFactor;
        if (depthFactor === undefined || depthFactor <= 0) {
            return 0;
        }
        const depthBenefit = Math.floor(Math.pow(1 + depthFactor, this.context.depth)) - 1;
        return -Math.min(this.warbs[0].weight * depthBenefit, Number.MAX_SAFE_INTEGER) || 0;
    }
}
exports.FrequencyArbitrary = FrequencyArbitrary;


/***/ }),

/***/ "./node_modules/fast-check/lib/arbitrary/_internals/IntegerArbitrary.js":
/*!******************************************************************************!*\
  !*** ./node_modules/fast-check/lib/arbitrary/_internals/IntegerArbitrary.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.IntegerArbitrary = void 0;
const NextArbitrary_1 = __webpack_require__(/*! ../../check/arbitrary/definition/NextArbitrary */ "./node_modules/fast-check/lib/check/arbitrary/definition/NextArbitrary.js");
const NextValue_1 = __webpack_require__(/*! ../../check/arbitrary/definition/NextValue */ "./node_modules/fast-check/lib/check/arbitrary/definition/NextValue.js");
const Stream_1 = __webpack_require__(/*! ../../stream/Stream */ "./node_modules/fast-check/lib/stream/Stream.js");
const BiasNumericRange_1 = __webpack_require__(/*! ./helpers/BiasNumericRange */ "./node_modules/fast-check/lib/arbitrary/_internals/helpers/BiasNumericRange.js");
const ShrinkInteger_1 = __webpack_require__(/*! ./helpers/ShrinkInteger */ "./node_modules/fast-check/lib/arbitrary/_internals/helpers/ShrinkInteger.js");
class IntegerArbitrary extends NextArbitrary_1.NextArbitrary {
    constructor(min, max) {
        super();
        this.min = min;
        this.max = max;
    }
    generate(mrng, biasFactor) {
        const range = this.computeGenerateRange(mrng, biasFactor);
        return new NextValue_1.NextValue(mrng.nextInt(range.min, range.max), undefined);
    }
    canShrinkWithoutContext(value) {
        return (typeof value === 'number' &&
            Number.isInteger(value) &&
            !Object.is(value, -0) &&
            this.min <= value &&
            value <= this.max);
    }
    shrink(current, context) {
        if (!IntegerArbitrary.isValidContext(current, context)) {
            const target = this.defaultTarget();
            return ShrinkInteger_1.shrinkInteger(current, target, true);
        }
        if (this.isLastChanceTry(current, context)) {
            return Stream_1.Stream.of(new NextValue_1.NextValue(context, undefined));
        }
        return ShrinkInteger_1.shrinkInteger(current, context, false);
    }
    defaultTarget() {
        if (this.min <= 0 && this.max >= 0) {
            return 0;
        }
        return this.min < 0 ? this.max : this.min;
    }
    computeGenerateRange(mrng, biasFactor) {
        if (biasFactor === undefined || mrng.nextInt(1, biasFactor) !== 1) {
            return { min: this.min, max: this.max };
        }
        const ranges = BiasNumericRange_1.biasNumericRange(this.min, this.max, BiasNumericRange_1.integerLogLike);
        if (ranges.length === 1) {
            return ranges[0];
        }
        const id = mrng.nextInt(-2 * (ranges.length - 1), ranges.length - 2);
        return id < 0 ? ranges[0] : ranges[id + 1];
    }
    isLastChanceTry(current, context) {
        if (current > 0)
            return current === context + 1 && current > this.min;
        if (current < 0)
            return current === context - 1 && current < this.max;
        return false;
    }
    static isValidContext(current, context) {
        if (context === undefined) {
            return false;
        }
        if (typeof context !== 'number') {
            throw new Error(`Invalid context type passed to IntegerArbitrary (#1)`);
        }
        if (context !== 0 && Math.sign(current) !== Math.sign(context)) {
            throw new Error(`Invalid context value passed to IntegerArbitrary (#2)`);
        }
        return true;
    }
}
exports.IntegerArbitrary = IntegerArbitrary;


/***/ }),

/***/ "./node_modules/fast-check/lib/arbitrary/_internals/LazyArbitrary.js":
/*!***************************************************************************!*\
  !*** ./node_modules/fast-check/lib/arbitrary/_internals/LazyArbitrary.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LazyArbitrary = void 0;
const NextArbitrary_1 = __webpack_require__(/*! ../../check/arbitrary/definition/NextArbitrary */ "./node_modules/fast-check/lib/check/arbitrary/definition/NextArbitrary.js");
class LazyArbitrary extends NextArbitrary_1.NextArbitrary {
    constructor(name) {
        super();
        this.name = name;
        this.underlying = null;
    }
    generate(mrng, biasFactor) {
        if (!this.underlying) {
            throw new Error(`Lazy arbitrary ${JSON.stringify(this.name)} not correctly initialized`);
        }
        return this.underlying.generate(mrng, biasFactor);
    }
    canShrinkWithoutContext(value) {
        if (!this.underlying) {
            throw new Error(`Lazy arbitrary ${JSON.stringify(this.name)} not correctly initialized`);
        }
        return this.underlying.canShrinkWithoutContext(value);
    }
    shrink(value, context) {
        if (!this.underlying) {
            throw new Error(`Lazy arbitrary ${JSON.stringify(this.name)} not correctly initialized`);
        }
        return this.underlying.shrink(value, context);
    }
}
exports.LazyArbitrary = LazyArbitrary;


/***/ }),

/***/ "./node_modules/fast-check/lib/arbitrary/_internals/MixedCaseArbitrary.js":
/*!********************************************************************************!*\
  !*** ./node_modules/fast-check/lib/arbitrary/_internals/MixedCaseArbitrary.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MixedCaseArbitrary = exports.computeNextFlags = exports.countToggledBits = void 0;
const Stream_1 = __webpack_require__(/*! ../../stream/Stream */ "./node_modules/fast-check/lib/stream/Stream.js");
const bigUintN_1 = __webpack_require__(/*! ../bigUintN */ "./node_modules/fast-check/lib/arbitrary/bigUintN.js");
const NextArbitrary_1 = __webpack_require__(/*! ../../check/arbitrary/definition/NextArbitrary */ "./node_modules/fast-check/lib/check/arbitrary/definition/NextArbitrary.js");
const Converters_1 = __webpack_require__(/*! ../../check/arbitrary/definition/Converters */ "./node_modules/fast-check/lib/check/arbitrary/definition/Converters.js");
const NextValue_1 = __webpack_require__(/*! ../../check/arbitrary/definition/NextValue */ "./node_modules/fast-check/lib/check/arbitrary/definition/NextValue.js");
const LazyIterableIterator_1 = __webpack_require__(/*! ../../stream/LazyIterableIterator */ "./node_modules/fast-check/lib/stream/LazyIterableIterator.js");
function countToggledBits(n) {
    let count = 0;
    while (n > BigInt(0)) {
        if (n & BigInt(1))
            ++count;
        n >>= BigInt(1);
    }
    return count;
}
exports.countToggledBits = countToggledBits;
function computeNextFlags(flags, nextSize) {
    const allowedMask = (BigInt(1) << BigInt(nextSize)) - BigInt(1);
    const preservedFlags = flags & allowedMask;
    let numMissingFlags = countToggledBits(flags - preservedFlags);
    let nFlags = preservedFlags;
    for (let mask = BigInt(1); mask <= allowedMask && numMissingFlags !== 0; mask <<= BigInt(1)) {
        if (!(nFlags & mask)) {
            nFlags |= mask;
            --numMissingFlags;
        }
    }
    return nFlags;
}
exports.computeNextFlags = computeNextFlags;
class MixedCaseArbitrary extends NextArbitrary_1.NextArbitrary {
    constructor(stringArb, toggleCase) {
        super();
        this.stringArb = stringArb;
        this.toggleCase = toggleCase;
    }
    computeTogglePositions(chars) {
        const positions = [];
        for (let idx = 0; idx !== chars.length; ++idx) {
            if (this.toggleCase(chars[idx]) !== chars[idx])
                positions.push(idx);
        }
        return positions;
    }
    applyFlagsOnChars(chars, flags, togglePositions) {
        for (let idx = 0, mask = BigInt(1); idx !== togglePositions.length; ++idx, mask <<= BigInt(1)) {
            if (flags & mask)
                chars[togglePositions[idx]] = this.toggleCase(chars[togglePositions[idx]]);
        }
        return chars;
    }
    buildContextFor(rawStringNextValue, flagsNextValue) {
        return {
            rawString: rawStringNextValue.value,
            rawStringContext: rawStringNextValue.context,
            flags: flagsNextValue.value,
            flagsContext: flagsNextValue.context,
        };
    }
    generate(mrng, biasFactor) {
        const rawStringNextValue = this.stringArb.generate(mrng, biasFactor);
        const chars = [...rawStringNextValue.value];
        const togglePositions = this.computeTogglePositions(chars);
        const flagsArb = Converters_1.convertToNext(bigUintN_1.bigUintN(togglePositions.length));
        const flagsNextValue = flagsArb.generate(mrng, undefined);
        this.applyFlagsOnChars(chars, flagsNextValue.value, togglePositions);
        return new NextValue_1.NextValue(chars.join(''), this.buildContextFor(rawStringNextValue, flagsNextValue));
    }
    canShrinkWithoutContext(value) {
        return false;
    }
    shrink(_value, context) {
        if (context === undefined) {
            return Stream_1.Stream.nil();
        }
        const contextSafe = context;
        const rawString = contextSafe.rawString;
        const flags = contextSafe.flags;
        return this.stringArb
            .shrink(rawString, contextSafe.rawStringContext)
            .map((nRawStringNextValue) => {
            const nChars = [...nRawStringNextValue.value];
            const nTogglePositions = this.computeTogglePositions(nChars);
            const nFlags = computeNextFlags(flags, nTogglePositions.length);
            this.applyFlagsOnChars(nChars, nFlags, nTogglePositions);
            return new NextValue_1.NextValue(nChars.join(''), this.buildContextFor(nRawStringNextValue, new NextValue_1.NextValue(nFlags, undefined)));
        })
            .join(LazyIterableIterator_1.makeLazy(() => {
            const chars = [...rawString];
            const togglePositions = this.computeTogglePositions(chars);
            return Converters_1.convertToNext(bigUintN_1.bigUintN(togglePositions.length))
                .shrink(flags, contextSafe.flagsContext)
                .map((nFlagsNextValue) => {
                const nChars = chars.slice();
                this.applyFlagsOnChars(nChars, nFlagsNextValue.value, togglePositions);
                return new NextValue_1.NextValue(nChars.join(''), this.buildContextFor(new NextValue_1.NextValue(rawString, contextSafe.rawStringContext), nFlagsNextValue));
            });
        }));
    }
}
exports.MixedCaseArbitrary = MixedCaseArbitrary;


/***/ }),

/***/ "./node_modules/fast-check/lib/arbitrary/_internals/SchedulerArbitrary.js":
/*!********************************************************************************!*\
  !*** ./node_modules/fast-check/lib/arbitrary/_internals/SchedulerArbitrary.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SchedulerArbitrary = void 0;
const NextArbitrary_1 = __webpack_require__(/*! ../../check/arbitrary/definition/NextArbitrary */ "./node_modules/fast-check/lib/check/arbitrary/definition/NextArbitrary.js");
const NextValue_1 = __webpack_require__(/*! ../../check/arbitrary/definition/NextValue */ "./node_modules/fast-check/lib/check/arbitrary/definition/NextValue.js");
const Stream_1 = __webpack_require__(/*! ../../stream/Stream */ "./node_modules/fast-check/lib/stream/Stream.js");
const SchedulerImplem_1 = __webpack_require__(/*! ./implementations/SchedulerImplem */ "./node_modules/fast-check/lib/arbitrary/_internals/implementations/SchedulerImplem.js");
function buildNextTaskIndex(mrng) {
    const clonedMrng = mrng.clone();
    return {
        clone: () => buildNextTaskIndex(clonedMrng),
        nextTaskIndex: (scheduledTasks) => {
            return mrng.nextInt(0, scheduledTasks.length - 1);
        },
    };
}
class SchedulerArbitrary extends NextArbitrary_1.NextArbitrary {
    constructor(act) {
        super();
        this.act = act;
    }
    generate(mrng, _biasFactor) {
        return new NextValue_1.NextValue(new SchedulerImplem_1.SchedulerImplem(this.act, buildNextTaskIndex(mrng.clone())), undefined);
    }
    canShrinkWithoutContext(value) {
        return false;
    }
    shrink(_value, _context) {
        return Stream_1.Stream.nil();
    }
}
exports.SchedulerArbitrary = SchedulerArbitrary;


/***/ }),

/***/ "./node_modules/fast-check/lib/arbitrary/_internals/StreamArbitrary.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/fast-check/lib/arbitrary/_internals/StreamArbitrary.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.StreamArbitrary = void 0;
const NextArbitrary_1 = __webpack_require__(/*! ../../check/arbitrary/definition/NextArbitrary */ "./node_modules/fast-check/lib/check/arbitrary/definition/NextArbitrary.js");
const NextValue_1 = __webpack_require__(/*! ../../check/arbitrary/definition/NextValue */ "./node_modules/fast-check/lib/check/arbitrary/definition/NextValue.js");
const symbols_1 = __webpack_require__(/*! ../../check/symbols */ "./node_modules/fast-check/lib/check/symbols.js");
const Stream_1 = __webpack_require__(/*! ../../stream/Stream */ "./node_modules/fast-check/lib/stream/Stream.js");
const stringify_1 = __webpack_require__(/*! ../../utils/stringify */ "./node_modules/fast-check/lib/utils/stringify.js");
function prettyPrint(seenValuesStrings) {
    return `Stream(${seenValuesStrings.join(',')})`;
}
class StreamArbitrary extends NextArbitrary_1.NextArbitrary {
    constructor(arb) {
        super();
        this.arb = arb;
    }
    generate(mrng, biasFactor) {
        const appliedBiasFactor = biasFactor !== undefined && mrng.nextInt(1, biasFactor) === 1 ? biasFactor : undefined;
        const enrichedProducer = () => {
            const seenValues = [];
            const g = function* (arb, clonedMrng) {
                while (true) {
                    const value = arb.generate(clonedMrng, appliedBiasFactor).value;
                    seenValues.push(value);
                    yield value;
                }
            };
            const s = new Stream_1.Stream(g(this.arb, mrng.clone()));
            return Object.defineProperties(s, {
                toString: { value: () => prettyPrint(seenValues.map(stringify_1.stringify)) },
                [stringify_1.toStringMethod]: { value: () => prettyPrint(seenValues.map(stringify_1.stringify)) },
                [stringify_1.asyncToStringMethod]: { value: async () => prettyPrint(await Promise.all(seenValues.map(stringify_1.asyncStringify))) },
                [symbols_1.cloneMethod]: { value: enrichedProducer, enumerable: true },
            });
        };
        return new NextValue_1.NextValue(enrichedProducer(), undefined);
    }
    canShrinkWithoutContext(value) {
        return false;
    }
    shrink(_value, _context) {
        return Stream_1.Stream.nil();
    }
}
exports.StreamArbitrary = StreamArbitrary;


/***/ }),

/***/ "./node_modules/fast-check/lib/arbitrary/_internals/TupleArbitrary.js":
/*!****************************************************************************!*\
  !*** ./node_modules/fast-check/lib/arbitrary/_internals/TupleArbitrary.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TupleArbitrary = void 0;
const Stream_1 = __webpack_require__(/*! ../../stream/Stream */ "./node_modules/fast-check/lib/stream/Stream.js");
const symbols_1 = __webpack_require__(/*! ../../check/symbols */ "./node_modules/fast-check/lib/check/symbols.js");
const NextArbitrary_1 = __webpack_require__(/*! ../../check/arbitrary/definition/NextArbitrary */ "./node_modules/fast-check/lib/check/arbitrary/definition/NextArbitrary.js");
const NextValue_1 = __webpack_require__(/*! ../../check/arbitrary/definition/NextValue */ "./node_modules/fast-check/lib/check/arbitrary/definition/NextValue.js");
class TupleArbitrary extends NextArbitrary_1.NextArbitrary {
    constructor(arbs) {
        super();
        this.arbs = arbs;
        for (let idx = 0; idx !== arbs.length; ++idx) {
            const arb = arbs[idx];
            if (arb == null || arb.generate == null)
                throw new Error(`Invalid parameter encountered at index ${idx}: expecting an Arbitrary`);
        }
    }
    static makeItCloneable(vs, values) {
        return Object.defineProperty(vs, symbols_1.cloneMethod, {
            value: () => {
                const cloned = [];
                for (let idx = 0; idx !== values.length; ++idx) {
                    cloned.push(values[idx].value);
                }
                TupleArbitrary.makeItCloneable(cloned, values);
                return cloned;
            },
        });
    }
    static wrapper(values) {
        let cloneable = false;
        const vs = [];
        const ctxs = [];
        for (let idx = 0; idx !== values.length; ++idx) {
            const v = values[idx];
            cloneable = cloneable || v.hasToBeCloned;
            vs.push(v.value);
            ctxs.push(v.context);
        }
        if (cloneable) {
            TupleArbitrary.makeItCloneable(vs, values);
        }
        return new NextValue_1.NextValue(vs, ctxs);
    }
    generate(mrng, biasFactor) {
        return TupleArbitrary.wrapper(this.arbs.map((a) => a.generate(mrng, biasFactor)));
    }
    canShrinkWithoutContext(value) {
        if (!Array.isArray(value) || value.length !== this.arbs.length) {
            return false;
        }
        for (let index = 0; index !== this.arbs.length; ++index) {
            if (!this.arbs[index].canShrinkWithoutContext(value[index])) {
                return false;
            }
        }
        return true;
    }
    shrink(value, context) {
        let s = Stream_1.Stream.nil();
        const safeContext = Array.isArray(context) ? context : [];
        for (let idx = 0; idx !== this.arbs.length; ++idx) {
            const shrinksForIndex = this.arbs[idx]
                .shrink(value[idx], safeContext[idx])
                .map((v) => {
                const nextValues = value.map((v, idx) => new NextValue_1.NextValue(symbols_1.cloneIfNeeded(v), safeContext[idx]));
                return nextValues
                    .slice(0, idx)
                    .concat([v])
                    .concat(nextValues.slice(idx + 1));
            })
                .map((values) => TupleArbitrary.wrapper(values));
            s = s.join(shrinksForIndex);
        }
        return s;
    }
}
exports.TupleArbitrary = TupleArbitrary;


/***/ }),

/***/ "./node_modules/fast-check/lib/arbitrary/_internals/builders/CharacterArbitraryBuilder.js":
/*!************************************************************************************************!*\
  !*** ./node_modules/fast-check/lib/arbitrary/_internals/builders/CharacterArbitraryBuilder.js ***!
  \************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.buildCharacterArbitrary = void 0;
const Converters_1 = __webpack_require__(/*! ../../../check/arbitrary/definition/Converters */ "./node_modules/fast-check/lib/check/arbitrary/definition/Converters.js");
const integer_1 = __webpack_require__(/*! ../../integer */ "./node_modules/fast-check/lib/arbitrary/integer.js");
const IndexToCharString_1 = __webpack_require__(/*! ../mappers/IndexToCharString */ "./node_modules/fast-check/lib/arbitrary/_internals/mappers/IndexToCharString.js");
function buildCharacterArbitrary(min, max, mapToCode, unmapFromCode) {
    return Converters_1.convertFromNext(Converters_1.convertToNext(integer_1.integer(min, max)).map((n) => IndexToCharString_1.indexToCharStringMapper(mapToCode(n)), (c) => unmapFromCode(IndexToCharString_1.indexToCharStringUnmapper(c))));
}
exports.buildCharacterArbitrary = buildCharacterArbitrary;


/***/ }),

/***/ "./node_modules/fast-check/lib/arbitrary/_internals/builders/CompareFunctionArbitraryBuilder.js":
/*!******************************************************************************************************!*\
  !*** ./node_modules/fast-check/lib/arbitrary/_internals/builders/CompareFunctionArbitraryBuilder.js ***!
  \******************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.buildCompareFunctionArbitrary = void 0;
const TextEscaper_1 = __webpack_require__(/*! ../../../check/arbitrary/helpers/TextEscaper */ "./node_modules/fast-check/lib/check/arbitrary/helpers/TextEscaper.js");
const symbols_1 = __webpack_require__(/*! ../../../check/symbols */ "./node_modules/fast-check/lib/check/symbols.js");
const hash_1 = __webpack_require__(/*! ../../../utils/hash */ "./node_modules/fast-check/lib/utils/hash.js");
const stringify_1 = __webpack_require__(/*! ../../../utils/stringify */ "./node_modules/fast-check/lib/utils/stringify.js");
const integer_1 = __webpack_require__(/*! ../../integer */ "./node_modules/fast-check/lib/arbitrary/integer.js");
const tuple_1 = __webpack_require__(/*! ../../tuple */ "./node_modules/fast-check/lib/arbitrary/tuple.js");
function buildCompareFunctionArbitrary(cmp) {
    return tuple_1.tuple(integer_1.integer().noShrink(), integer_1.integer(1, 0xffffffff).noShrink()).map(([seed, hashEnvSize]) => {
        const producer = () => {
            const recorded = {};
            const f = (a, b) => {
                const reprA = stringify_1.stringify(a);
                const reprB = stringify_1.stringify(b);
                const hA = hash_1.hash(`${seed}${reprA}`) % hashEnvSize;
                const hB = hash_1.hash(`${seed}${reprB}`) % hashEnvSize;
                const val = cmp(hA, hB);
                recorded[`[${reprA},${reprB}]`] = val;
                return val;
            };
            return Object.assign(f, {
                toString: () => {
                    const seenValues = Object.keys(recorded)
                        .sort()
                        .map((k) => `${k} => ${stringify_1.stringify(recorded[k])}`)
                        .map((line) => `/* ${TextEscaper_1.escapeForMultilineComments(line)} */`);
                    return `function(a, b) {
  // With hash and stringify coming from fast-check${seenValues.length !== 0 ? `\n  ${seenValues.join('\n  ')}` : ''}
  const cmp = ${cmp};
  const hA = hash('${seed}' + stringify(a)) % ${hashEnvSize};
  const hB = hash('${seed}' + stringify(b)) % ${hashEnvSize};
  return cmp(hA, hB);
}`;
                },
                [symbols_1.cloneMethod]: producer,
            });
        };
        return producer();
    });
}
exports.buildCompareFunctionArbitrary = buildCompareFunctionArbitrary;


/***/ }),

/***/ "./node_modules/fast-check/lib/arbitrary/_internals/builders/PartialRecordArbitraryBuilder.js":
/*!****************************************************************************************************!*\
  !*** ./node_modules/fast-check/lib/arbitrary/_internals/builders/PartialRecordArbitraryBuilder.js ***!
  \****************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.buildPartialRecordArbitrary = void 0;
const Converters_1 = __webpack_require__(/*! ../../../check/arbitrary/definition/Converters */ "./node_modules/fast-check/lib/check/arbitrary/definition/Converters.js");
const option_1 = __webpack_require__(/*! ../../option */ "./node_modules/fast-check/lib/arbitrary/option.js");
const tuple_1 = __webpack_require__(/*! ../../tuple */ "./node_modules/fast-check/lib/arbitrary/tuple.js");
const EnumerableKeysExtractor_1 = __webpack_require__(/*! ../helpers/EnumerableKeysExtractor */ "./node_modules/fast-check/lib/arbitrary/_internals/helpers/EnumerableKeysExtractor.js");
const ValuesAndSeparateKeysToObject_1 = __webpack_require__(/*! ../mappers/ValuesAndSeparateKeysToObject */ "./node_modules/fast-check/lib/arbitrary/_internals/mappers/ValuesAndSeparateKeysToObject.js");
const noKeyValue = Symbol('no-key');
function buildPartialRecordArbitrary(recordModel, requiredKeys) {
    const keys = EnumerableKeysExtractor_1.extractEnumerableKeys(recordModel);
    const arbs = [];
    for (let index = 0; index !== keys.length; ++index) {
        const k = keys[index];
        const requiredArbitrary = recordModel[k];
        if (requiredKeys === undefined || requiredKeys.indexOf(k) !== -1)
            arbs.push(requiredArbitrary);
        else
            arbs.push(option_1.option(requiredArbitrary, { nil: noKeyValue }));
    }
    return Converters_1.convertFromNext(Converters_1.convertToNext(tuple_1.tuple(...arbs)).map(ValuesAndSeparateKeysToObject_1.buildValuesAndSeparateKeysToObjectMapper(keys, noKeyValue), ValuesAndSeparateKeysToObject_1.buildValuesAndSeparateKeysToObjectUnmapper(keys, noKeyValue)));
}
exports.buildPartialRecordArbitrary = buildPartialRecordArbitrary;


/***/ }),

/***/ "./node_modules/fast-check/lib/arbitrary/_internals/builders/StringifiedNatArbitraryBuilder.js":
/*!*****************************************************************************************************!*\
  !*** ./node_modules/fast-check/lib/arbitrary/_internals/builders/StringifiedNatArbitraryBuilder.js ***!
  \*****************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.buildStringifiedNatArbitrary = void 0;
const Converters_1 = __webpack_require__(/*! ../../../check/arbitrary/definition/Converters */ "./node_modules/fast-check/lib/check/arbitrary/definition/Converters.js");
const constantFrom_1 = __webpack_require__(/*! ../../constantFrom */ "./node_modules/fast-check/lib/arbitrary/constantFrom.js");
const nat_1 = __webpack_require__(/*! ../../nat */ "./node_modules/fast-check/lib/arbitrary/nat.js");
const tuple_1 = __webpack_require__(/*! ../../tuple */ "./node_modules/fast-check/lib/arbitrary/tuple.js");
const NatToStringifiedNat_1 = __webpack_require__(/*! ../mappers/NatToStringifiedNat */ "./node_modules/fast-check/lib/arbitrary/_internals/mappers/NatToStringifiedNat.js");
function buildStringifiedNatArbitrary(maxValue) {
    return Converters_1.convertFromNext(Converters_1.convertToNext(tuple_1.tuple(constantFrom_1.constantFrom('dec', 'oct', 'hex'), nat_1.nat(maxValue))).map(NatToStringifiedNat_1.natToStringifiedNatMapper, NatToStringifiedNat_1.natToStringifiedNatUnmapper));
}
exports.buildStringifiedNatArbitrary = buildStringifiedNatArbitrary;


/***/ }),

/***/ "./node_modules/fast-check/lib/arbitrary/_internals/builders/TypedIntArrayArbitraryBuilder.js":
/*!****************************************************************************************************!*\
  !*** ./node_modules/fast-check/lib/arbitrary/_internals/builders/TypedIntArrayArbitraryBuilder.js ***!
  \****************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.typedIntArrayArbitraryArbitraryBuilder = void 0;
const array_1 = __webpack_require__(/*! ../../array */ "./node_modules/fast-check/lib/arbitrary/array.js");
function typedIntArrayArbitraryArbitraryBuilder(constraints, defaultMin, defaultMax, TypedArrayClass, arbitraryBuilder) {
    const generatorName = TypedArrayClass.name;
    const { min = defaultMin, max = defaultMax } = constraints, arrayConstraints = __rest(constraints, ["min", "max"]);
    if (min > max) {
        throw new Error(`Invalid range passed to ${generatorName}: min must be lower than or equal to max`);
    }
    if (min < defaultMin) {
        throw new Error(`Invalid min value passed to ${generatorName}: min must be greater than or equal to ${defaultMin}`);
    }
    if (max > defaultMax) {
        throw new Error(`Invalid max value passed to ${generatorName}: max must be lower than or equal to ${defaultMax}`);
    }
    return array_1.array(arbitraryBuilder({ min, max }), arrayConstraints).map((data) => TypedArrayClass.from(data));
}
exports.typedIntArrayArbitraryArbitraryBuilder = typedIntArrayArbitraryArbitraryBuilder;


/***/ }),

/***/ "./node_modules/fast-check/lib/arbitrary/_internals/helpers/BiasNumericRange.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/fast-check/lib/arbitrary/_internals/helpers/BiasNumericRange.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.biasNumericRange = exports.bigIntLogLike = exports.integerLogLike = void 0;
function integerLogLike(v) {
    return Math.floor(Math.log(v) / Math.log(2));
}
exports.integerLogLike = integerLogLike;
function bigIntLogLike(v) {
    if (v === BigInt(0))
        return BigInt(0);
    return BigInt(v.toString().length);
}
exports.bigIntLogLike = bigIntLogLike;
function biasNumericRange(min, max, logLike) {
    if (min === max) {
        return [{ min: min, max: max }];
    }
    if (min < 0 && max > 0) {
        const logMin = logLike(-min);
        const logMax = logLike(max);
        return [
            { min: -logMin, max: logMax },
            { min: (max - logMax), max: max },
            { min: min, max: min + logMin },
        ];
    }
    const logGap = logLike((max - min));
    const arbCloseToMin = { min: min, max: min + logGap };
    const arbCloseToMax = { min: (max - logGap), max: max };
    return min < 0
        ? [arbCloseToMax, arbCloseToMin]
        : [arbCloseToMin, arbCloseToMax];
}
exports.biasNumericRange = biasNumericRange;


/***/ }),

/***/ "./node_modules/fast-check/lib/arbitrary/_internals/helpers/BuildCompareFilter.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/fast-check/lib/arbitrary/_internals/helpers/BuildCompareFilter.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.buildCompareFilter = void 0;
function subArrayContains(tab, upperBound, includeValue) {
    for (let idx = 0; idx < upperBound; ++idx) {
        if (includeValue(tab[idx]))
            return true;
    }
    return false;
}
function swap(tab, idx1, idx2) {
    const temp = tab[idx1];
    tab[idx1] = tab[idx2];
    tab[idx2] = temp;
}
function buildCompareFilter(compare) {
    return (tab) => {
        let finalLength = tab.length;
        for (let idx = tab.length - 1; idx !== -1; --idx) {
            if (subArrayContains(tab, idx, (t) => compare(t.value_, tab[idx].value_))) {
                --finalLength;
                swap(tab, idx, finalLength);
            }
        }
        return tab.slice(0, finalLength);
    };
}
exports.buildCompareFilter = buildCompareFilter;


/***/ }),

/***/ "./node_modules/fast-check/lib/arbitrary/_internals/helpers/BuildSchedulerFor.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/fast-check/lib/arbitrary/_internals/helpers/BuildSchedulerFor.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.buildSchedulerFor = void 0;
const SchedulerImplem_1 = __webpack_require__(/*! ../implementations/SchedulerImplem */ "./node_modules/fast-check/lib/arbitrary/_internals/implementations/SchedulerImplem.js");
function buildNextTaskIndex(ordering) {
    let numTasks = 0;
    return {
        clone: () => buildNextTaskIndex(ordering),
        nextTaskIndex: (scheduledTasks) => {
            if (ordering.length <= numTasks) {
                throw new Error(`Invalid schedulerFor defined: too many tasks have been scheduled`);
            }
            const taskIndex = scheduledTasks.findIndex((t) => t.taskId === ordering[numTasks]);
            if (taskIndex === -1) {
                throw new Error(`Invalid schedulerFor defined: unable to find next task`);
            }
            ++numTasks;
            return taskIndex;
        },
    };
}
function buildSchedulerFor(act, ordering) {
    return new SchedulerImplem_1.SchedulerImplem(act, buildNextTaskIndex(ordering));
}
exports.buildSchedulerFor = buildSchedulerFor;


/***/ }),

/***/ "./node_modules/fast-check/lib/arbitrary/_internals/helpers/DepthContext.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/fast-check/lib/arbitrary/_internals/helpers/DepthContext.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getDepthContextFor = void 0;
const depthContextCache = new Map();
function getDepthContextFor(contextMeta) {
    if (contextMeta === undefined) {
        return { depth: 0 };
    }
    if (typeof contextMeta !== 'string') {
        return contextMeta;
    }
    const cachedContext = depthContextCache.get(contextMeta);
    if (cachedContext !== undefined) {
        return cachedContext;
    }
    const context = { depth: 0 };
    depthContextCache.set(contextMeta, context);
    return context;
}
exports.getDepthContextFor = getDepthContextFor;


/***/ }),

/***/ "./node_modules/fast-check/lib/arbitrary/_internals/helpers/EnumerableKeysExtractor.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/fast-check/lib/arbitrary/_internals/helpers/EnumerableKeysExtractor.js ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.extractEnumerableKeys = void 0;
function extractEnumerableKeys(instance) {
    const keys = Object.keys(instance);
    const symbols = Object.getOwnPropertySymbols(instance);
    for (let index = 0; index !== symbols.length; ++index) {
        const symbol = symbols[index];
        const descriptor = Object.getOwnPropertyDescriptor(instance, symbol);
        if (descriptor && descriptor.enumerable) {
            keys.push(symbol);
        }
    }
    return keys;
}
exports.extractEnumerableKeys = extractEnumerableKeys;


/***/ }),

/***/ "./node_modules/fast-check/lib/arbitrary/_internals/helpers/MaxLengthFromMinLength.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/fast-check/lib/arbitrary/_internals/helpers/MaxLengthFromMinLength.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.maxLengthFromMinLength = void 0;
function maxLengthFromMinLength(minLength) {
    return 2 * minLength + 10;
}
exports.maxLengthFromMinLength = maxLengthFromMinLength;


/***/ }),

/***/ "./node_modules/fast-check/lib/arbitrary/_internals/helpers/ShrinkBigInt.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/fast-check/lib/arbitrary/_internals/helpers/ShrinkBigInt.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.shrinkBigInt = void 0;
const Stream_1 = __webpack_require__(/*! ../../../stream/Stream */ "./node_modules/fast-check/lib/stream/Stream.js");
const NextValue_1 = __webpack_require__(/*! ../../../check/arbitrary/definition/NextValue */ "./node_modules/fast-check/lib/check/arbitrary/definition/NextValue.js");
function halveBigInt(n) {
    return n / BigInt(2);
}
function shrinkBigInt(current, target, tryTargetAsap) {
    const realGap = current - target;
    function* shrinkDecr() {
        let previous = tryTargetAsap ? undefined : target;
        const gap = tryTargetAsap ? realGap : halveBigInt(realGap);
        for (let toremove = gap; toremove > 0; toremove = halveBigInt(toremove)) {
            const next = current - toremove;
            yield new NextValue_1.NextValue(next, previous);
            previous = next;
        }
    }
    function* shrinkIncr() {
        let previous = tryTargetAsap ? undefined : target;
        const gap = tryTargetAsap ? realGap : halveBigInt(realGap);
        for (let toremove = gap; toremove < 0; toremove = halveBigInt(toremove)) {
            const next = current - toremove;
            yield new NextValue_1.NextValue(next, previous);
            previous = next;
        }
    }
    return realGap > 0 ? Stream_1.stream(shrinkDecr()) : Stream_1.stream(shrinkIncr());
}
exports.shrinkBigInt = shrinkBigInt;


/***/ }),

/***/ "./node_modules/fast-check/lib/arbitrary/_internals/helpers/ShrinkInteger.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/fast-check/lib/arbitrary/_internals/helpers/ShrinkInteger.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.shrinkInteger = void 0;
const NextValue_1 = __webpack_require__(/*! ../../../check/arbitrary/definition/NextValue */ "./node_modules/fast-check/lib/check/arbitrary/definition/NextValue.js");
const Stream_1 = __webpack_require__(/*! ../../../stream/Stream */ "./node_modules/fast-check/lib/stream/Stream.js");
function halvePosInteger(n) {
    return Math.floor(n / 2);
}
function halveNegInteger(n) {
    return Math.ceil(n / 2);
}
function shrinkInteger(current, target, tryTargetAsap) {
    const realGap = current - target;
    function* shrinkDecr() {
        let previous = tryTargetAsap ? undefined : target;
        const gap = tryTargetAsap ? realGap : halvePosInteger(realGap);
        for (let toremove = gap; toremove > 0; toremove = halvePosInteger(toremove)) {
            const next = toremove === realGap ? target : current - toremove;
            yield new NextValue_1.NextValue(next, previous);
            previous = next;
        }
    }
    function* shrinkIncr() {
        let previous = tryTargetAsap ? undefined : target;
        const gap = tryTargetAsap ? realGap : halveNegInteger(realGap);
        for (let toremove = gap; toremove < 0; toremove = halveNegInteger(toremove)) {
            const next = toremove === realGap ? target : current - toremove;
            yield new NextValue_1.NextValue(next, previous);
            previous = next;
        }
    }
    return realGap > 0 ? Stream_1.stream(shrinkDecr()) : Stream_1.stream(shrinkIncr());
}
exports.shrinkInteger = shrinkInteger;


/***/ }),

/***/ "./node_modules/fast-check/lib/arbitrary/_internals/helpers/StringConstraintsExtractor.js":
/*!************************************************************************************************!*\
  !*** ./node_modules/fast-check/lib/arbitrary/_internals/helpers/StringConstraintsExtractor.js ***!
  \************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.extractStringConstraints = void 0;
function extractStringConstraints(options) {
    return options[0] !== undefined
        ? typeof options[0] === 'number'
            ? typeof options[1] === 'number'
                ? { minLength: options[0], maxLength: options[1] }
                : { maxLength: options[0] }
            : options[0]
        : {};
}
exports.extractStringConstraints = extractStringConstraints;


/***/ }),

/***/ "./node_modules/fast-check/lib/arbitrary/_internals/implementations/SchedulerImplem.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/fast-check/lib/arbitrary/_internals/implementations/SchedulerImplem.js ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SchedulerImplem = void 0;
const TextEscaper_1 = __webpack_require__(/*! ../../../check/arbitrary/helpers/TextEscaper */ "./node_modules/fast-check/lib/check/arbitrary/helpers/TextEscaper.js");
const symbols_1 = __webpack_require__(/*! ../../../check/symbols */ "./node_modules/fast-check/lib/check/symbols.js");
const stringify_1 = __webpack_require__(/*! ../../../utils/stringify */ "./node_modules/fast-check/lib/utils/stringify.js");
class SchedulerImplem {
    constructor(act, taskSelector) {
        this.act = act;
        this.taskSelector = taskSelector;
        this.lastTaskId = 0;
        this.sourceTaskSelector = taskSelector.clone();
        this.scheduledTasks = [];
        this.triggeredTasks = [];
    }
    static buildLog(reportItem) {
        return `[task\${${reportItem.taskId}}] ${reportItem.label.length !== 0 ? `${reportItem.schedulingType}::${reportItem.label}` : reportItem.schedulingType} ${reportItem.status}${reportItem.outputValue !== undefined ? ` with value ${TextEscaper_1.escapeForTemplateString(reportItem.outputValue)}` : ''}`;
    }
    log(schedulingType, taskId, label, metadata, status, data) {
        this.triggeredTasks.push({
            status,
            schedulingType,
            taskId,
            label,
            metadata,
            outputValue: data !== undefined ? stringify_1.stringify(data) : undefined,
        });
    }
    scheduleInternal(schedulingType, label, task, metadata, thenTaskToBeAwaited) {
        let trigger = null;
        const taskId = ++this.lastTaskId;
        const scheduledPromise = new Promise((resolve, reject) => {
            trigger = () => {
                (thenTaskToBeAwaited ? task.then(() => thenTaskToBeAwaited()) : task).then((data) => {
                    this.log(schedulingType, taskId, label, metadata, 'resolved', data);
                    return resolve(data);
                }, (err) => {
                    this.log(schedulingType, taskId, label, metadata, 'rejected', err);
                    return reject(err);
                });
            };
        });
        this.scheduledTasks.push({
            original: task,
            scheduled: scheduledPromise,
            trigger: trigger,
            schedulingType,
            taskId,
            label,
            metadata,
        });
        return scheduledPromise;
    }
    schedule(task, label, metadata) {
        return this.scheduleInternal('promise', label || '', task, metadata);
    }
    scheduleFunction(asyncFunction) {
        return (...args) => this.scheduleInternal('function', `${asyncFunction.name}(${args.map(stringify_1.stringify).join(',')})`, asyncFunction(...args), undefined);
    }
    scheduleSequence(sequenceBuilders) {
        const status = { done: false, faulty: false };
        const dummyResolvedPromise = { then: (f) => f() };
        let resolveSequenceTask = () => { };
        const sequenceTask = new Promise((resolve) => (resolveSequenceTask = resolve));
        sequenceBuilders
            .reduce((previouslyScheduled, item) => {
            const [builder, label, metadata] = typeof item === 'function' ? [item, item.name, undefined] : [item.builder, item.label, item.metadata];
            return previouslyScheduled.then(() => {
                const scheduled = this.scheduleInternal('sequence', label, dummyResolvedPromise, metadata, () => builder());
                scheduled.catch(() => {
                    status.faulty = true;
                    resolveSequenceTask();
                });
                return scheduled;
            });
        }, dummyResolvedPromise)
            .then(() => {
            status.done = true;
            resolveSequenceTask();
        }, () => {
        });
        return Object.assign(status, {
            task: Promise.resolve(sequenceTask).then(() => {
                return { done: status.done, faulty: status.faulty };
            }),
        });
    }
    count() {
        return this.scheduledTasks.length;
    }
    async internalWaitOne() {
        if (this.scheduledTasks.length === 0) {
            throw new Error('No task scheduled');
        }
        const taskIndex = this.taskSelector.nextTaskIndex(this.scheduledTasks);
        const [scheduledTask] = this.scheduledTasks.splice(taskIndex, 1);
        scheduledTask.trigger();
        try {
            await scheduledTask.scheduled;
        }
        catch (_err) {
        }
    }
    async waitOne() {
        await this.act(async () => await this.internalWaitOne());
    }
    async waitAll() {
        while (this.scheduledTasks.length > 0) {
            await this.waitOne();
        }
    }
    report() {
        return [
            ...this.triggeredTasks,
            ...this.scheduledTasks.map((t) => ({
                status: 'pending',
                schedulingType: t.schedulingType,
                taskId: t.taskId,
                label: t.label,
                metadata: t.metadata,
            })),
        ];
    }
    toString() {
        return ('schedulerFor()`\n' +
            this.report()
                .map(SchedulerImplem.buildLog)
                .map((log) => `-> ${log}`)
                .join('\n') +
            '`');
    }
    [symbols_1.cloneMethod]() {
        return new SchedulerImplem(this.act, this.sourceTaskSelector);
    }
}
exports.SchedulerImplem = SchedulerImplem;


/***/ }),

/***/ "./node_modules/fast-check/lib/arbitrary/_internals/mappers/CharsToString.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/fast-check/lib/arbitrary/_internals/mappers/CharsToString.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.charsToStringUnmapper = exports.charsToStringMapper = void 0;
function charsToStringMapper(tab) {
    return tab.join('');
}
exports.charsToStringMapper = charsToStringMapper;
function charsToStringUnmapper(value) {
    if (typeof value !== 'string') {
        throw new Error('Cannot unmap the passed value');
    }
    return value.split('');
}
exports.charsToStringUnmapper = charsToStringUnmapper;


/***/ }),

/***/ "./node_modules/fast-check/lib/arbitrary/_internals/mappers/CodePointsToString.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/fast-check/lib/arbitrary/_internals/mappers/CodePointsToString.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.codePointsToStringUnmapper = exports.codePointsToStringMapper = void 0;
function codePointsToStringMapper(tab) {
    return tab.join('');
}
exports.codePointsToStringMapper = codePointsToStringMapper;
function codePointsToStringUnmapper(value) {
    if (typeof value !== 'string') {
        throw new Error('Cannot unmap the passed value');
    }
    return [...value];
}
exports.codePointsToStringUnmapper = codePointsToStringUnmapper;


/***/ }),

/***/ "./node_modules/fast-check/lib/arbitrary/_internals/mappers/EntitiesToIPv6.js":
/*!************************************************************************************!*\
  !*** ./node_modules/fast-check/lib/arbitrary/_internals/mappers/EntitiesToIPv6.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.noTrailingUnmapper = exports.noTrailingMapper = exports.singleTrailingUnmapper = exports.singleTrailingMapper = exports.multiTrailingUnmapperOne = exports.multiTrailingMapperOne = exports.multiTrailingUnmapper = exports.multiTrailingMapper = exports.onlyTrailingUnmapper = exports.onlyTrailingMapper = exports.fullySpecifiedUnmapper = exports.fullySpecifiedMapper = void 0;
function readBh(value) {
    if (value.length === 0)
        return [];
    else
        return value.split(':');
}
function extractEhAndL(value) {
    const valueSplits = value.split(':');
    if (valueSplits.length >= 2 && valueSplits[valueSplits.length - 1].length <= 4) {
        return [
            valueSplits.slice(0, valueSplits.length - 2),
            `${valueSplits[valueSplits.length - 2]}:${valueSplits[valueSplits.length - 1]}`,
        ];
    }
    return [valueSplits.slice(0, valueSplits.length - 1), valueSplits[valueSplits.length - 1]];
}
function fullySpecifiedMapper(data) {
    return `${data[0].join(':')}:${data[1]}`;
}
exports.fullySpecifiedMapper = fullySpecifiedMapper;
function fullySpecifiedUnmapper(value) {
    if (typeof value !== 'string')
        throw new Error('Invalid type');
    return extractEhAndL(value);
}
exports.fullySpecifiedUnmapper = fullySpecifiedUnmapper;
function onlyTrailingMapper(data) {
    return `::${data[0].join(':')}:${data[1]}`;
}
exports.onlyTrailingMapper = onlyTrailingMapper;
function onlyTrailingUnmapper(value) {
    if (typeof value !== 'string')
        throw new Error('Invalid type');
    if (!value.startsWith('::'))
        throw new Error('Invalid value');
    return extractEhAndL(value.substring(2));
}
exports.onlyTrailingUnmapper = onlyTrailingUnmapper;
function multiTrailingMapper(data) {
    return `${data[0].join(':')}::${data[1].join(':')}:${data[2]}`;
}
exports.multiTrailingMapper = multiTrailingMapper;
function multiTrailingUnmapper(value) {
    if (typeof value !== 'string')
        throw new Error('Invalid type');
    const [bhString, trailingString] = value.split('::', 2);
    const [eh, l] = extractEhAndL(trailingString);
    return [readBh(bhString), eh, l];
}
exports.multiTrailingUnmapper = multiTrailingUnmapper;
function multiTrailingMapperOne(data) {
    return multiTrailingMapper([data[0], [data[1]], data[2]]);
}
exports.multiTrailingMapperOne = multiTrailingMapperOne;
function multiTrailingUnmapperOne(value) {
    const out = multiTrailingUnmapper(value);
    return [out[0], out[1].join(':'), out[2]];
}
exports.multiTrailingUnmapperOne = multiTrailingUnmapperOne;
function singleTrailingMapper(data) {
    return `${data[0].join(':')}::${data[1]}`;
}
exports.singleTrailingMapper = singleTrailingMapper;
function singleTrailingUnmapper(value) {
    if (typeof value !== 'string')
        throw new Error('Invalid type');
    const [bhString, trailing] = value.split('::', 2);
    return [readBh(bhString), trailing];
}
exports.singleTrailingUnmapper = singleTrailingUnmapper;
function noTrailingMapper(data) {
    return `${data[0].join(':')}::`;
}
exports.noTrailingMapper = noTrailingMapper;
function noTrailingUnmapper(value) {
    if (typeof value !== 'string')
        throw new Error('Invalid type');
    if (!value.endsWith('::'))
        throw new Error('Invalid value');
    return [readBh(value.substring(0, value.length - 2))];
}
exports.noTrailingUnmapper = noTrailingUnmapper;


/***/ }),

/***/ "./node_modules/fast-check/lib/arbitrary/_internals/mappers/IndexToCharString.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/fast-check/lib/arbitrary/_internals/mappers/IndexToCharString.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.indexToCharStringUnmapper = exports.indexToCharStringMapper = void 0;
exports.indexToCharStringMapper = String.fromCodePoint;
function indexToCharStringUnmapper(c) {
    if (typeof c !== 'string') {
        throw new Error('Cannot unmap non-string');
    }
    if (c.length === 0 || c.length > 2) {
        throw new Error('Cannot unmap string with more or less than one character');
    }
    const c1 = c.charCodeAt(0);
    if (c.length === 1) {
        return c1;
    }
    const c2 = c.charCodeAt(1);
    if (c1 < 0xd800 || c1 > 0xdbff || c2 < 0xdc00 || c2 > 0xdfff) {
        throw new Error('Cannot unmap invalid surrogate pairs');
    }
    return c.codePointAt(0);
}
exports.indexToCharStringUnmapper = indexToCharStringUnmapper;


/***/ }),

/***/ "./node_modules/fast-check/lib/arbitrary/_internals/mappers/IndexToMappedConstant.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/fast-check/lib/arbitrary/_internals/mappers/IndexToMappedConstant.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.indexToMappedConstantUnmapperFor = exports.indexToMappedConstantMapperFor = void 0;
function indexToMappedConstantMapperFor(entries) {
    return function indexToMappedConstantMapper(choiceIndex) {
        let idx = -1;
        let numSkips = 0;
        while (choiceIndex >= numSkips) {
            numSkips += entries[++idx].num;
        }
        return entries[idx].build(choiceIndex - numSkips + entries[idx].num);
    };
}
exports.indexToMappedConstantMapperFor = indexToMappedConstantMapperFor;
function buildReverseMapping(entries) {
    const reverseMapping = { mapping: new Map(), negativeZeroIndex: undefined };
    let choiceIndex = 0;
    for (let entryIdx = 0; entryIdx !== entries.length; ++entryIdx) {
        const entry = entries[entryIdx];
        for (let idxInEntry = 0; idxInEntry !== entry.num; ++idxInEntry) {
            const value = entry.build(idxInEntry);
            if (value === 0 && 1 / value === Number.NEGATIVE_INFINITY) {
                reverseMapping.negativeZeroIndex = choiceIndex;
            }
            else {
                reverseMapping.mapping.set(value, choiceIndex);
            }
            ++choiceIndex;
        }
    }
    return reverseMapping;
}
function indexToMappedConstantUnmapperFor(entries) {
    let reverseMapping = null;
    return function indexToMappedConstantUnmapper(value) {
        if (reverseMapping === null) {
            reverseMapping = buildReverseMapping(entries);
        }
        const choiceIndex = Object.is(value, -0) ? reverseMapping.negativeZeroIndex : reverseMapping.mapping.get(value);
        if (choiceIndex === undefined) {
            throw new Error('Unknown value encountered cannot be built using this mapToConstant');
        }
        return choiceIndex;
    };
}
exports.indexToMappedConstantUnmapperFor = indexToMappedConstantUnmapperFor;


/***/ }),

/***/ "./node_modules/fast-check/lib/arbitrary/_internals/mappers/IndexToPrintableIndex.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/fast-check/lib/arbitrary/_internals/mappers/IndexToPrintableIndex.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.indexToPrintableIndexUnmapper = exports.indexToPrintableIndexMapper = void 0;
function indexToPrintableIndexMapper(v) {
    if (v < 95)
        return v + 0x20;
    if (v <= 0x7e)
        return v - 95;
    return v;
}
exports.indexToPrintableIndexMapper = indexToPrintableIndexMapper;
function indexToPrintableIndexUnmapper(v) {
    if (v >= 0x20 && v <= 0x7e)
        return v - 0x20;
    if (v >= 0 && v <= 0x1f)
        return v + 95;
    return v;
}
exports.indexToPrintableIndexUnmapper = indexToPrintableIndexUnmapper;


/***/ }),

/***/ "./node_modules/fast-check/lib/arbitrary/_internals/mappers/KeyValuePairsToObject.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/fast-check/lib/arbitrary/_internals/mappers/KeyValuePairsToObject.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.keyValuePairsToObjectUnmapper = exports.keyValuePairsToObjectMapper = void 0;
function keyValuePairsToObjectMapper(items) {
    const obj = {};
    for (const keyValue of items) {
        obj[keyValue[0]] = keyValue[1];
    }
    return obj;
}
exports.keyValuePairsToObjectMapper = keyValuePairsToObjectMapper;
function buildInvalidPropertyNameFilter(obj) {
    return function invalidPropertyNameFilter(key) {
        const descriptor = Object.getOwnPropertyDescriptor(obj, key);
        return (descriptor === undefined ||
            !descriptor.configurable ||
            !descriptor.enumerable ||
            !descriptor.writable ||
            descriptor.get !== undefined ||
            descriptor.set !== undefined);
    };
}
function keyValuePairsToObjectUnmapper(value) {
    if (typeof value !== 'object' || value === null) {
        throw new Error('Incompatible instance received: should be a non-null object');
    }
    if (!('constructor' in value) || value.constructor !== Object) {
        throw new Error('Incompatible instance received: should be of exact type Object');
    }
    if (Object.getOwnPropertySymbols(value).length > 0) {
        throw new Error('Incompatible instance received: should contain symbols');
    }
    if (Object.getOwnPropertyNames(value).find(buildInvalidPropertyNameFilter(value)) !== undefined) {
        throw new Error('Incompatible instance received: should contain only c/e/w properties without get/set');
    }
    return Object.entries(value);
}
exports.keyValuePairsToObjectUnmapper = keyValuePairsToObjectUnmapper;


/***/ }),

/***/ "./node_modules/fast-check/lib/arbitrary/_internals/mappers/NatToStringifiedNat.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/fast-check/lib/arbitrary/_internals/mappers/NatToStringifiedNat.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.natToStringifiedNatUnmapper = exports.tryParseStringifiedNat = exports.natToStringifiedNatMapper = void 0;
function natToStringifiedNatMapper(options) {
    const [style, v] = options;
    switch (style) {
        case 'oct':
            return `0${Number(v).toString(8)}`;
        case 'hex':
            return `0x${Number(v).toString(16)}`;
        case 'dec':
        default:
            return `${v}`;
    }
}
exports.natToStringifiedNatMapper = natToStringifiedNatMapper;
function tryParseStringifiedNat(stringValue, radix) {
    const parsedNat = Number.parseInt(stringValue, radix);
    if (parsedNat.toString(radix) !== stringValue) {
        throw new Error('Invalid value');
    }
    return parsedNat;
}
exports.tryParseStringifiedNat = tryParseStringifiedNat;
function natToStringifiedNatUnmapper(value) {
    if (typeof value !== 'string') {
        throw new Error('Invalid type');
    }
    if (value.length >= 2 && value[0] === '0') {
        if (value[1] === 'x') {
            return ['hex', tryParseStringifiedNat(value.substr(2), 16)];
        }
        return ['oct', tryParseStringifiedNat(value.substr(1), 8)];
    }
    return ['dec', tryParseStringifiedNat(value, 10)];
}
exports.natToStringifiedNatUnmapper = natToStringifiedNatUnmapper;


/***/ }),

/***/ "./node_modules/fast-check/lib/arbitrary/_internals/mappers/PatternsToString.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/fast-check/lib/arbitrary/_internals/mappers/PatternsToString.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.patternsToStringUnmapperFor = exports.patternsToStringMapper = void 0;
const MaxLengthFromMinLength_1 = __webpack_require__(/*! ../helpers/MaxLengthFromMinLength */ "./node_modules/fast-check/lib/arbitrary/_internals/helpers/MaxLengthFromMinLength.js");
function patternsToStringMapper(tab) {
    return tab.join('');
}
exports.patternsToStringMapper = patternsToStringMapper;
function patternsToStringUnmapperFor(patternsArb, constraints) {
    return function patternsToStringUnmapper(value) {
        if (typeof value !== 'string') {
            throw new Error('Unsupported value');
        }
        const minLength = constraints.minLength !== undefined ? constraints.minLength : 0;
        const maxLength = constraints.maxLength !== undefined ? constraints.maxLength : MaxLengthFromMinLength_1.maxLengthFromMinLength(minLength);
        if (value.length === 0) {
            if (minLength > 0) {
                throw new Error('Unable to unmap received string');
            }
            return [];
        }
        const stack = [{ endIndexChunks: 0, nextStartIndex: 1, chunks: [] }];
        while (stack.length > 0) {
            const last = stack.pop();
            for (let index = last.nextStartIndex; index <= value.length; ++index) {
                const chunk = value.substring(last.endIndexChunks, index);
                if (patternsArb.canShrinkWithoutContext(chunk)) {
                    const newChunks = last.chunks.concat([chunk]);
                    if (index === value.length) {
                        if (newChunks.length < minLength || newChunks.length > maxLength) {
                            break;
                        }
                        return newChunks;
                    }
                    stack.push({ endIndexChunks: last.endIndexChunks, nextStartIndex: index + 1, chunks: last.chunks });
                    stack.push({ endIndexChunks: index, nextStartIndex: index + 1, chunks: newChunks });
                    break;
                }
            }
        }
        throw new Error('Unable to unmap received string');
    };
}
exports.patternsToStringUnmapperFor = patternsToStringUnmapperFor;


/***/ }),

/***/ "./node_modules/fast-check/lib/arbitrary/_internals/mappers/StringToBase64.js":
/*!************************************************************************************!*\
  !*** ./node_modules/fast-check/lib/arbitrary/_internals/mappers/StringToBase64.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.stringToBase64Unmapper = exports.stringToBase64Mapper = void 0;
function stringToBase64Mapper(s) {
    switch (s.length % 4) {
        case 0:
            return s;
        case 3:
            return `${s}=`;
        case 2:
            return `${s}==`;
        default:
            return s.slice(1);
    }
}
exports.stringToBase64Mapper = stringToBase64Mapper;
function stringToBase64Unmapper(value) {
    if (typeof value !== 'string' || value.length % 4 !== 0) {
        throw new Error('Invalid string received');
    }
    const lastTrailingIndex = value.indexOf('=');
    if (lastTrailingIndex === -1) {
        return value;
    }
    const numTrailings = value.length - lastTrailingIndex;
    if (numTrailings > 2) {
        throw new Error('Cannot unmap the passed value');
    }
    return value.substring(0, lastTrailingIndex);
}
exports.stringToBase64Unmapper = stringToBase64Unmapper;


/***/ }),

/***/ "./node_modules/fast-check/lib/arbitrary/_internals/mappers/TimeToDate.js":
/*!********************************************************************************!*\
  !*** ./node_modules/fast-check/lib/arbitrary/_internals/mappers/TimeToDate.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.timeToDateUnmapper = exports.timeToDateMapper = void 0;
function timeToDateMapper(time) {
    return new Date(time);
}
exports.timeToDateMapper = timeToDateMapper;
function timeToDateUnmapper(value) {
    if (!(value instanceof Date) || value.constructor !== Date) {
        throw new Error('Not a valid value for date unmapper');
    }
    return value.getTime();
}
exports.timeToDateUnmapper = timeToDateUnmapper;


/***/ }),

/***/ "./node_modules/fast-check/lib/arbitrary/_internals/mappers/ValuesAndSeparateKeysToObject.js":
/*!***************************************************************************************************!*\
  !*** ./node_modules/fast-check/lib/arbitrary/_internals/mappers/ValuesAndSeparateKeysToObject.js ***!
  \***************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.buildValuesAndSeparateKeysToObjectUnmapper = exports.buildValuesAndSeparateKeysToObjectMapper = void 0;
function buildValuesAndSeparateKeysToObjectMapper(keys, noKeyValue) {
    return function valuesAndSeparateKeysToObjectMapper(gs) {
        const obj = {};
        for (let idx = 0; idx !== keys.length; ++idx) {
            const valueWrapper = gs[idx];
            if (valueWrapper !== noKeyValue) {
                obj[keys[idx]] = valueWrapper;
            }
        }
        return obj;
    };
}
exports.buildValuesAndSeparateKeysToObjectMapper = buildValuesAndSeparateKeysToObjectMapper;
function buildValuesAndSeparateKeysToObjectUnmapper(keys, noKeyValue) {
    return function valuesAndSeparateKeysToObjectUnmapper(value) {
        if (typeof value !== 'object' || value === null) {
            throw new Error('Incompatible instance received: should be a non-null object');
        }
        if (!('constructor' in value) || value.constructor !== Object) {
            throw new Error('Incompatible instance received: should be of exact type Object');
        }
        let extractedPropertiesCount = 0;
        const extractedValues = [];
        for (let idx = 0; idx !== keys.length; ++idx) {
            const descriptor = Object.getOwnPropertyDescriptor(value, keys[idx]);
            if (descriptor !== undefined) {
                if (!descriptor.configurable || !descriptor.enumerable || !descriptor.writable) {
                    throw new Error('Incompatible instance received: should contain only c/e/w properties');
                }
                if (descriptor.get !== undefined || descriptor.set !== undefined) {
                    throw new Error('Incompatible instance received: should contain only no get/set properties');
                }
                ++extractedPropertiesCount;
                extractedValues.push(descriptor.value);
            }
            else {
                extractedValues.push(noKeyValue);
            }
        }
        const namePropertiesCount = Object.getOwnPropertyNames(value).length;
        const symbolPropertiesCount = Object.getOwnPropertySymbols(value).length;
        if (extractedPropertiesCount !== namePropertiesCount + symbolPropertiesCount) {
            throw new Error('Incompatible instance received: should not contain extra properties');
        }
        return extractedValues;
    };
}
exports.buildValuesAndSeparateKeysToObjectUnmapper = buildValuesAndSeparateKeysToObjectUnmapper;


/***/ }),

/***/ "./node_modules/fast-check/lib/arbitrary/_internals/mappers/WordsToLorem.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/fast-check/lib/arbitrary/_internals/mappers/WordsToLorem.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.sentencesToParagraphUnmapper = exports.sentencesToParagraphMapper = exports.wordsToSentenceUnmapperFor = exports.wordsToSentenceMapper = exports.wordsToJoinedStringUnmapperFor = exports.wordsToJoinedStringMapper = void 0;
function wordsToJoinedStringMapper(words) {
    return words.map((w) => (w[w.length - 1] === ',' ? w.substr(0, w.length - 1) : w)).join(' ');
}
exports.wordsToJoinedStringMapper = wordsToJoinedStringMapper;
function wordsToJoinedStringUnmapperFor(wordsArbitrary) {
    return function wordsToJoinedStringUnmapper(value) {
        if (typeof value !== 'string') {
            throw new Error('Unsupported type');
        }
        const words = [];
        for (const candidate of value.split(' ')) {
            if (wordsArbitrary.canShrinkWithoutContext(candidate))
                words.push(candidate);
            else if (wordsArbitrary.canShrinkWithoutContext(candidate + ','))
                words.push(candidate + ',');
            else
                throw new Error('Unsupported word');
        }
        return words;
    };
}
exports.wordsToJoinedStringUnmapperFor = wordsToJoinedStringUnmapperFor;
function wordsToSentenceMapper(words) {
    let sentence = words.join(' ');
    if (sentence[sentence.length - 1] === ',') {
        sentence = sentence.substr(0, sentence.length - 1);
    }
    return sentence[0].toUpperCase() + sentence.substring(1) + '.';
}
exports.wordsToSentenceMapper = wordsToSentenceMapper;
function wordsToSentenceUnmapperFor(wordsArbitrary) {
    return function wordsToSentenceUnmapper(value) {
        if (typeof value !== 'string') {
            throw new Error('Unsupported type');
        }
        if (value.length < 2 ||
            value[value.length - 1] !== '.' ||
            value[value.length - 2] === ',' ||
            value[0].toLowerCase().toUpperCase() !== value[0]) {
            throw new Error('Unsupported value');
        }
        const adaptedValue = value[0].toLowerCase() + value.substring(1, value.length - 1);
        const words = [];
        const candidates = adaptedValue.split(' ');
        for (let idx = 0; idx !== candidates.length; ++idx) {
            const candidate = candidates[idx];
            if (wordsArbitrary.canShrinkWithoutContext(candidate))
                words.push(candidate);
            else if (idx === candidates.length - 1 && wordsArbitrary.canShrinkWithoutContext(candidate + ','))
                words.push(candidate + ',');
            else
                throw new Error('Unsupported word');
        }
        return words;
    };
}
exports.wordsToSentenceUnmapperFor = wordsToSentenceUnmapperFor;
function sentencesToParagraphMapper(sentences) {
    return sentences.join(' ');
}
exports.sentencesToParagraphMapper = sentencesToParagraphMapper;
function sentencesToParagraphUnmapper(value) {
    if (typeof value !== 'string') {
        throw new Error('Unsupported type');
    }
    const sentences = value.split('. ');
    for (let idx = 0; idx < sentences.length - 1; ++idx) {
        sentences[idx] += '.';
    }
    return sentences;
}
exports.sentencesToParagraphUnmapper = sentencesToParagraphUnmapper;


/***/ }),

/***/ "./node_modules/fast-check/lib/arbitrary/array.js":
/*!********************************************************!*\
  !*** ./node_modules/fast-check/lib/arbitrary/array.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.array = void 0;
const Converters_1 = __webpack_require__(/*! ../check/arbitrary/definition/Converters */ "./node_modules/fast-check/lib/check/arbitrary/definition/Converters.js");
const ArrayArbitrary_1 = __webpack_require__(/*! ./_internals/ArrayArbitrary */ "./node_modules/fast-check/lib/arbitrary/_internals/ArrayArbitrary.js");
const MaxLengthFromMinLength_1 = __webpack_require__(/*! ./_internals/helpers/MaxLengthFromMinLength */ "./node_modules/fast-check/lib/arbitrary/_internals/helpers/MaxLengthFromMinLength.js");
function array(arb, ...args) {
    const nextArb = Converters_1.convertToNext(arb);
    if (args[0] === undefined)
        return Converters_1.convertFromNext(new ArrayArbitrary_1.ArrayArbitrary(nextArb, 0, MaxLengthFromMinLength_1.maxLengthFromMinLength(0)));
    if (typeof args[0] === 'object') {
        const minLength = args[0].minLength || 0;
        const specifiedMaxLength = args[0].maxLength;
        const maxLength = specifiedMaxLength !== undefined ? specifiedMaxLength : MaxLengthFromMinLength_1.maxLengthFromMinLength(minLength);
        return Converters_1.convertFromNext(new ArrayArbitrary_1.ArrayArbitrary(nextArb, minLength, maxLength));
    }
    if (args[1] !== undefined)
        return Converters_1.convertFromNext(new ArrayArbitrary_1.ArrayArbitrary(nextArb, args[0], args[1]));
    return Converters_1.convertFromNext(new ArrayArbitrary_1.ArrayArbitrary(nextArb, 0, args[0]));
}
exports.array = array;


/***/ }),

/***/ "./node_modules/fast-check/lib/arbitrary/ascii.js":
/*!********************************************************!*\
  !*** ./node_modules/fast-check/lib/arbitrary/ascii.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ascii = void 0;
const CharacterArbitraryBuilder_1 = __webpack_require__(/*! ./_internals/builders/CharacterArbitraryBuilder */ "./node_modules/fast-check/lib/arbitrary/_internals/builders/CharacterArbitraryBuilder.js");
const IndexToPrintableIndex_1 = __webpack_require__(/*! ./_internals/mappers/IndexToPrintableIndex */ "./node_modules/fast-check/lib/arbitrary/_internals/mappers/IndexToPrintableIndex.js");
function ascii() {
    return CharacterArbitraryBuilder_1.buildCharacterArbitrary(0x00, 0x7f, IndexToPrintableIndex_1.indexToPrintableIndexMapper, IndexToPrintableIndex_1.indexToPrintableIndexUnmapper);
}
exports.ascii = ascii;


/***/ }),

/***/ "./node_modules/fast-check/lib/arbitrary/asciiString.js":
/*!**************************************************************!*\
  !*** ./node_modules/fast-check/lib/arbitrary/asciiString.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.asciiString = void 0;
const Converters_1 = __webpack_require__(/*! ../check/arbitrary/definition/Converters */ "./node_modules/fast-check/lib/check/arbitrary/definition/Converters.js");
const array_1 = __webpack_require__(/*! ./array */ "./node_modules/fast-check/lib/arbitrary/array.js");
const ascii_1 = __webpack_require__(/*! ./ascii */ "./node_modules/fast-check/lib/arbitrary/ascii.js");
const StringConstraintsExtractor_1 = __webpack_require__(/*! ./_internals/helpers/StringConstraintsExtractor */ "./node_modules/fast-check/lib/arbitrary/_internals/helpers/StringConstraintsExtractor.js");
const CodePointsToString_1 = __webpack_require__(/*! ./_internals/mappers/CodePointsToString */ "./node_modules/fast-check/lib/arbitrary/_internals/mappers/CodePointsToString.js");
function asciiString(...args) {
    const constraints = StringConstraintsExtractor_1.extractStringConstraints(args);
    return Converters_1.convertFromNext(Converters_1.convertToNext(array_1.array(ascii_1.ascii(), constraints)).map(CodePointsToString_1.codePointsToStringMapper, CodePointsToString_1.codePointsToStringUnmapper));
}
exports.asciiString = asciiString;


/***/ }),

/***/ "./node_modules/fast-check/lib/arbitrary/base64.js":
/*!*********************************************************!*\
  !*** ./node_modules/fast-check/lib/arbitrary/base64.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.base64 = void 0;
const CharacterArbitraryBuilder_1 = __webpack_require__(/*! ./_internals/builders/CharacterArbitraryBuilder */ "./node_modules/fast-check/lib/arbitrary/_internals/builders/CharacterArbitraryBuilder.js");
function base64Mapper(v) {
    if (v < 26)
        return v + 65;
    if (v < 52)
        return v + 97 - 26;
    if (v < 62)
        return v + 48 - 52;
    return v === 62 ? 43 : 47;
}
function base64Unmapper(v) {
    if (v >= 65 && v <= 90)
        return v - 65;
    if (v >= 97 && v <= 122)
        return v - 97 + 26;
    if (v >= 48 && v <= 57)
        return v - 48 + 52;
    return v === 43 ? 62 : v === 47 ? 63 : -1;
}
function base64() {
    return CharacterArbitraryBuilder_1.buildCharacterArbitrary(0, 63, base64Mapper, base64Unmapper);
}
exports.base64 = base64;


/***/ }),

/***/ "./node_modules/fast-check/lib/arbitrary/base64String.js":
/*!***************************************************************!*\
  !*** ./node_modules/fast-check/lib/arbitrary/base64String.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.base64String = void 0;
const Converters_1 = __webpack_require__(/*! ../check/arbitrary/definition/Converters */ "./node_modules/fast-check/lib/check/arbitrary/definition/Converters.js");
const array_1 = __webpack_require__(/*! ./array */ "./node_modules/fast-check/lib/arbitrary/array.js");
const base64_1 = __webpack_require__(/*! ./base64 */ "./node_modules/fast-check/lib/arbitrary/base64.js");
const MaxLengthFromMinLength_1 = __webpack_require__(/*! ./_internals/helpers/MaxLengthFromMinLength */ "./node_modules/fast-check/lib/arbitrary/_internals/helpers/MaxLengthFromMinLength.js");
const StringConstraintsExtractor_1 = __webpack_require__(/*! ./_internals/helpers/StringConstraintsExtractor */ "./node_modules/fast-check/lib/arbitrary/_internals/helpers/StringConstraintsExtractor.js");
const CodePointsToString_1 = __webpack_require__(/*! ./_internals/mappers/CodePointsToString */ "./node_modules/fast-check/lib/arbitrary/_internals/mappers/CodePointsToString.js");
const StringToBase64_1 = __webpack_require__(/*! ./_internals/mappers/StringToBase64 */ "./node_modules/fast-check/lib/arbitrary/_internals/mappers/StringToBase64.js");
function extractMinMaxConstraints(args) {
    const constraints = StringConstraintsExtractor_1.extractStringConstraints(args);
    const minLength = constraints.minLength !== undefined ? constraints.minLength : 0;
    const maxLength = constraints.maxLength !== undefined ? constraints.maxLength : MaxLengthFromMinLength_1.maxLengthFromMinLength(minLength);
    return { minLength, maxLength };
}
function base64String(...args) {
    const constraints = extractMinMaxConstraints(args);
    const unscaledMinLength = constraints.minLength;
    const unscaledMaxLength = constraints.maxLength;
    const minLength = unscaledMinLength + 3 - ((unscaledMinLength + 3) % 4);
    const maxLength = unscaledMaxLength - (unscaledMaxLength % 4);
    if (minLength > maxLength)
        throw new Error('Minimal length should be inferior or equal to maximal length');
    if (minLength % 4 !== 0)
        throw new Error('Minimal length of base64 strings must be a multiple of 4');
    if (maxLength % 4 !== 0)
        throw new Error('Maximal length of base64 strings must be a multiple of 4');
    return Converters_1.convertFromNext(Converters_1.convertToNext(array_1.array(base64_1.base64(), { minLength, maxLength }))
        .map(CodePointsToString_1.codePointsToStringMapper, CodePointsToString_1.codePointsToStringUnmapper)
        .map(StringToBase64_1.stringToBase64Mapper, StringToBase64_1.stringToBase64Unmapper));
}
exports.base64String = base64String;


/***/ }),

/***/ "./node_modules/fast-check/lib/arbitrary/bigInt.js":
/*!*********************************************************!*\
  !*** ./node_modules/fast-check/lib/arbitrary/bigInt.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.bigInt = void 0;
const Converters_1 = __webpack_require__(/*! ../check/arbitrary/definition/Converters */ "./node_modules/fast-check/lib/check/arbitrary/definition/Converters.js");
const BigIntArbitrary_1 = __webpack_require__(/*! ./_internals/BigIntArbitrary */ "./node_modules/fast-check/lib/arbitrary/_internals/BigIntArbitrary.js");
function buildCompleteBigIntConstraints(constraints) {
    const DefaultPow = 256;
    const DefaultMin = BigInt(-1) << BigInt(DefaultPow - 1);
    const DefaultMax = (BigInt(1) << BigInt(DefaultPow - 1)) - BigInt(1);
    const min = constraints.min;
    const max = constraints.max;
    return {
        min: min !== undefined ? min : DefaultMin - (max !== undefined && max < BigInt(0) ? max * max : BigInt(0)),
        max: max !== undefined ? max : DefaultMax + (min !== undefined && min > BigInt(0) ? min * min : BigInt(0)),
    };
}
function extractBigIntConstraints(args) {
    if (args[0] === undefined) {
        return {};
    }
    if (args[1] === undefined) {
        const constraints = args[0];
        return constraints;
    }
    return { min: args[0], max: args[1] };
}
function bigInt(...args) {
    const constraints = buildCompleteBigIntConstraints(extractBigIntConstraints(args));
    if (constraints.min > constraints.max) {
        throw new Error('fc.bigInt expects max to be greater than or equal to min');
    }
    const arb = new BigIntArbitrary_1.BigIntArbitrary(constraints.min, constraints.max);
    return Converters_1.convertFromNextWithShrunkOnce(arb, arb.defaultTarget());
}
exports.bigInt = bigInt;


/***/ }),

/***/ "./node_modules/fast-check/lib/arbitrary/bigIntN.js":
/*!**********************************************************!*\
  !*** ./node_modules/fast-check/lib/arbitrary/bigIntN.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.bigIntN = void 0;
const Converters_1 = __webpack_require__(/*! ../check/arbitrary/definition/Converters */ "./node_modules/fast-check/lib/check/arbitrary/definition/Converters.js");
const BigIntArbitrary_1 = __webpack_require__(/*! ./_internals/BigIntArbitrary */ "./node_modules/fast-check/lib/arbitrary/_internals/BigIntArbitrary.js");
function bigIntN(n) {
    if (n < 1) {
        throw new Error('fc.bigIntN expects requested number of bits to be superior or equal to 1');
    }
    const min = BigInt(-1) << BigInt(n - 1);
    const max = (BigInt(1) << BigInt(n - 1)) - BigInt(1);
    const arb = new BigIntArbitrary_1.BigIntArbitrary(min, max);
    return Converters_1.convertFromNextWithShrunkOnce(arb, arb.defaultTarget());
}
exports.bigIntN = bigIntN;


/***/ }),

/***/ "./node_modules/fast-check/lib/arbitrary/bigUint.js":
/*!**********************************************************!*\
  !*** ./node_modules/fast-check/lib/arbitrary/bigUint.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.bigUint = void 0;
const Converters_1 = __webpack_require__(/*! ../check/arbitrary/definition/Converters */ "./node_modules/fast-check/lib/check/arbitrary/definition/Converters.js");
const BigIntArbitrary_1 = __webpack_require__(/*! ./_internals/BigIntArbitrary */ "./node_modules/fast-check/lib/arbitrary/_internals/BigIntArbitrary.js");
function computeDefaultMax() {
    return (BigInt(1) << BigInt(256)) - BigInt(1);
}
function bigUint(constraints) {
    const requestedMax = typeof constraints === 'object' ? constraints.max : constraints;
    const max = requestedMax !== undefined ? requestedMax : computeDefaultMax();
    if (max < 0) {
        throw new Error('fc.bigUint expects max to be greater than or equal to zero');
    }
    const arb = new BigIntArbitrary_1.BigIntArbitrary(BigInt(0), max);
    return Converters_1.convertFromNextWithShrunkOnce(arb, arb.defaultTarget());
}
exports.bigUint = bigUint;


/***/ }),

/***/ "./node_modules/fast-check/lib/arbitrary/bigUintN.js":
/*!***********************************************************!*\
  !*** ./node_modules/fast-check/lib/arbitrary/bigUintN.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.bigUintN = void 0;
const Converters_1 = __webpack_require__(/*! ../check/arbitrary/definition/Converters */ "./node_modules/fast-check/lib/check/arbitrary/definition/Converters.js");
const BigIntArbitrary_1 = __webpack_require__(/*! ./_internals/BigIntArbitrary */ "./node_modules/fast-check/lib/arbitrary/_internals/BigIntArbitrary.js");
function bigUintN(n) {
    if (n < 0) {
        throw new Error('fc.bigUintN expects requested number of bits to be superior or equal to 0');
    }
    const min = BigInt(0);
    const max = (BigInt(1) << BigInt(n)) - BigInt(1);
    const arb = new BigIntArbitrary_1.BigIntArbitrary(min, max);
    return Converters_1.convertFromNextWithShrunkOnce(arb, arb.defaultTarget());
}
exports.bigUintN = bigUintN;


/***/ }),

/***/ "./node_modules/fast-check/lib/arbitrary/boolean.js":
/*!**********************************************************!*\
  !*** ./node_modules/fast-check/lib/arbitrary/boolean.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.boolean = void 0;
const Converters_1 = __webpack_require__(/*! ../check/arbitrary/definition/Converters */ "./node_modules/fast-check/lib/check/arbitrary/definition/Converters.js");
const integer_1 = __webpack_require__(/*! ./integer */ "./node_modules/fast-check/lib/arbitrary/integer.js");
function booleanMapper(v) {
    return v === 1;
}
function booleanUnmapper(v) {
    if (typeof v !== 'boolean')
        throw new Error('Unsupported input type');
    return v === true ? 1 : 0;
}
function boolean() {
    return Converters_1.convertFromNext(Converters_1.convertToNext(integer_1.integer({ min: 0, max: 1 }))
        .map(booleanMapper, booleanUnmapper)
        .noBias());
}
exports.boolean = boolean;


/***/ }),

/***/ "./node_modules/fast-check/lib/arbitrary/char.js":
/*!*******************************************************!*\
  !*** ./node_modules/fast-check/lib/arbitrary/char.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.char = void 0;
const CharacterArbitraryBuilder_1 = __webpack_require__(/*! ./_internals/builders/CharacterArbitraryBuilder */ "./node_modules/fast-check/lib/arbitrary/_internals/builders/CharacterArbitraryBuilder.js");
function identity(v) {
    return v;
}
function char() {
    return CharacterArbitraryBuilder_1.buildCharacterArbitrary(0x20, 0x7e, identity, identity);
}
exports.char = char;


/***/ }),

/***/ "./node_modules/fast-check/lib/arbitrary/char16bits.js":
/*!*************************************************************!*\
  !*** ./node_modules/fast-check/lib/arbitrary/char16bits.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.char16bits = void 0;
const CharacterArbitraryBuilder_1 = __webpack_require__(/*! ./_internals/builders/CharacterArbitraryBuilder */ "./node_modules/fast-check/lib/arbitrary/_internals/builders/CharacterArbitraryBuilder.js");
const IndexToPrintableIndex_1 = __webpack_require__(/*! ./_internals/mappers/IndexToPrintableIndex */ "./node_modules/fast-check/lib/arbitrary/_internals/mappers/IndexToPrintableIndex.js");
function char16bits() {
    return CharacterArbitraryBuilder_1.buildCharacterArbitrary(0x0000, 0xffff, IndexToPrintableIndex_1.indexToPrintableIndexMapper, IndexToPrintableIndex_1.indexToPrintableIndexUnmapper);
}
exports.char16bits = char16bits;


/***/ }),

/***/ "./node_modules/fast-check/lib/arbitrary/clone.js":
/*!********************************************************!*\
  !*** ./node_modules/fast-check/lib/arbitrary/clone.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.clone = void 0;
const Converters_1 = __webpack_require__(/*! ../check/arbitrary/definition/Converters */ "./node_modules/fast-check/lib/check/arbitrary/definition/Converters.js");
const CloneArbitrary_1 = __webpack_require__(/*! ./_internals/CloneArbitrary */ "./node_modules/fast-check/lib/arbitrary/_internals/CloneArbitrary.js");
function clone(arb, numValues) {
    return Converters_1.convertFromNext(new CloneArbitrary_1.CloneArbitrary(Converters_1.convertToNext(arb), numValues));
}
exports.clone = clone;


/***/ }),

/***/ "./node_modules/fast-check/lib/arbitrary/clonedConstant.js":
/*!*****************************************************************!*\
  !*** ./node_modules/fast-check/lib/arbitrary/clonedConstant.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.clonedConstant = void 0;
const constant_1 = __webpack_require__(/*! ./constant */ "./node_modules/fast-check/lib/arbitrary/constant.js");
exports.clonedConstant = constant_1.constant;


/***/ }),

/***/ "./node_modules/fast-check/lib/arbitrary/compareBooleanFunc.js":
/*!*********************************************************************!*\
  !*** ./node_modules/fast-check/lib/arbitrary/compareBooleanFunc.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.compareBooleanFunc = void 0;
const CompareFunctionArbitraryBuilder_1 = __webpack_require__(/*! ./_internals/builders/CompareFunctionArbitraryBuilder */ "./node_modules/fast-check/lib/arbitrary/_internals/builders/CompareFunctionArbitraryBuilder.js");
function compareBooleanFunc() {
    return CompareFunctionArbitraryBuilder_1.buildCompareFunctionArbitrary(Object.assign((hA, hB) => hA < hB, {
        toString() {
            return '(hA, hB) => hA < hB';
        },
    }));
}
exports.compareBooleanFunc = compareBooleanFunc;


/***/ }),

/***/ "./node_modules/fast-check/lib/arbitrary/compareFunc.js":
/*!**************************************************************!*\
  !*** ./node_modules/fast-check/lib/arbitrary/compareFunc.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.compareFunc = void 0;
const CompareFunctionArbitraryBuilder_1 = __webpack_require__(/*! ./_internals/builders/CompareFunctionArbitraryBuilder */ "./node_modules/fast-check/lib/arbitrary/_internals/builders/CompareFunctionArbitraryBuilder.js");
function compareFunc() {
    return CompareFunctionArbitraryBuilder_1.buildCompareFunctionArbitrary(Object.assign((hA, hB) => hA - hB, {
        toString() {
            return '(hA, hB) => hA - hB';
        },
    }));
}
exports.compareFunc = compareFunc;


/***/ }),

/***/ "./node_modules/fast-check/lib/arbitrary/constant.js":
/*!***********************************************************!*\
  !*** ./node_modules/fast-check/lib/arbitrary/constant.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.constant = void 0;
const Converters_1 = __webpack_require__(/*! ../check/arbitrary/definition/Converters */ "./node_modules/fast-check/lib/check/arbitrary/definition/Converters.js");
const ConstantArbitrary_1 = __webpack_require__(/*! ./_internals/ConstantArbitrary */ "./node_modules/fast-check/lib/arbitrary/_internals/ConstantArbitrary.js");
function constant(value) {
    return Converters_1.convertFromNext(new ConstantArbitrary_1.ConstantArbitrary([value]));
}
exports.constant = constant;


/***/ }),

/***/ "./node_modules/fast-check/lib/arbitrary/constantFrom.js":
/*!***************************************************************!*\
  !*** ./node_modules/fast-check/lib/arbitrary/constantFrom.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.constantFrom = void 0;
const Converters_1 = __webpack_require__(/*! ../check/arbitrary/definition/Converters */ "./node_modules/fast-check/lib/check/arbitrary/definition/Converters.js");
const ConstantArbitrary_1 = __webpack_require__(/*! ./_internals/ConstantArbitrary */ "./node_modules/fast-check/lib/arbitrary/_internals/ConstantArbitrary.js");
function constantFrom(...values) {
    if (values.length === 0) {
        throw new Error('fc.constantFrom expects at least one parameter');
    }
    return Converters_1.convertFromNext(new ConstantArbitrary_1.ConstantArbitrary(values));
}
exports.constantFrom = constantFrom;


/***/ }),

/***/ "./node_modules/fast-check/lib/arbitrary/context.js":
/*!**********************************************************!*\
  !*** ./node_modules/fast-check/lib/arbitrary/context.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.context = void 0;
const symbols_1 = __webpack_require__(/*! ../check/symbols */ "./node_modules/fast-check/lib/check/symbols.js");
const constant_1 = __webpack_require__(/*! ./constant */ "./node_modules/fast-check/lib/arbitrary/constant.js");
class ContextImplem {
    constructor() {
        this.receivedLogs = [];
    }
    log(data) {
        this.receivedLogs.push(data);
    }
    size() {
        return this.receivedLogs.length;
    }
    toString() {
        return JSON.stringify({ logs: this.receivedLogs });
    }
    [symbols_1.cloneMethod]() {
        return new ContextImplem();
    }
}
function context() {
    return constant_1.constant(new ContextImplem());
}
exports.context = context;


/***/ }),

/***/ "./node_modules/fast-check/lib/arbitrary/date.js":
/*!*******************************************************!*\
  !*** ./node_modules/fast-check/lib/arbitrary/date.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.date = void 0;
const Converters_1 = __webpack_require__(/*! ../check/arbitrary/definition/Converters */ "./node_modules/fast-check/lib/check/arbitrary/definition/Converters.js");
const integer_1 = __webpack_require__(/*! ./integer */ "./node_modules/fast-check/lib/arbitrary/integer.js");
const TimeToDate_1 = __webpack_require__(/*! ./_internals/mappers/TimeToDate */ "./node_modules/fast-check/lib/arbitrary/_internals/mappers/TimeToDate.js");
function date(constraints) {
    const intMin = constraints && constraints.min !== undefined ? constraints.min.getTime() : -8640000000000000;
    const intMax = constraints && constraints.max !== undefined ? constraints.max.getTime() : 8640000000000000;
    if (Number.isNaN(intMin))
        throw new Error('fc.date min must be valid instance of Date');
    if (Number.isNaN(intMax))
        throw new Error('fc.date max must be valid instance of Date');
    if (intMin > intMax)
        throw new Error('fc.date max must be greater or equal to min');
    return Converters_1.convertFromNext(Converters_1.convertToNext(integer_1.integer(intMin, intMax)).map(TimeToDate_1.timeToDateMapper, TimeToDate_1.timeToDateUnmapper));
}
exports.date = date;


/***/ }),

/***/ "./node_modules/fast-check/lib/arbitrary/dedup.js":
/*!********************************************************!*\
  !*** ./node_modules/fast-check/lib/arbitrary/dedup.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.dedup = void 0;
const clone_1 = __webpack_require__(/*! ./clone */ "./node_modules/fast-check/lib/arbitrary/clone.js");
exports.dedup = clone_1.clone;


/***/ }),

/***/ "./node_modules/fast-check/lib/arbitrary/dictionary.js":
/*!*************************************************************!*\
  !*** ./node_modules/fast-check/lib/arbitrary/dictionary.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.dictionary = void 0;
const Converters_1 = __webpack_require__(/*! ../check/arbitrary/definition/Converters */ "./node_modules/fast-check/lib/check/arbitrary/definition/Converters.js");
const set_1 = __webpack_require__(/*! ./set */ "./node_modules/fast-check/lib/arbitrary/set.js");
const tuple_1 = __webpack_require__(/*! ./tuple */ "./node_modules/fast-check/lib/arbitrary/tuple.js");
const KeyValuePairsToObject_1 = __webpack_require__(/*! ./_internals/mappers/KeyValuePairsToObject */ "./node_modules/fast-check/lib/arbitrary/_internals/mappers/KeyValuePairsToObject.js");
function dictionary(keyArb, valueArb) {
    return Converters_1.convertFromNext(Converters_1.convertToNext(set_1.set(tuple_1.tuple(keyArb, valueArb), { compare: (t1, t2) => t1[0] === t2[0] })).map(KeyValuePairsToObject_1.keyValuePairsToObjectMapper, KeyValuePairsToObject_1.keyValuePairsToObjectUnmapper));
}
exports.dictionary = dictionary;


/***/ }),

/***/ "./node_modules/fast-check/lib/arbitrary/falsy.js":
/*!********************************************************!*\
  !*** ./node_modules/fast-check/lib/arbitrary/falsy.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.falsy = void 0;
const constantFrom_1 = __webpack_require__(/*! ./constantFrom */ "./node_modules/fast-check/lib/arbitrary/constantFrom.js");
function falsy(constraints) {
    if (!constraints || !constraints.withBigInt) {
        return constantFrom_1.constantFrom(false, null, undefined, 0, '', NaN);
    }
    return constantFrom_1.constantFrom(false, null, undefined, 0, '', NaN, BigInt(0));
}
exports.falsy = falsy;


/***/ }),

/***/ "./node_modules/fast-check/lib/arbitrary/float32Array.js":
/*!***************************************************************!*\
  !*** ./node_modules/fast-check/lib/arbitrary/float32Array.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.float32Array = void 0;
const FloatingPointArbitrary_1 = __webpack_require__(/*! ../check/arbitrary/FloatingPointArbitrary */ "./node_modules/fast-check/lib/check/arbitrary/FloatingPointArbitrary.js");
const array_1 = __webpack_require__(/*! ./array */ "./node_modules/fast-check/lib/arbitrary/array.js");
function float32Array(constraints = {}) {
    return array_1.array(FloatingPointArbitrary_1.float(Object.assign(Object.assign({}, constraints), { next: true })), constraints).map((data) => Float32Array.from(data));
}
exports.float32Array = float32Array;


/***/ }),

/***/ "./node_modules/fast-check/lib/arbitrary/float64Array.js":
/*!***************************************************************!*\
  !*** ./node_modules/fast-check/lib/arbitrary/float64Array.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.float64Array = void 0;
const FloatingPointArbitrary_1 = __webpack_require__(/*! ../check/arbitrary/FloatingPointArbitrary */ "./node_modules/fast-check/lib/check/arbitrary/FloatingPointArbitrary.js");
const array_1 = __webpack_require__(/*! ./array */ "./node_modules/fast-check/lib/arbitrary/array.js");
function float64Array(constraints = {}) {
    return array_1.array(FloatingPointArbitrary_1.double(Object.assign(Object.assign({}, constraints), { next: true })), constraints).map((data) => Float64Array.from(data));
}
exports.float64Array = float64Array;


/***/ }),

/***/ "./node_modules/fast-check/lib/arbitrary/frequency.js":
/*!************************************************************!*\
  !*** ./node_modules/fast-check/lib/arbitrary/frequency.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.frequency = void 0;
const FrequencyArbitrary_1 = __webpack_require__(/*! ./_internals/FrequencyArbitrary */ "./node_modules/fast-check/lib/arbitrary/_internals/FrequencyArbitrary.js");
function isFrequencyContraints(param) {
    return param != null && typeof param === 'object' && !('arbitrary' in param);
}
function frequency(...args) {
    const label = 'fc.frequency';
    const constraints = args[0];
    if (isFrequencyContraints(constraints)) {
        return FrequencyArbitrary_1.FrequencyArbitrary.fromOld(args.slice(1), constraints, label);
    }
    return FrequencyArbitrary_1.FrequencyArbitrary.fromOld(args, {}, label);
}
exports.frequency = frequency;


/***/ }),

/***/ "./node_modules/fast-check/lib/arbitrary/fullUnicode.js":
/*!**************************************************************!*\
  !*** ./node_modules/fast-check/lib/arbitrary/fullUnicode.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.fullUnicode = void 0;
const CharacterArbitraryBuilder_1 = __webpack_require__(/*! ./_internals/builders/CharacterArbitraryBuilder */ "./node_modules/fast-check/lib/arbitrary/_internals/builders/CharacterArbitraryBuilder.js");
const IndexToPrintableIndex_1 = __webpack_require__(/*! ./_internals/mappers/IndexToPrintableIndex */ "./node_modules/fast-check/lib/arbitrary/_internals/mappers/IndexToPrintableIndex.js");
const gapSize = 0xdfff + 1 - 0xd800;
function unicodeMapper(v) {
    if (v < 0xd800)
        return IndexToPrintableIndex_1.indexToPrintableIndexMapper(v);
    return v + gapSize;
}
function unicodeUnmapper(v) {
    if (v < 0xd800)
        return IndexToPrintableIndex_1.indexToPrintableIndexUnmapper(v);
    if (v <= 0xdfff)
        return -1;
    return v - gapSize;
}
function fullUnicode() {
    return CharacterArbitraryBuilder_1.buildCharacterArbitrary(0x0000, 0x10ffff - gapSize, unicodeMapper, unicodeUnmapper);
}
exports.fullUnicode = fullUnicode;


/***/ }),

/***/ "./node_modules/fast-check/lib/arbitrary/fullUnicodeString.js":
/*!********************************************************************!*\
  !*** ./node_modules/fast-check/lib/arbitrary/fullUnicodeString.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.fullUnicodeString = void 0;
const Converters_1 = __webpack_require__(/*! ../check/arbitrary/definition/Converters */ "./node_modules/fast-check/lib/check/arbitrary/definition/Converters.js");
const array_1 = __webpack_require__(/*! ./array */ "./node_modules/fast-check/lib/arbitrary/array.js");
const fullUnicode_1 = __webpack_require__(/*! ./fullUnicode */ "./node_modules/fast-check/lib/arbitrary/fullUnicode.js");
const StringConstraintsExtractor_1 = __webpack_require__(/*! ./_internals/helpers/StringConstraintsExtractor */ "./node_modules/fast-check/lib/arbitrary/_internals/helpers/StringConstraintsExtractor.js");
const CodePointsToString_1 = __webpack_require__(/*! ./_internals/mappers/CodePointsToString */ "./node_modules/fast-check/lib/arbitrary/_internals/mappers/CodePointsToString.js");
function fullUnicodeString(...args) {
    const constraints = StringConstraintsExtractor_1.extractStringConstraints(args);
    return Converters_1.convertFromNext(Converters_1.convertToNext(array_1.array(fullUnicode_1.fullUnicode(), constraints)).map(CodePointsToString_1.codePointsToStringMapper, CodePointsToString_1.codePointsToStringUnmapper));
}
exports.fullUnicodeString = fullUnicodeString;


/***/ }),

/***/ "./node_modules/fast-check/lib/arbitrary/func.js":
/*!*******************************************************!*\
  !*** ./node_modules/fast-check/lib/arbitrary/func.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.func = void 0;
const hash_1 = __webpack_require__(/*! ../utils/hash */ "./node_modules/fast-check/lib/utils/hash.js");
const stringify_1 = __webpack_require__(/*! ../utils/stringify */ "./node_modules/fast-check/lib/utils/stringify.js");
const symbols_1 = __webpack_require__(/*! ../check/symbols */ "./node_modules/fast-check/lib/check/symbols.js");
const array_1 = __webpack_require__(/*! ./array */ "./node_modules/fast-check/lib/arbitrary/array.js");
const integer_1 = __webpack_require__(/*! ./integer */ "./node_modules/fast-check/lib/arbitrary/integer.js");
const tuple_1 = __webpack_require__(/*! ./tuple */ "./node_modules/fast-check/lib/arbitrary/tuple.js");
const TextEscaper_1 = __webpack_require__(/*! ../check/arbitrary/helpers/TextEscaper */ "./node_modules/fast-check/lib/check/arbitrary/helpers/TextEscaper.js");
function func(arb) {
    return tuple_1.tuple(array_1.array(arb, { minLength: 1 }), integer_1.integer().noShrink()).map(([outs, seed]) => {
        const producer = () => {
            const recorded = {};
            const f = (...args) => {
                const repr = stringify_1.stringify(args);
                const val = outs[hash_1.hash(`${seed}${repr}`) % outs.length];
                recorded[repr] = val;
                return symbols_1.hasCloneMethod(val) ? val[symbols_1.cloneMethod]() : val;
            };
            function prettyPrint(stringifiedOuts) {
                const seenValues = Object.keys(recorded)
                    .sort()
                    .map((k) => `${k} => ${stringify_1.stringify(recorded[k])}`)
                    .map((line) => `/* ${TextEscaper_1.escapeForMultilineComments(line)} */`);
                return `function(...args) {
  // With hash and stringify coming from fast-check${seenValues.length !== 0 ? `\n  ${seenValues.join('\n  ')}` : ''}
  const outs = ${stringifiedOuts};
  return outs[hash('${seed}' + stringify(args)) % outs.length];
}`;
            }
            return Object.defineProperties(f, {
                toString: { value: () => prettyPrint(stringify_1.stringify(outs)) },
                [stringify_1.toStringMethod]: { value: () => prettyPrint(stringify_1.stringify(outs)) },
                [stringify_1.asyncToStringMethod]: { value: async () => prettyPrint(await stringify_1.asyncStringify(outs)) },
                [symbols_1.cloneMethod]: { value: producer, configurable: true },
            });
        };
        return producer();
    });
}
exports.func = func;


/***/ }),

/***/ "./node_modules/fast-check/lib/arbitrary/genericTuple.js":
/*!***************************************************************!*\
  !*** ./node_modules/fast-check/lib/arbitrary/genericTuple.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.genericTuple = void 0;
const Converters_1 = __webpack_require__(/*! ../check/arbitrary/definition/Converters */ "./node_modules/fast-check/lib/check/arbitrary/definition/Converters.js");
const TupleArbitrary_1 = __webpack_require__(/*! ./_internals/TupleArbitrary */ "./node_modules/fast-check/lib/arbitrary/_internals/TupleArbitrary.js");
function genericTuple(arbs) {
    const nextArbs = arbs.map((arb) => Converters_1.convertToNext(arb));
    return Converters_1.convertFromNext(new TupleArbitrary_1.TupleArbitrary(nextArbs));
}
exports.genericTuple = genericTuple;


/***/ }),

/***/ "./node_modules/fast-check/lib/arbitrary/hexa.js":
/*!*******************************************************!*\
  !*** ./node_modules/fast-check/lib/arbitrary/hexa.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.hexa = void 0;
const CharacterArbitraryBuilder_1 = __webpack_require__(/*! ./_internals/builders/CharacterArbitraryBuilder */ "./node_modules/fast-check/lib/arbitrary/_internals/builders/CharacterArbitraryBuilder.js");
function hexaMapper(v) {
    return v < 10
        ? v + 48
        : v + 97 - 10;
}
function hexaUnmapper(v) {
    return v < 58
        ? v - 48
        : v < 103
            ? v - 97 + 10
            : -1;
}
function hexa() {
    return CharacterArbitraryBuilder_1.buildCharacterArbitrary(0, 15, hexaMapper, hexaUnmapper);
}
exports.hexa = hexa;


/***/ }),

/***/ "./node_modules/fast-check/lib/arbitrary/hexaString.js":
/*!*************************************************************!*\
  !*** ./node_modules/fast-check/lib/arbitrary/hexaString.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.hexaString = void 0;
const Converters_1 = __webpack_require__(/*! ../check/arbitrary/definition/Converters */ "./node_modules/fast-check/lib/check/arbitrary/definition/Converters.js");
const array_1 = __webpack_require__(/*! ./array */ "./node_modules/fast-check/lib/arbitrary/array.js");
const hexa_1 = __webpack_require__(/*! ./hexa */ "./node_modules/fast-check/lib/arbitrary/hexa.js");
const StringConstraintsExtractor_1 = __webpack_require__(/*! ./_internals/helpers/StringConstraintsExtractor */ "./node_modules/fast-check/lib/arbitrary/_internals/helpers/StringConstraintsExtractor.js");
const CodePointsToString_1 = __webpack_require__(/*! ./_internals/mappers/CodePointsToString */ "./node_modules/fast-check/lib/arbitrary/_internals/mappers/CodePointsToString.js");
function hexaString(...args) {
    const constraints = StringConstraintsExtractor_1.extractStringConstraints(args);
    return Converters_1.convertFromNext(Converters_1.convertToNext(array_1.array(hexa_1.hexa(), constraints)).map(CodePointsToString_1.codePointsToStringMapper, CodePointsToString_1.codePointsToStringUnmapper));
}
exports.hexaString = hexaString;


/***/ }),

/***/ "./node_modules/fast-check/lib/arbitrary/infiniteStream.js":
/*!*****************************************************************!*\
  !*** ./node_modules/fast-check/lib/arbitrary/infiniteStream.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.infiniteStream = void 0;
const Converters_1 = __webpack_require__(/*! ../check/arbitrary/definition/Converters */ "./node_modules/fast-check/lib/check/arbitrary/definition/Converters.js");
const StreamArbitrary_1 = __webpack_require__(/*! ./_internals/StreamArbitrary */ "./node_modules/fast-check/lib/arbitrary/_internals/StreamArbitrary.js");
function infiniteStream(arb) {
    return Converters_1.convertFromNext(new StreamArbitrary_1.StreamArbitrary(Converters_1.convertToNext(arb)));
}
exports.infiniteStream = infiniteStream;


/***/ }),

/***/ "./node_modules/fast-check/lib/arbitrary/int16Array.js":
/*!*************************************************************!*\
  !*** ./node_modules/fast-check/lib/arbitrary/int16Array.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.int16Array = void 0;
const integer_1 = __webpack_require__(/*! ./integer */ "./node_modules/fast-check/lib/arbitrary/integer.js");
const TypedIntArrayArbitraryBuilder_1 = __webpack_require__(/*! ./_internals/builders/TypedIntArrayArbitraryBuilder */ "./node_modules/fast-check/lib/arbitrary/_internals/builders/TypedIntArrayArbitraryBuilder.js");
function int16Array(constraints = {}) {
    return TypedIntArrayArbitraryBuilder_1.typedIntArrayArbitraryArbitraryBuilder(constraints, -32768, 32767, Int16Array, integer_1.integer);
}
exports.int16Array = int16Array;


/***/ }),

/***/ "./node_modules/fast-check/lib/arbitrary/int32Array.js":
/*!*************************************************************!*\
  !*** ./node_modules/fast-check/lib/arbitrary/int32Array.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.int32Array = void 0;
const integer_1 = __webpack_require__(/*! ./integer */ "./node_modules/fast-check/lib/arbitrary/integer.js");
const TypedIntArrayArbitraryBuilder_1 = __webpack_require__(/*! ./_internals/builders/TypedIntArrayArbitraryBuilder */ "./node_modules/fast-check/lib/arbitrary/_internals/builders/TypedIntArrayArbitraryBuilder.js");
function int32Array(constraints = {}) {
    return TypedIntArrayArbitraryBuilder_1.typedIntArrayArbitraryArbitraryBuilder(constraints, -0x80000000, 0x7fffffff, Int32Array, integer_1.integer);
}
exports.int32Array = int32Array;


/***/ }),

/***/ "./node_modules/fast-check/lib/arbitrary/int8Array.js":
/*!************************************************************!*\
  !*** ./node_modules/fast-check/lib/arbitrary/int8Array.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.int8Array = void 0;
const integer_1 = __webpack_require__(/*! ./integer */ "./node_modules/fast-check/lib/arbitrary/integer.js");
const TypedIntArrayArbitraryBuilder_1 = __webpack_require__(/*! ./_internals/builders/TypedIntArrayArbitraryBuilder */ "./node_modules/fast-check/lib/arbitrary/_internals/builders/TypedIntArrayArbitraryBuilder.js");
function int8Array(constraints = {}) {
    return TypedIntArrayArbitraryBuilder_1.typedIntArrayArbitraryArbitraryBuilder(constraints, -128, 127, Int8Array, integer_1.integer);
}
exports.int8Array = int8Array;


/***/ }),

/***/ "./node_modules/fast-check/lib/arbitrary/integer.js":
/*!**********************************************************!*\
  !*** ./node_modules/fast-check/lib/arbitrary/integer.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.integer = void 0;
const Converters_1 = __webpack_require__(/*! ../check/arbitrary/definition/Converters */ "./node_modules/fast-check/lib/check/arbitrary/definition/Converters.js");
const IntegerArbitrary_1 = __webpack_require__(/*! ./_internals/IntegerArbitrary */ "./node_modules/fast-check/lib/arbitrary/_internals/IntegerArbitrary.js");
function buildCompleteIntegerConstraints(constraints) {
    const min = constraints.min !== undefined ? constraints.min : -0x80000000;
    const max = constraints.max !== undefined ? constraints.max : 0x7fffffff;
    return { min, max };
}
function extractIntegerConstraints(args) {
    if (args[0] === undefined) {
        return {};
    }
    if (args[1] === undefined) {
        const sargs = args;
        if (typeof sargs[0] === 'number')
            return { max: sargs[0] };
        return sargs[0];
    }
    const sargs = args;
    return { min: sargs[0], max: sargs[1] };
}
function integer(...args) {
    const constraints = buildCompleteIntegerConstraints(extractIntegerConstraints(args));
    if (constraints.min > constraints.max) {
        throw new Error('fc.integer maximum value should be equal or greater than the minimum one');
    }
    const arb = new IntegerArbitrary_1.IntegerArbitrary(constraints.min, constraints.max);
    return Converters_1.convertFromNextWithShrunkOnce(arb, arb.defaultTarget());
}
exports.integer = integer;


/***/ }),

/***/ "./node_modules/fast-check/lib/arbitrary/ipV4.js":
/*!*******************************************************!*\
  !*** ./node_modules/fast-check/lib/arbitrary/ipV4.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ipV4 = void 0;
const Converters_1 = __webpack_require__(/*! ../check/arbitrary/definition/Converters */ "./node_modules/fast-check/lib/check/arbitrary/definition/Converters.js");
const nat_1 = __webpack_require__(/*! ./nat */ "./node_modules/fast-check/lib/arbitrary/nat.js");
const tuple_1 = __webpack_require__(/*! ./tuple */ "./node_modules/fast-check/lib/arbitrary/tuple.js");
const NatToStringifiedNat_1 = __webpack_require__(/*! ./_internals/mappers/NatToStringifiedNat */ "./node_modules/fast-check/lib/arbitrary/_internals/mappers/NatToStringifiedNat.js");
function dotJoinerMapper(data) {
    return data.join('.');
}
function dotJoinerUnmapper(value) {
    if (typeof value !== 'string') {
        throw new Error('Invalid type');
    }
    return value.split('.').map((v) => NatToStringifiedNat_1.tryParseStringifiedNat(v, 10));
}
function ipV4() {
    return Converters_1.convertFromNext(Converters_1.convertToNext(tuple_1.tuple(nat_1.nat(255), nat_1.nat(255), nat_1.nat(255), nat_1.nat(255))).map(dotJoinerMapper, dotJoinerUnmapper));
}
exports.ipV4 = ipV4;


/***/ }),

/***/ "./node_modules/fast-check/lib/arbitrary/ipV4Extended.js":
/*!***************************************************************!*\
  !*** ./node_modules/fast-check/lib/arbitrary/ipV4Extended.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ipV4Extended = void 0;
const oneof_1 = __webpack_require__(/*! ./oneof */ "./node_modules/fast-check/lib/arbitrary/oneof.js");
const tuple_1 = __webpack_require__(/*! ./tuple */ "./node_modules/fast-check/lib/arbitrary/tuple.js");
const StringifiedNatArbitraryBuilder_1 = __webpack_require__(/*! ./_internals/builders/StringifiedNatArbitraryBuilder */ "./node_modules/fast-check/lib/arbitrary/_internals/builders/StringifiedNatArbitraryBuilder.js");
const Converters_1 = __webpack_require__(/*! ../check/arbitrary/definition/Converters */ "./node_modules/fast-check/lib/check/arbitrary/definition/Converters.js");
function dotJoinerMapper(data) {
    return data.join('.');
}
function dotJoinerUnmapper(value) {
    if (typeof value !== 'string') {
        throw new Error('Invalid type');
    }
    return value.split('.');
}
function ipV4Extended() {
    return oneof_1.oneof(Converters_1.convertFromNext(Converters_1.convertToNext(tuple_1.tuple(StringifiedNatArbitraryBuilder_1.buildStringifiedNatArbitrary(255), StringifiedNatArbitraryBuilder_1.buildStringifiedNatArbitrary(255), StringifiedNatArbitraryBuilder_1.buildStringifiedNatArbitrary(255), StringifiedNatArbitraryBuilder_1.buildStringifiedNatArbitrary(255))).map(dotJoinerMapper, dotJoinerUnmapper)), Converters_1.convertFromNext(Converters_1.convertToNext(tuple_1.tuple(StringifiedNatArbitraryBuilder_1.buildStringifiedNatArbitrary(255), StringifiedNatArbitraryBuilder_1.buildStringifiedNatArbitrary(255), StringifiedNatArbitraryBuilder_1.buildStringifiedNatArbitrary(65535))).map(dotJoinerMapper, dotJoinerUnmapper)), Converters_1.convertFromNext(Converters_1.convertToNext(tuple_1.tuple(StringifiedNatArbitraryBuilder_1.buildStringifiedNatArbitrary(255), StringifiedNatArbitraryBuilder_1.buildStringifiedNatArbitrary(16777215))).map(dotJoinerMapper, dotJoinerUnmapper)), StringifiedNatArbitraryBuilder_1.buildStringifiedNatArbitrary(4294967295));
}
exports.ipV4Extended = ipV4Extended;


/***/ }),

/***/ "./node_modules/fast-check/lib/arbitrary/ipV6.js":
/*!*******************************************************!*\
  !*** ./node_modules/fast-check/lib/arbitrary/ipV6.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ipV6 = void 0;
const array_1 = __webpack_require__(/*! ./array */ "./node_modules/fast-check/lib/arbitrary/array.js");
const Converters_1 = __webpack_require__(/*! ../check/arbitrary/definition/Converters */ "./node_modules/fast-check/lib/check/arbitrary/definition/Converters.js");
const oneof_1 = __webpack_require__(/*! ./oneof */ "./node_modules/fast-check/lib/arbitrary/oneof.js");
const hexaString_1 = __webpack_require__(/*! ./hexaString */ "./node_modules/fast-check/lib/arbitrary/hexaString.js");
const tuple_1 = __webpack_require__(/*! ./tuple */ "./node_modules/fast-check/lib/arbitrary/tuple.js");
const ipV4_1 = __webpack_require__(/*! ./ipV4 */ "./node_modules/fast-check/lib/arbitrary/ipV4.js");
const EntitiesToIPv6_1 = __webpack_require__(/*! ./_internals/mappers/EntitiesToIPv6 */ "./node_modules/fast-check/lib/arbitrary/_internals/mappers/EntitiesToIPv6.js");
function h16sTol32Mapper([a, b]) {
    return `${a}:${b}`;
}
function h16sTol32Unmapper(value) {
    if (typeof value !== 'string')
        throw new Error('Invalid type');
    if (!value.includes(':'))
        throw new Error('Invalid value');
    return value.split(':', 2);
}
function ipV6() {
    const h16Arb = hexaString_1.hexaString({ minLength: 1, maxLength: 4 });
    const ls32Arb = oneof_1.oneof(Converters_1.convertFromNext(Converters_1.convertToNext(tuple_1.tuple(h16Arb, h16Arb)).map(h16sTol32Mapper, h16sTol32Unmapper)), ipV4_1.ipV4());
    return oneof_1.oneof(Converters_1.convertFromNext(Converters_1.convertToNext(tuple_1.tuple(array_1.array(h16Arb, { minLength: 6, maxLength: 6 }), ls32Arb)).map(EntitiesToIPv6_1.fullySpecifiedMapper, EntitiesToIPv6_1.fullySpecifiedUnmapper)), Converters_1.convertFromNext(Converters_1.convertToNext(tuple_1.tuple(array_1.array(h16Arb, { minLength: 5, maxLength: 5 }), ls32Arb)).map(EntitiesToIPv6_1.onlyTrailingMapper, EntitiesToIPv6_1.onlyTrailingUnmapper)), Converters_1.convertFromNext(Converters_1.convertToNext(tuple_1.tuple(array_1.array(h16Arb, { minLength: 0, maxLength: 1 }), array_1.array(h16Arb, { minLength: 4, maxLength: 4 }), ls32Arb)).map(EntitiesToIPv6_1.multiTrailingMapper, EntitiesToIPv6_1.multiTrailingUnmapper)), Converters_1.convertFromNext(Converters_1.convertToNext(tuple_1.tuple(array_1.array(h16Arb, { minLength: 0, maxLength: 2 }), array_1.array(h16Arb, { minLength: 3, maxLength: 3 }), ls32Arb)).map(EntitiesToIPv6_1.multiTrailingMapper, EntitiesToIPv6_1.multiTrailingUnmapper)), Converters_1.convertFromNext(Converters_1.convertToNext(tuple_1.tuple(array_1.array(h16Arb, { minLength: 0, maxLength: 3 }), array_1.array(h16Arb, { minLength: 2, maxLength: 2 }), ls32Arb)).map(EntitiesToIPv6_1.multiTrailingMapper, EntitiesToIPv6_1.multiTrailingUnmapper)), Converters_1.convertFromNext(Converters_1.convertToNext(tuple_1.tuple(array_1.array(h16Arb, { minLength: 0, maxLength: 4 }), h16Arb, ls32Arb)).map(EntitiesToIPv6_1.multiTrailingMapperOne, EntitiesToIPv6_1.multiTrailingUnmapperOne)), Converters_1.convertFromNext(Converters_1.convertToNext(tuple_1.tuple(array_1.array(h16Arb, { minLength: 0, maxLength: 5 }), ls32Arb)).map(EntitiesToIPv6_1.singleTrailingMapper, EntitiesToIPv6_1.singleTrailingUnmapper)), Converters_1.convertFromNext(Converters_1.convertToNext(tuple_1.tuple(array_1.array(h16Arb, { minLength: 0, maxLength: 6 }), h16Arb)).map(EntitiesToIPv6_1.singleTrailingMapper, EntitiesToIPv6_1.singleTrailingUnmapper)), Converters_1.convertFromNext(Converters_1.convertToNext(tuple_1.tuple(array_1.array(h16Arb, { minLength: 0, maxLength: 7 }))).map(EntitiesToIPv6_1.noTrailingMapper, EntitiesToIPv6_1.noTrailingUnmapper)));
}
exports.ipV6 = ipV6;


/***/ }),

/***/ "./node_modules/fast-check/lib/arbitrary/letrec.js":
/*!*********************************************************!*\
  !*** ./node_modules/fast-check/lib/arbitrary/letrec.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.letrec = void 0;
const LazyArbitrary_1 = __webpack_require__(/*! ./_internals/LazyArbitrary */ "./node_modules/fast-check/lib/arbitrary/_internals/LazyArbitrary.js");
const Converters_1 = __webpack_require__(/*! ../check/arbitrary/definition/Converters */ "./node_modules/fast-check/lib/check/arbitrary/definition/Converters.js");
function letrec(builder) {
    const lazyArbs = Object.create(null);
    const tie = (key) => {
        if (!Object.prototype.hasOwnProperty.call(lazyArbs, key)) {
            lazyArbs[key] = new LazyArbitrary_1.LazyArbitrary(String(key));
        }
        return Converters_1.convertFromNext(lazyArbs[key]);
    };
    const strictArbs = builder(tie);
    for (const key in strictArbs) {
        if (!Object.prototype.hasOwnProperty.call(strictArbs, key)) {
            continue;
        }
        const lazyAtKey = lazyArbs[key];
        const lazyArb = lazyAtKey !== undefined ? lazyAtKey : new LazyArbitrary_1.LazyArbitrary(key);
        lazyArb.underlying = Converters_1.convertToNext(strictArbs[key]);
        lazyArbs[key] = lazyArb;
    }
    return strictArbs;
}
exports.letrec = letrec;


/***/ }),

/***/ "./node_modules/fast-check/lib/arbitrary/lorem.js":
/*!********************************************************!*\
  !*** ./node_modules/fast-check/lib/arbitrary/lorem.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.lorem = void 0;
const array_1 = __webpack_require__(/*! ./array */ "./node_modules/fast-check/lib/arbitrary/array.js");
const constant_1 = __webpack_require__(/*! ./constant */ "./node_modules/fast-check/lib/arbitrary/constant.js");
const frequency_1 = __webpack_require__(/*! ./frequency */ "./node_modules/fast-check/lib/arbitrary/frequency.js");
const WordsToLorem_1 = __webpack_require__(/*! ./_internals/mappers/WordsToLorem */ "./node_modules/fast-check/lib/arbitrary/_internals/mappers/WordsToLorem.js");
const Converters_1 = __webpack_require__(/*! ../check/arbitrary/definition/Converters */ "./node_modules/fast-check/lib/check/arbitrary/definition/Converters.js");
const h = (v, w) => {
    return { arbitrary: constant_1.constant(v), weight: w };
};
function loremWord() {
    return frequency_1.frequency(h('non', 6), h('adipiscing', 5), h('ligula', 5), h('enim', 5), h('pellentesque', 5), h('in', 5), h('augue', 5), h('et', 5), h('nulla', 5), h('lorem', 4), h('sit', 4), h('sed', 4), h('diam', 4), h('fermentum', 4), h('ut', 4), h('eu', 4), h('aliquam', 4), h('mauris', 4), h('vitae', 4), h('felis', 4), h('ipsum', 3), h('dolor', 3), h('amet,', 3), h('elit', 3), h('euismod', 3), h('mi', 3), h('orci', 3), h('erat', 3), h('praesent', 3), h('egestas', 3), h('leo', 3), h('vel', 3), h('sapien', 3), h('integer', 3), h('curabitur', 3), h('convallis', 3), h('purus', 3), h('risus', 2), h('suspendisse', 2), h('lectus', 2), h('nec,', 2), h('ultricies', 2), h('sed,', 2), h('cras', 2), h('elementum', 2), h('ultrices', 2), h('maecenas', 2), h('massa,', 2), h('varius', 2), h('a,', 2), h('semper', 2), h('proin', 2), h('nec', 2), h('nisl', 2), h('amet', 2), h('duis', 2), h('congue', 2), h('libero', 2), h('vestibulum', 2), h('pede', 2), h('blandit', 2), h('sodales', 2), h('ante', 2), h('nibh', 2), h('ac', 2), h('aenean', 2), h('massa', 2), h('suscipit', 2), h('sollicitudin', 2), h('fusce', 2), h('tempus', 2), h('aliquam,', 2), h('nunc', 2), h('ullamcorper', 2), h('rhoncus', 2), h('metus', 2), h('faucibus,', 2), h('justo', 2), h('magna', 2), h('at', 2), h('tincidunt', 2), h('consectetur', 1), h('tortor,', 1), h('dignissim', 1), h('congue,', 1), h('non,', 1), h('porttitor,', 1), h('nonummy', 1), h('molestie,', 1), h('est', 1), h('eleifend', 1), h('mi,', 1), h('arcu', 1), h('scelerisque', 1), h('vitae,', 1), h('consequat', 1), h('in,', 1), h('pretium', 1), h('volutpat', 1), h('pharetra', 1), h('tempor', 1), h('bibendum', 1), h('odio', 1), h('dui', 1), h('primis', 1), h('faucibus', 1), h('luctus', 1), h('posuere', 1), h('cubilia', 1), h('curae,', 1), h('hendrerit', 1), h('velit', 1), h('mauris,', 1), h('gravida', 1), h('ornare', 1), h('ut,', 1), h('pulvinar', 1), h('varius,', 1), h('turpis', 1), h('nibh,', 1), h('eros', 1), h('id', 1), h('aliquet', 1), h('quis', 1), h('lobortis', 1), h('consectetuer', 1), h('morbi', 1), h('vehicula', 1), h('tortor', 1), h('tellus,', 1), h('id,', 1), h('eu,', 1), h('quam', 1), h('feugiat,', 1), h('posuere,', 1), h('iaculis', 1), h('lectus,', 1), h('tristique', 1), h('mollis,', 1), h('nisl,', 1), h('vulputate', 1), h('sem', 1), h('vivamus', 1), h('placerat', 1), h('imperdiet', 1), h('cursus', 1), h('rutrum', 1), h('iaculis,', 1), h('augue,', 1), h('lacus', 1));
}
function lorem(...args) {
    const maxWordsCount = typeof args[0] === 'object' ? args[0].maxCount : args[0];
    const sentencesMode = typeof args[0] === 'object' ? args[0].mode === 'sentences' : args[1];
    const maxCount = maxWordsCount !== undefined ? maxWordsCount : 5;
    if (maxCount < 1) {
        throw new Error(`lorem has to produce at least one word/sentence`);
    }
    const wordArbitrary = loremWord();
    const wordArbitraryNext = Converters_1.convertToNext(wordArbitrary);
    if (sentencesMode) {
        const sentence = Converters_1.convertToNext(array_1.array(wordArbitrary, { minLength: 1 })).map(WordsToLorem_1.wordsToSentenceMapper, WordsToLorem_1.wordsToSentenceUnmapperFor(wordArbitraryNext));
        return Converters_1.convertFromNext(Converters_1.convertToNext(array_1.array(Converters_1.convertFromNext(sentence), { minLength: 1, maxLength: maxCount })).map(WordsToLorem_1.sentencesToParagraphMapper, WordsToLorem_1.sentencesToParagraphUnmapper));
    }
    else {
        return Converters_1.convertFromNext(Converters_1.convertToNext(array_1.array(wordArbitrary, { minLength: 1, maxLength: maxCount })).map(WordsToLorem_1.wordsToJoinedStringMapper, WordsToLorem_1.wordsToJoinedStringUnmapperFor(wordArbitraryNext)));
    }
}
exports.lorem = lorem;


/***/ }),

/***/ "./node_modules/fast-check/lib/arbitrary/mapToConstant.js":
/*!****************************************************************!*\
  !*** ./node_modules/fast-check/lib/arbitrary/mapToConstant.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.mapToConstant = void 0;
const Converters_1 = __webpack_require__(/*! ../check/arbitrary/definition/Converters */ "./node_modules/fast-check/lib/check/arbitrary/definition/Converters.js");
const nat_1 = __webpack_require__(/*! ./nat */ "./node_modules/fast-check/lib/arbitrary/nat.js");
const IndexToMappedConstant_1 = __webpack_require__(/*! ./_internals/mappers/IndexToMappedConstant */ "./node_modules/fast-check/lib/arbitrary/_internals/mappers/IndexToMappedConstant.js");
function computeNumChoices(options) {
    if (options.length === 0)
        throw new Error(`fc.mapToConstant expects at least one option`);
    let numChoices = 0;
    for (let idx = 0; idx !== options.length; ++idx) {
        if (options[idx].num < 0)
            throw new Error(`fc.mapToConstant expects all options to have a number of entries greater or equal to zero`);
        numChoices += options[idx].num;
    }
    if (numChoices === 0)
        throw new Error(`fc.mapToConstant expects at least one choice among options`);
    return numChoices;
}
function mapToConstant(...entries) {
    const numChoices = computeNumChoices(entries);
    return Converters_1.convertFromNext(Converters_1.convertToNext(nat_1.nat({ max: numChoices - 1 })).map(IndexToMappedConstant_1.indexToMappedConstantMapperFor(entries), IndexToMappedConstant_1.indexToMappedConstantUnmapperFor(entries)));
}
exports.mapToConstant = mapToConstant;


/***/ }),

/***/ "./node_modules/fast-check/lib/arbitrary/maxSafeInteger.js":
/*!*****************************************************************!*\
  !*** ./node_modules/fast-check/lib/arbitrary/maxSafeInteger.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.maxSafeInteger = void 0;
const Converters_1 = __webpack_require__(/*! ../check/arbitrary/definition/Converters */ "./node_modules/fast-check/lib/check/arbitrary/definition/Converters.js");
const IntegerArbitrary_1 = __webpack_require__(/*! ./_internals/IntegerArbitrary */ "./node_modules/fast-check/lib/arbitrary/_internals/IntegerArbitrary.js");
function maxSafeInteger() {
    const arb = new IntegerArbitrary_1.IntegerArbitrary(Number.MIN_SAFE_INTEGER, Number.MAX_SAFE_INTEGER);
    return Converters_1.convertFromNextWithShrunkOnce(arb, arb.defaultTarget());
}
exports.maxSafeInteger = maxSafeInteger;


/***/ }),

/***/ "./node_modules/fast-check/lib/arbitrary/maxSafeNat.js":
/*!*************************************************************!*\
  !*** ./node_modules/fast-check/lib/arbitrary/maxSafeNat.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.maxSafeNat = void 0;
const Converters_1 = __webpack_require__(/*! ../check/arbitrary/definition/Converters */ "./node_modules/fast-check/lib/check/arbitrary/definition/Converters.js");
const IntegerArbitrary_1 = __webpack_require__(/*! ./_internals/IntegerArbitrary */ "./node_modules/fast-check/lib/arbitrary/_internals/IntegerArbitrary.js");
function maxSafeNat() {
    const arb = new IntegerArbitrary_1.IntegerArbitrary(0, Number.MAX_SAFE_INTEGER);
    return Converters_1.convertFromNextWithShrunkOnce(arb, arb.defaultTarget());
}
exports.maxSafeNat = maxSafeNat;


/***/ }),

/***/ "./node_modules/fast-check/lib/arbitrary/memo.js":
/*!*******************************************************!*\
  !*** ./node_modules/fast-check/lib/arbitrary/memo.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.memo = void 0;
let contextRemainingDepth = 10;
function memo(builder) {
    const previous = {};
    return ((maxDepth) => {
        const n = maxDepth !== undefined ? maxDepth : contextRemainingDepth;
        if (!Object.prototype.hasOwnProperty.call(previous, n)) {
            const prev = contextRemainingDepth;
            contextRemainingDepth = n - 1;
            previous[n] = builder(n);
            contextRemainingDepth = prev;
        }
        return previous[n];
    });
}
exports.memo = memo;


/***/ }),

/***/ "./node_modules/fast-check/lib/arbitrary/mixedCase.js":
/*!************************************************************!*\
  !*** ./node_modules/fast-check/lib/arbitrary/mixedCase.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.mixedCase = void 0;
const Converters_1 = __webpack_require__(/*! ../check/arbitrary/definition/Converters */ "./node_modules/fast-check/lib/check/arbitrary/definition/Converters.js");
const MixedCaseArbitrary_1 = __webpack_require__(/*! ./_internals/MixedCaseArbitrary */ "./node_modules/fast-check/lib/arbitrary/_internals/MixedCaseArbitrary.js");
function defaultToggleCase(rawChar) {
    const upper = rawChar.toUpperCase();
    if (upper !== rawChar)
        return upper;
    return rawChar.toLowerCase();
}
function mixedCase(stringArb, constraints) {
    if (typeof BigInt === 'undefined') {
        throw new Error(`mixedCase requires BigInt support`);
    }
    const toggleCase = (constraints && constraints.toggleCase) || defaultToggleCase;
    return Converters_1.convertFromNext(new MixedCaseArbitrary_1.MixedCaseArbitrary(Converters_1.convertToNext(stringArb), toggleCase));
}
exports.mixedCase = mixedCase;


/***/ }),

/***/ "./node_modules/fast-check/lib/arbitrary/nat.js":
/*!******************************************************!*\
  !*** ./node_modules/fast-check/lib/arbitrary/nat.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.nat = void 0;
const Converters_1 = __webpack_require__(/*! ../check/arbitrary/definition/Converters */ "./node_modules/fast-check/lib/check/arbitrary/definition/Converters.js");
const IntegerArbitrary_1 = __webpack_require__(/*! ./_internals/IntegerArbitrary */ "./node_modules/fast-check/lib/arbitrary/_internals/IntegerArbitrary.js");
function nat(arg) {
    const max = typeof arg === 'number' ? arg : arg && arg.max !== undefined ? arg.max : 0x7fffffff;
    if (max < 0) {
        throw new Error('fc.nat value should be greater than or equal to 0');
    }
    const arb = new IntegerArbitrary_1.IntegerArbitrary(0, max);
    return Converters_1.convertFromNextWithShrunkOnce(arb, arb.defaultTarget());
}
exports.nat = nat;


/***/ }),

/***/ "./node_modules/fast-check/lib/arbitrary/oneof.js":
/*!********************************************************!*\
  !*** ./node_modules/fast-check/lib/arbitrary/oneof.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.oneof = void 0;
const FrequencyArbitrary_1 = __webpack_require__(/*! ./_internals/FrequencyArbitrary */ "./node_modules/fast-check/lib/arbitrary/_internals/FrequencyArbitrary.js");
function isOneOfContraints(param) {
    return param != null && typeof param === 'object' && !('generate' in param);
}
function oneof(...args) {
    const constraints = args[0];
    if (isOneOfContraints(constraints)) {
        const weightedArbs = args.slice(1).map((arbitrary) => ({ arbitrary, weight: 1 }));
        return FrequencyArbitrary_1.FrequencyArbitrary.fromOld(weightedArbs, constraints, 'fc.oneof');
    }
    const weightedArbs = args.map((arbitrary) => ({ arbitrary, weight: 1 }));
    return FrequencyArbitrary_1.FrequencyArbitrary.fromOld(weightedArbs, {}, 'fc.oneof');
}
exports.oneof = oneof;


/***/ }),

/***/ "./node_modules/fast-check/lib/arbitrary/option.js":
/*!*********************************************************!*\
  !*** ./node_modules/fast-check/lib/arbitrary/option.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.option = void 0;
const constant_1 = __webpack_require__(/*! ./constant */ "./node_modules/fast-check/lib/arbitrary/constant.js");
const FrequencyArbitrary_1 = __webpack_require__(/*! ./_internals/FrequencyArbitrary */ "./node_modules/fast-check/lib/arbitrary/_internals/FrequencyArbitrary.js");
function extractOptionConstraints(constraints) {
    if (typeof constraints === 'number')
        return { freq: constraints };
    if (!constraints)
        return {};
    return constraints;
}
function option(arb, rawConstraints) {
    const constraints = extractOptionConstraints(rawConstraints);
    const freq = constraints.freq == null ? 5 : constraints.freq;
    const nilValue = Object.prototype.hasOwnProperty.call(constraints, 'nil') ? constraints.nil : null;
    const nilArb = constant_1.constant(nilValue);
    const weightedArbs = [
        { arbitrary: nilArb, weight: 1, fallbackValue: { default: nilValue } },
        { arbitrary: arb, weight: freq },
    ];
    const frequencyConstraints = {
        withCrossShrink: true,
        depthFactor: constraints.depthFactor,
        maxDepth: constraints.maxDepth,
        depthIdentifier: constraints.depthIdentifier,
    };
    return FrequencyArbitrary_1.FrequencyArbitrary.fromOld(weightedArbs, frequencyConstraints, 'fc.option');
}
exports.option = option;


/***/ }),

/***/ "./node_modules/fast-check/lib/arbitrary/record.js":
/*!*********************************************************!*\
  !*** ./node_modules/fast-check/lib/arbitrary/record.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.record = void 0;
const PartialRecordArbitraryBuilder_1 = __webpack_require__(/*! ./_internals/builders/PartialRecordArbitraryBuilder */ "./node_modules/fast-check/lib/arbitrary/_internals/builders/PartialRecordArbitraryBuilder.js");
function record(recordModel, constraints) {
    if (constraints == null) {
        return PartialRecordArbitraryBuilder_1.buildPartialRecordArbitrary(recordModel, undefined);
    }
    if ('withDeletedKeys' in constraints && 'requiredKeys' in constraints) {
        throw new Error(`requiredKeys and withDeletedKeys cannot be used together in fc.record`);
    }
    const requireDeletedKeys = ('requiredKeys' in constraints && constraints.requiredKeys !== undefined) ||
        ('withDeletedKeys' in constraints && !!constraints.withDeletedKeys);
    if (!requireDeletedKeys) {
        return PartialRecordArbitraryBuilder_1.buildPartialRecordArbitrary(recordModel, undefined);
    }
    const requiredKeys = ('requiredKeys' in constraints ? constraints.requiredKeys : undefined) || [];
    for (let idx = 0; idx !== requiredKeys.length; ++idx) {
        const descriptor = Object.getOwnPropertyDescriptor(recordModel, requiredKeys[idx]);
        if (descriptor === undefined) {
            throw new Error(`requiredKeys cannot reference keys that have not been defined in recordModel`);
        }
        if (!descriptor.enumerable) {
            throw new Error(`requiredKeys cannot reference keys that have are enumerable in recordModel`);
        }
    }
    return PartialRecordArbitraryBuilder_1.buildPartialRecordArbitrary(recordModel, requiredKeys);
}
exports.record = record;


/***/ }),

/***/ "./node_modules/fast-check/lib/arbitrary/scheduler.js":
/*!************************************************************!*\
  !*** ./node_modules/fast-check/lib/arbitrary/scheduler.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.schedulerFor = exports.scheduler = void 0;
const Converters_1 = __webpack_require__(/*! ../check/arbitrary/definition/Converters */ "./node_modules/fast-check/lib/check/arbitrary/definition/Converters.js");
const BuildSchedulerFor_1 = __webpack_require__(/*! ./_internals/helpers/BuildSchedulerFor */ "./node_modules/fast-check/lib/arbitrary/_internals/helpers/BuildSchedulerFor.js");
const SchedulerArbitrary_1 = __webpack_require__(/*! ./_internals/SchedulerArbitrary */ "./node_modules/fast-check/lib/arbitrary/_internals/SchedulerArbitrary.js");
function scheduler(constraints) {
    const { act = (f) => f() } = constraints || {};
    return Converters_1.convertFromNext(new SchedulerArbitrary_1.SchedulerArbitrary(act));
}
exports.scheduler = scheduler;
function schedulerFor(customOrderingOrConstraints, constraintsOrUndefined) {
    const { act = (f) => f() } = Array.isArray(customOrderingOrConstraints)
        ? constraintsOrUndefined || {}
        : customOrderingOrConstraints || {};
    if (Array.isArray(customOrderingOrConstraints)) {
        return BuildSchedulerFor_1.buildSchedulerFor(act, customOrderingOrConstraints);
    }
    return function (_strs, ...ordering) {
        return BuildSchedulerFor_1.buildSchedulerFor(act, ordering);
    };
}
exports.schedulerFor = schedulerFor;


/***/ }),

/***/ "./node_modules/fast-check/lib/arbitrary/set.js":
/*!******************************************************!*\
  !*** ./node_modules/fast-check/lib/arbitrary/set.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.set = void 0;
const ArrayArbitrary_1 = __webpack_require__(/*! ./_internals/ArrayArbitrary */ "./node_modules/fast-check/lib/arbitrary/_internals/ArrayArbitrary.js");
const Converters_1 = __webpack_require__(/*! ../check/arbitrary/definition/Converters */ "./node_modules/fast-check/lib/check/arbitrary/definition/Converters.js");
const MaxLengthFromMinLength_1 = __webpack_require__(/*! ./_internals/helpers/MaxLengthFromMinLength */ "./node_modules/fast-check/lib/arbitrary/_internals/helpers/MaxLengthFromMinLength.js");
function buildCompleteSetConstraints(constraints) {
    const minLength = constraints.minLength !== undefined ? constraints.minLength : 0;
    const maxLength = constraints.maxLength !== undefined ? constraints.maxLength : MaxLengthFromMinLength_1.maxLengthFromMinLength(minLength);
    const compare = constraints.compare !== undefined ? constraints.compare : (a, b) => a === b;
    return { minLength, maxLength, compare };
}
function extractSetConstraints(args) {
    if (args[0] === undefined) {
        return {};
    }
    if (args[1] === undefined) {
        const sargs = args;
        if (typeof sargs[0] === 'number')
            return { maxLength: sargs[0] };
        if (typeof sargs[0] === 'function')
            return { compare: sargs[0] };
        return sargs[0];
    }
    if (args[2] === undefined) {
        const sargs = args;
        if (typeof sargs[1] === 'number')
            return { minLength: sargs[0], maxLength: sargs[1] };
        return { maxLength: sargs[0], compare: sargs[1] };
    }
    const sargs = args;
    return { minLength: sargs[0], maxLength: sargs[1], compare: sargs[2] };
}
function set(arb, ...args) {
    const constraints = buildCompleteSetConstraints(extractSetConstraints(args));
    const minLength = constraints.minLength;
    const maxLength = constraints.maxLength;
    const compare = constraints.compare;
    const nextArb = Converters_1.convertToNext(arb);
    const arrayArb = Converters_1.convertFromNext(new ArrayArbitrary_1.ArrayArbitrary(nextArb, minLength, maxLength, compare));
    if (minLength === 0)
        return arrayArb;
    return arrayArb.filter((tab) => tab.length >= minLength);
}
exports.set = set;


/***/ }),

/***/ "./node_modules/fast-check/lib/arbitrary/string.js":
/*!*********************************************************!*\
  !*** ./node_modules/fast-check/lib/arbitrary/string.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.string = void 0;
const Converters_1 = __webpack_require__(/*! ../check/arbitrary/definition/Converters */ "./node_modules/fast-check/lib/check/arbitrary/definition/Converters.js");
const array_1 = __webpack_require__(/*! ./array */ "./node_modules/fast-check/lib/arbitrary/array.js");
const char_1 = __webpack_require__(/*! ./char */ "./node_modules/fast-check/lib/arbitrary/char.js");
const StringConstraintsExtractor_1 = __webpack_require__(/*! ./_internals/helpers/StringConstraintsExtractor */ "./node_modules/fast-check/lib/arbitrary/_internals/helpers/StringConstraintsExtractor.js");
const CodePointsToString_1 = __webpack_require__(/*! ./_internals/mappers/CodePointsToString */ "./node_modules/fast-check/lib/arbitrary/_internals/mappers/CodePointsToString.js");
function string(...args) {
    const constraints = StringConstraintsExtractor_1.extractStringConstraints(args);
    return Converters_1.convertFromNext(Converters_1.convertToNext(array_1.array(char_1.char(), constraints)).map(CodePointsToString_1.codePointsToStringMapper, CodePointsToString_1.codePointsToStringUnmapper));
}
exports.string = string;


/***/ }),

/***/ "./node_modules/fast-check/lib/arbitrary/string16bits.js":
/*!***************************************************************!*\
  !*** ./node_modules/fast-check/lib/arbitrary/string16bits.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.string16bits = void 0;
const Converters_1 = __webpack_require__(/*! ../check/arbitrary/definition/Converters */ "./node_modules/fast-check/lib/check/arbitrary/definition/Converters.js");
const array_1 = __webpack_require__(/*! ./array */ "./node_modules/fast-check/lib/arbitrary/array.js");
const char16bits_1 = __webpack_require__(/*! ./char16bits */ "./node_modules/fast-check/lib/arbitrary/char16bits.js");
const StringConstraintsExtractor_1 = __webpack_require__(/*! ./_internals/helpers/StringConstraintsExtractor */ "./node_modules/fast-check/lib/arbitrary/_internals/helpers/StringConstraintsExtractor.js");
const CharsToString_1 = __webpack_require__(/*! ./_internals/mappers/CharsToString */ "./node_modules/fast-check/lib/arbitrary/_internals/mappers/CharsToString.js");
function string16bits(...args) {
    const constraints = StringConstraintsExtractor_1.extractStringConstraints(args);
    return Converters_1.convertFromNext(Converters_1.convertToNext(array_1.array(char16bits_1.char16bits(), constraints)).map(CharsToString_1.charsToStringMapper, CharsToString_1.charsToStringUnmapper));
}
exports.string16bits = string16bits;


/***/ }),

/***/ "./node_modules/fast-check/lib/arbitrary/stringOf.js":
/*!***********************************************************!*\
  !*** ./node_modules/fast-check/lib/arbitrary/stringOf.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.stringOf = void 0;
const Converters_1 = __webpack_require__(/*! ../check/arbitrary/definition/Converters */ "./node_modules/fast-check/lib/check/arbitrary/definition/Converters.js");
const array_1 = __webpack_require__(/*! ./array */ "./node_modules/fast-check/lib/arbitrary/array.js");
const StringConstraintsExtractor_1 = __webpack_require__(/*! ./_internals/helpers/StringConstraintsExtractor */ "./node_modules/fast-check/lib/arbitrary/_internals/helpers/StringConstraintsExtractor.js");
const PatternsToString_1 = __webpack_require__(/*! ./_internals/mappers/PatternsToString */ "./node_modules/fast-check/lib/arbitrary/_internals/mappers/PatternsToString.js");
function stringOf(charArb, ...args) {
    const constraints = StringConstraintsExtractor_1.extractStringConstraints(args);
    return Converters_1.convertFromNext(Converters_1.convertToNext(array_1.array(charArb, constraints)).map(PatternsToString_1.patternsToStringMapper, PatternsToString_1.patternsToStringUnmapperFor(Converters_1.convertToNext(charArb), constraints)));
}
exports.stringOf = stringOf;


/***/ }),

/***/ "./node_modules/fast-check/lib/arbitrary/tuple.js":
/*!********************************************************!*\
  !*** ./node_modules/fast-check/lib/arbitrary/tuple.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.tuple = void 0;
const Converters_1 = __webpack_require__(/*! ../check/arbitrary/definition/Converters */ "./node_modules/fast-check/lib/check/arbitrary/definition/Converters.js");
const TupleArbitrary_1 = __webpack_require__(/*! ./_internals/TupleArbitrary */ "./node_modules/fast-check/lib/arbitrary/_internals/TupleArbitrary.js");
function tuple(...arbs) {
    const nextArbs = arbs.map((arb) => Converters_1.convertToNext(arb));
    return Converters_1.convertFromNext(new TupleArbitrary_1.TupleArbitrary(nextArbs));
}
exports.tuple = tuple;


/***/ }),

/***/ "./node_modules/fast-check/lib/arbitrary/uint16Array.js":
/*!**************************************************************!*\
  !*** ./node_modules/fast-check/lib/arbitrary/uint16Array.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.uint16Array = void 0;
const integer_1 = __webpack_require__(/*! ./integer */ "./node_modules/fast-check/lib/arbitrary/integer.js");
const TypedIntArrayArbitraryBuilder_1 = __webpack_require__(/*! ./_internals/builders/TypedIntArrayArbitraryBuilder */ "./node_modules/fast-check/lib/arbitrary/_internals/builders/TypedIntArrayArbitraryBuilder.js");
function uint16Array(constraints = {}) {
    return TypedIntArrayArbitraryBuilder_1.typedIntArrayArbitraryArbitraryBuilder(constraints, 0, 65535, Uint16Array, integer_1.integer);
}
exports.uint16Array = uint16Array;


/***/ }),

/***/ "./node_modules/fast-check/lib/arbitrary/uint32Array.js":
/*!**************************************************************!*\
  !*** ./node_modules/fast-check/lib/arbitrary/uint32Array.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.uint32Array = void 0;
const integer_1 = __webpack_require__(/*! ./integer */ "./node_modules/fast-check/lib/arbitrary/integer.js");
const TypedIntArrayArbitraryBuilder_1 = __webpack_require__(/*! ./_internals/builders/TypedIntArrayArbitraryBuilder */ "./node_modules/fast-check/lib/arbitrary/_internals/builders/TypedIntArrayArbitraryBuilder.js");
function uint32Array(constraints = {}) {
    return TypedIntArrayArbitraryBuilder_1.typedIntArrayArbitraryArbitraryBuilder(constraints, 0, 0xffffffff, Uint32Array, integer_1.integer);
}
exports.uint32Array = uint32Array;


/***/ }),

/***/ "./node_modules/fast-check/lib/arbitrary/uint8Array.js":
/*!*************************************************************!*\
  !*** ./node_modules/fast-check/lib/arbitrary/uint8Array.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.uint8Array = void 0;
const integer_1 = __webpack_require__(/*! ./integer */ "./node_modules/fast-check/lib/arbitrary/integer.js");
const TypedIntArrayArbitraryBuilder_1 = __webpack_require__(/*! ./_internals/builders/TypedIntArrayArbitraryBuilder */ "./node_modules/fast-check/lib/arbitrary/_internals/builders/TypedIntArrayArbitraryBuilder.js");
function uint8Array(constraints = {}) {
    return TypedIntArrayArbitraryBuilder_1.typedIntArrayArbitraryArbitraryBuilder(constraints, 0, 255, Uint8Array, integer_1.integer);
}
exports.uint8Array = uint8Array;


/***/ }),

/***/ "./node_modules/fast-check/lib/arbitrary/uint8ClampedArray.js":
/*!********************************************************************!*\
  !*** ./node_modules/fast-check/lib/arbitrary/uint8ClampedArray.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.uint8ClampedArray = void 0;
const integer_1 = __webpack_require__(/*! ./integer */ "./node_modules/fast-check/lib/arbitrary/integer.js");
const TypedIntArrayArbitraryBuilder_1 = __webpack_require__(/*! ./_internals/builders/TypedIntArrayArbitraryBuilder */ "./node_modules/fast-check/lib/arbitrary/_internals/builders/TypedIntArrayArbitraryBuilder.js");
function uint8ClampedArray(constraints = {}) {
    return TypedIntArrayArbitraryBuilder_1.typedIntArrayArbitraryArbitraryBuilder(constraints, 0, 255, Uint8ClampedArray, integer_1.integer);
}
exports.uint8ClampedArray = uint8ClampedArray;


/***/ }),

/***/ "./node_modules/fast-check/lib/arbitrary/unicode.js":
/*!**********************************************************!*\
  !*** ./node_modules/fast-check/lib/arbitrary/unicode.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.unicode = void 0;
const CharacterArbitraryBuilder_1 = __webpack_require__(/*! ./_internals/builders/CharacterArbitraryBuilder */ "./node_modules/fast-check/lib/arbitrary/_internals/builders/CharacterArbitraryBuilder.js");
const IndexToPrintableIndex_1 = __webpack_require__(/*! ./_internals/mappers/IndexToPrintableIndex */ "./node_modules/fast-check/lib/arbitrary/_internals/mappers/IndexToPrintableIndex.js");
const gapSize = 0xdfff + 1 - 0xd800;
function unicodeMapper(v) {
    if (v < 0xd800)
        return IndexToPrintableIndex_1.indexToPrintableIndexMapper(v);
    return v + gapSize;
}
function unicodeUnmapper(v) {
    if (v < 0xd800)
        return IndexToPrintableIndex_1.indexToPrintableIndexUnmapper(v);
    if (v <= 0xdfff)
        return -1;
    return v - gapSize;
}
function unicode() {
    return CharacterArbitraryBuilder_1.buildCharacterArbitrary(0x0000, 0xffff - gapSize, unicodeMapper, unicodeUnmapper);
}
exports.unicode = unicode;


/***/ }),

/***/ "./node_modules/fast-check/lib/arbitrary/unicodeString.js":
/*!****************************************************************!*\
  !*** ./node_modules/fast-check/lib/arbitrary/unicodeString.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.unicodeString = void 0;
const Converters_1 = __webpack_require__(/*! ../check/arbitrary/definition/Converters */ "./node_modules/fast-check/lib/check/arbitrary/definition/Converters.js");
const array_1 = __webpack_require__(/*! ./array */ "./node_modules/fast-check/lib/arbitrary/array.js");
const unicode_1 = __webpack_require__(/*! ./unicode */ "./node_modules/fast-check/lib/arbitrary/unicode.js");
const StringConstraintsExtractor_1 = __webpack_require__(/*! ./_internals/helpers/StringConstraintsExtractor */ "./node_modules/fast-check/lib/arbitrary/_internals/helpers/StringConstraintsExtractor.js");
const CodePointsToString_1 = __webpack_require__(/*! ./_internals/mappers/CodePointsToString */ "./node_modules/fast-check/lib/arbitrary/_internals/mappers/CodePointsToString.js");
function unicodeString(...args) {
    const constraints = StringConstraintsExtractor_1.extractStringConstraints(args);
    return Converters_1.convertFromNext(Converters_1.convertToNext(array_1.array(unicode_1.unicode(), constraints)).map(CodePointsToString_1.codePointsToStringMapper, CodePointsToString_1.codePointsToStringUnmapper));
}
exports.unicodeString = unicodeString;


/***/ }),

/***/ "./node_modules/fast-check/lib/check/arbitrary/DoubleNextArbitrary.js":
/*!****************************************************************************!*\
  !*** ./node_modules/fast-check/lib/check/arbitrary/DoubleNextArbitrary.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.doubleNext = exports.indexToDouble = exports.doubleToIndex = exports.decomposeDouble = void 0;
const ArrayInt64_1 = __webpack_require__(/*! ./helpers/ArrayInt64 */ "./node_modules/fast-check/lib/check/arbitrary/helpers/ArrayInt64.js");
const ArrayInt64Arbitrary_1 = __webpack_require__(/*! ./helpers/ArrayInt64Arbitrary */ "./node_modules/fast-check/lib/check/arbitrary/helpers/ArrayInt64Arbitrary.js");
const INDEX_POSITIVE_INFINITY = { sign: 1, data: [2146435072, 0] };
const INDEX_NEGATIVE_INFINITY = { sign: -1, data: [2146435072, 1] };
function decomposeDouble(d) {
    const maxSignificand = 2 - Number.EPSILON;
    for (let exponent = -1022; exponent !== 1024; ++exponent) {
        const powExponent = 2 ** exponent;
        const maxForExponent = maxSignificand * powExponent;
        if (Math.abs(d) <= maxForExponent) {
            return { exponent, significand: d / powExponent };
        }
    }
    return { exponent: Number.NaN, significand: Number.NaN };
}
exports.decomposeDouble = decomposeDouble;
function positiveNumberToInt64(n) {
    return [~~(n / 0x100000000), n >>> 0];
}
function indexInDoubleFromDecomp(exponent, significand) {
    if (exponent === -1022) {
        const rescaledSignificand = significand * 2 ** 52;
        return positiveNumberToInt64(rescaledSignificand);
    }
    const rescaledSignificand = (significand - 1) * 2 ** 52;
    const exponentOnlyHigh = (exponent + 1023) * 2 ** 20;
    const index = positiveNumberToInt64(rescaledSignificand);
    index[0] += exponentOnlyHigh;
    return index;
}
function doubleToIndex(d) {
    if (d === Number.POSITIVE_INFINITY) {
        return ArrayInt64_1.clone64(INDEX_POSITIVE_INFINITY);
    }
    if (d === Number.NEGATIVE_INFINITY) {
        return ArrayInt64_1.clone64(INDEX_NEGATIVE_INFINITY);
    }
    const decomp = decomposeDouble(d);
    const exponent = decomp.exponent;
    const significand = decomp.significand;
    if (d > 0 || (d === 0 && 1 / d === Number.POSITIVE_INFINITY)) {
        return { sign: 1, data: indexInDoubleFromDecomp(exponent, significand) };
    }
    else {
        const indexOpposite = indexInDoubleFromDecomp(exponent, -significand);
        if (indexOpposite[1] === 0xffffffff) {
            indexOpposite[0] += 1;
            indexOpposite[1] = 0;
        }
        else {
            indexOpposite[1] += 1;
        }
        return { sign: -1, data: indexOpposite };
    }
}
exports.doubleToIndex = doubleToIndex;
function indexToDouble(index) {
    if (index.sign === -1) {
        const indexOpposite = { sign: 1, data: [index.data[0], index.data[1]] };
        if (indexOpposite.data[1] === 0) {
            indexOpposite.data[0] -= 1;
            indexOpposite.data[1] = 0xffffffff;
        }
        else {
            indexOpposite.data[1] -= 1;
        }
        return -indexToDouble(indexOpposite);
    }
    if (ArrayInt64_1.isEqual64(index, INDEX_POSITIVE_INFINITY)) {
        return Number.POSITIVE_INFINITY;
    }
    if (index.data[0] < 0x200000) {
        return (index.data[0] * 0x100000000 + index.data[1]) * 2 ** -1074;
    }
    const postIndexHigh = index.data[0] - 0x200000;
    const exponent = -1021 + (postIndexHigh >> 20);
    const significand = 1 + ((postIndexHigh & 0xfffff) * 2 ** 32 + index.data[1]) * Number.EPSILON;
    return significand * 2 ** exponent;
}
exports.indexToDouble = indexToDouble;
function safeDoubleToIndex(d, constraintsLabel) {
    if (Number.isNaN(d)) {
        throw new Error('fc.doubleNext constraints.' + constraintsLabel + ' must be a 32-bit float');
    }
    return doubleToIndex(d);
}
function doubleNext(constraints = {}) {
    const { noDefaultInfinity = false, noNaN = false, min = noDefaultInfinity ? -Number.MAX_VALUE : Number.NEGATIVE_INFINITY, max = noDefaultInfinity ? Number.MAX_VALUE : Number.POSITIVE_INFINITY, } = constraints;
    const minIndex = safeDoubleToIndex(min, 'min');
    const maxIndex = safeDoubleToIndex(max, 'max');
    if (ArrayInt64_1.isStrictlySmaller64(maxIndex, minIndex)) {
        throw new Error('fc.doubleNext constraints.min must be smaller or equal to constraints.max');
    }
    if (noNaN) {
        return ArrayInt64Arbitrary_1.arrayInt64(minIndex, maxIndex).map(indexToDouble);
    }
    const positiveMaxIdx = ArrayInt64_1.isStrictlyPositive64(maxIndex);
    const minIndexWithNaN = positiveMaxIdx ? minIndex : ArrayInt64_1.substract64(minIndex, ArrayInt64_1.Unit64);
    const maxIndexWithNaN = positiveMaxIdx ? ArrayInt64_1.add64(maxIndex, ArrayInt64_1.Unit64) : maxIndex;
    return ArrayInt64Arbitrary_1.arrayInt64(minIndexWithNaN, maxIndexWithNaN).map((index) => {
        if (ArrayInt64_1.isStrictlySmaller64(maxIndex, index) || ArrayInt64_1.isStrictlySmaller64(index, minIndex))
            return Number.NaN;
        else
            return indexToDouble(index);
    });
}
exports.doubleNext = doubleNext;


/***/ }),

/***/ "./node_modules/fast-check/lib/check/arbitrary/EmailArbitrary.js":
/*!***********************************************************************!*\
  !*** ./node_modules/fast-check/lib/check/arbitrary/EmailArbitrary.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.emailAddress = void 0;
const array_1 = __webpack_require__(/*! ../../arbitrary/array */ "./node_modules/fast-check/lib/arbitrary/array.js");
const SpecificCharacterRange_1 = __webpack_require__(/*! ./helpers/SpecificCharacterRange */ "./node_modules/fast-check/lib/check/arbitrary/helpers/SpecificCharacterRange.js");
const HostArbitrary_1 = __webpack_require__(/*! ./HostArbitrary */ "./node_modules/fast-check/lib/check/arbitrary/HostArbitrary.js");
const stringOf_1 = __webpack_require__(/*! ../../arbitrary/stringOf */ "./node_modules/fast-check/lib/arbitrary/stringOf.js");
const tuple_1 = __webpack_require__(/*! ../../arbitrary/tuple */ "./node_modules/fast-check/lib/arbitrary/tuple.js");
function emailAddress() {
    const others = ['!', '#', '$', '%', '&', "'", '*', '+', '-', '/', '=', '?', '^', '_', '`', '{', '|', '}', '~'];
    const atextArb = SpecificCharacterRange_1.buildLowerAlphaNumericArb(others);
    const localPartArb = array_1.array(stringOf_1.stringOf(atextArb, { minLength: 1, maxLength: 10 }), { minLength: 1, maxLength: 5 })
        .map((a) => a.join('.'))
        .filter((lp) => lp.length <= 64);
    return tuple_1.tuple(localPartArb, HostArbitrary_1.domain()).map(([lp, d]) => `${lp}@${d}`);
}
exports.emailAddress = emailAddress;


/***/ }),

/***/ "./node_modules/fast-check/lib/check/arbitrary/FloatNextArbitrary.js":
/*!***************************************************************************!*\
  !*** ./node_modules/fast-check/lib/check/arbitrary/FloatNextArbitrary.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.floatNext = exports.indexToFloat = exports.floatToIndex = exports.decomposeFloat = exports.EPSILON_32 = exports.MAX_VALUE_32 = exports.MIN_VALUE_32 = void 0;
const integer_1 = __webpack_require__(/*! ../../arbitrary/integer */ "./node_modules/fast-check/lib/arbitrary/integer.js");
exports.MIN_VALUE_32 = 2 ** -126 * 2 ** -23;
exports.MAX_VALUE_32 = 2 ** 127 * (1 + (2 ** 23 - 1) / 2 ** 23);
exports.EPSILON_32 = 2 ** -23;
const INDEX_POSITIVE_INFINITY = 2139095040;
const INDEX_NEGATIVE_INFINITY = -2139095041;
function decomposeFloat(f) {
    const maxSignificand = 1 + (2 ** 23 - 1) / 2 ** 23;
    for (let exponent = -126; exponent !== 128; ++exponent) {
        const powExponent = 2 ** exponent;
        const maxForExponent = maxSignificand * powExponent;
        if (Math.abs(f) <= maxForExponent) {
            return { exponent, significand: f / powExponent };
        }
    }
    return { exponent: Number.NaN, significand: Number.NaN };
}
exports.decomposeFloat = decomposeFloat;
function indexInFloatFromDecomp(exponent, significand) {
    if (exponent === -126) {
        return significand * 0x800000;
    }
    return (exponent + 127) * 0x800000 + (significand - 1) * 0x800000;
}
function floatToIndex(f) {
    if (f === Number.POSITIVE_INFINITY) {
        return INDEX_POSITIVE_INFINITY;
    }
    if (f === Number.NEGATIVE_INFINITY) {
        return INDEX_NEGATIVE_INFINITY;
    }
    const decomp = decomposeFloat(f);
    const exponent = decomp.exponent;
    const significand = decomp.significand;
    if (Number.isNaN(exponent) || Number.isNaN(significand) || !Number.isInteger(significand * 0x800000)) {
        return Number.NaN;
    }
    if (f > 0 || (f === 0 && 1 / f === Number.POSITIVE_INFINITY)) {
        return indexInFloatFromDecomp(exponent, significand);
    }
    else {
        return -indexInFloatFromDecomp(exponent, -significand) - 1;
    }
}
exports.floatToIndex = floatToIndex;
function indexToFloat(index) {
    if (index < 0) {
        return -indexToFloat(-index - 1);
    }
    if (index === INDEX_POSITIVE_INFINITY) {
        return Number.POSITIVE_INFINITY;
    }
    if (index < 0x1000000) {
        return index * 2 ** -149;
    }
    const postIndex = index - 0x1000000;
    const exponent = -125 + (postIndex >> 23);
    const significand = 1 + (postIndex & 0x7fffff) / 0x800000;
    return significand * 2 ** exponent;
}
exports.indexToFloat = indexToFloat;
function safeFloatToIndex(f, constraintsLabel) {
    const conversionTrick = 'you can convert any double to a 32-bit float by using `new Float32Array([myDouble])[0]`';
    const errorMessage = 'fc.floatNext constraints.' + constraintsLabel + ' must be a 32-bit float - ' + conversionTrick;
    if (Number.isNaN(f) || (Number.isFinite(f) && (f < -exports.MAX_VALUE_32 || f > exports.MAX_VALUE_32))) {
        throw new Error(errorMessage);
    }
    const index = floatToIndex(f);
    if (!Number.isInteger(index)) {
        throw new Error(errorMessage);
    }
    return index;
}
function floatNext(constraints = {}) {
    const { noDefaultInfinity = false, noNaN = false, min = noDefaultInfinity ? -exports.MAX_VALUE_32 : Number.NEGATIVE_INFINITY, max = noDefaultInfinity ? exports.MAX_VALUE_32 : Number.POSITIVE_INFINITY, } = constraints;
    const minIndex = safeFloatToIndex(min, 'min');
    const maxIndex = safeFloatToIndex(max, 'max');
    if (minIndex > maxIndex) {
        throw new Error('fc.floatNext constraints.min must be smaller or equal to constraints.max');
    }
    if (noNaN) {
        return integer_1.integer({ min: minIndex, max: maxIndex }).map(indexToFloat);
    }
    const minIndexWithNaN = maxIndex > 0 ? minIndex : minIndex - 1;
    const maxIndexWithNaN = maxIndex > 0 ? maxIndex + 1 : maxIndex;
    return integer_1.integer({ min: minIndexWithNaN, max: maxIndexWithNaN }).map((index) => {
        if (index > maxIndex || index < minIndex)
            return Number.NaN;
        else
            return indexToFloat(index);
    });
}
exports.floatNext = floatNext;


/***/ }),

/***/ "./node_modules/fast-check/lib/check/arbitrary/FloatingPointArbitrary.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/fast-check/lib/check/arbitrary/FloatingPointArbitrary.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.double = exports.float = void 0;
const DoubleNextArbitrary_1 = __webpack_require__(/*! ./DoubleNextArbitrary */ "./node_modules/fast-check/lib/check/arbitrary/DoubleNextArbitrary.js");
const FloatNextArbitrary_1 = __webpack_require__(/*! ./FloatNextArbitrary */ "./node_modules/fast-check/lib/check/arbitrary/FloatNextArbitrary.js");
const integer_1 = __webpack_require__(/*! ../../arbitrary/integer */ "./node_modules/fast-check/lib/arbitrary/integer.js");
const tuple_1 = __webpack_require__(/*! ../../arbitrary/tuple */ "./node_modules/fast-check/lib/arbitrary/tuple.js");
function next(n) {
    return integer_1.integer(0, (1 << n) - 1);
}
const floatInternal = () => {
    return next(24).map((v) => v / (1 << 24));
};
function float(...args) {
    if (typeof args[0] === 'object') {
        if (args[0].next) {
            return FloatNextArbitrary_1.floatNext(args[0]);
        }
        const min = args[0].min !== undefined ? args[0].min : 0;
        const max = args[0].max !== undefined ? args[0].max : 1;
        return (floatInternal()
            .map((v) => min + v * (max - min))
            .filter((g) => g !== max || g === min));
    }
    else {
        const a = args[0];
        const b = args[1];
        if (a === undefined)
            return floatInternal();
        if (b === undefined)
            return (floatInternal()
                .map((v) => v * a)
                .filter((g) => g !== a || g === 0));
        return (floatInternal()
            .map((v) => a + v * (b - a))
            .filter((g) => g !== b || g === a));
    }
}
exports.float = float;
const doubleFactor = Math.pow(2, 27);
const doubleDivisor = Math.pow(2, -53);
const doubleInternal = () => {
    return tuple_1.tuple(next(26), next(27)).map((v) => (v[0] * doubleFactor + v[1]) * doubleDivisor);
};
function double(...args) {
    if (typeof args[0] === 'object') {
        if (args[0].next) {
            return DoubleNextArbitrary_1.doubleNext(args[0]);
        }
        const min = args[0].min !== undefined ? args[0].min : 0;
        const max = args[0].max !== undefined ? args[0].max : 1;
        return (doubleInternal()
            .map((v) => min + v * (max - min))
            .filter((g) => g !== max || g === min));
    }
    else {
        const a = args[0];
        const b = args[1];
        if (a === undefined)
            return doubleInternal();
        if (b === undefined)
            return (doubleInternal()
                .map((v) => v * a)
                .filter((g) => g !== a || g === 0));
        return (doubleInternal()
            .map((v) => a + v * (b - a))
            .filter((g) => g !== b || g === a));
    }
}
exports.double = double;


/***/ }),

/***/ "./node_modules/fast-check/lib/check/arbitrary/HostArbitrary.js":
/*!**********************************************************************!*\
  !*** ./node_modules/fast-check/lib/check/arbitrary/HostArbitrary.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.hostUserInfo = exports.domain = exports.filterInvalidSubdomainLabel = void 0;
const array_1 = __webpack_require__(/*! ../../arbitrary/array */ "./node_modules/fast-check/lib/arbitrary/array.js");
const SpecificCharacterRange_1 = __webpack_require__(/*! ./helpers/SpecificCharacterRange */ "./node_modules/fast-check/lib/check/arbitrary/helpers/SpecificCharacterRange.js");
const option_1 = __webpack_require__(/*! ../../arbitrary/option */ "./node_modules/fast-check/lib/arbitrary/option.js");
const stringOf_1 = __webpack_require__(/*! ../../arbitrary/stringOf */ "./node_modules/fast-check/lib/arbitrary/stringOf.js");
const tuple_1 = __webpack_require__(/*! ../../arbitrary/tuple */ "./node_modules/fast-check/lib/arbitrary/tuple.js");
function filterInvalidSubdomainLabel(subdomainLabel) {
    if (subdomainLabel.length > 63) {
        return false;
    }
    return (subdomainLabel.length < 4 ||
        subdomainLabel[0] !== 'x' ||
        subdomainLabel[1] !== 'n' ||
        subdomainLabel[2] !== '-' ||
        subdomainLabel[3] !== '-');
}
exports.filterInvalidSubdomainLabel = filterInvalidSubdomainLabel;
function subdomainLabel() {
    const alphaNumericArb = SpecificCharacterRange_1.buildLowerAlphaNumericArb([]);
    const alphaNumericHyphenArb = SpecificCharacterRange_1.buildLowerAlphaNumericArb(['-']);
    return tuple_1.tuple(alphaNumericArb, option_1.option(tuple_1.tuple(stringOf_1.stringOf(alphaNumericHyphenArb, { maxLength: 61 }), alphaNumericArb)))
        .map(([f, d]) => (d === null ? f : `${f}${d[0]}${d[1]}`))
        .filter(filterInvalidSubdomainLabel);
}
function domain() {
    const alphaNumericArb = SpecificCharacterRange_1.buildLowerAlphaArb([]);
    const publicSuffixArb = stringOf_1.stringOf(alphaNumericArb, { minLength: 2, maxLength: 10 });
    return (tuple_1.tuple(array_1.array(subdomainLabel(), { minLength: 1, maxLength: 5 }), publicSuffixArb)
        .map(([mid, ext]) => `${mid.join('.')}.${ext}`)
        .filter((d) => d.length <= 255));
}
exports.domain = domain;
function hostUserInfo() {
    const others = ['-', '.', '_', '~', '!', '$', '&', "'", '(', ')', '*', '+', ',', ';', '=', ':'];
    return stringOf_1.stringOf(SpecificCharacterRange_1.buildAlphaNumericPercentArb(others));
}
exports.hostUserInfo = hostUserInfo;


/***/ }),

/***/ "./node_modules/fast-check/lib/check/arbitrary/ObjectArbitrary.js":
/*!************************************************************************!*\
  !*** ./node_modules/fast-check/lib/check/arbitrary/ObjectArbitrary.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.unicodeJson = exports.json = exports.unicodeJsonObject = exports.jsonObject = exports.object = exports.anything = exports.boxArbitrary = void 0;
const stringify_1 = __webpack_require__(/*! ../../utils/stringify */ "./node_modules/fast-check/lib/utils/stringify.js");
const array_1 = __webpack_require__(/*! ../../arbitrary/array */ "./node_modules/fast-check/lib/arbitrary/array.js");
const boolean_1 = __webpack_require__(/*! ../../arbitrary/boolean */ "./node_modules/fast-check/lib/arbitrary/boolean.js");
const constant_1 = __webpack_require__(/*! ../../arbitrary/constant */ "./node_modules/fast-check/lib/arbitrary/constant.js");
const dictionary_1 = __webpack_require__(/*! ../../arbitrary/dictionary */ "./node_modules/fast-check/lib/arbitrary/dictionary.js");
const FloatingPointArbitrary_1 = __webpack_require__(/*! ./FloatingPointArbitrary */ "./node_modules/fast-check/lib/check/arbitrary/FloatingPointArbitrary.js");
const frequency_1 = __webpack_require__(/*! ../../arbitrary/frequency */ "./node_modules/fast-check/lib/arbitrary/frequency.js");
const maxSafeInteger_1 = __webpack_require__(/*! ../../arbitrary/maxSafeInteger */ "./node_modules/fast-check/lib/arbitrary/maxSafeInteger.js");
const memo_1 = __webpack_require__(/*! ../../arbitrary/memo */ "./node_modules/fast-check/lib/arbitrary/memo.js");
const oneof_1 = __webpack_require__(/*! ../../arbitrary/oneof */ "./node_modules/fast-check/lib/arbitrary/oneof.js");
const set_1 = __webpack_require__(/*! ../../arbitrary/set */ "./node_modules/fast-check/lib/arbitrary/set.js");
const string_1 = __webpack_require__(/*! ../../arbitrary/string */ "./node_modules/fast-check/lib/arbitrary/string.js");
const unicodeString_1 = __webpack_require__(/*! ../../arbitrary/unicodeString */ "./node_modules/fast-check/lib/arbitrary/unicodeString.js");
const tuple_1 = __webpack_require__(/*! ../../arbitrary/tuple */ "./node_modules/fast-check/lib/arbitrary/tuple.js");
const bigInt_1 = __webpack_require__(/*! ../../arbitrary/bigInt */ "./node_modules/fast-check/lib/arbitrary/bigInt.js");
const date_1 = __webpack_require__(/*! ../../arbitrary/date */ "./node_modules/fast-check/lib/arbitrary/date.js");
const float32Array_1 = __webpack_require__(/*! ../../arbitrary/float32Array */ "./node_modules/fast-check/lib/arbitrary/float32Array.js");
const float64Array_1 = __webpack_require__(/*! ../../arbitrary/float64Array */ "./node_modules/fast-check/lib/arbitrary/float64Array.js");
const int16Array_1 = __webpack_require__(/*! ../../arbitrary/int16Array */ "./node_modules/fast-check/lib/arbitrary/int16Array.js");
const int32Array_1 = __webpack_require__(/*! ../../arbitrary/int32Array */ "./node_modules/fast-check/lib/arbitrary/int32Array.js");
const int8Array_1 = __webpack_require__(/*! ../../arbitrary/int8Array */ "./node_modules/fast-check/lib/arbitrary/int8Array.js");
const uint16Array_1 = __webpack_require__(/*! ../../arbitrary/uint16Array */ "./node_modules/fast-check/lib/arbitrary/uint16Array.js");
const uint32Array_1 = __webpack_require__(/*! ../../arbitrary/uint32Array */ "./node_modules/fast-check/lib/arbitrary/uint32Array.js");
const uint8Array_1 = __webpack_require__(/*! ../../arbitrary/uint8Array */ "./node_modules/fast-check/lib/arbitrary/uint8Array.js");
const uint8ClampedArray_1 = __webpack_require__(/*! ../../arbitrary/uint8ClampedArray */ "./node_modules/fast-check/lib/arbitrary/uint8ClampedArray.js");
const SparseArrayArbitrary_1 = __webpack_require__(/*! ./SparseArrayArbitrary */ "./node_modules/fast-check/lib/check/arbitrary/SparseArrayArbitrary.js");
const KeyValuePairsToObject_1 = __webpack_require__(/*! ../../arbitrary/_internals/mappers/KeyValuePairsToObject */ "./node_modules/fast-check/lib/arbitrary/_internals/mappers/KeyValuePairsToObject.js");
function boxArbitrary(arb) {
    return arb.map((v) => {
        switch (typeof v) {
            case 'boolean':
                return new Boolean(v);
            case 'number':
                return new Number(v);
            case 'string':
                return new String(v);
            default:
                return v;
        }
    });
}
exports.boxArbitrary = boxArbitrary;
class QualifiedObjectConstraints {
    constructor(key, values, maxDepth, maxKeys, withSet, withMap, withObjectString, withNullPrototype, withBigInt, withDate, withTypedArray, withSparseArray) {
        this.key = key;
        this.values = values;
        this.maxDepth = maxDepth;
        this.maxKeys = maxKeys;
        this.withSet = withSet;
        this.withMap = withMap;
        this.withObjectString = withObjectString;
        this.withNullPrototype = withNullPrototype;
        this.withBigInt = withBigInt;
        this.withDate = withDate;
        this.withTypedArray = withTypedArray;
        this.withSparseArray = withSparseArray;
    }
    static defaultValues() {
        return [
            boolean_1.boolean(),
            maxSafeInteger_1.maxSafeInteger(),
            FloatingPointArbitrary_1.double({ next: true }),
            string_1.string(),
            oneof_1.oneof(string_1.string(), constant_1.constant(null), constant_1.constant(undefined)),
        ];
    }
    static boxArbitraries(arbs) {
        return arbs.map((arb) => boxArbitrary(arb));
    }
    static boxArbitrariesIfNeeded(arbs, boxEnabled) {
        return boxEnabled ? QualifiedObjectConstraints.boxArbitraries(arbs).concat(arbs) : arbs;
    }
    static from(settings = {}) {
        function orDefault(optionalValue, defaultValue) {
            return optionalValue !== undefined ? optionalValue : defaultValue;
        }
        return new QualifiedObjectConstraints(orDefault(settings.key, string_1.string()), QualifiedObjectConstraints.boxArbitrariesIfNeeded(orDefault(settings.values, QualifiedObjectConstraints.defaultValues()), orDefault(settings.withBoxedValues, false)), orDefault(settings.maxDepth, 2), orDefault(settings.maxKeys, 5), orDefault(settings.withSet, false), orDefault(settings.withMap, false), orDefault(settings.withObjectString, false), orDefault(settings.withNullPrototype, false), orDefault(settings.withBigInt, false), orDefault(settings.withDate, false), orDefault(settings.withTypedArray, false), orDefault(settings.withSparseArray, false));
    }
}
const anythingInternal = (constraints) => {
    const arbKeys = constraints.withObjectString
        ? memo_1.memo((n) => frequency_1.frequency({ arbitrary: constraints.key, weight: 10 }, { arbitrary: anythingArb(n).map((o) => stringify_1.stringify(o)), weight: 1 }))
        : memo_1.memo(() => constraints.key);
    const arbitrariesForBase = constraints.values;
    const maxDepth = constraints.maxDepth;
    const maxKeys = constraints.maxKeys;
    const entriesOf = (keyArb, valueArb) => set_1.set(tuple_1.tuple(keyArb, valueArb), { maxLength: maxKeys, compare: (t1, t2) => t1[0] === t2[0] });
    const mapOf = (ka, va) => entriesOf(ka, va).map((v) => new Map(v));
    const dictOf = (ka, va) => entriesOf(ka, va).map((v) => KeyValuePairsToObject_1.keyValuePairsToObjectMapper(v));
    const baseArb = oneof_1.oneof(...arbitrariesForBase);
    const arrayBaseArb = oneof_1.oneof(...arbitrariesForBase.map((arb) => array_1.array(arb, { maxLength: maxKeys })));
    const objectBaseArb = (n) => oneof_1.oneof(...arbitrariesForBase.map((arb) => dictOf(arbKeys(n), arb)));
    const setBaseArb = () => oneof_1.oneof(...arbitrariesForBase.map((arb) => set_1.set(arb, { maxLength: maxKeys }).map((v) => new Set(v))));
    const mapBaseArb = (n) => oneof_1.oneof(...arbitrariesForBase.map((arb) => mapOf(arbKeys(n), arb)));
    const arrayArb = memo_1.memo((n) => oneof_1.oneof(arrayBaseArb, array_1.array(anythingArb(n), { maxLength: maxKeys })));
    const setArb = memo_1.memo((n) => oneof_1.oneof(setBaseArb(), set_1.set(anythingArb(n), { maxLength: maxKeys }).map((v) => new Set(v))));
    const mapArb = memo_1.memo((n) => oneof_1.oneof(mapBaseArb(n), oneof_1.oneof(mapOf(arbKeys(n), anythingArb(n)), mapOf(anythingArb(n), anythingArb(n)))));
    const objectArb = memo_1.memo((n) => oneof_1.oneof(objectBaseArb(n), dictOf(arbKeys(n), anythingArb(n))));
    const anythingArb = memo_1.memo((n) => {
        if (n <= 0)
            return oneof_1.oneof(baseArb);
        return oneof_1.oneof(baseArb, arrayArb(), objectArb(), ...(constraints.withMap ? [mapArb()] : []), ...(constraints.withSet ? [setArb()] : []), ...(constraints.withObjectString ? [anythingArb().map((o) => stringify_1.stringify(o))] : []), ...(constraints.withNullPrototype ? [objectArb().map((o) => Object.assign(Object.create(null), o))] : []), ...(constraints.withBigInt ? [bigInt_1.bigInt()] : []), ...(constraints.withDate ? [date_1.date()] : []), ...(constraints.withTypedArray
            ? [
                oneof_1.oneof(int8Array_1.int8Array(), uint8Array_1.uint8Array(), uint8ClampedArray_1.uint8ClampedArray(), int16Array_1.int16Array(), uint16Array_1.uint16Array(), int32Array_1.int32Array(), uint32Array_1.uint32Array(), float32Array_1.float32Array(), float64Array_1.float64Array()),
            ]
            : []), ...(constraints.withSparseArray ? [SparseArrayArbitrary_1.sparseArray(anythingArb())] : []));
    });
    return anythingArb(maxDepth);
};
const objectInternal = (constraints) => {
    return dictionary_1.dictionary(constraints.key, anythingInternal(constraints));
};
function anything(constraints) {
    return anythingInternal(QualifiedObjectConstraints.from(constraints));
}
exports.anything = anything;
function object(constraints) {
    return objectInternal(QualifiedObjectConstraints.from(constraints));
}
exports.object = object;
function jsonSettings(stringArbitrary, constraints) {
    const key = stringArbitrary;
    const values = [
        boolean_1.boolean(),
        maxSafeInteger_1.maxSafeInteger(),
        FloatingPointArbitrary_1.double({ next: true, noDefaultInfinity: true, noNaN: true }),
        stringArbitrary,
        constant_1.constant(null),
    ];
    return constraints != null
        ? typeof constraints === 'number'
            ? { key, values, maxDepth: constraints }
            : { key, values, maxDepth: constraints.maxDepth }
        : { key, values };
}
function jsonObject(constraints) {
    return anything(jsonSettings(string_1.string(), constraints));
}
exports.jsonObject = jsonObject;
function unicodeJsonObject(constraints) {
    return anything(jsonSettings(unicodeString_1.unicodeString(), constraints));
}
exports.unicodeJsonObject = unicodeJsonObject;
function json(constraints) {
    const arb = constraints != null ? jsonObject(constraints) : jsonObject();
    return arb.map(JSON.stringify);
}
exports.json = json;
function unicodeJson(constraints) {
    const arb = constraints != null ? unicodeJsonObject(constraints) : unicodeJsonObject();
    return arb.map(JSON.stringify);
}
exports.unicodeJson = unicodeJson;


/***/ }),

/***/ "./node_modules/fast-check/lib/check/arbitrary/SparseArrayArbitrary.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/fast-check/lib/check/arbitrary/SparseArrayArbitrary.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.sparseArray = void 0;
const nat_1 = __webpack_require__(/*! ../../arbitrary/nat */ "./node_modules/fast-check/lib/arbitrary/nat.js");
const set_1 = __webpack_require__(/*! ../../arbitrary/set */ "./node_modules/fast-check/lib/arbitrary/set.js");
const tuple_1 = __webpack_require__(/*! ../../arbitrary/tuple */ "./node_modules/fast-check/lib/arbitrary/tuple.js");
const MaxLengthFromMinLength_1 = __webpack_require__(/*! ../../arbitrary/_internals/helpers/MaxLengthFromMinLength */ "./node_modules/fast-check/lib/arbitrary/_internals/helpers/MaxLengthFromMinLength.js");
function extractMaxIndex(indexesAndValues) {
    let maxIndex = -1;
    for (let index = 0; index !== indexesAndValues.length; ++index) {
        maxIndex = Math.max(maxIndex, indexesAndValues[index][0]);
    }
    return maxIndex;
}
function arrayFromItems(length, indexesAndValues) {
    const array = Array(length);
    for (let index = 0; index !== indexesAndValues.length; ++index) {
        const it = indexesAndValues[index];
        if (it[0] < length)
            array[it[0]] = it[1];
    }
    return array;
}
function sparseArray(arb, constraints = {}) {
    const { minNumElements = 0, maxNumElements = MaxLengthFromMinLength_1.maxLengthFromMinLength(minNumElements), maxLength = Math.min(MaxLengthFromMinLength_1.maxLengthFromMinLength(maxNumElements), 4294967295), noTrailingHole, } = constraints;
    if (minNumElements > maxLength) {
        throw new Error(`The minimal number of non-hole elements cannot be higher than the maximal length of the array`);
    }
    if (minNumElements > maxNumElements) {
        throw new Error(`The minimal number of non-hole elements cannot be higher than the maximal number of non-holes`);
    }
    const resultedMaxNumElements = Math.min(maxNumElements, maxLength);
    if (noTrailingHole) {
        const maxIndexAuthorized = Math.max(maxLength - 1, 0);
        return set_1.set(tuple_1.tuple(nat_1.nat(maxIndexAuthorized), arb), {
            minLength: minNumElements,
            maxLength: resultedMaxNumElements,
            compare: (itemA, itemB) => itemA[0] === itemB[0],
        }).map((items) => {
            const lastIndex = extractMaxIndex(items);
            return arrayFromItems(lastIndex + 1, items);
        });
    }
    return set_1.set(tuple_1.tuple(nat_1.nat(maxLength), arb), {
        minLength: minNumElements + 1,
        maxLength: resultedMaxNumElements + 1,
        compare: (itemA, itemB) => itemA[0] === itemB[0],
    }).map((items) => {
        const length = extractMaxIndex(items);
        return arrayFromItems(length, items);
    });
}
exports.sparseArray = sparseArray;


/***/ }),

/***/ "./node_modules/fast-check/lib/check/arbitrary/SubarrayArbitrary.js":
/*!**************************************************************************!*\
  !*** ./node_modules/fast-check/lib/check/arbitrary/SubarrayArbitrary.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.shuffledSubarray = exports.subarray = void 0;
const Stream_1 = __webpack_require__(/*! ../../stream/Stream */ "./node_modules/fast-check/lib/stream/Stream.js");
const Arbitrary_1 = __webpack_require__(/*! ./definition/Arbitrary */ "./node_modules/fast-check/lib/check/arbitrary/definition/Arbitrary.js");
const BiasedArbitraryWrapper_1 = __webpack_require__(/*! ./definition/BiasedArbitraryWrapper */ "./node_modules/fast-check/lib/check/arbitrary/definition/BiasedArbitraryWrapper.js");
const Shrinkable_1 = __webpack_require__(/*! ./definition/Shrinkable */ "./node_modules/fast-check/lib/check/arbitrary/definition/Shrinkable.js");
const integer_1 = __webpack_require__(/*! ../../arbitrary/integer */ "./node_modules/fast-check/lib/arbitrary/integer.js");
const LazyIterableIterator_1 = __webpack_require__(/*! ../../stream/LazyIterableIterator */ "./node_modules/fast-check/lib/stream/LazyIterableIterator.js");
class SubarrayArbitrary extends Arbitrary_1.Arbitrary {
    constructor(originalArray, isOrdered, minLength, maxLength) {
        super();
        this.originalArray = originalArray;
        this.isOrdered = isOrdered;
        this.minLength = minLength;
        this.maxLength = maxLength;
        if (minLength < 0 || minLength > originalArray.length)
            throw new Error('fc.*{s|S}ubarrayOf expects the minimal length to be between 0 and the size of the original array');
        if (maxLength < 0 || maxLength > originalArray.length)
            throw new Error('fc.*{s|S}ubarrayOf expects the maximal length to be between 0 and the size of the original array');
        if (minLength > maxLength)
            throw new Error('fc.*{s|S}ubarrayOf expects the minimal length to be inferior or equal to the maximal length');
        this.lengthArb = integer_1.integer(minLength, maxLength);
    }
    wrapper(items, itemsLengthContext) {
        return new Shrinkable_1.Shrinkable(items, () => this.shrinkImpl(items, itemsLengthContext).map((contextualValue) => this.wrapper(contextualValue[0], contextualValue[1])));
    }
    generate(mrng) {
        const remainingElements = this.originalArray.map((_v, idx) => idx);
        const size = this.lengthArb.generate(mrng).value;
        const ids = [];
        for (let idx = 0; idx !== size; ++idx) {
            const selectedIdIndex = mrng.nextInt(0, remainingElements.length - 1);
            ids.push(remainingElements[selectedIdIndex]);
            remainingElements.splice(selectedIdIndex, 1);
        }
        if (this.isOrdered)
            ids.sort((a, b) => a - b);
        return this.wrapper(ids.map((i) => this.originalArray[i]), undefined);
    }
    shrinkImpl(items, itemsLengthContext) {
        if (items.length === 0) {
            return Stream_1.Stream.nil();
        }
        return this.lengthArb
            .contextualShrink(items.length, itemsLengthContext)
            .map((contextualValue) => {
            return [
                items.slice(items.length - contextualValue[0]),
                contextualValue[1],
            ];
        })
            .join(items.length > this.minLength
            ? LazyIterableIterator_1.makeLazy(() => this.shrinkImpl(items.slice(1), undefined)
                .filter((contextualValue) => this.minLength <= contextualValue[0].length + 1)
                .map((contextualValue) => [[items[0]].concat(contextualValue[0]), undefined]))
            : Stream_1.Stream.nil());
    }
    withBias(freq) {
        return this.minLength !== this.maxLength
            ? BiasedArbitraryWrapper_1.biasWrapper(freq, this, (originalArbitrary) => {
                return new SubarrayArbitrary(originalArbitrary.originalArray, originalArbitrary.isOrdered, originalArbitrary.minLength, originalArbitrary.minLength +
                    Math.floor(Math.log(originalArbitrary.maxLength - originalArbitrary.minLength) / Math.log(2)));
            })
            : this;
    }
}
function subarray(originalArray, ...args) {
    if (typeof args[0] === 'number' && typeof args[1] === 'number') {
        return new SubarrayArbitrary(originalArray, true, args[0], args[1]);
    }
    const ct = args[0];
    const minLength = ct !== undefined && ct.minLength !== undefined ? ct.minLength : 0;
    const maxLength = ct !== undefined && ct.maxLength !== undefined ? ct.maxLength : originalArray.length;
    return new SubarrayArbitrary(originalArray, true, minLength, maxLength);
}
exports.subarray = subarray;
function shuffledSubarray(originalArray, ...args) {
    if (typeof args[0] === 'number' && typeof args[1] === 'number') {
        return new SubarrayArbitrary(originalArray, false, args[0], args[1]);
    }
    const ct = args[0];
    const minLength = ct !== undefined && ct.minLength !== undefined ? ct.minLength : 0;
    const maxLength = ct !== undefined && ct.maxLength !== undefined ? ct.maxLength : originalArray.length;
    return new SubarrayArbitrary(originalArray, false, minLength, maxLength);
}
exports.shuffledSubarray = shuffledSubarray;


/***/ }),

/***/ "./node_modules/fast-check/lib/check/arbitrary/UuidArbitrary.js":
/*!**********************************************************************!*\
  !*** ./node_modules/fast-check/lib/check/arbitrary/UuidArbitrary.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.uuidV = exports.uuid = void 0;
const integer_1 = __webpack_require__(/*! ../../arbitrary/integer */ "./node_modules/fast-check/lib/arbitrary/integer.js");
const nat_1 = __webpack_require__(/*! ../../arbitrary/nat */ "./node_modules/fast-check/lib/arbitrary/nat.js");
const tuple_1 = __webpack_require__(/*! ../../arbitrary/tuple */ "./node_modules/fast-check/lib/arbitrary/tuple.js");
const padEight = (arb) => arb.map((n) => n.toString(16).padStart(8, '0'));
function uuid() {
    const padded = padEight(nat_1.nat(0xffffffff));
    const secondPadded = padEight(integer_1.integer(0x10000000, 0x5fffffff));
    const thirdPadded = padEight(integer_1.integer(0x80000000, 0xbfffffff));
    return tuple_1.tuple(padded, secondPadded, thirdPadded, padded).map((t) => {
        return `${t[0]}-${t[1].substring(4)}-${t[1].substring(0, 4)}-${t[2].substring(0, 4)}-${t[2].substring(4)}${t[3]}`;
    });
}
exports.uuid = uuid;
function uuidV(versionNumber) {
    const padded = padEight(nat_1.nat(0xffffffff));
    const secondPadded = padEight(nat_1.nat(0x0fffffff));
    const thirdPadded = padEight(integer_1.integer(0x80000000, 0xbfffffff));
    return tuple_1.tuple(padded, secondPadded, thirdPadded, padded).map((t) => {
        return `${t[0]}-${t[1].substring(4)}-${versionNumber}${t[1].substring(1, 4)}-${t[2].substring(0, 4)}-${t[2].substring(4)}${t[3]}`;
    });
}
exports.uuidV = uuidV;


/***/ }),

/***/ "./node_modules/fast-check/lib/check/arbitrary/WebArbitrary.js":
/*!*********************************************************************!*\
  !*** ./node_modules/fast-check/lib/check/arbitrary/WebArbitrary.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.webUrl = exports.webFragments = exports.webQueryParameters = exports.webSegment = exports.webAuthority = void 0;
const array_1 = __webpack_require__(/*! ../../arbitrary/array */ "./node_modules/fast-check/lib/arbitrary/array.js");
const constantFrom_1 = __webpack_require__(/*! ../../arbitrary/constantFrom */ "./node_modules/fast-check/lib/arbitrary/constantFrom.js");
const constant_1 = __webpack_require__(/*! ../../arbitrary/constant */ "./node_modules/fast-check/lib/arbitrary/constant.js");
const SpecificCharacterRange_1 = __webpack_require__(/*! ./helpers/SpecificCharacterRange */ "./node_modules/fast-check/lib/check/arbitrary/helpers/SpecificCharacterRange.js");
const HostArbitrary_1 = __webpack_require__(/*! ./HostArbitrary */ "./node_modules/fast-check/lib/check/arbitrary/HostArbitrary.js");
const nat_1 = __webpack_require__(/*! ../../arbitrary/nat */ "./node_modules/fast-check/lib/arbitrary/nat.js");
const ipV4_1 = __webpack_require__(/*! ../../arbitrary/ipV4 */ "./node_modules/fast-check/lib/arbitrary/ipV4.js");
const ipV4Extended_1 = __webpack_require__(/*! ../../arbitrary/ipV4Extended */ "./node_modules/fast-check/lib/arbitrary/ipV4Extended.js");
const ipV6_1 = __webpack_require__(/*! ../../arbitrary/ipV6 */ "./node_modules/fast-check/lib/arbitrary/ipV6.js");
const oneof_1 = __webpack_require__(/*! ../../arbitrary/oneof */ "./node_modules/fast-check/lib/arbitrary/oneof.js");
const option_1 = __webpack_require__(/*! ../../arbitrary/option */ "./node_modules/fast-check/lib/arbitrary/option.js");
const stringOf_1 = __webpack_require__(/*! ../../arbitrary/stringOf */ "./node_modules/fast-check/lib/arbitrary/stringOf.js");
const tuple_1 = __webpack_require__(/*! ../../arbitrary/tuple */ "./node_modules/fast-check/lib/arbitrary/tuple.js");
function webAuthority(constraints) {
    const c = constraints || {};
    const hostnameArbs = [HostArbitrary_1.domain()]
        .concat(c.withIPv4 === true ? [ipV4_1.ipV4()] : [])
        .concat(c.withIPv6 === true ? [ipV6_1.ipV6().map((ip) => `[${ip}]`)] : [])
        .concat(c.withIPv4Extended === true ? [ipV4Extended_1.ipV4Extended()] : []);
    return tuple_1.tuple(c.withUserInfo === true ? option_1.option(HostArbitrary_1.hostUserInfo()) : constant_1.constant(null), oneof_1.oneof(...hostnameArbs), c.withPort === true ? option_1.option(nat_1.nat(65535)) : constant_1.constant(null)).map(([u, h, p]) => (u === null ? '' : `${u}@`) + h + (p === null ? '' : `:${p}`));
}
exports.webAuthority = webAuthority;
function webSegment() {
    const others = ['-', '.', '_', '~', '!', '$', '&', "'", '(', ')', '*', '+', ',', ';', '=', ':', '@'];
    return stringOf_1.stringOf(SpecificCharacterRange_1.buildAlphaNumericPercentArb(others));
}
exports.webSegment = webSegment;
function uriQueryOrFragment() {
    const others = ['-', '.', '_', '~', '!', '$', '&', "'", '(', ')', '*', '+', ',', ';', '=', ':', '@', '/', '?'];
    return stringOf_1.stringOf(SpecificCharacterRange_1.buildAlphaNumericPercentArb(others));
}
function webQueryParameters() {
    return uriQueryOrFragment();
}
exports.webQueryParameters = webQueryParameters;
function webFragments() {
    return uriQueryOrFragment();
}
exports.webFragments = webFragments;
function webUrl(constraints) {
    const c = constraints || {};
    const validSchemes = c.validSchemes || ['http', 'https'];
    const schemeArb = constantFrom_1.constantFrom(...validSchemes);
    const authorityArb = webAuthority(c.authoritySettings);
    const pathArb = array_1.array(webSegment()).map((p) => p.map((v) => `/${v}`).join(''));
    return tuple_1.tuple(schemeArb, authorityArb, pathArb, c.withQueryParameters === true ? option_1.option(webQueryParameters()) : constant_1.constant(null), c.withFragments === true ? option_1.option(webFragments()) : constant_1.constant(null)).map(([s, a, p, q, f]) => `${s}://${a}${p}${q === null ? '' : `?${q}`}${f === null ? '' : `#${f}`}`);
}
exports.webUrl = webUrl;


/***/ }),

/***/ "./node_modules/fast-check/lib/check/arbitrary/definition/Arbitrary.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/fast-check/lib/check/arbitrary/definition/Arbitrary.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.assertIsArbitrary = exports.Arbitrary = void 0;
const Shrinkable_1 = __webpack_require__(/*! ./Shrinkable */ "./node_modules/fast-check/lib/check/arbitrary/definition/Shrinkable.js");
class Arbitrary {
    filter(refinement) {
        return new FilterArbitrary(this, refinement);
    }
    map(mapper) {
        return new MapArbitrary(this, mapper);
    }
    chain(fmapper) {
        return new ChainArbitrary(this, fmapper);
    }
    noShrink() {
        return new NoShrinkArbitrary(this);
    }
    withBias(_freq) {
        return this;
    }
    noBias() {
        return new NoBiasArbitrary(this);
    }
}
exports.Arbitrary = Arbitrary;
class ChainArbitrary extends Arbitrary {
    constructor(arb, fmapper) {
        super();
        this.arb = arb;
        this.fmapper = fmapper;
    }
    generate(mrng) {
        const clonedMrng = mrng.clone();
        const src = this.arb.generate(mrng);
        const dst = this.fmapper(src.value).generate(mrng);
        return ChainArbitrary.shrinkChain(clonedMrng, src, dst, this.fmapper);
    }
    withBias(freq) {
        return this.arb.withBias(freq).chain((t) => this.fmapper(t).withBias(freq));
    }
    static shrinkChain(mrng, src, dst, fmapper) {
        return new Shrinkable_1.Shrinkable(dst.value, () => src
            .shrink()
            .map((v) => ChainArbitrary.shrinkChain(mrng.clone(), v, fmapper(v.value).generate(mrng.clone()), fmapper))
            .join(dst.shrink()));
    }
}
class MapArbitrary extends Arbitrary {
    constructor(arb, mapper) {
        super();
        this.arb = arb;
        this.mapper = mapper;
    }
    generate(mrng) {
        return this.arb.generate(mrng).map(this.mapper);
    }
    withBias(freq) {
        return this.arb.withBias(freq).map(this.mapper);
    }
}
class FilterArbitrary extends Arbitrary {
    constructor(arb, refinement) {
        super();
        this.arb = arb;
        this.refinement = refinement;
    }
    generate(mrng) {
        let g = this.arb.generate(mrng);
        while (!this.refinementOnShrinkable(g)) {
            g = this.arb.generate(mrng);
        }
        return g.filter(this.refinement);
    }
    withBias(freq) {
        return this.arb.withBias(freq).filter(this.refinement);
    }
    refinementOnShrinkable(s) {
        return this.refinement(s.value);
    }
}
class NoShrinkArbitrary extends Arbitrary {
    constructor(arb) {
        super();
        this.arb = arb;
    }
    generate(mrng) {
        return new Shrinkable_1.Shrinkable(this.arb.generate(mrng).value);
    }
    withBias(freq) {
        return this.arb.withBias(freq).noShrink();
    }
}
class NoBiasArbitrary extends Arbitrary {
    constructor(arb) {
        super();
        this.arb = arb;
    }
    generate(mrng) {
        return this.arb.generate(mrng);
    }
}
function assertIsArbitrary(instance) {
    if (typeof instance !== 'object' || instance === null || !('generate' in instance)) {
        throw new Error('Unexpected value received: not an instance of Arbitrary');
    }
}
exports.assertIsArbitrary = assertIsArbitrary;


/***/ }),

/***/ "./node_modules/fast-check/lib/check/arbitrary/definition/ArbitraryWithContextualShrink.js":
/*!*************************************************************************************************!*\
  !*** ./node_modules/fast-check/lib/check/arbitrary/definition/ArbitraryWithContextualShrink.js ***!
  \*************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ArbitraryWithContextualShrink = void 0;
const Arbitrary_1 = __webpack_require__(/*! ./Arbitrary */ "./node_modules/fast-check/lib/check/arbitrary/definition/Arbitrary.js");
const Shrinkable_1 = __webpack_require__(/*! ./Shrinkable */ "./node_modules/fast-check/lib/check/arbitrary/definition/Shrinkable.js");
function removeContextFromContextualValue(contextualValue) {
    return contextualValue[0];
}
class ArbitraryWithContextualShrink extends Arbitrary_1.Arbitrary {
    contextualShrinkableFor(value, context) {
        return new Shrinkable_1.Shrinkable(value, () => this.contextualShrink(value, context).map((contextualValue) => this.contextualShrinkableFor(contextualValue[0], contextualValue[1])));
    }
    shrink(value, shrunkOnce) {
        const context = shrunkOnce === true ? this.shrunkOnceContext() : undefined;
        return this.contextualShrink(value, context).map(removeContextFromContextualValue);
    }
    shrinkableFor(value, shrunkOnce) {
        return new Shrinkable_1.Shrinkable(value, () => {
            return this.shrink(value, shrunkOnce).map((value) => this.shrinkableFor(value, true));
        });
    }
}
exports.ArbitraryWithContextualShrink = ArbitraryWithContextualShrink;


/***/ }),

/***/ "./node_modules/fast-check/lib/check/arbitrary/definition/ArbitraryWithShrink.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/fast-check/lib/check/arbitrary/definition/ArbitraryWithShrink.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ArbitraryWithShrink = void 0;
const Arbitrary_1 = __webpack_require__(/*! ./Arbitrary */ "./node_modules/fast-check/lib/check/arbitrary/definition/Arbitrary.js");
const Shrinkable_1 = __webpack_require__(/*! ./Shrinkable */ "./node_modules/fast-check/lib/check/arbitrary/definition/Shrinkable.js");
class ArbitraryWithShrink extends Arbitrary_1.Arbitrary {
    shrinkableFor(value, shrunkOnce) {
        return new Shrinkable_1.Shrinkable(value, () => this.shrink(value, shrunkOnce === true).map((v) => this.shrinkableFor(v, true)));
    }
}
exports.ArbitraryWithShrink = ArbitraryWithShrink;


/***/ }),

/***/ "./node_modules/fast-check/lib/check/arbitrary/definition/BiasedArbitraryWrapper.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/fast-check/lib/check/arbitrary/definition/BiasedArbitraryWrapper.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.biasWrapper = void 0;
const Arbitrary_1 = __webpack_require__(/*! ./Arbitrary */ "./node_modules/fast-check/lib/check/arbitrary/definition/Arbitrary.js");
class BiasedArbitraryWrapper extends Arbitrary_1.Arbitrary {
    constructor(freq, arb, biasedArbBuilder) {
        super();
        this.freq = freq;
        this.arb = arb;
        this.biasedArbBuilder = biasedArbBuilder;
    }
    generate(mrng) {
        return mrng.nextInt(1, this.freq) === 1 ? this.biasedArbBuilder(this.arb).generate(mrng) : this.arb.generate(mrng);
    }
}
function biasWrapper(freq, arb, biasedArbBuilder) {
    return new BiasedArbitraryWrapper(freq, arb, biasedArbBuilder);
}
exports.biasWrapper = biasWrapper;


/***/ }),

/***/ "./node_modules/fast-check/lib/check/arbitrary/definition/ConverterFromNext.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/fast-check/lib/check/arbitrary/definition/ConverterFromNext.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var _a;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ConverterFromNext = void 0;
const ArbitraryWithContextualShrink_1 = __webpack_require__(/*! ./ArbitraryWithContextualShrink */ "./node_modules/fast-check/lib/check/arbitrary/definition/ArbitraryWithContextualShrink.js");
const ConverterToNext_1 = __webpack_require__(/*! ./ConverterToNext */ "./node_modules/fast-check/lib/check/arbitrary/definition/ConverterToNext.js");
const Shrinkable_1 = __webpack_require__(/*! ./Shrinkable */ "./node_modules/fast-check/lib/check/arbitrary/definition/Shrinkable.js");
const identifier = '__ConverterFromNext__';
function fromNextValueToShrinkableFor(arb) {
    return function fromNextValueToShrinkable(v) {
        const value_ = v.value_;
        const shrinker = () => arb.shrink(value_, v.context).map(fromNextValueToShrinkable);
        if (!v.hasToBeCloned) {
            return new Shrinkable_1.Shrinkable(value_, shrinker);
        }
        return new Shrinkable_1.Shrinkable(value_, shrinker, () => v.value);
    };
}
class ConverterFromNext extends ArbitraryWithContextualShrink_1.ArbitraryWithContextualShrink {
    constructor(arb, legacyShrunkOnceContext, biasFactor = undefined) {
        super();
        this.arb = arb;
        this.legacyShrunkOnceContext = legacyShrunkOnceContext;
        this.biasFactor = biasFactor;
        this[_a] = true;
        this.toShrinkable = fromNextValueToShrinkableFor(arb);
    }
    static isConverterFromNext(arb) {
        return identifier in arb;
    }
    static convertIfNeeded(arb) {
        if (ConverterToNext_1.ConverterToNext.isConverterToNext(arb))
            return arb.arb;
        else
            return new ConverterFromNext(arb);
    }
    generate(mrng) {
        const g = this.arb.generate(mrng, this.biasFactor);
        return this.toShrinkable(g);
    }
    contextualShrink(value, context) {
        return this.arb.shrink(value, context).map((v) => [v.value_, v.context]);
    }
    shrunkOnceContext() {
        return this.legacyShrunkOnceContext;
    }
    filter(refinement) {
        return ConverterFromNext.convertIfNeeded(this.arb.filter(refinement));
    }
    map(mapper) {
        return ConverterFromNext.convertIfNeeded(this.arb.map(mapper));
    }
    chain(fmapper) {
        return ConverterFromNext.convertIfNeeded(this.arb.chain((t) => {
            const fmapped = fmapper(t);
            if (ConverterFromNext.isConverterFromNext(fmapped))
                return fmapped.arb;
            else
                return new ConverterToNext_1.ConverterToNext(fmapped);
        }));
    }
    noShrink() {
        return ConverterFromNext.convertIfNeeded(this.arb.noShrink());
    }
    withBias(freq) {
        return new ConverterFromNext(this.arb, this.legacyShrunkOnceContext, freq);
    }
    noBias() {
        return ConverterFromNext.convertIfNeeded(this.arb.noBias());
    }
}
exports.ConverterFromNext = ConverterFromNext;
_a = identifier;


/***/ }),

/***/ "./node_modules/fast-check/lib/check/arbitrary/definition/ConverterToNext.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/fast-check/lib/check/arbitrary/definition/ConverterToNext.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var _a;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ConverterToNext = void 0;
const Stream_1 = __webpack_require__(/*! ../../../stream/Stream */ "./node_modules/fast-check/lib/stream/Stream.js");
const ConverterFromNext_1 = __webpack_require__(/*! ./ConverterFromNext */ "./node_modules/fast-check/lib/check/arbitrary/definition/ConverterFromNext.js");
const NextArbitrary_1 = __webpack_require__(/*! ./NextArbitrary */ "./node_modules/fast-check/lib/check/arbitrary/definition/NextArbitrary.js");
const NextValue_1 = __webpack_require__(/*! ./NextValue */ "./node_modules/fast-check/lib/check/arbitrary/definition/NextValue.js");
const identifier = '__ConverterToNext__';
function fromShrinkableToNextValue(g) {
    if (!g.hasToBeCloned) {
        return new NextValue_1.NextValue(g.value_, g);
    }
    return new NextValue_1.NextValue(g.value_, g, () => g.value);
}
class ConverterToNext extends NextArbitrary_1.NextArbitrary {
    constructor(arb) {
        super();
        this.arb = arb;
        this[_a] = true;
    }
    static isConverterToNext(arb) {
        return identifier in arb;
    }
    static convertIfNeeded(arb) {
        if (ConverterFromNext_1.ConverterFromNext.isConverterFromNext(arb))
            return arb.arb;
        else
            return new ConverterToNext(arb);
    }
    generate(mrng, biasFactor) {
        const g = biasFactor !== undefined ? this.arb.withBias(biasFactor).generate(mrng) : this.arb.generate(mrng);
        return fromShrinkableToNextValue(g);
    }
    canShrinkWithoutContext(_value) {
        return false;
    }
    shrink(_value, context) {
        if (this.isSafeContext(context)) {
            return context.shrink().map(fromShrinkableToNextValue);
        }
        return Stream_1.Stream.nil();
    }
    isSafeContext(context) {
        return (context != null && typeof context === 'object' && 'value' in context && 'shrink' in context);
    }
    filter(refinement) {
        return ConverterToNext.convertIfNeeded(this.arb.filter(refinement));
    }
    map(mapper) {
        return ConverterToNext.convertIfNeeded(this.arb.map(mapper));
    }
    chain(fmapper) {
        return ConverterToNext.convertIfNeeded(this.arb.chain((t) => {
            const fmapped = fmapper(t);
            if (ConverterToNext.isConverterToNext(fmapped))
                return fmapped.arb;
            else
                return new ConverterFromNext_1.ConverterFromNext(fmapped);
        }));
    }
    noShrink() {
        return ConverterToNext.convertIfNeeded(this.arb.noShrink());
    }
    noBias() {
        return ConverterToNext.convertIfNeeded(this.arb.noBias());
    }
}
exports.ConverterToNext = ConverterToNext;
_a = identifier;


/***/ }),

/***/ "./node_modules/fast-check/lib/check/arbitrary/definition/Converters.js":
/*!******************************************************************************!*\
  !*** ./node_modules/fast-check/lib/check/arbitrary/definition/Converters.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.convertToNext = exports.convertFromNextWithShrunkOnce = exports.convertFromNext = void 0;
const Arbitrary_1 = __webpack_require__(/*! ./Arbitrary */ "./node_modules/fast-check/lib/check/arbitrary/definition/Arbitrary.js");
const ConverterFromNext_1 = __webpack_require__(/*! ./ConverterFromNext */ "./node_modules/fast-check/lib/check/arbitrary/definition/ConverterFromNext.js");
const ConverterToNext_1 = __webpack_require__(/*! ./ConverterToNext */ "./node_modules/fast-check/lib/check/arbitrary/definition/ConverterToNext.js");
const NextArbitrary_1 = __webpack_require__(/*! ./NextArbitrary */ "./node_modules/fast-check/lib/check/arbitrary/definition/NextArbitrary.js");
function convertFromNext(arb) {
    if (ConverterToNext_1.ConverterToNext.isConverterToNext(arb)) {
        return arb.arb;
    }
    NextArbitrary_1.assertIsNextArbitrary(arb);
    return new ConverterFromNext_1.ConverterFromNext(arb);
}
exports.convertFromNext = convertFromNext;
function convertFromNextWithShrunkOnce(arb, legacyShrunkOnceContext) {
    if (ConverterToNext_1.ConverterToNext.isConverterToNext(arb)) {
        if (!('contextualShrink' in arb.arb) ||
            !('contextualShrinkableFor' in arb.arb) ||
            !('shrunkOnceContext' in arb.arb) ||
            !('shrink' in arb.arb) ||
            !('shrinkableFor' in arb.arb)) {
            throw new Error('Conversion rejected: Underlying arbitrary is not compatible with ArbitraryWithContextualShrink');
        }
        return arb.arb;
    }
    NextArbitrary_1.assertIsNextArbitrary(arb);
    return new ConverterFromNext_1.ConverterFromNext(arb, legacyShrunkOnceContext);
}
exports.convertFromNextWithShrunkOnce = convertFromNextWithShrunkOnce;
function convertToNext(arb) {
    if (ConverterFromNext_1.ConverterFromNext.isConverterFromNext(arb)) {
        return arb.arb;
    }
    Arbitrary_1.assertIsArbitrary(arb);
    return new ConverterToNext_1.ConverterToNext(arb);
}
exports.convertToNext = convertToNext;


/***/ }),

/***/ "./node_modules/fast-check/lib/check/arbitrary/definition/NextArbitrary.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/fast-check/lib/check/arbitrary/definition/NextArbitrary.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.assertIsNextArbitrary = exports.NextArbitrary = void 0;
const Stream_1 = __webpack_require__(/*! ../../../stream/Stream */ "./node_modules/fast-check/lib/stream/Stream.js");
const symbols_1 = __webpack_require__(/*! ../../symbols */ "./node_modules/fast-check/lib/check/symbols.js");
const NextValue_1 = __webpack_require__(/*! ./NextValue */ "./node_modules/fast-check/lib/check/arbitrary/definition/NextValue.js");
class NextArbitrary {
    filter(refinement) {
        return new FilterArbitrary(this, refinement);
    }
    map(mapper, unmapper) {
        return new MapArbitrary(this, mapper, unmapper);
    }
    chain(chainer) {
        return new ChainArbitrary(this, chainer);
    }
    noShrink() {
        return new NoShrinkArbitrary(this);
    }
    noBias() {
        return new NoBiasArbitrary(this);
    }
}
exports.NextArbitrary = NextArbitrary;
class ChainArbitrary extends NextArbitrary {
    constructor(arb, chainer) {
        super();
        this.arb = arb;
        this.chainer = chainer;
    }
    generate(mrng, biasFactor) {
        const clonedMrng = mrng.clone();
        const src = this.arb.generate(mrng, biasFactor);
        return this.valueChainer(src, mrng, clonedMrng, biasFactor);
    }
    canShrinkWithoutContext(value) {
        return false;
    }
    shrink(value, context) {
        if (this.isSafeContext(context)) {
            return (!context.stoppedForOriginal
                ? this.arb
                    .shrink(context.originalValue, context.originalContext)
                    .map((v) => this.valueChainer(v, context.clonedMrng.clone(), context.clonedMrng, context.originalBias))
                : Stream_1.Stream.nil()).join(context.chainedArbitrary.shrink(value, context.chainedContext).map((dst) => {
                const newContext = Object.assign(Object.assign({}, context), { chainedContext: dst.context, stoppedForOriginal: true });
                return new NextValue_1.NextValue(dst.value_, newContext);
            }));
        }
        return Stream_1.Stream.nil();
    }
    valueChainer(v, generateMrng, clonedMrng, biasFactor) {
        const chainedArbitrary = this.chainer(v.value_);
        const dst = chainedArbitrary.generate(generateMrng, biasFactor);
        const context = {
            originalBias: biasFactor,
            originalValue: v.value_,
            originalContext: v.context,
            stoppedForOriginal: false,
            chainedArbitrary,
            chainedContext: dst.context,
            clonedMrng,
        };
        return new NextValue_1.NextValue(dst.value_, context);
    }
    isSafeContext(context) {
        return (context != null &&
            typeof context === 'object' &&
            'originalBias' in context &&
            'originalValue' in context &&
            'originalContext' in context &&
            'stoppedForOriginal' in context &&
            'chainedArbitrary' in context &&
            'chainedContext' in context &&
            'clonedMrng' in context);
    }
}
class MapArbitrary extends NextArbitrary {
    constructor(arb, mapper, unmapper) {
        super();
        this.arb = arb;
        this.mapper = mapper;
        this.unmapper = unmapper;
        this.bindValueMapper = this.valueMapper.bind(this);
    }
    generate(mrng, biasFactor) {
        const g = this.arb.generate(mrng, biasFactor);
        return this.valueMapper(g);
    }
    canShrinkWithoutContext(value) {
        if (this.unmapper !== undefined) {
            try {
                const unmapped = this.unmapper(value);
                return this.arb.canShrinkWithoutContext(unmapped);
            }
            catch (_err) {
                return false;
            }
        }
        return false;
    }
    shrink(value, context) {
        if (this.isSafeContext(context)) {
            return this.arb.shrink(context.originalValue, context.originalContext).map(this.bindValueMapper);
        }
        if (this.unmapper !== undefined) {
            const unmapped = this.unmapper(value);
            return this.arb.shrink(unmapped, undefined).map(this.bindValueMapper);
        }
        return Stream_1.Stream.nil();
    }
    mapperWithCloneIfNeeded(v) {
        const sourceValue = v.value;
        const mappedValue = this.mapper(sourceValue);
        if (v.hasToBeCloned &&
            ((typeof mappedValue === 'object' && mappedValue !== null) || typeof mappedValue === 'function') &&
            Object.isExtensible(mappedValue)) {
            Object.defineProperty(mappedValue, symbols_1.cloneMethod, { get: () => () => this.mapperWithCloneIfNeeded(v)[0] });
        }
        return [mappedValue, sourceValue];
    }
    valueMapper(v) {
        const [mappedValue, sourceValue] = this.mapperWithCloneIfNeeded(v);
        const context = { originalValue: sourceValue, originalContext: v.context };
        return new NextValue_1.NextValue(mappedValue, context);
    }
    isSafeContext(context) {
        return (context != null &&
            typeof context === 'object' &&
            'originalValue' in context &&
            'originalContext' in context);
    }
}
class FilterArbitrary extends NextArbitrary {
    constructor(arb, refinement) {
        super();
        this.arb = arb;
        this.refinement = refinement;
        this.bindRefinementOnValue = this.refinementOnValue.bind(this);
    }
    generate(mrng, biasFactor) {
        while (true) {
            const g = this.arb.generate(mrng, biasFactor);
            if (this.refinementOnValue(g)) {
                return g;
            }
        }
    }
    canShrinkWithoutContext(value) {
        return this.arb.canShrinkWithoutContext(value) && this.refinement(value);
    }
    shrink(value, context) {
        return this.arb.shrink(value, context).filter(this.bindRefinementOnValue);
    }
    refinementOnValue(v) {
        return this.refinement(v.value);
    }
}
class NoShrinkArbitrary extends NextArbitrary {
    constructor(arb) {
        super();
        this.arb = arb;
    }
    generate(mrng, biasFactor) {
        return this.arb.generate(mrng, biasFactor);
    }
    canShrinkWithoutContext(value) {
        return this.arb.canShrinkWithoutContext(value);
    }
    shrink(_value, _context) {
        return Stream_1.Stream.nil();
    }
    noShrink() {
        return this;
    }
}
class NoBiasArbitrary extends NextArbitrary {
    constructor(arb) {
        super();
        this.arb = arb;
    }
    generate(mrng, _biasFactor) {
        return this.arb.generate(mrng, undefined);
    }
    canShrinkWithoutContext(value) {
        return this.arb.canShrinkWithoutContext(value);
    }
    shrink(value, context) {
        return this.arb.shrink(value, context);
    }
    noBias() {
        return this;
    }
}
function assertIsNextArbitrary(instance) {
    if (typeof instance !== 'object' ||
        instance === null ||
        !('generate' in instance) ||
        !('shrink' in instance) ||
        'shrinkableFor' in instance) {
        throw new Error('Unexpected value received: not an instance of NextArbitrary');
    }
}
exports.assertIsNextArbitrary = assertIsNextArbitrary;


/***/ }),

/***/ "./node_modules/fast-check/lib/check/arbitrary/definition/NextValue.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/fast-check/lib/check/arbitrary/definition/NextValue.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.NextValue = void 0;
const symbols_1 = __webpack_require__(/*! ../../symbols */ "./node_modules/fast-check/lib/check/symbols.js");
class NextValue {
    constructor(value_, context, customGetValue = undefined) {
        this.value_ = value_;
        this.context = context;
        this.hasToBeCloned = customGetValue !== undefined || symbols_1.hasCloneMethod(value_);
        this.readOnce = false;
        if (this.hasToBeCloned) {
            Object.defineProperty(this, 'value', { get: customGetValue !== undefined ? customGetValue : this.getValue });
        }
        else {
            this.value = value_;
        }
    }
    getValue() {
        if (this.hasToBeCloned) {
            if (!this.readOnce) {
                this.readOnce = true;
                return this.value_;
            }
            return this.value_[symbols_1.cloneMethod]();
        }
        return this.value_;
    }
}
exports.NextValue = NextValue;


/***/ }),

/***/ "./node_modules/fast-check/lib/check/arbitrary/definition/Shrinkable.js":
/*!******************************************************************************!*\
  !*** ./node_modules/fast-check/lib/check/arbitrary/definition/Shrinkable.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Shrinkable = void 0;
const Stream_1 = __webpack_require__(/*! ../../../stream/Stream */ "./node_modules/fast-check/lib/stream/Stream.js");
const symbols_1 = __webpack_require__(/*! ../../symbols */ "./node_modules/fast-check/lib/check/symbols.js");
class Shrinkable {
    constructor(value_, shrink = () => Stream_1.Stream.nil(), customGetValue = undefined) {
        this.value_ = value_;
        this.shrink = shrink;
        this.hasToBeCloned = customGetValue !== undefined || symbols_1.hasCloneMethod(value_);
        this.readOnce = false;
        if (this.hasToBeCloned) {
            Object.defineProperty(this, 'value', { get: customGetValue !== undefined ? customGetValue : this.getValue });
        }
        else {
            this.value = value_;
        }
    }
    getValue() {
        if (!this.readOnce) {
            this.readOnce = true;
            return this.value_;
        }
        return this.value_[symbols_1.cloneMethod]();
    }
    applyMapper(mapper) {
        if (this.hasToBeCloned) {
            const out = mapper(this.value);
            if (out instanceof Object) {
                out[symbols_1.cloneMethod] = () => this.applyMapper(mapper);
            }
            return out;
        }
        return mapper(this.value);
    }
    map(mapper) {
        return new Shrinkable(this.applyMapper(mapper), () => this.shrink().map((v) => v.map(mapper)));
    }
    filter(refinement) {
        const refinementOnShrinkable = (s) => {
            return refinement(s.value_);
        };
        return new Shrinkable(this.value, () => this.shrink()
            .filter(refinementOnShrinkable)
            .map((v) => v.filter(refinement)));
    }
}
exports.Shrinkable = Shrinkable;


/***/ }),

/***/ "./node_modules/fast-check/lib/check/arbitrary/helpers/ArrayInt64.js":
/*!***************************************************************************!*\
  !*** ./node_modules/fast-check/lib/check/arbitrary/helpers/ArrayInt64.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.logLike64 = exports.halve64 = exports.add64 = exports.negative64 = exports.substract64 = exports.clone64 = exports.isStrictlySmaller64 = exports.isEqual64 = exports.isStrictlyPositive64 = exports.isStrictlyNegative64 = exports.isZero64 = exports.Unit64 = exports.Zero64 = void 0;
exports.Zero64 = { sign: 1, data: [0, 0] };
exports.Unit64 = { sign: 1, data: [0, 1] };
function isZero64(a) {
    return a.data[0] === 0 && a.data[1] === 0;
}
exports.isZero64 = isZero64;
function isStrictlyNegative64(a) {
    return a.sign === -1 && !isZero64(a);
}
exports.isStrictlyNegative64 = isStrictlyNegative64;
function isStrictlyPositive64(a) {
    return a.sign === 1 && !isZero64(a);
}
exports.isStrictlyPositive64 = isStrictlyPositive64;
function isEqual64(a, b) {
    if (a.data[0] === b.data[0] && a.data[1] === b.data[1]) {
        return a.sign === b.sign || (a.data[0] === 0 && a.data[1] === 0);
    }
    return false;
}
exports.isEqual64 = isEqual64;
function isStrictlySmaller64Internal(a, b) {
    return a[0] < b[0] || (a[0] === b[0] && a[1] < b[1]);
}
function isStrictlySmaller64(a, b) {
    if (a.sign === b.sign) {
        return a.sign === 1
            ? isStrictlySmaller64Internal(a.data, b.data)
            : isStrictlySmaller64Internal(b.data, a.data);
    }
    return a.sign === -1 && (!isZero64(a) || !isZero64(b));
}
exports.isStrictlySmaller64 = isStrictlySmaller64;
function clone64(a) {
    return { sign: a.sign, data: [a.data[0], a.data[1]] };
}
exports.clone64 = clone64;
function substract64DataInternal(a, b) {
    let reminderLow = 0;
    let low = a[1] - b[1];
    if (low < 0) {
        reminderLow = 1;
        low = low >>> 0;
    }
    return [a[0] - b[0] - reminderLow, low];
}
function substract64Internal(a, b) {
    if (a.sign === 1 && b.sign === -1) {
        const low = a.data[1] + b.data[1];
        const high = a.data[0] + b.data[0] + (low > 0xffffffff ? 1 : 0);
        return { sign: 1, data: [high >>> 0, low >>> 0] };
    }
    return {
        sign: 1,
        data: a.sign === 1 ? substract64DataInternal(a.data, b.data) : substract64DataInternal(b.data, a.data),
    };
}
function substract64(arrayIntA, arrayIntB) {
    if (isStrictlySmaller64(arrayIntA, arrayIntB)) {
        const out = substract64Internal(arrayIntB, arrayIntA);
        out.sign = -1;
        return out;
    }
    return substract64Internal(arrayIntA, arrayIntB);
}
exports.substract64 = substract64;
function negative64(arrayIntA) {
    return {
        sign: -arrayIntA.sign,
        data: [arrayIntA.data[0], arrayIntA.data[1]],
    };
}
exports.negative64 = negative64;
function add64(arrayIntA, arrayIntB) {
    if (isZero64(arrayIntB)) {
        if (isZero64(arrayIntA)) {
            return clone64(exports.Zero64);
        }
        return clone64(arrayIntA);
    }
    return substract64(arrayIntA, negative64(arrayIntB));
}
exports.add64 = add64;
function halve64(a) {
    return {
        sign: a.sign,
        data: [Math.floor(a.data[0] / 2), (a.data[0] % 2 === 1 ? 0x80000000 : 0) + Math.floor(a.data[1] / 2)],
    };
}
exports.halve64 = halve64;
function logLike64(a) {
    return {
        sign: a.sign,
        data: [0, Math.floor(Math.log(a.data[0] * 0x100000000 + a.data[1]) / Math.log(2))],
    };
}
exports.logLike64 = logLike64;


/***/ }),

/***/ "./node_modules/fast-check/lib/check/arbitrary/helpers/ArrayInt64Arbitrary.js":
/*!************************************************************************************!*\
  !*** ./node_modules/fast-check/lib/check/arbitrary/helpers/ArrayInt64Arbitrary.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.arrayInt64 = void 0;
const Stream_1 = __webpack_require__(/*! ../../../stream/Stream */ "./node_modules/fast-check/lib/stream/Stream.js");
const Converters_1 = __webpack_require__(/*! ../definition/Converters */ "./node_modules/fast-check/lib/check/arbitrary/definition/Converters.js");
const NextArbitrary_1 = __webpack_require__(/*! ../definition/NextArbitrary */ "./node_modules/fast-check/lib/check/arbitrary/definition/NextArbitrary.js");
const NextValue_1 = __webpack_require__(/*! ../definition/NextValue */ "./node_modules/fast-check/lib/check/arbitrary/definition/NextValue.js");
const ArrayInt64_1 = __webpack_require__(/*! ./ArrayInt64 */ "./node_modules/fast-check/lib/check/arbitrary/helpers/ArrayInt64.js");
class ArrayInt64Arbitrary extends NextArbitrary_1.NextArbitrary {
    constructor(min, max) {
        super();
        this.min = min;
        this.max = max;
        this.biasedRanges = null;
    }
    generate(mrng, biasFactor) {
        const range = this.computeGenerateRange(mrng, biasFactor);
        const uncheckedValue = mrng.nextArrayInt(range.min, range.max);
        if (uncheckedValue.data.length === 1) {
            uncheckedValue.data.unshift(0);
        }
        return new NextValue_1.NextValue(uncheckedValue, undefined);
    }
    computeGenerateRange(mrng, biasFactor) {
        if (biasFactor === undefined || mrng.nextInt(1, biasFactor) !== 1) {
            return { min: this.min, max: this.max };
        }
        const ranges = this.retrieveBiasedRanges();
        if (ranges.length === 1) {
            return ranges[0];
        }
        const id = mrng.nextInt(-2 * (ranges.length - 1), ranges.length - 2);
        return id < 0 ? ranges[0] : ranges[id + 1];
    }
    canShrinkWithoutContext(value) {
        const unsafeValue = value;
        return (typeof value === 'object' &&
            value !== null &&
            (unsafeValue.sign === -1 || unsafeValue.sign === 1) &&
            Array.isArray(unsafeValue.data) &&
            unsafeValue.data.length === 2 &&
            ((ArrayInt64_1.isStrictlySmaller64(this.min, unsafeValue) && ArrayInt64_1.isStrictlySmaller64(unsafeValue, this.max)) ||
                ArrayInt64_1.isEqual64(this.min, unsafeValue) ||
                ArrayInt64_1.isEqual64(this.max, unsafeValue)));
    }
    shrinkArrayInt64(value, target, tryTargetAsap) {
        const realGap = ArrayInt64_1.substract64(value, target);
        function* shrinkGen() {
            let previous = tryTargetAsap ? undefined : target;
            const gap = tryTargetAsap ? realGap : ArrayInt64_1.halve64(realGap);
            for (let toremove = gap; !ArrayInt64_1.isZero64(toremove); toremove = ArrayInt64_1.halve64(toremove)) {
                const next = ArrayInt64_1.substract64(value, toremove);
                yield new NextValue_1.NextValue(next, previous);
                previous = next;
            }
        }
        return Stream_1.stream(shrinkGen());
    }
    shrink(current, context) {
        if (!ArrayInt64Arbitrary.isValidContext(current, context)) {
            const target = this.defaultTarget();
            return this.shrinkArrayInt64(current, target, true);
        }
        if (this.isLastChanceTry(current, context)) {
            return Stream_1.Stream.of(new NextValue_1.NextValue(context, undefined));
        }
        return this.shrinkArrayInt64(current, context, false);
    }
    defaultTarget() {
        if (!ArrayInt64_1.isStrictlyPositive64(this.min) && !ArrayInt64_1.isStrictlyNegative64(this.max)) {
            return ArrayInt64_1.Zero64;
        }
        return ArrayInt64_1.isStrictlyNegative64(this.min) ? this.max : this.min;
    }
    isLastChanceTry(current, context) {
        if (ArrayInt64_1.isZero64(current)) {
            return false;
        }
        if (current.sign === 1) {
            return ArrayInt64_1.isEqual64(current, ArrayInt64_1.add64(context, ArrayInt64_1.Unit64)) && ArrayInt64_1.isStrictlyPositive64(ArrayInt64_1.substract64(current, this.min));
        }
        else {
            return ArrayInt64_1.isEqual64(current, ArrayInt64_1.substract64(context, ArrayInt64_1.Unit64)) && ArrayInt64_1.isStrictlyNegative64(ArrayInt64_1.substract64(current, this.max));
        }
    }
    static isValidContext(_current, context) {
        if (context === undefined) {
            return false;
        }
        if (typeof context !== 'object' || context === null || !('sign' in context) || !('data' in context)) {
            throw new Error(`Invalid context type passed to ArrayInt64Arbitrary (#1)`);
        }
        return true;
    }
    retrieveBiasedRanges() {
        if (this.biasedRanges != null) {
            return this.biasedRanges;
        }
        if (ArrayInt64_1.isEqual64(this.min, this.max)) {
            this.biasedRanges = [{ min: this.min, max: this.max }];
            return this.biasedRanges;
        }
        const minStrictlySmallerZero = ArrayInt64_1.isStrictlyNegative64(this.min);
        const maxStrictlyGreaterZero = ArrayInt64_1.isStrictlyPositive64(this.max);
        if (minStrictlySmallerZero && maxStrictlyGreaterZero) {
            const logMin = ArrayInt64_1.logLike64(this.min);
            const logMax = ArrayInt64_1.logLike64(this.max);
            this.biasedRanges = [
                { min: logMin, max: logMax },
                { min: ArrayInt64_1.substract64(this.max, logMax), max: this.max },
                { min: this.min, max: ArrayInt64_1.substract64(this.min, logMin) },
            ];
        }
        else {
            const logGap = ArrayInt64_1.logLike64(ArrayInt64_1.substract64(this.max, this.min));
            const arbCloseToMin = { min: this.min, max: ArrayInt64_1.add64(this.min, logGap) };
            const arbCloseToMax = { min: ArrayInt64_1.substract64(this.max, logGap), max: this.max };
            this.biasedRanges = minStrictlySmallerZero
                ? [arbCloseToMax, arbCloseToMin]
                : [arbCloseToMin, arbCloseToMax];
        }
        return this.biasedRanges;
    }
}
function arrayInt64(min, max) {
    const arb = new ArrayInt64Arbitrary(min, max);
    return Converters_1.convertFromNextWithShrunkOnce(arb, arb.defaultTarget());
}
exports.arrayInt64 = arrayInt64;


/***/ }),

/***/ "./node_modules/fast-check/lib/check/arbitrary/helpers/SpecificCharacterRange.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/fast-check/lib/check/arbitrary/helpers/SpecificCharacterRange.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.buildAlphaNumericPercentArb = exports.buildAlphaNumericArb = exports.buildLowerAlphaNumericArb = exports.buildLowerAlphaArb = void 0;
const fullUnicode_1 = __webpack_require__(/*! ../../../arbitrary/fullUnicode */ "./node_modules/fast-check/lib/arbitrary/fullUnicode.js");
const frequency_1 = __webpack_require__(/*! ../../../arbitrary/frequency */ "./node_modules/fast-check/lib/arbitrary/frequency.js");
const mapToConstant_1 = __webpack_require__(/*! ../../../arbitrary/mapToConstant */ "./node_modules/fast-check/lib/arbitrary/mapToConstant.js");
const lowerCaseMapper = { num: 26, build: (v) => String.fromCharCode(v + 0x61) };
const upperCaseMapper = { num: 26, build: (v) => String.fromCharCode(v + 0x41) };
const numericMapper = { num: 10, build: (v) => String.fromCharCode(v + 0x30) };
const percentCharArb = fullUnicode_1.fullUnicode().map((c) => {
    const encoded = encodeURIComponent(c);
    return c !== encoded ? encoded : `%${c.charCodeAt(0).toString(16)}`;
});
const buildLowerAlphaArb = (others) => mapToConstant_1.mapToConstant(lowerCaseMapper, { num: others.length, build: (v) => others[v] });
exports.buildLowerAlphaArb = buildLowerAlphaArb;
const buildLowerAlphaNumericArb = (others) => mapToConstant_1.mapToConstant(lowerCaseMapper, numericMapper, { num: others.length, build: (v) => others[v] });
exports.buildLowerAlphaNumericArb = buildLowerAlphaNumericArb;
const buildAlphaNumericArb = (others) => mapToConstant_1.mapToConstant(lowerCaseMapper, upperCaseMapper, numericMapper, { num: others.length, build: (v) => others[v] });
exports.buildAlphaNumericArb = buildAlphaNumericArb;
const buildAlphaNumericPercentArb = (others) => frequency_1.frequency({
    weight: 10,
    arbitrary: exports.buildAlphaNumericArb(others),
}, {
    weight: 1,
    arbitrary: percentCharArb,
});
exports.buildAlphaNumericPercentArb = buildAlphaNumericPercentArb;


/***/ }),

/***/ "./node_modules/fast-check/lib/check/arbitrary/helpers/TextEscaper.js":
/*!****************************************************************************!*\
  !*** ./node_modules/fast-check/lib/check/arbitrary/helpers/TextEscaper.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.escapeForMultilineComments = exports.escapeForTemplateString = void 0;
function escapeForTemplateString(originalText) {
    return originalText.replace(/([$`\\])/g, '\\$1').replace(/\r/g, '\\r');
}
exports.escapeForTemplateString = escapeForTemplateString;
function escapeForMultilineComments(originalText) {
    return originalText.replace(/\*\//g, '*\\/');
}
exports.escapeForMultilineComments = escapeForMultilineComments;


/***/ }),

/***/ "./node_modules/fast-check/lib/check/model/ModelRunner.js":
/*!****************************************************************!*\
  !*** ./node_modules/fast-check/lib/check/model/ModelRunner.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.scheduledModelRun = exports.asyncModelRun = exports.modelRun = void 0;
const ScheduledCommand_1 = __webpack_require__(/*! ./commands/ScheduledCommand */ "./node_modules/fast-check/lib/check/model/commands/ScheduledCommand.js");
const genericModelRun = (s, cmds, initialValue, runCmd, then) => {
    return s.then((o) => {
        const { model, real } = o;
        let state = initialValue;
        for (const c of cmds) {
            state = then(state, () => {
                return runCmd(c, model, real);
            });
        }
        return state;
    });
};
const internalModelRun = (s, cmds) => {
    const then = (_p, c) => c();
    const setupProducer = {
        then: (fun) => {
            fun(s());
            return undefined;
        },
    };
    const runSync = (cmd, m, r) => {
        if (cmd.check(m))
            cmd.run(m, r);
        return undefined;
    };
    return genericModelRun(setupProducer, cmds, undefined, runSync, then);
};
const isAsyncSetup = (s) => {
    return typeof s.then === 'function';
};
const internalAsyncModelRun = async (s, cmds, defaultPromise = Promise.resolve()) => {
    const then = (p, c) => p.then(c);
    const setupProducer = {
        then: (fun) => {
            const out = s();
            if (isAsyncSetup(out))
                return out.then(fun);
            else
                return fun(out);
        },
    };
    const runAsync = async (cmd, m, r) => {
        if (await cmd.check(m))
            await cmd.run(m, r);
    };
    return await genericModelRun(setupProducer, cmds, defaultPromise, runAsync, then);
};
function modelRun(s, cmds) {
    internalModelRun(s, cmds);
}
exports.modelRun = modelRun;
async function asyncModelRun(s, cmds) {
    await internalAsyncModelRun(s, cmds);
}
exports.asyncModelRun = asyncModelRun;
async function scheduledModelRun(scheduler, s, cmds) {
    const scheduledCommands = ScheduledCommand_1.scheduleCommands(scheduler, cmds);
    const out = internalAsyncModelRun(s, scheduledCommands, scheduler.schedule(Promise.resolve(), 'startModel'));
    await scheduler.waitAll();
    await out;
}
exports.scheduledModelRun = scheduledModelRun;


/***/ }),

/***/ "./node_modules/fast-check/lib/check/model/ReplayPath.js":
/*!***************************************************************!*\
  !*** ./node_modules/fast-check/lib/check/model/ReplayPath.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ReplayPath = void 0;
class ReplayPath {
    static parse(replayPathStr) {
        const [serializedCount, serializedChanges] = replayPathStr.split(':');
        const counts = this.parseCounts(serializedCount);
        const changes = this.parseChanges(serializedChanges);
        return this.parseOccurences(counts, changes);
    }
    static stringify(replayPath) {
        const occurences = this.countOccurences(replayPath);
        const serializedCount = this.stringifyCounts(occurences);
        const serializedChanges = this.stringifyChanges(occurences);
        return `${serializedCount}:${serializedChanges}`;
    }
    static intToB64(n) {
        if (n < 26)
            return String.fromCharCode(n + 65);
        if (n < 52)
            return String.fromCharCode(n + 97 - 26);
        if (n < 62)
            return String.fromCharCode(n + 48 - 52);
        return String.fromCharCode(n === 62 ? 43 : 47);
    }
    static b64ToInt(c) {
        if (c >= 'a')
            return c.charCodeAt(0) - 97 + 26;
        if (c >= 'A')
            return c.charCodeAt(0) - 65;
        if (c >= '0')
            return c.charCodeAt(0) - 48 + 52;
        return c === '+' ? 62 : 63;
    }
    static countOccurences(replayPath) {
        return replayPath.reduce((counts, cur) => {
            if (counts.length === 0 || counts[counts.length - 1].count === 64 || counts[counts.length - 1].value !== cur)
                counts.push({ value: cur, count: 1 });
            else
                counts[counts.length - 1].count += 1;
            return counts;
        }, []);
    }
    static parseOccurences(counts, changes) {
        const replayPath = [];
        for (let idx = 0; idx !== counts.length; ++idx) {
            const count = counts[idx];
            const value = changes[idx];
            for (let num = 0; num !== count; ++num)
                replayPath.push(value);
        }
        return replayPath;
    }
    static stringifyChanges(occurences) {
        let serializedChanges = '';
        for (let idx = 0; idx < occurences.length; idx += 6) {
            const changesInt = occurences
                .slice(idx, idx + 6)
                .reduceRight((prev, cur) => prev * 2 + (cur.value ? 1 : 0), 0);
            serializedChanges += this.intToB64(changesInt);
        }
        return serializedChanges;
    }
    static parseChanges(serializedChanges) {
        const changesInt = serializedChanges.split('').map((c) => this.b64ToInt(c));
        const changes = [];
        for (let idx = 0; idx !== changesInt.length; ++idx) {
            let current = changesInt[idx];
            for (let n = 0; n !== 6; ++n, current >>= 1) {
                changes.push(current % 2 === 1);
            }
        }
        return changes;
    }
    static stringifyCounts(occurences) {
        return occurences.map(({ count }) => this.intToB64(count - 1)).join('');
    }
    static parseCounts(serializedCount) {
        return serializedCount.split('').map((c) => this.b64ToInt(c) + 1);
    }
}
exports.ReplayPath = ReplayPath;


/***/ }),

/***/ "./node_modules/fast-check/lib/check/model/commands/CommandWrapper.js":
/*!****************************************************************************!*\
  !*** ./node_modules/fast-check/lib/check/model/commands/CommandWrapper.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CommandWrapper = void 0;
const stringify_1 = __webpack_require__(/*! ../../../utils/stringify */ "./node_modules/fast-check/lib/utils/stringify.js");
const symbols_1 = __webpack_require__(/*! ../../symbols */ "./node_modules/fast-check/lib/check/symbols.js");
class CommandWrapper {
    constructor(cmd) {
        this.cmd = cmd;
        this.hasRan = false;
        if (stringify_1.hasToStringMethod(cmd)) {
            const method = cmd[stringify_1.toStringMethod];
            this[stringify_1.toStringMethod] = function toStringMethod() {
                return method.call(cmd);
            };
        }
        if (stringify_1.hasAsyncToStringMethod(cmd)) {
            const method = cmd[stringify_1.asyncToStringMethod];
            this[stringify_1.asyncToStringMethod] = function asyncToStringMethod() {
                return method.call(cmd);
            };
        }
    }
    check(m) {
        return this.cmd.check(m);
    }
    run(m, r) {
        this.hasRan = true;
        return this.cmd.run(m, r);
    }
    clone() {
        if (symbols_1.hasCloneMethod(this.cmd))
            return new CommandWrapper(this.cmd[symbols_1.cloneMethod]());
        return new CommandWrapper(this.cmd);
    }
    toString() {
        return this.cmd.toString();
    }
}
exports.CommandWrapper = CommandWrapper;


/***/ }),

/***/ "./node_modules/fast-check/lib/check/model/commands/CommandsArbitrary.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/fast-check/lib/check/model/commands/CommandsArbitrary.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.commands = void 0;
const Stream_1 = __webpack_require__(/*! ../../../stream/Stream */ "./node_modules/fast-check/lib/stream/Stream.js");
const Arbitrary_1 = __webpack_require__(/*! ../../arbitrary/definition/Arbitrary */ "./node_modules/fast-check/lib/check/arbitrary/definition/Arbitrary.js");
const Shrinkable_1 = __webpack_require__(/*! ../../arbitrary/definition/Shrinkable */ "./node_modules/fast-check/lib/check/arbitrary/definition/Shrinkable.js");
const nat_1 = __webpack_require__(/*! ../../../arbitrary/nat */ "./node_modules/fast-check/lib/arbitrary/nat.js");
const oneof_1 = __webpack_require__(/*! ../../../arbitrary/oneof */ "./node_modules/fast-check/lib/arbitrary/oneof.js");
const ReplayPath_1 = __webpack_require__(/*! ../ReplayPath */ "./node_modules/fast-check/lib/check/model/ReplayPath.js");
const CommandsIterable_1 = __webpack_require__(/*! ./CommandsIterable */ "./node_modules/fast-check/lib/check/model/commands/CommandsIterable.js");
const CommandWrapper_1 = __webpack_require__(/*! ./CommandWrapper */ "./node_modules/fast-check/lib/check/model/commands/CommandWrapper.js");
const LazyIterableIterator_1 = __webpack_require__(/*! ../../../stream/LazyIterableIterator */ "./node_modules/fast-check/lib/stream/LazyIterableIterator.js");
class CommandsArbitrary extends Arbitrary_1.Arbitrary {
    constructor(commandArbs, maxCommands, sourceReplayPath, disableReplayLog) {
        super();
        this.sourceReplayPath = sourceReplayPath;
        this.disableReplayLog = disableReplayLog;
        this.oneCommandArb = oneof_1.oneof(...commandArbs).map((c) => new CommandWrapper_1.CommandWrapper(c));
        this.lengthArb = nat_1.nat(maxCommands);
        this.replayPath = [];
        this.replayPathPosition = 0;
    }
    metadataForReplay() {
        return this.disableReplayLog ? '' : `replayPath=${JSON.stringify(ReplayPath_1.ReplayPath.stringify(this.replayPath))}`;
    }
    wrapper(items, shrunkOnce) {
        return new Shrinkable_1.Shrinkable(new CommandsIterable_1.CommandsIterable(items.map((s) => s.value_), () => this.metadataForReplay()), () => this.shrinkImpl(items, shrunkOnce).map((v) => this.wrapper(v, true)));
    }
    generate(mrng) {
        const size = this.lengthArb.generate(mrng);
        const items = Array(size.value_);
        for (let idx = 0; idx !== size.value_; ++idx) {
            const item = this.oneCommandArb.generate(mrng);
            items[idx] = item;
        }
        this.replayPathPosition = 0;
        return this.wrapper(items, false);
    }
    filterOnExecution(itemsRaw) {
        const items = [];
        for (const c of itemsRaw) {
            if (c.value_.hasRan) {
                this.replayPath.push(true);
                items.push(c);
            }
            else
                this.replayPath.push(false);
        }
        return items;
    }
    filterOnReplay(itemsRaw) {
        return itemsRaw.filter((c, idx) => {
            const state = this.replayPath[this.replayPathPosition + idx];
            if (state === undefined)
                throw new Error(`Too short replayPath`);
            if (!state && c.value_.hasRan)
                throw new Error(`Mismatch between replayPath and real execution`);
            return state;
        });
    }
    filterForShrinkImpl(itemsRaw) {
        if (this.replayPathPosition === 0) {
            this.replayPath = this.sourceReplayPath !== null ? ReplayPath_1.ReplayPath.parse(this.sourceReplayPath) : [];
        }
        const items = this.replayPathPosition < this.replayPath.length
            ? this.filterOnReplay(itemsRaw)
            : this.filterOnExecution(itemsRaw);
        this.replayPathPosition += itemsRaw.length;
        return items;
    }
    shrinkImpl(itemsRaw, shrunkOnce) {
        const items = this.filterForShrinkImpl(itemsRaw);
        if (items.length === 0) {
            return Stream_1.Stream.nil();
        }
        const rootShrink = shrunkOnce
            ? Stream_1.Stream.nil()
            : new Stream_1.Stream([[]][Symbol.iterator]());
        const nextShrinks = [];
        for (let numToKeep = 0; numToKeep !== items.length; ++numToKeep) {
            nextShrinks.push(LazyIterableIterator_1.makeLazy(() => {
                const size = this.lengthArb.contextualShrinkableFor(items.length - 1 - numToKeep);
                const fixedStart = items.slice(0, numToKeep);
                return size.shrink().map((l) => fixedStart.concat(items.slice(items.length - (l.value + 1))));
            }));
        }
        for (let itemAt = 0; itemAt !== items.length; ++itemAt) {
            nextShrinks.push(LazyIterableIterator_1.makeLazy(() => items[itemAt].shrink().map((v) => items.slice(0, itemAt).concat([v], items.slice(itemAt + 1)))));
        }
        return rootShrink.join(...nextShrinks).map((shrinkables) => {
            return shrinkables.map((c) => {
                return new Shrinkable_1.Shrinkable(c.value_.clone(), c.shrink);
            });
        });
    }
}
function commands(commandArbs, constraints) {
    const config = constraints == null ? {} : typeof constraints === 'number' ? { maxCommands: constraints } : constraints;
    return new CommandsArbitrary(commandArbs, config.maxCommands != null ? config.maxCommands : 10, config.replayPath != null ? config.replayPath : null, !!config.disableReplayLog);
}
exports.commands = commands;


/***/ }),

/***/ "./node_modules/fast-check/lib/check/model/commands/CommandsIterable.js":
/*!******************************************************************************!*\
  !*** ./node_modules/fast-check/lib/check/model/commands/CommandsIterable.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CommandsIterable = void 0;
const symbols_1 = __webpack_require__(/*! ../../symbols */ "./node_modules/fast-check/lib/check/symbols.js");
class CommandsIterable {
    constructor(commands, metadataForReplay) {
        this.commands = commands;
        this.metadataForReplay = metadataForReplay;
    }
    [Symbol.iterator]() {
        return this.commands[Symbol.iterator]();
    }
    [symbols_1.cloneMethod]() {
        return new CommandsIterable(this.commands.map((c) => c.clone()), this.metadataForReplay);
    }
    toString() {
        const serializedCommands = this.commands
            .filter((c) => c.hasRan)
            .map((c) => c.toString())
            .join(',');
        const metadata = this.metadataForReplay();
        return metadata.length !== 0 ? `${serializedCommands} /*${metadata}*/` : serializedCommands;
    }
}
exports.CommandsIterable = CommandsIterable;


/***/ }),

/***/ "./node_modules/fast-check/lib/check/model/commands/ScheduledCommand.js":
/*!******************************************************************************!*\
  !*** ./node_modules/fast-check/lib/check/model/commands/ScheduledCommand.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.scheduleCommands = exports.ScheduledCommand = void 0;
class ScheduledCommand {
    constructor(s, cmd) {
        this.s = s;
        this.cmd = cmd;
    }
    async check(m) {
        let error = null;
        let checkPassed = false;
        const status = await this.s.scheduleSequence([
            {
                label: `check@${this.cmd.toString()}`,
                builder: async () => {
                    try {
                        checkPassed = await Promise.resolve(this.cmd.check(m));
                    }
                    catch (err) {
                        error = err;
                        throw err;
                    }
                },
            },
        ]).task;
        if (status.faulty) {
            throw error;
        }
        return checkPassed;
    }
    async run(m, r) {
        let error = null;
        const status = await this.s.scheduleSequence([
            {
                label: `run@${this.cmd.toString()}`,
                builder: async () => {
                    try {
                        await this.cmd.run(m, r);
                    }
                    catch (err) {
                        error = err;
                        throw err;
                    }
                },
            },
        ]).task;
        if (status.faulty) {
            throw error;
        }
    }
}
exports.ScheduledCommand = ScheduledCommand;
const scheduleCommands = function* (s, cmds) {
    for (const cmd of cmds) {
        yield new ScheduledCommand(s, cmd);
    }
};
exports.scheduleCommands = scheduleCommands;


/***/ }),

/***/ "./node_modules/fast-check/lib/check/precondition/Pre.js":
/*!***************************************************************!*\
  !*** ./node_modules/fast-check/lib/check/precondition/Pre.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.pre = void 0;
const PreconditionFailure_1 = __webpack_require__(/*! ./PreconditionFailure */ "./node_modules/fast-check/lib/check/precondition/PreconditionFailure.js");
function pre(expectTruthy) {
    if (!expectTruthy) {
        throw new PreconditionFailure_1.PreconditionFailure();
    }
}
exports.pre = pre;


/***/ }),

/***/ "./node_modules/fast-check/lib/check/precondition/PreconditionFailure.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/fast-check/lib/check/precondition/PreconditionFailure.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PreconditionFailure = void 0;
class PreconditionFailure extends Error {
    constructor(interruptExecution = false) {
        super();
        this.interruptExecution = interruptExecution;
        this.footprint = PreconditionFailure.SharedFootPrint;
    }
    static isFailure(err) {
        return err != null && err.footprint === PreconditionFailure.SharedFootPrint;
    }
}
exports.PreconditionFailure = PreconditionFailure;
PreconditionFailure.SharedFootPrint = Symbol('fast-check/PreconditionFailure');


/***/ }),

/***/ "./node_modules/fast-check/lib/check/property/AsyncProperty.generated.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/fast-check/lib/check/property/AsyncProperty.generated.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.asyncProperty = void 0;
const genericTuple_1 = __webpack_require__(/*! ../../arbitrary/genericTuple */ "./node_modules/fast-check/lib/arbitrary/genericTuple.js");
const AsyncProperty_generic_1 = __webpack_require__(/*! ./AsyncProperty.generic */ "./node_modules/fast-check/lib/check/property/AsyncProperty.generic.js");
function asyncProperty(...args) {
    if (args.length < 2)
        throw new Error('asyncProperty expects at least two parameters');
    const arbs = args.slice(0, args.length - 1);
    const p = args[args.length - 1];
    return new AsyncProperty_generic_1.AsyncProperty(genericTuple_1.genericTuple(arbs), t => p(...t));
}
exports.asyncProperty = asyncProperty;


/***/ }),

/***/ "./node_modules/fast-check/lib/check/property/AsyncProperty.generic.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/fast-check/lib/check/property/AsyncProperty.generic.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AsyncProperty = void 0;
const PreconditionFailure_1 = __webpack_require__(/*! ../precondition/PreconditionFailure */ "./node_modules/fast-check/lib/check/precondition/PreconditionFailure.js");
const IRawProperty_1 = __webpack_require__(/*! ./IRawProperty */ "./node_modules/fast-check/lib/check/property/IRawProperty.js");
const GlobalParameters_1 = __webpack_require__(/*! ../runner/configuration/GlobalParameters */ "./node_modules/fast-check/lib/check/runner/configuration/GlobalParameters.js");
const ConverterFromNext_1 = __webpack_require__(/*! ../arbitrary/definition/ConverterFromNext */ "./node_modules/fast-check/lib/check/arbitrary/definition/ConverterFromNext.js");
class AsyncProperty {
    constructor(arb, predicate) {
        this.arb = arb;
        this.predicate = predicate;
        this.isAsync = () => true;
        const { asyncBeforeEach, asyncAfterEach, beforeEach, afterEach } = GlobalParameters_1.readConfigureGlobal() || {};
        if (asyncBeforeEach !== undefined && beforeEach !== undefined) {
            throw Error('Global "asyncBeforeEach" and "beforeEach" parameters can\'t be set at the same time when running async properties');
        }
        if (asyncAfterEach !== undefined && afterEach !== undefined) {
            throw Error('Global "asyncAfterEach" and "afterEach" parameters can\'t be set at the same time when running async properties');
        }
        this.beforeEachHook = asyncBeforeEach || beforeEach || AsyncProperty.dummyHook;
        this.afterEachHook = asyncAfterEach || afterEach || AsyncProperty.dummyHook;
    }
    generate(mrng, runId) {
        if (ConverterFromNext_1.ConverterFromNext.isConverterFromNext(this.arb)) {
            return this.arb.toShrinkable(this.arb.arb.generate(mrng, runId != null ? IRawProperty_1.runIdToFrequency(runId) : undefined));
        }
        return runId != null ? this.arb.withBias(IRawProperty_1.runIdToFrequency(runId)).generate(mrng) : this.arb.generate(mrng);
    }
    async run(v) {
        await this.beforeEachHook();
        try {
            const output = await this.predicate(v);
            return output == null || output === true ? null : 'Property failed by returning false';
        }
        catch (err) {
            if (PreconditionFailure_1.PreconditionFailure.isFailure(err))
                return err;
            if (err instanceof Error && err.stack)
                return `${err}\n\nStack trace: ${err.stack}`;
            return `${err}`;
        }
        finally {
            await this.afterEachHook();
        }
    }
    beforeEach(hookFunction) {
        const previousBeforeEachHook = this.beforeEachHook;
        this.beforeEachHook = () => hookFunction(previousBeforeEachHook);
        return this;
    }
    afterEach(hookFunction) {
        const previousAfterEachHook = this.afterEachHook;
        this.afterEachHook = () => hookFunction(previousAfterEachHook);
        return this;
    }
}
exports.AsyncProperty = AsyncProperty;
AsyncProperty.dummyHook = () => { };


/***/ }),

/***/ "./node_modules/fast-check/lib/check/property/AsyncProperty.js":
/*!*********************************************************************!*\
  !*** ./node_modules/fast-check/lib/check/property/AsyncProperty.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.asyncProperty = void 0;
const AsyncProperty_generated_1 = __webpack_require__(/*! ./AsyncProperty.generated */ "./node_modules/fast-check/lib/check/property/AsyncProperty.generated.js");
Object.defineProperty(exports, "asyncProperty", ({ enumerable: true, get: function () { return AsyncProperty_generated_1.asyncProperty; } }));


/***/ }),

/***/ "./node_modules/fast-check/lib/check/property/IRawProperty.js":
/*!********************************************************************!*\
  !*** ./node_modules/fast-check/lib/check/property/IRawProperty.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.runIdToFrequency = void 0;
const runIdToFrequency = (runId) => 2 + Math.floor(Math.log(runId + 1) / Math.log(10));
exports.runIdToFrequency = runIdToFrequency;


/***/ }),

/***/ "./node_modules/fast-check/lib/check/property/IgnoreEqualValuesProperty.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/fast-check/lib/check/property/IgnoreEqualValuesProperty.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.IgnoreEqualValuesProperty = void 0;
const stringify_1 = __webpack_require__(/*! ../../utils/stringify */ "./node_modules/fast-check/lib/utils/stringify.js");
const PreconditionFailure_1 = __webpack_require__(/*! ../precondition/PreconditionFailure */ "./node_modules/fast-check/lib/check/precondition/PreconditionFailure.js");
function fromSyncCached(cachedValue) {
    return cachedValue === null ? new PreconditionFailure_1.PreconditionFailure() : cachedValue;
}
function fromCached(...data) {
    if (data[1])
        return data[0].then(fromSyncCached);
    return fromSyncCached(data[0]);
}
function fromCachedUnsafe(cachedValue, isAsync) {
    return fromCached(cachedValue, isAsync);
}
class IgnoreEqualValuesProperty {
    constructor(property, skipRuns) {
        this.property = property;
        this.skipRuns = skipRuns;
        this.coveredCases = new Map();
        this.isAsync = () => this.property.isAsync();
        this.generate = (mrng, runId) => this.property.generate(mrng, runId);
        this.run = (v) => {
            const stringifiedValue = stringify_1.stringify(v);
            if (this.coveredCases.has(stringifiedValue)) {
                const lastOutput = this.coveredCases.get(stringifiedValue);
                if (!this.skipRuns) {
                    return lastOutput;
                }
                return fromCachedUnsafe(lastOutput, this.property.isAsync());
            }
            const out = this.property.run(v);
            this.coveredCases.set(stringifiedValue, out);
            return out;
        };
    }
}
exports.IgnoreEqualValuesProperty = IgnoreEqualValuesProperty;


/***/ }),

/***/ "./node_modules/fast-check/lib/check/property/Property.generated.js":
/*!**************************************************************************!*\
  !*** ./node_modules/fast-check/lib/check/property/Property.generated.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.property = void 0;
const genericTuple_1 = __webpack_require__(/*! ../../arbitrary/genericTuple */ "./node_modules/fast-check/lib/arbitrary/genericTuple.js");
const Property_generic_1 = __webpack_require__(/*! ./Property.generic */ "./node_modules/fast-check/lib/check/property/Property.generic.js");
function property(...args) {
    if (args.length < 2)
        throw new Error('property expects at least two parameters');
    const arbs = args.slice(0, args.length - 1);
    const p = args[args.length - 1];
    return new Property_generic_1.Property(genericTuple_1.genericTuple(arbs), t => p(...t));
}
exports.property = property;


/***/ }),

/***/ "./node_modules/fast-check/lib/check/property/Property.generic.js":
/*!************************************************************************!*\
  !*** ./node_modules/fast-check/lib/check/property/Property.generic.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Property = void 0;
const PreconditionFailure_1 = __webpack_require__(/*! ../precondition/PreconditionFailure */ "./node_modules/fast-check/lib/check/precondition/PreconditionFailure.js");
const IRawProperty_1 = __webpack_require__(/*! ./IRawProperty */ "./node_modules/fast-check/lib/check/property/IRawProperty.js");
const GlobalParameters_1 = __webpack_require__(/*! ../runner/configuration/GlobalParameters */ "./node_modules/fast-check/lib/check/runner/configuration/GlobalParameters.js");
const ConverterFromNext_1 = __webpack_require__(/*! ../arbitrary/definition/ConverterFromNext */ "./node_modules/fast-check/lib/check/arbitrary/definition/ConverterFromNext.js");
class Property {
    constructor(arb, predicate) {
        this.arb = arb;
        this.predicate = predicate;
        this.isAsync = () => false;
        const { beforeEach = Property.dummyHook, afterEach = Property.dummyHook, asyncBeforeEach, asyncAfterEach, } = GlobalParameters_1.readConfigureGlobal() || {};
        if (asyncBeforeEach !== undefined) {
            throw Error('"asyncBeforeEach" can\'t be set when running synchronous properties');
        }
        if (asyncAfterEach !== undefined) {
            throw Error('"asyncAfterEach" can\'t be set when running synchronous properties');
        }
        this.beforeEachHook = beforeEach;
        this.afterEachHook = afterEach;
    }
    generate(mrng, runId) {
        if (ConverterFromNext_1.ConverterFromNext.isConverterFromNext(this.arb)) {
            return this.arb.toShrinkable(this.arb.arb.generate(mrng, runId != null ? IRawProperty_1.runIdToFrequency(runId) : undefined));
        }
        return runId != null ? this.arb.withBias(IRawProperty_1.runIdToFrequency(runId)).generate(mrng) : this.arb.generate(mrng);
    }
    run(v) {
        this.beforeEachHook();
        try {
            const output = this.predicate(v);
            return output == null || output === true ? null : 'Property failed by returning false';
        }
        catch (err) {
            if (PreconditionFailure_1.PreconditionFailure.isFailure(err))
                return err;
            if (err instanceof Error && err.stack)
                return `${err}\n\nStack trace: ${err.stack}`;
            return `${err}`;
        }
        finally {
            this.afterEachHook();
        }
    }
    beforeEach(hookFunction) {
        const previousBeforeEachHook = this.beforeEachHook;
        this.beforeEachHook = () => hookFunction(previousBeforeEachHook);
        return this;
    }
    afterEach(hookFunction) {
        const previousAfterEachHook = this.afterEachHook;
        this.afterEachHook = () => hookFunction(previousAfterEachHook);
        return this;
    }
}
exports.Property = Property;
Property.dummyHook = () => { };


/***/ }),

/***/ "./node_modules/fast-check/lib/check/property/Property.js":
/*!****************************************************************!*\
  !*** ./node_modules/fast-check/lib/check/property/Property.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.property = void 0;
const Property_generated_1 = __webpack_require__(/*! ./Property.generated */ "./node_modules/fast-check/lib/check/property/Property.generated.js");
Object.defineProperty(exports, "property", ({ enumerable: true, get: function () { return Property_generated_1.property; } }));


/***/ }),

/***/ "./node_modules/fast-check/lib/check/property/SkipAfterProperty.js":
/*!*************************************************************************!*\
  !*** ./node_modules/fast-check/lib/check/property/SkipAfterProperty.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SkipAfterProperty = void 0;
const PreconditionFailure_1 = __webpack_require__(/*! ../precondition/PreconditionFailure */ "./node_modules/fast-check/lib/check/precondition/PreconditionFailure.js");
class SkipAfterProperty {
    constructor(property, getTime, timeLimit, interruptExecution) {
        this.property = property;
        this.getTime = getTime;
        this.interruptExecution = interruptExecution;
        this.isAsync = () => this.property.isAsync();
        this.generate = (mrng, runId) => this.property.generate(mrng, runId);
        this.run = (v) => {
            if (this.getTime() >= this.skipAfterTime) {
                const preconditionFailure = new PreconditionFailure_1.PreconditionFailure(this.interruptExecution);
                if (this.isAsync()) {
                    return Promise.resolve(preconditionFailure);
                }
                else {
                    return preconditionFailure;
                }
            }
            return this.property.run(v);
        };
        this.skipAfterTime = this.getTime() + timeLimit;
    }
}
exports.SkipAfterProperty = SkipAfterProperty;


/***/ }),

/***/ "./node_modules/fast-check/lib/check/property/TimeoutProperty.js":
/*!***********************************************************************!*\
  !*** ./node_modules/fast-check/lib/check/property/TimeoutProperty.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TimeoutProperty = void 0;
const timeoutAfter = (timeMs) => {
    let timeoutHandle = null;
    const promise = new Promise((resolve) => {
        timeoutHandle = setTimeout(() => {
            resolve(`Property timeout: exceeded limit of ${timeMs} milliseconds`);
        }, timeMs);
    });
    return {
        clear: () => clearTimeout(timeoutHandle),
        promise,
    };
};
class TimeoutProperty {
    constructor(property, timeMs) {
        this.property = property;
        this.timeMs = timeMs;
        this.isAsync = () => true;
    }
    generate(mrng, runId) {
        return this.property.generate(mrng, runId);
    }
    async run(v) {
        const t = timeoutAfter(this.timeMs);
        const propRun = Promise.race([this.property.run(v), t.promise]);
        propRun.then(t.clear, t.clear);
        return propRun;
    }
}
exports.TimeoutProperty = TimeoutProperty;


/***/ }),

/***/ "./node_modules/fast-check/lib/check/property/UnbiasedProperty.js":
/*!************************************************************************!*\
  !*** ./node_modules/fast-check/lib/check/property/UnbiasedProperty.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UnbiasedProperty = void 0;
class UnbiasedProperty {
    constructor(property) {
        this.property = property;
        this.isAsync = () => this.property.isAsync();
        this.generate = (mrng, _runId) => this.property.generate(mrng);
        this.run = (v) => this.property.run(v);
    }
}
exports.UnbiasedProperty = UnbiasedProperty;


/***/ }),

/***/ "./node_modules/fast-check/lib/check/runner/DecorateProperty.js":
/*!**********************************************************************!*\
  !*** ./node_modules/fast-check/lib/check/runner/DecorateProperty.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.decorateProperty = void 0;
const SkipAfterProperty_1 = __webpack_require__(/*! ../property/SkipAfterProperty */ "./node_modules/fast-check/lib/check/property/SkipAfterProperty.js");
const TimeoutProperty_1 = __webpack_require__(/*! ../property/TimeoutProperty */ "./node_modules/fast-check/lib/check/property/TimeoutProperty.js");
const UnbiasedProperty_1 = __webpack_require__(/*! ../property/UnbiasedProperty */ "./node_modules/fast-check/lib/check/property/UnbiasedProperty.js");
const IgnoreEqualValuesProperty_1 = __webpack_require__(/*! ../property/IgnoreEqualValuesProperty */ "./node_modules/fast-check/lib/check/property/IgnoreEqualValuesProperty.js");
function decorateProperty(rawProperty, qParams) {
    let prop = rawProperty;
    if (rawProperty.isAsync() && qParams.timeout != null) {
        prop = new TimeoutProperty_1.TimeoutProperty(prop, qParams.timeout);
    }
    if (qParams.unbiased) {
        prop = new UnbiasedProperty_1.UnbiasedProperty(prop);
    }
    if (qParams.skipAllAfterTimeLimit != null) {
        prop = new SkipAfterProperty_1.SkipAfterProperty(prop, Date.now, qParams.skipAllAfterTimeLimit, false);
    }
    if (qParams.interruptAfterTimeLimit != null) {
        prop = new SkipAfterProperty_1.SkipAfterProperty(prop, Date.now, qParams.interruptAfterTimeLimit, true);
    }
    if (qParams.skipEqualValues) {
        prop = new IgnoreEqualValuesProperty_1.IgnoreEqualValuesProperty(prop, true);
    }
    if (qParams.ignoreEqualValues) {
        prop = new IgnoreEqualValuesProperty_1.IgnoreEqualValuesProperty(prop, false);
    }
    return prop;
}
exports.decorateProperty = decorateProperty;


/***/ }),

/***/ "./node_modules/fast-check/lib/check/runner/Runner.js":
/*!************************************************************!*\
  !*** ./node_modules/fast-check/lib/check/runner/Runner.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.assert = exports.check = void 0;
const Stream_1 = __webpack_require__(/*! ../../stream/Stream */ "./node_modules/fast-check/lib/stream/Stream.js");
const Shrinkable_1 = __webpack_require__(/*! ../arbitrary/definition/Shrinkable */ "./node_modules/fast-check/lib/check/arbitrary/definition/Shrinkable.js");
const GlobalParameters_1 = __webpack_require__(/*! ./configuration/GlobalParameters */ "./node_modules/fast-check/lib/check/runner/configuration/GlobalParameters.js");
const QualifiedParameters_1 = __webpack_require__(/*! ./configuration/QualifiedParameters */ "./node_modules/fast-check/lib/check/runner/configuration/QualifiedParameters.js");
const DecorateProperty_1 = __webpack_require__(/*! ./DecorateProperty */ "./node_modules/fast-check/lib/check/runner/DecorateProperty.js");
const RunnerIterator_1 = __webpack_require__(/*! ./RunnerIterator */ "./node_modules/fast-check/lib/check/runner/RunnerIterator.js");
const SourceValuesIterator_1 = __webpack_require__(/*! ./SourceValuesIterator */ "./node_modules/fast-check/lib/check/runner/SourceValuesIterator.js");
const Tosser_1 = __webpack_require__(/*! ./Tosser */ "./node_modules/fast-check/lib/check/runner/Tosser.js");
const PathWalker_1 = __webpack_require__(/*! ./utils/PathWalker */ "./node_modules/fast-check/lib/check/runner/utils/PathWalker.js");
const RunDetailsFormatter_1 = __webpack_require__(/*! ./utils/RunDetailsFormatter */ "./node_modules/fast-check/lib/check/runner/utils/RunDetailsFormatter.js");
function runIt(property, sourceValues, verbose, interruptedAsFailure) {
    const runner = new RunnerIterator_1.RunnerIterator(sourceValues, verbose, interruptedAsFailure);
    for (const v of runner) {
        const out = property.run(v);
        runner.handleResult(out);
    }
    return runner.runExecution;
}
async function asyncRunIt(property, sourceValues, verbose, interruptedAsFailure) {
    const runner = new RunnerIterator_1.RunnerIterator(sourceValues, verbose, interruptedAsFailure);
    for (const v of runner) {
        const out = await property.run(v);
        runner.handleResult(out);
    }
    return runner.runExecution;
}
function runnerPathWalker(valueProducers, path) {
    const pathPoints = path.split(':');
    const pathStream = Stream_1.stream(valueProducers)
        .drop(pathPoints.length > 0 ? +pathPoints[0] : 0)
        .map((producer) => producer());
    const adaptedPath = ['0', ...pathPoints.slice(1)].join(':');
    return Stream_1.stream(PathWalker_1.pathWalk(adaptedPath, pathStream)).map((v) => () => v);
}
function buildInitialValues(valueProducers, qParams) {
    const rawValues = qParams.path.length === 0 ? Stream_1.stream(valueProducers) : runnerPathWalker(valueProducers, qParams.path);
    if (!qParams.endOnFailure)
        return rawValues;
    return rawValues.map((shrinkableGen) => {
        return () => {
            const s = shrinkableGen();
            return new Shrinkable_1.Shrinkable(s.value_);
        };
    });
}
function check(rawProperty, params) {
    if (rawProperty == null || rawProperty.generate == null)
        throw new Error('Invalid property encountered, please use a valid property');
    if (rawProperty.run == null)
        throw new Error('Invalid property encountered, please use a valid property not an arbitrary');
    const qParams = QualifiedParameters_1.QualifiedParameters.read(Object.assign(Object.assign({}, GlobalParameters_1.readConfigureGlobal()), params));
    if (qParams.reporter !== null && qParams.asyncReporter !== null)
        throw new Error('Invalid parameters encountered, reporter and asyncReporter cannot be specified together');
    if (qParams.asyncReporter !== null && !rawProperty.isAsync())
        throw new Error('Invalid parameters encountered, only asyncProperty can be used when asyncReporter specified');
    const property = DecorateProperty_1.decorateProperty(rawProperty, qParams);
    const generator = Tosser_1.toss(property, qParams.seed, qParams.randomType, qParams.examples);
    const maxInitialIterations = qParams.path.indexOf(':') === -1 ? qParams.numRuns : -1;
    const maxSkips = qParams.numRuns * qParams.maxSkipsPerRun;
    const initialValues = buildInitialValues(generator, qParams);
    const sourceValues = new SourceValuesIterator_1.SourceValuesIterator(initialValues, maxInitialIterations, maxSkips);
    return property.isAsync()
        ? asyncRunIt(property, sourceValues, qParams.verbose, qParams.markInterruptAsFailure).then((e) => e.toRunDetails(qParams.seed, qParams.path, maxSkips, qParams))
        : runIt(property, sourceValues, qParams.verbose, qParams.markInterruptAsFailure).toRunDetails(qParams.seed, qParams.path, maxSkips, qParams);
}
exports.check = check;
function assert(property, params) {
    const out = check(property, params);
    if (property.isAsync())
        return out.then(RunDetailsFormatter_1.asyncReportRunDetails);
    else
        RunDetailsFormatter_1.reportRunDetails(out);
}
exports.assert = assert;


/***/ }),

/***/ "./node_modules/fast-check/lib/check/runner/RunnerIterator.js":
/*!********************************************************************!*\
  !*** ./node_modules/fast-check/lib/check/runner/RunnerIterator.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RunnerIterator = void 0;
const RunExecution_1 = __webpack_require__(/*! ./reporter/RunExecution */ "./node_modules/fast-check/lib/check/runner/reporter/RunExecution.js");
class RunnerIterator {
    constructor(sourceValues, verbose, interruptedAsFailure) {
        this.sourceValues = sourceValues;
        this.runExecution = new RunExecution_1.RunExecution(verbose, interruptedAsFailure);
        this.currentIdx = -1;
        this.nextValues = sourceValues;
    }
    [Symbol.iterator]() {
        return this;
    }
    next() {
        const nextValue = this.nextValues.next();
        if (nextValue.done || this.runExecution.interrupted) {
            return { done: true, value: undefined };
        }
        this.currentShrinkable = nextValue.value;
        ++this.currentIdx;
        return { done: false, value: nextValue.value.value_ };
    }
    handleResult(result) {
        if (result != null && typeof result === 'string') {
            this.runExecution.fail(this.currentShrinkable.value_, this.currentIdx, result);
            this.currentIdx = -1;
            this.nextValues = this.currentShrinkable.shrink();
        }
        else if (result != null) {
            if (!result.interruptExecution) {
                this.runExecution.skip(this.currentShrinkable.value_);
                this.sourceValues.skippedOne();
            }
            else {
                this.runExecution.interrupt();
            }
        }
        else {
            this.runExecution.success(this.currentShrinkable.value_);
        }
    }
}
exports.RunnerIterator = RunnerIterator;


/***/ }),

/***/ "./node_modules/fast-check/lib/check/runner/Sampler.js":
/*!*************************************************************!*\
  !*** ./node_modules/fast-check/lib/check/runner/Sampler.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.statistics = exports.sample = void 0;
const Stream_1 = __webpack_require__(/*! ../../stream/Stream */ "./node_modules/fast-check/lib/stream/Stream.js");
const Property_generic_1 = __webpack_require__(/*! ../property/Property.generic */ "./node_modules/fast-check/lib/check/property/Property.generic.js");
const UnbiasedProperty_1 = __webpack_require__(/*! ../property/UnbiasedProperty */ "./node_modules/fast-check/lib/check/property/UnbiasedProperty.js");
const GlobalParameters_1 = __webpack_require__(/*! ./configuration/GlobalParameters */ "./node_modules/fast-check/lib/check/runner/configuration/GlobalParameters.js");
const QualifiedParameters_1 = __webpack_require__(/*! ./configuration/QualifiedParameters */ "./node_modules/fast-check/lib/check/runner/configuration/QualifiedParameters.js");
const Tosser_1 = __webpack_require__(/*! ./Tosser */ "./node_modules/fast-check/lib/check/runner/Tosser.js");
const PathWalker_1 = __webpack_require__(/*! ./utils/PathWalker */ "./node_modules/fast-check/lib/check/runner/utils/PathWalker.js");
function toProperty(generator, qParams) {
    const prop = !Object.prototype.hasOwnProperty.call(generator, 'isAsync')
        ? new Property_generic_1.Property(generator, () => true)
        : generator;
    return qParams.unbiased === true ? new UnbiasedProperty_1.UnbiasedProperty(prop) : prop;
}
function streamSample(generator, params) {
    const extendedParams = typeof params === 'number'
        ? Object.assign(Object.assign({}, GlobalParameters_1.readConfigureGlobal()), { numRuns: params }) : Object.assign(Object.assign({}, GlobalParameters_1.readConfigureGlobal()), params);
    const qParams = QualifiedParameters_1.QualifiedParameters.read(extendedParams);
    const tossedValues = Stream_1.stream(Tosser_1.toss(toProperty(generator, qParams), qParams.seed, qParams.randomType, qParams.examples));
    if (qParams.path.length === 0) {
        return tossedValues.take(qParams.numRuns).map((s) => s().value_);
    }
    return Stream_1.stream(PathWalker_1.pathWalk(qParams.path, tossedValues.map((s) => s())))
        .take(qParams.numRuns)
        .map((s) => s.value_);
}
function sample(generator, params) {
    return [...streamSample(generator, params)];
}
exports.sample = sample;
function statistics(generator, classify, params) {
    const extendedParams = typeof params === 'number'
        ? Object.assign(Object.assign({}, GlobalParameters_1.readConfigureGlobal()), { numRuns: params }) : Object.assign(Object.assign({}, GlobalParameters_1.readConfigureGlobal()), params);
    const qParams = QualifiedParameters_1.QualifiedParameters.read(extendedParams);
    const recorded = {};
    for (const g of streamSample(generator, params)) {
        const out = classify(g);
        const categories = Array.isArray(out) ? out : [out];
        for (const c of categories) {
            recorded[c] = (recorded[c] || 0) + 1;
        }
    }
    const data = Object.entries(recorded)
        .sort((a, b) => b[1] - a[1])
        .map((i) => [i[0], `${((i[1] * 100.0) / qParams.numRuns).toFixed(2)}%`]);
    const longestName = data.map((i) => i[0].length).reduce((p, c) => Math.max(p, c), 0);
    const longestPercent = data.map((i) => i[1].length).reduce((p, c) => Math.max(p, c), 0);
    for (const item of data) {
        qParams.logger(`${item[0].padEnd(longestName, '.')}..${item[1].padStart(longestPercent, '.')}`);
    }
}
exports.statistics = statistics;


/***/ }),

/***/ "./node_modules/fast-check/lib/check/runner/SourceValuesIterator.js":
/*!**************************************************************************!*\
  !*** ./node_modules/fast-check/lib/check/runner/SourceValuesIterator.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SourceValuesIterator = void 0;
class SourceValuesIterator {
    constructor(initialValues, maxInitialIterations, remainingSkips) {
        this.initialValues = initialValues;
        this.maxInitialIterations = maxInitialIterations;
        this.remainingSkips = remainingSkips;
    }
    [Symbol.iterator]() {
        return this;
    }
    next() {
        if (--this.maxInitialIterations !== -1 && this.remainingSkips >= 0) {
            const n = this.initialValues.next();
            if (!n.done)
                return { value: n.value(), done: false };
        }
        return { value: undefined, done: true };
    }
    skippedOne() {
        --this.remainingSkips;
        ++this.maxInitialIterations;
    }
}
exports.SourceValuesIterator = SourceValuesIterator;


/***/ }),

/***/ "./node_modules/fast-check/lib/check/runner/Tosser.js":
/*!************************************************************!*\
  !*** ./node_modules/fast-check/lib/check/runner/Tosser.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.toss = void 0;
const pure_rand_1 = __webpack_require__(/*! pure-rand */ "./node_modules/pure-rand/lib/pure-rand.js");
const Random_1 = __webpack_require__(/*! ../../random/generator/Random */ "./node_modules/fast-check/lib/random/generator/Random.js");
const Shrinkable_1 = __webpack_require__(/*! ../arbitrary/definition/Shrinkable */ "./node_modules/fast-check/lib/check/arbitrary/definition/Shrinkable.js");
const PureRandom_1 = __webpack_require__(/*! ../../random/generator/PureRandom */ "./node_modules/fast-check/lib/random/generator/PureRandom.js");
function lazyGenerate(generator, rng, idx) {
    return () => generator.generate(new Random_1.Random(rng), idx);
}
function* toss(generator, seed, random, examples) {
    yield* examples.map((e) => () => new Shrinkable_1.Shrinkable(e));
    let idx = 0;
    let rng = PureRandom_1.convertToRandomGenerator(random(seed));
    for (;;) {
        rng = rng.jump ? rng.jump() : pure_rand_1.skipN(rng, 42);
        yield lazyGenerate(generator, rng, idx++);
    }
}
exports.toss = toss;


/***/ }),

/***/ "./node_modules/fast-check/lib/check/runner/configuration/GlobalParameters.js":
/*!************************************************************************************!*\
  !*** ./node_modules/fast-check/lib/check/runner/configuration/GlobalParameters.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.resetConfigureGlobal = exports.readConfigureGlobal = exports.configureGlobal = void 0;
let globalParameters = {};
function configureGlobal(parameters) {
    globalParameters = parameters;
}
exports.configureGlobal = configureGlobal;
function readConfigureGlobal() {
    return globalParameters;
}
exports.readConfigureGlobal = readConfigureGlobal;
function resetConfigureGlobal() {
    globalParameters = {};
}
exports.resetConfigureGlobal = resetConfigureGlobal;


/***/ }),

/***/ "./node_modules/fast-check/lib/check/runner/configuration/QualifiedParameters.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/fast-check/lib/check/runner/configuration/QualifiedParameters.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.QualifiedParameters = void 0;
const pure_rand_1 = __webpack_require__(/*! pure-rand */ "./node_modules/pure-rand/lib/pure-rand.js");
const VerbosityLevel_1 = __webpack_require__(/*! ./VerbosityLevel */ "./node_modules/fast-check/lib/check/runner/configuration/VerbosityLevel.js");
class QualifiedParameters {
    constructor(op) {
        const p = op || {};
        this.seed = QualifiedParameters.readSeed(p);
        this.randomType = QualifiedParameters.readRandomType(p);
        this.numRuns = QualifiedParameters.readNumRuns(p);
        this.verbose = QualifiedParameters.readVerbose(p);
        this.maxSkipsPerRun = QualifiedParameters.readOrDefault(p, 'maxSkipsPerRun', 100);
        this.timeout = QualifiedParameters.readOrDefault(p, 'timeout', null);
        this.skipAllAfterTimeLimit = QualifiedParameters.readOrDefault(p, 'skipAllAfterTimeLimit', null);
        this.interruptAfterTimeLimit = QualifiedParameters.readOrDefault(p, 'interruptAfterTimeLimit', null);
        this.markInterruptAsFailure = QualifiedParameters.readBoolean(p, 'markInterruptAsFailure');
        this.skipEqualValues = QualifiedParameters.readBoolean(p, 'skipEqualValues');
        this.ignoreEqualValues = QualifiedParameters.readBoolean(p, 'ignoreEqualValues');
        this.logger = QualifiedParameters.readOrDefault(p, 'logger', (v) => {
            console.log(v);
        });
        this.path = QualifiedParameters.readOrDefault(p, 'path', '');
        this.unbiased = QualifiedParameters.readBoolean(p, 'unbiased');
        this.examples = QualifiedParameters.readOrDefault(p, 'examples', []);
        this.endOnFailure = QualifiedParameters.readBoolean(p, 'endOnFailure');
        this.reporter = QualifiedParameters.readOrDefault(p, 'reporter', null);
        this.asyncReporter = QualifiedParameters.readOrDefault(p, 'asyncReporter', null);
    }
    toParameters() {
        const orUndefined = (value) => (value !== null ? value : undefined);
        return {
            seed: this.seed,
            randomType: this.randomType,
            numRuns: this.numRuns,
            maxSkipsPerRun: this.maxSkipsPerRun,
            timeout: orUndefined(this.timeout),
            skipAllAfterTimeLimit: orUndefined(this.skipAllAfterTimeLimit),
            interruptAfterTimeLimit: orUndefined(this.interruptAfterTimeLimit),
            markInterruptAsFailure: this.markInterruptAsFailure,
            skipEqualValues: this.skipEqualValues,
            ignoreEqualValues: this.ignoreEqualValues,
            path: this.path,
            logger: this.logger,
            unbiased: this.unbiased,
            verbose: this.verbose,
            examples: this.examples,
            endOnFailure: this.endOnFailure,
            reporter: orUndefined(this.reporter),
            asyncReporter: orUndefined(this.asyncReporter),
        };
    }
    static read(op) {
        return new QualifiedParameters(op);
    }
}
exports.QualifiedParameters = QualifiedParameters;
QualifiedParameters.readSeed = (p) => {
    if (p.seed == null)
        return Date.now() ^ (Math.random() * 0x100000000);
    const seed32 = p.seed | 0;
    if (p.seed === seed32)
        return seed32;
    const gap = p.seed - seed32;
    return seed32 ^ (gap * 0x100000000);
};
QualifiedParameters.readRandomType = (p) => {
    if (p.randomType == null)
        return pure_rand_1.default.xorshift128plus;
    if (typeof p.randomType === 'string') {
        switch (p.randomType) {
            case 'mersenne':
                return pure_rand_1.default.mersenne;
            case 'congruential':
                return pure_rand_1.default.congruential;
            case 'congruential32':
                return pure_rand_1.default.congruential32;
            case 'xorshift128plus':
                return pure_rand_1.default.xorshift128plus;
            case 'xoroshiro128plus':
                return pure_rand_1.default.xoroshiro128plus;
            default:
                throw new Error(`Invalid random specified: '${p.randomType}'`);
        }
    }
    return p.randomType;
};
QualifiedParameters.readNumRuns = (p) => {
    const defaultValue = 100;
    if (p.numRuns != null)
        return p.numRuns;
    if (p.num_runs != null)
        return p.num_runs;
    return defaultValue;
};
QualifiedParameters.readVerbose = (p) => {
    if (p.verbose == null)
        return VerbosityLevel_1.VerbosityLevel.None;
    if (typeof p.verbose === 'boolean') {
        return p.verbose === true ? VerbosityLevel_1.VerbosityLevel.Verbose : VerbosityLevel_1.VerbosityLevel.None;
    }
    if (p.verbose <= VerbosityLevel_1.VerbosityLevel.None) {
        return VerbosityLevel_1.VerbosityLevel.None;
    }
    if (p.verbose >= VerbosityLevel_1.VerbosityLevel.VeryVerbose) {
        return VerbosityLevel_1.VerbosityLevel.VeryVerbose;
    }
    return p.verbose | 0;
};
QualifiedParameters.readBoolean = (p, key) => p[key] === true;
QualifiedParameters.readOrDefault = (p, key, defaultValue) => {
    const value = p[key];
    return value != null ? value : defaultValue;
};


/***/ }),

/***/ "./node_modules/fast-check/lib/check/runner/configuration/VerbosityLevel.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/fast-check/lib/check/runner/configuration/VerbosityLevel.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.VerbosityLevel = void 0;
var VerbosityLevel;
(function (VerbosityLevel) {
    VerbosityLevel[VerbosityLevel["None"] = 0] = "None";
    VerbosityLevel[VerbosityLevel["Verbose"] = 1] = "Verbose";
    VerbosityLevel[VerbosityLevel["VeryVerbose"] = 2] = "VeryVerbose";
})(VerbosityLevel = exports.VerbosityLevel || (exports.VerbosityLevel = {}));


/***/ }),

/***/ "./node_modules/fast-check/lib/check/runner/reporter/ExecutionStatus.js":
/*!******************************************************************************!*\
  !*** ./node_modules/fast-check/lib/check/runner/reporter/ExecutionStatus.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ExecutionStatus = void 0;
var ExecutionStatus;
(function (ExecutionStatus) {
    ExecutionStatus[ExecutionStatus["Success"] = 0] = "Success";
    ExecutionStatus[ExecutionStatus["Skipped"] = -1] = "Skipped";
    ExecutionStatus[ExecutionStatus["Failure"] = 1] = "Failure";
})(ExecutionStatus = exports.ExecutionStatus || (exports.ExecutionStatus = {}));


/***/ }),

/***/ "./node_modules/fast-check/lib/check/runner/reporter/RunExecution.js":
/*!***************************************************************************!*\
  !*** ./node_modules/fast-check/lib/check/runner/reporter/RunExecution.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RunExecution = void 0;
const VerbosityLevel_1 = __webpack_require__(/*! ../configuration/VerbosityLevel */ "./node_modules/fast-check/lib/check/runner/configuration/VerbosityLevel.js");
const ExecutionStatus_1 = __webpack_require__(/*! ./ExecutionStatus */ "./node_modules/fast-check/lib/check/runner/reporter/ExecutionStatus.js");
class RunExecution {
    constructor(verbosity, interruptedAsFailure) {
        this.verbosity = verbosity;
        this.interruptedAsFailure = interruptedAsFailure;
        this.isSuccess = () => this.pathToFailure == null;
        this.firstFailure = () => (this.pathToFailure ? +this.pathToFailure.split(':')[0] : -1);
        this.numShrinks = () => (this.pathToFailure ? this.pathToFailure.split(':').length - 1 : 0);
        this.rootExecutionTrees = [];
        this.currentLevelExecutionTrees = this.rootExecutionTrees;
        this.failure = null;
        this.numSkips = 0;
        this.numSuccesses = 0;
        this.interrupted = false;
    }
    appendExecutionTree(status, value) {
        const currentTree = { status, value, children: [] };
        this.currentLevelExecutionTrees.push(currentTree);
        return currentTree;
    }
    fail(value, id, message) {
        if (this.verbosity >= VerbosityLevel_1.VerbosityLevel.Verbose) {
            const currentTree = this.appendExecutionTree(ExecutionStatus_1.ExecutionStatus.Failure, value);
            this.currentLevelExecutionTrees = currentTree.children;
        }
        if (this.pathToFailure == null)
            this.pathToFailure = `${id}`;
        else
            this.pathToFailure += `:${id}`;
        this.value = value;
        this.failure = message;
    }
    skip(value) {
        if (this.verbosity >= VerbosityLevel_1.VerbosityLevel.VeryVerbose) {
            this.appendExecutionTree(ExecutionStatus_1.ExecutionStatus.Skipped, value);
        }
        if (this.pathToFailure == null) {
            ++this.numSkips;
        }
    }
    success(value) {
        if (this.verbosity >= VerbosityLevel_1.VerbosityLevel.VeryVerbose) {
            this.appendExecutionTree(ExecutionStatus_1.ExecutionStatus.Success, value);
        }
        if (this.pathToFailure == null) {
            ++this.numSuccesses;
        }
    }
    interrupt() {
        this.interrupted = true;
    }
    extractFailures() {
        if (this.isSuccess()) {
            return [];
        }
        const failures = [];
        let cursor = this.rootExecutionTrees;
        while (cursor.length > 0 && cursor[cursor.length - 1].status === ExecutionStatus_1.ExecutionStatus.Failure) {
            const failureTree = cursor[cursor.length - 1];
            failures.push(failureTree.value);
            cursor = failureTree.children;
        }
        return failures;
    }
    toRunDetails(seed, basePath, maxSkips, qParams) {
        if (!this.isSuccess()) {
            return {
                failed: true,
                interrupted: this.interrupted,
                numRuns: this.firstFailure() + 1 - this.numSkips,
                numSkips: this.numSkips,
                numShrinks: this.numShrinks(),
                seed,
                counterexample: this.value,
                counterexamplePath: RunExecution.mergePaths(basePath, this.pathToFailure),
                error: this.failure,
                failures: this.extractFailures(),
                executionSummary: this.rootExecutionTrees,
                verbose: this.verbosity,
                runConfiguration: qParams.toParameters(),
            };
        }
        const failed = this.numSkips > maxSkips || (this.interrupted && this.interruptedAsFailure);
        return {
            failed,
            interrupted: this.interrupted,
            numRuns: this.numSuccesses,
            numSkips: this.numSkips,
            numShrinks: 0,
            seed,
            counterexample: null,
            counterexamplePath: null,
            error: null,
            failures: [],
            executionSummary: this.rootExecutionTrees,
            verbose: this.verbosity,
            runConfiguration: qParams.toParameters(),
        };
    }
}
exports.RunExecution = RunExecution;
RunExecution.mergePaths = (offsetPath, path) => {
    if (offsetPath.length === 0)
        return path;
    const offsetItems = offsetPath.split(':');
    const remainingItems = path.split(':');
    const middle = +offsetItems[offsetItems.length - 1] + +remainingItems[0];
    return [...offsetItems.slice(0, offsetItems.length - 1), `${middle}`, ...remainingItems.slice(1)].join(':');
};


/***/ }),

/***/ "./node_modules/fast-check/lib/check/runner/utils/PathWalker.js":
/*!**********************************************************************!*\
  !*** ./node_modules/fast-check/lib/check/runner/utils/PathWalker.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.pathWalk = void 0;
const Stream_1 = __webpack_require__(/*! ../../../stream/Stream */ "./node_modules/fast-check/lib/stream/Stream.js");
function pathWalk(path, initialValues) {
    let values = Stream_1.stream(initialValues);
    const segments = path.split(':').map((text) => +text);
    if (segments.length === 0)
        return values;
    if (!segments.every((v) => !Number.isNaN(v))) {
        throw new Error(`Unable to replay, got invalid path=${path}`);
    }
    values = values.drop(segments[0]);
    for (const s of segments.slice(1)) {
        const valueToShrink = values.getNthOrLast(0);
        if (valueToShrink == null) {
            throw new Error(`Unable to replay, got wrong path=${path}`);
        }
        values = valueToShrink.shrink().drop(s);
    }
    return values;
}
exports.pathWalk = pathWalk;


/***/ }),

/***/ "./node_modules/fast-check/lib/check/runner/utils/RunDetailsFormatter.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/fast-check/lib/check/runner/utils/RunDetailsFormatter.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.asyncDefaultReportMessage = exports.defaultReportMessage = exports.asyncReportRunDetails = exports.reportRunDetails = void 0;
const stringify_1 = __webpack_require__(/*! ../../../utils/stringify */ "./node_modules/fast-check/lib/utils/stringify.js");
const VerbosityLevel_1 = __webpack_require__(/*! ../configuration/VerbosityLevel */ "./node_modules/fast-check/lib/check/runner/configuration/VerbosityLevel.js");
const ExecutionStatus_1 = __webpack_require__(/*! ../reporter/ExecutionStatus */ "./node_modules/fast-check/lib/check/runner/reporter/ExecutionStatus.js");
function formatHints(hints) {
    if (hints.length === 1) {
        return `Hint: ${hints[0]}`;
    }
    return hints.map((h, idx) => `Hint (${idx + 1}): ${h}`).join('\n');
}
function formatFailures(failures, stringifyOne) {
    return `Encountered failures were:\n- ${failures.map(stringifyOne).join('\n- ')}`;
}
function formatExecutionSummary(executionTrees, stringifyOne) {
    const summaryLines = [];
    const remainingTreesAndDepth = [];
    for (const tree of executionTrees.slice().reverse()) {
        remainingTreesAndDepth.push({ depth: 1, tree });
    }
    while (remainingTreesAndDepth.length !== 0) {
        const currentTreeAndDepth = remainingTreesAndDepth.pop();
        const currentTree = currentTreeAndDepth.tree;
        const currentDepth = currentTreeAndDepth.depth;
        const statusIcon = currentTree.status === ExecutionStatus_1.ExecutionStatus.Success
            ? '\x1b[32m\u221A\x1b[0m'
            : currentTree.status === ExecutionStatus_1.ExecutionStatus.Failure
                ? '\x1b[31m\xD7\x1b[0m'
                : '\x1b[33m!\x1b[0m';
        const leftPadding = Array(currentDepth).join('. ');
        summaryLines.push(`${leftPadding}${statusIcon} ${stringifyOne(currentTree.value)}`);
        for (const tree of currentTree.children.slice().reverse()) {
            remainingTreesAndDepth.push({ depth: currentDepth + 1, tree });
        }
    }
    return `Execution summary:\n${summaryLines.join('\n')}`;
}
function preFormatTooManySkipped(out, stringifyOne) {
    const message = `Failed to run property, too many pre-condition failures encountered\n{ seed: ${out.seed} }\n\nRan ${out.numRuns} time(s)\nSkipped ${out.numSkips} time(s)`;
    let details = null;
    const hints = [
        'Try to reduce the number of rejected values by combining map, flatMap and built-in arbitraries',
        'Increase failure tolerance by setting maxSkipsPerRun to an higher value',
    ];
    if (out.verbose >= VerbosityLevel_1.VerbosityLevel.VeryVerbose) {
        details = formatExecutionSummary(out.executionSummary, stringifyOne);
    }
    else {
        hints.push('Enable verbose mode at level VeryVerbose in order to check all generated values and their associated status');
    }
    return { message, details, hints };
}
function preFormatFailure(out, stringifyOne) {
    const message = `Property failed after ${out.numRuns} tests\n{ seed: ${out.seed}, path: "${out.counterexamplePath}", endOnFailure: true }\nCounterexample: ${stringifyOne(out.counterexample)}\nShrunk ${out.numShrinks} time(s)\nGot error: ${out.error}`;
    let details = null;
    const hints = [];
    if (out.verbose >= VerbosityLevel_1.VerbosityLevel.VeryVerbose) {
        details = formatExecutionSummary(out.executionSummary, stringifyOne);
    }
    else if (out.verbose === VerbosityLevel_1.VerbosityLevel.Verbose) {
        details = formatFailures(out.failures, stringifyOne);
    }
    else {
        hints.push('Enable verbose mode in order to have the list of all failing values encountered during the run');
    }
    return { message, details, hints };
}
function preFormatEarlyInterrupted(out, stringifyOne) {
    const message = `Property interrupted after ${out.numRuns} tests\n{ seed: ${out.seed} }`;
    let details = null;
    const hints = [];
    if (out.verbose >= VerbosityLevel_1.VerbosityLevel.VeryVerbose) {
        details = formatExecutionSummary(out.executionSummary, stringifyOne);
    }
    else {
        hints.push('Enable verbose mode at level VeryVerbose in order to check all generated values and their associated status');
    }
    return { message, details, hints };
}
function defaultReportMessageInternal(out, stringifyOne) {
    if (!out.failed)
        return;
    const { message, details, hints } = out.counterexamplePath === null
        ? out.interrupted
            ? preFormatEarlyInterrupted(out, stringifyOne)
            : preFormatTooManySkipped(out, stringifyOne)
        : preFormatFailure(out, stringifyOne);
    let errorMessage = message;
    if (details != null)
        errorMessage += `\n\n${details}`;
    if (hints.length > 0)
        errorMessage += `\n\n${formatHints(hints)}`;
    return errorMessage;
}
function defaultReportMessage(out) {
    return defaultReportMessageInternal(out, stringify_1.stringify);
}
exports.defaultReportMessage = defaultReportMessage;
async function asyncDefaultReportMessage(out) {
    const pendingStringifieds = [];
    function stringifyOne(value) {
        const stringified = stringify_1.possiblyAsyncStringify(value);
        if (typeof stringified === 'string') {
            return stringified;
        }
        pendingStringifieds.push(Promise.all([value, stringified]));
        return '\u2026';
    }
    const firstTryMessage = defaultReportMessageInternal(out, stringifyOne);
    if (pendingStringifieds.length === 0) {
        return firstTryMessage;
    }
    const registeredValues = new Map(await Promise.all(pendingStringifieds));
    function stringifySecond(value) {
        const asyncStringifiedIfRegistered = registeredValues.get(value);
        if (asyncStringifiedIfRegistered !== undefined) {
            return asyncStringifiedIfRegistered;
        }
        return stringify_1.stringify(value);
    }
    return defaultReportMessageInternal(out, stringifySecond);
}
exports.asyncDefaultReportMessage = asyncDefaultReportMessage;
function throwIfFailed(out) {
    if (!out.failed)
        return;
    throw new Error(defaultReportMessage(out));
}
async function asyncThrowIfFailed(out) {
    if (!out.failed)
        return;
    throw new Error(await asyncDefaultReportMessage(out));
}
function reportRunDetails(out) {
    if (out.runConfiguration.asyncReporter)
        return out.runConfiguration.asyncReporter(out);
    else if (out.runConfiguration.reporter)
        return out.runConfiguration.reporter(out);
    else
        return throwIfFailed(out);
}
exports.reportRunDetails = reportRunDetails;
async function asyncReportRunDetails(out) {
    if (out.runConfiguration.asyncReporter)
        return out.runConfiguration.asyncReporter(out);
    else if (out.runConfiguration.reporter)
        return out.runConfiguration.reporter(out);
    else
        return asyncThrowIfFailed(out);
}
exports.asyncReportRunDetails = asyncReportRunDetails;


/***/ }),

/***/ "./node_modules/fast-check/lib/check/symbols.js":
/*!******************************************************!*\
  !*** ./node_modules/fast-check/lib/check/symbols.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.cloneIfNeeded = exports.hasCloneMethod = exports.cloneMethod = void 0;
exports.cloneMethod = Symbol('fast-check/cloneMethod');
function hasCloneMethod(instance) {
    return (instance !== null &&
        (typeof instance === 'object' || typeof instance === 'function') &&
        exports.cloneMethod in instance &&
        typeof instance[exports.cloneMethod] === 'function');
}
exports.hasCloneMethod = hasCloneMethod;
function cloneIfNeeded(instance) {
    return hasCloneMethod(instance) ? instance[exports.cloneMethod]() : instance;
}
exports.cloneIfNeeded = cloneIfNeeded;


/***/ }),

/***/ "./node_modules/fast-check/lib/fast-check-default.js":
/*!***********************************************************!*\
  !*** ./node_modules/fast-check/lib/fast-check-default.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.shuffledSubarray = exports.dedup = exports.clone = exports.frequency = exports.oneof = exports.option = exports.mapToConstant = exports.clonedConstant = exports.constantFrom = exports.constant = exports.lorem = exports.base64String = exports.hexaString = exports.fullUnicodeString = exports.unicodeString = exports.stringOf = exports.string16bits = exports.asciiString = exports.string = exports.mixedCase = exports.base64 = exports.hexa = exports.fullUnicode = exports.unicode = exports.char16bits = exports.ascii = exports.char = exports.bigUint = exports.bigInt = exports.bigUintN = exports.bigIntN = exports.maxSafeNat = exports.maxSafeInteger = exports.nat = exports.integer = exports.double = exports.float = exports.falsy = exports.boolean = exports.asyncProperty = exports.property = exports.PreconditionFailure = exports.pre = exports.assert = exports.check = exports.statistics = exports.sample = exports.__commitHash = exports.__version = exports.__type = void 0;
exports.Arbitrary = exports.schedulerFor = exports.scheduler = exports.commands = exports.scheduledModelRun = exports.modelRun = exports.asyncModelRun = exports.float64Array = exports.float32Array = exports.uint32Array = exports.int32Array = exports.uint16Array = exports.int16Array = exports.uint8ClampedArray = exports.uint8Array = exports.int8Array = exports.uuidV = exports.uuid = exports.emailAddress = exports.webUrl = exports.webQueryParameters = exports.webFragments = exports.webSegment = exports.webAuthority = exports.domain = exports.ipV6 = exports.ipV4Extended = exports.ipV4 = exports.date = exports.context = exports.func = exports.compareFunc = exports.compareBooleanFunc = exports.memo = exports.letrec = exports.unicodeJsonObject = exports.unicodeJson = exports.jsonObject = exports.json = exports.object = exports.anything = exports.dictionary = exports.record = exports.genericTuple = exports.tuple = exports.set = exports.infiniteStream = exports.sparseArray = exports.array = exports.subarray = void 0;
exports.stream = exports.Stream = exports.Random = exports.ExecutionStatus = exports.resetConfigureGlobal = exports.readConfigureGlobal = exports.configureGlobal = exports.VerbosityLevel = exports.hash = exports.asyncDefaultReportMessage = exports.defaultReportMessage = exports.asyncStringify = exports.stringify = exports.hasAsyncToStringMethod = exports.asyncToStringMethod = exports.hasToStringMethod = exports.toStringMethod = exports.convertToNext = exports.convertFromNextWithShrunkOnce = exports.convertFromNext = exports.hasCloneMethod = exports.cloneIfNeeded = exports.cloneMethod = exports.NextValue = exports.Shrinkable = exports.ArbitraryWithContextualShrink = exports.ArbitraryWithShrink = exports.NextArbitrary = void 0;
const Pre_1 = __webpack_require__(/*! ./check/precondition/Pre */ "./node_modules/fast-check/lib/check/precondition/Pre.js");
Object.defineProperty(exports, "pre", ({ enumerable: true, get: function () { return Pre_1.pre; } }));
const AsyncProperty_1 = __webpack_require__(/*! ./check/property/AsyncProperty */ "./node_modules/fast-check/lib/check/property/AsyncProperty.js");
Object.defineProperty(exports, "asyncProperty", ({ enumerable: true, get: function () { return AsyncProperty_1.asyncProperty; } }));
const Property_1 = __webpack_require__(/*! ./check/property/Property */ "./node_modules/fast-check/lib/check/property/Property.js");
Object.defineProperty(exports, "property", ({ enumerable: true, get: function () { return Property_1.property; } }));
const Runner_1 = __webpack_require__(/*! ./check/runner/Runner */ "./node_modules/fast-check/lib/check/runner/Runner.js");
Object.defineProperty(exports, "assert", ({ enumerable: true, get: function () { return Runner_1.assert; } }));
Object.defineProperty(exports, "check", ({ enumerable: true, get: function () { return Runner_1.check; } }));
const Sampler_1 = __webpack_require__(/*! ./check/runner/Sampler */ "./node_modules/fast-check/lib/check/runner/Sampler.js");
Object.defineProperty(exports, "sample", ({ enumerable: true, get: function () { return Sampler_1.sample; } }));
Object.defineProperty(exports, "statistics", ({ enumerable: true, get: function () { return Sampler_1.statistics; } }));
const array_1 = __webpack_require__(/*! ./arbitrary/array */ "./node_modules/fast-check/lib/arbitrary/array.js");
Object.defineProperty(exports, "array", ({ enumerable: true, get: function () { return array_1.array; } }));
const bigInt_1 = __webpack_require__(/*! ./arbitrary/bigInt */ "./node_modules/fast-check/lib/arbitrary/bigInt.js");
Object.defineProperty(exports, "bigInt", ({ enumerable: true, get: function () { return bigInt_1.bigInt; } }));
const bigIntN_1 = __webpack_require__(/*! ./arbitrary/bigIntN */ "./node_modules/fast-check/lib/arbitrary/bigIntN.js");
Object.defineProperty(exports, "bigIntN", ({ enumerable: true, get: function () { return bigIntN_1.bigIntN; } }));
const bigUint_1 = __webpack_require__(/*! ./arbitrary/bigUint */ "./node_modules/fast-check/lib/arbitrary/bigUint.js");
Object.defineProperty(exports, "bigUint", ({ enumerable: true, get: function () { return bigUint_1.bigUint; } }));
const bigUintN_1 = __webpack_require__(/*! ./arbitrary/bigUintN */ "./node_modules/fast-check/lib/arbitrary/bigUintN.js");
Object.defineProperty(exports, "bigUintN", ({ enumerable: true, get: function () { return bigUintN_1.bigUintN; } }));
const boolean_1 = __webpack_require__(/*! ./arbitrary/boolean */ "./node_modules/fast-check/lib/arbitrary/boolean.js");
Object.defineProperty(exports, "boolean", ({ enumerable: true, get: function () { return boolean_1.boolean; } }));
const falsy_1 = __webpack_require__(/*! ./arbitrary/falsy */ "./node_modules/fast-check/lib/arbitrary/falsy.js");
Object.defineProperty(exports, "falsy", ({ enumerable: true, get: function () { return falsy_1.falsy; } }));
const ascii_1 = __webpack_require__(/*! ./arbitrary/ascii */ "./node_modules/fast-check/lib/arbitrary/ascii.js");
Object.defineProperty(exports, "ascii", ({ enumerable: true, get: function () { return ascii_1.ascii; } }));
const base64_1 = __webpack_require__(/*! ./arbitrary/base64 */ "./node_modules/fast-check/lib/arbitrary/base64.js");
Object.defineProperty(exports, "base64", ({ enumerable: true, get: function () { return base64_1.base64; } }));
const char_1 = __webpack_require__(/*! ./arbitrary/char */ "./node_modules/fast-check/lib/arbitrary/char.js");
Object.defineProperty(exports, "char", ({ enumerable: true, get: function () { return char_1.char; } }));
const char16bits_1 = __webpack_require__(/*! ./arbitrary/char16bits */ "./node_modules/fast-check/lib/arbitrary/char16bits.js");
Object.defineProperty(exports, "char16bits", ({ enumerable: true, get: function () { return char16bits_1.char16bits; } }));
const fullUnicode_1 = __webpack_require__(/*! ./arbitrary/fullUnicode */ "./node_modules/fast-check/lib/arbitrary/fullUnicode.js");
Object.defineProperty(exports, "fullUnicode", ({ enumerable: true, get: function () { return fullUnicode_1.fullUnicode; } }));
const hexa_1 = __webpack_require__(/*! ./arbitrary/hexa */ "./node_modules/fast-check/lib/arbitrary/hexa.js");
Object.defineProperty(exports, "hexa", ({ enumerable: true, get: function () { return hexa_1.hexa; } }));
const unicode_1 = __webpack_require__(/*! ./arbitrary/unicode */ "./node_modules/fast-check/lib/arbitrary/unicode.js");
Object.defineProperty(exports, "unicode", ({ enumerable: true, get: function () { return unicode_1.unicode; } }));
const clonedConstant_1 = __webpack_require__(/*! ./arbitrary/clonedConstant */ "./node_modules/fast-check/lib/arbitrary/clonedConstant.js");
Object.defineProperty(exports, "clonedConstant", ({ enumerable: true, get: function () { return clonedConstant_1.clonedConstant; } }));
const constant_1 = __webpack_require__(/*! ./arbitrary/constant */ "./node_modules/fast-check/lib/arbitrary/constant.js");
Object.defineProperty(exports, "constant", ({ enumerable: true, get: function () { return constant_1.constant; } }));
const constantFrom_1 = __webpack_require__(/*! ./arbitrary/constantFrom */ "./node_modules/fast-check/lib/arbitrary/constantFrom.js");
Object.defineProperty(exports, "constantFrom", ({ enumerable: true, get: function () { return constantFrom_1.constantFrom; } }));
const context_1 = __webpack_require__(/*! ./arbitrary/context */ "./node_modules/fast-check/lib/arbitrary/context.js");
Object.defineProperty(exports, "context", ({ enumerable: true, get: function () { return context_1.context; } }));
const date_1 = __webpack_require__(/*! ./arbitrary/date */ "./node_modules/fast-check/lib/arbitrary/date.js");
Object.defineProperty(exports, "date", ({ enumerable: true, get: function () { return date_1.date; } }));
const clone_1 = __webpack_require__(/*! ./arbitrary/clone */ "./node_modules/fast-check/lib/arbitrary/clone.js");
Object.defineProperty(exports, "clone", ({ enumerable: true, get: function () { return clone_1.clone; } }));
const dedup_1 = __webpack_require__(/*! ./arbitrary/dedup */ "./node_modules/fast-check/lib/arbitrary/dedup.js");
Object.defineProperty(exports, "dedup", ({ enumerable: true, get: function () { return dedup_1.dedup; } }));
const Arbitrary_1 = __webpack_require__(/*! ./check/arbitrary/definition/Arbitrary */ "./node_modules/fast-check/lib/check/arbitrary/definition/Arbitrary.js");
Object.defineProperty(exports, "Arbitrary", ({ enumerable: true, get: function () { return Arbitrary_1.Arbitrary; } }));
const Shrinkable_1 = __webpack_require__(/*! ./check/arbitrary/definition/Shrinkable */ "./node_modules/fast-check/lib/check/arbitrary/definition/Shrinkable.js");
Object.defineProperty(exports, "Shrinkable", ({ enumerable: true, get: function () { return Shrinkable_1.Shrinkable; } }));
const dictionary_1 = __webpack_require__(/*! ./arbitrary/dictionary */ "./node_modules/fast-check/lib/arbitrary/dictionary.js");
Object.defineProperty(exports, "dictionary", ({ enumerable: true, get: function () { return dictionary_1.dictionary; } }));
const EmailArbitrary_1 = __webpack_require__(/*! ./check/arbitrary/EmailArbitrary */ "./node_modules/fast-check/lib/check/arbitrary/EmailArbitrary.js");
Object.defineProperty(exports, "emailAddress", ({ enumerable: true, get: function () { return EmailArbitrary_1.emailAddress; } }));
const FloatingPointArbitrary_1 = __webpack_require__(/*! ./check/arbitrary/FloatingPointArbitrary */ "./node_modules/fast-check/lib/check/arbitrary/FloatingPointArbitrary.js");
Object.defineProperty(exports, "double", ({ enumerable: true, get: function () { return FloatingPointArbitrary_1.double; } }));
Object.defineProperty(exports, "float", ({ enumerable: true, get: function () { return FloatingPointArbitrary_1.float; } }));
const frequency_1 = __webpack_require__(/*! ./arbitrary/frequency */ "./node_modules/fast-check/lib/arbitrary/frequency.js");
Object.defineProperty(exports, "frequency", ({ enumerable: true, get: function () { return frequency_1.frequency; } }));
const compareBooleanFunc_1 = __webpack_require__(/*! ./arbitrary/compareBooleanFunc */ "./node_modules/fast-check/lib/arbitrary/compareBooleanFunc.js");
Object.defineProperty(exports, "compareBooleanFunc", ({ enumerable: true, get: function () { return compareBooleanFunc_1.compareBooleanFunc; } }));
const compareFunc_1 = __webpack_require__(/*! ./arbitrary/compareFunc */ "./node_modules/fast-check/lib/arbitrary/compareFunc.js");
Object.defineProperty(exports, "compareFunc", ({ enumerable: true, get: function () { return compareFunc_1.compareFunc; } }));
const func_1 = __webpack_require__(/*! ./arbitrary/func */ "./node_modules/fast-check/lib/arbitrary/func.js");
Object.defineProperty(exports, "func", ({ enumerable: true, get: function () { return func_1.func; } }));
const HostArbitrary_1 = __webpack_require__(/*! ./check/arbitrary/HostArbitrary */ "./node_modules/fast-check/lib/check/arbitrary/HostArbitrary.js");
Object.defineProperty(exports, "domain", ({ enumerable: true, get: function () { return HostArbitrary_1.domain; } }));
const integer_1 = __webpack_require__(/*! ./arbitrary/integer */ "./node_modules/fast-check/lib/arbitrary/integer.js");
Object.defineProperty(exports, "integer", ({ enumerable: true, get: function () { return integer_1.integer; } }));
const maxSafeInteger_1 = __webpack_require__(/*! ./arbitrary/maxSafeInteger */ "./node_modules/fast-check/lib/arbitrary/maxSafeInteger.js");
Object.defineProperty(exports, "maxSafeInteger", ({ enumerable: true, get: function () { return maxSafeInteger_1.maxSafeInteger; } }));
const maxSafeNat_1 = __webpack_require__(/*! ./arbitrary/maxSafeNat */ "./node_modules/fast-check/lib/arbitrary/maxSafeNat.js");
Object.defineProperty(exports, "maxSafeNat", ({ enumerable: true, get: function () { return maxSafeNat_1.maxSafeNat; } }));
const nat_1 = __webpack_require__(/*! ./arbitrary/nat */ "./node_modules/fast-check/lib/arbitrary/nat.js");
Object.defineProperty(exports, "nat", ({ enumerable: true, get: function () { return nat_1.nat; } }));
const ipV4_1 = __webpack_require__(/*! ./arbitrary/ipV4 */ "./node_modules/fast-check/lib/arbitrary/ipV4.js");
Object.defineProperty(exports, "ipV4", ({ enumerable: true, get: function () { return ipV4_1.ipV4; } }));
const ipV4Extended_1 = __webpack_require__(/*! ./arbitrary/ipV4Extended */ "./node_modules/fast-check/lib/arbitrary/ipV4Extended.js");
Object.defineProperty(exports, "ipV4Extended", ({ enumerable: true, get: function () { return ipV4Extended_1.ipV4Extended; } }));
const ipV6_1 = __webpack_require__(/*! ./arbitrary/ipV6 */ "./node_modules/fast-check/lib/arbitrary/ipV6.js");
Object.defineProperty(exports, "ipV6", ({ enumerable: true, get: function () { return ipV6_1.ipV6; } }));
const letrec_1 = __webpack_require__(/*! ./arbitrary/letrec */ "./node_modules/fast-check/lib/arbitrary/letrec.js");
Object.defineProperty(exports, "letrec", ({ enumerable: true, get: function () { return letrec_1.letrec; } }));
const lorem_1 = __webpack_require__(/*! ./arbitrary/lorem */ "./node_modules/fast-check/lib/arbitrary/lorem.js");
Object.defineProperty(exports, "lorem", ({ enumerable: true, get: function () { return lorem_1.lorem; } }));
const mapToConstant_1 = __webpack_require__(/*! ./arbitrary/mapToConstant */ "./node_modules/fast-check/lib/arbitrary/mapToConstant.js");
Object.defineProperty(exports, "mapToConstant", ({ enumerable: true, get: function () { return mapToConstant_1.mapToConstant; } }));
const memo_1 = __webpack_require__(/*! ./arbitrary/memo */ "./node_modules/fast-check/lib/arbitrary/memo.js");
Object.defineProperty(exports, "memo", ({ enumerable: true, get: function () { return memo_1.memo; } }));
const mixedCase_1 = __webpack_require__(/*! ./arbitrary/mixedCase */ "./node_modules/fast-check/lib/arbitrary/mixedCase.js");
Object.defineProperty(exports, "mixedCase", ({ enumerable: true, get: function () { return mixedCase_1.mixedCase; } }));
const ObjectArbitrary_1 = __webpack_require__(/*! ./check/arbitrary/ObjectArbitrary */ "./node_modules/fast-check/lib/check/arbitrary/ObjectArbitrary.js");
Object.defineProperty(exports, "anything", ({ enumerable: true, get: function () { return ObjectArbitrary_1.anything; } }));
Object.defineProperty(exports, "json", ({ enumerable: true, get: function () { return ObjectArbitrary_1.json; } }));
Object.defineProperty(exports, "jsonObject", ({ enumerable: true, get: function () { return ObjectArbitrary_1.jsonObject; } }));
Object.defineProperty(exports, "object", ({ enumerable: true, get: function () { return ObjectArbitrary_1.object; } }));
Object.defineProperty(exports, "unicodeJson", ({ enumerable: true, get: function () { return ObjectArbitrary_1.unicodeJson; } }));
Object.defineProperty(exports, "unicodeJsonObject", ({ enumerable: true, get: function () { return ObjectArbitrary_1.unicodeJsonObject; } }));
const oneof_1 = __webpack_require__(/*! ./arbitrary/oneof */ "./node_modules/fast-check/lib/arbitrary/oneof.js");
Object.defineProperty(exports, "oneof", ({ enumerable: true, get: function () { return oneof_1.oneof; } }));
const option_1 = __webpack_require__(/*! ./arbitrary/option */ "./node_modules/fast-check/lib/arbitrary/option.js");
Object.defineProperty(exports, "option", ({ enumerable: true, get: function () { return option_1.option; } }));
const record_1 = __webpack_require__(/*! ./arbitrary/record */ "./node_modules/fast-check/lib/arbitrary/record.js");
Object.defineProperty(exports, "record", ({ enumerable: true, get: function () { return record_1.record; } }));
const set_1 = __webpack_require__(/*! ./arbitrary/set */ "./node_modules/fast-check/lib/arbitrary/set.js");
Object.defineProperty(exports, "set", ({ enumerable: true, get: function () { return set_1.set; } }));
const infiniteStream_1 = __webpack_require__(/*! ./arbitrary/infiniteStream */ "./node_modules/fast-check/lib/arbitrary/infiniteStream.js");
Object.defineProperty(exports, "infiniteStream", ({ enumerable: true, get: function () { return infiniteStream_1.infiniteStream; } }));
const asciiString_1 = __webpack_require__(/*! ./arbitrary/asciiString */ "./node_modules/fast-check/lib/arbitrary/asciiString.js");
Object.defineProperty(exports, "asciiString", ({ enumerable: true, get: function () { return asciiString_1.asciiString; } }));
const base64String_1 = __webpack_require__(/*! ./arbitrary/base64String */ "./node_modules/fast-check/lib/arbitrary/base64String.js");
Object.defineProperty(exports, "base64String", ({ enumerable: true, get: function () { return base64String_1.base64String; } }));
const fullUnicodeString_1 = __webpack_require__(/*! ./arbitrary/fullUnicodeString */ "./node_modules/fast-check/lib/arbitrary/fullUnicodeString.js");
Object.defineProperty(exports, "fullUnicodeString", ({ enumerable: true, get: function () { return fullUnicodeString_1.fullUnicodeString; } }));
const hexaString_1 = __webpack_require__(/*! ./arbitrary/hexaString */ "./node_modules/fast-check/lib/arbitrary/hexaString.js");
Object.defineProperty(exports, "hexaString", ({ enumerable: true, get: function () { return hexaString_1.hexaString; } }));
const string_1 = __webpack_require__(/*! ./arbitrary/string */ "./node_modules/fast-check/lib/arbitrary/string.js");
Object.defineProperty(exports, "string", ({ enumerable: true, get: function () { return string_1.string; } }));
const string16bits_1 = __webpack_require__(/*! ./arbitrary/string16bits */ "./node_modules/fast-check/lib/arbitrary/string16bits.js");
Object.defineProperty(exports, "string16bits", ({ enumerable: true, get: function () { return string16bits_1.string16bits; } }));
const stringOf_1 = __webpack_require__(/*! ./arbitrary/stringOf */ "./node_modules/fast-check/lib/arbitrary/stringOf.js");
Object.defineProperty(exports, "stringOf", ({ enumerable: true, get: function () { return stringOf_1.stringOf; } }));
const unicodeString_1 = __webpack_require__(/*! ./arbitrary/unicodeString */ "./node_modules/fast-check/lib/arbitrary/unicodeString.js");
Object.defineProperty(exports, "unicodeString", ({ enumerable: true, get: function () { return unicodeString_1.unicodeString; } }));
const SubarrayArbitrary_1 = __webpack_require__(/*! ./check/arbitrary/SubarrayArbitrary */ "./node_modules/fast-check/lib/check/arbitrary/SubarrayArbitrary.js");
Object.defineProperty(exports, "shuffledSubarray", ({ enumerable: true, get: function () { return SubarrayArbitrary_1.shuffledSubarray; } }));
Object.defineProperty(exports, "subarray", ({ enumerable: true, get: function () { return SubarrayArbitrary_1.subarray; } }));
const genericTuple_1 = __webpack_require__(/*! ./arbitrary/genericTuple */ "./node_modules/fast-check/lib/arbitrary/genericTuple.js");
Object.defineProperty(exports, "genericTuple", ({ enumerable: true, get: function () { return genericTuple_1.genericTuple; } }));
const tuple_1 = __webpack_require__(/*! ./arbitrary/tuple */ "./node_modules/fast-check/lib/arbitrary/tuple.js");
Object.defineProperty(exports, "tuple", ({ enumerable: true, get: function () { return tuple_1.tuple; } }));
const UuidArbitrary_1 = __webpack_require__(/*! ./check/arbitrary/UuidArbitrary */ "./node_modules/fast-check/lib/check/arbitrary/UuidArbitrary.js");
Object.defineProperty(exports, "uuid", ({ enumerable: true, get: function () { return UuidArbitrary_1.uuid; } }));
Object.defineProperty(exports, "uuidV", ({ enumerable: true, get: function () { return UuidArbitrary_1.uuidV; } }));
const WebArbitrary_1 = __webpack_require__(/*! ./check/arbitrary/WebArbitrary */ "./node_modules/fast-check/lib/check/arbitrary/WebArbitrary.js");
Object.defineProperty(exports, "webAuthority", ({ enumerable: true, get: function () { return WebArbitrary_1.webAuthority; } }));
Object.defineProperty(exports, "webFragments", ({ enumerable: true, get: function () { return WebArbitrary_1.webFragments; } }));
Object.defineProperty(exports, "webQueryParameters", ({ enumerable: true, get: function () { return WebArbitrary_1.webQueryParameters; } }));
Object.defineProperty(exports, "webSegment", ({ enumerable: true, get: function () { return WebArbitrary_1.webSegment; } }));
Object.defineProperty(exports, "webUrl", ({ enumerable: true, get: function () { return WebArbitrary_1.webUrl; } }));
const CommandsArbitrary_1 = __webpack_require__(/*! ./check/model/commands/CommandsArbitrary */ "./node_modules/fast-check/lib/check/model/commands/CommandsArbitrary.js");
Object.defineProperty(exports, "commands", ({ enumerable: true, get: function () { return CommandsArbitrary_1.commands; } }));
const ModelRunner_1 = __webpack_require__(/*! ./check/model/ModelRunner */ "./node_modules/fast-check/lib/check/model/ModelRunner.js");
Object.defineProperty(exports, "asyncModelRun", ({ enumerable: true, get: function () { return ModelRunner_1.asyncModelRun; } }));
Object.defineProperty(exports, "modelRun", ({ enumerable: true, get: function () { return ModelRunner_1.modelRun; } }));
Object.defineProperty(exports, "scheduledModelRun", ({ enumerable: true, get: function () { return ModelRunner_1.scheduledModelRun; } }));
const Random_1 = __webpack_require__(/*! ./random/generator/Random */ "./node_modules/fast-check/lib/random/generator/Random.js");
Object.defineProperty(exports, "Random", ({ enumerable: true, get: function () { return Random_1.Random; } }));
const GlobalParameters_1 = __webpack_require__(/*! ./check/runner/configuration/GlobalParameters */ "./node_modules/fast-check/lib/check/runner/configuration/GlobalParameters.js");
Object.defineProperty(exports, "configureGlobal", ({ enumerable: true, get: function () { return GlobalParameters_1.configureGlobal; } }));
Object.defineProperty(exports, "readConfigureGlobal", ({ enumerable: true, get: function () { return GlobalParameters_1.readConfigureGlobal; } }));
Object.defineProperty(exports, "resetConfigureGlobal", ({ enumerable: true, get: function () { return GlobalParameters_1.resetConfigureGlobal; } }));
const VerbosityLevel_1 = __webpack_require__(/*! ./check/runner/configuration/VerbosityLevel */ "./node_modules/fast-check/lib/check/runner/configuration/VerbosityLevel.js");
Object.defineProperty(exports, "VerbosityLevel", ({ enumerable: true, get: function () { return VerbosityLevel_1.VerbosityLevel; } }));
const ExecutionStatus_1 = __webpack_require__(/*! ./check/runner/reporter/ExecutionStatus */ "./node_modules/fast-check/lib/check/runner/reporter/ExecutionStatus.js");
Object.defineProperty(exports, "ExecutionStatus", ({ enumerable: true, get: function () { return ExecutionStatus_1.ExecutionStatus; } }));
const symbols_1 = __webpack_require__(/*! ./check/symbols */ "./node_modules/fast-check/lib/check/symbols.js");
Object.defineProperty(exports, "cloneMethod", ({ enumerable: true, get: function () { return symbols_1.cloneMethod; } }));
Object.defineProperty(exports, "cloneIfNeeded", ({ enumerable: true, get: function () { return symbols_1.cloneIfNeeded; } }));
Object.defineProperty(exports, "hasCloneMethod", ({ enumerable: true, get: function () { return symbols_1.hasCloneMethod; } }));
const Stream_1 = __webpack_require__(/*! ./stream/Stream */ "./node_modules/fast-check/lib/stream/Stream.js");
Object.defineProperty(exports, "Stream", ({ enumerable: true, get: function () { return Stream_1.Stream; } }));
Object.defineProperty(exports, "stream", ({ enumerable: true, get: function () { return Stream_1.stream; } }));
const hash_1 = __webpack_require__(/*! ./utils/hash */ "./node_modules/fast-check/lib/utils/hash.js");
Object.defineProperty(exports, "hash", ({ enumerable: true, get: function () { return hash_1.hash; } }));
const stringify_1 = __webpack_require__(/*! ./utils/stringify */ "./node_modules/fast-check/lib/utils/stringify.js");
Object.defineProperty(exports, "stringify", ({ enumerable: true, get: function () { return stringify_1.stringify; } }));
Object.defineProperty(exports, "asyncStringify", ({ enumerable: true, get: function () { return stringify_1.asyncStringify; } }));
Object.defineProperty(exports, "toStringMethod", ({ enumerable: true, get: function () { return stringify_1.toStringMethod; } }));
Object.defineProperty(exports, "hasToStringMethod", ({ enumerable: true, get: function () { return stringify_1.hasToStringMethod; } }));
Object.defineProperty(exports, "asyncToStringMethod", ({ enumerable: true, get: function () { return stringify_1.asyncToStringMethod; } }));
Object.defineProperty(exports, "hasAsyncToStringMethod", ({ enumerable: true, get: function () { return stringify_1.hasAsyncToStringMethod; } }));
const scheduler_1 = __webpack_require__(/*! ./arbitrary/scheduler */ "./node_modules/fast-check/lib/arbitrary/scheduler.js");
Object.defineProperty(exports, "scheduler", ({ enumerable: true, get: function () { return scheduler_1.scheduler; } }));
Object.defineProperty(exports, "schedulerFor", ({ enumerable: true, get: function () { return scheduler_1.schedulerFor; } }));
const RunDetailsFormatter_1 = __webpack_require__(/*! ./check/runner/utils/RunDetailsFormatter */ "./node_modules/fast-check/lib/check/runner/utils/RunDetailsFormatter.js");
Object.defineProperty(exports, "defaultReportMessage", ({ enumerable: true, get: function () { return RunDetailsFormatter_1.defaultReportMessage; } }));
Object.defineProperty(exports, "asyncDefaultReportMessage", ({ enumerable: true, get: function () { return RunDetailsFormatter_1.asyncDefaultReportMessage; } }));
const ArbitraryWithShrink_1 = __webpack_require__(/*! ./check/arbitrary/definition/ArbitraryWithShrink */ "./node_modules/fast-check/lib/check/arbitrary/definition/ArbitraryWithShrink.js");
Object.defineProperty(exports, "ArbitraryWithShrink", ({ enumerable: true, get: function () { return ArbitraryWithShrink_1.ArbitraryWithShrink; } }));
const ArbitraryWithContextualShrink_1 = __webpack_require__(/*! ./check/arbitrary/definition/ArbitraryWithContextualShrink */ "./node_modules/fast-check/lib/check/arbitrary/definition/ArbitraryWithContextualShrink.js");
Object.defineProperty(exports, "ArbitraryWithContextualShrink", ({ enumerable: true, get: function () { return ArbitraryWithContextualShrink_1.ArbitraryWithContextualShrink; } }));
const PreconditionFailure_1 = __webpack_require__(/*! ./check/precondition/PreconditionFailure */ "./node_modules/fast-check/lib/check/precondition/PreconditionFailure.js");
Object.defineProperty(exports, "PreconditionFailure", ({ enumerable: true, get: function () { return PreconditionFailure_1.PreconditionFailure; } }));
const int8Array_1 = __webpack_require__(/*! ./arbitrary/int8Array */ "./node_modules/fast-check/lib/arbitrary/int8Array.js");
Object.defineProperty(exports, "int8Array", ({ enumerable: true, get: function () { return int8Array_1.int8Array; } }));
const int16Array_1 = __webpack_require__(/*! ./arbitrary/int16Array */ "./node_modules/fast-check/lib/arbitrary/int16Array.js");
Object.defineProperty(exports, "int16Array", ({ enumerable: true, get: function () { return int16Array_1.int16Array; } }));
const int32Array_1 = __webpack_require__(/*! ./arbitrary/int32Array */ "./node_modules/fast-check/lib/arbitrary/int32Array.js");
Object.defineProperty(exports, "int32Array", ({ enumerable: true, get: function () { return int32Array_1.int32Array; } }));
const uint8Array_1 = __webpack_require__(/*! ./arbitrary/uint8Array */ "./node_modules/fast-check/lib/arbitrary/uint8Array.js");
Object.defineProperty(exports, "uint8Array", ({ enumerable: true, get: function () { return uint8Array_1.uint8Array; } }));
const uint8ClampedArray_1 = __webpack_require__(/*! ./arbitrary/uint8ClampedArray */ "./node_modules/fast-check/lib/arbitrary/uint8ClampedArray.js");
Object.defineProperty(exports, "uint8ClampedArray", ({ enumerable: true, get: function () { return uint8ClampedArray_1.uint8ClampedArray; } }));
const uint16Array_1 = __webpack_require__(/*! ./arbitrary/uint16Array */ "./node_modules/fast-check/lib/arbitrary/uint16Array.js");
Object.defineProperty(exports, "uint16Array", ({ enumerable: true, get: function () { return uint16Array_1.uint16Array; } }));
const uint32Array_1 = __webpack_require__(/*! ./arbitrary/uint32Array */ "./node_modules/fast-check/lib/arbitrary/uint32Array.js");
Object.defineProperty(exports, "uint32Array", ({ enumerable: true, get: function () { return uint32Array_1.uint32Array; } }));
const float32Array_1 = __webpack_require__(/*! ./arbitrary/float32Array */ "./node_modules/fast-check/lib/arbitrary/float32Array.js");
Object.defineProperty(exports, "float32Array", ({ enumerable: true, get: function () { return float32Array_1.float32Array; } }));
const float64Array_1 = __webpack_require__(/*! ./arbitrary/float64Array */ "./node_modules/fast-check/lib/arbitrary/float64Array.js");
Object.defineProperty(exports, "float64Array", ({ enumerable: true, get: function () { return float64Array_1.float64Array; } }));
const SparseArrayArbitrary_1 = __webpack_require__(/*! ./check/arbitrary/SparseArrayArbitrary */ "./node_modules/fast-check/lib/check/arbitrary/SparseArrayArbitrary.js");
Object.defineProperty(exports, "sparseArray", ({ enumerable: true, get: function () { return SparseArrayArbitrary_1.sparseArray; } }));
const NextArbitrary_1 = __webpack_require__(/*! ./check/arbitrary/definition/NextArbitrary */ "./node_modules/fast-check/lib/check/arbitrary/definition/NextArbitrary.js");
Object.defineProperty(exports, "NextArbitrary", ({ enumerable: true, get: function () { return NextArbitrary_1.NextArbitrary; } }));
const NextValue_1 = __webpack_require__(/*! ./check/arbitrary/definition/NextValue */ "./node_modules/fast-check/lib/check/arbitrary/definition/NextValue.js");
Object.defineProperty(exports, "NextValue", ({ enumerable: true, get: function () { return NextValue_1.NextValue; } }));
const Converters_1 = __webpack_require__(/*! ./check/arbitrary/definition/Converters */ "./node_modules/fast-check/lib/check/arbitrary/definition/Converters.js");
Object.defineProperty(exports, "convertFromNext", ({ enumerable: true, get: function () { return Converters_1.convertFromNext; } }));
Object.defineProperty(exports, "convertFromNextWithShrunkOnce", ({ enumerable: true, get: function () { return Converters_1.convertFromNextWithShrunkOnce; } }));
Object.defineProperty(exports, "convertToNext", ({ enumerable: true, get: function () { return Converters_1.convertToNext; } }));
const __type = 'commonjs';
exports.__type = __type;
const __version = '2.17.0';
exports.__version = __version;
const __commitHash = 'b7064a21412eb9e68edb3aece74d45522c80bc77';
exports.__commitHash = __commitHash;


/***/ }),

/***/ "./node_modules/fast-check/lib/fast-check.js":
/*!***************************************************!*\
  !*** ./node_modules/fast-check/lib/fast-check.js ***!
  \***************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const fc = __webpack_require__(/*! ./fast-check-default */ "./node_modules/fast-check/lib/fast-check-default.js");
exports.default = fc;
__exportStar(__webpack_require__(/*! ./fast-check-default */ "./node_modules/fast-check/lib/fast-check-default.js"), exports);


/***/ }),

/***/ "./node_modules/fast-check/lib/random/generator/PureRandom.js":
/*!********************************************************************!*\
  !*** ./node_modules/fast-check/lib/random/generator/PureRandom.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.convertToRandomGenerator = void 0;
class ConvertedRandomGenerator {
    constructor(rng) {
        this.rng = rng;
        if (typeof this.rng.jump === 'function') {
            this.jump = function jump() {
                const out = this.jump();
                return new ConvertedRandomGenerator(out);
            };
            this.unsafeJump = function unsafeJump() {
                const out = this.jump();
                this.rng = out;
            };
        }
    }
    min() {
        return this.rng.min();
    }
    max() {
        return this.rng.max();
    }
    clone() {
        return new ConvertedRandomGenerator(this.rng);
    }
    next() {
        const out = this.rng.next();
        return [out[0], new ConvertedRandomGenerator(out[1])];
    }
    unsafeNext() {
        const out = this.rng.next();
        this.rng = out[1];
        return out[0];
    }
}
function convertToRandomGenerator(rng) {
    if ('clone' in rng && 'unsafeNext' in rng) {
        return rng;
    }
    return new ConvertedRandomGenerator(rng);
}
exports.convertToRandomGenerator = convertToRandomGenerator;


/***/ }),

/***/ "./node_modules/fast-check/lib/random/generator/Random.js":
/*!****************************************************************!*\
  !*** ./node_modules/fast-check/lib/random/generator/Random.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Random = void 0;
const pure_rand_1 = __webpack_require__(/*! pure-rand */ "./node_modules/pure-rand/lib/pure-rand.js");
const PureRandom_1 = __webpack_require__(/*! ./PureRandom */ "./node_modules/fast-check/lib/random/generator/PureRandom.js");
class Random {
    constructor(sourceRng) {
        this.internalRng = PureRandom_1.convertToRandomGenerator(sourceRng).clone();
    }
    clone() {
        return new Random(this.internalRng);
    }
    next(bits) {
        return pure_rand_1.unsafeUniformIntDistribution(0, (1 << bits) - 1, this.internalRng);
    }
    nextBoolean() {
        return pure_rand_1.unsafeUniformIntDistribution(0, 1, this.internalRng) == 1;
    }
    nextInt(min, max) {
        return pure_rand_1.unsafeUniformIntDistribution(min == null ? Random.MIN_INT : min, max == null ? Random.MAX_INT : max, this.internalRng);
    }
    nextBigInt(min, max) {
        return pure_rand_1.unsafeUniformBigIntDistribution(min, max, this.internalRng);
    }
    nextArrayInt(min, max) {
        return pure_rand_1.unsafeUniformArrayIntDistribution(min, max, this.internalRng);
    }
    nextDouble() {
        const a = this.next(26);
        const b = this.next(27);
        return (a * Random.DBL_FACTOR + b) * Random.DBL_DIVISOR;
    }
}
exports.Random = Random;
Random.MIN_INT = 0x80000000 | 0;
Random.MAX_INT = 0x7fffffff | 0;
Random.DBL_FACTOR = Math.pow(2, 27);
Random.DBL_DIVISOR = Math.pow(2, -53);


/***/ }),

/***/ "./node_modules/fast-check/lib/stream/LazyIterableIterator.js":
/*!********************************************************************!*\
  !*** ./node_modules/fast-check/lib/stream/LazyIterableIterator.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.makeLazy = void 0;
class LazyIterableIterator {
    constructor(producer) {
        this.producer = producer;
    }
    [Symbol.iterator]() {
        if (this.it === undefined) {
            this.it = this.producer();
        }
        return this.it;
    }
    next() {
        if (this.it === undefined) {
            this.it = this.producer();
        }
        return this.it.next();
    }
}
function makeLazy(producer) {
    return new LazyIterableIterator(producer);
}
exports.makeLazy = makeLazy;


/***/ }),

/***/ "./node_modules/fast-check/lib/stream/Stream.js":
/*!******************************************************!*\
  !*** ./node_modules/fast-check/lib/stream/Stream.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.stream = exports.Stream = void 0;
const StreamHelpers_1 = __webpack_require__(/*! ./StreamHelpers */ "./node_modules/fast-check/lib/stream/StreamHelpers.js");
class Stream {
    constructor(g) {
        this.g = g;
    }
    static nil() {
        return new Stream(StreamHelpers_1.nilHelper());
    }
    static of(...elements) {
        return new Stream(elements[Symbol.iterator]());
    }
    next() {
        return this.g.next();
    }
    [Symbol.iterator]() {
        return this.g;
    }
    map(f) {
        return new Stream(StreamHelpers_1.mapHelper(this.g, f));
    }
    flatMap(f) {
        return new Stream(StreamHelpers_1.flatMapHelper(this.g, f));
    }
    dropWhile(f) {
        let foundEligible = false;
        function* helper(v) {
            if (foundEligible || !f(v)) {
                foundEligible = true;
                yield v;
            }
        }
        return this.flatMap(helper);
    }
    drop(n) {
        let idx = 0;
        function helper() {
            return idx++ < n;
        }
        return this.dropWhile(helper);
    }
    takeWhile(f) {
        return new Stream(StreamHelpers_1.takeWhileHelper(this.g, f));
    }
    take(n) {
        return new Stream(StreamHelpers_1.takeNHelper(this.g, n));
    }
    filter(f) {
        return new Stream(StreamHelpers_1.filterHelper(this.g, f));
    }
    every(f) {
        for (const v of this.g) {
            if (!f(v)) {
                return false;
            }
        }
        return true;
    }
    has(f) {
        for (const v of this.g) {
            if (f(v)) {
                return [true, v];
            }
        }
        return [false, null];
    }
    join(...others) {
        return new Stream(StreamHelpers_1.joinHelper(this.g, others));
    }
    getNthOrLast(nth) {
        let remaining = nth;
        let last = null;
        for (const v of this.g) {
            if (remaining-- === 0)
                return v;
            last = v;
        }
        return last;
    }
}
exports.Stream = Stream;
function stream(g) {
    return new Stream(g);
}
exports.stream = stream;


/***/ }),

/***/ "./node_modules/fast-check/lib/stream/StreamHelpers.js":
/*!*************************************************************!*\
  !*** ./node_modules/fast-check/lib/stream/StreamHelpers.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.joinHelper = exports.takeWhileHelper = exports.takeNHelper = exports.filterHelper = exports.flatMapHelper = exports.mapHelper = exports.nilHelper = void 0;
class Nil {
    [Symbol.iterator]() {
        return this;
    }
    next(value) {
        return { value, done: true };
    }
}
Nil.nil = new Nil();
function nilHelper() {
    return Nil.nil;
}
exports.nilHelper = nilHelper;
function* mapHelper(g, f) {
    for (const v of g) {
        yield f(v);
    }
}
exports.mapHelper = mapHelper;
function* flatMapHelper(g, f) {
    for (const v of g) {
        yield* f(v);
    }
}
exports.flatMapHelper = flatMapHelper;
function* filterHelper(g, f) {
    for (const v of g) {
        if (f(v)) {
            yield v;
        }
    }
}
exports.filterHelper = filterHelper;
function* takeNHelper(g, n) {
    for (let i = 0; i < n; ++i) {
        const cur = g.next();
        if (cur.done) {
            break;
        }
        yield cur.value;
    }
}
exports.takeNHelper = takeNHelper;
function* takeWhileHelper(g, f) {
    let cur = g.next();
    while (!cur.done && f(cur.value)) {
        yield cur.value;
        cur = g.next();
    }
}
exports.takeWhileHelper = takeWhileHelper;
function* joinHelper(g, others) {
    for (let cur = g.next(); !cur.done; cur = g.next()) {
        yield cur.value;
    }
    for (const s of others) {
        for (let cur = s.next(); !cur.done; cur = s.next()) {
            yield cur.value;
        }
    }
}
exports.joinHelper = joinHelper;


/***/ }),

/***/ "./node_modules/fast-check/lib/utils/hash.js":
/*!***************************************************!*\
  !*** ./node_modules/fast-check/lib/utils/hash.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.hash = void 0;
const crc32Table = [
    0x00000000, 0x77073096, 0xee0e612c, 0x990951ba, 0x076dc419, 0x706af48f, 0xe963a535, 0x9e6495a3, 0x0edb8832,
    0x79dcb8a4, 0xe0d5e91e, 0x97d2d988, 0x09b64c2b, 0x7eb17cbd, 0xe7b82d07, 0x90bf1d91, 0x1db71064, 0x6ab020f2,
    0xf3b97148, 0x84be41de, 0x1adad47d, 0x6ddde4eb, 0xf4d4b551, 0x83d385c7, 0x136c9856, 0x646ba8c0, 0xfd62f97a,
    0x8a65c9ec, 0x14015c4f, 0x63066cd9, 0xfa0f3d63, 0x8d080df5, 0x3b6e20c8, 0x4c69105e, 0xd56041e4, 0xa2677172,
    0x3c03e4d1, 0x4b04d447, 0xd20d85fd, 0xa50ab56b, 0x35b5a8fa, 0x42b2986c, 0xdbbbc9d6, 0xacbcf940, 0x32d86ce3,
    0x45df5c75, 0xdcd60dcf, 0xabd13d59, 0x26d930ac, 0x51de003a, 0xc8d75180, 0xbfd06116, 0x21b4f4b5, 0x56b3c423,
    0xcfba9599, 0xb8bda50f, 0x2802b89e, 0x5f058808, 0xc60cd9b2, 0xb10be924, 0x2f6f7c87, 0x58684c11, 0xc1611dab,
    0xb6662d3d, 0x76dc4190, 0x01db7106, 0x98d220bc, 0xefd5102a, 0x71b18589, 0x06b6b51f, 0x9fbfe4a5, 0xe8b8d433,
    0x7807c9a2, 0x0f00f934, 0x9609a88e, 0xe10e9818, 0x7f6a0dbb, 0x086d3d2d, 0x91646c97, 0xe6635c01, 0x6b6b51f4,
    0x1c6c6162, 0x856530d8, 0xf262004e, 0x6c0695ed, 0x1b01a57b, 0x8208f4c1, 0xf50fc457, 0x65b0d9c6, 0x12b7e950,
    0x8bbeb8ea, 0xfcb9887c, 0x62dd1ddf, 0x15da2d49, 0x8cd37cf3, 0xfbd44c65, 0x4db26158, 0x3ab551ce, 0xa3bc0074,
    0xd4bb30e2, 0x4adfa541, 0x3dd895d7, 0xa4d1c46d, 0xd3d6f4fb, 0x4369e96a, 0x346ed9fc, 0xad678846, 0xda60b8d0,
    0x44042d73, 0x33031de5, 0xaa0a4c5f, 0xdd0d7cc9, 0x5005713c, 0x270241aa, 0xbe0b1010, 0xc90c2086, 0x5768b525,
    0x206f85b3, 0xb966d409, 0xce61e49f, 0x5edef90e, 0x29d9c998, 0xb0d09822, 0xc7d7a8b4, 0x59b33d17, 0x2eb40d81,
    0xb7bd5c3b, 0xc0ba6cad, 0xedb88320, 0x9abfb3b6, 0x03b6e20c, 0x74b1d29a, 0xead54739, 0x9dd277af, 0x04db2615,
    0x73dc1683, 0xe3630b12, 0x94643b84, 0x0d6d6a3e, 0x7a6a5aa8, 0xe40ecf0b, 0x9309ff9d, 0x0a00ae27, 0x7d079eb1,
    0xf00f9344, 0x8708a3d2, 0x1e01f268, 0x6906c2fe, 0xf762575d, 0x806567cb, 0x196c3671, 0x6e6b06e7, 0xfed41b76,
    0x89d32be0, 0x10da7a5a, 0x67dd4acc, 0xf9b9df6f, 0x8ebeeff9, 0x17b7be43, 0x60b08ed5, 0xd6d6a3e8, 0xa1d1937e,
    0x38d8c2c4, 0x4fdff252, 0xd1bb67f1, 0xa6bc5767, 0x3fb506dd, 0x48b2364b, 0xd80d2bda, 0xaf0a1b4c, 0x36034af6,
    0x41047a60, 0xdf60efc3, 0xa867df55, 0x316e8eef, 0x4669be79, 0xcb61b38c, 0xbc66831a, 0x256fd2a0, 0x5268e236,
    0xcc0c7795, 0xbb0b4703, 0x220216b9, 0x5505262f, 0xc5ba3bbe, 0xb2bd0b28, 0x2bb45a92, 0x5cb36a04, 0xc2d7ffa7,
    0xb5d0cf31, 0x2cd99e8b, 0x5bdeae1d, 0x9b64c2b0, 0xec63f226, 0x756aa39c, 0x026d930a, 0x9c0906a9, 0xeb0e363f,
    0x72076785, 0x05005713, 0x95bf4a82, 0xe2b87a14, 0x7bb12bae, 0x0cb61b38, 0x92d28e9b, 0xe5d5be0d, 0x7cdcefb7,
    0x0bdbdf21, 0x86d3d2d4, 0xf1d4e242, 0x68ddb3f8, 0x1fda836e, 0x81be16cd, 0xf6b9265b, 0x6fb077e1, 0x18b74777,
    0x88085ae6, 0xff0f6a70, 0x66063bca, 0x11010b5c, 0x8f659eff, 0xf862ae69, 0x616bffd3, 0x166ccf45, 0xa00ae278,
    0xd70dd2ee, 0x4e048354, 0x3903b3c2, 0xa7672661, 0xd06016f7, 0x4969474d, 0x3e6e77db, 0xaed16a4a, 0xd9d65adc,
    0x40df0b66, 0x37d83bf0, 0xa9bcae53, 0xdebb9ec5, 0x47b2cf7f, 0x30b5ffe9, 0xbdbdf21c, 0xcabac28a, 0x53b39330,
    0x24b4a3a6, 0xbad03605, 0xcdd70693, 0x54de5729, 0x23d967bf, 0xb3667a2e, 0xc4614ab8, 0x5d681b02, 0x2a6f2b94,
    0xb40bbe37, 0xc30c8ea1, 0x5a05df1b, 0x2d02ef8d,
];
function hash(repr) {
    let crc = 0xffffffff;
    for (let idx = 0; idx < repr.length; ++idx) {
        const c = repr.charCodeAt(idx);
        if (c < 0x80) {
            crc = crc32Table[(crc & 0xff) ^ c] ^ (crc >> 8);
        }
        else if (c < 0x800) {
            crc = crc32Table[(crc & 0xff) ^ (192 | ((c >> 6) & 31))] ^ (crc >> 8);
            crc = crc32Table[(crc & 0xff) ^ (128 | (c & 63))] ^ (crc >> 8);
        }
        else if (c >= 0xd800 && c < 0xe000) {
            const cNext = repr.charCodeAt(++idx);
            if (c >= 0xdc00 || cNext < 0xdc00 || cNext > 0xdfff || Number.isNaN(cNext)) {
                idx -= 1;
                crc = crc32Table[(crc & 0xff) ^ 0xef] ^ (crc >> 8);
                crc = crc32Table[(crc & 0xff) ^ 0xbf] ^ (crc >> 8);
                crc = crc32Table[(crc & 0xff) ^ 0xbd] ^ (crc >> 8);
            }
            else {
                const c1 = (c & 1023) + 64;
                const c2 = cNext & 1023;
                crc = crc32Table[(crc & 0xff) ^ (240 | ((c1 >> 8) & 7))] ^ (crc >> 8);
                crc = crc32Table[(crc & 0xff) ^ (128 | ((c1 >> 2) & 63))] ^ (crc >> 8);
                crc = crc32Table[(crc & 0xff) ^ (128 | ((c2 >> 6) & 15) | ((c1 & 3) << 4))] ^ (crc >> 8);
                crc = crc32Table[(crc & 0xff) ^ (128 | (c2 & 63))] ^ (crc >> 8);
            }
        }
        else {
            crc = crc32Table[(crc & 0xff) ^ (224 | ((c >> 12) & 15))] ^ (crc >> 8);
            crc = crc32Table[(crc & 0xff) ^ (128 | ((c >> 6) & 63))] ^ (crc >> 8);
            crc = crc32Table[(crc & 0xff) ^ (128 | (c & 63))] ^ (crc >> 8);
        }
    }
    return (crc | 0) + 0x80000000;
}
exports.hash = hash;


/***/ }),

/***/ "./node_modules/fast-check/lib/utils/stringify.js":
/*!********************************************************!*\
  !*** ./node_modules/fast-check/lib/utils/stringify.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.asyncStringify = exports.possiblyAsyncStringify = exports.stringify = exports.stringifyInternal = exports.hasAsyncToStringMethod = exports.asyncToStringMethod = exports.hasToStringMethod = exports.toStringMethod = void 0;
exports.toStringMethod = Symbol('fast-check/toStringMethod');
function hasToStringMethod(instance) {
    return (instance !== null &&
        (typeof instance === 'object' || typeof instance === 'function') &&
        exports.toStringMethod in instance &&
        typeof instance[exports.toStringMethod] === 'function');
}
exports.hasToStringMethod = hasToStringMethod;
exports.asyncToStringMethod = Symbol('fast-check/asyncToStringMethod');
function hasAsyncToStringMethod(instance) {
    return (instance !== null &&
        (typeof instance === 'object' || typeof instance === 'function') &&
        exports.asyncToStringMethod in instance &&
        typeof instance[exports.asyncToStringMethod] === 'function');
}
exports.hasAsyncToStringMethod = hasAsyncToStringMethod;
const findSymbolNameRegex = /^Symbol\((.*)\)$/;
function getSymbolDescription(s) {
    if (s.description !== undefined)
        return s.description;
    const m = findSymbolNameRegex.exec(String(s));
    return m && m[1].length ? m[1] : null;
}
function stringifyNumber(numValue) {
    switch (numValue) {
        case 0:
            return 1 / numValue === Number.NEGATIVE_INFINITY ? '-0' : '0';
        case Number.NEGATIVE_INFINITY:
            return 'Number.NEGATIVE_INFINITY';
        case Number.POSITIVE_INFINITY:
            return 'Number.POSITIVE_INFINITY';
        default:
            return numValue === numValue ? String(numValue) : 'Number.NaN';
    }
}
function isSparseArray(arr) {
    let previousNumberedIndex = -1;
    for (const index in arr) {
        const numberedIndex = Number(index);
        if (numberedIndex !== previousNumberedIndex + 1)
            return true;
        previousNumberedIndex = numberedIndex;
    }
    return previousNumberedIndex + 1 !== arr.length;
}
function stringifyInternal(value, previousValues, getAsyncContent) {
    const currentValues = previousValues.concat([value]);
    if (typeof value === 'object') {
        if (previousValues.indexOf(value) !== -1) {
            return '[cyclic]';
        }
    }
    if (hasAsyncToStringMethod(value)) {
        const content = getAsyncContent(value);
        if (content.state === 'fulfilled') {
            return content.value;
        }
    }
    if (hasToStringMethod(value)) {
        try {
            return value[exports.toStringMethod]();
        }
        catch (err) {
        }
    }
    switch (Object.prototype.toString.call(value)) {
        case '[object Array]': {
            const arr = value;
            if (arr.length >= 50 && isSparseArray(arr)) {
                const assignments = [];
                for (const index in arr) {
                    if (!Number.isNaN(Number(index)))
                        assignments.push(`${index}:${stringifyInternal(arr[index], currentValues, getAsyncContent)}`);
                }
                return assignments.length !== 0
                    ? `Object.assign(Array(${arr.length}),{${assignments.join(',')}})`
                    : `Array(${arr.length})`;
            }
            const stringifiedArray = arr.map((v) => stringifyInternal(v, currentValues, getAsyncContent)).join(',');
            return arr.length === 0 || arr.length - 1 in arr ? `[${stringifiedArray}]` : `[${stringifiedArray},]`;
        }
        case '[object BigInt]':
            return `${value}n`;
        case '[object Boolean]':
            return typeof value === 'boolean' ? JSON.stringify(value) : `new Boolean(${JSON.stringify(value)})`;
        case '[object Date]': {
            const d = value;
            return Number.isNaN(d.getTime()) ? `new Date(NaN)` : `new Date(${JSON.stringify(d.toISOString())})`;
        }
        case '[object Map]':
            return `new Map(${stringifyInternal(Array.from(value), currentValues, getAsyncContent)})`;
        case '[object Null]':
            return `null`;
        case '[object Number]':
            return typeof value === 'number' ? stringifyNumber(value) : `new Number(${stringifyNumber(Number(value))})`;
        case '[object Object]': {
            try {
                const toStringAccessor = value.toString;
                if (typeof toStringAccessor === 'function' && toStringAccessor !== Object.prototype.toString) {
                    return value.toString();
                }
            }
            catch (err) {
                return '[object Object]';
            }
            const mapper = (k) => `${k === '__proto__'
                ? '["__proto__"]'
                : typeof k === 'symbol'
                    ? `[${stringifyInternal(k, currentValues, getAsyncContent)}]`
                    : JSON.stringify(k)}:${stringifyInternal(value[k], currentValues, getAsyncContent)}`;
            const stringifiedProperties = [
                ...Object.keys(value).map(mapper),
                ...Object.getOwnPropertySymbols(value)
                    .filter((s) => {
                    const descriptor = Object.getOwnPropertyDescriptor(value, s);
                    return descriptor && descriptor.enumerable;
                })
                    .map(mapper),
            ];
            const rawRepr = '{' + stringifiedProperties.join(',') + '}';
            if (Object.getPrototypeOf(value) === null) {
                return rawRepr === '{}' ? 'Object.create(null)' : `Object.assign(Object.create(null),${rawRepr})`;
            }
            return rawRepr;
        }
        case '[object Set]':
            return `new Set(${stringifyInternal(Array.from(value), currentValues, getAsyncContent)})`;
        case '[object String]':
            return typeof value === 'string' ? JSON.stringify(value) : `new String(${JSON.stringify(value)})`;
        case '[object Symbol]': {
            const s = value;
            if (Symbol.keyFor(s) !== undefined) {
                return `Symbol.for(${JSON.stringify(Symbol.keyFor(s))})`;
            }
            const desc = getSymbolDescription(s);
            if (desc === null) {
                return 'Symbol()';
            }
            const knownSymbol = desc.startsWith('Symbol.') && Symbol[desc.substring(7)];
            return s === knownSymbol ? desc : `Symbol(${JSON.stringify(desc)})`;
        }
        case '[object Promise]': {
            const promiseContent = getAsyncContent(value);
            switch (promiseContent.state) {
                case 'fulfilled':
                    return `Promise.resolve(${stringifyInternal(promiseContent.value, currentValues, getAsyncContent)})`;
                case 'rejected':
                    return `Promise.reject(${stringifyInternal(promiseContent.value, currentValues, getAsyncContent)})`;
                case 'pending':
                    return `new Promise(() => {/*pending*/})`;
                case 'unknown':
                default:
                    return `new Promise(() => {/*unknown*/})`;
            }
        }
        case '[object Error]':
            if (value instanceof Error) {
                return `new Error(${stringifyInternal(value.message, currentValues, getAsyncContent)})`;
            }
            break;
        case '[object Undefined]':
            return `undefined`;
        case '[object Int8Array]':
        case '[object Uint8Array]':
        case '[object Uint8ClampedArray]':
        case '[object Int16Array]':
        case '[object Uint16Array]':
        case '[object Int32Array]':
        case '[object Uint32Array]':
        case '[object Float32Array]':
        case '[object Float64Array]':
        case '[object BigInt64Array]':
        case '[object BigUint64Array]': {
            if (typeof Buffer !== 'undefined' && typeof Buffer.isBuffer === 'function' && Buffer.isBuffer(value)) {
                return `Buffer.from(${stringifyInternal(Array.from(value.values()), currentValues, getAsyncContent)})`;
            }
            const valuePrototype = Object.getPrototypeOf(value);
            const className = valuePrototype && valuePrototype.constructor && valuePrototype.constructor.name;
            if (typeof className === 'string') {
                const typedArray = value;
                const valuesFromTypedArr = typedArray.values();
                return `${className}.from(${stringifyInternal(Array.from(valuesFromTypedArr), currentValues, getAsyncContent)})`;
            }
            break;
        }
    }
    try {
        return value.toString();
    }
    catch (_a) {
        return Object.prototype.toString.call(value);
    }
}
exports.stringifyInternal = stringifyInternal;
function stringify(value) {
    return stringifyInternal(value, [], () => ({ state: 'unknown', value: undefined }));
}
exports.stringify = stringify;
function possiblyAsyncStringify(value) {
    const stillPendingMarker = Symbol();
    const pendingPromisesForCache = [];
    const cache = new Map();
    function createDelay0() {
        let handleId = null;
        const cancel = () => {
            if (handleId !== null) {
                clearTimeout(handleId);
            }
        };
        const delay = new Promise((resolve) => {
            handleId = setTimeout(() => {
                handleId = null;
                resolve(stillPendingMarker);
            }, 0);
        });
        return { delay, cancel };
    }
    const unknownState = { state: 'unknown', value: undefined };
    const getAsyncContent = function getAsyncContent(data) {
        const cacheKey = data;
        if (cache.has(cacheKey)) {
            return cache.get(cacheKey);
        }
        const delay0 = createDelay0();
        const p = exports.asyncToStringMethod in data
            ? Promise.resolve().then(() => data[exports.asyncToStringMethod]())
            : data;
        p.catch(() => { });
        pendingPromisesForCache.push(Promise.race([p, delay0.delay]).then((successValue) => {
            if (successValue === stillPendingMarker)
                cache.set(cacheKey, { state: 'pending', value: undefined });
            else
                cache.set(cacheKey, { state: 'fulfilled', value: successValue });
            delay0.cancel();
        }, (errorValue) => {
            cache.set(cacheKey, { state: 'rejected', value: errorValue });
            delay0.cancel();
        }));
        cache.set(cacheKey, unknownState);
        return unknownState;
    };
    function loop() {
        const stringifiedValue = stringifyInternal(value, [], getAsyncContent);
        if (pendingPromisesForCache.length === 0) {
            return stringifiedValue;
        }
        return Promise.all(pendingPromisesForCache.splice(0)).then(loop);
    }
    return loop();
}
exports.possiblyAsyncStringify = possiblyAsyncStringify;
async function asyncStringify(value) {
    return Promise.resolve(possiblyAsyncStringify(value));
}
exports.asyncStringify = asyncStringify;


/***/ }),

/***/ "./node_modules/pure-rand/lib/distribution/UniformArrayIntDistribution.js":
/*!********************************************************************************!*\
  !*** ./node_modules/pure-rand/lib/distribution/UniformArrayIntDistribution.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

exports.__esModule = true;
exports.uniformArrayIntDistribution = void 0;
var UnsafeUniformArrayIntDistribution_1 = __webpack_require__(/*! ./UnsafeUniformArrayIntDistribution */ "./node_modules/pure-rand/lib/distribution/UnsafeUniformArrayIntDistribution.js");
function uniformArrayIntDistribution(from, to, rng) {
    if (rng != null) {
        var nextRng = rng.clone();
        return [UnsafeUniformArrayIntDistribution_1.unsafeUniformArrayIntDistribution(from, to, nextRng), nextRng];
    }
    return function (rng) {
        var nextRng = rng.clone();
        return [UnsafeUniformArrayIntDistribution_1.unsafeUniformArrayIntDistribution(from, to, nextRng), nextRng];
    };
}
exports.uniformArrayIntDistribution = uniformArrayIntDistribution;


/***/ }),

/***/ "./node_modules/pure-rand/lib/distribution/UniformBigIntDistribution.js":
/*!******************************************************************************!*\
  !*** ./node_modules/pure-rand/lib/distribution/UniformBigIntDistribution.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

exports.__esModule = true;
exports.uniformBigIntDistribution = void 0;
var UnsafeUniformBigIntDistribution_1 = __webpack_require__(/*! ./UnsafeUniformBigIntDistribution */ "./node_modules/pure-rand/lib/distribution/UnsafeUniformBigIntDistribution.js");
function uniformBigIntDistribution(from, to, rng) {
    if (rng != null) {
        var nextRng = rng.clone();
        return [UnsafeUniformBigIntDistribution_1.unsafeUniformBigIntDistribution(from, to, nextRng), nextRng];
    }
    return function (rng) {
        var nextRng = rng.clone();
        return [UnsafeUniformBigIntDistribution_1.unsafeUniformBigIntDistribution(from, to, nextRng), nextRng];
    };
}
exports.uniformBigIntDistribution = uniformBigIntDistribution;


/***/ }),

/***/ "./node_modules/pure-rand/lib/distribution/UniformIntDistribution.js":
/*!***************************************************************************!*\
  !*** ./node_modules/pure-rand/lib/distribution/UniformIntDistribution.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

exports.__esModule = true;
exports.uniformIntDistribution = void 0;
var UnsafeUniformIntDistribution_1 = __webpack_require__(/*! ./UnsafeUniformIntDistribution */ "./node_modules/pure-rand/lib/distribution/UnsafeUniformIntDistribution.js");
function uniformIntDistribution(from, to, rng) {
    if (rng != null) {
        var nextRng = rng.clone();
        return [UnsafeUniformIntDistribution_1.unsafeUniformIntDistribution(from, to, nextRng), nextRng];
    }
    return function (rng) {
        var nextRng = rng.clone();
        return [UnsafeUniformIntDistribution_1.unsafeUniformIntDistribution(from, to, nextRng), nextRng];
    };
}
exports.uniformIntDistribution = uniformIntDistribution;


/***/ }),

/***/ "./node_modules/pure-rand/lib/distribution/UnsafeUniformArrayIntDistribution.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/pure-rand/lib/distribution/UnsafeUniformArrayIntDistribution.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

exports.__esModule = true;
exports.unsafeUniformArrayIntDistribution = void 0;
var ArrayInt_1 = __webpack_require__(/*! ./internals/ArrayInt */ "./node_modules/pure-rand/lib/distribution/internals/ArrayInt.js");
var UnsafeUniformArrayIntDistributionInternal_1 = __webpack_require__(/*! ./internals/UnsafeUniformArrayIntDistributionInternal */ "./node_modules/pure-rand/lib/distribution/internals/UnsafeUniformArrayIntDistributionInternal.js");
function unsafeUniformArrayIntDistribution(from, to, rng) {
    var rangeSize = ArrayInt_1.trimArrayIntInplace(ArrayInt_1.addOneToPositiveArrayInt(ArrayInt_1.substractArrayIntToNew(to, from)));
    var emptyArrayIntData = rangeSize.data.slice(0);
    var g = UnsafeUniformArrayIntDistributionInternal_1.unsafeUniformArrayIntDistributionInternal(emptyArrayIntData, rangeSize.data, rng);
    return ArrayInt_1.trimArrayIntInplace(ArrayInt_1.addArrayIntToNew({ sign: 1, data: g }, from));
}
exports.unsafeUniformArrayIntDistribution = unsafeUniformArrayIntDistribution;


/***/ }),

/***/ "./node_modules/pure-rand/lib/distribution/UnsafeUniformBigIntDistribution.js":
/*!************************************************************************************!*\
  !*** ./node_modules/pure-rand/lib/distribution/UnsafeUniformBigIntDistribution.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

exports.__esModule = true;
exports.unsafeUniformBigIntDistribution = void 0;
function unsafeUniformBigIntDistribution(from, to, rng) {
    var diff = to - from + BigInt(1);
    var MinRng = BigInt(rng.min());
    var NumValues = BigInt(rng.max() - rng.min() + 1);
    var FinalNumValues = NumValues;
    var NumIterations = BigInt(1);
    while (FinalNumValues < diff) {
        FinalNumValues *= NumValues;
        ++NumIterations;
    }
    var MaxAcceptedRandom = FinalNumValues - (FinalNumValues % diff);
    while (true) {
        var value = BigInt(0);
        for (var num = BigInt(0); num !== NumIterations; ++num) {
            var out = rng.unsafeNext();
            value = NumValues * value + (BigInt(out) - MinRng);
        }
        if (value < MaxAcceptedRandom) {
            var inDiff = value % diff;
            return inDiff + from;
        }
    }
}
exports.unsafeUniformBigIntDistribution = unsafeUniformBigIntDistribution;


/***/ }),

/***/ "./node_modules/pure-rand/lib/distribution/UnsafeUniformIntDistribution.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/pure-rand/lib/distribution/UnsafeUniformIntDistribution.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

exports.__esModule = true;
exports.unsafeUniformIntDistribution = void 0;
var UnsafeUniformIntDistributionInternal_1 = __webpack_require__(/*! ./internals/UnsafeUniformIntDistributionInternal */ "./node_modules/pure-rand/lib/distribution/internals/UnsafeUniformIntDistributionInternal.js");
var ArrayInt_1 = __webpack_require__(/*! ./internals/ArrayInt */ "./node_modules/pure-rand/lib/distribution/internals/ArrayInt.js");
var UnsafeUniformArrayIntDistributionInternal_1 = __webpack_require__(/*! ./internals/UnsafeUniformArrayIntDistributionInternal */ "./node_modules/pure-rand/lib/distribution/internals/UnsafeUniformArrayIntDistributionInternal.js");
var sharedA = { sign: 1, data: [0, 0] };
var sharedB = { sign: 1, data: [0, 0] };
var sharedC = { sign: 1, data: [0, 0] };
var sharedData = [0, 0];
function uniformLargeIntInternal(from, to, rangeSize, rng) {
    var rangeSizeArrayIntValue = rangeSize <= Number.MAX_SAFE_INTEGER
        ? ArrayInt_1.fromNumberToArrayInt64(sharedC, rangeSize)
        : ArrayInt_1.substractArrayInt64(sharedC, ArrayInt_1.fromNumberToArrayInt64(sharedA, to), ArrayInt_1.fromNumberToArrayInt64(sharedB, from));
    if (rangeSizeArrayIntValue.data[1] === 0xffffffff) {
        rangeSizeArrayIntValue.data[0] += 1;
        rangeSizeArrayIntValue.data[1] = 0;
    }
    else {
        rangeSizeArrayIntValue.data[1] += 1;
    }
    UnsafeUniformArrayIntDistributionInternal_1.unsafeUniformArrayIntDistributionInternal(sharedData, rangeSizeArrayIntValue.data, rng);
    return sharedData[0] * 0x100000000 + sharedData[1] + from;
}
function unsafeUniformIntDistribution(from, to, rng) {
    var rangeSize = to - from;
    if (rangeSize <= 0xffffffff) {
        var g = UnsafeUniformIntDistributionInternal_1.unsafeUniformIntDistributionInternal(rangeSize + 1, rng);
        return g + from;
    }
    return uniformLargeIntInternal(from, to, rangeSize, rng);
}
exports.unsafeUniformIntDistribution = unsafeUniformIntDistribution;


/***/ }),

/***/ "./node_modules/pure-rand/lib/distribution/internals/ArrayInt.js":
/*!***********************************************************************!*\
  !*** ./node_modules/pure-rand/lib/distribution/internals/ArrayInt.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

exports.__esModule = true;
exports.substractArrayInt64 = exports.fromNumberToArrayInt64 = exports.trimArrayIntInplace = exports.substractArrayIntToNew = exports.addOneToPositiveArrayInt = exports.addArrayIntToNew = void 0;
function addArrayIntToNew(arrayIntA, arrayIntB) {
    if (arrayIntA.sign !== arrayIntB.sign) {
        return substractArrayIntToNew(arrayIntA, { sign: -arrayIntB.sign, data: arrayIntB.data });
    }
    var data = [];
    var reminder = 0;
    var dataA = arrayIntA.data;
    var dataB = arrayIntB.data;
    for (var indexA = dataA.length - 1, indexB = dataB.length - 1; indexA >= 0 || indexB >= 0; --indexA, --indexB) {
        var vA = indexA >= 0 ? dataA[indexA] : 0;
        var vB = indexB >= 0 ? dataB[indexB] : 0;
        var current = vA + vB + reminder;
        data.push(current >>> 0);
        reminder = ~~(current / 0x100000000);
    }
    if (reminder !== 0) {
        data.push(reminder);
    }
    return { sign: arrayIntA.sign, data: data.reverse() };
}
exports.addArrayIntToNew = addArrayIntToNew;
function addOneToPositiveArrayInt(arrayInt) {
    arrayInt.sign = 1;
    var data = arrayInt.data;
    for (var index = data.length - 1; index >= 0; --index) {
        if (data[index] === 0xffffffff) {
            data[index] = 0;
        }
        else {
            data[index] += 1;
            return arrayInt;
        }
    }
    data.unshift(1);
    return arrayInt;
}
exports.addOneToPositiveArrayInt = addOneToPositiveArrayInt;
function isStrictlySmaller(dataA, dataB) {
    var maxLength = Math.max(dataA.length, dataB.length);
    for (var index = 0; index < maxLength; ++index) {
        var indexA = index + dataA.length - maxLength;
        var indexB = index + dataB.length - maxLength;
        var vA = indexA >= 0 ? dataA[indexA] : 0;
        var vB = indexB >= 0 ? dataB[indexB] : 0;
        if (vA < vB)
            return true;
        if (vA > vB)
            return false;
    }
    return false;
}
function substractArrayIntToNew(arrayIntA, arrayIntB) {
    if (arrayIntA.sign !== arrayIntB.sign) {
        return addArrayIntToNew(arrayIntA, { sign: -arrayIntB.sign, data: arrayIntB.data });
    }
    var dataA = arrayIntA.data;
    var dataB = arrayIntB.data;
    if (isStrictlySmaller(dataA, dataB)) {
        var out = substractArrayIntToNew(arrayIntB, arrayIntA);
        out.sign = -out.sign;
        return out;
    }
    var data = [];
    var reminder = 0;
    for (var indexA = dataA.length - 1, indexB = dataB.length - 1; indexA >= 0 || indexB >= 0; --indexA, --indexB) {
        var vA = indexA >= 0 ? dataA[indexA] : 0;
        var vB = indexB >= 0 ? dataB[indexB] : 0;
        var current = vA - vB - reminder;
        data.push(current >>> 0);
        reminder = current < 0 ? 1 : 0;
    }
    return { sign: arrayIntA.sign, data: data.reverse() };
}
exports.substractArrayIntToNew = substractArrayIntToNew;
function trimArrayIntInplace(arrayInt) {
    var data = arrayInt.data;
    var firstNonZero = 0;
    for (; firstNonZero !== data.length && data[firstNonZero] === 0; ++firstNonZero) { }
    if (firstNonZero === data.length) {
        arrayInt.sign = 1;
        arrayInt.data = [0];
        return arrayInt;
    }
    data.splice(0, firstNonZero);
    return arrayInt;
}
exports.trimArrayIntInplace = trimArrayIntInplace;
function fromNumberToArrayInt64(out, n) {
    if (n < 0) {
        var posN = -n;
        out.sign = -1;
        out.data[0] = ~~(posN / 0x100000000);
        out.data[1] = posN >>> 0;
    }
    else {
        out.sign = 1;
        out.data[0] = ~~(n / 0x100000000);
        out.data[1] = n >>> 0;
    }
    return out;
}
exports.fromNumberToArrayInt64 = fromNumberToArrayInt64;
function substractArrayInt64(out, arrayIntA, arrayIntB) {
    var lowA = arrayIntA.data[1];
    var highA = arrayIntA.data[0];
    var signA = arrayIntA.sign;
    var lowB = arrayIntB.data[1];
    var highB = arrayIntB.data[0];
    var signB = arrayIntB.sign;
    out.sign = 1;
    if (signA === 1 && signB === -1) {
        var low_1 = lowA + lowB;
        var high = highA + highB + (low_1 > 0xffffffff ? 1 : 0);
        out.data[0] = high >>> 0;
        out.data[1] = low_1 >>> 0;
        return out;
    }
    var lowFirst = lowA;
    var highFirst = highA;
    var lowSecond = lowB;
    var highSecond = highB;
    if (signA === -1) {
        lowFirst = lowB;
        highFirst = highB;
        lowSecond = lowA;
        highSecond = highA;
    }
    var reminderLow = 0;
    var low = lowFirst - lowSecond;
    if (low < 0) {
        reminderLow = 1;
        low = low >>> 0;
    }
    out.data[0] = highFirst - highSecond - reminderLow;
    out.data[1] = low;
    return out;
}
exports.substractArrayInt64 = substractArrayInt64;


/***/ }),

/***/ "./node_modules/pure-rand/lib/distribution/internals/UnsafeUniformArrayIntDistributionInternal.js":
/*!********************************************************************************************************!*\
  !*** ./node_modules/pure-rand/lib/distribution/internals/UnsafeUniformArrayIntDistributionInternal.js ***!
  \********************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

exports.__esModule = true;
exports.unsafeUniformArrayIntDistributionInternal = void 0;
var UnsafeUniformIntDistributionInternal_1 = __webpack_require__(/*! ./UnsafeUniformIntDistributionInternal */ "./node_modules/pure-rand/lib/distribution/internals/UnsafeUniformIntDistributionInternal.js");
function unsafeUniformArrayIntDistributionInternal(out, rangeSize, rng) {
    var rangeLength = rangeSize.length;
    while (true) {
        for (var index = 0; index !== rangeLength; ++index) {
            var indexRangeSize = index === 0 ? rangeSize[0] + 1 : 0x100000000;
            var g = UnsafeUniformIntDistributionInternal_1.unsafeUniformIntDistributionInternal(indexRangeSize, rng);
            out[index] = g;
        }
        for (var index = 0; index !== rangeLength; ++index) {
            var current = out[index];
            var currentInRange = rangeSize[index];
            if (current < currentInRange) {
                return out;
            }
            else if (current > currentInRange) {
                break;
            }
        }
    }
}
exports.unsafeUniformArrayIntDistributionInternal = unsafeUniformArrayIntDistributionInternal;


/***/ }),

/***/ "./node_modules/pure-rand/lib/distribution/internals/UnsafeUniformIntDistributionInternal.js":
/*!***************************************************************************************************!*\
  !*** ./node_modules/pure-rand/lib/distribution/internals/UnsafeUniformIntDistributionInternal.js ***!
  \***************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

exports.__esModule = true;
exports.unsafeUniformIntDistributionInternal = void 0;
function unsafeUniformIntDistributionInternal(rangeSize, rng) {
    var MinRng = rng.min();
    var NumValues = rng.max() - rng.min() + 1;
    if (rangeSize <= NumValues) {
        var nrng_1 = rng;
        var MaxAllowed = NumValues - (NumValues % rangeSize);
        while (true) {
            var out = nrng_1.unsafeNext();
            var deltaV = out - MinRng;
            if (deltaV < MaxAllowed) {
                return deltaV % rangeSize;
            }
        }
    }
    var FinalNumValues = NumValues * NumValues;
    var NumIterations = 2;
    while (FinalNumValues < rangeSize) {
        FinalNumValues *= NumValues;
        ++NumIterations;
    }
    var MaxAcceptedRandom = rangeSize * Math.floor((1 * FinalNumValues) / rangeSize);
    var nrng = rng;
    while (true) {
        var value = 0;
        for (var num = 0; num !== NumIterations; ++num) {
            var out = nrng.unsafeNext();
            value = NumValues * value + (out - MinRng);
        }
        if (value < MaxAcceptedRandom) {
            var inDiff = value - rangeSize * Math.floor((1 * value) / rangeSize);
            return inDiff;
        }
    }
}
exports.unsafeUniformIntDistributionInternal = unsafeUniformIntDistributionInternal;


/***/ }),

/***/ "./node_modules/pure-rand/lib/generator/LinearCongruential.js":
/*!********************************************************************!*\
  !*** ./node_modules/pure-rand/lib/generator/LinearCongruential.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

exports.__esModule = true;
exports.congruential32 = exports.congruential = void 0;
var MULTIPLIER = 0x000343fd;
var INCREMENT = 0x00269ec3;
var MASK = 0xffffffff;
var MASK_2 = (1 << 31) - 1;
var computeNextSeed = function (seed) {
    return (seed * MULTIPLIER + INCREMENT) & MASK;
};
var computeValueFromNextSeed = function (nextseed) {
    return (nextseed & MASK_2) >> 16;
};
var LinearCongruential = (function () {
    function LinearCongruential(seed) {
        this.seed = seed;
    }
    LinearCongruential.prototype.min = function () {
        return LinearCongruential.min;
    };
    LinearCongruential.prototype.max = function () {
        return LinearCongruential.max;
    };
    LinearCongruential.prototype.clone = function () {
        return new LinearCongruential(this.seed);
    };
    LinearCongruential.prototype.next = function () {
        var nextRng = new LinearCongruential(this.seed);
        var out = nextRng.unsafeNext();
        return [out, nextRng];
    };
    LinearCongruential.prototype.unsafeNext = function () {
        this.seed = computeNextSeed(this.seed);
        return computeValueFromNextSeed(this.seed);
    };
    LinearCongruential.min = 0;
    LinearCongruential.max = Math.pow(2, 15) - 1;
    return LinearCongruential;
}());
var LinearCongruential32 = (function () {
    function LinearCongruential32(seed) {
        this.seed = seed;
    }
    LinearCongruential32.prototype.min = function () {
        return LinearCongruential32.min;
    };
    LinearCongruential32.prototype.max = function () {
        return LinearCongruential32.max;
    };
    LinearCongruential32.prototype.clone = function () {
        return new LinearCongruential32(this.seed);
    };
    LinearCongruential32.prototype.next = function () {
        var nextRng = new LinearCongruential32(this.seed);
        var out = nextRng.unsafeNext();
        return [out, nextRng];
    };
    LinearCongruential32.prototype.unsafeNext = function () {
        var s1 = computeNextSeed(this.seed);
        var v1 = computeValueFromNextSeed(s1);
        var s2 = computeNextSeed(s1);
        var v2 = computeValueFromNextSeed(s2);
        this.seed = computeNextSeed(s2);
        var v3 = computeValueFromNextSeed(this.seed);
        var vnext = v3 + ((v2 + (v1 << 15)) << 15);
        return ((vnext + 0x80000000) | 0) + 0x80000000;
    };
    LinearCongruential32.min = 0;
    LinearCongruential32.max = 0xffffffff;
    return LinearCongruential32;
}());
var congruential = function (seed) {
    return new LinearCongruential(seed);
};
exports.congruential = congruential;
var congruential32 = function (seed) {
    return new LinearCongruential32(seed);
};
exports.congruential32 = congruential32;


/***/ }),

/***/ "./node_modules/pure-rand/lib/generator/MersenneTwister.js":
/*!*****************************************************************!*\
  !*** ./node_modules/pure-rand/lib/generator/MersenneTwister.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

exports.__esModule = true;
var MersenneTwister = (function () {
    function MersenneTwister(states, index) {
        this.states = states;
        this.index = index;
    }
    MersenneTwister.twist = function (prev) {
        var mt = prev.slice();
        for (var idx = 0; idx !== MersenneTwister.N - MersenneTwister.M; ++idx) {
            var y_1 = (mt[idx] & MersenneTwister.MASK_UPPER) + (mt[idx + 1] & MersenneTwister.MASK_LOWER);
            mt[idx] = mt[idx + MersenneTwister.M] ^ (y_1 >>> 1) ^ (-(y_1 & 1) & MersenneTwister.A);
        }
        for (var idx = MersenneTwister.N - MersenneTwister.M; idx !== MersenneTwister.N - 1; ++idx) {
            var y_2 = (mt[idx] & MersenneTwister.MASK_UPPER) + (mt[idx + 1] & MersenneTwister.MASK_LOWER);
            mt[idx] = mt[idx + MersenneTwister.M - MersenneTwister.N] ^ (y_2 >>> 1) ^ (-(y_2 & 1) & MersenneTwister.A);
        }
        var y = (mt[MersenneTwister.N - 1] & MersenneTwister.MASK_UPPER) + (mt[0] & MersenneTwister.MASK_LOWER);
        mt[MersenneTwister.N - 1] = mt[MersenneTwister.M - 1] ^ (y >>> 1) ^ (-(y & 1) & MersenneTwister.A);
        return mt;
    };
    MersenneTwister.seeded = function (seed) {
        var out = Array(MersenneTwister.N);
        out[0] = seed;
        for (var idx = 1; idx !== MersenneTwister.N; ++idx) {
            var xored = out[idx - 1] ^ (out[idx - 1] >>> 30);
            out[idx] = (Math.imul(MersenneTwister.F, xored) + idx) | 0;
        }
        return out;
    };
    MersenneTwister.from = function (seed) {
        return new MersenneTwister(MersenneTwister.twist(MersenneTwister.seeded(seed)), 0);
    };
    MersenneTwister.prototype.min = function () {
        return MersenneTwister.min;
    };
    MersenneTwister.prototype.max = function () {
        return MersenneTwister.max;
    };
    MersenneTwister.prototype.clone = function () {
        return new MersenneTwister(this.states, this.index);
    };
    MersenneTwister.prototype.next = function () {
        var nextRng = new MersenneTwister(this.states, this.index);
        var out = nextRng.unsafeNext();
        return [out, nextRng];
    };
    MersenneTwister.prototype.unsafeNext = function () {
        var y = this.states[this.index];
        y ^= this.states[this.index] >>> MersenneTwister.U;
        y ^= (y << MersenneTwister.S) & MersenneTwister.B;
        y ^= (y << MersenneTwister.T) & MersenneTwister.C;
        y ^= y >>> MersenneTwister.L;
        if (++this.index >= MersenneTwister.N) {
            this.states = MersenneTwister.twist(this.states);
            this.index = 0;
        }
        return y >>> 0;
    };
    MersenneTwister.min = 0;
    MersenneTwister.max = 0xffffffff;
    MersenneTwister.N = 624;
    MersenneTwister.M = 397;
    MersenneTwister.R = 31;
    MersenneTwister.A = 0x9908b0df;
    MersenneTwister.F = 1812433253;
    MersenneTwister.U = 11;
    MersenneTwister.S = 7;
    MersenneTwister.B = 0x9d2c5680;
    MersenneTwister.T = 15;
    MersenneTwister.C = 0xefc60000;
    MersenneTwister.L = 18;
    MersenneTwister.MASK_LOWER = Math.pow(2, MersenneTwister.R) - 1;
    MersenneTwister.MASK_UPPER = Math.pow(2, MersenneTwister.R);
    return MersenneTwister;
}());
function default_1(seed) {
    return MersenneTwister.from(seed);
}
exports.default = default_1;


/***/ }),

/***/ "./node_modules/pure-rand/lib/generator/RandomGenerator.js":
/*!*****************************************************************!*\
  !*** ./node_modules/pure-rand/lib/generator/RandomGenerator.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

exports.__esModule = true;
exports.skipN = exports.unsafeSkipN = exports.generateN = exports.unsafeGenerateN = void 0;
function unsafeGenerateN(rng, num) {
    var out = [];
    for (var idx = 0; idx != num; ++idx) {
        out.push(rng.unsafeNext());
    }
    return out;
}
exports.unsafeGenerateN = unsafeGenerateN;
function generateN(rng, num) {
    var nextRng = rng.clone();
    var out = unsafeGenerateN(nextRng, num);
    return [out, nextRng];
}
exports.generateN = generateN;
function unsafeSkipN(rng, num) {
    for (var idx = 0; idx != num; ++idx) {
        rng.unsafeNext();
    }
}
exports.unsafeSkipN = unsafeSkipN;
function skipN(rng, num) {
    var nextRng = rng.clone();
    unsafeSkipN(nextRng, num);
    return nextRng;
}
exports.skipN = skipN;


/***/ }),

/***/ "./node_modules/pure-rand/lib/generator/XorShift.js":
/*!**********************************************************!*\
  !*** ./node_modules/pure-rand/lib/generator/XorShift.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

exports.__esModule = true;
exports.xorshift128plus = void 0;
var XorShift128Plus = (function () {
    function XorShift128Plus(s01, s00, s11, s10) {
        this.s01 = s01;
        this.s00 = s00;
        this.s11 = s11;
        this.s10 = s10;
    }
    XorShift128Plus.prototype.min = function () {
        return -0x80000000;
    };
    XorShift128Plus.prototype.max = function () {
        return 0x7fffffff;
    };
    XorShift128Plus.prototype.clone = function () {
        return new XorShift128Plus(this.s01, this.s00, this.s11, this.s10);
    };
    XorShift128Plus.prototype.next = function () {
        var nextRng = new XorShift128Plus(this.s01, this.s00, this.s11, this.s10);
        var out = nextRng.unsafeNext();
        return [out, nextRng];
    };
    XorShift128Plus.prototype.unsafeNext = function () {
        var a0 = this.s00 ^ (this.s00 << 23);
        var a1 = this.s01 ^ ((this.s01 << 23) | (this.s00 >>> 9));
        var b0 = a0 ^ this.s10 ^ ((a0 >>> 18) | (a1 << 14)) ^ ((this.s10 >>> 5) | (this.s11 << 27));
        var b1 = a1 ^ this.s11 ^ (a1 >>> 18) ^ (this.s11 >>> 5);
        var out = (this.s00 + this.s10) | 0;
        this.s01 = this.s11;
        this.s00 = this.s10;
        this.s11 = b1;
        this.s10 = b0;
        return out;
    };
    XorShift128Plus.prototype.jump = function () {
        var nextRng = new XorShift128Plus(this.s01, this.s00, this.s11, this.s10);
        nextRng.unsafeJump();
        return nextRng;
    };
    XorShift128Plus.prototype.unsafeJump = function () {
        var ns01 = 0;
        var ns00 = 0;
        var ns11 = 0;
        var ns10 = 0;
        var jump = [0x635d2dff, 0x8a5cd789, 0x5c472f96, 0x121fd215];
        for (var i = 0; i !== 4; ++i) {
            for (var mask = 1; mask; mask <<= 1) {
                if (jump[i] & mask) {
                    ns01 ^= this.s01;
                    ns00 ^= this.s00;
                    ns11 ^= this.s11;
                    ns10 ^= this.s10;
                }
                this.unsafeNext();
            }
        }
        this.s01 = ns01;
        this.s00 = ns00;
        this.s11 = ns11;
        this.s10 = ns10;
    };
    return XorShift128Plus;
}());
var xorshift128plus = function (seed) {
    return new XorShift128Plus(-1, ~seed, seed | 0, 0);
};
exports.xorshift128plus = xorshift128plus;


/***/ }),

/***/ "./node_modules/pure-rand/lib/generator/XoroShiro.js":
/*!***********************************************************!*\
  !*** ./node_modules/pure-rand/lib/generator/XoroShiro.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

exports.__esModule = true;
exports.xoroshiro128plus = void 0;
var XoroShiro128Plus = (function () {
    function XoroShiro128Plus(s01, s00, s11, s10) {
        this.s01 = s01;
        this.s00 = s00;
        this.s11 = s11;
        this.s10 = s10;
    }
    XoroShiro128Plus.prototype.min = function () {
        return -0x80000000;
    };
    XoroShiro128Plus.prototype.max = function () {
        return 0x7fffffff;
    };
    XoroShiro128Plus.prototype.clone = function () {
        return new XoroShiro128Plus(this.s01, this.s00, this.s11, this.s10);
    };
    XoroShiro128Plus.prototype.next = function () {
        var nextRng = new XoroShiro128Plus(this.s01, this.s00, this.s11, this.s10);
        var out = nextRng.unsafeNext();
        return [out, nextRng];
    };
    XoroShiro128Plus.prototype.unsafeNext = function () {
        var out = (this.s00 + this.s10) | 0;
        var a0 = this.s10 ^ this.s00;
        var a1 = this.s11 ^ this.s01;
        var s00 = this.s00;
        var s01 = this.s01;
        this.s00 = (s00 << 24) ^ (s01 >>> 8) ^ a0 ^ (a0 << 16);
        this.s01 = (s01 << 24) ^ (s00 >>> 8) ^ a1 ^ ((a1 << 16) | (a0 >>> 16));
        this.s10 = (a1 << 5) ^ (a0 >>> 27);
        this.s11 = (a0 << 5) ^ (a1 >>> 27);
        return out;
    };
    XoroShiro128Plus.prototype.jump = function () {
        var nextRng = new XoroShiro128Plus(this.s01, this.s00, this.s11, this.s10);
        nextRng.unsafeJump();
        return nextRng;
    };
    XoroShiro128Plus.prototype.unsafeJump = function () {
        var ns01 = 0;
        var ns00 = 0;
        var ns11 = 0;
        var ns10 = 0;
        var jump = [0xd8f554a5, 0xdf900294, 0x4b3201fc, 0x170865df];
        for (var i = 0; i !== 4; ++i) {
            for (var mask = 1; mask; mask <<= 1) {
                if (jump[i] & mask) {
                    ns01 ^= this.s01;
                    ns00 ^= this.s00;
                    ns11 ^= this.s11;
                    ns10 ^= this.s10;
                }
                this.unsafeNext();
            }
        }
        this.s01 = ns01;
        this.s00 = ns00;
        this.s11 = ns11;
        this.s10 = ns10;
    };
    return XoroShiro128Plus;
}());
var xoroshiro128plus = function (seed) {
    return new XoroShiro128Plus(-1, ~seed, seed | 0, 0);
};
exports.xoroshiro128plus = xoroshiro128plus;


/***/ }),

/***/ "./node_modules/pure-rand/lib/pure-rand-default.js":
/*!*********************************************************!*\
  !*** ./node_modules/pure-rand/lib/pure-rand-default.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

exports.__esModule = true;
exports.unsafeUniformIntDistribution = exports.unsafeUniformBigIntDistribution = exports.unsafeUniformArrayIntDistribution = exports.uniformIntDistribution = exports.uniformBigIntDistribution = exports.uniformArrayIntDistribution = exports.xoroshiro128plus = exports.xorshift128plus = exports.mersenne = exports.congruential32 = exports.congruential = exports.unsafeSkipN = exports.unsafeGenerateN = exports.skipN = exports.generateN = exports.__commitHash = exports.__version = exports.__type = void 0;
var RandomGenerator_1 = __webpack_require__(/*! ./generator/RandomGenerator */ "./node_modules/pure-rand/lib/generator/RandomGenerator.js");
exports.generateN = RandomGenerator_1.generateN;
exports.skipN = RandomGenerator_1.skipN;
exports.unsafeGenerateN = RandomGenerator_1.unsafeGenerateN;
exports.unsafeSkipN = RandomGenerator_1.unsafeSkipN;
var LinearCongruential_1 = __webpack_require__(/*! ./generator/LinearCongruential */ "./node_modules/pure-rand/lib/generator/LinearCongruential.js");
exports.congruential = LinearCongruential_1.congruential;
exports.congruential32 = LinearCongruential_1.congruential32;
var MersenneTwister_1 = __webpack_require__(/*! ./generator/MersenneTwister */ "./node_modules/pure-rand/lib/generator/MersenneTwister.js");
exports.mersenne = MersenneTwister_1["default"];
var XorShift_1 = __webpack_require__(/*! ./generator/XorShift */ "./node_modules/pure-rand/lib/generator/XorShift.js");
exports.xorshift128plus = XorShift_1.xorshift128plus;
var XoroShiro_1 = __webpack_require__(/*! ./generator/XoroShiro */ "./node_modules/pure-rand/lib/generator/XoroShiro.js");
exports.xoroshiro128plus = XoroShiro_1.xoroshiro128plus;
var UniformArrayIntDistribution_1 = __webpack_require__(/*! ./distribution/UniformArrayIntDistribution */ "./node_modules/pure-rand/lib/distribution/UniformArrayIntDistribution.js");
exports.uniformArrayIntDistribution = UniformArrayIntDistribution_1.uniformArrayIntDistribution;
var UniformBigIntDistribution_1 = __webpack_require__(/*! ./distribution/UniformBigIntDistribution */ "./node_modules/pure-rand/lib/distribution/UniformBigIntDistribution.js");
exports.uniformBigIntDistribution = UniformBigIntDistribution_1.uniformBigIntDistribution;
var UniformIntDistribution_1 = __webpack_require__(/*! ./distribution/UniformIntDistribution */ "./node_modules/pure-rand/lib/distribution/UniformIntDistribution.js");
exports.uniformIntDistribution = UniformIntDistribution_1.uniformIntDistribution;
var UnsafeUniformArrayIntDistribution_1 = __webpack_require__(/*! ./distribution/UnsafeUniformArrayIntDistribution */ "./node_modules/pure-rand/lib/distribution/UnsafeUniformArrayIntDistribution.js");
exports.unsafeUniformArrayIntDistribution = UnsafeUniformArrayIntDistribution_1.unsafeUniformArrayIntDistribution;
var UnsafeUniformBigIntDistribution_1 = __webpack_require__(/*! ./distribution/UnsafeUniformBigIntDistribution */ "./node_modules/pure-rand/lib/distribution/UnsafeUniformBigIntDistribution.js");
exports.unsafeUniformBigIntDistribution = UnsafeUniformBigIntDistribution_1.unsafeUniformBigIntDistribution;
var UnsafeUniformIntDistribution_1 = __webpack_require__(/*! ./distribution/UnsafeUniformIntDistribution */ "./node_modules/pure-rand/lib/distribution/UnsafeUniformIntDistribution.js");
exports.unsafeUniformIntDistribution = UnsafeUniformIntDistribution_1.unsafeUniformIntDistribution;
var __type = 'commonjs';
exports.__type = __type;
var __version = '5.0.0';
exports.__version = __version;
var __commitHash = '744555855a01e1551ab1cf67a6ea973d14964661';
exports.__commitHash = __commitHash;


/***/ }),

/***/ "./node_modules/pure-rand/lib/pure-rand.js":
/*!*************************************************!*\
  !*** ./node_modules/pure-rand/lib/pure-rand.js ***!
  \*************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
exports.__esModule = true;
var prand = __webpack_require__(/*! ./pure-rand-default */ "./node_modules/pure-rand/lib/pure-rand-default.js");
exports.default = prand;
__exportStar(__webpack_require__(/*! ./pure-rand-default */ "./node_modules/pure-rand/lib/pure-rand-default.js"), exports);


/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			loaded: false,
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/node module decorator */
/******/ 	(() => {
/******/ 		__webpack_require__.nmd = (module) => {
/******/ 			module.paths = [];
/******/ 			if (!module.children) module.children = [];
/******/ 			return module;
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be in strict mode.
(() => {
"use strict";
var exports = __webpack_exports__;
/*!*******************************************!*\
  !*** ./src/visualizers/run-expr-tests.ts ***!
  \*******************************************/

Object.defineProperty(exports, "__esModule", ({ value: true }));
const vis = __webpack_require__(/*! litscript/lib/visualizer */ "./node_modules/litscript/lib/visualizer.js");
const le = __webpack_require__(/*! lits-extras */ "./node_modules/lits-extras/lib/index.js");
const pz = __webpack_require__(/*! .. */ "./src/index.ts");
const ep = __webpack_require__(/*! ../test/exprparser */ "./src/test/exprparser.ts");
__webpack_require__(/*! ../test/exprtests */ "./src/test/exprtests.ts");
__webpack_require__(/*! ./run-expr-tests.less */ "./src/visualizers/run-expr-tests.less");
vis.registerVisualizer("run-expr-tests", le.runTests);
vis.registerVisualizer("calculator", calculator);
function calculator(params, parent) {
    parent.classList.add("calculator");
    let ta = document.createElement('input');
    let res = document.createElement('div');
    res.classList.add("result");
    parent.append(ta, res);
    ta.addEventListener("change", _ => {
        try {
            res.innerText = ep.evaluateExpression(ta.value).toString();
        }
        catch (e) {
            if (e instanceof pz.ParseError)
                res.innerText = e.message;
            else
                throw e;
        }
    });
}

})();

/******/ })()
;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHFDQUFxQyx5QkFBeUI7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCw0QkFBNEI7QUFDNUIsNEJBQTRCO0FBQzVCLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RDtBQUM3RCw2REFBNkQ7QUFDN0Q7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0Qix3QkFBd0I7QUFDcEQ7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFD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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztBQ3ZKYTs7QUFFYixRQUFRLG1CQUFPLENBQUMsdURBQVU7O0FBRTFCOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9FQUFvRSxXQUFXO0FBQy9FO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsY0FBYztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsc0JBQXNCO0FBQ2xFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsc0JBQXNCO0FBQ2xFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtQkFBbUI7QUFDbkI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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Q0E7QUFDQTtBQUNBLHVCQUF1QixVQUFVO0FBQ2pDO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEscUJBQXFCLFVBQVU7QUFDL0I7O0FBRUEscUJBQXFCLFVBQVU7QUFDL0I7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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Q0E7QUFDQSxLQUFLO0FBQ0wiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wYXJ6ZWMvLi9ub2RlX21vZHVsZXMvZGFncmUvaW5kZXguanMiLCJ3ZWJwYWNrOi8vcGFyemVjLy4vbm9kZV9tb2R1bGVzL2RhZ3JlL2xpYi9hY3ljbGljLmpzIiwid2VicGFjazovL3BhcnplYy8uL25vZGVfbW9kdWxlcy9kYWdyZS9saWIvYWRkLWJvcmRlci1zZWdtZW50cy5qcyIsIndlYnBhY2s6Ly9wYXJ6ZWMvLi9ub2RlX21vZHVsZXMvZGFncmUvbGliL2Nvb3JkaW5hdGUtc3lzdGVtLmpzIiwid2VicGFjazovL3BhcnplYy8uL25vZGVfbW9kdWxlcy9kYWdyZS9saWIvZGF0YS9saXN0LmpzIiwid2VicGFjazovL3BhcnplYy8uL25vZGVfbW9kdWxlcy9kYWdyZS9saWIvZGVidWcuanMiLCJ3ZWJwYWNrOi8vcGFyemVjLy4vbm9kZV9tb2R1bGVzL2RhZ3JlL2xpYi9ncmFwaGxpYi5qcyIsIndlYnBhY2s6Ly9wYXJ6ZWMvLi9ub2RlX21vZHVsZXMvZGFncmUvbGliL2dyZWVkeS1mYXMuanMiLCJ3ZWJwYWNrOi8vcGFyemVjLy4vbm9kZV9tb2R1bGVzL2RhZ3JlL2xpYi9sYXlvdXQuanMiLCJ3ZWJwYWNrOi8vcGFyemVjLy4vbm9kZV9tb2R1bGVzL2RhZ3JlL2xpYi9sb2Rhc2guanMiLCJ3ZWJwYWNrOi8vcGFyemVjLy4vbm9kZV9tb2R1bGVzL2RhZ3JlL2xpYi9uZXN0aW5nLWdyYXBoLmpzIiwid2VicGFjazovL3BhcnplYy8uL25vZGVfbW9kdWxlcy9kYWdyZS9saWIvbm9ybWFsaXplLmpzIiwid2VicGFjazovL3BhcnplYy8uL25vZGVfbW9kdWxlcy9kYWdyZS9saWIvb3JkZXIvYWRkLXN1YmdyYXBoLWNvbnN0cmFpbnRzLmpzIiwid2VicGFjazovL3BhcnplYy8uL25vZGVfbW9kdWxlcy9kYWdyZS9saWIvb3JkZXIvYmFyeWNlbnRlci5qcyIsIndlYnBhY2s6Ly9wYXJ6ZWMvLi9ub2RlX21vZHVsZXMvZGFncmUvbGliL29yZGVyL2J1aWxkLWxheWVyLWdyYXBoLmpzIiwid2VicGFjazovL3BhcnplYy8uL25vZGVfbW9kdWxlcy9kYWdyZS9saWIvb3JkZXIvY3Jvc3MtY291bnQuanMiLCJ3ZWJwYWNrOi8vcGFyemVjLy4vbm9kZV9tb2R1bGVzL2RhZ3JlL2xpYi9vcmRlci9pbmRleC5qcyIsIndlYnBhY2s6Ly9wYXJ6ZWMvLi9ub2RlX21vZHVsZXMvZGFncmUvbGliL29yZGVyL2luaXQtb3JkZXIuanMiLCJ3ZWJwYWNrOi8vcGFyemVjLy4vbm9kZV9tb2R1bGVzL2RhZ3JlL2xpYi9vcmRlci9yZXNvbHZlLWNvbmZsaWN0cy5qcyIsIndlYnBhY2s6Ly9wYXJ6ZWMvLi9ub2RlX21vZHVsZXMvZGFncmUvbGliL29yZGVyL3NvcnQtc3ViZ3JhcGguanMiLCJ3ZWJwYWNrOi8vcGFyemVjLy4vbm9kZV9tb2R1bGVzL2RhZ3JlL2xpYi9vcmRlci9zb3J0LmpzIiwid2VicGFjazovL3BhcnplYy8uL25vZGVfbW9kdWxlcy9kYWdyZS9saWIvcGFyZW50LWR1bW15LWNoYWlucy5qcyIsIndlYnBhY2s6Ly9wYXJ6ZWMvLi9ub2RlX21vZHVsZXMvZGFncmUvbGliL3Bvc2l0aW9uL2JrLmpzIiwid2VicGFjazovL3BhcnplYy8uL25vZGVfbW9kdWxlcy9kYWdyZS9saWIvcG9zaXRpb24vaW5kZXguanMiLCJ3ZWJwYWNrOi8vcGFyemVjLy4vbm9kZV9tb2R1bGVzL2RhZ3JlL2xpYi9yYW5rL2ZlYXNpYmxlLXRyZWUuanMiLCJ3ZWJwYWNrOi8vcGFyemVjLy4vbm9kZV9tb2R1bGVzL2RhZ3JlL2xpYi9yYW5rL2luZGV4LmpzIiwid2VicGFjazovL3BhcnplYy8uL25vZGVfbW9kdWxlcy9kYWdyZS9saWIvcmFuay9uZXR3b3JrLXNpbXBsZXguanMiLCJ3ZWJwYWNrOi8vcGFyemVjLy4vbm9kZV9tb2R1bGVzL2RhZ3JlL2xpYi9yYW5rL3V0aWwuanMiLCJ3ZWJwYWNrOi8vcGFyemVjLy4vbm9kZV9tb2R1bGVzL2RhZ3JlL2xpYi91dGlsLmpzIiwid2VicGFjazovL3BhcnplYy8uL25vZGVfbW9kdWxlcy9kYWdyZS9saWIvdmVyc2lvbi5qcyIsIndlYnBhY2s6Ly9wYXJ6ZWMvLi9ub2RlX21vZHVsZXMvZ3JhcGhsaWIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vcGFyemVjLy4vbm9kZV9tb2R1bGVzL2dyYXBobGliL2xpYi9hbGcvY29tcG9uZW50cy5qcyIsIndlYnBhY2s6Ly9wYXJ6ZWMvLi9ub2RlX21vZHVsZXMvZ3JhcGhsaWIvbGliL2FsZy9kZnMuanMiLCJ3ZWJwYWNrOi8vcGFyemVjLy4vbm9kZV9tb2R1bGVzL2dyYXBobGliL2xpYi9hbGcvZGlqa3N0cmEtYWxsLmpzIiwid2VicGFjazovL3BhcnplYy8uL25vZGVfbW9kdWxlcy9ncmFwaGxpYi9saWIvYWxnL2RpamtzdHJhLmpzIiwid2VicGFjazovL3BhcnplYy8uL25vZGVfbW9kdWxlcy9ncmFwaGxpYi9saWIvYWxnL2ZpbmQtY3ljbGVzLmpzIiwid2VicGFjazovL3BhcnplYy8uL25vZGVfbW9kdWxlcy9ncmFwaGxpYi9saWIvYWxnL2Zsb3lkLXdhcnNoYWxsLmpzIiwid2VicGFjazovL3BhcnplYy8uL25vZGVfbW9kdWxlcy9ncmFwaGxpYi9saWIvYWxnL2luZGV4LmpzIiwid2VicGFjazovL3BhcnplYy8uL25vZGVfbW9kdWxlcy9ncmFwaGxpYi9saWIvYWxnL2lzLWFjeWNsaWMuanMiLCJ3ZWJwYWNrOi8vcGFyemVjLy4vbm9kZV9tb2R1bGVzL2dyYXBobGliL2xpYi9hbGcvcG9zdG9yZGVyLmpzIiwid2VicGFjazovL3BhcnplYy8uL25vZGVfbW9kdWxlcy9ncmFwaGxpYi9saWIvYWxnL3ByZW9yZGVyLmpzIiwid2VicGFjazovL3BhcnplYy8uL25vZGVfbW9kdWxlcy9ncmFwaGxpYi9saWIvYWxnL3ByaW0uanMiLCJ3ZWJwYWNrOi8vcGFyemVjLy4vbm9kZV9tb2R1bGVzL2dyYXBobGliL2xpYi9hbGcvdGFyamFuLmpzIiwid2VicGFjazovL3BhcnplYy8uL25vZGVfbW9kdWxlcy9ncmFwaGxpYi9saWIvYWxnL3RvcHNvcnQuanMiLCJ3ZWJwYWNrOi8vcGFyemVjLy4vbm9kZV9tb2R1bGVzL2dyYXBobGliL2xpYi9kYXRhL3ByaW9yaXR5LXF1ZXVlLmpzIiwid2VicGFjazovL3BhcnplYy8uL25vZGVfbW9kdWxlcy9ncmFwaGxpYi9saWIvZ3JhcGguanMiLCJ3ZWJwYWNrOi8vcGFyemVjLy4vbm9kZV9tb2R1bGVzL2dyYXBobGliL2xpYi9pbmRleC5qcyIsIndlYnBhY2s6Ly9wYXJ6ZWMvLi9ub2RlX21vZHVsZXMvZ3JhcGhsaWIvbGliL2pzb24uanMiLCJ3ZWJwYWNrOi8vcGFyemVjLy4vbm9kZV9tb2R1bGVzL2dyYXBobGliL2xpYi9sb2Rhc2guanMiLCJ3ZWJwYWNrOi8vcGFyemVjLy4vbm9kZV9tb2R1bGVzL2dyYXBobGliL2xpYi92ZXJzaW9uLmpzIiwid2VicGFjazovL3BhcnplYy8uL25vZGVfbW9kdWxlcy9saXRzLWV4dHJhcy9saWIvZGVwZW5kZW5jeS1kaWFnLmpzIiwid2VicGFjazovL3BhcnplYy8uL25vZGVfbW9kdWxlcy9saXRzLWV4dHJhcy9saWIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vcGFyemVjLy4vbm9kZV9tb2R1bGVzL2xpdHMtZXh0cmFzL2xpYi90ZXN0LXJlcG9ydGVyLmpzIiwid2VicGFjazovL3BhcnplYy8uL25vZGVfbW9kdWxlcy9saXRzLWV4dHJhcy9saWIvdGVzdC12aXN1YWxpemVyLmpzIiwid2VicGFjazovL3BhcnplYy8uL25vZGVfbW9kdWxlcy9saXRzLWV4dHJhcy9saWIvdGVzdGVyLmpzIiwid2VicGFjazovL3BhcnplYy8uL25vZGVfbW9kdWxlcy9saXRzY3JpcHQvbGliL3Zpc3VhbGl6ZXIuanMiLCJ3ZWJwYWNrOi8vcGFyemVjLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fRGF0YVZpZXcuanMiLCJ3ZWJwYWNrOi8vcGFyemVjLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fSGFzaC5qcyIsIndlYnBhY2s6Ly9wYXJ6ZWMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19MaXN0Q2FjaGUuanMiLCJ3ZWJwYWNrOi8vcGFyemVjLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fTWFwLmpzIiwid2VicGFjazovL3BhcnplYy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX01hcENhY2hlLmpzIiwid2VicGFjazovL3BhcnplYy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX1Byb21pc2UuanMiLCJ3ZWJwYWNrOi8vcGFyemVjLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fU2V0LmpzIiwid2VicGFjazovL3BhcnplYy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX1NldENhY2hlLmpzIiwid2VicGFjazovL3BhcnplYy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX1N0YWNrLmpzIiwid2VicGFjazovL3BhcnplYy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX1N5bWJvbC5qcyIsIndlYnBhY2s6Ly9wYXJ6ZWMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19VaW50OEFycmF5LmpzIiwid2VicGFjazovL3BhcnplYy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX1dlYWtNYXAuanMiLCJ3ZWJwYWNrOi8vcGFyemVjLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYXBwbHkuanMiLCJ3ZWJwYWNrOi8vcGFyemVjLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYXJyYXlFYWNoLmpzIiwid2VicGFjazovL3BhcnplYy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2FycmF5RmlsdGVyLmpzIiwid2VicGFjazovL3BhcnplYy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2FycmF5SW5jbHVkZXMuanMiLCJ3ZWJwYWNrOi8vcGFyemVjLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYXJyYXlJbmNsdWRlc1dpdGguanMiLCJ3ZWJwYWNrOi8vcGFyemVjLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYXJyYXlMaWtlS2V5cy5qcyIsIndlYnBhY2s6Ly9wYXJ6ZWMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19hcnJheU1hcC5qcyIsIndlYnBhY2s6Ly9wYXJ6ZWMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19hcnJheVB1c2guanMiLCJ3ZWJwYWNrOi8vcGFyemVjLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYXJyYXlSZWR1Y2UuanMiLCJ3ZWJwYWNrOi8vcGFyemVjLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYXJyYXlTb21lLmpzIiwid2VicGFjazovL3BhcnplYy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2FzY2lpU2l6ZS5qcyIsIndlYnBhY2s6Ly9wYXJ6ZWMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19hc3NpZ25NZXJnZVZhbHVlLmpzIiwid2VicGFjazovL3BhcnplYy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Fzc2lnblZhbHVlLmpzIiwid2VicGFjazovL3BhcnplYy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Fzc29jSW5kZXhPZi5qcyIsIndlYnBhY2s6Ly9wYXJ6ZWMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlQXNzaWduLmpzIiwid2VicGFjazovL3BhcnplYy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VBc3NpZ25Jbi5qcyIsIndlYnBhY2s6Ly9wYXJ6ZWMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlQXNzaWduVmFsdWUuanMiLCJ3ZWJwYWNrOi8vcGFyemVjLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUNsb25lLmpzIiwid2VicGFjazovL3BhcnplYy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VDcmVhdGUuanMiLCJ3ZWJwYWNrOi8vcGFyemVjLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUVhY2guanMiLCJ3ZWJwYWNrOi8vcGFyemVjLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUV4dHJlbXVtLmpzIiwid2VicGFjazovL3BhcnplYy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VGaWx0ZXIuanMiLCJ3ZWJwYWNrOi8vcGFyemVjLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUZpbmRJbmRleC5qcyIsIndlYnBhY2s6Ly9wYXJ6ZWMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlRmxhdHRlbi5qcyIsIndlYnBhY2s6Ly9wYXJ6ZWMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlRm9yLmpzIiwid2VicGFjazovL3BhcnplYy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VGb3JPd24uanMiLCJ3ZWJwYWNrOi8vcGFyemVjLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUdldC5qcyIsIndlYnBhY2s6Ly9wYXJ6ZWMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlR2V0QWxsS2V5cy5qcyIsIndlYnBhY2s6Ly9wYXJ6ZWMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlR2V0VGFnLmpzIiwid2VicGFjazovL3BhcnplYy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VHdC5qcyIsIndlYnBhY2s6Ly9wYXJ6ZWMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlSGFzLmpzIiwid2VicGFjazovL3BhcnplYy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VIYXNJbi5qcyIsIndlYnBhY2s6Ly9wYXJ6ZWMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlSW5kZXhPZi5qcyIsIndlYnBhY2s6Ly9wYXJ6ZWMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlSXNBcmd1bWVudHMuanMiLCJ3ZWJwYWNrOi8vcGFyemVjLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUlzRXF1YWwuanMiLCJ3ZWJwYWNrOi8vcGFyemVjLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUlzRXF1YWxEZWVwLmpzIiwid2VicGFjazovL3BhcnplYy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VJc01hcC5qcyIsIndlYnBhY2s6Ly9wYXJ6ZWMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlSXNNYXRjaC5qcyIsIndlYnBhY2s6Ly9wYXJ6ZWMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlSXNOYU4uanMiLCJ3ZWJwYWNrOi8vcGFyemVjLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUlzTmF0aXZlLmpzIiwid2VicGFjazovL3BhcnplYy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VJc1NldC5qcyIsIndlYnBhY2s6Ly9wYXJ6ZWMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlSXNUeXBlZEFycmF5LmpzIiwid2VicGFjazovL3BhcnplYy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VJdGVyYXRlZS5qcyIsIndlYnBhY2s6Ly9wYXJ6ZWMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlS2V5cy5qcyIsIndlYnBhY2s6Ly9wYXJ6ZWMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlS2V5c0luLmpzIiwid2VicGFjazovL3BhcnplYy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VMdC5qcyIsIndlYnBhY2s6Ly9wYXJ6ZWMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlTWFwLmpzIiwid2VicGFjazovL3BhcnplYy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VNYXRjaGVzLmpzIiwid2VicGFjazovL3BhcnplYy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VNYXRjaGVzUHJvcGVydHkuanMiLCJ3ZWJwYWNrOi8vcGFyemVjLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZU1lcmdlLmpzIiwid2VicGFjazovL3BhcnplYy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VNZXJnZURlZXAuanMiLCJ3ZWJwYWNrOi8vcGFyemVjLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZU9yZGVyQnkuanMiLCJ3ZWJwYWNrOi8vcGFyemVjLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZVBpY2suanMiLCJ3ZWJwYWNrOi8vcGFyemVjLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZVBpY2tCeS5qcyIsIndlYnBhY2s6Ly9wYXJ6ZWMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlUHJvcGVydHkuanMiLCJ3ZWJwYWNrOi8vcGFyemVjLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZVByb3BlcnR5RGVlcC5qcyIsIndlYnBhY2s6Ly9wYXJ6ZWMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlUmFuZ2UuanMiLCJ3ZWJwYWNrOi8vcGFyemVjLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZVJlZHVjZS5qcyIsIndlYnBhY2s6Ly9wYXJ6ZWMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlUmVzdC5qcyIsIndlYnBhY2s6Ly9wYXJ6ZWMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlU2V0LmpzIiwid2VicGFjazovL3BhcnplYy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VTZXRUb1N0cmluZy5qcyIsIndlYnBhY2s6Ly9wYXJ6ZWMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlU29ydEJ5LmpzIiwid2VicGFjazovL3BhcnplYy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VUaW1lcy5qcyIsIndlYnBhY2s6Ly9wYXJ6ZWMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlVG9TdHJpbmcuanMiLCJ3ZWJwYWNrOi8vcGFyemVjLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZVRyaW0uanMiLCJ3ZWJwYWNrOi8vcGFyemVjLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZVVuYXJ5LmpzIiwid2VicGFjazovL3BhcnplYy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VVbmlxLmpzIiwid2VicGFjazovL3BhcnplYy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VWYWx1ZXMuanMiLCJ3ZWJwYWNrOi8vcGFyemVjLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZVppcE9iamVjdC5qcyIsIndlYnBhY2s6Ly9wYXJ6ZWMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19jYWNoZUhhcy5qcyIsIndlYnBhY2s6Ly9wYXJ6ZWMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19jYXN0RnVuY3Rpb24uanMiLCJ3ZWJwYWNrOi8vcGFyemVjLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fY2FzdFBhdGguanMiLCJ3ZWJwYWNrOi8vcGFyemVjLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fY2xvbmVBcnJheUJ1ZmZlci5qcyIsIndlYnBhY2s6Ly9wYXJ6ZWMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19jbG9uZUJ1ZmZlci5qcyIsIndlYnBhY2s6Ly9wYXJ6ZWMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19jbG9uZURhdGFWaWV3LmpzIiwid2VicGFjazovL3BhcnplYy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Nsb25lUmVnRXhwLmpzIiwid2VicGFjazovL3BhcnplYy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Nsb25lU3ltYm9sLmpzIiwid2VicGFjazovL3BhcnplYy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Nsb25lVHlwZWRBcnJheS5qcyIsIndlYnBhY2s6Ly9wYXJ6ZWMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19jb21wYXJlQXNjZW5kaW5nLmpzIiwid2VicGFjazovL3BhcnplYy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2NvbXBhcmVNdWx0aXBsZS5qcyIsIndlYnBhY2s6Ly9wYXJ6ZWMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19jb3B5QXJyYXkuanMiLCJ3ZWJwYWNrOi8vcGFyemVjLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fY29weU9iamVjdC5qcyIsIndlYnBhY2s6Ly9wYXJ6ZWMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19jb3B5U3ltYm9scy5qcyIsIndlYnBhY2s6Ly9wYXJ6ZWMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19jb3B5U3ltYm9sc0luLmpzIiwid2VicGFjazovL3BhcnplYy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2NvcmVKc0RhdGEuanMiLCJ3ZWJwYWNrOi8vcGFyemVjLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fY3JlYXRlQXNzaWduZXIuanMiLCJ3ZWJwYWNrOi8vcGFyemVjLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fY3JlYXRlQmFzZUVhY2guanMiLCJ3ZWJwYWNrOi8vcGFyemVjLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fY3JlYXRlQmFzZUZvci5qcyIsIndlYnBhY2s6Ly9wYXJ6ZWMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19jcmVhdGVGaW5kLmpzIiwid2VicGFjazovL3BhcnplYy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2NyZWF0ZVJhbmdlLmpzIiwid2VicGFjazovL3BhcnplYy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2NyZWF0ZVNldC5qcyIsIndlYnBhY2s6Ly9wYXJ6ZWMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19kZWZpbmVQcm9wZXJ0eS5qcyIsIndlYnBhY2s6Ly9wYXJ6ZWMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19lcXVhbEFycmF5cy5qcyIsIndlYnBhY2s6Ly9wYXJ6ZWMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19lcXVhbEJ5VGFnLmpzIiwid2VicGFjazovL3BhcnplYy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2VxdWFsT2JqZWN0cy5qcyIsIndlYnBhY2s6Ly9wYXJ6ZWMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19mbGF0UmVzdC5qcyIsIndlYnBhY2s6Ly9wYXJ6ZWMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19mcmVlR2xvYmFsLmpzIiwid2VicGFjazovL3BhcnplYy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2dldEFsbEtleXMuanMiLCJ3ZWJwYWNrOi8vcGFyemVjLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fZ2V0QWxsS2V5c0luLmpzIiwid2VicGFjazovL3BhcnplYy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2dldE1hcERhdGEuanMiLCJ3ZWJwYWNrOi8vcGFyemVjLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fZ2V0TWF0Y2hEYXRhLmpzIiwid2VicGFjazovL3BhcnplYy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2dldE5hdGl2ZS5qcyIsIndlYnBhY2s6Ly9wYXJ6ZWMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19nZXRQcm90b3R5cGUuanMiLCJ3ZWJwYWNrOi8vcGFyemVjLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fZ2V0UmF3VGFnLmpzIiwid2VicGFjazovL3BhcnplYy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2dldFN5bWJvbHMuanMiLCJ3ZWJwYWNrOi8vcGFyemVjLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fZ2V0U3ltYm9sc0luLmpzIiwid2VicGFjazovL3BhcnplYy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2dldFRhZy5qcyIsIndlYnBhY2s6Ly9wYXJ6ZWMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19nZXRWYWx1ZS5qcyIsIndlYnBhY2s6Ly9wYXJ6ZWMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19oYXNQYXRoLmpzIiwid2VicGFjazovL3BhcnplYy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2hhc1VuaWNvZGUuanMiLCJ3ZWJwYWNrOi8vcGFyemVjLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9faGFzaENsZWFyLmpzIiwid2VicGFjazovL3BhcnplYy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2hhc2hEZWxldGUuanMiLCJ3ZWJwYWNrOi8vcGFyemVjLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9faGFzaEdldC5qcyIsIndlYnBhY2s6Ly9wYXJ6ZWMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19oYXNoSGFzLmpzIiwid2VicGFjazovL3BhcnplYy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2hhc2hTZXQuanMiLCJ3ZWJwYWNrOi8vcGFyemVjLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9faW5pdENsb25lQXJyYXkuanMiLCJ3ZWJwYWNrOi8vcGFyemVjLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9faW5pdENsb25lQnlUYWcuanMiLCJ3ZWJwYWNrOi8vcGFyemVjLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9faW5pdENsb25lT2JqZWN0LmpzIiwid2VicGFjazovL3BhcnplYy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2lzRmxhdHRlbmFibGUuanMiLCJ3ZWJwYWNrOi8vcGFyemVjLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9faXNJbmRleC5qcyIsIndlYnBhY2s6Ly9wYXJ6ZWMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19pc0l0ZXJhdGVlQ2FsbC5qcyIsIndlYnBhY2s6Ly9wYXJ6ZWMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19pc0tleS5qcyIsIndlYnBhY2s6Ly9wYXJ6ZWMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19pc0tleWFibGUuanMiLCJ3ZWJwYWNrOi8vcGFyemVjLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9faXNNYXNrZWQuanMiLCJ3ZWJwYWNrOi8vcGFyemVjLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9faXNQcm90b3R5cGUuanMiLCJ3ZWJwYWNrOi8vcGFyemVjLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9faXNTdHJpY3RDb21wYXJhYmxlLmpzIiwid2VicGFjazovL3BhcnplYy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2xpc3RDYWNoZUNsZWFyLmpzIiwid2VicGFjazovL3BhcnplYy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2xpc3RDYWNoZURlbGV0ZS5qcyIsIndlYnBhY2s6Ly9wYXJ6ZWMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19saXN0Q2FjaGVHZXQuanMiLCJ3ZWJwYWNrOi8vcGFyemVjLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fbGlzdENhY2hlSGFzLmpzIiwid2VicGFjazovL3BhcnplYy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2xpc3RDYWNoZVNldC5qcyIsIndlYnBhY2s6Ly9wYXJ6ZWMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19tYXBDYWNoZUNsZWFyLmpzIiwid2VicGFjazovL3BhcnplYy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX21hcENhY2hlRGVsZXRlLmpzIiwid2VicGFjazovL3BhcnplYy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX21hcENhY2hlR2V0LmpzIiwid2VicGFjazovL3BhcnplYy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX21hcENhY2hlSGFzLmpzIiwid2VicGFjazovL3BhcnplYy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX21hcENhY2hlU2V0LmpzIiwid2VicGFjazovL3BhcnplYy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX21hcFRvQXJyYXkuanMiLCJ3ZWJwYWNrOi8vcGFyemVjLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fbWF0Y2hlc1N0cmljdENvbXBhcmFibGUuanMiLCJ3ZWJwYWNrOi8vcGFyemVjLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fbWVtb2l6ZUNhcHBlZC5qcyIsIndlYnBhY2s6Ly9wYXJ6ZWMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19uYXRpdmVDcmVhdGUuanMiLCJ3ZWJwYWNrOi8vcGFyemVjLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fbmF0aXZlS2V5cy5qcyIsIndlYnBhY2s6Ly9wYXJ6ZWMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19uYXRpdmVLZXlzSW4uanMiLCJ3ZWJwYWNrOi8vcGFyemVjLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fbm9kZVV0aWwuanMiLCJ3ZWJwYWNrOi8vcGFyemVjLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fb2JqZWN0VG9TdHJpbmcuanMiLCJ3ZWJwYWNrOi8vcGFyemVjLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fb3ZlckFyZy5qcyIsIndlYnBhY2s6Ly9wYXJ6ZWMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19vdmVyUmVzdC5qcyIsIndlYnBhY2s6Ly9wYXJ6ZWMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19yb290LmpzIiwid2VicGFjazovL3BhcnplYy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX3NhZmVHZXQuanMiLCJ3ZWJwYWNrOi8vcGFyemVjLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fc2V0Q2FjaGVBZGQuanMiLCJ3ZWJwYWNrOi8vcGFyemVjLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fc2V0Q2FjaGVIYXMuanMiLCJ3ZWJwYWNrOi8vcGFyemVjLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fc2V0VG9BcnJheS5qcyIsIndlYnBhY2s6Ly9wYXJ6ZWMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19zZXRUb1N0cmluZy5qcyIsIndlYnBhY2s6Ly9wYXJ6ZWMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19zaG9ydE91dC5qcyIsIndlYnBhY2s6Ly9wYXJ6ZWMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19zdGFja0NsZWFyLmpzIiwid2VicGFjazovL3BhcnplYy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX3N0YWNrRGVsZXRlLmpzIiwid2VicGFjazovL3BhcnplYy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX3N0YWNrR2V0LmpzIiwid2VicGFjazovL3BhcnplYy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX3N0YWNrSGFzLmpzIiwid2VicGFjazovL3BhcnplYy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX3N0YWNrU2V0LmpzIiwid2VicGFjazovL3BhcnplYy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX3N0cmljdEluZGV4T2YuanMiLCJ3ZWJwYWNrOi8vcGFyemVjLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fc3RyaW5nU2l6ZS5qcyIsIndlYnBhY2s6Ly9wYXJ6ZWMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19zdHJpbmdUb1BhdGguanMiLCJ3ZWJwYWNrOi8vcGFyemVjLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fdG9LZXkuanMiLCJ3ZWJwYWNrOi8vcGFyemVjLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fdG9Tb3VyY2UuanMiLCJ3ZWJwYWNrOi8vcGFyemVjLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fdHJpbW1lZEVuZEluZGV4LmpzIiwid2VicGFjazovL3BhcnplYy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX3VuaWNvZGVTaXplLmpzIiwid2VicGFjazovL3BhcnplYy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvY2xvbmUuanMiLCJ3ZWJwYWNrOi8vcGFyemVjLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9jbG9uZURlZXAuanMiLCJ3ZWJwYWNrOi8vcGFyemVjLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9jb25zdGFudC5qcyIsIndlYnBhY2s6Ly9wYXJ6ZWMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL2RlZmF1bHRzLmpzIiwid2VicGFjazovL3BhcnplYy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvZWFjaC5qcyIsIndlYnBhY2s6Ly9wYXJ6ZWMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL2VxLmpzIiwid2VicGFjazovL3BhcnplYy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvZmlsdGVyLmpzIiwid2VicGFjazovL3BhcnplYy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvZmluZC5qcyIsIndlYnBhY2s6Ly9wYXJ6ZWMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL2ZpbmRJbmRleC5qcyIsIndlYnBhY2s6Ly9wYXJ6ZWMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL2ZsYXR0ZW4uanMiLCJ3ZWJwYWNrOi8vcGFyemVjLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9mb3JFYWNoLmpzIiwid2VicGFjazovL3BhcnplYy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvZm9ySW4uanMiLCJ3ZWJwYWNrOi8vcGFyemVjLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9nZXQuanMiLCJ3ZWJwYWNrOi8vcGFyemVjLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9oYXMuanMiLCJ3ZWJwYWNrOi8vcGFyemVjLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9oYXNJbi5qcyIsIndlYnBhY2s6Ly9wYXJ6ZWMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL2lkZW50aXR5LmpzIiwid2VicGFjazovL3BhcnplYy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvaXNBcmd1bWVudHMuanMiLCJ3ZWJwYWNrOi8vcGFyemVjLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9pc0FycmF5LmpzIiwid2VicGFjazovL3BhcnplYy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvaXNBcnJheUxpa2UuanMiLCJ3ZWJwYWNrOi8vcGFyemVjLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9pc0FycmF5TGlrZU9iamVjdC5qcyIsIndlYnBhY2s6Ly9wYXJ6ZWMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL2lzQnVmZmVyLmpzIiwid2VicGFjazovL3BhcnplYy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvaXNFbXB0eS5qcyIsIndlYnBhY2s6Ly9wYXJ6ZWMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL2lzRnVuY3Rpb24uanMiLCJ3ZWJwYWNrOi8vcGFyemVjLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9pc0xlbmd0aC5qcyIsIndlYnBhY2s6Ly9wYXJ6ZWMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL2lzTWFwLmpzIiwid2VicGFjazovL3BhcnplYy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvaXNPYmplY3QuanMiLCJ3ZWJwYWNrOi8vcGFyemVjLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9pc09iamVjdExpa2UuanMiLCJ3ZWJwYWNrOi8vcGFyemVjLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9pc1BsYWluT2JqZWN0LmpzIiwid2VicGFjazovL3BhcnplYy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvaXNTZXQuanMiLCJ3ZWJwYWNrOi8vcGFyemVjLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9pc1N0cmluZy5qcyIsIndlYnBhY2s6Ly9wYXJ6ZWMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL2lzU3ltYm9sLmpzIiwid2VicGFjazovL3BhcnplYy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvaXNUeXBlZEFycmF5LmpzIiwid2VicGFjazovL3BhcnplYy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvaXNVbmRlZmluZWQuanMiLCJ3ZWJwYWNrOi8vcGFyemVjLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9rZXlzLmpzIiwid2VicGFjazovL3BhcnplYy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gva2V5c0luLmpzIiwid2VicGFjazovL3BhcnplYy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvbGFzdC5qcyIsIndlYnBhY2s6Ly9wYXJ6ZWMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL21hcC5qcyIsIndlYnBhY2s6Ly9wYXJ6ZWMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL21hcFZhbHVlcy5qcyIsIndlYnBhY2s6Ly9wYXJ6ZWMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL21heC5qcyIsIndlYnBhY2s6Ly9wYXJ6ZWMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL21lbW9pemUuanMiLCJ3ZWJwYWNrOi8vcGFyemVjLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9tZXJnZS5qcyIsIndlYnBhY2s6Ly9wYXJ6ZWMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL21pbi5qcyIsIndlYnBhY2s6Ly9wYXJ6ZWMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL21pbkJ5LmpzIiwid2VicGFjazovL3BhcnplYy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvbm9vcC5qcyIsIndlYnBhY2s6Ly9wYXJ6ZWMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL25vdy5qcyIsIndlYnBhY2s6Ly9wYXJ6ZWMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL3BpY2suanMiLCJ3ZWJwYWNrOi8vcGFyemVjLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9wcm9wZXJ0eS5qcyIsIndlYnBhY2s6Ly9wYXJ6ZWMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL3JhbmdlLmpzIiwid2VicGFjazovL3BhcnplYy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvcmVkdWNlLmpzIiwid2VicGFjazovL3BhcnplYy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvc2l6ZS5qcyIsIndlYnBhY2s6Ly9wYXJ6ZWMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL3NvcnRCeS5qcyIsIndlYnBhY2s6Ly9wYXJ6ZWMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL3N0dWJBcnJheS5qcyIsIndlYnBhY2s6Ly9wYXJ6ZWMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL3N0dWJGYWxzZS5qcyIsIndlYnBhY2s6Ly9wYXJ6ZWMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL3RvRmluaXRlLmpzIiwid2VicGFjazovL3BhcnplYy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvdG9JbnRlZ2VyLmpzIiwid2VicGFjazovL3BhcnplYy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvdG9OdW1iZXIuanMiLCJ3ZWJwYWNrOi8vcGFyemVjLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC90b1BsYWluT2JqZWN0LmpzIiwid2VicGFjazovL3BhcnplYy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvdG9TdHJpbmcuanMiLCJ3ZWJwYWNrOi8vcGFyemVjLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC90cmFuc2Zvcm0uanMiLCJ3ZWJwYWNrOi8vcGFyemVjLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC91bmlvbi5qcyIsIndlYnBhY2s6Ly9wYXJ6ZWMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL3VuaXF1ZUlkLmpzIiwid2VicGFjazovL3BhcnplYy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvdmFsdWVzLmpzIiwid2VicGFjazovL3BhcnplYy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvemlwT2JqZWN0LmpzIiwid2VicGFjazovL3BhcnplYy8uL3NyYy92aXN1YWxpemVycy9ydW4tZXhwci10ZXN0cy5sZXNzP2VkZTgiLCJ3ZWJwYWNrOi8vcGFyemVjLy4vbm9kZV9tb2R1bGVzL3RhaXR0by9saWIvYW5pbS9hbmltLmpzIiwid2VicGFjazovL3BhcnplYy8uL25vZGVfbW9kdWxlcy90YWl0dG8vbGliL2FuaW0vYW5pbWF0ZWQtdmlldy5qcyIsIndlYnBhY2s6Ly9wYXJ6ZWMvLi9ub2RlX21vZHVsZXMvdGFpdHRvL2xpYi9hbmltL2FuaW1hdGVkLmpzIiwid2VicGFjazovL3BhcnplYy8uL25vZGVfbW9kdWxlcy90YWl0dG8vbGliL2FuaW0vY3VzdG9tLWFuaW0uanMiLCJ3ZWJwYWNrOi8vcGFyemVjLy4vbm9kZV9tb2R1bGVzL3RhaXR0by9saWIvYW5pbS9pbmRleC5qcyIsIndlYnBhY2s6Ly9wYXJ6ZWMvLi9ub2RlX21vZHVsZXMvdGFpdHRvL2xpYi9hbmltL2tleWZyYW1lLWFuaW0uanMiLCJ3ZWJwYWNrOi8vcGFyemVjLy4vbm9kZV9tb2R1bGVzL3RhaXR0by9saWIvZGlncmFwaC5qcyIsIndlYnBhY2s6Ly9wYXJ6ZWMvLi9ub2RlX21vZHVsZXMvdGFpdHRvL2xpYi9maWxlLWRpYWdyYW0uanMiLCJ3ZWJwYWNrOi8vcGFyemVjLy4vbm9kZV9tb2R1bGVzL3RhaXR0by9saWIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vcGFyemVjLy4vbm9kZV9tb2R1bGVzL3RhaXR0by9saWIvc3ZnL2VsZW0uanMiLCJ3ZWJwYWNrOi8vcGFyemVjLy4vbm9kZV9tb2R1bGVzL3RhaXR0by9saWIvc3ZnL2ZpbHRlci5qcyIsIndlYnBhY2s6Ly9wYXJ6ZWMvLi9ub2RlX21vZHVsZXMvdGFpdHRvL2xpYi9zdmcvaW5kZXguanMiLCJ3ZWJwYWNrOi8vcGFyemVjLy4vbm9kZV9tb2R1bGVzL3RhaXR0by9saWIvc3ZnL21hcmtlci5qcyIsIndlYnBhY2s6Ly9wYXJ6ZWMvLi9ub2RlX21vZHVsZXMvdGFpdHRvL2xpYi9zdmcvcGF0aC5qcyIsIndlYnBhY2s6Ly9wYXJ6ZWMvLi9ub2RlX21vZHVsZXMvdGFpdHRvL2xpYi9zdmcvcmVjdC5qcyIsIndlYnBhY2s6Ly9wYXJ6ZWMvLi9ub2RlX21vZHVsZXMvdGFpdHRvL2xpYi9zdmcvdGV4dC5qcyIsIndlYnBhY2s6Ly9wYXJ6ZWMvLi9ub2RlX21vZHVsZXMvdGFpdHRvL2xpYi9zdmcvdmVjdG9yLmpzIiwid2VicGFjazovL3BhcnplYy8uL3NyYy9hcnJheXBhcnNlcnMudHMiLCJ3ZWJwYWNrOi8vcGFyemVjLy4vc3JjL2Vycm9yLnRzIiwid2VicGFjazovL3BhcnplYy8uL3NyYy9pbmRleC50cyIsIndlYnBhY2s6Ly9wYXJ6ZWMvLi9zcmMvaW5wdXQudHMiLCJ3ZWJwYWNrOi8vcGFyemVjLy4vc3JjL2xleGVyLnRzIiwid2VicGFjazovL3BhcnplYy8uL3NyYy9wYXJzZXIudHMiLCJ3ZWJwYWNrOi8vcGFyemVjLy4vc3JjL3JlZi50cyIsIndlYnBhY2s6Ly9wYXJ6ZWMvLi9zcmMvcmVzdWx0LnRzIiwid2VicGFjazovL3BhcnplYy8uL3NyYy90ZXN0L2V4cHJwYXJzZXIudHMiLCJ3ZWJwYWNrOi8vcGFyemVjLy4vc3JjL3Rlc3QvZXhwcnRlc3RzLnRzIiwid2VicGFjazovL3BhcnplYy8uL3NyYy91dGlscy50cyIsIndlYnBhY2s6Ly9wYXJ6ZWMvLi9ub2RlX21vZHVsZXMvem9yYS9kaXN0L2J1bmRsZS9pbmRleC5qcyIsIndlYnBhY2s6Ly9wYXJ6ZWMvLi9ub2RlX21vZHVsZXMvZmFzdC1jaGVjay9saWIvYXJiaXRyYXJ5L19pbnRlcm5hbHMvQXJyYXlBcmJpdHJhcnkuanMiLCJ3ZWJwYWNrOi8vcGFyemVjLy4vbm9kZV9tb2R1bGVzL2Zhc3QtY2hlY2svbGliL2FyYml0cmFyeS9faW50ZXJuYWxzL0JpZ0ludEFyYml0cmFyeS5qcyIsIndlYnBhY2s6Ly9wYXJ6ZWMvLi9ub2RlX21vZHVsZXMvZmFzdC1jaGVjay9saWIvYXJiaXRyYXJ5L19pbnRlcm5hbHMvQ2xvbmVBcmJpdHJhcnkuanMiLCJ3ZWJwYWNrOi8vcGFyemVjLy4vbm9kZV9tb2R1bGVzL2Zhc3QtY2hlY2svbGliL2FyYml0cmFyeS9faW50ZXJuYWxzL0NvbnN0YW50QXJiaXRyYXJ5LmpzIiwid2VicGFjazovL3BhcnplYy8uL25vZGVfbW9kdWxlcy9mYXN0LWNoZWNrL2xpYi9hcmJpdHJhcnkvX2ludGVybmFscy9GcmVxdWVuY3lBcmJpdHJhcnkuanMiLCJ3ZWJwYWNrOi8vcGFyemVjLy4vbm9kZV9tb2R1bGVzL2Zhc3QtY2hlY2svbGliL2FyYml0cmFyeS9faW50ZXJuYWxzL0ludGVnZXJBcmJpdHJhcnkuanMiLCJ3ZWJwYWNrOi8vcGFyemVjLy4vbm9kZV9tb2R1bGVzL2Zhc3QtY2hlY2svbGliL2FyYml0cmFyeS9faW50ZXJuYWxzL0xhenlBcmJpdHJhcnkuanMiLCJ3ZWJwYWNrOi8vcGFyemVjLy4vbm9kZV9tb2R1bGVzL2Zhc3QtY2hlY2svbGliL2FyYml0cmFyeS9faW50ZXJuYWxzL01peGVkQ2FzZUFyYml0cmFyeS5qcyIsIndlYnBhY2s6Ly9wYXJ6ZWMvLi9ub2RlX21vZHVsZXMvZmFzdC1jaGVjay9saWIvYXJiaXRyYXJ5L19pbnRlcm5hbHMvU2NoZWR1bGVyQXJiaXRyYXJ5LmpzIiwid2VicGFjazovL3BhcnplYy8uL25vZGVfbW9kdWxlcy9mYXN0LWNoZWNrL2xpYi9hcmJpdHJhcnkvX2ludGVybmFscy9TdHJlYW1BcmJpdHJhcnkuanMiLCJ3ZWJwYWNrOi8vcGFyemVjLy4vbm9kZV9tb2R1bGVzL2Zhc3QtY2hlY2svbGliL2FyYml0cmFyeS9faW50ZXJuYWxzL1R1cGxlQXJiaXRyYXJ5LmpzIiwid2VicGFjazovL3BhcnplYy8uL25vZGVfbW9kdWxlcy9mYXN0LWNoZWNrL2xpYi9hcmJpdHJhcnkvX2ludGVybmFscy9idWlsZGVycy9DaGFyYWN0ZXJBcmJpdHJhcnlCdWlsZGVyLmpzIiwid2VicGFjazovL3BhcnplYy8uL25vZGVfbW9kdWxlcy9mYXN0LWNoZWNrL2xpYi9hcmJpdHJhcnkvX2ludGVybmFscy9idWlsZGVycy9Db21wYXJlRnVuY3Rpb25BcmJpdHJhcnlCdWlsZGVyLmpzIiwid2VicGFjazovL3BhcnplYy8uL25vZGVfbW9kdWxlcy9mYXN0LWNoZWNrL2xpYi9hcmJpdHJhcnkvX2ludGVybmFscy9idWlsZGVycy9QYXJ0aWFsUmVjb3JkQXJiaXRyYXJ5QnVpbGRlci5qcyIsIndlYnBhY2s6Ly9wYXJ6ZWMvLi9ub2RlX21vZHVsZXMvZmFzdC1jaGVjay9saWIvYXJiaXRyYXJ5L19pbnRlcm5hbHMvYnVpbGRlcnMvU3RyaW5naWZpZWROYXRBcmJpdHJhcnlCdWlsZGVyLmpzIiwid2VicGFjazovL3BhcnplYy8uL25vZGVfbW9kdWxlcy9mYXN0LWNoZWNrL2xpYi9hcmJpdHJhcnkvX2ludGVybmFscy9idWlsZGVycy9UeXBlZEludEFycmF5QXJiaXRyYXJ5QnVpbGRlci5qcyIsIndlYnBhY2s6Ly9wYXJ6ZWMvLi9ub2RlX21vZHVsZXMvZmFzdC1jaGVjay9saWIvYXJiaXRyYXJ5L19pbnRlcm5hbHMvaGVscGVycy9CaWFzTnVtZXJpY1JhbmdlLmpzIiwid2VicGFjazovL3BhcnplYy8uL25vZGVfbW9kdWxlcy9mYXN0LWNoZWNrL2xpYi9hcmJpdHJhcnkvX2ludGVybmFscy9oZWxwZXJzL0J1aWxkQ29tcGFyZUZpbHRlci5qcyIsIndlYnBhY2s6Ly9wYXJ6ZWMvLi9ub2RlX21vZHVsZXMvZmFzdC1jaGVjay9saWIvYXJiaXRyYXJ5L19pbnRlcm5hbHMvaGVscGVycy9CdWlsZFNjaGVkdWxlckZvci5qcyIsIndlYnBhY2s6Ly9wYXJ6ZWMvLi9ub2RlX21vZHVsZXMvZmFzdC1jaGVjay9saWIvYXJiaXRyYXJ5L19pbnRlcm5hbHMvaGVscGVycy9EZXB0aENvbnRleHQuanMiLCJ3ZWJwYWNrOi8vcGFyemVjLy4vbm9kZV9tb2R1bGVzL2Zhc3QtY2hlY2svbGliL2FyYml0cmFyeS9faW50ZXJuYWxzL2hlbHBlcnMvRW51bWVyYWJsZUtleXNFeHRyYWN0b3IuanMiLCJ3ZWJwYWNrOi8vcGFyemVjLy4vbm9kZV9tb2R1bGVzL2Zhc3QtY2hlY2svbGliL2FyYml0cmFyeS9faW50ZXJuYWxzL2hlbHBlcnMvTWF4TGVuZ3RoRnJvbU1pbkxlbmd0aC5qcyIsIndlYnBhY2s6Ly9wYXJ6ZWMvLi9ub2RlX21vZHVsZXMvZmFzdC1jaGVjay9saWIvYXJiaXRyYXJ5L19pbnRlcm5hbHMvaGVscGVycy9TaHJpbmtCaWdJbnQuanMiLCJ3ZWJwYWNrOi8vcGFyemVjLy4vbm9kZV9tb2R1bGVzL2Zhc3QtY2hlY2svbGliL2FyYml0cmFyeS9faW50ZXJuYWxzL2hlbHBlcnMvU2hyaW5rSW50ZWdlci5qcyIsIndlYnBhY2s6Ly9wYXJ6ZWMvLi9ub2RlX21vZHVsZXMvZmFzdC1jaGVjay9saWIvYXJiaXRyYXJ5L19pbnRlcm5hbHMvaGVscGVycy9TdHJpbmdDb25zdHJhaW50c0V4dHJhY3Rvci5qcyIsIndlYnBhY2s6Ly9wYXJ6ZWMvLi9ub2RlX21vZHVsZXMvZmFzdC1jaGVjay9saWIvYXJiaXRyYXJ5L19pbnRlcm5hbHMvaW1wbGVtZW50YXRpb25zL1NjaGVkdWxlckltcGxlbS5qcyIsIndlYnBhY2s6Ly9wYXJ6ZWMvLi9ub2RlX21vZHVsZXMvZmFzdC1jaGVjay9saWIvYXJiaXRyYXJ5L19pbnRlcm5hbHMvbWFwcGVycy9DaGFyc1RvU3RyaW5nLmpzIiwid2VicGFjazovL3BhcnplYy8uL25vZGVfbW9kdWxlcy9mYXN0LWNoZWNrL2xpYi9hcmJpdHJhcnkvX2ludGVybmFscy9tYXBwZXJzL0NvZGVQb2ludHNUb1N0cmluZy5qcyIsIndlYnBhY2s6Ly9wYXJ6ZWMvLi9ub2RlX21vZHVsZXMvZmFzdC1jaGVjay9saWIvYXJiaXRyYXJ5L19pbnRlcm5hbHMvbWFwcGVycy9FbnRpdGllc1RvSVB2Ni5qcyIsIndlYnBhY2s6Ly9wYXJ6ZWMvLi9ub2RlX21vZHVsZXMvZmFzdC1jaGVjay9saWIvYXJiaXRyYXJ5L19pbnRlcm5hbHMvbWFwcGVycy9JbmRleFRvQ2hhclN0cmluZy5qcyIsIndlYnBhY2s6Ly9wYXJ6ZWMvLi9ub2RlX21vZHVsZXMvZmFzdC1jaGVjay9saWIvYXJiaXRyYXJ5L19pbnRlcm5hbHMvbWFwcGVycy9JbmRleFRvTWFwcGVkQ29uc3RhbnQuanMiLCJ3ZWJwYWNrOi8vcGFyemVjLy4vbm9kZV9tb2R1bGVzL2Zhc3QtY2hlY2svbGliL2FyYml0cmFyeS9faW50ZXJuYWxzL21hcHBlcnMvSW5kZXhUb1ByaW50YWJsZUluZGV4LmpzIiwid2VicGFjazovL3BhcnplYy8uL25vZGVfbW9kdWxlcy9mYXN0LWNoZWNrL2xpYi9hcmJpdHJhcnkvX2ludGVybmFscy9tYXBwZXJzL0tleVZhbHVlUGFpcnNUb09iamVjdC5qcyIsIndlYnBhY2s6Ly9wYXJ6ZWMvLi9ub2RlX21vZHVsZXMvZmFzdC1jaGVjay9saWIvYXJiaXRyYXJ5L19pbnRlcm5hbHMvbWFwcGVycy9OYXRUb1N0cmluZ2lmaWVkTmF0LmpzIiwid2VicGFjazovL3BhcnplYy8uL25vZGVfbW9kdWxlcy9mYXN0LWNoZWNrL2xpYi9hcmJpdHJhcnkvX2ludGVybmFscy9tYXBwZXJzL1BhdHRlcm5zVG9TdHJpbmcuanMiLCJ3ZWJwYWNrOi8vcGFyemVjLy4vbm9kZV9tb2R1bGVzL2Zhc3QtY2hlY2svbGliL2FyYml0cmFyeS9faW50ZXJuYWxzL21hcHBlcnMvU3RyaW5nVG9CYXNlNjQuanMiLCJ3ZWJwYWNrOi8vcGFyemVjLy4vbm9kZV9tb2R1bGVzL2Zhc3QtY2hlY2svbGliL2FyYml0cmFyeS9faW50ZXJuYWxzL21hcHBlcnMvVGltZVRvRGF0ZS5qcyIsIndlYnBhY2s6Ly9wYXJ6ZWMvLi9ub2RlX21vZHVsZXMvZmFzdC1jaGVjay9saWIvYXJiaXRyYXJ5L19pbnRlcm5hbHMvbWFwcGVycy9WYWx1ZXNBbmRTZXBhcmF0ZUtleXNUb09iamVjdC5qcyIsIndlYnBhY2s6Ly9wYXJ6ZWMvLi9ub2RlX21vZHVsZXMvZmFzdC1jaGVjay9saWIvYXJiaXRyYXJ5L19pbnRlcm5hbHMvbWFwcGVycy9Xb3Jkc1RvTG9yZW0uanMiLCJ3ZWJwYWNrOi8vcGFyemVjLy4vbm9kZV9tb2R1bGVzL2Zhc3QtY2hlY2svbGliL2FyYml0cmFyeS9hcnJheS5qcyIsIndlYnBhY2s6Ly9wYXJ6ZWMvLi9ub2RlX21vZHVsZXMvZmFzdC1jaGVjay9saWIvYXJiaXRyYXJ5L2FzY2lpLmpzIiwid2VicGFjazovL3BhcnplYy8uL25vZGVfbW9kdWxlcy9mYXN0LWNoZWNrL2xpYi9hcmJpdHJhcnkvYXNjaWlTdHJpbmcuanMiLCJ3ZWJwYWNrOi8vcGFyemVjLy4vbm9kZV9tb2R1bGVzL2Zhc3QtY2hlY2svbGliL2FyYml0cmFyeS9iYXNlNjQuanMiLCJ3ZWJwYWNrOi8vcGFyemVjLy4vbm9kZV9tb2R1bGVzL2Zhc3QtY2hlY2svbGliL2FyYml0cmFyeS9iYXNlNjRTdHJpbmcuanMiLCJ3ZWJwYWNrOi8vcGFyemVjLy4vbm9kZV9tb2R1bGVzL2Zhc3QtY2hlY2svbGliL2FyYml0cmFyeS9iaWdJbnQuanMiLCJ3ZWJwYWNrOi8vcGFyemVjLy4vbm9kZV9tb2R1bGVzL2Zhc3QtY2hlY2svbGliL2FyYml0cmFyeS9iaWdJbnROLmpzIiwid2VicGFjazovL3BhcnplYy8uL25vZGVfbW9kdWxlcy9mYXN0LWNoZWNrL2xpYi9hcmJpdHJhcnkvYmlnVWludC5qcyIsIndlYnBhY2s6Ly9wYXJ6ZWMvLi9ub2RlX21vZHVsZXMvZmFzdC1jaGVjay9saWIvYXJiaXRyYXJ5L2JpZ1VpbnROLmpzIiwid2VicGFjazovL3BhcnplYy8uL25vZGVfbW9kdWxlcy9mYXN0LWNoZWNrL2xpYi9hcmJpdHJhcnkvYm9vbGVhbi5qcyIsIndlYnBhY2s6Ly9wYXJ6ZWMvLi9ub2RlX21vZHVsZXMvZmFzdC1jaGVjay9saWIvYXJiaXRyYXJ5L2NoYXIuanMiLCJ3ZWJwYWNrOi8vcGFyemVjLy4vbm9kZV9tb2R1bGVzL2Zhc3QtY2hlY2svbGliL2FyYml0cmFyeS9jaGFyMTZiaXRzLmpzIiwid2VicGFjazovL3BhcnplYy8uL25vZGVfbW9kdWxlcy9mYXN0LWNoZWNrL2xpYi9hcmJpdHJhcnkvY2xvbmUuanMiLCJ3ZWJwYWNrOi8vcGFyemVjLy4vbm9kZV9tb2R1bGVzL2Zhc3QtY2hlY2svbGliL2FyYml0cmFyeS9jbG9uZWRDb25zdGFudC5qcyIsIndlYnBhY2s6Ly9wYXJ6ZWMvLi9ub2RlX21vZHVsZXMvZmFzdC1jaGVjay9saWIvYXJiaXRyYXJ5L2NvbXBhcmVCb29sZWFuRnVuYy5qcyIsIndlYnBhY2s6Ly9wYXJ6ZWMvLi9ub2RlX21vZHVsZXMvZmFzdC1jaGVjay9saWIvYXJiaXRyYXJ5L2NvbXBhcmVGdW5jLmpzIiwid2VicGFjazovL3BhcnplYy8uL25vZGVfbW9kdWxlcy9mYXN0LWNoZWNrL2xpYi9hcmJpdHJhcnkvY29uc3RhbnQuanMiLCJ3ZWJwYWNrOi8vcGFyemVjLy4vbm9kZV9tb2R1bGVzL2Zhc3QtY2hlY2svbGliL2FyYml0cmFyeS9jb25zdGFudEZyb20uanMiLCJ3ZWJwYWNrOi8vcGFyemVjLy4vbm9kZV9tb2R1bGVzL2Zhc3QtY2hlY2svbGliL2FyYml0cmFyeS9jb250ZXh0LmpzIiwid2VicGFjazovL3BhcnplYy8uL25vZGVfbW9kdWxlcy9mYXN0LWNoZWNrL2xpYi9hcmJpdHJhcnkvZGF0ZS5qcyIsIndlYnBhY2s6Ly9wYXJ6ZWMvLi9ub2RlX21vZHVsZXMvZmFzdC1jaGVjay9saWIvYXJiaXRyYXJ5L2RlZHVwLmpzIiwid2VicGFjazovL3BhcnplYy8uL25vZGVfbW9kdWxlcy9mYXN0LWNoZWNrL2xpYi9hcmJpdHJhcnkvZGljdGlvbmFyeS5qcyIsIndlYnBhY2s6Ly9wYXJ6ZWMvLi9ub2RlX21vZHVsZXMvZmFzdC1jaGVjay9saWIvYXJiaXRyYXJ5L2ZhbHN5LmpzIiwid2VicGFjazovL3BhcnplYy8uL25vZGVfbW9kdWxlcy9mYXN0LWNoZWNrL2xpYi9hcmJpdHJhcnkvZmxvYXQzMkFycmF5LmpzIiwid2VicGFjazovL3BhcnplYy8uL25vZGVfbW9kdWxlcy9mYXN0LWNoZWNrL2xpYi9hcmJpdHJhcnkvZmxvYXQ2NEFycmF5LmpzIiwid2VicGFjazovL3BhcnplYy8uL25vZGVfbW9kdWxlcy9mYXN0LWNoZWNrL2xpYi9hcmJpdHJhcnkvZnJlcXVlbmN5LmpzIiwid2VicGFjazovL3BhcnplYy8uL25vZGVfbW9kdWxlcy9mYXN0LWNoZWNrL2xpYi9hcmJpdHJhcnkvZnVsbFVuaWNvZGUuanMiLCJ3ZWJwYWNrOi8vcGFyemVjLy4vbm9kZV9tb2R1bGVzL2Zhc3QtY2hlY2svbGliL2FyYml0cmFyeS9mdWxsVW5pY29kZVN0cmluZy5qcyIsIndlYnBhY2s6Ly9wYXJ6ZWMvLi9ub2RlX21vZHVsZXMvZmFzdC1jaGVjay9saWIvYXJiaXRyYXJ5L2Z1bmMuanMiLCJ3ZWJwYWNrOi8vcGFyemVjLy4vbm9kZV9tb2R1bGVzL2Zhc3QtY2hlY2svbGliL2FyYml0cmFyeS9nZW5lcmljVHVwbGUuanMiLCJ3ZWJwYWNrOi8vcGFyemVjLy4vbm9kZV9tb2R1bGVzL2Zhc3QtY2hlY2svbGliL2FyYml0cmFyeS9oZXhhLmpzIiwid2VicGFjazovL3BhcnplYy8uL25vZGVfbW9kdWxlcy9mYXN0LWNoZWNrL2xpYi9hcmJpdHJhcnkvaGV4YVN0cmluZy5qcyIsIndlYnBhY2s6Ly9wYXJ6ZWMvLi9ub2RlX21vZHVsZXMvZmFzdC1jaGVjay9saWIvYXJiaXRyYXJ5L2luZmluaXRlU3RyZWFtLmpzIiwid2VicGFjazovL3BhcnplYy8uL25vZGVfbW9kdWxlcy9mYXN0LWNoZWNrL2xpYi9hcmJpdHJhcnkvaW50MTZBcnJheS5qcyIsIndlYnBhY2s6Ly9wYXJ6ZWMvLi9ub2RlX21vZHVsZXMvZmFzdC1jaGVjay9saWIvYXJiaXRyYXJ5L2ludDMyQXJyYXkuanMiLCJ3ZWJwYWNrOi8vcGFyemVjLy4vbm9kZV9tb2R1bGVzL2Zhc3QtY2hlY2svbGliL2FyYml0cmFyeS9pbnQ4QXJyYXkuanMiLCJ3ZWJwYWNrOi8vcGFyemVjLy4vbm9kZV9tb2R1bGVzL2Zhc3QtY2hlY2svbGliL2FyYml0cmFyeS9pbnRlZ2VyLmpzIiwid2VicGFjazovL3BhcnplYy8uL25vZGVfbW9kdWxlcy9mYXN0LWNoZWNrL2xpYi9hcmJpdHJhcnkvaXBWNC5qcyIsIndlYnBhY2s6Ly9wYXJ6ZWMvLi9ub2RlX21vZHVsZXMvZmFzdC1jaGVjay9saWIvYXJiaXRyYXJ5L2lwVjRFeHRlbmRlZC5qcyIsIndlYnBhY2s6Ly9wYXJ6ZWMvLi9ub2RlX21vZHVsZXMvZmFzdC1jaGVjay9saWIvYXJiaXRyYXJ5L2lwVjYuanMiLCJ3ZWJwYWNrOi8vcGFyemVjLy4vbm9kZV9tb2R1bGVzL2Zhc3QtY2hlY2svbGliL2FyYml0cmFyeS9sZXRyZWMuanMiLCJ3ZWJwYWNrOi8vcGFyemVjLy4vbm9kZV9tb2R1bGVzL2Zhc3QtY2hlY2svbGliL2FyYml0cmFyeS9sb3JlbS5qcyIsIndlYnBhY2s6Ly9wYXJ6ZWMvLi9ub2RlX21vZHVsZXMvZmFzdC1jaGVjay9saWIvYXJiaXRyYXJ5L21hcFRvQ29uc3RhbnQuanMiLCJ3ZWJwYWNrOi8vcGFyemVjLy4vbm9kZV9tb2R1bGVzL2Zhc3QtY2hlY2svbGliL2FyYml0cmFyeS9tYXhTYWZlSW50ZWdlci5qcyIsIndlYnBhY2s6Ly9wYXJ6ZWMvLi9ub2RlX21vZHVsZXMvZmFzdC1jaGVjay9saWIvYXJiaXRyYXJ5L21heFNhZmVOYXQuanMiLCJ3ZWJwYWNrOi8vcGFyemVjLy4vbm9kZV9tb2R1bGVzL2Zhc3QtY2hlY2svbGliL2FyYml0cmFyeS9tZW1vLmpzIiwid2VicGFjazovL3BhcnplYy8uL25vZGVfbW9kdWxlcy9mYXN0LWNoZWNrL2xpYi9hcmJpdHJhcnkvbWl4ZWRDYXNlLmpzIiwid2VicGFjazovL3BhcnplYy8uL25vZGVfbW9kdWxlcy9mYXN0LWNoZWNrL2xpYi9hcmJpdHJhcnkvbmF0LmpzIiwid2VicGFjazovL3BhcnplYy8uL25vZGVfbW9kdWxlcy9mYXN0LWNoZWNrL2xpYi9hcmJpdHJhcnkvb25lb2YuanMiLCJ3ZWJwYWNrOi8vcGFyemVjLy4vbm9kZV9tb2R1bGVzL2Zhc3QtY2hlY2svbGliL2FyYml0cmFyeS9vcHRpb24uanMiLCJ3ZWJwYWNrOi8vcGFyemVjLy4vbm9kZV9tb2R1bGVzL2Zhc3QtY2hlY2svbGliL2FyYml0cmFyeS9yZWNvcmQuanMiLCJ3ZWJwYWNrOi8vcGFyemVjLy4vbm9kZV9tb2R1bGVzL2Zhc3QtY2hlY2svbGliL2FyYml0cmFyeS9zY2hlZHVsZXIuanMiLCJ3ZWJwYWNrOi8vcGFyemVjLy4vbm9kZV9tb2R1bGVzL2Zhc3QtY2hlY2svbGliL2FyYml0cmFyeS9zZXQuanMiLCJ3ZWJwYWNrOi8vcGFyemVjLy4vbm9kZV9tb2R1bGVzL2Zhc3QtY2hlY2svbGliL2FyYml0cmFyeS9zdHJpbmcuanMiLCJ3ZWJwYWNrOi8vcGFyemVjLy4vbm9kZV9tb2R1bGVzL2Zhc3QtY2hlY2svbGliL2FyYml0cmFyeS9zdHJpbmcxNmJpdHMuanMiLCJ3ZWJwYWNrOi8vcGFyemVjLy4vbm9kZV9tb2R1bGVzL2Zhc3QtY2hlY2svbGliL2FyYml0cmFyeS9zdHJpbmdPZi5qcyIsIndlYnBhY2s6Ly9wYXJ6ZWMvLi9ub2RlX21vZHVsZXMvZmFzdC1jaGVjay9saWIvYXJiaXRyYXJ5L3R1cGxlLmpzIiwid2VicGFjazovL3BhcnplYy8uL25vZGVfbW9kdWxlcy9mYXN0LWNoZWNrL2xpYi9hcmJpdHJhcnkvdWludDE2QXJyYXkuanMiLCJ3ZWJwYWNrOi8vcGFyemVjLy4vbm9kZV9tb2R1bGVzL2Zhc3QtY2hlY2svbGliL2FyYml0cmFyeS91aW50MzJBcnJheS5qcyIsIndlYnBhY2s6Ly9wYXJ6ZWMvLi9ub2RlX21vZHVsZXMvZmFzdC1jaGVjay9saWIvYXJiaXRyYXJ5L3VpbnQ4QXJyYXkuanMiLCJ3ZWJwYWNrOi8vcGFyemVjLy4vbm9kZV9tb2R1bGVzL2Zhc3QtY2hlY2svbGliL2FyYml0cmFyeS91aW50OENsYW1wZWRBcnJheS5qcyIsIndlYnBhY2s6Ly9wYXJ6ZWMvLi9ub2RlX21vZHVsZXMvZmFzdC1jaGVjay9saWIvYXJiaXRyYXJ5L3VuaWNvZGUuanMiLCJ3ZWJwYWNrOi8vcGFyemVjLy4vbm9kZV9tb2R1bGVzL2Zhc3QtY2hlY2svbGliL2FyYml0cmFyeS91bmljb2RlU3RyaW5nLmpzIiwid2VicGFjazovL3BhcnplYy8uL25vZGVfbW9kdWxlcy9mYXN0LWNoZWNrL2xpYi9jaGVjay9hcmJpdHJhcnkvRG91YmxlTmV4dEFyYml0cmFyeS5qcyIsIndlYnBhY2s6Ly9wYXJ6ZWMvLi9ub2RlX21vZHVsZXMvZmFzdC1jaGVjay9saWIvY2hlY2svYXJiaXRyYXJ5L0VtYWlsQXJiaXRyYXJ5LmpzIiwid2VicGFjazovL3BhcnplYy8uL25vZGVfbW9kdWxlcy9mYXN0LWNoZWNrL2xpYi9jaGVjay9hcmJpdHJhcnkvRmxvYXROZXh0QXJiaXRyYXJ5LmpzIiwid2VicGFjazovL3BhcnplYy8uL25vZGVfbW9kdWxlcy9mYXN0LWNoZWNrL2xpYi9jaGVjay9hcmJpdHJhcnkvRmxvYXRpbmdQb2ludEFyYml0cmFyeS5qcyIsIndlYnBhY2s6Ly9wYXJ6ZWMvLi9ub2RlX21vZHVsZXMvZmFzdC1jaGVjay9saWIvY2hlY2svYXJiaXRyYXJ5L0hvc3RBcmJpdHJhcnkuanMiLCJ3ZWJwYWNrOi8vcGFyemVjLy4vbm9kZV9tb2R1bGVzL2Zhc3QtY2hlY2svbGliL2NoZWNrL2FyYml0cmFyeS9PYmplY3RBcmJpdHJhcnkuanMiLCJ3ZWJwYWNrOi8vcGFyemVjLy4vbm9kZV9tb2R1bGVzL2Zhc3QtY2hlY2svbGliL2NoZWNrL2FyYml0cmFyeS9TcGFyc2VBcnJheUFyYml0cmFyeS5qcyIsIndlYnBhY2s6Ly9wYXJ6ZWMvLi9ub2RlX21vZHVsZXMvZmFzdC1jaGVjay9saWIvY2hlY2svYXJiaXRyYXJ5L1N1YmFycmF5QXJiaXRyYXJ5LmpzIiwid2VicGFjazovL3BhcnplYy8uL25vZGVfbW9kdWxlcy9mYXN0LWNoZWNrL2xpYi9jaGVjay9hcmJpdHJhcnkvVXVpZEFyYml0cmFyeS5qcyIsIndlYnBhY2s6Ly9wYXJ6ZWMvLi9ub2RlX21vZHVsZXMvZmFzdC1jaGVjay9saWIvY2hlY2svYXJiaXRyYXJ5L1dlYkFyYml0cmFyeS5qcyIsIndlYnBhY2s6Ly9wYXJ6ZWMvLi9ub2RlX21vZHVsZXMvZmFzdC1jaGVjay9saWIvY2hlY2svYXJiaXRyYXJ5L2RlZmluaXRpb24vQXJiaXRyYXJ5LmpzIiwid2VicGFjazovL3BhcnplYy8uL25vZGVfbW9kdWxlcy9mYXN0LWNoZWNrL2xpYi9jaGVjay9hcmJpdHJhcnkvZGVmaW5pdGlvbi9BcmJpdHJhcnlXaXRoQ29udGV4dHVhbFNocmluay5qcyIsIndlYnBhY2s6Ly9wYXJ6ZWMvLi9ub2RlX21vZHVsZXMvZmFzdC1jaGVjay9saWIvY2hlY2svYXJiaXRyYXJ5L2RlZmluaXRpb24vQXJiaXRyYXJ5V2l0aFNocmluay5qcyIsIndlYnBhY2s6Ly9wYXJ6ZWMvLi9ub2RlX21vZHVsZXMvZmFzdC1jaGVjay9saWIvY2hlY2svYXJiaXRyYXJ5L2RlZmluaXRpb24vQmlhc2VkQXJiaXRyYXJ5V3JhcHBlci5qcyIsIndlYnBhY2s6Ly9wYXJ6ZWMvLi9ub2RlX21vZHVsZXMvZmFzdC1jaGVjay9saWIvY2hlY2svYXJiaXRyYXJ5L2RlZmluaXRpb24vQ29udmVydGVyRnJvbU5leHQuanMiLCJ3ZWJwYWNrOi8vcGFyemVjLy4vbm9kZV9tb2R1bGVzL2Zhc3QtY2hlY2svbGliL2NoZWNrL2FyYml0cmFyeS9kZWZpbml0aW9uL0NvbnZlcnRlclRvTmV4dC5qcyIsIndlYnBhY2s6Ly9wYXJ6ZWMvLi9ub2RlX21vZHVsZXMvZmFzdC1jaGVjay9saWIvY2hlY2svYXJiaXRyYXJ5L2RlZmluaXRpb24vQ29udmVydGVycy5qcyIsIndlYnBhY2s6Ly9wYXJ6ZWMvLi9ub2RlX21vZHVsZXMvZmFzdC1jaGVjay9saWIvY2hlY2svYXJiaXRyYXJ5L2RlZmluaXRpb24vTmV4dEFyYml0cmFyeS5qcyIsIndlYnBhY2s6Ly9wYXJ6ZWMvLi9ub2RlX21vZHVsZXMvZmFzdC1jaGVjay9saWIvY2hlY2svYXJiaXRyYXJ5L2RlZmluaXRpb24vTmV4dFZhbHVlLmpzIiwid2VicGFjazovL3BhcnplYy8uL25vZGVfbW9kdWxlcy9mYXN0LWNoZWNrL2xpYi9jaGVjay9hcmJpdHJhcnkvZGVmaW5pdGlvbi9TaHJpbmthYmxlLmpzIiwid2VicGFjazovL3BhcnplYy8uL25vZGVfbW9kdWxlcy9mYXN0LWNoZWNrL2xpYi9jaGVjay9hcmJpdHJhcnkvaGVscGVycy9BcnJheUludDY0LmpzIiwid2VicGFjazovL3BhcnplYy8uL25vZGVfbW9kdWxlcy9mYXN0LWNoZWNrL2xpYi9jaGVjay9hcmJpdHJhcnkvaGVscGVycy9BcnJheUludDY0QXJiaXRyYXJ5LmpzIiwid2VicGFjazovL3BhcnplYy8uL25vZGVfbW9kdWxlcy9mYXN0LWNoZWNrL2xpYi9jaGVjay9hcmJpdHJhcnkvaGVscGVycy9TcGVjaWZpY0NoYXJhY3RlclJhbmdlLmpzIiwid2VicGFjazovL3BhcnplYy8uL25vZGVfbW9kdWxlcy9mYXN0LWNoZWNrL2xpYi9jaGVjay9hcmJpdHJhcnkvaGVscGVycy9UZXh0RXNjYXBlci5qcyIsIndlYnBhY2s6Ly9wYXJ6ZWMvLi9ub2RlX21vZHVsZXMvZmFzdC1jaGVjay9saWIvY2hlY2svbW9kZWwvTW9kZWxSdW5uZXIuanMiLCJ3ZWJwYWNrOi8vcGFyemVjLy4vbm9kZV9tb2R1bGVzL2Zhc3QtY2hlY2svbGliL2NoZWNrL21vZGVsL1JlcGxheVBhdGguanMiLCJ3ZWJwYWNrOi8vcGFyemVjLy4vbm9kZV9tb2R1bGVzL2Zhc3QtY2hlY2svbGliL2NoZWNrL21vZGVsL2NvbW1hbmRzL0NvbW1hbmRXcmFwcGVyLmpzIiwid2VicGFjazovL3BhcnplYy8uL25vZGVfbW9kdWxlcy9mYXN0LWNoZWNrL2xpYi9jaGVjay9tb2RlbC9jb21tYW5kcy9Db21tYW5kc0FyYml0cmFyeS5qcyIsIndlYnBhY2s6Ly9wYXJ6ZWMvLi9ub2RlX21vZHVsZXMvZmFzdC1jaGVjay9saWIvY2hlY2svbW9kZWwvY29tbWFuZHMvQ29tbWFuZHNJdGVyYWJsZS5qcyIsIndlYnBhY2s6Ly9wYXJ6ZWMvLi9ub2RlX21vZHVsZXMvZmFzdC1jaGVjay9saWIvY2hlY2svbW9kZWwvY29tbWFuZHMvU2NoZWR1bGVkQ29tbWFuZC5qcyIsIndlYnBhY2s6Ly9wYXJ6ZWMvLi9ub2RlX21vZHVsZXMvZmFzdC1jaGVjay9saWIvY2hlY2svcHJlY29uZGl0aW9uL1ByZS5qcyIsIndlYnBhY2s6Ly9wYXJ6ZWMvLi9ub2RlX21vZHVsZXMvZmFzdC1jaGVjay9saWIvY2hlY2svcHJlY29uZGl0aW9uL1ByZWNvbmRpdGlvbkZhaWx1cmUuanMiLCJ3ZWJwYWNrOi8vcGFyemVjLy4vbm9kZV9tb2R1bGVzL2Zhc3QtY2hlY2svbGliL2NoZWNrL3Byb3BlcnR5L0FzeW5jUHJvcGVydHkuZ2VuZXJhdGVkLmpzIiwid2VicGFjazovL3BhcnplYy8uL25vZGVfbW9kdWxlcy9mYXN0LWNoZWNrL2xpYi9jaGVjay9wcm9wZXJ0eS9Bc3luY1Byb3BlcnR5LmdlbmVyaWMuanMiLCJ3ZWJwYWNrOi8vcGFyemVjLy4vbm9kZV9tb2R1bGVzL2Zhc3QtY2hlY2svbGliL2NoZWNrL3Byb3BlcnR5L0FzeW5jUHJvcGVydHkuanMiLCJ3ZWJwYWNrOi8vcGFyemVjLy4vbm9kZV9tb2R1bGVzL2Zhc3QtY2hlY2svbGliL2NoZWNrL3Byb3BlcnR5L0lSYXdQcm9wZXJ0eS5qcyIsIndlYnBhY2s6Ly9wYXJ6ZWMvLi9ub2RlX21vZHVsZXMvZmFzdC1jaGVjay9saWIvY2hlY2svcHJvcGVydHkvSWdub3JlRXF1YWxWYWx1ZXNQcm9wZXJ0eS5qcyIsIndlYnBhY2s6Ly9wYXJ6ZWMvLi9ub2RlX21vZHVsZXMvZmFzdC1jaGVjay9saWIvY2hlY2svcHJvcGVydHkvUHJvcGVydHkuZ2VuZXJhdGVkLmpzIiwid2VicGFjazovL3BhcnplYy8uL25vZGVfbW9kdWxlcy9mYXN0LWNoZWNrL2xpYi9jaGVjay9wcm9wZXJ0eS9Qcm9wZXJ0eS5nZW5lcmljLmpzIiwid2VicGFjazovL3BhcnplYy8uL25vZGVfbW9kdWxlcy9mYXN0LWNoZWNrL2xpYi9jaGVjay9wcm9wZXJ0eS9Qcm9wZXJ0eS5qcyIsIndlYnBhY2s6Ly9wYXJ6ZWMvLi9ub2RlX21vZHVsZXMvZmFzdC1jaGVjay9saWIvY2hlY2svcHJvcGVydHkvU2tpcEFmdGVyUHJvcGVydHkuanMiLCJ3ZWJwYWNrOi8vcGFyemVjLy4vbm9kZV9tb2R1bGVzL2Zhc3QtY2hlY2svbGliL2NoZWNrL3Byb3BlcnR5L1RpbWVvdXRQcm9wZXJ0eS5qcyIsIndlYnBhY2s6Ly9wYXJ6ZWMvLi9ub2RlX21vZHVsZXMvZmFzdC1jaGVjay9saWIvY2hlY2svcHJvcGVydHkvVW5iaWFzZWRQcm9wZXJ0eS5qcyIsIndlYnBhY2s6Ly9wYXJ6ZWMvLi9ub2RlX21vZHVsZXMvZmFzdC1jaGVjay9saWIvY2hlY2svcnVubmVyL0RlY29yYXRlUHJvcGVydHkuanMiLCJ3ZWJwYWNrOi8vcGFyemVjLy4vbm9kZV9tb2R1bGVzL2Zhc3QtY2hlY2svbGliL2NoZWNrL3J1bm5lci9SdW5uZXIuanMiLCJ3ZWJwYWNrOi8vcGFyemVjLy4vbm9kZV9tb2R1bGVzL2Zhc3QtY2hlY2svbGliL2NoZWNrL3J1bm5lci9SdW5uZXJJdGVyYXRvci5qcyIsIndlYnBhY2s6Ly9wYXJ6ZWMvLi9ub2RlX21vZHVsZXMvZmFzdC1jaGVjay9saWIvY2hlY2svcnVubmVyL1NhbXBsZXIuanMiLCJ3ZWJwYWNrOi8vcGFyemVjLy4vbm9kZV9tb2R1bGVzL2Zhc3QtY2hlY2svbGliL2NoZWNrL3J1bm5lci9Tb3VyY2VWYWx1ZXNJdGVyYXRvci5qcyIsIndlYnBhY2s6Ly9wYXJ6ZWMvLi9ub2RlX21vZHVsZXMvZmFzdC1jaGVjay9saWIvY2hlY2svcnVubmVyL1Rvc3Nlci5qcyIsIndlYnBhY2s6Ly9wYXJ6ZWMvLi9ub2RlX21vZHVsZXMvZmFzdC1jaGVjay9saWIvY2hlY2svcnVubmVyL2NvbmZpZ3VyYXRpb24vR2xvYmFsUGFyYW1ldGVycy5qcyIsIndlYnBhY2s6Ly9wYXJ6ZWMvLi9ub2RlX21vZHVsZXMvZmFzdC1jaGVjay9saWIvY2hlY2svcnVubmVyL2NvbmZpZ3VyYXRpb24vUXVhbGlmaWVkUGFyYW1ldGVycy5qcyIsIndlYnBhY2s6Ly9wYXJ6ZWMvLi9ub2RlX21vZHVsZXMvZmFzdC1jaGVjay9saWIvY2hlY2svcnVubmVyL2NvbmZpZ3VyYXRpb24vVmVyYm9zaXR5TGV2ZWwuanMiLCJ3ZWJwYWNrOi8vcGFyemVjLy4vbm9kZV9tb2R1bGVzL2Zhc3QtY2hlY2svbGliL2NoZWNrL3J1bm5lci9yZXBvcnRlci9FeGVjdXRpb25TdGF0dXMuanMiLCJ3ZWJwYWNrOi8vcGFyemVjLy4vbm9kZV9tb2R1bGVzL2Zhc3QtY2hlY2svbGliL2NoZWNrL3J1bm5lci9yZXBvcnRlci9SdW5FeGVjdXRpb24uanMiLCJ3ZWJwYWNrOi8vcGFyemVjLy4vbm9kZV9tb2R1bGVzL2Zhc3QtY2hlY2svbGliL2NoZWNrL3J1bm5lci91dGlscy9QYXRoV2Fsa2VyLmpzIiwid2VicGFjazovL3BhcnplYy8uL25vZGVfbW9kdWxlcy9mYXN0LWNoZWNrL2xpYi9jaGVjay9ydW5uZXIvdXRpbHMvUnVuRGV0YWlsc0Zvcm1hdHRlci5qcyIsIndlYnBhY2s6Ly9wYXJ6ZWMvLi9ub2RlX21vZHVsZXMvZmFzdC1jaGVjay9saWIvY2hlY2svc3ltYm9scy5qcyIsIndlYnBhY2s6Ly9wYXJ6ZWMvLi9ub2RlX21vZHVsZXMvZmFzdC1jaGVjay9saWIvZmFzdC1jaGVjay1kZWZhdWx0LmpzIiwid2VicGFjazovL3BhcnplYy8uL25vZGVfbW9kdWxlcy9mYXN0LWNoZWNrL2xpYi9mYXN0LWNoZWNrLmpzIiwid2VicGFjazovL3BhcnplYy8uL25vZGVfbW9kdWxlcy9mYXN0LWNoZWNrL2xpYi9yYW5kb20vZ2VuZXJhdG9yL1B1cmVSYW5kb20uanMiLCJ3ZWJwYWNrOi8vcGFyemVjLy4vbm9kZV9tb2R1bGVzL2Zhc3QtY2hlY2svbGliL3JhbmRvbS9nZW5lcmF0b3IvUmFuZG9tLmpzIiwid2VicGFjazovL3BhcnplYy8uL25vZGVfbW9kdWxlcy9mYXN0LWNoZWNrL2xpYi9zdHJlYW0vTGF6eUl0ZXJhYmxlSXRlcmF0b3IuanMiLCJ3ZWJwYWNrOi8vcGFyemVjLy4vbm9kZV9tb2R1bGVzL2Zhc3QtY2hlY2svbGliL3N0cmVhbS9TdHJlYW0uanMiLCJ3ZWJwYWNrOi8vcGFyemVjLy4vbm9kZV9tb2R1bGVzL2Zhc3QtY2hlY2svbGliL3N0cmVhbS9TdHJlYW1IZWxwZXJzLmpzIiwid2VicGFjazovL3BhcnplYy8uL25vZGVfbW9kdWxlcy9mYXN0LWNoZWNrL2xpYi91dGlscy9oYXNoLmpzIiwid2VicGFjazovL3BhcnplYy8uL25vZGVfbW9kdWxlcy9mYXN0LWNoZWNrL2xpYi91dGlscy9zdHJpbmdpZnkuanMiLCJ3ZWJwYWNrOi8vcGFyemVjLy4vbm9kZV9tb2R1bGVzL3B1cmUtcmFuZC9saWIvZGlzdHJpYnV0aW9uL1VuaWZvcm1BcnJheUludERpc3RyaWJ1dGlvbi5qcyIsIndlYnBhY2s6Ly9wYXJ6ZWMvLi9ub2RlX21vZHVsZXMvcHVyZS1yYW5kL2xpYi9kaXN0cmlidXRpb24vVW5pZm9ybUJpZ0ludERpc3RyaWJ1dGlvbi5qcyIsIndlYnBhY2s6Ly9wYXJ6ZWMvLi9ub2RlX21vZHVsZXMvcHVyZS1yYW5kL2xpYi9kaXN0cmlidXRpb24vVW5pZm9ybUludERpc3RyaWJ1dGlvbi5qcyIsIndlYnBhY2s6Ly9wYXJ6ZWMvLi9ub2RlX21vZHVsZXMvcHVyZS1yYW5kL2xpYi9kaXN0cmlidXRpb24vVW5zYWZlVW5pZm9ybUFycmF5SW50RGlzdHJpYnV0aW9uLmpzIiwid2VicGFjazovL3BhcnplYy8uL25vZGVfbW9kdWxlcy9wdXJlLXJhbmQvbGliL2Rpc3RyaWJ1dGlvbi9VbnNhZmVVbmlmb3JtQmlnSW50RGlzdHJpYnV0aW9uLmpzIiwid2VicGFjazovL3BhcnplYy8uL25vZGVfbW9kdWxlcy9wdXJlLXJhbmQvbGliL2Rpc3RyaWJ1dGlvbi9VbnNhZmVVbmlmb3JtSW50RGlzdHJpYnV0aW9uLmpzIiwid2VicGFjazovL3BhcnplYy8uL25vZGVfbW9kdWxlcy9wdXJlLXJhbmQvbGliL2Rpc3RyaWJ1dGlvbi9pbnRlcm5hbHMvQXJyYXlJbnQuanMiLCJ3ZWJwYWNrOi8vcGFyemVjLy4vbm9kZV9tb2R1bGVzL3B1cmUtcmFuZC9saWIvZGlzdHJpYnV0aW9uL2ludGVybmFscy9VbnNhZmVVbmlmb3JtQXJyYXlJbnREaXN0cmlidXRpb25JbnRlcm5hbC5qcyIsIndlYnBhY2s6Ly9wYXJ6ZWMvLi9ub2RlX21vZHVsZXMvcHVyZS1yYW5kL2xpYi9kaXN0cmlidXRpb24vaW50ZXJuYWxzL1Vuc2FmZVVuaWZvcm1JbnREaXN0cmlidXRpb25JbnRlcm5hbC5qcyIsIndlYnBhY2s6Ly9wYXJ6ZWMvLi9ub2RlX21vZHVsZXMvcHVyZS1yYW5kL2xpYi9nZW5lcmF0b3IvTGluZWFyQ29uZ3J1ZW50aWFsLmpzIiwid2VicGFjazovL3BhcnplYy8uL25vZGVfbW9kdWxlcy9wdXJlLXJhbmQvbGliL2dlbmVyYXRvci9NZXJzZW5uZVR3aXN0ZXIuanMiLCJ3ZWJwYWNrOi8vcGFyemVjLy4vbm9kZV9tb2R1bGVzL3B1cmUtcmFuZC9saWIvZ2VuZXJhdG9yL1JhbmRvbUdlbmVyYXRvci5qcyIsIndlYnBhY2s6Ly9wYXJ6ZWMvLi9ub2RlX21vZHVsZXMvcHVyZS1yYW5kL2xpYi9nZW5lcmF0b3IvWG9yU2hpZnQuanMiLCJ3ZWJwYWNrOi8vcGFyemVjLy4vbm9kZV9tb2R1bGVzL3B1cmUtcmFuZC9saWIvZ2VuZXJhdG9yL1hvcm9TaGlyby5qcyIsIndlYnBhY2s6Ly9wYXJ6ZWMvLi9ub2RlX21vZHVsZXMvcHVyZS1yYW5kL2xpYi9wdXJlLXJhbmQtZGVmYXVsdC5qcyIsIndlYnBhY2s6Ly9wYXJ6ZWMvLi9ub2RlX21vZHVsZXMvcHVyZS1yYW5kL2xpYi9wdXJlLXJhbmQuanMiLCJ3ZWJwYWNrOi8vcGFyemVjL3dlYnBhY2svYm9vdHN0cmFwIiwid2VicGFjazovL3BhcnplYy93ZWJwYWNrL3J1bnRpbWUvZ2xvYmFsIiwid2VicGFjazovL3BhcnplYy93ZWJwYWNrL3J1bnRpbWUvbWFrZSBuYW1lc3BhY2Ugb2JqZWN0Iiwid2VicGFjazovL3BhcnplYy93ZWJwYWNrL3J1bnRpbWUvbm9kZSBtb2R1bGUgZGVjb3JhdG9yIiwid2VicGFjazovL3BhcnplYy8uL3NyYy92aXN1YWxpemVycy9ydW4tZXhwci10ZXN0cy50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuQ29weXJpZ2h0IChjKSAyMDEyLTIwMTQgQ2hyaXMgUGV0dGl0dFxuXG5QZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG5vZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG5pbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG50byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG5jb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbmZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG5cblRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG5hbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cblxuVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG5GSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbkFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbkxJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG5PVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG5USEUgU09GVFdBUkUuXG4qL1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgZ3JhcGhsaWI6IHJlcXVpcmUoXCIuL2xpYi9ncmFwaGxpYlwiKSxcblxuICBsYXlvdXQ6IHJlcXVpcmUoXCIuL2xpYi9sYXlvdXRcIiksXG4gIGRlYnVnOiByZXF1aXJlKFwiLi9saWIvZGVidWdcIiksXG4gIHV0aWw6IHtcbiAgICB0aW1lOiByZXF1aXJlKFwiLi9saWIvdXRpbFwiKS50aW1lLFxuICAgIG5vdGltZTogcmVxdWlyZShcIi4vbGliL3V0aWxcIikubm90aW1lXG4gIH0sXG4gIHZlcnNpb246IHJlcXVpcmUoXCIuL2xpYi92ZXJzaW9uXCIpXG59O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfID0gcmVxdWlyZShcIi4vbG9kYXNoXCIpO1xudmFyIGdyZWVkeUZBUyA9IHJlcXVpcmUoXCIuL2dyZWVkeS1mYXNcIik7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBydW46IHJ1bixcbiAgdW5kbzogdW5kb1xufTtcblxuZnVuY3Rpb24gcnVuKGcpIHtcbiAgdmFyIGZhcyA9IChnLmdyYXBoKCkuYWN5Y2xpY2VyID09PSBcImdyZWVkeVwiXG4gICAgPyBncmVlZHlGQVMoZywgd2VpZ2h0Rm4oZykpXG4gICAgOiBkZnNGQVMoZykpO1xuICBfLmZvckVhY2goZmFzLCBmdW5jdGlvbihlKSB7XG4gICAgdmFyIGxhYmVsID0gZy5lZGdlKGUpO1xuICAgIGcucmVtb3ZlRWRnZShlKTtcbiAgICBsYWJlbC5mb3J3YXJkTmFtZSA9IGUubmFtZTtcbiAgICBsYWJlbC5yZXZlcnNlZCA9IHRydWU7XG4gICAgZy5zZXRFZGdlKGUudywgZS52LCBsYWJlbCwgXy51bmlxdWVJZChcInJldlwiKSk7XG4gIH0pO1xuXG4gIGZ1bmN0aW9uIHdlaWdodEZuKGcpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oZSkge1xuICAgICAgcmV0dXJuIGcuZWRnZShlKS53ZWlnaHQ7XG4gICAgfTtcbiAgfVxufVxuXG5mdW5jdGlvbiBkZnNGQVMoZykge1xuICB2YXIgZmFzID0gW107XG4gIHZhciBzdGFjayA9IHt9O1xuICB2YXIgdmlzaXRlZCA9IHt9O1xuXG4gIGZ1bmN0aW9uIGRmcyh2KSB7XG4gICAgaWYgKF8uaGFzKHZpc2l0ZWQsIHYpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZpc2l0ZWRbdl0gPSB0cnVlO1xuICAgIHN0YWNrW3ZdID0gdHJ1ZTtcbiAgICBfLmZvckVhY2goZy5vdXRFZGdlcyh2KSwgZnVuY3Rpb24oZSkge1xuICAgICAgaWYgKF8uaGFzKHN0YWNrLCBlLncpKSB7XG4gICAgICAgIGZhcy5wdXNoKGUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGZzKGUudyk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgZGVsZXRlIHN0YWNrW3ZdO1xuICB9XG5cbiAgXy5mb3JFYWNoKGcubm9kZXMoKSwgZGZzKTtcbiAgcmV0dXJuIGZhcztcbn1cblxuZnVuY3Rpb24gdW5kbyhnKSB7XG4gIF8uZm9yRWFjaChnLmVkZ2VzKCksIGZ1bmN0aW9uKGUpIHtcbiAgICB2YXIgbGFiZWwgPSBnLmVkZ2UoZSk7XG4gICAgaWYgKGxhYmVsLnJldmVyc2VkKSB7XG4gICAgICBnLnJlbW92ZUVkZ2UoZSk7XG5cbiAgICAgIHZhciBmb3J3YXJkTmFtZSA9IGxhYmVsLmZvcndhcmROYW1lO1xuICAgICAgZGVsZXRlIGxhYmVsLnJldmVyc2VkO1xuICAgICAgZGVsZXRlIGxhYmVsLmZvcndhcmROYW1lO1xuICAgICAgZy5zZXRFZGdlKGUudywgZS52LCBsYWJlbCwgZm9yd2FyZE5hbWUpO1xuICAgIH1cbiAgfSk7XG59XG4iLCJ2YXIgXyA9IHJlcXVpcmUoXCIuL2xvZGFzaFwiKTtcbnZhciB1dGlsID0gcmVxdWlyZShcIi4vdXRpbFwiKTtcblxubW9kdWxlLmV4cG9ydHMgPSBhZGRCb3JkZXJTZWdtZW50cztcblxuZnVuY3Rpb24gYWRkQm9yZGVyU2VnbWVudHMoZykge1xuICBmdW5jdGlvbiBkZnModikge1xuICAgIHZhciBjaGlsZHJlbiA9IGcuY2hpbGRyZW4odik7XG4gICAgdmFyIG5vZGUgPSBnLm5vZGUodik7XG4gICAgaWYgKGNoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgXy5mb3JFYWNoKGNoaWxkcmVuLCBkZnMpO1xuICAgIH1cblxuICAgIGlmIChfLmhhcyhub2RlLCBcIm1pblJhbmtcIikpIHtcbiAgICAgIG5vZGUuYm9yZGVyTGVmdCA9IFtdO1xuICAgICAgbm9kZS5ib3JkZXJSaWdodCA9IFtdO1xuICAgICAgZm9yICh2YXIgcmFuayA9IG5vZGUubWluUmFuaywgbWF4UmFuayA9IG5vZGUubWF4UmFuayArIDE7XG4gICAgICAgIHJhbmsgPCBtYXhSYW5rO1xuICAgICAgICArK3JhbmspIHtcbiAgICAgICAgYWRkQm9yZGVyTm9kZShnLCBcImJvcmRlckxlZnRcIiwgXCJfYmxcIiwgdiwgbm9kZSwgcmFuayk7XG4gICAgICAgIGFkZEJvcmRlck5vZGUoZywgXCJib3JkZXJSaWdodFwiLCBcIl9iclwiLCB2LCBub2RlLCByYW5rKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBfLmZvckVhY2goZy5jaGlsZHJlbigpLCBkZnMpO1xufVxuXG5mdW5jdGlvbiBhZGRCb3JkZXJOb2RlKGcsIHByb3AsIHByZWZpeCwgc2csIHNnTm9kZSwgcmFuaykge1xuICB2YXIgbGFiZWwgPSB7IHdpZHRoOiAwLCBoZWlnaHQ6IDAsIHJhbms6IHJhbmssIGJvcmRlclR5cGU6IHByb3AgfTtcbiAgdmFyIHByZXYgPSBzZ05vZGVbcHJvcF1bcmFuayAtIDFdO1xuICB2YXIgY3VyciA9IHV0aWwuYWRkRHVtbXlOb2RlKGcsIFwiYm9yZGVyXCIsIGxhYmVsLCBwcmVmaXgpO1xuICBzZ05vZGVbcHJvcF1bcmFua10gPSBjdXJyO1xuICBnLnNldFBhcmVudChjdXJyLCBzZyk7XG4gIGlmIChwcmV2KSB7XG4gICAgZy5zZXRFZGdlKHByZXYsIGN1cnIsIHsgd2VpZ2h0OiAxIH0pO1xuICB9XG59XG4iLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIF8gPSByZXF1aXJlKFwiLi9sb2Rhc2hcIik7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBhZGp1c3Q6IGFkanVzdCxcbiAgdW5kbzogdW5kb1xufTtcblxuZnVuY3Rpb24gYWRqdXN0KGcpIHtcbiAgdmFyIHJhbmtEaXIgPSBnLmdyYXBoKCkucmFua2Rpci50b0xvd2VyQ2FzZSgpO1xuICBpZiAocmFua0RpciA9PT0gXCJsclwiIHx8IHJhbmtEaXIgPT09IFwicmxcIikge1xuICAgIHN3YXBXaWR0aEhlaWdodChnKTtcbiAgfVxufVxuXG5mdW5jdGlvbiB1bmRvKGcpIHtcbiAgdmFyIHJhbmtEaXIgPSBnLmdyYXBoKCkucmFua2Rpci50b0xvd2VyQ2FzZSgpO1xuICBpZiAocmFua0RpciA9PT0gXCJidFwiIHx8IHJhbmtEaXIgPT09IFwicmxcIikge1xuICAgIHJldmVyc2VZKGcpO1xuICB9XG5cbiAgaWYgKHJhbmtEaXIgPT09IFwibHJcIiB8fCByYW5rRGlyID09PSBcInJsXCIpIHtcbiAgICBzd2FwWFkoZyk7XG4gICAgc3dhcFdpZHRoSGVpZ2h0KGcpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHN3YXBXaWR0aEhlaWdodChnKSB7XG4gIF8uZm9yRWFjaChnLm5vZGVzKCksIGZ1bmN0aW9uKHYpIHsgc3dhcFdpZHRoSGVpZ2h0T25lKGcubm9kZSh2KSk7IH0pO1xuICBfLmZvckVhY2goZy5lZGdlcygpLCBmdW5jdGlvbihlKSB7IHN3YXBXaWR0aEhlaWdodE9uZShnLmVkZ2UoZSkpOyB9KTtcbn1cblxuZnVuY3Rpb24gc3dhcFdpZHRoSGVpZ2h0T25lKGF0dHJzKSB7XG4gIHZhciB3ID0gYXR0cnMud2lkdGg7XG4gIGF0dHJzLndpZHRoID0gYXR0cnMuaGVpZ2h0O1xuICBhdHRycy5oZWlnaHQgPSB3O1xufVxuXG5mdW5jdGlvbiByZXZlcnNlWShnKSB7XG4gIF8uZm9yRWFjaChnLm5vZGVzKCksIGZ1bmN0aW9uKHYpIHsgcmV2ZXJzZVlPbmUoZy5ub2RlKHYpKTsgfSk7XG5cbiAgXy5mb3JFYWNoKGcuZWRnZXMoKSwgZnVuY3Rpb24oZSkge1xuICAgIHZhciBlZGdlID0gZy5lZGdlKGUpO1xuICAgIF8uZm9yRWFjaChlZGdlLnBvaW50cywgcmV2ZXJzZVlPbmUpO1xuICAgIGlmIChfLmhhcyhlZGdlLCBcInlcIikpIHtcbiAgICAgIHJldmVyc2VZT25lKGVkZ2UpO1xuICAgIH1cbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHJldmVyc2VZT25lKGF0dHJzKSB7XG4gIGF0dHJzLnkgPSAtYXR0cnMueTtcbn1cblxuZnVuY3Rpb24gc3dhcFhZKGcpIHtcbiAgXy5mb3JFYWNoKGcubm9kZXMoKSwgZnVuY3Rpb24odikgeyBzd2FwWFlPbmUoZy5ub2RlKHYpKTsgfSk7XG5cbiAgXy5mb3JFYWNoKGcuZWRnZXMoKSwgZnVuY3Rpb24oZSkge1xuICAgIHZhciBlZGdlID0gZy5lZGdlKGUpO1xuICAgIF8uZm9yRWFjaChlZGdlLnBvaW50cywgc3dhcFhZT25lKTtcbiAgICBpZiAoXy5oYXMoZWRnZSwgXCJ4XCIpKSB7XG4gICAgICBzd2FwWFlPbmUoZWRnZSk7XG4gICAgfVxuICB9KTtcbn1cblxuZnVuY3Rpb24gc3dhcFhZT25lKGF0dHJzKSB7XG4gIHZhciB4ID0gYXR0cnMueDtcbiAgYXR0cnMueCA9IGF0dHJzLnk7XG4gIGF0dHJzLnkgPSB4O1xufVxuIiwiLypcbiAqIFNpbXBsZSBkb3VibHkgbGlua2VkIGxpc3QgaW1wbGVtZW50YXRpb24gZGVyaXZlZCBmcm9tIENvcm1lbiwgZXQgYWwuLFxuICogXCJJbnRyb2R1Y3Rpb24gdG8gQWxnb3JpdGhtc1wiLlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gTGlzdDtcblxuZnVuY3Rpb24gTGlzdCgpIHtcbiAgdmFyIHNlbnRpbmVsID0ge307XG4gIHNlbnRpbmVsLl9uZXh0ID0gc2VudGluZWwuX3ByZXYgPSBzZW50aW5lbDtcbiAgdGhpcy5fc2VudGluZWwgPSBzZW50aW5lbDtcbn1cblxuTGlzdC5wcm90b3R5cGUuZGVxdWV1ZSA9IGZ1bmN0aW9uKCkge1xuICB2YXIgc2VudGluZWwgPSB0aGlzLl9zZW50aW5lbDtcbiAgdmFyIGVudHJ5ID0gc2VudGluZWwuX3ByZXY7XG4gIGlmIChlbnRyeSAhPT0gc2VudGluZWwpIHtcbiAgICB1bmxpbmsoZW50cnkpO1xuICAgIHJldHVybiBlbnRyeTtcbiAgfVxufTtcblxuTGlzdC5wcm90b3R5cGUuZW5xdWV1ZSA9IGZ1bmN0aW9uKGVudHJ5KSB7XG4gIHZhciBzZW50aW5lbCA9IHRoaXMuX3NlbnRpbmVsO1xuICBpZiAoZW50cnkuX3ByZXYgJiYgZW50cnkuX25leHQpIHtcbiAgICB1bmxpbmsoZW50cnkpO1xuICB9XG4gIGVudHJ5Ll9uZXh0ID0gc2VudGluZWwuX25leHQ7XG4gIHNlbnRpbmVsLl9uZXh0Ll9wcmV2ID0gZW50cnk7XG4gIHNlbnRpbmVsLl9uZXh0ID0gZW50cnk7XG4gIGVudHJ5Ll9wcmV2ID0gc2VudGluZWw7XG59O1xuXG5MaXN0LnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICB2YXIgc3RycyA9IFtdO1xuICB2YXIgc2VudGluZWwgPSB0aGlzLl9zZW50aW5lbDtcbiAgdmFyIGN1cnIgPSBzZW50aW5lbC5fcHJldjtcbiAgd2hpbGUgKGN1cnIgIT09IHNlbnRpbmVsKSB7XG4gICAgc3Rycy5wdXNoKEpTT04uc3RyaW5naWZ5KGN1cnIsIGZpbHRlck91dExpbmtzKSk7XG4gICAgY3VyciA9IGN1cnIuX3ByZXY7XG4gIH1cbiAgcmV0dXJuIFwiW1wiICsgc3Rycy5qb2luKFwiLCBcIikgKyBcIl1cIjtcbn07XG5cbmZ1bmN0aW9uIHVubGluayhlbnRyeSkge1xuICBlbnRyeS5fcHJldi5fbmV4dCA9IGVudHJ5Ll9uZXh0O1xuICBlbnRyeS5fbmV4dC5fcHJldiA9IGVudHJ5Ll9wcmV2O1xuICBkZWxldGUgZW50cnkuX25leHQ7XG4gIGRlbGV0ZSBlbnRyeS5fcHJldjtcbn1cblxuZnVuY3Rpb24gZmlsdGVyT3V0TGlua3Moaywgdikge1xuICBpZiAoayAhPT0gXCJfbmV4dFwiICYmIGsgIT09IFwiX3ByZXZcIikge1xuICAgIHJldHVybiB2O1xuICB9XG59XG4iLCJ2YXIgXyA9IHJlcXVpcmUoXCIuL2xvZGFzaFwiKTtcbnZhciB1dGlsID0gcmVxdWlyZShcIi4vdXRpbFwiKTtcbnZhciBHcmFwaCA9IHJlcXVpcmUoXCIuL2dyYXBobGliXCIpLkdyYXBoO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgZGVidWdPcmRlcmluZzogZGVidWdPcmRlcmluZ1xufTtcblxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbmZ1bmN0aW9uIGRlYnVnT3JkZXJpbmcoZykge1xuICB2YXIgbGF5ZXJNYXRyaXggPSB1dGlsLmJ1aWxkTGF5ZXJNYXRyaXgoZyk7XG5cbiAgdmFyIGggPSBuZXcgR3JhcGgoeyBjb21wb3VuZDogdHJ1ZSwgbXVsdGlncmFwaDogdHJ1ZSB9KS5zZXRHcmFwaCh7fSk7XG5cbiAgXy5mb3JFYWNoKGcubm9kZXMoKSwgZnVuY3Rpb24odikge1xuICAgIGguc2V0Tm9kZSh2LCB7IGxhYmVsOiB2IH0pO1xuICAgIGguc2V0UGFyZW50KHYsIFwibGF5ZXJcIiArIGcubm9kZSh2KS5yYW5rKTtcbiAgfSk7XG5cbiAgXy5mb3JFYWNoKGcuZWRnZXMoKSwgZnVuY3Rpb24oZSkge1xuICAgIGguc2V0RWRnZShlLnYsIGUudywge30sIGUubmFtZSk7XG4gIH0pO1xuXG4gIF8uZm9yRWFjaChsYXllck1hdHJpeCwgZnVuY3Rpb24obGF5ZXIsIGkpIHtcbiAgICB2YXIgbGF5ZXJWID0gXCJsYXllclwiICsgaTtcbiAgICBoLnNldE5vZGUobGF5ZXJWLCB7IHJhbms6IFwic2FtZVwiIH0pO1xuICAgIF8ucmVkdWNlKGxheWVyLCBmdW5jdGlvbih1LCB2KSB7XG4gICAgICBoLnNldEVkZ2UodSwgdiwgeyBzdHlsZTogXCJpbnZpc1wiIH0pO1xuICAgICAgcmV0dXJuIHY7XG4gICAgfSk7XG4gIH0pO1xuXG4gIHJldHVybiBoO1xufVxuIiwiLyogZ2xvYmFsIHdpbmRvdyAqL1xuXG52YXIgZ3JhcGhsaWI7XG5cbmlmICh0eXBlb2YgcmVxdWlyZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gIHRyeSB7XG4gICAgZ3JhcGhsaWIgPSByZXF1aXJlKFwiZ3JhcGhsaWJcIik7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICAvLyBjb250aW51ZSByZWdhcmRsZXNzIG9mIGVycm9yXG4gIH1cbn1cblxuaWYgKCFncmFwaGxpYikge1xuICBncmFwaGxpYiA9IHdpbmRvdy5ncmFwaGxpYjtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBncmFwaGxpYjtcbiIsInZhciBfID0gcmVxdWlyZShcIi4vbG9kYXNoXCIpO1xudmFyIEdyYXBoID0gcmVxdWlyZShcIi4vZ3JhcGhsaWJcIikuR3JhcGg7XG52YXIgTGlzdCA9IHJlcXVpcmUoXCIuL2RhdGEvbGlzdFwiKTtcblxuLypcbiAqIEEgZ3JlZWR5IGhldXJpc3RpYyBmb3IgZmluZGluZyBhIGZlZWRiYWNrIGFyYyBzZXQgZm9yIGEgZ3JhcGguIEEgZmVlZGJhY2tcbiAqIGFyYyBzZXQgaXMgYSBzZXQgb2YgZWRnZXMgdGhhdCBjYW4gYmUgcmVtb3ZlZCB0byBtYWtlIGEgZ3JhcGggYWN5Y2xpYy5cbiAqIFRoZSBhbGdvcml0aG0gY29tZXMgZnJvbTogUC4gRWFkZXMsIFguIExpbiwgYW5kIFcuIEYuIFNteXRoLCBcIkEgZmFzdCBhbmRcbiAqIGVmZmVjdGl2ZSBoZXVyaXN0aWMgZm9yIHRoZSBmZWVkYmFjayBhcmMgc2V0IHByb2JsZW0uXCIgVGhpcyBpbXBsZW1lbnRhdGlvblxuICogYWRqdXN0cyB0aGF0IGZyb20gdGhlIHBhcGVyIHRvIGFsbG93IGZvciB3ZWlnaHRlZCBlZGdlcy5cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBncmVlZHlGQVM7XG5cbnZhciBERUZBVUxUX1dFSUdIVF9GTiA9IF8uY29uc3RhbnQoMSk7XG5cbmZ1bmN0aW9uIGdyZWVkeUZBUyhnLCB3ZWlnaHRGbikge1xuICBpZiAoZy5ub2RlQ291bnQoKSA8PSAxKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG4gIHZhciBzdGF0ZSA9IGJ1aWxkU3RhdGUoZywgd2VpZ2h0Rm4gfHwgREVGQVVMVF9XRUlHSFRfRk4pO1xuICB2YXIgcmVzdWx0cyA9IGRvR3JlZWR5RkFTKHN0YXRlLmdyYXBoLCBzdGF0ZS5idWNrZXRzLCBzdGF0ZS56ZXJvSWR4KTtcblxuICAvLyBFeHBhbmQgbXVsdGktZWRnZXNcbiAgcmV0dXJuIF8uZmxhdHRlbihfLm1hcChyZXN1bHRzLCBmdW5jdGlvbihlKSB7XG4gICAgcmV0dXJuIGcub3V0RWRnZXMoZS52LCBlLncpO1xuICB9KSwgdHJ1ZSk7XG59XG5cbmZ1bmN0aW9uIGRvR3JlZWR5RkFTKGcsIGJ1Y2tldHMsIHplcm9JZHgpIHtcbiAgdmFyIHJlc3VsdHMgPSBbXTtcbiAgdmFyIHNvdXJjZXMgPSBidWNrZXRzW2J1Y2tldHMubGVuZ3RoIC0gMV07XG4gIHZhciBzaW5rcyA9IGJ1Y2tldHNbMF07XG5cbiAgdmFyIGVudHJ5O1xuICB3aGlsZSAoZy5ub2RlQ291bnQoKSkge1xuICAgIHdoaWxlICgoZW50cnkgPSBzaW5rcy5kZXF1ZXVlKCkpKSAgIHsgcmVtb3ZlTm9kZShnLCBidWNrZXRzLCB6ZXJvSWR4LCBlbnRyeSk7IH1cbiAgICB3aGlsZSAoKGVudHJ5ID0gc291cmNlcy5kZXF1ZXVlKCkpKSB7IHJlbW92ZU5vZGUoZywgYnVja2V0cywgemVyb0lkeCwgZW50cnkpOyB9XG4gICAgaWYgKGcubm9kZUNvdW50KCkpIHtcbiAgICAgIGZvciAodmFyIGkgPSBidWNrZXRzLmxlbmd0aCAtIDI7IGkgPiAwOyAtLWkpIHtcbiAgICAgICAgZW50cnkgPSBidWNrZXRzW2ldLmRlcXVldWUoKTtcbiAgICAgICAgaWYgKGVudHJ5KSB7XG4gICAgICAgICAgcmVzdWx0cyA9IHJlc3VsdHMuY29uY2F0KHJlbW92ZU5vZGUoZywgYnVja2V0cywgemVyb0lkeCwgZW50cnksIHRydWUpKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXN1bHRzO1xufVxuXG5mdW5jdGlvbiByZW1vdmVOb2RlKGcsIGJ1Y2tldHMsIHplcm9JZHgsIGVudHJ5LCBjb2xsZWN0UHJlZGVjZXNzb3JzKSB7XG4gIHZhciByZXN1bHRzID0gY29sbGVjdFByZWRlY2Vzc29ycyA/IFtdIDogdW5kZWZpbmVkO1xuXG4gIF8uZm9yRWFjaChnLmluRWRnZXMoZW50cnkudiksIGZ1bmN0aW9uKGVkZ2UpIHtcbiAgICB2YXIgd2VpZ2h0ID0gZy5lZGdlKGVkZ2UpO1xuICAgIHZhciB1RW50cnkgPSBnLm5vZGUoZWRnZS52KTtcblxuICAgIGlmIChjb2xsZWN0UHJlZGVjZXNzb3JzKSB7XG4gICAgICByZXN1bHRzLnB1c2goeyB2OiBlZGdlLnYsIHc6IGVkZ2UudyB9KTtcbiAgICB9XG5cbiAgICB1RW50cnkub3V0IC09IHdlaWdodDtcbiAgICBhc3NpZ25CdWNrZXQoYnVja2V0cywgemVyb0lkeCwgdUVudHJ5KTtcbiAgfSk7XG5cbiAgXy5mb3JFYWNoKGcub3V0RWRnZXMoZW50cnkudiksIGZ1bmN0aW9uKGVkZ2UpIHtcbiAgICB2YXIgd2VpZ2h0ID0gZy5lZGdlKGVkZ2UpO1xuICAgIHZhciB3ID0gZWRnZS53O1xuICAgIHZhciB3RW50cnkgPSBnLm5vZGUodyk7XG4gICAgd0VudHJ5W1wiaW5cIl0gLT0gd2VpZ2h0O1xuICAgIGFzc2lnbkJ1Y2tldChidWNrZXRzLCB6ZXJvSWR4LCB3RW50cnkpO1xuICB9KTtcblxuICBnLnJlbW92ZU5vZGUoZW50cnkudik7XG5cbiAgcmV0dXJuIHJlc3VsdHM7XG59XG5cbmZ1bmN0aW9uIGJ1aWxkU3RhdGUoZywgd2VpZ2h0Rm4pIHtcbiAgdmFyIGZhc0dyYXBoID0gbmV3IEdyYXBoKCk7XG4gIHZhciBtYXhJbiA9IDA7XG4gIHZhciBtYXhPdXQgPSAwO1xuXG4gIF8uZm9yRWFjaChnLm5vZGVzKCksIGZ1bmN0aW9uKHYpIHtcbiAgICBmYXNHcmFwaC5zZXROb2RlKHYsIHsgdjogdiwgXCJpblwiOiAwLCBvdXQ6IDAgfSk7XG4gIH0pO1xuXG4gIC8vIEFnZ3JlZ2F0ZSB3ZWlnaHRzIG9uIG5vZGVzLCBidXQgYWxzbyBzdW0gdGhlIHdlaWdodHMgYWNyb3NzIG11bHRpLWVkZ2VzXG4gIC8vIGludG8gYSBzaW5nbGUgZWRnZSBmb3IgdGhlIGZhc0dyYXBoLlxuICBfLmZvckVhY2goZy5lZGdlcygpLCBmdW5jdGlvbihlKSB7XG4gICAgdmFyIHByZXZXZWlnaHQgPSBmYXNHcmFwaC5lZGdlKGUudiwgZS53KSB8fCAwO1xuICAgIHZhciB3ZWlnaHQgPSB3ZWlnaHRGbihlKTtcbiAgICB2YXIgZWRnZVdlaWdodCA9IHByZXZXZWlnaHQgKyB3ZWlnaHQ7XG4gICAgZmFzR3JhcGguc2V0RWRnZShlLnYsIGUudywgZWRnZVdlaWdodCk7XG4gICAgbWF4T3V0ID0gTWF0aC5tYXgobWF4T3V0LCBmYXNHcmFwaC5ub2RlKGUudikub3V0ICs9IHdlaWdodCk7XG4gICAgbWF4SW4gID0gTWF0aC5tYXgobWF4SW4sICBmYXNHcmFwaC5ub2RlKGUudylbXCJpblwiXSAgKz0gd2VpZ2h0KTtcbiAgfSk7XG5cbiAgdmFyIGJ1Y2tldHMgPSBfLnJhbmdlKG1heE91dCArIG1heEluICsgMykubWFwKGZ1bmN0aW9uKCkgeyByZXR1cm4gbmV3IExpc3QoKTsgfSk7XG4gIHZhciB6ZXJvSWR4ID0gbWF4SW4gKyAxO1xuXG4gIF8uZm9yRWFjaChmYXNHcmFwaC5ub2RlcygpLCBmdW5jdGlvbih2KSB7XG4gICAgYXNzaWduQnVja2V0KGJ1Y2tldHMsIHplcm9JZHgsIGZhc0dyYXBoLm5vZGUodikpO1xuICB9KTtcblxuICByZXR1cm4geyBncmFwaDogZmFzR3JhcGgsIGJ1Y2tldHM6IGJ1Y2tldHMsIHplcm9JZHg6IHplcm9JZHggfTtcbn1cblxuZnVuY3Rpb24gYXNzaWduQnVja2V0KGJ1Y2tldHMsIHplcm9JZHgsIGVudHJ5KSB7XG4gIGlmICghZW50cnkub3V0KSB7XG4gICAgYnVja2V0c1swXS5lbnF1ZXVlKGVudHJ5KTtcbiAgfSBlbHNlIGlmICghZW50cnlbXCJpblwiXSkge1xuICAgIGJ1Y2tldHNbYnVja2V0cy5sZW5ndGggLSAxXS5lbnF1ZXVlKGVudHJ5KTtcbiAgfSBlbHNlIHtcbiAgICBidWNrZXRzW2VudHJ5Lm91dCAtIGVudHJ5W1wiaW5cIl0gKyB6ZXJvSWR4XS5lbnF1ZXVlKGVudHJ5KTtcbiAgfVxufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfID0gcmVxdWlyZShcIi4vbG9kYXNoXCIpO1xudmFyIGFjeWNsaWMgPSByZXF1aXJlKFwiLi9hY3ljbGljXCIpO1xudmFyIG5vcm1hbGl6ZSA9IHJlcXVpcmUoXCIuL25vcm1hbGl6ZVwiKTtcbnZhciByYW5rID0gcmVxdWlyZShcIi4vcmFua1wiKTtcbnZhciBub3JtYWxpemVSYW5rcyA9IHJlcXVpcmUoXCIuL3V0aWxcIikubm9ybWFsaXplUmFua3M7XG52YXIgcGFyZW50RHVtbXlDaGFpbnMgPSByZXF1aXJlKFwiLi9wYXJlbnQtZHVtbXktY2hhaW5zXCIpO1xudmFyIHJlbW92ZUVtcHR5UmFua3MgPSByZXF1aXJlKFwiLi91dGlsXCIpLnJlbW92ZUVtcHR5UmFua3M7XG52YXIgbmVzdGluZ0dyYXBoID0gcmVxdWlyZShcIi4vbmVzdGluZy1ncmFwaFwiKTtcbnZhciBhZGRCb3JkZXJTZWdtZW50cyA9IHJlcXVpcmUoXCIuL2FkZC1ib3JkZXItc2VnbWVudHNcIik7XG52YXIgY29vcmRpbmF0ZVN5c3RlbSA9IHJlcXVpcmUoXCIuL2Nvb3JkaW5hdGUtc3lzdGVtXCIpO1xudmFyIG9yZGVyID0gcmVxdWlyZShcIi4vb3JkZXJcIik7XG52YXIgcG9zaXRpb24gPSByZXF1aXJlKFwiLi9wb3NpdGlvblwiKTtcbnZhciB1dGlsID0gcmVxdWlyZShcIi4vdXRpbFwiKTtcbnZhciBHcmFwaCA9IHJlcXVpcmUoXCIuL2dyYXBobGliXCIpLkdyYXBoO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGxheW91dDtcblxuZnVuY3Rpb24gbGF5b3V0KGcsIG9wdHMpIHtcbiAgdmFyIHRpbWUgPSBvcHRzICYmIG9wdHMuZGVidWdUaW1pbmcgPyB1dGlsLnRpbWUgOiB1dGlsLm5vdGltZTtcbiAgdGltZShcImxheW91dFwiLCBmdW5jdGlvbigpIHtcbiAgICB2YXIgbGF5b3V0R3JhcGggPSBcbiAgICAgIHRpbWUoXCIgIGJ1aWxkTGF5b3V0R3JhcGhcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBidWlsZExheW91dEdyYXBoKGcpOyB9KTtcbiAgICB0aW1lKFwiICBydW5MYXlvdXRcIiwgICAgICAgIGZ1bmN0aW9uKCkgeyBydW5MYXlvdXQobGF5b3V0R3JhcGgsIHRpbWUpOyB9KTtcbiAgICB0aW1lKFwiICB1cGRhdGVJbnB1dEdyYXBoXCIsIGZ1bmN0aW9uKCkgeyB1cGRhdGVJbnB1dEdyYXBoKGcsIGxheW91dEdyYXBoKTsgfSk7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBydW5MYXlvdXQoZywgdGltZSkge1xuICB0aW1lKFwiICAgIG1ha2VTcGFjZUZvckVkZ2VMYWJlbHNcIiwgZnVuY3Rpb24oKSB7IG1ha2VTcGFjZUZvckVkZ2VMYWJlbHMoZyk7IH0pO1xuICB0aW1lKFwiICAgIHJlbW92ZVNlbGZFZGdlc1wiLCAgICAgICAgZnVuY3Rpb24oKSB7IHJlbW92ZVNlbGZFZGdlcyhnKTsgfSk7XG4gIHRpbWUoXCIgICAgYWN5Y2xpY1wiLCAgICAgICAgICAgICAgICBmdW5jdGlvbigpIHsgYWN5Y2xpYy5ydW4oZyk7IH0pO1xuICB0aW1lKFwiICAgIG5lc3RpbmdHcmFwaC5ydW5cIiwgICAgICAgZnVuY3Rpb24oKSB7IG5lc3RpbmdHcmFwaC5ydW4oZyk7IH0pO1xuICB0aW1lKFwiICAgIHJhbmtcIiwgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24oKSB7IHJhbmsodXRpbC5hc05vbkNvbXBvdW5kR3JhcGgoZykpOyB9KTtcbiAgdGltZShcIiAgICBpbmplY3RFZGdlTGFiZWxQcm94aWVzXCIsIGZ1bmN0aW9uKCkgeyBpbmplY3RFZGdlTGFiZWxQcm94aWVzKGcpOyB9KTtcbiAgdGltZShcIiAgICByZW1vdmVFbXB0eVJhbmtzXCIsICAgICAgIGZ1bmN0aW9uKCkgeyByZW1vdmVFbXB0eVJhbmtzKGcpOyB9KTtcbiAgdGltZShcIiAgICBuZXN0aW5nR3JhcGguY2xlYW51cFwiLCAgIGZ1bmN0aW9uKCkgeyBuZXN0aW5nR3JhcGguY2xlYW51cChnKTsgfSk7XG4gIHRpbWUoXCIgICAgbm9ybWFsaXplUmFua3NcIiwgICAgICAgICBmdW5jdGlvbigpIHsgbm9ybWFsaXplUmFua3MoZyk7IH0pO1xuICB0aW1lKFwiICAgIGFzc2lnblJhbmtNaW5NYXhcIiwgICAgICAgZnVuY3Rpb24oKSB7IGFzc2lnblJhbmtNaW5NYXgoZyk7IH0pO1xuICB0aW1lKFwiICAgIHJlbW92ZUVkZ2VMYWJlbFByb3hpZXNcIiwgZnVuY3Rpb24oKSB7IHJlbW92ZUVkZ2VMYWJlbFByb3hpZXMoZyk7IH0pO1xuICB0aW1lKFwiICAgIG5vcm1hbGl6ZS5ydW5cIiwgICAgICAgICAgZnVuY3Rpb24oKSB7IG5vcm1hbGl6ZS5ydW4oZyk7IH0pO1xuICB0aW1lKFwiICAgIHBhcmVudER1bW15Q2hhaW5zXCIsICAgICAgZnVuY3Rpb24oKSB7IHBhcmVudER1bW15Q2hhaW5zKGcpOyB9KTtcbiAgdGltZShcIiAgICBhZGRCb3JkZXJTZWdtZW50c1wiLCAgICAgIGZ1bmN0aW9uKCkgeyBhZGRCb3JkZXJTZWdtZW50cyhnKTsgfSk7XG4gIHRpbWUoXCIgICAgb3JkZXJcIiwgICAgICAgICAgICAgICAgICBmdW5jdGlvbigpIHsgb3JkZXIoZyk7IH0pO1xuICB0aW1lKFwiICAgIGluc2VydFNlbGZFZGdlc1wiLCAgICAgICAgZnVuY3Rpb24oKSB7IGluc2VydFNlbGZFZGdlcyhnKTsgfSk7XG4gIHRpbWUoXCIgICAgYWRqdXN0Q29vcmRpbmF0ZVN5c3RlbVwiLCBmdW5jdGlvbigpIHsgY29vcmRpbmF0ZVN5c3RlbS5hZGp1c3QoZyk7IH0pO1xuICB0aW1lKFwiICAgIHBvc2l0aW9uXCIsICAgICAgICAgICAgICAgZnVuY3Rpb24oKSB7IHBvc2l0aW9uKGcpOyB9KTtcbiAgdGltZShcIiAgICBwb3NpdGlvblNlbGZFZGdlc1wiLCAgICAgIGZ1bmN0aW9uKCkgeyBwb3NpdGlvblNlbGZFZGdlcyhnKTsgfSk7XG4gIHRpbWUoXCIgICAgcmVtb3ZlQm9yZGVyTm9kZXNcIiwgICAgICBmdW5jdGlvbigpIHsgcmVtb3ZlQm9yZGVyTm9kZXMoZyk7IH0pO1xuICB0aW1lKFwiICAgIG5vcm1hbGl6ZS51bmRvXCIsICAgICAgICAgZnVuY3Rpb24oKSB7IG5vcm1hbGl6ZS51bmRvKGcpOyB9KTtcbiAgdGltZShcIiAgICBmaXh1cEVkZ2VMYWJlbENvb3Jkc1wiLCAgIGZ1bmN0aW9uKCkgeyBmaXh1cEVkZ2VMYWJlbENvb3JkcyhnKTsgfSk7XG4gIHRpbWUoXCIgICAgdW5kb0Nvb3JkaW5hdGVTeXN0ZW1cIiwgICBmdW5jdGlvbigpIHsgY29vcmRpbmF0ZVN5c3RlbS51bmRvKGcpOyB9KTtcbiAgdGltZShcIiAgICB0cmFuc2xhdGVHcmFwaFwiLCAgICAgICAgIGZ1bmN0aW9uKCkgeyB0cmFuc2xhdGVHcmFwaChnKTsgfSk7XG4gIHRpbWUoXCIgICAgYXNzaWduTm9kZUludGVyc2VjdHNcIiwgICBmdW5jdGlvbigpIHsgYXNzaWduTm9kZUludGVyc2VjdHMoZyk7IH0pO1xuICB0aW1lKFwiICAgIHJldmVyc2VQb2ludHNcIiwgICAgICAgICAgZnVuY3Rpb24oKSB7IHJldmVyc2VQb2ludHNGb3JSZXZlcnNlZEVkZ2VzKGcpOyB9KTtcbiAgdGltZShcIiAgICBhY3ljbGljLnVuZG9cIiwgICAgICAgICAgIGZ1bmN0aW9uKCkgeyBhY3ljbGljLnVuZG8oZyk7IH0pO1xufVxuXG4vKlxuICogQ29waWVzIGZpbmFsIGxheW91dCBpbmZvcm1hdGlvbiBmcm9tIHRoZSBsYXlvdXQgZ3JhcGggYmFjayB0byB0aGUgaW5wdXRcbiAqIGdyYXBoLiBUaGlzIHByb2Nlc3Mgb25seSBjb3BpZXMgd2hpdGVsaXN0ZWQgYXR0cmlidXRlcyBmcm9tIHRoZSBsYXlvdXQgZ3JhcGhcbiAqIHRvIHRoZSBpbnB1dCBncmFwaCwgc28gaXQgc2VydmVzIGFzIGEgZ29vZCBwbGFjZSB0byBkZXRlcm1pbmUgd2hhdFxuICogYXR0cmlidXRlcyBjYW4gaW5mbHVlbmNlIGxheW91dC5cbiAqL1xuZnVuY3Rpb24gdXBkYXRlSW5wdXRHcmFwaChpbnB1dEdyYXBoLCBsYXlvdXRHcmFwaCkge1xuICBfLmZvckVhY2goaW5wdXRHcmFwaC5ub2RlcygpLCBmdW5jdGlvbih2KSB7XG4gICAgdmFyIGlucHV0TGFiZWwgPSBpbnB1dEdyYXBoLm5vZGUodik7XG4gICAgdmFyIGxheW91dExhYmVsID0gbGF5b3V0R3JhcGgubm9kZSh2KTtcblxuICAgIGlmIChpbnB1dExhYmVsKSB7XG4gICAgICBpbnB1dExhYmVsLnggPSBsYXlvdXRMYWJlbC54O1xuICAgICAgaW5wdXRMYWJlbC55ID0gbGF5b3V0TGFiZWwueTtcblxuICAgICAgaWYgKGxheW91dEdyYXBoLmNoaWxkcmVuKHYpLmxlbmd0aCkge1xuICAgICAgICBpbnB1dExhYmVsLndpZHRoID0gbGF5b3V0TGFiZWwud2lkdGg7XG4gICAgICAgIGlucHV0TGFiZWwuaGVpZ2h0ID0gbGF5b3V0TGFiZWwuaGVpZ2h0O1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG5cbiAgXy5mb3JFYWNoKGlucHV0R3JhcGguZWRnZXMoKSwgZnVuY3Rpb24oZSkge1xuICAgIHZhciBpbnB1dExhYmVsID0gaW5wdXRHcmFwaC5lZGdlKGUpO1xuICAgIHZhciBsYXlvdXRMYWJlbCA9IGxheW91dEdyYXBoLmVkZ2UoZSk7XG5cbiAgICBpbnB1dExhYmVsLnBvaW50cyA9IGxheW91dExhYmVsLnBvaW50cztcbiAgICBpZiAoXy5oYXMobGF5b3V0TGFiZWwsIFwieFwiKSkge1xuICAgICAgaW5wdXRMYWJlbC54ID0gbGF5b3V0TGFiZWwueDtcbiAgICAgIGlucHV0TGFiZWwueSA9IGxheW91dExhYmVsLnk7XG4gICAgfVxuICB9KTtcblxuICBpbnB1dEdyYXBoLmdyYXBoKCkud2lkdGggPSBsYXlvdXRHcmFwaC5ncmFwaCgpLndpZHRoO1xuICBpbnB1dEdyYXBoLmdyYXBoKCkuaGVpZ2h0ID0gbGF5b3V0R3JhcGguZ3JhcGgoKS5oZWlnaHQ7XG59XG5cbnZhciBncmFwaE51bUF0dHJzID0gW1wibm9kZXNlcFwiLCBcImVkZ2VzZXBcIiwgXCJyYW5rc2VwXCIsIFwibWFyZ2lueFwiLCBcIm1hcmdpbnlcIl07XG52YXIgZ3JhcGhEZWZhdWx0cyA9IHsgcmFua3NlcDogNTAsIGVkZ2VzZXA6IDIwLCBub2Rlc2VwOiA1MCwgcmFua2RpcjogXCJ0YlwiIH07XG52YXIgZ3JhcGhBdHRycyA9IFtcImFjeWNsaWNlclwiLCBcInJhbmtlclwiLCBcInJhbmtkaXJcIiwgXCJhbGlnblwiXTtcbnZhciBub2RlTnVtQXR0cnMgPSBbXCJ3aWR0aFwiLCBcImhlaWdodFwiXTtcbnZhciBub2RlRGVmYXVsdHMgPSB7IHdpZHRoOiAwLCBoZWlnaHQ6IDAgfTtcbnZhciBlZGdlTnVtQXR0cnMgPSBbXCJtaW5sZW5cIiwgXCJ3ZWlnaHRcIiwgXCJ3aWR0aFwiLCBcImhlaWdodFwiLCBcImxhYmVsb2Zmc2V0XCJdO1xudmFyIGVkZ2VEZWZhdWx0cyA9IHtcbiAgbWlubGVuOiAxLCB3ZWlnaHQ6IDEsIHdpZHRoOiAwLCBoZWlnaHQ6IDAsXG4gIGxhYmVsb2Zmc2V0OiAxMCwgbGFiZWxwb3M6IFwiclwiXG59O1xudmFyIGVkZ2VBdHRycyA9IFtcImxhYmVscG9zXCJdO1xuXG4vKlxuICogQ29uc3RydWN0cyBhIG5ldyBncmFwaCBmcm9tIHRoZSBpbnB1dCBncmFwaCwgd2hpY2ggY2FuIGJlIHVzZWQgZm9yIGxheW91dC5cbiAqIFRoaXMgcHJvY2VzcyBjb3BpZXMgb25seSB3aGl0ZWxpc3RlZCBhdHRyaWJ1dGVzIGZyb20gdGhlIGlucHV0IGdyYXBoIHRvIHRoZVxuICogbGF5b3V0IGdyYXBoLiBUaHVzIHRoaXMgZnVuY3Rpb24gc2VydmVzIGFzIGEgZ29vZCBwbGFjZSB0byBkZXRlcm1pbmUgd2hhdFxuICogYXR0cmlidXRlcyBjYW4gaW5mbHVlbmNlIGxheW91dC5cbiAqL1xuZnVuY3Rpb24gYnVpbGRMYXlvdXRHcmFwaChpbnB1dEdyYXBoKSB7XG4gIHZhciBnID0gbmV3IEdyYXBoKHsgbXVsdGlncmFwaDogdHJ1ZSwgY29tcG91bmQ6IHRydWUgfSk7XG4gIHZhciBncmFwaCA9IGNhbm9uaWNhbGl6ZShpbnB1dEdyYXBoLmdyYXBoKCkpO1xuXG4gIGcuc2V0R3JhcGgoXy5tZXJnZSh7fSxcbiAgICBncmFwaERlZmF1bHRzLFxuICAgIHNlbGVjdE51bWJlckF0dHJzKGdyYXBoLCBncmFwaE51bUF0dHJzKSxcbiAgICBfLnBpY2soZ3JhcGgsIGdyYXBoQXR0cnMpKSk7XG5cbiAgXy5mb3JFYWNoKGlucHV0R3JhcGgubm9kZXMoKSwgZnVuY3Rpb24odikge1xuICAgIHZhciBub2RlID0gY2Fub25pY2FsaXplKGlucHV0R3JhcGgubm9kZSh2KSk7XG4gICAgZy5zZXROb2RlKHYsIF8uZGVmYXVsdHMoc2VsZWN0TnVtYmVyQXR0cnMobm9kZSwgbm9kZU51bUF0dHJzKSwgbm9kZURlZmF1bHRzKSk7XG4gICAgZy5zZXRQYXJlbnQodiwgaW5wdXRHcmFwaC5wYXJlbnQodikpO1xuICB9KTtcblxuICBfLmZvckVhY2goaW5wdXRHcmFwaC5lZGdlcygpLCBmdW5jdGlvbihlKSB7XG4gICAgdmFyIGVkZ2UgPSBjYW5vbmljYWxpemUoaW5wdXRHcmFwaC5lZGdlKGUpKTtcbiAgICBnLnNldEVkZ2UoZSwgXy5tZXJnZSh7fSxcbiAgICAgIGVkZ2VEZWZhdWx0cyxcbiAgICAgIHNlbGVjdE51bWJlckF0dHJzKGVkZ2UsIGVkZ2VOdW1BdHRycyksXG4gICAgICBfLnBpY2soZWRnZSwgZWRnZUF0dHJzKSkpO1xuICB9KTtcblxuICByZXR1cm4gZztcbn1cblxuLypcbiAqIFRoaXMgaWRlYSBjb21lcyBmcm9tIHRoZSBHYW5zbmVyIHBhcGVyOiB0byBhY2NvdW50IGZvciBlZGdlIGxhYmVscyBpbiBvdXJcbiAqIGxheW91dCB3ZSBzcGxpdCBlYWNoIHJhbmsgaW4gaGFsZiBieSBkb3VibGluZyBtaW5sZW4gYW5kIGhhbHZpbmcgcmFua3NlcC5cbiAqIFRoZW4gd2UgY2FuIHBsYWNlIGxhYmVscyBhdCB0aGVzZSBtaWQtcG9pbnRzIGJldHdlZW4gbm9kZXMuXG4gKlxuICogV2UgYWxzbyBhZGQgc29tZSBtaW5pbWFsIHBhZGRpbmcgdG8gdGhlIHdpZHRoIHRvIHB1c2ggdGhlIGxhYmVsIGZvciB0aGUgZWRnZVxuICogYXdheSBmcm9tIHRoZSBlZGdlIGl0c2VsZiBhIGJpdC5cbiAqL1xuZnVuY3Rpb24gbWFrZVNwYWNlRm9yRWRnZUxhYmVscyhnKSB7XG4gIHZhciBncmFwaCA9IGcuZ3JhcGgoKTtcbiAgZ3JhcGgucmFua3NlcCAvPSAyO1xuICBfLmZvckVhY2goZy5lZGdlcygpLCBmdW5jdGlvbihlKSB7XG4gICAgdmFyIGVkZ2UgPSBnLmVkZ2UoZSk7XG4gICAgZWRnZS5taW5sZW4gKj0gMjtcbiAgICBpZiAoZWRnZS5sYWJlbHBvcy50b0xvd2VyQ2FzZSgpICE9PSBcImNcIikge1xuICAgICAgaWYgKGdyYXBoLnJhbmtkaXIgPT09IFwiVEJcIiB8fCBncmFwaC5yYW5rZGlyID09PSBcIkJUXCIpIHtcbiAgICAgICAgZWRnZS53aWR0aCArPSBlZGdlLmxhYmVsb2Zmc2V0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZWRnZS5oZWlnaHQgKz0gZWRnZS5sYWJlbG9mZnNldDtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xufVxuXG4vKlxuICogQ3JlYXRlcyB0ZW1wb3JhcnkgZHVtbXkgbm9kZXMgdGhhdCBjYXB0dXJlIHRoZSByYW5rIGluIHdoaWNoIGVhY2ggZWRnZSdzXG4gKiBsYWJlbCBpcyBnb2luZyB0bywgaWYgaXQgaGFzIG9uZSBvZiBub24temVybyB3aWR0aCBhbmQgaGVpZ2h0LiBXZSBkbyB0aGlzXG4gKiBzbyB0aGF0IHdlIGNhbiBzYWZlbHkgcmVtb3ZlIGVtcHR5IHJhbmtzIHdoaWxlIHByZXNlcnZpbmcgYmFsYW5jZSBmb3IgdGhlXG4gKiBsYWJlbCdzIHBvc2l0aW9uLlxuICovXG5mdW5jdGlvbiBpbmplY3RFZGdlTGFiZWxQcm94aWVzKGcpIHtcbiAgXy5mb3JFYWNoKGcuZWRnZXMoKSwgZnVuY3Rpb24oZSkge1xuICAgIHZhciBlZGdlID0gZy5lZGdlKGUpO1xuICAgIGlmIChlZGdlLndpZHRoICYmIGVkZ2UuaGVpZ2h0KSB7XG4gICAgICB2YXIgdiA9IGcubm9kZShlLnYpO1xuICAgICAgdmFyIHcgPSBnLm5vZGUoZS53KTtcbiAgICAgIHZhciBsYWJlbCA9IHsgcmFuazogKHcucmFuayAtIHYucmFuaykgLyAyICsgdi5yYW5rLCBlOiBlIH07XG4gICAgICB1dGlsLmFkZER1bW15Tm9kZShnLCBcImVkZ2UtcHJveHlcIiwgbGFiZWwsIFwiX2VwXCIpO1xuICAgIH1cbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGFzc2lnblJhbmtNaW5NYXgoZykge1xuICB2YXIgbWF4UmFuayA9IDA7XG4gIF8uZm9yRWFjaChnLm5vZGVzKCksIGZ1bmN0aW9uKHYpIHtcbiAgICB2YXIgbm9kZSA9IGcubm9kZSh2KTtcbiAgICBpZiAobm9kZS5ib3JkZXJUb3ApIHtcbiAgICAgIG5vZGUubWluUmFuayA9IGcubm9kZShub2RlLmJvcmRlclRvcCkucmFuaztcbiAgICAgIG5vZGUubWF4UmFuayA9IGcubm9kZShub2RlLmJvcmRlckJvdHRvbSkucmFuaztcbiAgICAgIG1heFJhbmsgPSBfLm1heChtYXhSYW5rLCBub2RlLm1heFJhbmspO1xuICAgIH1cbiAgfSk7XG4gIGcuZ3JhcGgoKS5tYXhSYW5rID0gbWF4UmFuaztcbn1cblxuZnVuY3Rpb24gcmVtb3ZlRWRnZUxhYmVsUHJveGllcyhnKSB7XG4gIF8uZm9yRWFjaChnLm5vZGVzKCksIGZ1bmN0aW9uKHYpIHtcbiAgICB2YXIgbm9kZSA9IGcubm9kZSh2KTtcbiAgICBpZiAobm9kZS5kdW1teSA9PT0gXCJlZGdlLXByb3h5XCIpIHtcbiAgICAgIGcuZWRnZShub2RlLmUpLmxhYmVsUmFuayA9IG5vZGUucmFuaztcbiAgICAgIGcucmVtb3ZlTm9kZSh2KTtcbiAgICB9XG4gIH0pO1xufVxuXG5mdW5jdGlvbiB0cmFuc2xhdGVHcmFwaChnKSB7XG4gIHZhciBtaW5YID0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZO1xuICB2YXIgbWF4WCA9IDA7XG4gIHZhciBtaW5ZID0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZO1xuICB2YXIgbWF4WSA9IDA7XG4gIHZhciBncmFwaExhYmVsID0gZy5ncmFwaCgpO1xuICB2YXIgbWFyZ2luWCA9IGdyYXBoTGFiZWwubWFyZ2lueCB8fCAwO1xuICB2YXIgbWFyZ2luWSA9IGdyYXBoTGFiZWwubWFyZ2lueSB8fCAwO1xuXG4gIGZ1bmN0aW9uIGdldEV4dHJlbWVzKGF0dHJzKSB7XG4gICAgdmFyIHggPSBhdHRycy54O1xuICAgIHZhciB5ID0gYXR0cnMueTtcbiAgICB2YXIgdyA9IGF0dHJzLndpZHRoO1xuICAgIHZhciBoID0gYXR0cnMuaGVpZ2h0O1xuICAgIG1pblggPSBNYXRoLm1pbihtaW5YLCB4IC0gdyAvIDIpO1xuICAgIG1heFggPSBNYXRoLm1heChtYXhYLCB4ICsgdyAvIDIpO1xuICAgIG1pblkgPSBNYXRoLm1pbihtaW5ZLCB5IC0gaCAvIDIpO1xuICAgIG1heFkgPSBNYXRoLm1heChtYXhZLCB5ICsgaCAvIDIpO1xuICB9XG5cbiAgXy5mb3JFYWNoKGcubm9kZXMoKSwgZnVuY3Rpb24odikgeyBnZXRFeHRyZW1lcyhnLm5vZGUodikpOyB9KTtcbiAgXy5mb3JFYWNoKGcuZWRnZXMoKSwgZnVuY3Rpb24oZSkge1xuICAgIHZhciBlZGdlID0gZy5lZGdlKGUpO1xuICAgIGlmIChfLmhhcyhlZGdlLCBcInhcIikpIHtcbiAgICAgIGdldEV4dHJlbWVzKGVkZ2UpO1xuICAgIH1cbiAgfSk7XG5cbiAgbWluWCAtPSBtYXJnaW5YO1xuICBtaW5ZIC09IG1hcmdpblk7XG5cbiAgXy5mb3JFYWNoKGcubm9kZXMoKSwgZnVuY3Rpb24odikge1xuICAgIHZhciBub2RlID0gZy5ub2RlKHYpO1xuICAgIG5vZGUueCAtPSBtaW5YO1xuICAgIG5vZGUueSAtPSBtaW5ZO1xuICB9KTtcblxuICBfLmZvckVhY2goZy5lZGdlcygpLCBmdW5jdGlvbihlKSB7XG4gICAgdmFyIGVkZ2UgPSBnLmVkZ2UoZSk7XG4gICAgXy5mb3JFYWNoKGVkZ2UucG9pbnRzLCBmdW5jdGlvbihwKSB7XG4gICAgICBwLnggLT0gbWluWDtcbiAgICAgIHAueSAtPSBtaW5ZO1xuICAgIH0pO1xuICAgIGlmIChfLmhhcyhlZGdlLCBcInhcIikpIHsgZWRnZS54IC09IG1pblg7IH1cbiAgICBpZiAoXy5oYXMoZWRnZSwgXCJ5XCIpKSB7IGVkZ2UueSAtPSBtaW5ZOyB9XG4gIH0pO1xuXG4gIGdyYXBoTGFiZWwud2lkdGggPSBtYXhYIC0gbWluWCArIG1hcmdpblg7XG4gIGdyYXBoTGFiZWwuaGVpZ2h0ID0gbWF4WSAtIG1pblkgKyBtYXJnaW5ZO1xufVxuXG5mdW5jdGlvbiBhc3NpZ25Ob2RlSW50ZXJzZWN0cyhnKSB7XG4gIF8uZm9yRWFjaChnLmVkZ2VzKCksIGZ1bmN0aW9uKGUpIHtcbiAgICB2YXIgZWRnZSA9IGcuZWRnZShlKTtcbiAgICB2YXIgbm9kZVYgPSBnLm5vZGUoZS52KTtcbiAgICB2YXIgbm9kZVcgPSBnLm5vZGUoZS53KTtcbiAgICB2YXIgcDEsIHAyO1xuICAgIGlmICghZWRnZS5wb2ludHMpIHtcbiAgICAgIGVkZ2UucG9pbnRzID0gW107XG4gICAgICBwMSA9IG5vZGVXO1xuICAgICAgcDIgPSBub2RlVjtcbiAgICB9IGVsc2Uge1xuICAgICAgcDEgPSBlZGdlLnBvaW50c1swXTtcbiAgICAgIHAyID0gZWRnZS5wb2ludHNbZWRnZS5wb2ludHMubGVuZ3RoIC0gMV07XG4gICAgfVxuICAgIGVkZ2UucG9pbnRzLnVuc2hpZnQodXRpbC5pbnRlcnNlY3RSZWN0KG5vZGVWLCBwMSkpO1xuICAgIGVkZ2UucG9pbnRzLnB1c2godXRpbC5pbnRlcnNlY3RSZWN0KG5vZGVXLCBwMikpO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gZml4dXBFZGdlTGFiZWxDb29yZHMoZykge1xuICBfLmZvckVhY2goZy5lZGdlcygpLCBmdW5jdGlvbihlKSB7XG4gICAgdmFyIGVkZ2UgPSBnLmVkZ2UoZSk7XG4gICAgaWYgKF8uaGFzKGVkZ2UsIFwieFwiKSkge1xuICAgICAgaWYgKGVkZ2UubGFiZWxwb3MgPT09IFwibFwiIHx8IGVkZ2UubGFiZWxwb3MgPT09IFwiclwiKSB7XG4gICAgICAgIGVkZ2Uud2lkdGggLT0gZWRnZS5sYWJlbG9mZnNldDtcbiAgICAgIH1cbiAgICAgIHN3aXRjaCAoZWRnZS5sYWJlbHBvcykge1xuICAgICAgY2FzZSBcImxcIjogZWRnZS54IC09IGVkZ2Uud2lkdGggLyAyICsgZWRnZS5sYWJlbG9mZnNldDsgYnJlYWs7XG4gICAgICBjYXNlIFwiclwiOiBlZGdlLnggKz0gZWRnZS53aWR0aCAvIDIgKyBlZGdlLmxhYmVsb2Zmc2V0OyBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xufVxuXG5mdW5jdGlvbiByZXZlcnNlUG9pbnRzRm9yUmV2ZXJzZWRFZGdlcyhnKSB7XG4gIF8uZm9yRWFjaChnLmVkZ2VzKCksIGZ1bmN0aW9uKGUpIHtcbiAgICB2YXIgZWRnZSA9IGcuZWRnZShlKTtcbiAgICBpZiAoZWRnZS5yZXZlcnNlZCkge1xuICAgICAgZWRnZS5wb2ludHMucmV2ZXJzZSgpO1xuICAgIH1cbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHJlbW92ZUJvcmRlck5vZGVzKGcpIHtcbiAgXy5mb3JFYWNoKGcubm9kZXMoKSwgZnVuY3Rpb24odikge1xuICAgIGlmIChnLmNoaWxkcmVuKHYpLmxlbmd0aCkge1xuICAgICAgdmFyIG5vZGUgPSBnLm5vZGUodik7XG4gICAgICB2YXIgdCA9IGcubm9kZShub2RlLmJvcmRlclRvcCk7XG4gICAgICB2YXIgYiA9IGcubm9kZShub2RlLmJvcmRlckJvdHRvbSk7XG4gICAgICB2YXIgbCA9IGcubm9kZShfLmxhc3Qobm9kZS5ib3JkZXJMZWZ0KSk7XG4gICAgICB2YXIgciA9IGcubm9kZShfLmxhc3Qobm9kZS5ib3JkZXJSaWdodCkpO1xuXG4gICAgICBub2RlLndpZHRoID0gTWF0aC5hYnMoci54IC0gbC54KTtcbiAgICAgIG5vZGUuaGVpZ2h0ID0gTWF0aC5hYnMoYi55IC0gdC55KTtcbiAgICAgIG5vZGUueCA9IGwueCArIG5vZGUud2lkdGggLyAyO1xuICAgICAgbm9kZS55ID0gdC55ICsgbm9kZS5oZWlnaHQgLyAyO1xuICAgIH1cbiAgfSk7XG5cbiAgXy5mb3JFYWNoKGcubm9kZXMoKSwgZnVuY3Rpb24odikge1xuICAgIGlmIChnLm5vZGUodikuZHVtbXkgPT09IFwiYm9yZGVyXCIpIHtcbiAgICAgIGcucmVtb3ZlTm9kZSh2KTtcbiAgICB9XG4gIH0pO1xufVxuXG5mdW5jdGlvbiByZW1vdmVTZWxmRWRnZXMoZykge1xuICBfLmZvckVhY2goZy5lZGdlcygpLCBmdW5jdGlvbihlKSB7XG4gICAgaWYgKGUudiA9PT0gZS53KSB7XG4gICAgICB2YXIgbm9kZSA9IGcubm9kZShlLnYpO1xuICAgICAgaWYgKCFub2RlLnNlbGZFZGdlcykge1xuICAgICAgICBub2RlLnNlbGZFZGdlcyA9IFtdO1xuICAgICAgfVxuICAgICAgbm9kZS5zZWxmRWRnZXMucHVzaCh7IGU6IGUsIGxhYmVsOiBnLmVkZ2UoZSkgfSk7XG4gICAgICBnLnJlbW92ZUVkZ2UoZSk7XG4gICAgfVxuICB9KTtcbn1cblxuZnVuY3Rpb24gaW5zZXJ0U2VsZkVkZ2VzKGcpIHtcbiAgdmFyIGxheWVycyA9IHV0aWwuYnVpbGRMYXllck1hdHJpeChnKTtcbiAgXy5mb3JFYWNoKGxheWVycywgZnVuY3Rpb24obGF5ZXIpIHtcbiAgICB2YXIgb3JkZXJTaGlmdCA9IDA7XG4gICAgXy5mb3JFYWNoKGxheWVyLCBmdW5jdGlvbih2LCBpKSB7XG4gICAgICB2YXIgbm9kZSA9IGcubm9kZSh2KTtcbiAgICAgIG5vZGUub3JkZXIgPSBpICsgb3JkZXJTaGlmdDtcbiAgICAgIF8uZm9yRWFjaChub2RlLnNlbGZFZGdlcywgZnVuY3Rpb24oc2VsZkVkZ2UpIHtcbiAgICAgICAgdXRpbC5hZGREdW1teU5vZGUoZywgXCJzZWxmZWRnZVwiLCB7XG4gICAgICAgICAgd2lkdGg6IHNlbGZFZGdlLmxhYmVsLndpZHRoLFxuICAgICAgICAgIGhlaWdodDogc2VsZkVkZ2UubGFiZWwuaGVpZ2h0LFxuICAgICAgICAgIHJhbms6IG5vZGUucmFuayxcbiAgICAgICAgICBvcmRlcjogaSArICgrK29yZGVyU2hpZnQpLFxuICAgICAgICAgIGU6IHNlbGZFZGdlLmUsXG4gICAgICAgICAgbGFiZWw6IHNlbGZFZGdlLmxhYmVsXG4gICAgICAgIH0sIFwiX3NlXCIpO1xuICAgICAgfSk7XG4gICAgICBkZWxldGUgbm9kZS5zZWxmRWRnZXM7XG4gICAgfSk7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBwb3NpdGlvblNlbGZFZGdlcyhnKSB7XG4gIF8uZm9yRWFjaChnLm5vZGVzKCksIGZ1bmN0aW9uKHYpIHtcbiAgICB2YXIgbm9kZSA9IGcubm9kZSh2KTtcbiAgICBpZiAobm9kZS5kdW1teSA9PT0gXCJzZWxmZWRnZVwiKSB7XG4gICAgICB2YXIgc2VsZk5vZGUgPSBnLm5vZGUobm9kZS5lLnYpO1xuICAgICAgdmFyIHggPSBzZWxmTm9kZS54ICsgc2VsZk5vZGUud2lkdGggLyAyO1xuICAgICAgdmFyIHkgPSBzZWxmTm9kZS55O1xuICAgICAgdmFyIGR4ID0gbm9kZS54IC0geDtcbiAgICAgIHZhciBkeSA9IHNlbGZOb2RlLmhlaWdodCAvIDI7XG4gICAgICBnLnNldEVkZ2Uobm9kZS5lLCBub2RlLmxhYmVsKTtcbiAgICAgIGcucmVtb3ZlTm9kZSh2KTtcbiAgICAgIG5vZGUubGFiZWwucG9pbnRzID0gW1xuICAgICAgICB7IHg6IHggKyAyICogZHggLyAzLCB5OiB5IC0gZHkgfSxcbiAgICAgICAgeyB4OiB4ICsgNSAqIGR4IC8gNiwgeTogeSAtIGR5IH0sXG4gICAgICAgIHsgeDogeCArICAgICBkeCAgICAsIHk6IHkgfSxcbiAgICAgICAgeyB4OiB4ICsgNSAqIGR4IC8gNiwgeTogeSArIGR5IH0sXG4gICAgICAgIHsgeDogeCArIDIgKiBkeCAvIDMsIHk6IHkgKyBkeSB9XG4gICAgICBdO1xuICAgICAgbm9kZS5sYWJlbC54ID0gbm9kZS54O1xuICAgICAgbm9kZS5sYWJlbC55ID0gbm9kZS55O1xuICAgIH1cbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHNlbGVjdE51bWJlckF0dHJzKG9iaiwgYXR0cnMpIHtcbiAgcmV0dXJuIF8ubWFwVmFsdWVzKF8ucGljayhvYmosIGF0dHJzKSwgTnVtYmVyKTtcbn1cblxuZnVuY3Rpb24gY2Fub25pY2FsaXplKGF0dHJzKSB7XG4gIHZhciBuZXdBdHRycyA9IHt9O1xuICBfLmZvckVhY2goYXR0cnMsIGZ1bmN0aW9uKHYsIGspIHtcbiAgICBuZXdBdHRyc1trLnRvTG93ZXJDYXNlKCldID0gdjtcbiAgfSk7XG4gIHJldHVybiBuZXdBdHRycztcbn1cbiIsIi8qIGdsb2JhbCB3aW5kb3cgKi9cblxudmFyIGxvZGFzaDtcblxuaWYgKHR5cGVvZiByZXF1aXJlID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgdHJ5IHtcbiAgICBsb2Rhc2ggPSB7XG4gICAgICBjbG9uZURlZXA6IHJlcXVpcmUoXCJsb2Rhc2gvY2xvbmVEZWVwXCIpLFxuICAgICAgY29uc3RhbnQ6IHJlcXVpcmUoXCJsb2Rhc2gvY29uc3RhbnRcIiksXG4gICAgICBkZWZhdWx0czogcmVxdWlyZShcImxvZGFzaC9kZWZhdWx0c1wiKSxcbiAgICAgIGVhY2g6IHJlcXVpcmUoXCJsb2Rhc2gvZWFjaFwiKSxcbiAgICAgIGZpbHRlcjogcmVxdWlyZShcImxvZGFzaC9maWx0ZXJcIiksXG4gICAgICBmaW5kOiByZXF1aXJlKFwibG9kYXNoL2ZpbmRcIiksXG4gICAgICBmbGF0dGVuOiByZXF1aXJlKFwibG9kYXNoL2ZsYXR0ZW5cIiksXG4gICAgICBmb3JFYWNoOiByZXF1aXJlKFwibG9kYXNoL2ZvckVhY2hcIiksXG4gICAgICBmb3JJbjogcmVxdWlyZShcImxvZGFzaC9mb3JJblwiKSxcbiAgICAgIGhhczogIHJlcXVpcmUoXCJsb2Rhc2gvaGFzXCIpLFxuICAgICAgaXNVbmRlZmluZWQ6IHJlcXVpcmUoXCJsb2Rhc2gvaXNVbmRlZmluZWRcIiksXG4gICAgICBsYXN0OiByZXF1aXJlKFwibG9kYXNoL2xhc3RcIiksXG4gICAgICBtYXA6IHJlcXVpcmUoXCJsb2Rhc2gvbWFwXCIpLFxuICAgICAgbWFwVmFsdWVzOiByZXF1aXJlKFwibG9kYXNoL21hcFZhbHVlc1wiKSxcbiAgICAgIG1heDogcmVxdWlyZShcImxvZGFzaC9tYXhcIiksXG4gICAgICBtZXJnZTogcmVxdWlyZShcImxvZGFzaC9tZXJnZVwiKSxcbiAgICAgIG1pbjogcmVxdWlyZShcImxvZGFzaC9taW5cIiksXG4gICAgICBtaW5CeTogcmVxdWlyZShcImxvZGFzaC9taW5CeVwiKSxcbiAgICAgIG5vdzogcmVxdWlyZShcImxvZGFzaC9ub3dcIiksXG4gICAgICBwaWNrOiByZXF1aXJlKFwibG9kYXNoL3BpY2tcIiksXG4gICAgICByYW5nZTogcmVxdWlyZShcImxvZGFzaC9yYW5nZVwiKSxcbiAgICAgIHJlZHVjZTogcmVxdWlyZShcImxvZGFzaC9yZWR1Y2VcIiksXG4gICAgICBzb3J0Qnk6IHJlcXVpcmUoXCJsb2Rhc2gvc29ydEJ5XCIpLFxuICAgICAgdW5pcXVlSWQ6IHJlcXVpcmUoXCJsb2Rhc2gvdW5pcXVlSWRcIiksXG4gICAgICB2YWx1ZXM6IHJlcXVpcmUoXCJsb2Rhc2gvdmFsdWVzXCIpLFxuICAgICAgemlwT2JqZWN0OiByZXF1aXJlKFwibG9kYXNoL3ppcE9iamVjdFwiKSxcbiAgICB9O1xuICB9IGNhdGNoIChlKSB7XG4gICAgLy8gY29udGludWUgcmVnYXJkbGVzcyBvZiBlcnJvclxuICB9XG59XG5cbmlmICghbG9kYXNoKSB7XG4gIGxvZGFzaCA9IHdpbmRvdy5fO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGxvZGFzaDtcbiIsInZhciBfID0gcmVxdWlyZShcIi4vbG9kYXNoXCIpO1xudmFyIHV0aWwgPSByZXF1aXJlKFwiLi91dGlsXCIpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgcnVuOiBydW4sXG4gIGNsZWFudXA6IGNsZWFudXBcbn07XG5cbi8qXG4gKiBBIG5lc3RpbmcgZ3JhcGggY3JlYXRlcyBkdW1teSBub2RlcyBmb3IgdGhlIHRvcHMgYW5kIGJvdHRvbXMgb2Ygc3ViZ3JhcGhzLFxuICogYWRkcyBhcHByb3ByaWF0ZSBlZGdlcyB0byBlbnN1cmUgdGhhdCBhbGwgY2x1c3RlciBub2RlcyBhcmUgcGxhY2VkIGJldHdlZW5cbiAqIHRoZXNlIGJvdW5kcmllcywgYW5kIGVuc3VyZXMgdGhhdCB0aGUgZ3JhcGggaXMgY29ubmVjdGVkLlxuICpcbiAqIEluIGFkZGl0aW9uIHdlIGVuc3VyZSwgdGhyb3VnaCB0aGUgdXNlIG9mIHRoZSBtaW5sZW4gcHJvcGVydHksIHRoYXQgbm9kZXNcbiAqIGFuZCBzdWJncmFwaCBib3JkZXIgbm9kZXMgdG8gbm90IGVuZCB1cCBvbiB0aGUgc2FtZSByYW5rLlxuICpcbiAqIFByZWNvbmRpdGlvbnM6XG4gKlxuICogICAgMS4gSW5wdXQgZ3JhcGggaXMgYSBEQUdcbiAqICAgIDIuIE5vZGVzIGluIHRoZSBpbnB1dCBncmFwaCBoYXMgYSBtaW5sZW4gYXR0cmlidXRlXG4gKlxuICogUG9zdGNvbmRpdGlvbnM6XG4gKlxuICogICAgMS4gSW5wdXQgZ3JhcGggaXMgY29ubmVjdGVkLlxuICogICAgMi4gRHVtbXkgbm9kZXMgYXJlIGFkZGVkIGZvciB0aGUgdG9wcyBhbmQgYm90dG9tcyBvZiBzdWJncmFwaHMuXG4gKiAgICAzLiBUaGUgbWlubGVuIGF0dHJpYnV0ZSBmb3Igbm9kZXMgaXMgYWRqdXN0ZWQgdG8gZW5zdXJlIG5vZGVzIGRvIG5vdFxuICogICAgICAgZ2V0IHBsYWNlZCBvbiB0aGUgc2FtZSByYW5rIGFzIHN1YmdyYXBoIGJvcmRlciBub2Rlcy5cbiAqXG4gKiBUaGUgbmVzdGluZyBncmFwaCBpZGVhIGNvbWVzIGZyb20gU2FuZGVyLCBcIkxheW91dCBvZiBDb21wb3VuZCBEaXJlY3RlZFxuICogR3JhcGhzLlwiXG4gKi9cbmZ1bmN0aW9uIHJ1bihnKSB7XG4gIHZhciByb290ID0gdXRpbC5hZGREdW1teU5vZGUoZywgXCJyb290XCIsIHt9LCBcIl9yb290XCIpO1xuICB2YXIgZGVwdGhzID0gdHJlZURlcHRocyhnKTtcbiAgdmFyIGhlaWdodCA9IF8ubWF4KF8udmFsdWVzKGRlcHRocykpIC0gMTsgLy8gTm90ZTogZGVwdGhzIGlzIGFuIE9iamVjdCBub3QgYW4gYXJyYXlcbiAgdmFyIG5vZGVTZXAgPSAyICogaGVpZ2h0ICsgMTtcblxuICBnLmdyYXBoKCkubmVzdGluZ1Jvb3QgPSByb290O1xuXG4gIC8vIE11bHRpcGx5IG1pbmxlbiBieSBub2RlU2VwIHRvIGFsaWduIG5vZGVzIG9uIG5vbi1ib3JkZXIgcmFua3MuXG4gIF8uZm9yRWFjaChnLmVkZ2VzKCksIGZ1bmN0aW9uKGUpIHsgZy5lZGdlKGUpLm1pbmxlbiAqPSBub2RlU2VwOyB9KTtcblxuICAvLyBDYWxjdWxhdGUgYSB3ZWlnaHQgdGhhdCBpcyBzdWZmaWNpZW50IHRvIGtlZXAgc3ViZ3JhcGhzIHZlcnRpY2FsbHkgY29tcGFjdFxuICB2YXIgd2VpZ2h0ID0gc3VtV2VpZ2h0cyhnKSArIDE7XG5cbiAgLy8gQ3JlYXRlIGJvcmRlciBub2RlcyBhbmQgbGluayB0aGVtIHVwXG4gIF8uZm9yRWFjaChnLmNoaWxkcmVuKCksIGZ1bmN0aW9uKGNoaWxkKSB7XG4gICAgZGZzKGcsIHJvb3QsIG5vZGVTZXAsIHdlaWdodCwgaGVpZ2h0LCBkZXB0aHMsIGNoaWxkKTtcbiAgfSk7XG5cbiAgLy8gU2F2ZSB0aGUgbXVsdGlwbGllciBmb3Igbm9kZSBsYXllcnMgZm9yIGxhdGVyIHJlbW92YWwgb2YgZW1wdHkgYm9yZGVyXG4gIC8vIGxheWVycy5cbiAgZy5ncmFwaCgpLm5vZGVSYW5rRmFjdG9yID0gbm9kZVNlcDtcbn1cblxuZnVuY3Rpb24gZGZzKGcsIHJvb3QsIG5vZGVTZXAsIHdlaWdodCwgaGVpZ2h0LCBkZXB0aHMsIHYpIHtcbiAgdmFyIGNoaWxkcmVuID0gZy5jaGlsZHJlbih2KTtcbiAgaWYgKCFjaGlsZHJlbi5sZW5ndGgpIHtcbiAgICBpZiAodiAhPT0gcm9vdCkge1xuICAgICAgZy5zZXRFZGdlKHJvb3QsIHYsIHsgd2VpZ2h0OiAwLCBtaW5sZW46IG5vZGVTZXAgfSk7XG4gICAgfVxuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciB0b3AgPSB1dGlsLmFkZEJvcmRlck5vZGUoZywgXCJfYnRcIik7XG4gIHZhciBib3R0b20gPSB1dGlsLmFkZEJvcmRlck5vZGUoZywgXCJfYmJcIik7XG4gIHZhciBsYWJlbCA9IGcubm9kZSh2KTtcblxuICBnLnNldFBhcmVudCh0b3AsIHYpO1xuICBsYWJlbC5ib3JkZXJUb3AgPSB0b3A7XG4gIGcuc2V0UGFyZW50KGJvdHRvbSwgdik7XG4gIGxhYmVsLmJvcmRlckJvdHRvbSA9IGJvdHRvbTtcblxuICBfLmZvckVhY2goY2hpbGRyZW4sIGZ1bmN0aW9uKGNoaWxkKSB7XG4gICAgZGZzKGcsIHJvb3QsIG5vZGVTZXAsIHdlaWdodCwgaGVpZ2h0LCBkZXB0aHMsIGNoaWxkKTtcblxuICAgIHZhciBjaGlsZE5vZGUgPSBnLm5vZGUoY2hpbGQpO1xuICAgIHZhciBjaGlsZFRvcCA9IGNoaWxkTm9kZS5ib3JkZXJUb3AgPyBjaGlsZE5vZGUuYm9yZGVyVG9wIDogY2hpbGQ7XG4gICAgdmFyIGNoaWxkQm90dG9tID0gY2hpbGROb2RlLmJvcmRlckJvdHRvbSA/IGNoaWxkTm9kZS5ib3JkZXJCb3R0b20gOiBjaGlsZDtcbiAgICB2YXIgdGhpc1dlaWdodCA9IGNoaWxkTm9kZS5ib3JkZXJUb3AgPyB3ZWlnaHQgOiAyICogd2VpZ2h0O1xuICAgIHZhciBtaW5sZW4gPSBjaGlsZFRvcCAhPT0gY2hpbGRCb3R0b20gPyAxIDogaGVpZ2h0IC0gZGVwdGhzW3ZdICsgMTtcblxuICAgIGcuc2V0RWRnZSh0b3AsIGNoaWxkVG9wLCB7XG4gICAgICB3ZWlnaHQ6IHRoaXNXZWlnaHQsXG4gICAgICBtaW5sZW46IG1pbmxlbixcbiAgICAgIG5lc3RpbmdFZGdlOiB0cnVlXG4gICAgfSk7XG5cbiAgICBnLnNldEVkZ2UoY2hpbGRCb3R0b20sIGJvdHRvbSwge1xuICAgICAgd2VpZ2h0OiB0aGlzV2VpZ2h0LFxuICAgICAgbWlubGVuOiBtaW5sZW4sXG4gICAgICBuZXN0aW5nRWRnZTogdHJ1ZVxuICAgIH0pO1xuICB9KTtcblxuICBpZiAoIWcucGFyZW50KHYpKSB7XG4gICAgZy5zZXRFZGdlKHJvb3QsIHRvcCwgeyB3ZWlnaHQ6IDAsIG1pbmxlbjogaGVpZ2h0ICsgZGVwdGhzW3ZdIH0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIHRyZWVEZXB0aHMoZykge1xuICB2YXIgZGVwdGhzID0ge307XG4gIGZ1bmN0aW9uIGRmcyh2LCBkZXB0aCkge1xuICAgIHZhciBjaGlsZHJlbiA9IGcuY2hpbGRyZW4odik7XG4gICAgaWYgKGNoaWxkcmVuICYmIGNoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgXy5mb3JFYWNoKGNoaWxkcmVuLCBmdW5jdGlvbihjaGlsZCkge1xuICAgICAgICBkZnMoY2hpbGQsIGRlcHRoICsgMSk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgZGVwdGhzW3ZdID0gZGVwdGg7XG4gIH1cbiAgXy5mb3JFYWNoKGcuY2hpbGRyZW4oKSwgZnVuY3Rpb24odikgeyBkZnModiwgMSk7IH0pO1xuICByZXR1cm4gZGVwdGhzO1xufVxuXG5mdW5jdGlvbiBzdW1XZWlnaHRzKGcpIHtcbiAgcmV0dXJuIF8ucmVkdWNlKGcuZWRnZXMoKSwgZnVuY3Rpb24oYWNjLCBlKSB7XG4gICAgcmV0dXJuIGFjYyArIGcuZWRnZShlKS53ZWlnaHQ7XG4gIH0sIDApO1xufVxuXG5mdW5jdGlvbiBjbGVhbnVwKGcpIHtcbiAgdmFyIGdyYXBoTGFiZWwgPSBnLmdyYXBoKCk7XG4gIGcucmVtb3ZlTm9kZShncmFwaExhYmVsLm5lc3RpbmdSb290KTtcbiAgZGVsZXRlIGdyYXBoTGFiZWwubmVzdGluZ1Jvb3Q7XG4gIF8uZm9yRWFjaChnLmVkZ2VzKCksIGZ1bmN0aW9uKGUpIHtcbiAgICB2YXIgZWRnZSA9IGcuZWRnZShlKTtcbiAgICBpZiAoZWRnZS5uZXN0aW5nRWRnZSkge1xuICAgICAgZy5yZW1vdmVFZGdlKGUpO1xuICAgIH1cbiAgfSk7XG59XG4iLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIF8gPSByZXF1aXJlKFwiLi9sb2Rhc2hcIik7XG52YXIgdXRpbCA9IHJlcXVpcmUoXCIuL3V0aWxcIik7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBydW46IHJ1bixcbiAgdW5kbzogdW5kb1xufTtcblxuLypcbiAqIEJyZWFrcyBhbnkgbG9uZyBlZGdlcyBpbiB0aGUgZ3JhcGggaW50byBzaG9ydCBzZWdtZW50cyB0aGF0IHNwYW4gMSBsYXllclxuICogZWFjaC4gVGhpcyBvcGVyYXRpb24gaXMgdW5kb2FibGUgd2l0aCB0aGUgZGVub3JtYWxpemUgZnVuY3Rpb24uXG4gKlxuICogUHJlLWNvbmRpdGlvbnM6XG4gKlxuICogICAgMS4gVGhlIGlucHV0IGdyYXBoIGlzIGEgREFHLlxuICogICAgMi4gRWFjaCBub2RlIGluIHRoZSBncmFwaCBoYXMgYSBcInJhbmtcIiBwcm9wZXJ0eS5cbiAqXG4gKiBQb3N0LWNvbmRpdGlvbjpcbiAqXG4gKiAgICAxLiBBbGwgZWRnZXMgaW4gdGhlIGdyYXBoIGhhdmUgYSBsZW5ndGggb2YgMS5cbiAqICAgIDIuIER1bW15IG5vZGVzIGFyZSBhZGRlZCB3aGVyZSBlZGdlcyBoYXZlIGJlZW4gc3BsaXQgaW50byBzZWdtZW50cy5cbiAqICAgIDMuIFRoZSBncmFwaCBpcyBhdWdtZW50ZWQgd2l0aCBhIFwiZHVtbXlDaGFpbnNcIiBhdHRyaWJ1dGUgd2hpY2ggY29udGFpbnNcbiAqICAgICAgIHRoZSBmaXJzdCBkdW1teSBpbiBlYWNoIGNoYWluIG9mIGR1bW15IG5vZGVzIHByb2R1Y2VkLlxuICovXG5mdW5jdGlvbiBydW4oZykge1xuICBnLmdyYXBoKCkuZHVtbXlDaGFpbnMgPSBbXTtcbiAgXy5mb3JFYWNoKGcuZWRnZXMoKSwgZnVuY3Rpb24oZWRnZSkgeyBub3JtYWxpemVFZGdlKGcsIGVkZ2UpOyB9KTtcbn1cblxuZnVuY3Rpb24gbm9ybWFsaXplRWRnZShnLCBlKSB7XG4gIHZhciB2ID0gZS52O1xuICB2YXIgdlJhbmsgPSBnLm5vZGUodikucmFuaztcbiAgdmFyIHcgPSBlLnc7XG4gIHZhciB3UmFuayA9IGcubm9kZSh3KS5yYW5rO1xuICB2YXIgbmFtZSA9IGUubmFtZTtcbiAgdmFyIGVkZ2VMYWJlbCA9IGcuZWRnZShlKTtcbiAgdmFyIGxhYmVsUmFuayA9IGVkZ2VMYWJlbC5sYWJlbFJhbms7XG5cbiAgaWYgKHdSYW5rID09PSB2UmFuayArIDEpIHJldHVybjtcblxuICBnLnJlbW92ZUVkZ2UoZSk7XG5cbiAgdmFyIGR1bW15LCBhdHRycywgaTtcbiAgZm9yIChpID0gMCwgKyt2UmFuazsgdlJhbmsgPCB3UmFuazsgKytpLCArK3ZSYW5rKSB7XG4gICAgZWRnZUxhYmVsLnBvaW50cyA9IFtdO1xuICAgIGF0dHJzID0ge1xuICAgICAgd2lkdGg6IDAsIGhlaWdodDogMCxcbiAgICAgIGVkZ2VMYWJlbDogZWRnZUxhYmVsLCBlZGdlT2JqOiBlLFxuICAgICAgcmFuazogdlJhbmtcbiAgICB9O1xuICAgIGR1bW15ID0gdXRpbC5hZGREdW1teU5vZGUoZywgXCJlZGdlXCIsIGF0dHJzLCBcIl9kXCIpO1xuICAgIGlmICh2UmFuayA9PT0gbGFiZWxSYW5rKSB7XG4gICAgICBhdHRycy53aWR0aCA9IGVkZ2VMYWJlbC53aWR0aDtcbiAgICAgIGF0dHJzLmhlaWdodCA9IGVkZ2VMYWJlbC5oZWlnaHQ7XG4gICAgICBhdHRycy5kdW1teSA9IFwiZWRnZS1sYWJlbFwiO1xuICAgICAgYXR0cnMubGFiZWxwb3MgPSBlZGdlTGFiZWwubGFiZWxwb3M7XG4gICAgfVxuICAgIGcuc2V0RWRnZSh2LCBkdW1teSwgeyB3ZWlnaHQ6IGVkZ2VMYWJlbC53ZWlnaHQgfSwgbmFtZSk7XG4gICAgaWYgKGkgPT09IDApIHtcbiAgICAgIGcuZ3JhcGgoKS5kdW1teUNoYWlucy5wdXNoKGR1bW15KTtcbiAgICB9XG4gICAgdiA9IGR1bW15O1xuICB9XG5cbiAgZy5zZXRFZGdlKHYsIHcsIHsgd2VpZ2h0OiBlZGdlTGFiZWwud2VpZ2h0IH0sIG5hbWUpO1xufVxuXG5mdW5jdGlvbiB1bmRvKGcpIHtcbiAgXy5mb3JFYWNoKGcuZ3JhcGgoKS5kdW1teUNoYWlucywgZnVuY3Rpb24odikge1xuICAgIHZhciBub2RlID0gZy5ub2RlKHYpO1xuICAgIHZhciBvcmlnTGFiZWwgPSBub2RlLmVkZ2VMYWJlbDtcbiAgICB2YXIgdztcbiAgICBnLnNldEVkZ2Uobm9kZS5lZGdlT2JqLCBvcmlnTGFiZWwpO1xuICAgIHdoaWxlIChub2RlLmR1bW15KSB7XG4gICAgICB3ID0gZy5zdWNjZXNzb3JzKHYpWzBdO1xuICAgICAgZy5yZW1vdmVOb2RlKHYpO1xuICAgICAgb3JpZ0xhYmVsLnBvaW50cy5wdXNoKHsgeDogbm9kZS54LCB5OiBub2RlLnkgfSk7XG4gICAgICBpZiAobm9kZS5kdW1teSA9PT0gXCJlZGdlLWxhYmVsXCIpIHtcbiAgICAgICAgb3JpZ0xhYmVsLnggPSBub2RlLng7XG4gICAgICAgIG9yaWdMYWJlbC55ID0gbm9kZS55O1xuICAgICAgICBvcmlnTGFiZWwud2lkdGggPSBub2RlLndpZHRoO1xuICAgICAgICBvcmlnTGFiZWwuaGVpZ2h0ID0gbm9kZS5oZWlnaHQ7XG4gICAgICB9XG4gICAgICB2ID0gdztcbiAgICAgIG5vZGUgPSBnLm5vZGUodik7XG4gICAgfVxuICB9KTtcbn1cbiIsInZhciBfID0gcmVxdWlyZShcIi4uL2xvZGFzaFwiKTtcblxubW9kdWxlLmV4cG9ydHMgPSBhZGRTdWJncmFwaENvbnN0cmFpbnRzO1xuXG5mdW5jdGlvbiBhZGRTdWJncmFwaENvbnN0cmFpbnRzKGcsIGNnLCB2cykge1xuICB2YXIgcHJldiA9IHt9LFxuICAgIHJvb3RQcmV2O1xuXG4gIF8uZm9yRWFjaCh2cywgZnVuY3Rpb24odikge1xuICAgIHZhciBjaGlsZCA9IGcucGFyZW50KHYpLFxuICAgICAgcGFyZW50LFxuICAgICAgcHJldkNoaWxkO1xuICAgIHdoaWxlIChjaGlsZCkge1xuICAgICAgcGFyZW50ID0gZy5wYXJlbnQoY2hpbGQpO1xuICAgICAgaWYgKHBhcmVudCkge1xuICAgICAgICBwcmV2Q2hpbGQgPSBwcmV2W3BhcmVudF07XG4gICAgICAgIHByZXZbcGFyZW50XSA9IGNoaWxkO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcHJldkNoaWxkID0gcm9vdFByZXY7XG4gICAgICAgIHJvb3RQcmV2ID0gY2hpbGQ7XG4gICAgICB9XG4gICAgICBpZiAocHJldkNoaWxkICYmIHByZXZDaGlsZCAhPT0gY2hpbGQpIHtcbiAgICAgICAgY2cuc2V0RWRnZShwcmV2Q2hpbGQsIGNoaWxkKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY2hpbGQgPSBwYXJlbnQ7XG4gICAgfVxuICB9KTtcblxuICAvKlxuICBmdW5jdGlvbiBkZnModikge1xuICAgIHZhciBjaGlsZHJlbiA9IHYgPyBnLmNoaWxkcmVuKHYpIDogZy5jaGlsZHJlbigpO1xuICAgIGlmIChjaGlsZHJlbi5sZW5ndGgpIHtcbiAgICAgIHZhciBtaW4gPSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFksXG4gICAgICAgICAgc3ViZ3JhcGhzID0gW107XG4gICAgICBfLmVhY2goY2hpbGRyZW4sIGZ1bmN0aW9uKGNoaWxkKSB7XG4gICAgICAgIHZhciBjaGlsZE1pbiA9IGRmcyhjaGlsZCk7XG4gICAgICAgIGlmIChnLmNoaWxkcmVuKGNoaWxkKS5sZW5ndGgpIHtcbiAgICAgICAgICBzdWJncmFwaHMucHVzaCh7IHY6IGNoaWxkLCBvcmRlcjogY2hpbGRNaW4gfSk7XG4gICAgICAgIH1cbiAgICAgICAgbWluID0gTWF0aC5taW4obWluLCBjaGlsZE1pbik7XG4gICAgICB9KTtcbiAgICAgIF8ucmVkdWNlKF8uc29ydEJ5KHN1YmdyYXBocywgXCJvcmRlclwiKSwgZnVuY3Rpb24ocHJldiwgY3Vycikge1xuICAgICAgICBjZy5zZXRFZGdlKHByZXYudiwgY3Vyci52KTtcbiAgICAgICAgcmV0dXJuIGN1cnI7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBtaW47XG4gICAgfVxuICAgIHJldHVybiBnLm5vZGUodikub3JkZXI7XG4gIH1cbiAgZGZzKHVuZGVmaW5lZCk7XG4gICovXG59XG4iLCJ2YXIgXyA9IHJlcXVpcmUoXCIuLi9sb2Rhc2hcIik7XG5cbm1vZHVsZS5leHBvcnRzID0gYmFyeWNlbnRlcjtcblxuZnVuY3Rpb24gYmFyeWNlbnRlcihnLCBtb3ZhYmxlKSB7XG4gIHJldHVybiBfLm1hcChtb3ZhYmxlLCBmdW5jdGlvbih2KSB7XG4gICAgdmFyIGluViA9IGcuaW5FZGdlcyh2KTtcbiAgICBpZiAoIWluVi5sZW5ndGgpIHtcbiAgICAgIHJldHVybiB7IHY6IHYgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHJlc3VsdCA9IF8ucmVkdWNlKGluViwgZnVuY3Rpb24oYWNjLCBlKSB7XG4gICAgICAgIHZhciBlZGdlID0gZy5lZGdlKGUpLFxuICAgICAgICAgIG5vZGVVID0gZy5ub2RlKGUudik7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgc3VtOiBhY2Muc3VtICsgKGVkZ2Uud2VpZ2h0ICogbm9kZVUub3JkZXIpLFxuICAgICAgICAgIHdlaWdodDogYWNjLndlaWdodCArIGVkZ2Uud2VpZ2h0XG4gICAgICAgIH07XG4gICAgICB9LCB7IHN1bTogMCwgd2VpZ2h0OiAwIH0pO1xuXG4gICAgICByZXR1cm4ge1xuICAgICAgICB2OiB2LFxuICAgICAgICBiYXJ5Y2VudGVyOiByZXN1bHQuc3VtIC8gcmVzdWx0LndlaWdodCxcbiAgICAgICAgd2VpZ2h0OiByZXN1bHQud2VpZ2h0XG4gICAgICB9O1xuICAgIH1cbiAgfSk7XG59XG5cbiIsInZhciBfID0gcmVxdWlyZShcIi4uL2xvZGFzaFwiKTtcbnZhciBHcmFwaCA9IHJlcXVpcmUoXCIuLi9ncmFwaGxpYlwiKS5HcmFwaDtcblxubW9kdWxlLmV4cG9ydHMgPSBidWlsZExheWVyR3JhcGg7XG5cbi8qXG4gKiBDb25zdHJ1Y3RzIGEgZ3JhcGggdGhhdCBjYW4gYmUgdXNlZCB0byBzb3J0IGEgbGF5ZXIgb2Ygbm9kZXMuIFRoZSBncmFwaCB3aWxsXG4gKiBjb250YWluIGFsbCBiYXNlIGFuZCBzdWJncmFwaCBub2RlcyBmcm9tIHRoZSByZXF1ZXN0IGxheWVyIGluIHRoZWlyIG9yaWdpbmFsXG4gKiBoaWVyYXJjaHkgYW5kIGFueSBlZGdlcyB0aGF0IGFyZSBpbmNpZGVudCBvbiB0aGVzZSBub2RlcyBhbmQgYXJlIG9mIHRoZSB0eXBlXG4gKiByZXF1ZXN0ZWQgYnkgdGhlIFwicmVsYXRpb25zaGlwXCIgcGFyYW1ldGVyLlxuICpcbiAqIE5vZGVzIGZyb20gdGhlIHJlcXVlc3RlZCByYW5rIHRoYXQgZG8gbm90IGhhdmUgcGFyZW50cyBhcmUgYXNzaWduZWQgYSByb290XG4gKiBub2RlIGluIHRoZSBvdXRwdXQgZ3JhcGgsIHdoaWNoIGlzIHNldCBpbiB0aGUgcm9vdCBncmFwaCBhdHRyaWJ1dGUuIFRoaXNcbiAqIG1ha2VzIGl0IGVhc3kgdG8gd2FsayB0aGUgaGllcmFyY2h5IG9mIG1vdmFibGUgbm9kZXMgZHVyaW5nIG9yZGVyaW5nLlxuICpcbiAqIFByZS1jb25kaXRpb25zOlxuICpcbiAqICAgIDEuIElucHV0IGdyYXBoIGlzIGEgREFHXG4gKiAgICAyLiBCYXNlIG5vZGVzIGluIHRoZSBpbnB1dCBncmFwaCBoYXZlIGEgcmFuayBhdHRyaWJ1dGVcbiAqICAgIDMuIFN1YmdyYXBoIG5vZGVzIGluIHRoZSBpbnB1dCBncmFwaCBoYXMgbWluUmFuayBhbmQgbWF4UmFuayBhdHRyaWJ1dGVzXG4gKiAgICA0LiBFZGdlcyBoYXZlIGFuIGFzc2lnbmVkIHdlaWdodFxuICpcbiAqIFBvc3QtY29uZGl0aW9uczpcbiAqXG4gKiAgICAxLiBPdXRwdXQgZ3JhcGggaGFzIGFsbCBub2RlcyBpbiB0aGUgbW92YWJsZSByYW5rIHdpdGggcHJlc2VydmVkXG4gKiAgICAgICBoaWVyYXJjaHkuXG4gKiAgICAyLiBSb290IG5vZGVzIGluIHRoZSBtb3ZhYmxlIGxheWVyIGFyZSBtYWRlIGNoaWxkcmVuIG9mIHRoZSBub2RlXG4gKiAgICAgICBpbmRpY2F0ZWQgYnkgdGhlIHJvb3QgYXR0cmlidXRlIG9mIHRoZSBncmFwaC5cbiAqICAgIDMuIE5vbi1tb3ZhYmxlIG5vZGVzIGluY2lkZW50IG9uIG1vdmFibGUgbm9kZXMsIHNlbGVjdGVkIGJ5IHRoZVxuICogICAgICAgcmVsYXRpb25zaGlwIHBhcmFtZXRlciwgYXJlIGluY2x1ZGVkIGluIHRoZSBncmFwaCAod2l0aG91dCBoaWVyYXJjaHkpLlxuICogICAgNC4gRWRnZXMgaW5jaWRlbnQgb24gbW92YWJsZSBub2Rlcywgc2VsZWN0ZWQgYnkgdGhlIHJlbGF0aW9uc2hpcFxuICogICAgICAgcGFyYW1ldGVyLCBhcmUgYWRkZWQgdG8gdGhlIG91dHB1dCBncmFwaC5cbiAqICAgIDUuIFRoZSB3ZWlnaHRzIGZvciBjb3BpZWQgZWRnZXMgYXJlIGFnZ3JlZ2F0ZWQgYXMgbmVlZCwgc2luY2UgdGhlIG91dHB1dFxuICogICAgICAgZ3JhcGggaXMgbm90IGEgbXVsdGktZ3JhcGguXG4gKi9cbmZ1bmN0aW9uIGJ1aWxkTGF5ZXJHcmFwaChnLCByYW5rLCByZWxhdGlvbnNoaXApIHtcbiAgdmFyIHJvb3QgPSBjcmVhdGVSb290Tm9kZShnKSxcbiAgICByZXN1bHQgPSBuZXcgR3JhcGgoeyBjb21wb3VuZDogdHJ1ZSB9KS5zZXRHcmFwaCh7IHJvb3Q6IHJvb3QgfSlcbiAgICAgIC5zZXREZWZhdWx0Tm9kZUxhYmVsKGZ1bmN0aW9uKHYpIHsgcmV0dXJuIGcubm9kZSh2KTsgfSk7XG5cbiAgXy5mb3JFYWNoKGcubm9kZXMoKSwgZnVuY3Rpb24odikge1xuICAgIHZhciBub2RlID0gZy5ub2RlKHYpLFxuICAgICAgcGFyZW50ID0gZy5wYXJlbnQodik7XG5cbiAgICBpZiAobm9kZS5yYW5rID09PSByYW5rIHx8IG5vZGUubWluUmFuayA8PSByYW5rICYmIHJhbmsgPD0gbm9kZS5tYXhSYW5rKSB7XG4gICAgICByZXN1bHQuc2V0Tm9kZSh2KTtcbiAgICAgIHJlc3VsdC5zZXRQYXJlbnQodiwgcGFyZW50IHx8IHJvb3QpO1xuXG4gICAgICAvLyBUaGlzIGFzc3VtZXMgd2UgaGF2ZSBvbmx5IHNob3J0IGVkZ2VzIVxuICAgICAgXy5mb3JFYWNoKGdbcmVsYXRpb25zaGlwXSh2KSwgZnVuY3Rpb24oZSkge1xuICAgICAgICB2YXIgdSA9IGUudiA9PT0gdiA/IGUudyA6IGUudixcbiAgICAgICAgICBlZGdlID0gcmVzdWx0LmVkZ2UodSwgdiksXG4gICAgICAgICAgd2VpZ2h0ID0gIV8uaXNVbmRlZmluZWQoZWRnZSkgPyBlZGdlLndlaWdodCA6IDA7XG4gICAgICAgIHJlc3VsdC5zZXRFZGdlKHUsIHYsIHsgd2VpZ2h0OiBnLmVkZ2UoZSkud2VpZ2h0ICsgd2VpZ2h0IH0pO1xuICAgICAgfSk7XG5cbiAgICAgIGlmIChfLmhhcyhub2RlLCBcIm1pblJhbmtcIikpIHtcbiAgICAgICAgcmVzdWx0LnNldE5vZGUodiwge1xuICAgICAgICAgIGJvcmRlckxlZnQ6IG5vZGUuYm9yZGVyTGVmdFtyYW5rXSxcbiAgICAgICAgICBib3JkZXJSaWdodDogbm9kZS5ib3JkZXJSaWdodFtyYW5rXVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVJvb3ROb2RlKGcpIHtcbiAgdmFyIHY7XG4gIHdoaWxlIChnLmhhc05vZGUoKHYgPSBfLnVuaXF1ZUlkKFwiX3Jvb3RcIikpKSk7XG4gIHJldHVybiB2O1xufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfID0gcmVxdWlyZShcIi4uL2xvZGFzaFwiKTtcblxubW9kdWxlLmV4cG9ydHMgPSBjcm9zc0NvdW50O1xuXG4vKlxuICogQSBmdW5jdGlvbiB0aGF0IHRha2VzIGEgbGF5ZXJpbmcgKGFuIGFycmF5IG9mIGxheWVycywgZWFjaCB3aXRoIGFuIGFycmF5IG9mXG4gKiBvcmRlcmVyZCBub2RlcykgYW5kIGEgZ3JhcGggYW5kIHJldHVybnMgYSB3ZWlnaHRlZCBjcm9zc2luZyBjb3VudC5cbiAqXG4gKiBQcmUtY29uZGl0aW9uczpcbiAqXG4gKiAgICAxLiBJbnB1dCBncmFwaCBtdXN0IGJlIHNpbXBsZSAobm90IGEgbXVsdGlncmFwaCksIGRpcmVjdGVkLCBhbmQgaW5jbHVkZVxuICogICAgICAgb25seSBzaW1wbGUgZWRnZXMuXG4gKiAgICAyLiBFZGdlcyBpbiB0aGUgaW5wdXQgZ3JhcGggbXVzdCBoYXZlIGFzc2lnbmVkIHdlaWdodHMuXG4gKlxuICogUG9zdC1jb25kaXRpb25zOlxuICpcbiAqICAgIDEuIFRoZSBncmFwaCBhbmQgbGF5ZXJpbmcgbWF0cml4IGFyZSBsZWZ0IHVuY2hhbmdlZC5cbiAqXG4gKiBUaGlzIGFsZ29yaXRobSBpcyBkZXJpdmVkIGZyb20gQmFydGgsIGV0IGFsLiwgXCJCaWxheWVyIENyb3NzIENvdW50aW5nLlwiXG4gKi9cbmZ1bmN0aW9uIGNyb3NzQ291bnQoZywgbGF5ZXJpbmcpIHtcbiAgdmFyIGNjID0gMDtcbiAgZm9yICh2YXIgaSA9IDE7IGkgPCBsYXllcmluZy5sZW5ndGg7ICsraSkge1xuICAgIGNjICs9IHR3b0xheWVyQ3Jvc3NDb3VudChnLCBsYXllcmluZ1tpLTFdLCBsYXllcmluZ1tpXSk7XG4gIH1cbiAgcmV0dXJuIGNjO1xufVxuXG5mdW5jdGlvbiB0d29MYXllckNyb3NzQ291bnQoZywgbm9ydGhMYXllciwgc291dGhMYXllcikge1xuICAvLyBTb3J0IGFsbCBvZiB0aGUgZWRnZXMgYmV0d2VlbiB0aGUgbm9ydGggYW5kIHNvdXRoIGxheWVycyBieSB0aGVpciBwb3NpdGlvblxuICAvLyBpbiB0aGUgbm9ydGggbGF5ZXIgYW5kIHRoZW4gdGhlIHNvdXRoLiBNYXAgdGhlc2UgZWRnZXMgdG8gdGhlIHBvc2l0aW9uIG9mXG4gIC8vIHRoZWlyIGhlYWQgaW4gdGhlIHNvdXRoIGxheWVyLlxuICB2YXIgc291dGhQb3MgPSBfLnppcE9iamVjdChzb3V0aExheWVyLFxuICAgIF8ubWFwKHNvdXRoTGF5ZXIsIGZ1bmN0aW9uICh2LCBpKSB7IHJldHVybiBpOyB9KSk7XG4gIHZhciBzb3V0aEVudHJpZXMgPSBfLmZsYXR0ZW4oXy5tYXAobm9ydGhMYXllciwgZnVuY3Rpb24odikge1xuICAgIHJldHVybiBfLnNvcnRCeShfLm1hcChnLm91dEVkZ2VzKHYpLCBmdW5jdGlvbihlKSB7XG4gICAgICByZXR1cm4geyBwb3M6IHNvdXRoUG9zW2Uud10sIHdlaWdodDogZy5lZGdlKGUpLndlaWdodCB9O1xuICAgIH0pLCBcInBvc1wiKTtcbiAgfSksIHRydWUpO1xuXG4gIC8vIEJ1aWxkIHRoZSBhY2N1bXVsYXRvciB0cmVlXG4gIHZhciBmaXJzdEluZGV4ID0gMTtcbiAgd2hpbGUgKGZpcnN0SW5kZXggPCBzb3V0aExheWVyLmxlbmd0aCkgZmlyc3RJbmRleCA8PD0gMTtcbiAgdmFyIHRyZWVTaXplID0gMiAqIGZpcnN0SW5kZXggLSAxO1xuICBmaXJzdEluZGV4IC09IDE7XG4gIHZhciB0cmVlID0gXy5tYXAobmV3IEFycmF5KHRyZWVTaXplKSwgZnVuY3Rpb24oKSB7IHJldHVybiAwOyB9KTtcblxuICAvLyBDYWxjdWxhdGUgdGhlIHdlaWdodGVkIGNyb3NzaW5nc1xuICB2YXIgY2MgPSAwO1xuICBfLmZvckVhY2goc291dGhFbnRyaWVzLmZvckVhY2goZnVuY3Rpb24oZW50cnkpIHtcbiAgICB2YXIgaW5kZXggPSBlbnRyeS5wb3MgKyBmaXJzdEluZGV4O1xuICAgIHRyZWVbaW5kZXhdICs9IGVudHJ5LndlaWdodDtcbiAgICB2YXIgd2VpZ2h0U3VtID0gMDtcbiAgICB3aGlsZSAoaW5kZXggPiAwKSB7XG4gICAgICBpZiAoaW5kZXggJSAyKSB7XG4gICAgICAgIHdlaWdodFN1bSArPSB0cmVlW2luZGV4ICsgMV07XG4gICAgICB9XG4gICAgICBpbmRleCA9IChpbmRleCAtIDEpID4+IDE7XG4gICAgICB0cmVlW2luZGV4XSArPSBlbnRyeS53ZWlnaHQ7XG4gICAgfVxuICAgIGNjICs9IGVudHJ5LndlaWdodCAqIHdlaWdodFN1bTtcbiAgfSkpO1xuXG4gIHJldHVybiBjYztcbn1cbiIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgXyA9IHJlcXVpcmUoXCIuLi9sb2Rhc2hcIik7XG52YXIgaW5pdE9yZGVyID0gcmVxdWlyZShcIi4vaW5pdC1vcmRlclwiKTtcbnZhciBjcm9zc0NvdW50ID0gcmVxdWlyZShcIi4vY3Jvc3MtY291bnRcIik7XG52YXIgc29ydFN1YmdyYXBoID0gcmVxdWlyZShcIi4vc29ydC1zdWJncmFwaFwiKTtcbnZhciBidWlsZExheWVyR3JhcGggPSByZXF1aXJlKFwiLi9idWlsZC1sYXllci1ncmFwaFwiKTtcbnZhciBhZGRTdWJncmFwaENvbnN0cmFpbnRzID0gcmVxdWlyZShcIi4vYWRkLXN1YmdyYXBoLWNvbnN0cmFpbnRzXCIpO1xudmFyIEdyYXBoID0gcmVxdWlyZShcIi4uL2dyYXBobGliXCIpLkdyYXBoO1xudmFyIHV0aWwgPSByZXF1aXJlKFwiLi4vdXRpbFwiKTtcblxubW9kdWxlLmV4cG9ydHMgPSBvcmRlcjtcblxuLypcbiAqIEFwcGxpZXMgaGV1cmlzdGljcyB0byBtaW5pbWl6ZSBlZGdlIGNyb3NzaW5ncyBpbiB0aGUgZ3JhcGggYW5kIHNldHMgdGhlIGJlc3RcbiAqIG9yZGVyIHNvbHV0aW9uIGFzIGFuIG9yZGVyIGF0dHJpYnV0ZSBvbiBlYWNoIG5vZGUuXG4gKlxuICogUHJlLWNvbmRpdGlvbnM6XG4gKlxuICogICAgMS4gR3JhcGggbXVzdCBiZSBEQUdcbiAqICAgIDIuIEdyYXBoIG5vZGVzIG11c3QgYmUgb2JqZWN0cyB3aXRoIGEgXCJyYW5rXCIgYXR0cmlidXRlXG4gKiAgICAzLiBHcmFwaCBlZGdlcyBtdXN0IGhhdmUgdGhlIFwid2VpZ2h0XCIgYXR0cmlidXRlXG4gKlxuICogUG9zdC1jb25kaXRpb25zOlxuICpcbiAqICAgIDEuIEdyYXBoIG5vZGVzIHdpbGwgaGF2ZSBhbiBcIm9yZGVyXCIgYXR0cmlidXRlIGJhc2VkIG9uIHRoZSByZXN1bHRzIG9mIHRoZVxuICogICAgICAgYWxnb3JpdGhtLlxuICovXG5mdW5jdGlvbiBvcmRlcihnKSB7XG4gIHZhciBtYXhSYW5rID0gdXRpbC5tYXhSYW5rKGcpLFxuICAgIGRvd25MYXllckdyYXBocyA9IGJ1aWxkTGF5ZXJHcmFwaHMoZywgXy5yYW5nZSgxLCBtYXhSYW5rICsgMSksIFwiaW5FZGdlc1wiKSxcbiAgICB1cExheWVyR3JhcGhzID0gYnVpbGRMYXllckdyYXBocyhnLCBfLnJhbmdlKG1heFJhbmsgLSAxLCAtMSwgLTEpLCBcIm91dEVkZ2VzXCIpO1xuXG4gIHZhciBsYXllcmluZyA9IGluaXRPcmRlcihnKTtcbiAgYXNzaWduT3JkZXIoZywgbGF5ZXJpbmcpO1xuXG4gIHZhciBiZXN0Q0MgPSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFksXG4gICAgYmVzdDtcblxuICBmb3IgKHZhciBpID0gMCwgbGFzdEJlc3QgPSAwOyBsYXN0QmVzdCA8IDQ7ICsraSwgKytsYXN0QmVzdCkge1xuICAgIHN3ZWVwTGF5ZXJHcmFwaHMoaSAlIDIgPyBkb3duTGF5ZXJHcmFwaHMgOiB1cExheWVyR3JhcGhzLCBpICUgNCA+PSAyKTtcblxuICAgIGxheWVyaW5nID0gdXRpbC5idWlsZExheWVyTWF0cml4KGcpO1xuICAgIHZhciBjYyA9IGNyb3NzQ291bnQoZywgbGF5ZXJpbmcpO1xuICAgIGlmIChjYyA8IGJlc3RDQykge1xuICAgICAgbGFzdEJlc3QgPSAwO1xuICAgICAgYmVzdCA9IF8uY2xvbmVEZWVwKGxheWVyaW5nKTtcbiAgICAgIGJlc3RDQyA9IGNjO1xuICAgIH1cbiAgfVxuXG4gIGFzc2lnbk9yZGVyKGcsIGJlc3QpO1xufVxuXG5mdW5jdGlvbiBidWlsZExheWVyR3JhcGhzKGcsIHJhbmtzLCByZWxhdGlvbnNoaXApIHtcbiAgcmV0dXJuIF8ubWFwKHJhbmtzLCBmdW5jdGlvbihyYW5rKSB7XG4gICAgcmV0dXJuIGJ1aWxkTGF5ZXJHcmFwaChnLCByYW5rLCByZWxhdGlvbnNoaXApO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gc3dlZXBMYXllckdyYXBocyhsYXllckdyYXBocywgYmlhc1JpZ2h0KSB7XG4gIHZhciBjZyA9IG5ldyBHcmFwaCgpO1xuICBfLmZvckVhY2gobGF5ZXJHcmFwaHMsIGZ1bmN0aW9uKGxnKSB7XG4gICAgdmFyIHJvb3QgPSBsZy5ncmFwaCgpLnJvb3Q7XG4gICAgdmFyIHNvcnRlZCA9IHNvcnRTdWJncmFwaChsZywgcm9vdCwgY2csIGJpYXNSaWdodCk7XG4gICAgXy5mb3JFYWNoKHNvcnRlZC52cywgZnVuY3Rpb24odiwgaSkge1xuICAgICAgbGcubm9kZSh2KS5vcmRlciA9IGk7XG4gICAgfSk7XG4gICAgYWRkU3ViZ3JhcGhDb25zdHJhaW50cyhsZywgY2csIHNvcnRlZC52cyk7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBhc3NpZ25PcmRlcihnLCBsYXllcmluZykge1xuICBfLmZvckVhY2gobGF5ZXJpbmcsIGZ1bmN0aW9uKGxheWVyKSB7XG4gICAgXy5mb3JFYWNoKGxheWVyLCBmdW5jdGlvbih2LCBpKSB7XG4gICAgICBnLm5vZGUodikub3JkZXIgPSBpO1xuICAgIH0pO1xuICB9KTtcbn1cbiIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgXyA9IHJlcXVpcmUoXCIuLi9sb2Rhc2hcIik7XG5cbm1vZHVsZS5leHBvcnRzID0gaW5pdE9yZGVyO1xuXG4vKlxuICogQXNzaWducyBhbiBpbml0aWFsIG9yZGVyIHZhbHVlIGZvciBlYWNoIG5vZGUgYnkgcGVyZm9ybWluZyBhIERGUyBzZWFyY2hcbiAqIHN0YXJ0aW5nIGZyb20gbm9kZXMgaW4gdGhlIGZpcnN0IHJhbmsuIE5vZGVzIGFyZSBhc3NpZ25lZCBhbiBvcmRlciBpbiB0aGVpclxuICogcmFuayBhcyB0aGV5IGFyZSBmaXJzdCB2aXNpdGVkLlxuICpcbiAqIFRoaXMgYXBwcm9hY2ggY29tZXMgZnJvbSBHYW5zbmVyLCBldCBhbC4sIFwiQSBUZWNobmlxdWUgZm9yIERyYXdpbmcgRGlyZWN0ZWRcbiAqIEdyYXBocy5cIlxuICpcbiAqIFJldHVybnMgYSBsYXllcmluZyBtYXRyaXggd2l0aCBhbiBhcnJheSBwZXIgbGF5ZXIgYW5kIGVhY2ggbGF5ZXIgc29ydGVkIGJ5XG4gKiB0aGUgb3JkZXIgb2YgaXRzIG5vZGVzLlxuICovXG5mdW5jdGlvbiBpbml0T3JkZXIoZykge1xuICB2YXIgdmlzaXRlZCA9IHt9O1xuICB2YXIgc2ltcGxlTm9kZXMgPSBfLmZpbHRlcihnLm5vZGVzKCksIGZ1bmN0aW9uKHYpIHtcbiAgICByZXR1cm4gIWcuY2hpbGRyZW4odikubGVuZ3RoO1xuICB9KTtcbiAgdmFyIG1heFJhbmsgPSBfLm1heChfLm1hcChzaW1wbGVOb2RlcywgZnVuY3Rpb24odikgeyByZXR1cm4gZy5ub2RlKHYpLnJhbms7IH0pKTtcbiAgdmFyIGxheWVycyA9IF8ubWFwKF8ucmFuZ2UobWF4UmFuayArIDEpLCBmdW5jdGlvbigpIHsgcmV0dXJuIFtdOyB9KTtcblxuICBmdW5jdGlvbiBkZnModikge1xuICAgIGlmIChfLmhhcyh2aXNpdGVkLCB2KSkgcmV0dXJuO1xuICAgIHZpc2l0ZWRbdl0gPSB0cnVlO1xuICAgIHZhciBub2RlID0gZy5ub2RlKHYpO1xuICAgIGxheWVyc1tub2RlLnJhbmtdLnB1c2godik7XG4gICAgXy5mb3JFYWNoKGcuc3VjY2Vzc29ycyh2KSwgZGZzKTtcbiAgfVxuXG4gIHZhciBvcmRlcmVkVnMgPSBfLnNvcnRCeShzaW1wbGVOb2RlcywgZnVuY3Rpb24odikgeyByZXR1cm4gZy5ub2RlKHYpLnJhbms7IH0pO1xuICBfLmZvckVhY2gob3JkZXJlZFZzLCBkZnMpO1xuXG4gIHJldHVybiBsYXllcnM7XG59XG4iLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIF8gPSByZXF1aXJlKFwiLi4vbG9kYXNoXCIpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJlc29sdmVDb25mbGljdHM7XG5cbi8qXG4gKiBHaXZlbiBhIGxpc3Qgb2YgZW50cmllcyBvZiB0aGUgZm9ybSB7diwgYmFyeWNlbnRlciwgd2VpZ2h0fSBhbmQgYVxuICogY29uc3RyYWludCBncmFwaCB0aGlzIGZ1bmN0aW9uIHdpbGwgcmVzb2x2ZSBhbnkgY29uZmxpY3RzIGJldHdlZW4gdGhlXG4gKiBjb25zdHJhaW50IGdyYXBoIGFuZCB0aGUgYmFyeWNlbnRlcnMgZm9yIHRoZSBlbnRyaWVzLiBJZiB0aGUgYmFyeWNlbnRlcnMgZm9yXG4gKiBhbiBlbnRyeSB3b3VsZCB2aW9sYXRlIGEgY29uc3RyYWludCBpbiB0aGUgY29uc3RyYWludCBncmFwaCB0aGVuIHdlIGNvYWxlc2NlXG4gKiB0aGUgbm9kZXMgaW4gdGhlIGNvbmZsaWN0IGludG8gYSBuZXcgbm9kZSB0aGF0IHJlc3BlY3RzIHRoZSBjb250cmFpbnQgYW5kXG4gKiBhZ2dyZWdhdGVzIGJhcnljZW50ZXIgYW5kIHdlaWdodCBpbmZvcm1hdGlvbi5cbiAqXG4gKiBUaGlzIGltcGxlbWVudGF0aW9uIGlzIGJhc2VkIG9uIHRoZSBkZXNjcmlwdGlvbiBpbiBGb3JzdGVyLCBcIkEgRmFzdCBhbmRcbiAqIFNpbXBsZSBIdWVyaXN0aWMgZm9yIENvbnN0cmFpbmVkIFR3by1MZXZlbCBDcm9zc2luZyBSZWR1Y3Rpb24sXCIgdGhvdWdodCBpdFxuICogZGlmZmVycyBpbiBzb21lIHNwZWNpZmljIGRldGFpbHMuXG4gKlxuICogUHJlLWNvbmRpdGlvbnM6XG4gKlxuICogICAgMS4gRWFjaCBlbnRyeSBoYXMgdGhlIGZvcm0ge3YsIGJhcnljZW50ZXIsIHdlaWdodH0sIG9yIGlmIHRoZSBub2RlIGhhc1xuICogICAgICAgbm8gYmFyeWNlbnRlciwgdGhlbiB7dn0uXG4gKlxuICogUmV0dXJuczpcbiAqXG4gKiAgICBBIG5ldyBsaXN0IG9mIGVudHJpZXMgb2YgdGhlIGZvcm0ge3ZzLCBpLCBiYXJ5Y2VudGVyLCB3ZWlnaHR9LiBUaGUgbGlzdFxuICogICAgYHZzYCBtYXkgZWl0aGVyIGJlIGEgc2luZ2xldG9uIG9yIGl0IG1heSBiZSBhbiBhZ2dyZWdhdGlvbiBvZiBub2Rlc1xuICogICAgb3JkZXJlZCBzdWNoIHRoYXQgdGhleSBkbyBub3QgdmlvbGF0ZSBjb25zdHJhaW50cyBmcm9tIHRoZSBjb25zdHJhaW50XG4gKiAgICBncmFwaC4gVGhlIHByb3BlcnR5IGBpYCBpcyB0aGUgbG93ZXN0IG9yaWdpbmFsIGluZGV4IG9mIGFueSBvZiB0aGVcbiAqICAgIGVsZW1lbnRzIGluIGB2c2AuXG4gKi9cbmZ1bmN0aW9uIHJlc29sdmVDb25mbGljdHMoZW50cmllcywgY2cpIHtcbiAgdmFyIG1hcHBlZEVudHJpZXMgPSB7fTtcbiAgXy5mb3JFYWNoKGVudHJpZXMsIGZ1bmN0aW9uKGVudHJ5LCBpKSB7XG4gICAgdmFyIHRtcCA9IG1hcHBlZEVudHJpZXNbZW50cnkudl0gPSB7XG4gICAgICBpbmRlZ3JlZTogMCxcbiAgICAgIFwiaW5cIjogW10sXG4gICAgICBvdXQ6IFtdLFxuICAgICAgdnM6IFtlbnRyeS52XSxcbiAgICAgIGk6IGlcbiAgICB9O1xuICAgIGlmICghXy5pc1VuZGVmaW5lZChlbnRyeS5iYXJ5Y2VudGVyKSkge1xuICAgICAgdG1wLmJhcnljZW50ZXIgPSBlbnRyeS5iYXJ5Y2VudGVyO1xuICAgICAgdG1wLndlaWdodCA9IGVudHJ5LndlaWdodDtcbiAgICB9XG4gIH0pO1xuXG4gIF8uZm9yRWFjaChjZy5lZGdlcygpLCBmdW5jdGlvbihlKSB7XG4gICAgdmFyIGVudHJ5ViA9IG1hcHBlZEVudHJpZXNbZS52XTtcbiAgICB2YXIgZW50cnlXID0gbWFwcGVkRW50cmllc1tlLnddO1xuICAgIGlmICghXy5pc1VuZGVmaW5lZChlbnRyeVYpICYmICFfLmlzVW5kZWZpbmVkKGVudHJ5VykpIHtcbiAgICAgIGVudHJ5Vy5pbmRlZ3JlZSsrO1xuICAgICAgZW50cnlWLm91dC5wdXNoKG1hcHBlZEVudHJpZXNbZS53XSk7XG4gICAgfVxuICB9KTtcblxuICB2YXIgc291cmNlU2V0ID0gXy5maWx0ZXIobWFwcGVkRW50cmllcywgZnVuY3Rpb24oZW50cnkpIHtcbiAgICByZXR1cm4gIWVudHJ5LmluZGVncmVlO1xuICB9KTtcblxuICByZXR1cm4gZG9SZXNvbHZlQ29uZmxpY3RzKHNvdXJjZVNldCk7XG59XG5cbmZ1bmN0aW9uIGRvUmVzb2x2ZUNvbmZsaWN0cyhzb3VyY2VTZXQpIHtcbiAgdmFyIGVudHJpZXMgPSBbXTtcblxuICBmdW5jdGlvbiBoYW5kbGVJbih2RW50cnkpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24odUVudHJ5KSB7XG4gICAgICBpZiAodUVudHJ5Lm1lcmdlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoXy5pc1VuZGVmaW5lZCh1RW50cnkuYmFyeWNlbnRlcikgfHxcbiAgICAgICAgICBfLmlzVW5kZWZpbmVkKHZFbnRyeS5iYXJ5Y2VudGVyKSB8fFxuICAgICAgICAgIHVFbnRyeS5iYXJ5Y2VudGVyID49IHZFbnRyeS5iYXJ5Y2VudGVyKSB7XG4gICAgICAgIG1lcmdlRW50cmllcyh2RW50cnksIHVFbnRyeSk7XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGhhbmRsZU91dCh2RW50cnkpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24od0VudHJ5KSB7XG4gICAgICB3RW50cnlbXCJpblwiXS5wdXNoKHZFbnRyeSk7XG4gICAgICBpZiAoLS13RW50cnkuaW5kZWdyZWUgPT09IDApIHtcbiAgICAgICAgc291cmNlU2V0LnB1c2god0VudHJ5KTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgd2hpbGUgKHNvdXJjZVNldC5sZW5ndGgpIHtcbiAgICB2YXIgZW50cnkgPSBzb3VyY2VTZXQucG9wKCk7XG4gICAgZW50cmllcy5wdXNoKGVudHJ5KTtcbiAgICBfLmZvckVhY2goZW50cnlbXCJpblwiXS5yZXZlcnNlKCksIGhhbmRsZUluKGVudHJ5KSk7XG4gICAgXy5mb3JFYWNoKGVudHJ5Lm91dCwgaGFuZGxlT3V0KGVudHJ5KSk7XG4gIH1cblxuICByZXR1cm4gXy5tYXAoXy5maWx0ZXIoZW50cmllcywgZnVuY3Rpb24oZW50cnkpIHsgcmV0dXJuICFlbnRyeS5tZXJnZWQ7IH0pLFxuICAgIGZ1bmN0aW9uKGVudHJ5KSB7XG4gICAgICByZXR1cm4gXy5waWNrKGVudHJ5LCBbXCJ2c1wiLCBcImlcIiwgXCJiYXJ5Y2VudGVyXCIsIFwid2VpZ2h0XCJdKTtcbiAgICB9KTtcblxufVxuXG5mdW5jdGlvbiBtZXJnZUVudHJpZXModGFyZ2V0LCBzb3VyY2UpIHtcbiAgdmFyIHN1bSA9IDA7XG4gIHZhciB3ZWlnaHQgPSAwO1xuXG4gIGlmICh0YXJnZXQud2VpZ2h0KSB7XG4gICAgc3VtICs9IHRhcmdldC5iYXJ5Y2VudGVyICogdGFyZ2V0LndlaWdodDtcbiAgICB3ZWlnaHQgKz0gdGFyZ2V0LndlaWdodDtcbiAgfVxuXG4gIGlmIChzb3VyY2Uud2VpZ2h0KSB7XG4gICAgc3VtICs9IHNvdXJjZS5iYXJ5Y2VudGVyICogc291cmNlLndlaWdodDtcbiAgICB3ZWlnaHQgKz0gc291cmNlLndlaWdodDtcbiAgfVxuXG4gIHRhcmdldC52cyA9IHNvdXJjZS52cy5jb25jYXQodGFyZ2V0LnZzKTtcbiAgdGFyZ2V0LmJhcnljZW50ZXIgPSBzdW0gLyB3ZWlnaHQ7XG4gIHRhcmdldC53ZWlnaHQgPSB3ZWlnaHQ7XG4gIHRhcmdldC5pID0gTWF0aC5taW4oc291cmNlLmksIHRhcmdldC5pKTtcbiAgc291cmNlLm1lcmdlZCA9IHRydWU7XG59XG4iLCJ2YXIgXyA9IHJlcXVpcmUoXCIuLi9sb2Rhc2hcIik7XG52YXIgYmFyeWNlbnRlciA9IHJlcXVpcmUoXCIuL2JhcnljZW50ZXJcIik7XG52YXIgcmVzb2x2ZUNvbmZsaWN0cyA9IHJlcXVpcmUoXCIuL3Jlc29sdmUtY29uZmxpY3RzXCIpO1xudmFyIHNvcnQgPSByZXF1aXJlKFwiLi9zb3J0XCIpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHNvcnRTdWJncmFwaDtcblxuZnVuY3Rpb24gc29ydFN1YmdyYXBoKGcsIHYsIGNnLCBiaWFzUmlnaHQpIHtcbiAgdmFyIG1vdmFibGUgPSBnLmNoaWxkcmVuKHYpO1xuICB2YXIgbm9kZSA9IGcubm9kZSh2KTtcbiAgdmFyIGJsID0gbm9kZSA/IG5vZGUuYm9yZGVyTGVmdCA6IHVuZGVmaW5lZDtcbiAgdmFyIGJyID0gbm9kZSA/IG5vZGUuYm9yZGVyUmlnaHQ6IHVuZGVmaW5lZDtcbiAgdmFyIHN1YmdyYXBocyA9IHt9O1xuXG4gIGlmIChibCkge1xuICAgIG1vdmFibGUgPSBfLmZpbHRlcihtb3ZhYmxlLCBmdW5jdGlvbih3KSB7XG4gICAgICByZXR1cm4gdyAhPT0gYmwgJiYgdyAhPT0gYnI7XG4gICAgfSk7XG4gIH1cblxuICB2YXIgYmFyeWNlbnRlcnMgPSBiYXJ5Y2VudGVyKGcsIG1vdmFibGUpO1xuICBfLmZvckVhY2goYmFyeWNlbnRlcnMsIGZ1bmN0aW9uKGVudHJ5KSB7XG4gICAgaWYgKGcuY2hpbGRyZW4oZW50cnkudikubGVuZ3RoKSB7XG4gICAgICB2YXIgc3ViZ3JhcGhSZXN1bHQgPSBzb3J0U3ViZ3JhcGgoZywgZW50cnkudiwgY2csIGJpYXNSaWdodCk7XG4gICAgICBzdWJncmFwaHNbZW50cnkudl0gPSBzdWJncmFwaFJlc3VsdDtcbiAgICAgIGlmIChfLmhhcyhzdWJncmFwaFJlc3VsdCwgXCJiYXJ5Y2VudGVyXCIpKSB7XG4gICAgICAgIG1lcmdlQmFyeWNlbnRlcnMoZW50cnksIHN1YmdyYXBoUmVzdWx0KTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuXG4gIHZhciBlbnRyaWVzID0gcmVzb2x2ZUNvbmZsaWN0cyhiYXJ5Y2VudGVycywgY2cpO1xuICBleHBhbmRTdWJncmFwaHMoZW50cmllcywgc3ViZ3JhcGhzKTtcblxuICB2YXIgcmVzdWx0ID0gc29ydChlbnRyaWVzLCBiaWFzUmlnaHQpO1xuXG4gIGlmIChibCkge1xuICAgIHJlc3VsdC52cyA9IF8uZmxhdHRlbihbYmwsIHJlc3VsdC52cywgYnJdLCB0cnVlKTtcbiAgICBpZiAoZy5wcmVkZWNlc3NvcnMoYmwpLmxlbmd0aCkge1xuICAgICAgdmFyIGJsUHJlZCA9IGcubm9kZShnLnByZWRlY2Vzc29ycyhibClbMF0pLFxuICAgICAgICBiclByZWQgPSBnLm5vZGUoZy5wcmVkZWNlc3NvcnMoYnIpWzBdKTtcbiAgICAgIGlmICghXy5oYXMocmVzdWx0LCBcImJhcnljZW50ZXJcIikpIHtcbiAgICAgICAgcmVzdWx0LmJhcnljZW50ZXIgPSAwO1xuICAgICAgICByZXN1bHQud2VpZ2h0ID0gMDtcbiAgICAgIH1cbiAgICAgIHJlc3VsdC5iYXJ5Y2VudGVyID0gKHJlc3VsdC5iYXJ5Y2VudGVyICogcmVzdWx0LndlaWdodCArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBibFByZWQub3JkZXIgKyBiclByZWQub3JkZXIpIC8gKHJlc3VsdC53ZWlnaHQgKyAyKTtcbiAgICAgIHJlc3VsdC53ZWlnaHQgKz0gMjtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiBleHBhbmRTdWJncmFwaHMoZW50cmllcywgc3ViZ3JhcGhzKSB7XG4gIF8uZm9yRWFjaChlbnRyaWVzLCBmdW5jdGlvbihlbnRyeSkge1xuICAgIGVudHJ5LnZzID0gXy5mbGF0dGVuKGVudHJ5LnZzLm1hcChmdW5jdGlvbih2KSB7XG4gICAgICBpZiAoc3ViZ3JhcGhzW3ZdKSB7XG4gICAgICAgIHJldHVybiBzdWJncmFwaHNbdl0udnM7XG4gICAgICB9XG4gICAgICByZXR1cm4gdjtcbiAgICB9KSwgdHJ1ZSk7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBtZXJnZUJhcnljZW50ZXJzKHRhcmdldCwgb3RoZXIpIHtcbiAgaWYgKCFfLmlzVW5kZWZpbmVkKHRhcmdldC5iYXJ5Y2VudGVyKSkge1xuICAgIHRhcmdldC5iYXJ5Y2VudGVyID0gKHRhcmdldC5iYXJ5Y2VudGVyICogdGFyZ2V0LndlaWdodCArXG4gICAgICAgICAgICAgICAgICAgICAgICAgb3RoZXIuYmFyeWNlbnRlciAqIG90aGVyLndlaWdodCkgL1xuICAgICAgICAgICAgICAgICAgICAgICAgKHRhcmdldC53ZWlnaHQgKyBvdGhlci53ZWlnaHQpO1xuICAgIHRhcmdldC53ZWlnaHQgKz0gb3RoZXIud2VpZ2h0O1xuICB9IGVsc2Uge1xuICAgIHRhcmdldC5iYXJ5Y2VudGVyID0gb3RoZXIuYmFyeWNlbnRlcjtcbiAgICB0YXJnZXQud2VpZ2h0ID0gb3RoZXIud2VpZ2h0O1xuICB9XG59XG4iLCJ2YXIgXyA9IHJlcXVpcmUoXCIuLi9sb2Rhc2hcIik7XG52YXIgdXRpbCA9IHJlcXVpcmUoXCIuLi91dGlsXCIpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHNvcnQ7XG5cbmZ1bmN0aW9uIHNvcnQoZW50cmllcywgYmlhc1JpZ2h0KSB7XG4gIHZhciBwYXJ0cyA9IHV0aWwucGFydGl0aW9uKGVudHJpZXMsIGZ1bmN0aW9uKGVudHJ5KSB7XG4gICAgcmV0dXJuIF8uaGFzKGVudHJ5LCBcImJhcnljZW50ZXJcIik7XG4gIH0pO1xuICB2YXIgc29ydGFibGUgPSBwYXJ0cy5saHMsXG4gICAgdW5zb3J0YWJsZSA9IF8uc29ydEJ5KHBhcnRzLnJocywgZnVuY3Rpb24oZW50cnkpIHsgcmV0dXJuIC1lbnRyeS5pOyB9KSxcbiAgICB2cyA9IFtdLFxuICAgIHN1bSA9IDAsXG4gICAgd2VpZ2h0ID0gMCxcbiAgICB2c0luZGV4ID0gMDtcblxuICBzb3J0YWJsZS5zb3J0KGNvbXBhcmVXaXRoQmlhcyghIWJpYXNSaWdodCkpO1xuXG4gIHZzSW5kZXggPSBjb25zdW1lVW5zb3J0YWJsZSh2cywgdW5zb3J0YWJsZSwgdnNJbmRleCk7XG5cbiAgXy5mb3JFYWNoKHNvcnRhYmxlLCBmdW5jdGlvbiAoZW50cnkpIHtcbiAgICB2c0luZGV4ICs9IGVudHJ5LnZzLmxlbmd0aDtcbiAgICB2cy5wdXNoKGVudHJ5LnZzKTtcbiAgICBzdW0gKz0gZW50cnkuYmFyeWNlbnRlciAqIGVudHJ5LndlaWdodDtcbiAgICB3ZWlnaHQgKz0gZW50cnkud2VpZ2h0O1xuICAgIHZzSW5kZXggPSBjb25zdW1lVW5zb3J0YWJsZSh2cywgdW5zb3J0YWJsZSwgdnNJbmRleCk7XG4gIH0pO1xuXG4gIHZhciByZXN1bHQgPSB7IHZzOiBfLmZsYXR0ZW4odnMsIHRydWUpIH07XG4gIGlmICh3ZWlnaHQpIHtcbiAgICByZXN1bHQuYmFyeWNlbnRlciA9IHN1bSAvIHdlaWdodDtcbiAgICByZXN1bHQud2VpZ2h0ID0gd2VpZ2h0O1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIGNvbnN1bWVVbnNvcnRhYmxlKHZzLCB1bnNvcnRhYmxlLCBpbmRleCkge1xuICB2YXIgbGFzdDtcbiAgd2hpbGUgKHVuc29ydGFibGUubGVuZ3RoICYmIChsYXN0ID0gXy5sYXN0KHVuc29ydGFibGUpKS5pIDw9IGluZGV4KSB7XG4gICAgdW5zb3J0YWJsZS5wb3AoKTtcbiAgICB2cy5wdXNoKGxhc3QudnMpO1xuICAgIGluZGV4Kys7XG4gIH1cbiAgcmV0dXJuIGluZGV4O1xufVxuXG5mdW5jdGlvbiBjb21wYXJlV2l0aEJpYXMoYmlhcykge1xuICByZXR1cm4gZnVuY3Rpb24oZW50cnlWLCBlbnRyeVcpIHtcbiAgICBpZiAoZW50cnlWLmJhcnljZW50ZXIgPCBlbnRyeVcuYmFyeWNlbnRlcikge1xuICAgICAgcmV0dXJuIC0xO1xuICAgIH0gZWxzZSBpZiAoZW50cnlWLmJhcnljZW50ZXIgPiBlbnRyeVcuYmFyeWNlbnRlcikge1xuICAgICAgcmV0dXJuIDE7XG4gICAgfVxuXG4gICAgcmV0dXJuICFiaWFzID8gZW50cnlWLmkgLSBlbnRyeVcuaSA6IGVudHJ5Vy5pIC0gZW50cnlWLmk7XG4gIH07XG59XG4iLCJ2YXIgXyA9IHJlcXVpcmUoXCIuL2xvZGFzaFwiKTtcblxubW9kdWxlLmV4cG9ydHMgPSBwYXJlbnREdW1teUNoYWlucztcblxuZnVuY3Rpb24gcGFyZW50RHVtbXlDaGFpbnMoZykge1xuICB2YXIgcG9zdG9yZGVyTnVtcyA9IHBvc3RvcmRlcihnKTtcblxuICBfLmZvckVhY2goZy5ncmFwaCgpLmR1bW15Q2hhaW5zLCBmdW5jdGlvbih2KSB7XG4gICAgdmFyIG5vZGUgPSBnLm5vZGUodik7XG4gICAgdmFyIGVkZ2VPYmogPSBub2RlLmVkZ2VPYmo7XG4gICAgdmFyIHBhdGhEYXRhID0gZmluZFBhdGgoZywgcG9zdG9yZGVyTnVtcywgZWRnZU9iai52LCBlZGdlT2JqLncpO1xuICAgIHZhciBwYXRoID0gcGF0aERhdGEucGF0aDtcbiAgICB2YXIgbGNhID0gcGF0aERhdGEubGNhO1xuICAgIHZhciBwYXRoSWR4ID0gMDtcbiAgICB2YXIgcGF0aFYgPSBwYXRoW3BhdGhJZHhdO1xuICAgIHZhciBhc2NlbmRpbmcgPSB0cnVlO1xuXG4gICAgd2hpbGUgKHYgIT09IGVkZ2VPYmoudykge1xuICAgICAgbm9kZSA9IGcubm9kZSh2KTtcblxuICAgICAgaWYgKGFzY2VuZGluZykge1xuICAgICAgICB3aGlsZSAoKHBhdGhWID0gcGF0aFtwYXRoSWR4XSkgIT09IGxjYSAmJlxuICAgICAgICAgICAgICAgZy5ub2RlKHBhdGhWKS5tYXhSYW5rIDwgbm9kZS5yYW5rKSB7XG4gICAgICAgICAgcGF0aElkeCsrO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHBhdGhWID09PSBsY2EpIHtcbiAgICAgICAgICBhc2NlbmRpbmcgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoIWFzY2VuZGluZykge1xuICAgICAgICB3aGlsZSAocGF0aElkeCA8IHBhdGgubGVuZ3RoIC0gMSAmJlxuICAgICAgICAgICAgICAgZy5ub2RlKHBhdGhWID0gcGF0aFtwYXRoSWR4ICsgMV0pLm1pblJhbmsgPD0gbm9kZS5yYW5rKSB7XG4gICAgICAgICAgcGF0aElkeCsrO1xuICAgICAgICB9XG4gICAgICAgIHBhdGhWID0gcGF0aFtwYXRoSWR4XTtcbiAgICAgIH1cblxuICAgICAgZy5zZXRQYXJlbnQodiwgcGF0aFYpO1xuICAgICAgdiA9IGcuc3VjY2Vzc29ycyh2KVswXTtcbiAgICB9XG4gIH0pO1xufVxuXG4vLyBGaW5kIGEgcGF0aCBmcm9tIHYgdG8gdyB0aHJvdWdoIHRoZSBsb3dlc3QgY29tbW9uIGFuY2VzdG9yIChMQ0EpLiBSZXR1cm4gdGhlXG4vLyBmdWxsIHBhdGggYW5kIHRoZSBMQ0EuXG5mdW5jdGlvbiBmaW5kUGF0aChnLCBwb3N0b3JkZXJOdW1zLCB2LCB3KSB7XG4gIHZhciB2UGF0aCA9IFtdO1xuICB2YXIgd1BhdGggPSBbXTtcbiAgdmFyIGxvdyA9IE1hdGgubWluKHBvc3RvcmRlck51bXNbdl0ubG93LCBwb3N0b3JkZXJOdW1zW3ddLmxvdyk7XG4gIHZhciBsaW0gPSBNYXRoLm1heChwb3N0b3JkZXJOdW1zW3ZdLmxpbSwgcG9zdG9yZGVyTnVtc1t3XS5saW0pO1xuICB2YXIgcGFyZW50O1xuICB2YXIgbGNhO1xuXG4gIC8vIFRyYXZlcnNlIHVwIGZyb20gdiB0byBmaW5kIHRoZSBMQ0FcbiAgcGFyZW50ID0gdjtcbiAgZG8ge1xuICAgIHBhcmVudCA9IGcucGFyZW50KHBhcmVudCk7XG4gICAgdlBhdGgucHVzaChwYXJlbnQpO1xuICB9IHdoaWxlIChwYXJlbnQgJiZcbiAgICAgICAgICAgKHBvc3RvcmRlck51bXNbcGFyZW50XS5sb3cgPiBsb3cgfHwgbGltID4gcG9zdG9yZGVyTnVtc1twYXJlbnRdLmxpbSkpO1xuICBsY2EgPSBwYXJlbnQ7XG5cbiAgLy8gVHJhdmVyc2UgZnJvbSB3IHRvIExDQVxuICBwYXJlbnQgPSB3O1xuICB3aGlsZSAoKHBhcmVudCA9IGcucGFyZW50KHBhcmVudCkpICE9PSBsY2EpIHtcbiAgICB3UGF0aC5wdXNoKHBhcmVudCk7XG4gIH1cblxuICByZXR1cm4geyBwYXRoOiB2UGF0aC5jb25jYXQod1BhdGgucmV2ZXJzZSgpKSwgbGNhOiBsY2EgfTtcbn1cblxuZnVuY3Rpb24gcG9zdG9yZGVyKGcpIHtcbiAgdmFyIHJlc3VsdCA9IHt9O1xuICB2YXIgbGltID0gMDtcblxuICBmdW5jdGlvbiBkZnModikge1xuICAgIHZhciBsb3cgPSBsaW07XG4gICAgXy5mb3JFYWNoKGcuY2hpbGRyZW4odiksIGRmcyk7XG4gICAgcmVzdWx0W3ZdID0geyBsb3c6IGxvdywgbGltOiBsaW0rKyB9O1xuICB9XG4gIF8uZm9yRWFjaChnLmNoaWxkcmVuKCksIGRmcyk7XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cbiIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgXyA9IHJlcXVpcmUoXCIuLi9sb2Rhc2hcIik7XG52YXIgR3JhcGggPSByZXF1aXJlKFwiLi4vZ3JhcGhsaWJcIikuR3JhcGg7XG52YXIgdXRpbCA9IHJlcXVpcmUoXCIuLi91dGlsXCIpO1xuXG4vKlxuICogVGhpcyBtb2R1bGUgcHJvdmlkZXMgY29vcmRpbmF0ZSBhc3NpZ25tZW50IGJhc2VkIG9uIEJyYW5kZXMgYW5kIEvDtnBmLCBcIkZhc3RcbiAqIGFuZCBTaW1wbGUgSG9yaXpvbnRhbCBDb29yZGluYXRlIEFzc2lnbm1lbnQuXCJcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgcG9zaXRpb25YOiBwb3NpdGlvblgsXG4gIGZpbmRUeXBlMUNvbmZsaWN0czogZmluZFR5cGUxQ29uZmxpY3RzLFxuICBmaW5kVHlwZTJDb25mbGljdHM6IGZpbmRUeXBlMkNvbmZsaWN0cyxcbiAgYWRkQ29uZmxpY3Q6IGFkZENvbmZsaWN0LFxuICBoYXNDb25mbGljdDogaGFzQ29uZmxpY3QsXG4gIHZlcnRpY2FsQWxpZ25tZW50OiB2ZXJ0aWNhbEFsaWdubWVudCxcbiAgaG9yaXpvbnRhbENvbXBhY3Rpb246IGhvcml6b250YWxDb21wYWN0aW9uLFxuICBhbGlnbkNvb3JkaW5hdGVzOiBhbGlnbkNvb3JkaW5hdGVzLFxuICBmaW5kU21hbGxlc3RXaWR0aEFsaWdubWVudDogZmluZFNtYWxsZXN0V2lkdGhBbGlnbm1lbnQsXG4gIGJhbGFuY2U6IGJhbGFuY2Vcbn07XG5cbi8qXG4gKiBNYXJrcyBhbGwgZWRnZXMgaW4gdGhlIGdyYXBoIHdpdGggYSB0eXBlLTEgY29uZmxpY3Qgd2l0aCB0aGUgXCJ0eXBlMUNvbmZsaWN0XCJcbiAqIHByb3BlcnR5LiBBIHR5cGUtMSBjb25mbGljdCBpcyBvbmUgd2hlcmUgYSBub24taW5uZXIgc2VnbWVudCBjcm9zc2VzIGFuXG4gKiBpbm5lciBzZWdtZW50LiBBbiBpbm5lciBzZWdtZW50IGlzIGFuIGVkZ2Ugd2l0aCBib3RoIGluY2lkZW50IG5vZGVzIG1hcmtlZFxuICogd2l0aCB0aGUgXCJkdW1teVwiIHByb3BlcnR5LlxuICpcbiAqIFRoaXMgYWxnb3JpdGhtIHNjYW5zIGxheWVyIGJ5IGxheWVyLCBzdGFydGluZyB3aXRoIHRoZSBzZWNvbmQsIGZvciB0eXBlLTFcbiAqIGNvbmZsaWN0cyBiZXR3ZWVuIHRoZSBjdXJyZW50IGxheWVyIGFuZCB0aGUgcHJldmlvdXMgbGF5ZXIuIEZvciBlYWNoIGxheWVyXG4gKiBpdCBzY2FucyB0aGUgbm9kZXMgZnJvbSBsZWZ0IHRvIHJpZ2h0IHVudGlsIGl0IHJlYWNoZXMgb25lIHRoYXQgaXMgaW5jaWRlbnRcbiAqIG9uIGFuIGlubmVyIHNlZ21lbnQuIEl0IHRoZW4gc2NhbnMgcHJlZGVjZXNzb3JzIHRvIGRldGVybWluZSBpZiB0aGV5IGhhdmVcbiAqIGVkZ2VzIHRoYXQgY3Jvc3MgdGhhdCBpbm5lciBzZWdtZW50LiBBdCB0aGUgZW5kIGEgZmluYWwgc2NhbiBpcyBkb25lIGZvciBhbGxcbiAqIG5vZGVzIG9uIHRoZSBjdXJyZW50IHJhbmsgdG8gc2VlIGlmIHRoZXkgY3Jvc3MgdGhlIGxhc3QgdmlzaXRlZCBpbm5lclxuICogc2VnbWVudC5cbiAqXG4gKiBUaGlzIGFsZ29yaXRobSAoc2FmZWx5KSBhc3N1bWVzIHRoYXQgYSBkdW1teSBub2RlIHdpbGwgb25seSBiZSBpbmNpZGVudCBvbiBhXG4gKiBzaW5nbGUgbm9kZSBpbiB0aGUgbGF5ZXJzIGJlaW5nIHNjYW5uZWQuXG4gKi9cbmZ1bmN0aW9uIGZpbmRUeXBlMUNvbmZsaWN0cyhnLCBsYXllcmluZykge1xuICB2YXIgY29uZmxpY3RzID0ge307XG5cbiAgZnVuY3Rpb24gdmlzaXRMYXllcihwcmV2TGF5ZXIsIGxheWVyKSB7XG4gICAgdmFyXG4gICAgICAvLyBsYXN0IHZpc2l0ZWQgbm9kZSBpbiB0aGUgcHJldmlvdXMgbGF5ZXIgdGhhdCBpcyBpbmNpZGVudCBvbiBhbiBpbm5lclxuICAgICAgLy8gc2VnbWVudC5cbiAgICAgIGswID0gMCxcbiAgICAgIC8vIFRyYWNrcyB0aGUgbGFzdCBub2RlIGluIHRoaXMgbGF5ZXIgc2Nhbm5lZCBmb3IgY3Jvc3NpbmdzIHdpdGggYSB0eXBlLTFcbiAgICAgIC8vIHNlZ21lbnQuXG4gICAgICBzY2FuUG9zID0gMCxcbiAgICAgIHByZXZMYXllckxlbmd0aCA9IHByZXZMYXllci5sZW5ndGgsXG4gICAgICBsYXN0Tm9kZSA9IF8ubGFzdChsYXllcik7XG5cbiAgICBfLmZvckVhY2gobGF5ZXIsIGZ1bmN0aW9uKHYsIGkpIHtcbiAgICAgIHZhciB3ID0gZmluZE90aGVySW5uZXJTZWdtZW50Tm9kZShnLCB2KSxcbiAgICAgICAgazEgPSB3ID8gZy5ub2RlKHcpLm9yZGVyIDogcHJldkxheWVyTGVuZ3RoO1xuXG4gICAgICBpZiAodyB8fCB2ID09PSBsYXN0Tm9kZSkge1xuICAgICAgICBfLmZvckVhY2gobGF5ZXIuc2xpY2Uoc2NhblBvcywgaSArMSksIGZ1bmN0aW9uKHNjYW5Ob2RlKSB7XG4gICAgICAgICAgXy5mb3JFYWNoKGcucHJlZGVjZXNzb3JzKHNjYW5Ob2RlKSwgZnVuY3Rpb24odSkge1xuICAgICAgICAgICAgdmFyIHVMYWJlbCA9IGcubm9kZSh1KSxcbiAgICAgICAgICAgICAgdVBvcyA9IHVMYWJlbC5vcmRlcjtcbiAgICAgICAgICAgIGlmICgodVBvcyA8IGswIHx8IGsxIDwgdVBvcykgJiZcbiAgICAgICAgICAgICAgICAhKHVMYWJlbC5kdW1teSAmJiBnLm5vZGUoc2Nhbk5vZGUpLmR1bW15KSkge1xuICAgICAgICAgICAgICBhZGRDb25mbGljdChjb25mbGljdHMsIHUsIHNjYW5Ob2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHNjYW5Qb3MgPSBpICsgMTtcbiAgICAgICAgazAgPSBrMTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiBsYXllcjtcbiAgfVxuXG4gIF8ucmVkdWNlKGxheWVyaW5nLCB2aXNpdExheWVyKTtcbiAgcmV0dXJuIGNvbmZsaWN0cztcbn1cblxuZnVuY3Rpb24gZmluZFR5cGUyQ29uZmxpY3RzKGcsIGxheWVyaW5nKSB7XG4gIHZhciBjb25mbGljdHMgPSB7fTtcblxuICBmdW5jdGlvbiBzY2FuKHNvdXRoLCBzb3V0aFBvcywgc291dGhFbmQsIHByZXZOb3J0aEJvcmRlciwgbmV4dE5vcnRoQm9yZGVyKSB7XG4gICAgdmFyIHY7XG4gICAgXy5mb3JFYWNoKF8ucmFuZ2Uoc291dGhQb3MsIHNvdXRoRW5kKSwgZnVuY3Rpb24oaSkge1xuICAgICAgdiA9IHNvdXRoW2ldO1xuICAgICAgaWYgKGcubm9kZSh2KS5kdW1teSkge1xuICAgICAgICBfLmZvckVhY2goZy5wcmVkZWNlc3NvcnModiksIGZ1bmN0aW9uKHUpIHtcbiAgICAgICAgICB2YXIgdU5vZGUgPSBnLm5vZGUodSk7XG4gICAgICAgICAgaWYgKHVOb2RlLmR1bW15ICYmXG4gICAgICAgICAgICAgICh1Tm9kZS5vcmRlciA8IHByZXZOb3J0aEJvcmRlciB8fCB1Tm9kZS5vcmRlciA+IG5leHROb3J0aEJvcmRlcikpIHtcbiAgICAgICAgICAgIGFkZENvbmZsaWN0KGNvbmZsaWN0cywgdSwgdik7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG5cbiAgZnVuY3Rpb24gdmlzaXRMYXllcihub3J0aCwgc291dGgpIHtcbiAgICB2YXIgcHJldk5vcnRoUG9zID0gLTEsXG4gICAgICBuZXh0Tm9ydGhQb3MsXG4gICAgICBzb3V0aFBvcyA9IDA7XG5cbiAgICBfLmZvckVhY2goc291dGgsIGZ1bmN0aW9uKHYsIHNvdXRoTG9va2FoZWFkKSB7XG4gICAgICBpZiAoZy5ub2RlKHYpLmR1bW15ID09PSBcImJvcmRlclwiKSB7XG4gICAgICAgIHZhciBwcmVkZWNlc3NvcnMgPSBnLnByZWRlY2Vzc29ycyh2KTtcbiAgICAgICAgaWYgKHByZWRlY2Vzc29ycy5sZW5ndGgpIHtcbiAgICAgICAgICBuZXh0Tm9ydGhQb3MgPSBnLm5vZGUocHJlZGVjZXNzb3JzWzBdKS5vcmRlcjtcbiAgICAgICAgICBzY2FuKHNvdXRoLCBzb3V0aFBvcywgc291dGhMb29rYWhlYWQsIHByZXZOb3J0aFBvcywgbmV4dE5vcnRoUG9zKTtcbiAgICAgICAgICBzb3V0aFBvcyA9IHNvdXRoTG9va2FoZWFkO1xuICAgICAgICAgIHByZXZOb3J0aFBvcyA9IG5leHROb3J0aFBvcztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgc2Nhbihzb3V0aCwgc291dGhQb3MsIHNvdXRoLmxlbmd0aCwgbmV4dE5vcnRoUG9zLCBub3J0aC5sZW5ndGgpO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHNvdXRoO1xuICB9XG5cbiAgXy5yZWR1Y2UobGF5ZXJpbmcsIHZpc2l0TGF5ZXIpO1xuICByZXR1cm4gY29uZmxpY3RzO1xufVxuXG5mdW5jdGlvbiBmaW5kT3RoZXJJbm5lclNlZ21lbnROb2RlKGcsIHYpIHtcbiAgaWYgKGcubm9kZSh2KS5kdW1teSkge1xuICAgIHJldHVybiBfLmZpbmQoZy5wcmVkZWNlc3NvcnModiksIGZ1bmN0aW9uKHUpIHtcbiAgICAgIHJldHVybiBnLm5vZGUodSkuZHVtbXk7XG4gICAgfSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gYWRkQ29uZmxpY3QoY29uZmxpY3RzLCB2LCB3KSB7XG4gIGlmICh2ID4gdykge1xuICAgIHZhciB0bXAgPSB2O1xuICAgIHYgPSB3O1xuICAgIHcgPSB0bXA7XG4gIH1cblxuICB2YXIgY29uZmxpY3RzViA9IGNvbmZsaWN0c1t2XTtcbiAgaWYgKCFjb25mbGljdHNWKSB7XG4gICAgY29uZmxpY3RzW3ZdID0gY29uZmxpY3RzViA9IHt9O1xuICB9XG4gIGNvbmZsaWN0c1Zbd10gPSB0cnVlO1xufVxuXG5mdW5jdGlvbiBoYXNDb25mbGljdChjb25mbGljdHMsIHYsIHcpIHtcbiAgaWYgKHYgPiB3KSB7XG4gICAgdmFyIHRtcCA9IHY7XG4gICAgdiA9IHc7XG4gICAgdyA9IHRtcDtcbiAgfVxuICByZXR1cm4gXy5oYXMoY29uZmxpY3RzW3ZdLCB3KTtcbn1cblxuLypcbiAqIFRyeSB0byBhbGlnbiBub2RlcyBpbnRvIHZlcnRpY2FsIFwiYmxvY2tzXCIgd2hlcmUgcG9zc2libGUuIFRoaXMgYWxnb3JpdGhtXG4gKiBhdHRlbXB0cyB0byBhbGlnbiBhIG5vZGUgd2l0aCBvbmUgb2YgaXRzIG1lZGlhbiBuZWlnaGJvcnMuIElmIHRoZSBlZGdlXG4gKiBjb25uZWN0aW5nIGEgbmVpZ2hib3IgaXMgYSB0eXBlLTEgY29uZmxpY3QgdGhlbiB3ZSBpZ25vcmUgdGhhdCBwb3NzaWJpbGl0eS5cbiAqIElmIGEgcHJldmlvdXMgbm9kZSBoYXMgYWxyZWFkeSBmb3JtZWQgYSBibG9jayB3aXRoIGEgbm9kZSBhZnRlciB0aGUgbm9kZVxuICogd2UncmUgdHJ5aW5nIHRvIGZvcm0gYSBibG9jayB3aXRoLCB3ZSBhbHNvIGlnbm9yZSB0aGF0IHBvc3NpYmlsaXR5IC0gb3VyXG4gKiBibG9ja3Mgd291bGQgYmUgc3BsaXQgaW4gdGhhdCBzY2VuYXJpby5cbiAqL1xuZnVuY3Rpb24gdmVydGljYWxBbGlnbm1lbnQoZywgbGF5ZXJpbmcsIGNvbmZsaWN0cywgbmVpZ2hib3JGbikge1xuICB2YXIgcm9vdCA9IHt9LFxuICAgIGFsaWduID0ge30sXG4gICAgcG9zID0ge307XG5cbiAgLy8gV2UgY2FjaGUgdGhlIHBvc2l0aW9uIGhlcmUgYmFzZWQgb24gdGhlIGxheWVyaW5nIGJlY2F1c2UgdGhlIGdyYXBoIGFuZFxuICAvLyBsYXllcmluZyBtYXkgYmUgb3V0IG9mIHN5bmMuIFRoZSBsYXllcmluZyBtYXRyaXggaXMgbWFuaXB1bGF0ZWQgdG9cbiAgLy8gZ2VuZXJhdGUgZGlmZmVyZW50IGV4dHJlbWUgYWxpZ25tZW50cy5cbiAgXy5mb3JFYWNoKGxheWVyaW5nLCBmdW5jdGlvbihsYXllcikge1xuICAgIF8uZm9yRWFjaChsYXllciwgZnVuY3Rpb24odiwgb3JkZXIpIHtcbiAgICAgIHJvb3Rbdl0gPSB2O1xuICAgICAgYWxpZ25bdl0gPSB2O1xuICAgICAgcG9zW3ZdID0gb3JkZXI7XG4gICAgfSk7XG4gIH0pO1xuXG4gIF8uZm9yRWFjaChsYXllcmluZywgZnVuY3Rpb24obGF5ZXIpIHtcbiAgICB2YXIgcHJldklkeCA9IC0xO1xuICAgIF8uZm9yRWFjaChsYXllciwgZnVuY3Rpb24odikge1xuICAgICAgdmFyIHdzID0gbmVpZ2hib3JGbih2KTtcbiAgICAgIGlmICh3cy5sZW5ndGgpIHtcbiAgICAgICAgd3MgPSBfLnNvcnRCeSh3cywgZnVuY3Rpb24odykgeyByZXR1cm4gcG9zW3ddOyB9KTtcbiAgICAgICAgdmFyIG1wID0gKHdzLmxlbmd0aCAtIDEpIC8gMjtcbiAgICAgICAgZm9yICh2YXIgaSA9IE1hdGguZmxvb3IobXApLCBpbCA9IE1hdGguY2VpbChtcCk7IGkgPD0gaWw7ICsraSkge1xuICAgICAgICAgIHZhciB3ID0gd3NbaV07XG4gICAgICAgICAgaWYgKGFsaWduW3ZdID09PSB2ICYmXG4gICAgICAgICAgICAgIHByZXZJZHggPCBwb3Nbd10gJiZcbiAgICAgICAgICAgICAgIWhhc0NvbmZsaWN0KGNvbmZsaWN0cywgdiwgdykpIHtcbiAgICAgICAgICAgIGFsaWduW3ddID0gdjtcbiAgICAgICAgICAgIGFsaWduW3ZdID0gcm9vdFt2XSA9IHJvb3Rbd107XG4gICAgICAgICAgICBwcmV2SWR4ID0gcG9zW3ddO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9KTtcblxuICByZXR1cm4geyByb290OiByb290LCBhbGlnbjogYWxpZ24gfTtcbn1cblxuZnVuY3Rpb24gaG9yaXpvbnRhbENvbXBhY3Rpb24oZywgbGF5ZXJpbmcsIHJvb3QsIGFsaWduLCByZXZlcnNlU2VwKSB7XG4gIC8vIFRoaXMgcG9ydGlvbiBvZiB0aGUgYWxnb3JpdGhtIGRpZmZlcnMgZnJvbSBCSyBkdWUgdG8gYSBudW1iZXIgb2YgcHJvYmxlbXMuXG4gIC8vIEluc3RlYWQgb2YgdGhlaXIgYWxnb3JpdGhtIHdlIGNvbnN0cnVjdCBhIG5ldyBibG9jayBncmFwaCBhbmQgZG8gdHdvXG4gIC8vIHN3ZWVwcy4gVGhlIGZpcnN0IHN3ZWVwIHBsYWNlcyBibG9ja3Mgd2l0aCB0aGUgc21hbGxlc3QgcG9zc2libGVcbiAgLy8gY29vcmRpbmF0ZXMuIFRoZSBzZWNvbmQgc3dlZXAgcmVtb3ZlcyB1bnVzZWQgc3BhY2UgYnkgbW92aW5nIGJsb2NrcyB0byB0aGVcbiAgLy8gZ3JlYXRlc3QgY29vcmRpbmF0ZXMgd2l0aG91dCB2aW9sYXRpbmcgc2VwYXJhdGlvbi5cbiAgdmFyIHhzID0ge30sXG4gICAgYmxvY2tHID0gYnVpbGRCbG9ja0dyYXBoKGcsIGxheWVyaW5nLCByb290LCByZXZlcnNlU2VwKSxcbiAgICBib3JkZXJUeXBlID0gcmV2ZXJzZVNlcCA/IFwiYm9yZGVyTGVmdFwiIDogXCJib3JkZXJSaWdodFwiO1xuXG4gIGZ1bmN0aW9uIGl0ZXJhdGUoc2V0WHNGdW5jLCBuZXh0Tm9kZXNGdW5jKSB7XG4gICAgdmFyIHN0YWNrID0gYmxvY2tHLm5vZGVzKCk7XG4gICAgdmFyIGVsZW0gPSBzdGFjay5wb3AoKTtcbiAgICB2YXIgdmlzaXRlZCA9IHt9O1xuICAgIHdoaWxlIChlbGVtKSB7XG4gICAgICBpZiAodmlzaXRlZFtlbGVtXSkge1xuICAgICAgICBzZXRYc0Z1bmMoZWxlbSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2aXNpdGVkW2VsZW1dID0gdHJ1ZTtcbiAgICAgICAgc3RhY2sucHVzaChlbGVtKTtcbiAgICAgICAgc3RhY2sgPSBzdGFjay5jb25jYXQobmV4dE5vZGVzRnVuYyhlbGVtKSk7XG4gICAgICB9XG5cbiAgICAgIGVsZW0gPSBzdGFjay5wb3AoKTtcbiAgICB9XG4gIH1cblxuICAvLyBGaXJzdCBwYXNzLCBhc3NpZ24gc21hbGxlc3QgY29vcmRpbmF0ZXNcbiAgZnVuY3Rpb24gcGFzczEoZWxlbSkge1xuICAgIHhzW2VsZW1dID0gYmxvY2tHLmluRWRnZXMoZWxlbSkucmVkdWNlKGZ1bmN0aW9uKGFjYywgZSkge1xuICAgICAgcmV0dXJuIE1hdGgubWF4KGFjYywgeHNbZS52XSArIGJsb2NrRy5lZGdlKGUpKTtcbiAgICB9LCAwKTtcbiAgfVxuXG4gIC8vIFNlY29uZCBwYXNzLCBhc3NpZ24gZ3JlYXRlc3QgY29vcmRpbmF0ZXNcbiAgZnVuY3Rpb24gcGFzczIoZWxlbSkge1xuICAgIHZhciBtaW4gPSBibG9ja0cub3V0RWRnZXMoZWxlbSkucmVkdWNlKGZ1bmN0aW9uKGFjYywgZSkge1xuICAgICAgcmV0dXJuIE1hdGgubWluKGFjYywgeHNbZS53XSAtIGJsb2NrRy5lZGdlKGUpKTtcbiAgICB9LCBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFkpO1xuXG4gICAgdmFyIG5vZGUgPSBnLm5vZGUoZWxlbSk7XG4gICAgaWYgKG1pbiAhPT0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZICYmIG5vZGUuYm9yZGVyVHlwZSAhPT0gYm9yZGVyVHlwZSkge1xuICAgICAgeHNbZWxlbV0gPSBNYXRoLm1heCh4c1tlbGVtXSwgbWluKTtcbiAgICB9XG4gIH1cblxuICBpdGVyYXRlKHBhc3MxLCBibG9ja0cucHJlZGVjZXNzb3JzLmJpbmQoYmxvY2tHKSk7XG4gIGl0ZXJhdGUocGFzczIsIGJsb2NrRy5zdWNjZXNzb3JzLmJpbmQoYmxvY2tHKSk7XG5cbiAgLy8gQXNzaWduIHggY29vcmRpbmF0ZXMgdG8gYWxsIG5vZGVzXG4gIF8uZm9yRWFjaChhbGlnbiwgZnVuY3Rpb24odikge1xuICAgIHhzW3ZdID0geHNbcm9vdFt2XV07XG4gIH0pO1xuXG4gIHJldHVybiB4cztcbn1cblxuXG5mdW5jdGlvbiBidWlsZEJsb2NrR3JhcGgoZywgbGF5ZXJpbmcsIHJvb3QsIHJldmVyc2VTZXApIHtcbiAgdmFyIGJsb2NrR3JhcGggPSBuZXcgR3JhcGgoKSxcbiAgICBncmFwaExhYmVsID0gZy5ncmFwaCgpLFxuICAgIHNlcEZuID0gc2VwKGdyYXBoTGFiZWwubm9kZXNlcCwgZ3JhcGhMYWJlbC5lZGdlc2VwLCByZXZlcnNlU2VwKTtcblxuICBfLmZvckVhY2gobGF5ZXJpbmcsIGZ1bmN0aW9uKGxheWVyKSB7XG4gICAgdmFyIHU7XG4gICAgXy5mb3JFYWNoKGxheWVyLCBmdW5jdGlvbih2KSB7XG4gICAgICB2YXIgdlJvb3QgPSByb290W3ZdO1xuICAgICAgYmxvY2tHcmFwaC5zZXROb2RlKHZSb290KTtcbiAgICAgIGlmICh1KSB7XG4gICAgICAgIHZhciB1Um9vdCA9IHJvb3RbdV0sXG4gICAgICAgICAgcHJldk1heCA9IGJsb2NrR3JhcGguZWRnZSh1Um9vdCwgdlJvb3QpO1xuICAgICAgICBibG9ja0dyYXBoLnNldEVkZ2UodVJvb3QsIHZSb290LCBNYXRoLm1heChzZXBGbihnLCB2LCB1KSwgcHJldk1heCB8fCAwKSk7XG4gICAgICB9XG4gICAgICB1ID0gdjtcbiAgICB9KTtcbiAgfSk7XG5cbiAgcmV0dXJuIGJsb2NrR3JhcGg7XG59XG5cbi8qXG4gKiBSZXR1cm5zIHRoZSBhbGlnbm1lbnQgdGhhdCBoYXMgdGhlIHNtYWxsZXN0IHdpZHRoIG9mIHRoZSBnaXZlbiBhbGlnbm1lbnRzLlxuICovXG5mdW5jdGlvbiBmaW5kU21hbGxlc3RXaWR0aEFsaWdubWVudChnLCB4c3MpIHtcbiAgcmV0dXJuIF8ubWluQnkoXy52YWx1ZXMoeHNzKSwgZnVuY3Rpb24gKHhzKSB7XG4gICAgdmFyIG1heCA9IE51bWJlci5ORUdBVElWRV9JTkZJTklUWTtcbiAgICB2YXIgbWluID0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZO1xuXG4gICAgXy5mb3JJbih4cywgZnVuY3Rpb24gKHgsIHYpIHtcbiAgICAgIHZhciBoYWxmV2lkdGggPSB3aWR0aChnLCB2KSAvIDI7XG5cbiAgICAgIG1heCA9IE1hdGgubWF4KHggKyBoYWxmV2lkdGgsIG1heCk7XG4gICAgICBtaW4gPSBNYXRoLm1pbih4IC0gaGFsZldpZHRoLCBtaW4pO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIG1heCAtIG1pbjtcbiAgfSk7XG59XG5cbi8qXG4gKiBBbGlnbiB0aGUgY29vcmRpbmF0ZXMgb2YgZWFjaCBvZiB0aGUgbGF5b3V0IGFsaWdubWVudHMgc3VjaCB0aGF0XG4gKiBsZWZ0LWJpYXNlZCBhbGlnbm1lbnRzIGhhdmUgdGhlaXIgbWluaW11bSBjb29yZGluYXRlIGF0IHRoZSBzYW1lIHBvaW50IGFzXG4gKiB0aGUgbWluaW11bSBjb29yZGluYXRlIG9mIHRoZSBzbWFsbGVzdCB3aWR0aCBhbGlnbm1lbnQgYW5kIHJpZ2h0LWJpYXNlZFxuICogYWxpZ25tZW50cyBoYXZlIHRoZWlyIG1heGltdW0gY29vcmRpbmF0ZSBhdCB0aGUgc2FtZSBwb2ludCBhcyB0aGUgbWF4aW11bVxuICogY29vcmRpbmF0ZSBvZiB0aGUgc21hbGxlc3Qgd2lkdGggYWxpZ25tZW50LlxuICovXG5mdW5jdGlvbiBhbGlnbkNvb3JkaW5hdGVzKHhzcywgYWxpZ25Ubykge1xuICB2YXIgYWxpZ25Ub1ZhbHMgPSBfLnZhbHVlcyhhbGlnblRvKSxcbiAgICBhbGlnblRvTWluID0gXy5taW4oYWxpZ25Ub1ZhbHMpLFxuICAgIGFsaWduVG9NYXggPSBfLm1heChhbGlnblRvVmFscyk7XG5cbiAgXy5mb3JFYWNoKFtcInVcIiwgXCJkXCJdLCBmdW5jdGlvbih2ZXJ0KSB7XG4gICAgXy5mb3JFYWNoKFtcImxcIiwgXCJyXCJdLCBmdW5jdGlvbihob3Jpeikge1xuICAgICAgdmFyIGFsaWdubWVudCA9IHZlcnQgKyBob3JpeixcbiAgICAgICAgeHMgPSB4c3NbYWxpZ25tZW50XSxcbiAgICAgICAgZGVsdGE7XG4gICAgICBpZiAoeHMgPT09IGFsaWduVG8pIHJldHVybjtcblxuICAgICAgdmFyIHhzVmFscyA9IF8udmFsdWVzKHhzKTtcbiAgICAgIGRlbHRhID0gaG9yaXogPT09IFwibFwiID8gYWxpZ25Ub01pbiAtIF8ubWluKHhzVmFscykgOiBhbGlnblRvTWF4IC0gXy5tYXgoeHNWYWxzKTtcblxuICAgICAgaWYgKGRlbHRhKSB7XG4gICAgICAgIHhzc1thbGlnbm1lbnRdID0gXy5tYXBWYWx1ZXMoeHMsIGZ1bmN0aW9uKHgpIHsgcmV0dXJuIHggKyBkZWx0YTsgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBiYWxhbmNlKHhzcywgYWxpZ24pIHtcbiAgcmV0dXJuIF8ubWFwVmFsdWVzKHhzcy51bCwgZnVuY3Rpb24oaWdub3JlLCB2KSB7XG4gICAgaWYgKGFsaWduKSB7XG4gICAgICByZXR1cm4geHNzW2FsaWduLnRvTG93ZXJDYXNlKCldW3ZdO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgeHMgPSBfLnNvcnRCeShfLm1hcCh4c3MsIHYpKTtcbiAgICAgIHJldHVybiAoeHNbMV0gKyB4c1syXSkgLyAyO1xuICAgIH1cbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHBvc2l0aW9uWChnKSB7XG4gIHZhciBsYXllcmluZyA9IHV0aWwuYnVpbGRMYXllck1hdHJpeChnKTtcbiAgdmFyIGNvbmZsaWN0cyA9IF8ubWVyZ2UoXG4gICAgZmluZFR5cGUxQ29uZmxpY3RzKGcsIGxheWVyaW5nKSxcbiAgICBmaW5kVHlwZTJDb25mbGljdHMoZywgbGF5ZXJpbmcpKTtcblxuICB2YXIgeHNzID0ge307XG4gIHZhciBhZGp1c3RlZExheWVyaW5nO1xuICBfLmZvckVhY2goW1widVwiLCBcImRcIl0sIGZ1bmN0aW9uKHZlcnQpIHtcbiAgICBhZGp1c3RlZExheWVyaW5nID0gdmVydCA9PT0gXCJ1XCIgPyBsYXllcmluZyA6IF8udmFsdWVzKGxheWVyaW5nKS5yZXZlcnNlKCk7XG4gICAgXy5mb3JFYWNoKFtcImxcIiwgXCJyXCJdLCBmdW5jdGlvbihob3Jpeikge1xuICAgICAgaWYgKGhvcml6ID09PSBcInJcIikge1xuICAgICAgICBhZGp1c3RlZExheWVyaW5nID0gXy5tYXAoYWRqdXN0ZWRMYXllcmluZywgZnVuY3Rpb24oaW5uZXIpIHtcbiAgICAgICAgICByZXR1cm4gXy52YWx1ZXMoaW5uZXIpLnJldmVyc2UoKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHZhciBuZWlnaGJvckZuID0gKHZlcnQgPT09IFwidVwiID8gZy5wcmVkZWNlc3NvcnMgOiBnLnN1Y2Nlc3NvcnMpLmJpbmQoZyk7XG4gICAgICB2YXIgYWxpZ24gPSB2ZXJ0aWNhbEFsaWdubWVudChnLCBhZGp1c3RlZExheWVyaW5nLCBjb25mbGljdHMsIG5laWdoYm9yRm4pO1xuICAgICAgdmFyIHhzID0gaG9yaXpvbnRhbENvbXBhY3Rpb24oZywgYWRqdXN0ZWRMYXllcmluZyxcbiAgICAgICAgYWxpZ24ucm9vdCwgYWxpZ24uYWxpZ24sIGhvcml6ID09PSBcInJcIik7XG4gICAgICBpZiAoaG9yaXogPT09IFwiclwiKSB7XG4gICAgICAgIHhzID0gXy5tYXBWYWx1ZXMoeHMsIGZ1bmN0aW9uKHgpIHsgcmV0dXJuIC14OyB9KTtcbiAgICAgIH1cbiAgICAgIHhzc1t2ZXJ0ICsgaG9yaXpdID0geHM7XG4gICAgfSk7XG4gIH0pO1xuXG4gIHZhciBzbWFsbGVzdFdpZHRoID0gZmluZFNtYWxsZXN0V2lkdGhBbGlnbm1lbnQoZywgeHNzKTtcbiAgYWxpZ25Db29yZGluYXRlcyh4c3MsIHNtYWxsZXN0V2lkdGgpO1xuICByZXR1cm4gYmFsYW5jZSh4c3MsIGcuZ3JhcGgoKS5hbGlnbik7XG59XG5cbmZ1bmN0aW9uIHNlcChub2RlU2VwLCBlZGdlU2VwLCByZXZlcnNlU2VwKSB7XG4gIHJldHVybiBmdW5jdGlvbihnLCB2LCB3KSB7XG4gICAgdmFyIHZMYWJlbCA9IGcubm9kZSh2KTtcbiAgICB2YXIgd0xhYmVsID0gZy5ub2RlKHcpO1xuICAgIHZhciBzdW0gPSAwO1xuICAgIHZhciBkZWx0YTtcblxuICAgIHN1bSArPSB2TGFiZWwud2lkdGggLyAyO1xuICAgIGlmIChfLmhhcyh2TGFiZWwsIFwibGFiZWxwb3NcIikpIHtcbiAgICAgIHN3aXRjaCAodkxhYmVsLmxhYmVscG9zLnRvTG93ZXJDYXNlKCkpIHtcbiAgICAgIGNhc2UgXCJsXCI6IGRlbHRhID0gLXZMYWJlbC53aWR0aCAvIDI7IGJyZWFrO1xuICAgICAgY2FzZSBcInJcIjogZGVsdGEgPSB2TGFiZWwud2lkdGggLyAyOyBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGRlbHRhKSB7XG4gICAgICBzdW0gKz0gcmV2ZXJzZVNlcCA/IGRlbHRhIDogLWRlbHRhO1xuICAgIH1cbiAgICBkZWx0YSA9IDA7XG5cbiAgICBzdW0gKz0gKHZMYWJlbC5kdW1teSA/IGVkZ2VTZXAgOiBub2RlU2VwKSAvIDI7XG4gICAgc3VtICs9ICh3TGFiZWwuZHVtbXkgPyBlZGdlU2VwIDogbm9kZVNlcCkgLyAyO1xuXG4gICAgc3VtICs9IHdMYWJlbC53aWR0aCAvIDI7XG4gICAgaWYgKF8uaGFzKHdMYWJlbCwgXCJsYWJlbHBvc1wiKSkge1xuICAgICAgc3dpdGNoICh3TGFiZWwubGFiZWxwb3MudG9Mb3dlckNhc2UoKSkge1xuICAgICAgY2FzZSBcImxcIjogZGVsdGEgPSB3TGFiZWwud2lkdGggLyAyOyBicmVhaztcbiAgICAgIGNhc2UgXCJyXCI6IGRlbHRhID0gLXdMYWJlbC53aWR0aCAvIDI7IGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoZGVsdGEpIHtcbiAgICAgIHN1bSArPSByZXZlcnNlU2VwID8gZGVsdGEgOiAtZGVsdGE7XG4gICAgfVxuICAgIGRlbHRhID0gMDtcblxuICAgIHJldHVybiBzdW07XG4gIH07XG59XG5cbmZ1bmN0aW9uIHdpZHRoKGcsIHYpIHtcbiAgcmV0dXJuIGcubm9kZSh2KS53aWR0aDtcbn1cbiIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgXyA9IHJlcXVpcmUoXCIuLi9sb2Rhc2hcIik7XG52YXIgdXRpbCA9IHJlcXVpcmUoXCIuLi91dGlsXCIpO1xudmFyIHBvc2l0aW9uWCA9IHJlcXVpcmUoXCIuL2JrXCIpLnBvc2l0aW9uWDtcblxubW9kdWxlLmV4cG9ydHMgPSBwb3NpdGlvbjtcblxuZnVuY3Rpb24gcG9zaXRpb24oZykge1xuICBnID0gdXRpbC5hc05vbkNvbXBvdW5kR3JhcGgoZyk7XG5cbiAgcG9zaXRpb25ZKGcpO1xuICBfLmZvckVhY2gocG9zaXRpb25YKGcpLCBmdW5jdGlvbih4LCB2KSB7XG4gICAgZy5ub2RlKHYpLnggPSB4O1xuICB9KTtcbn1cblxuZnVuY3Rpb24gcG9zaXRpb25ZKGcpIHtcbiAgdmFyIGxheWVyaW5nID0gdXRpbC5idWlsZExheWVyTWF0cml4KGcpO1xuICB2YXIgcmFua1NlcCA9IGcuZ3JhcGgoKS5yYW5rc2VwO1xuICB2YXIgcHJldlkgPSAwO1xuICBfLmZvckVhY2gobGF5ZXJpbmcsIGZ1bmN0aW9uKGxheWVyKSB7XG4gICAgdmFyIG1heEhlaWdodCA9IF8ubWF4KF8ubWFwKGxheWVyLCBmdW5jdGlvbih2KSB7IHJldHVybiBnLm5vZGUodikuaGVpZ2h0OyB9KSk7XG4gICAgXy5mb3JFYWNoKGxheWVyLCBmdW5jdGlvbih2KSB7XG4gICAgICBnLm5vZGUodikueSA9IHByZXZZICsgbWF4SGVpZ2h0IC8gMjtcbiAgICB9KTtcbiAgICBwcmV2WSArPSBtYXhIZWlnaHQgKyByYW5rU2VwO1xuICB9KTtcbn1cblxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfID0gcmVxdWlyZShcIi4uL2xvZGFzaFwiKTtcbnZhciBHcmFwaCA9IHJlcXVpcmUoXCIuLi9ncmFwaGxpYlwiKS5HcmFwaDtcbnZhciBzbGFjayA9IHJlcXVpcmUoXCIuL3V0aWxcIikuc2xhY2s7XG5cbm1vZHVsZS5leHBvcnRzID0gZmVhc2libGVUcmVlO1xuXG4vKlxuICogQ29uc3RydWN0cyBhIHNwYW5uaW5nIHRyZWUgd2l0aCB0aWdodCBlZGdlcyBhbmQgYWRqdXN0ZWQgdGhlIGlucHV0IG5vZGUnc1xuICogcmFua3MgdG8gYWNoaWV2ZSB0aGlzLiBBIHRpZ2h0IGVkZ2UgaXMgb25lIHRoYXQgaXMgaGFzIGEgbGVuZ3RoIHRoYXQgbWF0Y2hlc1xuICogaXRzIFwibWlubGVuXCIgYXR0cmlidXRlLlxuICpcbiAqIFRoZSBiYXNpYyBzdHJ1Y3R1cmUgZm9yIHRoaXMgZnVuY3Rpb24gaXMgZGVyaXZlZCBmcm9tIEdhbnNuZXIsIGV0IGFsLiwgXCJBXG4gKiBUZWNobmlxdWUgZm9yIERyYXdpbmcgRGlyZWN0ZWQgR3JhcGhzLlwiXG4gKlxuICogUHJlLWNvbmRpdGlvbnM6XG4gKlxuICogICAgMS4gR3JhcGggbXVzdCBiZSBhIERBRy5cbiAqICAgIDIuIEdyYXBoIG11c3QgYmUgY29ubmVjdGVkLlxuICogICAgMy4gR3JhcGggbXVzdCBoYXZlIGF0IGxlYXN0IG9uZSBub2RlLlxuICogICAgNS4gR3JhcGggbm9kZXMgbXVzdCBoYXZlIGJlZW4gcHJldmlvdXNseSBhc3NpZ25lZCBhIFwicmFua1wiIHByb3BlcnR5IHRoYXRcbiAqICAgICAgIHJlc3BlY3RzIHRoZSBcIm1pbmxlblwiIHByb3BlcnR5IG9mIGluY2lkZW50IGVkZ2VzLlxuICogICAgNi4gR3JhcGggZWRnZXMgbXVzdCBoYXZlIGEgXCJtaW5sZW5cIiBwcm9wZXJ0eS5cbiAqXG4gKiBQb3N0LWNvbmRpdGlvbnM6XG4gKlxuICogICAgLSBHcmFwaCBub2RlcyB3aWxsIGhhdmUgdGhlaXIgcmFuayBhZGp1c3RlZCB0byBlbnN1cmUgdGhhdCBhbGwgZWRnZXMgYXJlXG4gKiAgICAgIHRpZ2h0LlxuICpcbiAqIFJldHVybnMgYSB0cmVlICh1bmRpcmVjdGVkIGdyYXBoKSB0aGF0IGlzIGNvbnN0cnVjdGVkIHVzaW5nIG9ubHkgXCJ0aWdodFwiXG4gKiBlZGdlcy5cbiAqL1xuZnVuY3Rpb24gZmVhc2libGVUcmVlKGcpIHtcbiAgdmFyIHQgPSBuZXcgR3JhcGgoeyBkaXJlY3RlZDogZmFsc2UgfSk7XG5cbiAgLy8gQ2hvb3NlIGFyYml0cmFyeSBub2RlIGZyb20gd2hpY2ggdG8gc3RhcnQgb3VyIHRyZWVcbiAgdmFyIHN0YXJ0ID0gZy5ub2RlcygpWzBdO1xuICB2YXIgc2l6ZSA9IGcubm9kZUNvdW50KCk7XG4gIHQuc2V0Tm9kZShzdGFydCwge30pO1xuXG4gIHZhciBlZGdlLCBkZWx0YTtcbiAgd2hpbGUgKHRpZ2h0VHJlZSh0LCBnKSA8IHNpemUpIHtcbiAgICBlZGdlID0gZmluZE1pblNsYWNrRWRnZSh0LCBnKTtcbiAgICBkZWx0YSA9IHQuaGFzTm9kZShlZGdlLnYpID8gc2xhY2soZywgZWRnZSkgOiAtc2xhY2soZywgZWRnZSk7XG4gICAgc2hpZnRSYW5rcyh0LCBnLCBkZWx0YSk7XG4gIH1cblxuICByZXR1cm4gdDtcbn1cblxuLypcbiAqIEZpbmRzIGEgbWF4aW1hbCB0cmVlIG9mIHRpZ2h0IGVkZ2VzIGFuZCByZXR1cm5zIHRoZSBudW1iZXIgb2Ygbm9kZXMgaW4gdGhlXG4gKiB0cmVlLlxuICovXG5mdW5jdGlvbiB0aWdodFRyZWUodCwgZykge1xuICBmdW5jdGlvbiBkZnModikge1xuICAgIF8uZm9yRWFjaChnLm5vZGVFZGdlcyh2KSwgZnVuY3Rpb24oZSkge1xuICAgICAgdmFyIGVkZ2VWID0gZS52LFxuICAgICAgICB3ID0gKHYgPT09IGVkZ2VWKSA/IGUudyA6IGVkZ2VWO1xuICAgICAgaWYgKCF0Lmhhc05vZGUodykgJiYgIXNsYWNrKGcsIGUpKSB7XG4gICAgICAgIHQuc2V0Tm9kZSh3LCB7fSk7XG4gICAgICAgIHQuc2V0RWRnZSh2LCB3LCB7fSk7XG4gICAgICAgIGRmcyh3KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIF8uZm9yRWFjaCh0Lm5vZGVzKCksIGRmcyk7XG4gIHJldHVybiB0Lm5vZGVDb3VudCgpO1xufVxuXG4vKlxuICogRmluZHMgdGhlIGVkZ2Ugd2l0aCB0aGUgc21hbGxlc3Qgc2xhY2sgdGhhdCBpcyBpbmNpZGVudCBvbiB0cmVlIGFuZCByZXR1cm5zXG4gKiBpdC5cbiAqL1xuZnVuY3Rpb24gZmluZE1pblNsYWNrRWRnZSh0LCBnKSB7XG4gIHJldHVybiBfLm1pbkJ5KGcuZWRnZXMoKSwgZnVuY3Rpb24oZSkge1xuICAgIGlmICh0Lmhhc05vZGUoZS52KSAhPT0gdC5oYXNOb2RlKGUudykpIHtcbiAgICAgIHJldHVybiBzbGFjayhnLCBlKTtcbiAgICB9XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBzaGlmdFJhbmtzKHQsIGcsIGRlbHRhKSB7XG4gIF8uZm9yRWFjaCh0Lm5vZGVzKCksIGZ1bmN0aW9uKHYpIHtcbiAgICBnLm5vZGUodikucmFuayArPSBkZWx0YTtcbiAgfSk7XG59XG4iLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIHJhbmtVdGlsID0gcmVxdWlyZShcIi4vdXRpbFwiKTtcbnZhciBsb25nZXN0UGF0aCA9IHJhbmtVdGlsLmxvbmdlc3RQYXRoO1xudmFyIGZlYXNpYmxlVHJlZSA9IHJlcXVpcmUoXCIuL2ZlYXNpYmxlLXRyZWVcIik7XG52YXIgbmV0d29ya1NpbXBsZXggPSByZXF1aXJlKFwiLi9uZXR3b3JrLXNpbXBsZXhcIik7XG5cbm1vZHVsZS5leHBvcnRzID0gcmFuaztcblxuLypcbiAqIEFzc2lnbnMgYSByYW5rIHRvIGVhY2ggbm9kZSBpbiB0aGUgaW5wdXQgZ3JhcGggdGhhdCByZXNwZWN0cyB0aGUgXCJtaW5sZW5cIlxuICogY29uc3RyYWludCBzcGVjaWZpZWQgb24gZWRnZXMgYmV0d2VlbiBub2Rlcy5cbiAqXG4gKiBUaGlzIGJhc2ljIHN0cnVjdHVyZSBpcyBkZXJpdmVkIGZyb20gR2Fuc25lciwgZXQgYWwuLCBcIkEgVGVjaG5pcXVlIGZvclxuICogRHJhd2luZyBEaXJlY3RlZCBHcmFwaHMuXCJcbiAqXG4gKiBQcmUtY29uZGl0aW9uczpcbiAqXG4gKiAgICAxLiBHcmFwaCBtdXN0IGJlIGEgY29ubmVjdGVkIERBR1xuICogICAgMi4gR3JhcGggbm9kZXMgbXVzdCBiZSBvYmplY3RzXG4gKiAgICAzLiBHcmFwaCBlZGdlcyBtdXN0IGhhdmUgXCJ3ZWlnaHRcIiBhbmQgXCJtaW5sZW5cIiBhdHRyaWJ1dGVzXG4gKlxuICogUG9zdC1jb25kaXRpb25zOlxuICpcbiAqICAgIDEuIEdyYXBoIG5vZGVzIHdpbGwgaGF2ZSBhIFwicmFua1wiIGF0dHJpYnV0ZSBiYXNlZCBvbiB0aGUgcmVzdWx0cyBvZiB0aGVcbiAqICAgICAgIGFsZ29yaXRobS4gUmFua3MgY2FuIHN0YXJ0IGF0IGFueSBpbmRleCAoaW5jbHVkaW5nIG5lZ2F0aXZlKSwgd2UnbGxcbiAqICAgICAgIGZpeCB0aGVtIHVwIGxhdGVyLlxuICovXG5mdW5jdGlvbiByYW5rKGcpIHtcbiAgc3dpdGNoKGcuZ3JhcGgoKS5yYW5rZXIpIHtcbiAgY2FzZSBcIm5ldHdvcmstc2ltcGxleFwiOiBuZXR3b3JrU2ltcGxleFJhbmtlcihnKTsgYnJlYWs7XG4gIGNhc2UgXCJ0aWdodC10cmVlXCI6IHRpZ2h0VHJlZVJhbmtlcihnKTsgYnJlYWs7XG4gIGNhc2UgXCJsb25nZXN0LXBhdGhcIjogbG9uZ2VzdFBhdGhSYW5rZXIoZyk7IGJyZWFrO1xuICBkZWZhdWx0OiBuZXR3b3JrU2ltcGxleFJhbmtlcihnKTtcbiAgfVxufVxuXG4vLyBBIGZhc3QgYW5kIHNpbXBsZSByYW5rZXIsIGJ1dCByZXN1bHRzIGFyZSBmYXIgZnJvbSBvcHRpbWFsLlxudmFyIGxvbmdlc3RQYXRoUmFua2VyID0gbG9uZ2VzdFBhdGg7XG5cbmZ1bmN0aW9uIHRpZ2h0VHJlZVJhbmtlcihnKSB7XG4gIGxvbmdlc3RQYXRoKGcpO1xuICBmZWFzaWJsZVRyZWUoZyk7XG59XG5cbmZ1bmN0aW9uIG5ldHdvcmtTaW1wbGV4UmFua2VyKGcpIHtcbiAgbmV0d29ya1NpbXBsZXgoZyk7XG59XG4iLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIF8gPSByZXF1aXJlKFwiLi4vbG9kYXNoXCIpO1xudmFyIGZlYXNpYmxlVHJlZSA9IHJlcXVpcmUoXCIuL2ZlYXNpYmxlLXRyZWVcIik7XG52YXIgc2xhY2sgPSByZXF1aXJlKFwiLi91dGlsXCIpLnNsYWNrO1xudmFyIGluaXRSYW5rID0gcmVxdWlyZShcIi4vdXRpbFwiKS5sb25nZXN0UGF0aDtcbnZhciBwcmVvcmRlciA9IHJlcXVpcmUoXCIuLi9ncmFwaGxpYlwiKS5hbGcucHJlb3JkZXI7XG52YXIgcG9zdG9yZGVyID0gcmVxdWlyZShcIi4uL2dyYXBobGliXCIpLmFsZy5wb3N0b3JkZXI7XG52YXIgc2ltcGxpZnkgPSByZXF1aXJlKFwiLi4vdXRpbFwiKS5zaW1wbGlmeTtcblxubW9kdWxlLmV4cG9ydHMgPSBuZXR3b3JrU2ltcGxleDtcblxuLy8gRXhwb3NlIHNvbWUgaW50ZXJuYWxzIGZvciB0ZXN0aW5nIHB1cnBvc2VzXG5uZXR3b3JrU2ltcGxleC5pbml0TG93TGltVmFsdWVzID0gaW5pdExvd0xpbVZhbHVlcztcbm5ldHdvcmtTaW1wbGV4LmluaXRDdXRWYWx1ZXMgPSBpbml0Q3V0VmFsdWVzO1xubmV0d29ya1NpbXBsZXguY2FsY0N1dFZhbHVlID0gY2FsY0N1dFZhbHVlO1xubmV0d29ya1NpbXBsZXgubGVhdmVFZGdlID0gbGVhdmVFZGdlO1xubmV0d29ya1NpbXBsZXguZW50ZXJFZGdlID0gZW50ZXJFZGdlO1xubmV0d29ya1NpbXBsZXguZXhjaGFuZ2VFZGdlcyA9IGV4Y2hhbmdlRWRnZXM7XG5cbi8qXG4gKiBUaGUgbmV0d29yayBzaW1wbGV4IGFsZ29yaXRobSBhc3NpZ25zIHJhbmtzIHRvIGVhY2ggbm9kZSBpbiB0aGUgaW5wdXQgZ3JhcGhcbiAqIGFuZCBpdGVyYXRpdmVseSBpbXByb3ZlcyB0aGUgcmFua2luZyB0byByZWR1Y2UgdGhlIGxlbmd0aCBvZiBlZGdlcy5cbiAqXG4gKiBQcmVjb25kaXRpb25zOlxuICpcbiAqICAgIDEuIFRoZSBpbnB1dCBncmFwaCBtdXN0IGJlIGEgREFHLlxuICogICAgMi4gQWxsIG5vZGVzIGluIHRoZSBncmFwaCBtdXN0IGhhdmUgYW4gb2JqZWN0IHZhbHVlLlxuICogICAgMy4gQWxsIGVkZ2VzIGluIHRoZSBncmFwaCBtdXN0IGhhdmUgXCJtaW5sZW5cIiBhbmQgXCJ3ZWlnaHRcIiBhdHRyaWJ1dGVzLlxuICpcbiAqIFBvc3Rjb25kaXRpb25zOlxuICpcbiAqICAgIDEuIEFsbCBub2RlcyBpbiB0aGUgZ3JhcGggd2lsbCBoYXZlIGFuIGFzc2lnbmVkIFwicmFua1wiIGF0dHJpYnV0ZSB0aGF0IGhhc1xuICogICAgICAgYmVlbiBvcHRpbWl6ZWQgYnkgdGhlIG5ldHdvcmsgc2ltcGxleCBhbGdvcml0aG0uIFJhbmtzIHN0YXJ0IGF0IDAuXG4gKlxuICpcbiAqIEEgcm91Z2ggc2tldGNoIG9mIHRoZSBhbGdvcml0aG0gaXMgYXMgZm9sbG93czpcbiAqXG4gKiAgICAxLiBBc3NpZ24gaW5pdGlhbCByYW5rcyB0byBlYWNoIG5vZGUuIFdlIHVzZSB0aGUgbG9uZ2VzdCBwYXRoIGFsZ29yaXRobSxcbiAqICAgICAgIHdoaWNoIGFzc2lnbnMgcmFua3MgdG8gdGhlIGxvd2VzdCBwb3NpdGlvbiBwb3NzaWJsZS4gSW4gZ2VuZXJhbCB0aGlzXG4gKiAgICAgICBsZWFkcyB0byB2ZXJ5IHdpZGUgYm90dG9tIHJhbmtzIGFuZCB1bm5lY2Vzc2FyaWx5IGxvbmcgZWRnZXMuXG4gKiAgICAyLiBDb25zdHJ1Y3QgYSBmZWFzaWJsZSB0aWdodCB0cmVlLiBBIHRpZ2h0IHRyZWUgaXMgb25lIHN1Y2ggdGhhdCBhbGxcbiAqICAgICAgIGVkZ2VzIGluIHRoZSB0cmVlIGhhdmUgbm8gc2xhY2sgKGRpZmZlcmVuY2UgYmV0d2VlbiBsZW5ndGggb2YgZWRnZVxuICogICAgICAgYW5kIG1pbmxlbiBmb3IgdGhlIGVkZ2UpLiBUaGlzIGJ5IGl0c2VsZiBncmVhdGx5IGltcHJvdmVzIHRoZSBhc3NpZ25lZFxuICogICAgICAgcmFua2luZ3MgYnkgc2hvcnRpbmcgZWRnZXMuXG4gKiAgICAzLiBJdGVyYXRpdmVseSBmaW5kIGVkZ2VzIHRoYXQgaGF2ZSBuZWdhdGl2ZSBjdXQgdmFsdWVzLiBHZW5lcmFsbHkgYVxuICogICAgICAgbmVnYXRpdmUgY3V0IHZhbHVlIGluZGljYXRlcyB0aGF0IHRoZSBlZGdlIGNvdWxkIGJlIHJlbW92ZWQgYW5kIGEgbmV3XG4gKiAgICAgICB0cmVlIGVkZ2UgY291bGQgYmUgYWRkZWQgdG8gcHJvZHVjZSBhIG1vcmUgY29tcGFjdCBncmFwaC5cbiAqXG4gKiBNdWNoIG9mIHRoZSBhbGdvcml0aG1zIGhlcmUgYXJlIGRlcml2ZWQgZnJvbSBHYW5zbmVyLCBldCBhbC4sIFwiQSBUZWNobmlxdWVcbiAqIGZvciBEcmF3aW5nIERpcmVjdGVkIEdyYXBocy5cIiBUaGUgc3RydWN0dXJlIG9mIHRoZSBmaWxlIHJvdWdobHkgZm9sbG93cyB0aGVcbiAqIHN0cnVjdHVyZSBvZiB0aGUgb3ZlcmFsbCBhbGdvcml0aG0uXG4gKi9cbmZ1bmN0aW9uIG5ldHdvcmtTaW1wbGV4KGcpIHtcbiAgZyA9IHNpbXBsaWZ5KGcpO1xuICBpbml0UmFuayhnKTtcbiAgdmFyIHQgPSBmZWFzaWJsZVRyZWUoZyk7XG4gIGluaXRMb3dMaW1WYWx1ZXModCk7XG4gIGluaXRDdXRWYWx1ZXModCwgZyk7XG5cbiAgdmFyIGUsIGY7XG4gIHdoaWxlICgoZSA9IGxlYXZlRWRnZSh0KSkpIHtcbiAgICBmID0gZW50ZXJFZGdlKHQsIGcsIGUpO1xuICAgIGV4Y2hhbmdlRWRnZXModCwgZywgZSwgZik7XG4gIH1cbn1cblxuLypcbiAqIEluaXRpYWxpemVzIGN1dCB2YWx1ZXMgZm9yIGFsbCBlZGdlcyBpbiB0aGUgdHJlZS5cbiAqL1xuZnVuY3Rpb24gaW5pdEN1dFZhbHVlcyh0LCBnKSB7XG4gIHZhciB2cyA9IHBvc3RvcmRlcih0LCB0Lm5vZGVzKCkpO1xuICB2cyA9IHZzLnNsaWNlKDAsIHZzLmxlbmd0aCAtIDEpO1xuICBfLmZvckVhY2godnMsIGZ1bmN0aW9uKHYpIHtcbiAgICBhc3NpZ25DdXRWYWx1ZSh0LCBnLCB2KTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGFzc2lnbkN1dFZhbHVlKHQsIGcsIGNoaWxkKSB7XG4gIHZhciBjaGlsZExhYiA9IHQubm9kZShjaGlsZCk7XG4gIHZhciBwYXJlbnQgPSBjaGlsZExhYi5wYXJlbnQ7XG4gIHQuZWRnZShjaGlsZCwgcGFyZW50KS5jdXR2YWx1ZSA9IGNhbGNDdXRWYWx1ZSh0LCBnLCBjaGlsZCk7XG59XG5cbi8qXG4gKiBHaXZlbiB0aGUgdGlnaHQgdHJlZSwgaXRzIGdyYXBoLCBhbmQgYSBjaGlsZCBpbiB0aGUgZ3JhcGggY2FsY3VsYXRlIGFuZFxuICogcmV0dXJuIHRoZSBjdXQgdmFsdWUgZm9yIHRoZSBlZGdlIGJldHdlZW4gdGhlIGNoaWxkIGFuZCBpdHMgcGFyZW50LlxuICovXG5mdW5jdGlvbiBjYWxjQ3V0VmFsdWUodCwgZywgY2hpbGQpIHtcbiAgdmFyIGNoaWxkTGFiID0gdC5ub2RlKGNoaWxkKTtcbiAgdmFyIHBhcmVudCA9IGNoaWxkTGFiLnBhcmVudDtcbiAgLy8gVHJ1ZSBpZiB0aGUgY2hpbGQgaXMgb24gdGhlIHRhaWwgZW5kIG9mIHRoZSBlZGdlIGluIHRoZSBkaXJlY3RlZCBncmFwaFxuICB2YXIgY2hpbGRJc1RhaWwgPSB0cnVlO1xuICAvLyBUaGUgZ3JhcGgncyB2aWV3IG9mIHRoZSB0cmVlIGVkZ2Ugd2UncmUgaW5zcGVjdGluZ1xuICB2YXIgZ3JhcGhFZGdlID0gZy5lZGdlKGNoaWxkLCBwYXJlbnQpO1xuICAvLyBUaGUgYWNjdW11bGF0ZWQgY3V0IHZhbHVlIGZvciB0aGUgZWRnZSBiZXR3ZWVuIHRoaXMgbm9kZSBhbmQgaXRzIHBhcmVudFxuICB2YXIgY3V0VmFsdWUgPSAwO1xuXG4gIGlmICghZ3JhcGhFZGdlKSB7XG4gICAgY2hpbGRJc1RhaWwgPSBmYWxzZTtcbiAgICBncmFwaEVkZ2UgPSBnLmVkZ2UocGFyZW50LCBjaGlsZCk7XG4gIH1cblxuICBjdXRWYWx1ZSA9IGdyYXBoRWRnZS53ZWlnaHQ7XG5cbiAgXy5mb3JFYWNoKGcubm9kZUVkZ2VzKGNoaWxkKSwgZnVuY3Rpb24oZSkge1xuICAgIHZhciBpc091dEVkZ2UgPSBlLnYgPT09IGNoaWxkLFxuICAgICAgb3RoZXIgPSBpc091dEVkZ2UgPyBlLncgOiBlLnY7XG5cbiAgICBpZiAob3RoZXIgIT09IHBhcmVudCkge1xuICAgICAgdmFyIHBvaW50c1RvSGVhZCA9IGlzT3V0RWRnZSA9PT0gY2hpbGRJc1RhaWwsXG4gICAgICAgIG90aGVyV2VpZ2h0ID0gZy5lZGdlKGUpLndlaWdodDtcblxuICAgICAgY3V0VmFsdWUgKz0gcG9pbnRzVG9IZWFkID8gb3RoZXJXZWlnaHQgOiAtb3RoZXJXZWlnaHQ7XG4gICAgICBpZiAoaXNUcmVlRWRnZSh0LCBjaGlsZCwgb3RoZXIpKSB7XG4gICAgICAgIHZhciBvdGhlckN1dFZhbHVlID0gdC5lZGdlKGNoaWxkLCBvdGhlcikuY3V0dmFsdWU7XG4gICAgICAgIGN1dFZhbHVlICs9IHBvaW50c1RvSGVhZCA/IC1vdGhlckN1dFZhbHVlIDogb3RoZXJDdXRWYWx1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiBjdXRWYWx1ZTtcbn1cblxuZnVuY3Rpb24gaW5pdExvd0xpbVZhbHVlcyh0cmVlLCByb290KSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMikge1xuICAgIHJvb3QgPSB0cmVlLm5vZGVzKClbMF07XG4gIH1cbiAgZGZzQXNzaWduTG93TGltKHRyZWUsIHt9LCAxLCByb290KTtcbn1cblxuZnVuY3Rpb24gZGZzQXNzaWduTG93TGltKHRyZWUsIHZpc2l0ZWQsIG5leHRMaW0sIHYsIHBhcmVudCkge1xuICB2YXIgbG93ID0gbmV4dExpbTtcbiAgdmFyIGxhYmVsID0gdHJlZS5ub2RlKHYpO1xuXG4gIHZpc2l0ZWRbdl0gPSB0cnVlO1xuICBfLmZvckVhY2godHJlZS5uZWlnaGJvcnModiksIGZ1bmN0aW9uKHcpIHtcbiAgICBpZiAoIV8uaGFzKHZpc2l0ZWQsIHcpKSB7XG4gICAgICBuZXh0TGltID0gZGZzQXNzaWduTG93TGltKHRyZWUsIHZpc2l0ZWQsIG5leHRMaW0sIHcsIHYpO1xuICAgIH1cbiAgfSk7XG5cbiAgbGFiZWwubG93ID0gbG93O1xuICBsYWJlbC5saW0gPSBuZXh0TGltKys7XG4gIGlmIChwYXJlbnQpIHtcbiAgICBsYWJlbC5wYXJlbnQgPSBwYXJlbnQ7XG4gIH0gZWxzZSB7XG4gICAgLy8gVE9ETyBzaG91bGQgYmUgYWJsZSB0byByZW1vdmUgdGhpcyB3aGVuIHdlIGluY3JlbWVudGFsbHkgdXBkYXRlIGxvdyBsaW1cbiAgICBkZWxldGUgbGFiZWwucGFyZW50O1xuICB9XG5cbiAgcmV0dXJuIG5leHRMaW07XG59XG5cbmZ1bmN0aW9uIGxlYXZlRWRnZSh0cmVlKSB7XG4gIHJldHVybiBfLmZpbmQodHJlZS5lZGdlcygpLCBmdW5jdGlvbihlKSB7XG4gICAgcmV0dXJuIHRyZWUuZWRnZShlKS5jdXR2YWx1ZSA8IDA7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBlbnRlckVkZ2UodCwgZywgZWRnZSkge1xuICB2YXIgdiA9IGVkZ2UudjtcbiAgdmFyIHcgPSBlZGdlLnc7XG5cbiAgLy8gRm9yIHRoZSByZXN0IG9mIHRoaXMgZnVuY3Rpb24gd2UgYXNzdW1lIHRoYXQgdiBpcyB0aGUgdGFpbCBhbmQgdyBpcyB0aGVcbiAgLy8gaGVhZCwgc28gaWYgd2UgZG9uJ3QgaGF2ZSB0aGlzIGVkZ2UgaW4gdGhlIGdyYXBoIHdlIHNob3VsZCBmbGlwIGl0IHRvXG4gIC8vIG1hdGNoIHRoZSBjb3JyZWN0IG9yaWVudGF0aW9uLlxuICBpZiAoIWcuaGFzRWRnZSh2LCB3KSkge1xuICAgIHYgPSBlZGdlLnc7XG4gICAgdyA9IGVkZ2UudjtcbiAgfVxuXG4gIHZhciB2TGFiZWwgPSB0Lm5vZGUodik7XG4gIHZhciB3TGFiZWwgPSB0Lm5vZGUodyk7XG4gIHZhciB0YWlsTGFiZWwgPSB2TGFiZWw7XG4gIHZhciBmbGlwID0gZmFsc2U7XG5cbiAgLy8gSWYgdGhlIHJvb3QgaXMgaW4gdGhlIHRhaWwgb2YgdGhlIGVkZ2UgdGhlbiB3ZSBuZWVkIHRvIGZsaXAgdGhlIGxvZ2ljIHRoYXRcbiAgLy8gY2hlY2tzIGZvciB0aGUgaGVhZCBhbmQgdGFpbCBub2RlcyBpbiB0aGUgY2FuZGlkYXRlcyBmdW5jdGlvbiBiZWxvdy5cbiAgaWYgKHZMYWJlbC5saW0gPiB3TGFiZWwubGltKSB7XG4gICAgdGFpbExhYmVsID0gd0xhYmVsO1xuICAgIGZsaXAgPSB0cnVlO1xuICB9XG5cbiAgdmFyIGNhbmRpZGF0ZXMgPSBfLmZpbHRlcihnLmVkZ2VzKCksIGZ1bmN0aW9uKGVkZ2UpIHtcbiAgICByZXR1cm4gZmxpcCA9PT0gaXNEZXNjZW5kYW50KHQsIHQubm9kZShlZGdlLnYpLCB0YWlsTGFiZWwpICYmXG4gICAgICAgICAgIGZsaXAgIT09IGlzRGVzY2VuZGFudCh0LCB0Lm5vZGUoZWRnZS53KSwgdGFpbExhYmVsKTtcbiAgfSk7XG5cbiAgcmV0dXJuIF8ubWluQnkoY2FuZGlkYXRlcywgZnVuY3Rpb24oZWRnZSkgeyByZXR1cm4gc2xhY2soZywgZWRnZSk7IH0pO1xufVxuXG5mdW5jdGlvbiBleGNoYW5nZUVkZ2VzKHQsIGcsIGUsIGYpIHtcbiAgdmFyIHYgPSBlLnY7XG4gIHZhciB3ID0gZS53O1xuICB0LnJlbW92ZUVkZ2Uodiwgdyk7XG4gIHQuc2V0RWRnZShmLnYsIGYudywge30pO1xuICBpbml0TG93TGltVmFsdWVzKHQpO1xuICBpbml0Q3V0VmFsdWVzKHQsIGcpO1xuICB1cGRhdGVSYW5rcyh0LCBnKTtcbn1cblxuZnVuY3Rpb24gdXBkYXRlUmFua3ModCwgZykge1xuICB2YXIgcm9vdCA9IF8uZmluZCh0Lm5vZGVzKCksIGZ1bmN0aW9uKHYpIHsgcmV0dXJuICFnLm5vZGUodikucGFyZW50OyB9KTtcbiAgdmFyIHZzID0gcHJlb3JkZXIodCwgcm9vdCk7XG4gIHZzID0gdnMuc2xpY2UoMSk7XG4gIF8uZm9yRWFjaCh2cywgZnVuY3Rpb24odikge1xuICAgIHZhciBwYXJlbnQgPSB0Lm5vZGUodikucGFyZW50LFxuICAgICAgZWRnZSA9IGcuZWRnZSh2LCBwYXJlbnQpLFxuICAgICAgZmxpcHBlZCA9IGZhbHNlO1xuXG4gICAgaWYgKCFlZGdlKSB7XG4gICAgICBlZGdlID0gZy5lZGdlKHBhcmVudCwgdik7XG4gICAgICBmbGlwcGVkID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBnLm5vZGUodikucmFuayA9IGcubm9kZShwYXJlbnQpLnJhbmsgKyAoZmxpcHBlZCA/IGVkZ2UubWlubGVuIDogLWVkZ2UubWlubGVuKTtcbiAgfSk7XG59XG5cbi8qXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIGVkZ2UgaXMgaW4gdGhlIHRyZWUuXG4gKi9cbmZ1bmN0aW9uIGlzVHJlZUVkZ2UodHJlZSwgdSwgdikge1xuICByZXR1cm4gdHJlZS5oYXNFZGdlKHUsIHYpO1xufVxuXG4vKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSBzcGVjaWZpZWQgbm9kZSBpcyBkZXNjZW5kYW50IG9mIHRoZSByb290IG5vZGUgcGVyIHRoZVxuICogYXNzaWduZWQgbG93IGFuZCBsaW0gYXR0cmlidXRlcyBpbiB0aGUgdHJlZS5cbiAqL1xuZnVuY3Rpb24gaXNEZXNjZW5kYW50KHRyZWUsIHZMYWJlbCwgcm9vdExhYmVsKSB7XG4gIHJldHVybiByb290TGFiZWwubG93IDw9IHZMYWJlbC5saW0gJiYgdkxhYmVsLmxpbSA8PSByb290TGFiZWwubGltO1xufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfID0gcmVxdWlyZShcIi4uL2xvZGFzaFwiKTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGxvbmdlc3RQYXRoOiBsb25nZXN0UGF0aCxcbiAgc2xhY2s6IHNsYWNrXG59O1xuXG4vKlxuICogSW5pdGlhbGl6ZXMgcmFua3MgZm9yIHRoZSBpbnB1dCBncmFwaCB1c2luZyB0aGUgbG9uZ2VzdCBwYXRoIGFsZ29yaXRobS4gVGhpc1xuICogYWxnb3JpdGhtIHNjYWxlcyB3ZWxsIGFuZCBpcyBmYXN0IGluIHByYWN0aWNlLCBpdCB5aWVsZHMgcmF0aGVyIHBvb3JcbiAqIHNvbHV0aW9ucy4gTm9kZXMgYXJlIHB1c2hlZCB0byB0aGUgbG93ZXN0IGxheWVyIHBvc3NpYmxlLCBsZWF2aW5nIHRoZSBib3R0b21cbiAqIHJhbmtzIHdpZGUgYW5kIGxlYXZpbmcgZWRnZXMgbG9uZ2VyIHRoYW4gbmVjZXNzYXJ5LiBIb3dldmVyLCBkdWUgdG8gaXRzXG4gKiBzcGVlZCwgdGhpcyBhbGdvcml0aG0gaXMgZ29vZCBmb3IgZ2V0dGluZyBhbiBpbml0aWFsIHJhbmtpbmcgdGhhdCBjYW4gYmUgZmVkXG4gKiBpbnRvIG90aGVyIGFsZ29yaXRobXMuXG4gKlxuICogVGhpcyBhbGdvcml0aG0gZG9lcyBub3Qgbm9ybWFsaXplIGxheWVycyBiZWNhdXNlIGl0IHdpbGwgYmUgdXNlZCBieSBvdGhlclxuICogYWxnb3JpdGhtcyBpbiBtb3N0IGNhc2VzLiBJZiB1c2luZyB0aGlzIGFsZ29yaXRobSBkaXJlY3RseSwgYmUgc3VyZSB0b1xuICogcnVuIG5vcm1hbGl6ZSBhdCB0aGUgZW5kLlxuICpcbiAqIFByZS1jb25kaXRpb25zOlxuICpcbiAqICAgIDEuIElucHV0IGdyYXBoIGlzIGEgREFHLlxuICogICAgMi4gSW5wdXQgZ3JhcGggbm9kZSBsYWJlbHMgY2FuIGJlIGFzc2lnbmVkIHByb3BlcnRpZXMuXG4gKlxuICogUG9zdC1jb25kaXRpb25zOlxuICpcbiAqICAgIDEuIEVhY2ggbm9kZSB3aWxsIGJlIGFzc2lnbiBhbiAodW5ub3JtYWxpemVkKSBcInJhbmtcIiBwcm9wZXJ0eS5cbiAqL1xuZnVuY3Rpb24gbG9uZ2VzdFBhdGgoZykge1xuICB2YXIgdmlzaXRlZCA9IHt9O1xuXG4gIGZ1bmN0aW9uIGRmcyh2KSB7XG4gICAgdmFyIGxhYmVsID0gZy5ub2RlKHYpO1xuICAgIGlmIChfLmhhcyh2aXNpdGVkLCB2KSkge1xuICAgICAgcmV0dXJuIGxhYmVsLnJhbms7XG4gICAgfVxuICAgIHZpc2l0ZWRbdl0gPSB0cnVlO1xuXG4gICAgdmFyIHJhbmsgPSBfLm1pbihfLm1hcChnLm91dEVkZ2VzKHYpLCBmdW5jdGlvbihlKSB7XG4gICAgICByZXR1cm4gZGZzKGUudykgLSBnLmVkZ2UoZSkubWlubGVuO1xuICAgIH0pKTtcblxuICAgIGlmIChyYW5rID09PSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFkgfHwgLy8gcmV0dXJuIHZhbHVlIG9mIF8ubWFwKFtdKSBmb3IgTG9kYXNoIDNcbiAgICAgICAgcmFuayA9PT0gdW5kZWZpbmVkIHx8IC8vIHJldHVybiB2YWx1ZSBvZiBfLm1hcChbXSkgZm9yIExvZGFzaCA0XG4gICAgICAgIHJhbmsgPT09IG51bGwpIHsgLy8gcmV0dXJuIHZhbHVlIG9mIF8ubWFwKFtudWxsXSlcbiAgICAgIHJhbmsgPSAwO1xuICAgIH1cblxuICAgIHJldHVybiAobGFiZWwucmFuayA9IHJhbmspO1xuICB9XG5cbiAgXy5mb3JFYWNoKGcuc291cmNlcygpLCBkZnMpO1xufVxuXG4vKlxuICogUmV0dXJucyB0aGUgYW1vdW50IG9mIHNsYWNrIGZvciB0aGUgZ2l2ZW4gZWRnZS4gVGhlIHNsYWNrIGlzIGRlZmluZWQgYXMgdGhlXG4gKiBkaWZmZXJlbmNlIGJldHdlZW4gdGhlIGxlbmd0aCBvZiB0aGUgZWRnZSBhbmQgaXRzIG1pbmltdW0gbGVuZ3RoLlxuICovXG5mdW5jdGlvbiBzbGFjayhnLCBlKSB7XG4gIHJldHVybiBnLm5vZGUoZS53KS5yYW5rIC0gZy5ub2RlKGUudikucmFuayAtIGcuZWRnZShlKS5taW5sZW47XG59XG4iLCIvKiBlc2xpbnQgXCJuby1jb25zb2xlXCI6IG9mZiAqL1xuXG5cInVzZSBzdHJpY3RcIjtcblxudmFyIF8gPSByZXF1aXJlKFwiLi9sb2Rhc2hcIik7XG52YXIgR3JhcGggPSByZXF1aXJlKFwiLi9ncmFwaGxpYlwiKS5HcmFwaDtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGFkZER1bW15Tm9kZTogYWRkRHVtbXlOb2RlLFxuICBzaW1wbGlmeTogc2ltcGxpZnksXG4gIGFzTm9uQ29tcG91bmRHcmFwaDogYXNOb25Db21wb3VuZEdyYXBoLFxuICBzdWNjZXNzb3JXZWlnaHRzOiBzdWNjZXNzb3JXZWlnaHRzLFxuICBwcmVkZWNlc3NvcldlaWdodHM6IHByZWRlY2Vzc29yV2VpZ2h0cyxcbiAgaW50ZXJzZWN0UmVjdDogaW50ZXJzZWN0UmVjdCxcbiAgYnVpbGRMYXllck1hdHJpeDogYnVpbGRMYXllck1hdHJpeCxcbiAgbm9ybWFsaXplUmFua3M6IG5vcm1hbGl6ZVJhbmtzLFxuICByZW1vdmVFbXB0eVJhbmtzOiByZW1vdmVFbXB0eVJhbmtzLFxuICBhZGRCb3JkZXJOb2RlOiBhZGRCb3JkZXJOb2RlLFxuICBtYXhSYW5rOiBtYXhSYW5rLFxuICBwYXJ0aXRpb246IHBhcnRpdGlvbixcbiAgdGltZTogdGltZSxcbiAgbm90aW1lOiBub3RpbWVcbn07XG5cbi8qXG4gKiBBZGRzIGEgZHVtbXkgbm9kZSB0byB0aGUgZ3JhcGggYW5kIHJldHVybiB2LlxuICovXG5mdW5jdGlvbiBhZGREdW1teU5vZGUoZywgdHlwZSwgYXR0cnMsIG5hbWUpIHtcbiAgdmFyIHY7XG4gIGRvIHtcbiAgICB2ID0gXy51bmlxdWVJZChuYW1lKTtcbiAgfSB3aGlsZSAoZy5oYXNOb2RlKHYpKTtcblxuICBhdHRycy5kdW1teSA9IHR5cGU7XG4gIGcuc2V0Tm9kZSh2LCBhdHRycyk7XG4gIHJldHVybiB2O1xufVxuXG4vKlxuICogUmV0dXJucyBhIG5ldyBncmFwaCB3aXRoIG9ubHkgc2ltcGxlIGVkZ2VzLiBIYW5kbGVzIGFnZ3JlZ2F0aW9uIG9mIGRhdGFcbiAqIGFzc29jaWF0ZWQgd2l0aCBtdWx0aS1lZGdlcy5cbiAqL1xuZnVuY3Rpb24gc2ltcGxpZnkoZykge1xuICB2YXIgc2ltcGxpZmllZCA9IG5ldyBHcmFwaCgpLnNldEdyYXBoKGcuZ3JhcGgoKSk7XG4gIF8uZm9yRWFjaChnLm5vZGVzKCksIGZ1bmN0aW9uKHYpIHsgc2ltcGxpZmllZC5zZXROb2RlKHYsIGcubm9kZSh2KSk7IH0pO1xuICBfLmZvckVhY2goZy5lZGdlcygpLCBmdW5jdGlvbihlKSB7XG4gICAgdmFyIHNpbXBsZUxhYmVsID0gc2ltcGxpZmllZC5lZGdlKGUudiwgZS53KSB8fCB7IHdlaWdodDogMCwgbWlubGVuOiAxIH07XG4gICAgdmFyIGxhYmVsID0gZy5lZGdlKGUpO1xuICAgIHNpbXBsaWZpZWQuc2V0RWRnZShlLnYsIGUudywge1xuICAgICAgd2VpZ2h0OiBzaW1wbGVMYWJlbC53ZWlnaHQgKyBsYWJlbC53ZWlnaHQsXG4gICAgICBtaW5sZW46IE1hdGgubWF4KHNpbXBsZUxhYmVsLm1pbmxlbiwgbGFiZWwubWlubGVuKVxuICAgIH0pO1xuICB9KTtcbiAgcmV0dXJuIHNpbXBsaWZpZWQ7XG59XG5cbmZ1bmN0aW9uIGFzTm9uQ29tcG91bmRHcmFwaChnKSB7XG4gIHZhciBzaW1wbGlmaWVkID0gbmV3IEdyYXBoKHsgbXVsdGlncmFwaDogZy5pc011bHRpZ3JhcGgoKSB9KS5zZXRHcmFwaChnLmdyYXBoKCkpO1xuICBfLmZvckVhY2goZy5ub2RlcygpLCBmdW5jdGlvbih2KSB7XG4gICAgaWYgKCFnLmNoaWxkcmVuKHYpLmxlbmd0aCkge1xuICAgICAgc2ltcGxpZmllZC5zZXROb2RlKHYsIGcubm9kZSh2KSk7XG4gICAgfVxuICB9KTtcbiAgXy5mb3JFYWNoKGcuZWRnZXMoKSwgZnVuY3Rpb24oZSkge1xuICAgIHNpbXBsaWZpZWQuc2V0RWRnZShlLCBnLmVkZ2UoZSkpO1xuICB9KTtcbiAgcmV0dXJuIHNpbXBsaWZpZWQ7XG59XG5cbmZ1bmN0aW9uIHN1Y2Nlc3NvcldlaWdodHMoZykge1xuICB2YXIgd2VpZ2h0TWFwID0gXy5tYXAoZy5ub2RlcygpLCBmdW5jdGlvbih2KSB7XG4gICAgdmFyIHN1Y3MgPSB7fTtcbiAgICBfLmZvckVhY2goZy5vdXRFZGdlcyh2KSwgZnVuY3Rpb24oZSkge1xuICAgICAgc3Vjc1tlLnddID0gKHN1Y3NbZS53XSB8fCAwKSArIGcuZWRnZShlKS53ZWlnaHQ7XG4gICAgfSk7XG4gICAgcmV0dXJuIHN1Y3M7XG4gIH0pO1xuICByZXR1cm4gXy56aXBPYmplY3QoZy5ub2RlcygpLCB3ZWlnaHRNYXApO1xufVxuXG5mdW5jdGlvbiBwcmVkZWNlc3NvcldlaWdodHMoZykge1xuICB2YXIgd2VpZ2h0TWFwID0gXy5tYXAoZy5ub2RlcygpLCBmdW5jdGlvbih2KSB7XG4gICAgdmFyIHByZWRzID0ge307XG4gICAgXy5mb3JFYWNoKGcuaW5FZGdlcyh2KSwgZnVuY3Rpb24oZSkge1xuICAgICAgcHJlZHNbZS52XSA9IChwcmVkc1tlLnZdIHx8IDApICsgZy5lZGdlKGUpLndlaWdodDtcbiAgICB9KTtcbiAgICByZXR1cm4gcHJlZHM7XG4gIH0pO1xuICByZXR1cm4gXy56aXBPYmplY3QoZy5ub2RlcygpLCB3ZWlnaHRNYXApO1xufVxuXG4vKlxuICogRmluZHMgd2hlcmUgYSBsaW5lIHN0YXJ0aW5nIGF0IHBvaW50ICh7eCwgeX0pIHdvdWxkIGludGVyc2VjdCBhIHJlY3RhbmdsZVxuICogKHt4LCB5LCB3aWR0aCwgaGVpZ2h0fSkgaWYgaXQgd2VyZSBwb2ludGluZyBhdCB0aGUgcmVjdGFuZ2xlJ3MgY2VudGVyLlxuICovXG5mdW5jdGlvbiBpbnRlcnNlY3RSZWN0KHJlY3QsIHBvaW50KSB7XG4gIHZhciB4ID0gcmVjdC54O1xuICB2YXIgeSA9IHJlY3QueTtcblxuICAvLyBSZWN0YW5nbGUgaW50ZXJzZWN0aW9uIGFsZ29yaXRobSBmcm9tOlxuICAvLyBodHRwOi8vbWF0aC5zdGFja2V4Y2hhbmdlLmNvbS9xdWVzdGlvbnMvMTA4MTEzL2ZpbmQtZWRnZS1iZXR3ZWVuLXR3by1ib3hlc1xuICB2YXIgZHggPSBwb2ludC54IC0geDtcbiAgdmFyIGR5ID0gcG9pbnQueSAtIHk7XG4gIHZhciB3ID0gcmVjdC53aWR0aCAvIDI7XG4gIHZhciBoID0gcmVjdC5oZWlnaHQgLyAyO1xuXG4gIGlmICghZHggJiYgIWR5KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiTm90IHBvc3NpYmxlIHRvIGZpbmQgaW50ZXJzZWN0aW9uIGluc2lkZSBvZiB0aGUgcmVjdGFuZ2xlXCIpO1xuICB9XG5cbiAgdmFyIHN4LCBzeTtcbiAgaWYgKE1hdGguYWJzKGR5KSAqIHcgPiBNYXRoLmFicyhkeCkgKiBoKSB7XG4gICAgLy8gSW50ZXJzZWN0aW9uIGlzIHRvcCBvciBib3R0b20gb2YgcmVjdC5cbiAgICBpZiAoZHkgPCAwKSB7XG4gICAgICBoID0gLWg7XG4gICAgfVxuICAgIHN4ID0gaCAqIGR4IC8gZHk7XG4gICAgc3kgPSBoO1xuICB9IGVsc2Uge1xuICAgIC8vIEludGVyc2VjdGlvbiBpcyBsZWZ0IG9yIHJpZ2h0IG9mIHJlY3QuXG4gICAgaWYgKGR4IDwgMCkge1xuICAgICAgdyA9IC13O1xuICAgIH1cbiAgICBzeCA9IHc7XG4gICAgc3kgPSB3ICogZHkgLyBkeDtcbiAgfVxuXG4gIHJldHVybiB7IHg6IHggKyBzeCwgeTogeSArIHN5IH07XG59XG5cbi8qXG4gKiBHaXZlbiBhIERBRyB3aXRoIGVhY2ggbm9kZSBhc3NpZ25lZCBcInJhbmtcIiBhbmQgXCJvcmRlclwiIHByb3BlcnRpZXMsIHRoaXNcbiAqIGZ1bmN0aW9uIHdpbGwgcHJvZHVjZSBhIG1hdHJpeCB3aXRoIHRoZSBpZHMgb2YgZWFjaCBub2RlLlxuICovXG5mdW5jdGlvbiBidWlsZExheWVyTWF0cml4KGcpIHtcbiAgdmFyIGxheWVyaW5nID0gXy5tYXAoXy5yYW5nZShtYXhSYW5rKGcpICsgMSksIGZ1bmN0aW9uKCkgeyByZXR1cm4gW107IH0pO1xuICBfLmZvckVhY2goZy5ub2RlcygpLCBmdW5jdGlvbih2KSB7XG4gICAgdmFyIG5vZGUgPSBnLm5vZGUodik7XG4gICAgdmFyIHJhbmsgPSBub2RlLnJhbms7XG4gICAgaWYgKCFfLmlzVW5kZWZpbmVkKHJhbmspKSB7XG4gICAgICBsYXllcmluZ1tyYW5rXVtub2RlLm9yZGVyXSA9IHY7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIGxheWVyaW5nO1xufVxuXG4vKlxuICogQWRqdXN0cyB0aGUgcmFua3MgZm9yIGFsbCBub2RlcyBpbiB0aGUgZ3JhcGggc3VjaCB0aGF0IGFsbCBub2RlcyB2IGhhdmVcbiAqIHJhbmsodikgPj0gMCBhbmQgYXQgbGVhc3Qgb25lIG5vZGUgdyBoYXMgcmFuayh3KSA9IDAuXG4gKi9cbmZ1bmN0aW9uIG5vcm1hbGl6ZVJhbmtzKGcpIHtcbiAgdmFyIG1pbiA9IF8ubWluKF8ubWFwKGcubm9kZXMoKSwgZnVuY3Rpb24odikgeyByZXR1cm4gZy5ub2RlKHYpLnJhbms7IH0pKTtcbiAgXy5mb3JFYWNoKGcubm9kZXMoKSwgZnVuY3Rpb24odikge1xuICAgIHZhciBub2RlID0gZy5ub2RlKHYpO1xuICAgIGlmIChfLmhhcyhub2RlLCBcInJhbmtcIikpIHtcbiAgICAgIG5vZGUucmFuayAtPSBtaW47XG4gICAgfVxuICB9KTtcbn1cblxuZnVuY3Rpb24gcmVtb3ZlRW1wdHlSYW5rcyhnKSB7XG4gIC8vIFJhbmtzIG1heSBub3Qgc3RhcnQgYXQgMCwgc28gd2UgbmVlZCB0byBvZmZzZXQgdGhlbVxuICB2YXIgb2Zmc2V0ID0gXy5taW4oXy5tYXAoZy5ub2RlcygpLCBmdW5jdGlvbih2KSB7IHJldHVybiBnLm5vZGUodikucmFuazsgfSkpO1xuXG4gIHZhciBsYXllcnMgPSBbXTtcbiAgXy5mb3JFYWNoKGcubm9kZXMoKSwgZnVuY3Rpb24odikge1xuICAgIHZhciByYW5rID0gZy5ub2RlKHYpLnJhbmsgLSBvZmZzZXQ7XG4gICAgaWYgKCFsYXllcnNbcmFua10pIHtcbiAgICAgIGxheWVyc1tyYW5rXSA9IFtdO1xuICAgIH1cbiAgICBsYXllcnNbcmFua10ucHVzaCh2KTtcbiAgfSk7XG5cbiAgdmFyIGRlbHRhID0gMDtcbiAgdmFyIG5vZGVSYW5rRmFjdG9yID0gZy5ncmFwaCgpLm5vZGVSYW5rRmFjdG9yO1xuICBfLmZvckVhY2gobGF5ZXJzLCBmdW5jdGlvbih2cywgaSkge1xuICAgIGlmIChfLmlzVW5kZWZpbmVkKHZzKSAmJiBpICUgbm9kZVJhbmtGYWN0b3IgIT09IDApIHtcbiAgICAgIC0tZGVsdGE7XG4gICAgfSBlbHNlIGlmIChkZWx0YSkge1xuICAgICAgXy5mb3JFYWNoKHZzLCBmdW5jdGlvbih2KSB7IGcubm9kZSh2KS5yYW5rICs9IGRlbHRhOyB9KTtcbiAgICB9XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBhZGRCb3JkZXJOb2RlKGcsIHByZWZpeCwgcmFuaywgb3JkZXIpIHtcbiAgdmFyIG5vZGUgPSB7XG4gICAgd2lkdGg6IDAsXG4gICAgaGVpZ2h0OiAwXG4gIH07XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID49IDQpIHtcbiAgICBub2RlLnJhbmsgPSByYW5rO1xuICAgIG5vZGUub3JkZXIgPSBvcmRlcjtcbiAgfVxuICByZXR1cm4gYWRkRHVtbXlOb2RlKGcsIFwiYm9yZGVyXCIsIG5vZGUsIHByZWZpeCk7XG59XG5cbmZ1bmN0aW9uIG1heFJhbmsoZykge1xuICByZXR1cm4gXy5tYXgoXy5tYXAoZy5ub2RlcygpLCBmdW5jdGlvbih2KSB7XG4gICAgdmFyIHJhbmsgPSBnLm5vZGUodikucmFuaztcbiAgICBpZiAoIV8uaXNVbmRlZmluZWQocmFuaykpIHtcbiAgICAgIHJldHVybiByYW5rO1xuICAgIH1cbiAgfSkpO1xufVxuXG4vKlxuICogUGFydGl0aW9uIGEgY29sbGVjdGlvbiBpbnRvIHR3byBncm91cHM6IGBsaHNgIGFuZCBgcmhzYC4gSWYgdGhlIHN1cHBsaWVkXG4gKiBmdW5jdGlvbiByZXR1cm5zIHRydWUgZm9yIGFuIGVudHJ5IGl0IGdvZXMgaW50byBgbGhzYC4gT3RoZXJ3aXNlIGl0IGdvZXNcbiAqIGludG8gYHJocy5cbiAqL1xuZnVuY3Rpb24gcGFydGl0aW9uKGNvbGxlY3Rpb24sIGZuKSB7XG4gIHZhciByZXN1bHQgPSB7IGxoczogW10sIHJoczogW10gfTtcbiAgXy5mb3JFYWNoKGNvbGxlY3Rpb24sIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgaWYgKGZuKHZhbHVlKSkge1xuICAgICAgcmVzdWx0Lmxocy5wdXNoKHZhbHVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0LnJocy5wdXNoKHZhbHVlKTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKlxuICogUmV0dXJucyBhIG5ldyBmdW5jdGlvbiB0aGF0IHdyYXBzIGBmbmAgd2l0aCBhIHRpbWVyLiBUaGUgd3JhcHBlciBsb2dzIHRoZVxuICogdGltZSBpdCB0YWtlcyB0byBleGVjdXRlIHRoZSBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gdGltZShuYW1lLCBmbikge1xuICB2YXIgc3RhcnQgPSBfLm5vdygpO1xuICB0cnkge1xuICAgIHJldHVybiBmbigpO1xuICB9IGZpbmFsbHkge1xuICAgIGNvbnNvbGUubG9nKG5hbWUgKyBcIiB0aW1lOiBcIiArIChfLm5vdygpIC0gc3RhcnQpICsgXCJtc1wiKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBub3RpbWUobmFtZSwgZm4pIHtcbiAgcmV0dXJuIGZuKCk7XG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IFwiMC44LjVcIjtcbiIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDE0LCBDaHJpcyBQZXR0aXR0XG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dFxuICogbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBjb25kaXRpb25zIGFyZSBtZXQ6XG4gKlxuICogMS4gUmVkaXN0cmlidXRpb25zIG9mIHNvdXJjZSBjb2RlIG11c3QgcmV0YWluIHRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlLCB0aGlzXG4gKiBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lci5cbiAqXG4gKiAyLiBSZWRpc3RyaWJ1dGlvbnMgaW4gYmluYXJ5IGZvcm0gbXVzdCByZXByb2R1Y2UgdGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UsXG4gKiB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyIGluIHRoZSBkb2N1bWVudGF0aW9uXG4gKiBhbmQvb3Igb3RoZXIgbWF0ZXJpYWxzIHByb3ZpZGVkIHdpdGggdGhlIGRpc3RyaWJ1dGlvbi5cbiAqXG4gKiAzLiBOZWl0aGVyIHRoZSBuYW1lIG9mIHRoZSBjb3B5cmlnaHQgaG9sZGVyIG5vciB0aGUgbmFtZXMgb2YgaXRzIGNvbnRyaWJ1dG9yc1xuICogbWF5IGJlIHVzZWQgdG8gZW5kb3JzZSBvciBwcm9tb3RlIHByb2R1Y3RzIGRlcml2ZWQgZnJvbSB0aGlzIHNvZnR3YXJlIHdpdGhvdXRcbiAqIHNwZWNpZmljIHByaW9yIHdyaXR0ZW4gcGVybWlzc2lvbi5cbiAqXG4gKiBUSElTIFNPRlRXQVJFIElTIFBST1ZJREVEIEJZIFRIRSBDT1BZUklHSFQgSE9MREVSUyBBTkQgQ09OVFJJQlVUT1JTIFwiQVMgSVNcIiBBTkRcbiAqIEFOWSBFWFBSRVNTIE9SIElNUExJRUQgV0FSUkFOVElFUywgSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFRIRSBJTVBMSUVEXG4gKiBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQVJFXG4gKiBESVNDTEFJTUVELiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQ09QWVJJR0hUIEhPTERFUiBPUiBDT05UUklCVVRPUlMgQkUgTElBQkxFXG4gKiBGT1IgQU5ZIERJUkVDVCwgSU5ESVJFQ1QsIElOQ0lERU5UQUwsIFNQRUNJQUwsIEVYRU1QTEFSWSwgT1IgQ09OU0VRVUVOVElBTFxuICogREFNQUdFUyAoSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFBST0NVUkVNRU5UIE9GIFNVQlNUSVRVVEUgR09PRFMgT1JcbiAqIFNFUlZJQ0VTOyBMT1NTIE9GIFVTRSwgREFUQSwgT1IgUFJPRklUUzsgT1IgQlVTSU5FU1MgSU5URVJSVVBUSU9OKSBIT1dFVkVSXG4gKiBDQVVTRUQgQU5EIE9OIEFOWSBUSEVPUlkgT0YgTElBQklMSVRZLCBXSEVUSEVSIElOIENPTlRSQUNULCBTVFJJQ1QgTElBQklMSVRZLFxuICogT1IgVE9SVCAoSU5DTFVESU5HIE5FR0xJR0VOQ0UgT1IgT1RIRVJXSVNFKSBBUklTSU5HIElOIEFOWSBXQVkgT1VUIE9GIFRIRSBVU0VcbiAqIE9GIFRISVMgU09GVFdBUkUsIEVWRU4gSUYgQURWSVNFRCBPRiBUSEUgUE9TU0lCSUxJVFkgT0YgU1VDSCBEQU1BR0UuXG4gKi9cblxudmFyIGxpYiA9IHJlcXVpcmUoXCIuL2xpYlwiKTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIEdyYXBoOiBsaWIuR3JhcGgsXG4gIGpzb246IHJlcXVpcmUoXCIuL2xpYi9qc29uXCIpLFxuICBhbGc6IHJlcXVpcmUoXCIuL2xpYi9hbGdcIiksXG4gIHZlcnNpb246IGxpYi52ZXJzaW9uXG59O1xuIiwidmFyIF8gPSByZXF1aXJlKFwiLi4vbG9kYXNoXCIpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGNvbXBvbmVudHM7XG5cbmZ1bmN0aW9uIGNvbXBvbmVudHMoZykge1xuICB2YXIgdmlzaXRlZCA9IHt9O1xuICB2YXIgY21wdHMgPSBbXTtcbiAgdmFyIGNtcHQ7XG5cbiAgZnVuY3Rpb24gZGZzKHYpIHtcbiAgICBpZiAoXy5oYXModmlzaXRlZCwgdikpIHJldHVybjtcbiAgICB2aXNpdGVkW3ZdID0gdHJ1ZTtcbiAgICBjbXB0LnB1c2godik7XG4gICAgXy5lYWNoKGcuc3VjY2Vzc29ycyh2KSwgZGZzKTtcbiAgICBfLmVhY2goZy5wcmVkZWNlc3NvcnModiksIGRmcyk7XG4gIH1cblxuICBfLmVhY2goZy5ub2RlcygpLCBmdW5jdGlvbih2KSB7XG4gICAgY21wdCA9IFtdO1xuICAgIGRmcyh2KTtcbiAgICBpZiAoY21wdC5sZW5ndGgpIHtcbiAgICAgIGNtcHRzLnB1c2goY21wdCk7XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gY21wdHM7XG59XG4iLCJ2YXIgXyA9IHJlcXVpcmUoXCIuLi9sb2Rhc2hcIik7XG5cbm1vZHVsZS5leHBvcnRzID0gZGZzO1xuXG4vKlxuICogQSBoZWxwZXIgdGhhdCBwcmVmb3JtcyBhIHByZS0gb3IgcG9zdC1vcmRlciB0cmF2ZXJzYWwgb24gdGhlIGlucHV0IGdyYXBoXG4gKiBhbmQgcmV0dXJucyB0aGUgbm9kZXMgaW4gdGhlIG9yZGVyIHRoZXkgd2VyZSB2aXNpdGVkLiBJZiB0aGUgZ3JhcGggaXNcbiAqIHVuZGlyZWN0ZWQgdGhlbiB0aGlzIGFsZ29yaXRobSB3aWxsIG5hdmlnYXRlIHVzaW5nIG5laWdoYm9ycy4gSWYgdGhlIGdyYXBoXG4gKiBpcyBkaXJlY3RlZCB0aGVuIHRoaXMgYWxnb3JpdGhtIHdpbGwgbmF2aWdhdGUgdXNpbmcgc3VjY2Vzc29ycy5cbiAqXG4gKiBPcmRlciBtdXN0IGJlIG9uZSBvZiBcInByZVwiIG9yIFwicG9zdFwiLlxuICovXG5mdW5jdGlvbiBkZnMoZywgdnMsIG9yZGVyKSB7XG4gIGlmICghXy5pc0FycmF5KHZzKSkge1xuICAgIHZzID0gW3ZzXTtcbiAgfVxuXG4gIHZhciBuYXZpZ2F0aW9uID0gKGcuaXNEaXJlY3RlZCgpID8gZy5zdWNjZXNzb3JzIDogZy5uZWlnaGJvcnMpLmJpbmQoZyk7XG5cbiAgdmFyIGFjYyA9IFtdO1xuICB2YXIgdmlzaXRlZCA9IHt9O1xuICBfLmVhY2godnMsIGZ1bmN0aW9uKHYpIHtcbiAgICBpZiAoIWcuaGFzTm9kZSh2KSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiR3JhcGggZG9lcyBub3QgaGF2ZSBub2RlOiBcIiArIHYpO1xuICAgIH1cblxuICAgIGRvRGZzKGcsIHYsIG9yZGVyID09PSBcInBvc3RcIiwgdmlzaXRlZCwgbmF2aWdhdGlvbiwgYWNjKTtcbiAgfSk7XG4gIHJldHVybiBhY2M7XG59XG5cbmZ1bmN0aW9uIGRvRGZzKGcsIHYsIHBvc3RvcmRlciwgdmlzaXRlZCwgbmF2aWdhdGlvbiwgYWNjKSB7XG4gIGlmICghXy5oYXModmlzaXRlZCwgdikpIHtcbiAgICB2aXNpdGVkW3ZdID0gdHJ1ZTtcblxuICAgIGlmICghcG9zdG9yZGVyKSB7IGFjYy5wdXNoKHYpOyB9XG4gICAgXy5lYWNoKG5hdmlnYXRpb24odiksIGZ1bmN0aW9uKHcpIHtcbiAgICAgIGRvRGZzKGcsIHcsIHBvc3RvcmRlciwgdmlzaXRlZCwgbmF2aWdhdGlvbiwgYWNjKTtcbiAgICB9KTtcbiAgICBpZiAocG9zdG9yZGVyKSB7IGFjYy5wdXNoKHYpOyB9XG4gIH1cbn1cbiIsInZhciBkaWprc3RyYSA9IHJlcXVpcmUoXCIuL2RpamtzdHJhXCIpO1xudmFyIF8gPSByZXF1aXJlKFwiLi4vbG9kYXNoXCIpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGRpamtzdHJhQWxsO1xuXG5mdW5jdGlvbiBkaWprc3RyYUFsbChnLCB3ZWlnaHRGdW5jLCBlZGdlRnVuYykge1xuICByZXR1cm4gXy50cmFuc2Zvcm0oZy5ub2RlcygpLCBmdW5jdGlvbihhY2MsIHYpIHtcbiAgICBhY2Nbdl0gPSBkaWprc3RyYShnLCB2LCB3ZWlnaHRGdW5jLCBlZGdlRnVuYyk7XG4gIH0sIHt9KTtcbn1cbiIsInZhciBfID0gcmVxdWlyZShcIi4uL2xvZGFzaFwiKTtcbnZhciBQcmlvcml0eVF1ZXVlID0gcmVxdWlyZShcIi4uL2RhdGEvcHJpb3JpdHktcXVldWVcIik7XG5cbm1vZHVsZS5leHBvcnRzID0gZGlqa3N0cmE7XG5cbnZhciBERUZBVUxUX1dFSUdIVF9GVU5DID0gXy5jb25zdGFudCgxKTtcblxuZnVuY3Rpb24gZGlqa3N0cmEoZywgc291cmNlLCB3ZWlnaHRGbiwgZWRnZUZuKSB7XG4gIHJldHVybiBydW5EaWprc3RyYShnLCBTdHJpbmcoc291cmNlKSxcbiAgICB3ZWlnaHRGbiB8fCBERUZBVUxUX1dFSUdIVF9GVU5DLFxuICAgIGVkZ2VGbiB8fCBmdW5jdGlvbih2KSB7IHJldHVybiBnLm91dEVkZ2VzKHYpOyB9KTtcbn1cblxuZnVuY3Rpb24gcnVuRGlqa3N0cmEoZywgc291cmNlLCB3ZWlnaHRGbiwgZWRnZUZuKSB7XG4gIHZhciByZXN1bHRzID0ge307XG4gIHZhciBwcSA9IG5ldyBQcmlvcml0eVF1ZXVlKCk7XG4gIHZhciB2LCB2RW50cnk7XG5cbiAgdmFyIHVwZGF0ZU5laWdoYm9ycyA9IGZ1bmN0aW9uKGVkZ2UpIHtcbiAgICB2YXIgdyA9IGVkZ2UudiAhPT0gdiA/IGVkZ2UudiA6IGVkZ2UudztcbiAgICB2YXIgd0VudHJ5ID0gcmVzdWx0c1t3XTtcbiAgICB2YXIgd2VpZ2h0ID0gd2VpZ2h0Rm4oZWRnZSk7XG4gICAgdmFyIGRpc3RhbmNlID0gdkVudHJ5LmRpc3RhbmNlICsgd2VpZ2h0O1xuXG4gICAgaWYgKHdlaWdodCA8IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcImRpamtzdHJhIGRvZXMgbm90IGFsbG93IG5lZ2F0aXZlIGVkZ2Ugd2VpZ2h0cy4gXCIgK1xuICAgICAgICAgICAgICAgICAgICAgIFwiQmFkIGVkZ2U6IFwiICsgZWRnZSArIFwiIFdlaWdodDogXCIgKyB3ZWlnaHQpO1xuICAgIH1cblxuICAgIGlmIChkaXN0YW5jZSA8IHdFbnRyeS5kaXN0YW5jZSkge1xuICAgICAgd0VudHJ5LmRpc3RhbmNlID0gZGlzdGFuY2U7XG4gICAgICB3RW50cnkucHJlZGVjZXNzb3IgPSB2O1xuICAgICAgcHEuZGVjcmVhc2UodywgZGlzdGFuY2UpO1xuICAgIH1cbiAgfTtcblxuICBnLm5vZGVzKCkuZm9yRWFjaChmdW5jdGlvbih2KSB7XG4gICAgdmFyIGRpc3RhbmNlID0gdiA9PT0gc291cmNlID8gMCA6IE51bWJlci5QT1NJVElWRV9JTkZJTklUWTtcbiAgICByZXN1bHRzW3ZdID0geyBkaXN0YW5jZTogZGlzdGFuY2UgfTtcbiAgICBwcS5hZGQodiwgZGlzdGFuY2UpO1xuICB9KTtcblxuICB3aGlsZSAocHEuc2l6ZSgpID4gMCkge1xuICAgIHYgPSBwcS5yZW1vdmVNaW4oKTtcbiAgICB2RW50cnkgPSByZXN1bHRzW3ZdO1xuICAgIGlmICh2RW50cnkuZGlzdGFuY2UgPT09IE51bWJlci5QT1NJVElWRV9JTkZJTklUWSkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgZWRnZUZuKHYpLmZvckVhY2godXBkYXRlTmVpZ2hib3JzKTtcbiAgfVxuXG4gIHJldHVybiByZXN1bHRzO1xufVxuIiwidmFyIF8gPSByZXF1aXJlKFwiLi4vbG9kYXNoXCIpO1xudmFyIHRhcmphbiA9IHJlcXVpcmUoXCIuL3RhcmphblwiKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmaW5kQ3ljbGVzO1xuXG5mdW5jdGlvbiBmaW5kQ3ljbGVzKGcpIHtcbiAgcmV0dXJuIF8uZmlsdGVyKHRhcmphbihnKSwgZnVuY3Rpb24oY21wdCkge1xuICAgIHJldHVybiBjbXB0Lmxlbmd0aCA+IDEgfHwgKGNtcHQubGVuZ3RoID09PSAxICYmIGcuaGFzRWRnZShjbXB0WzBdLCBjbXB0WzBdKSk7XG4gIH0pO1xufVxuIiwidmFyIF8gPSByZXF1aXJlKFwiLi4vbG9kYXNoXCIpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZsb3lkV2Fyc2hhbGw7XG5cbnZhciBERUZBVUxUX1dFSUdIVF9GVU5DID0gXy5jb25zdGFudCgxKTtcblxuZnVuY3Rpb24gZmxveWRXYXJzaGFsbChnLCB3ZWlnaHRGbiwgZWRnZUZuKSB7XG4gIHJldHVybiBydW5GbG95ZFdhcnNoYWxsKGcsXG4gICAgd2VpZ2h0Rm4gfHwgREVGQVVMVF9XRUlHSFRfRlVOQyxcbiAgICBlZGdlRm4gfHwgZnVuY3Rpb24odikgeyByZXR1cm4gZy5vdXRFZGdlcyh2KTsgfSk7XG59XG5cbmZ1bmN0aW9uIHJ1bkZsb3lkV2Fyc2hhbGwoZywgd2VpZ2h0Rm4sIGVkZ2VGbikge1xuICB2YXIgcmVzdWx0cyA9IHt9O1xuICB2YXIgbm9kZXMgPSBnLm5vZGVzKCk7XG5cbiAgbm9kZXMuZm9yRWFjaChmdW5jdGlvbih2KSB7XG4gICAgcmVzdWx0c1t2XSA9IHt9O1xuICAgIHJlc3VsdHNbdl1bdl0gPSB7IGRpc3RhbmNlOiAwIH07XG4gICAgbm9kZXMuZm9yRWFjaChmdW5jdGlvbih3KSB7XG4gICAgICBpZiAodiAhPT0gdykge1xuICAgICAgICByZXN1bHRzW3ZdW3ddID0geyBkaXN0YW5jZTogTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZIH07XG4gICAgICB9XG4gICAgfSk7XG4gICAgZWRnZUZuKHYpLmZvckVhY2goZnVuY3Rpb24oZWRnZSkge1xuICAgICAgdmFyIHcgPSBlZGdlLnYgPT09IHYgPyBlZGdlLncgOiBlZGdlLnY7XG4gICAgICB2YXIgZCA9IHdlaWdodEZuKGVkZ2UpO1xuICAgICAgcmVzdWx0c1t2XVt3XSA9IHsgZGlzdGFuY2U6IGQsIHByZWRlY2Vzc29yOiB2IH07XG4gICAgfSk7XG4gIH0pO1xuXG4gIG5vZGVzLmZvckVhY2goZnVuY3Rpb24oaykge1xuICAgIHZhciByb3dLID0gcmVzdWx0c1trXTtcbiAgICBub2Rlcy5mb3JFYWNoKGZ1bmN0aW9uKGkpIHtcbiAgICAgIHZhciByb3dJID0gcmVzdWx0c1tpXTtcbiAgICAgIG5vZGVzLmZvckVhY2goZnVuY3Rpb24oaikge1xuICAgICAgICB2YXIgaWsgPSByb3dJW2tdO1xuICAgICAgICB2YXIga2ogPSByb3dLW2pdO1xuICAgICAgICB2YXIgaWogPSByb3dJW2pdO1xuICAgICAgICB2YXIgYWx0RGlzdGFuY2UgPSBpay5kaXN0YW5jZSArIGtqLmRpc3RhbmNlO1xuICAgICAgICBpZiAoYWx0RGlzdGFuY2UgPCBpai5kaXN0YW5jZSkge1xuICAgICAgICAgIGlqLmRpc3RhbmNlID0gYWx0RGlzdGFuY2U7XG4gICAgICAgICAgaWoucHJlZGVjZXNzb3IgPSBrai5wcmVkZWNlc3NvcjtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIHJldHVybiByZXN1bHRzO1xufVxuIiwibW9kdWxlLmV4cG9ydHMgPSB7XG4gIGNvbXBvbmVudHM6IHJlcXVpcmUoXCIuL2NvbXBvbmVudHNcIiksXG4gIGRpamtzdHJhOiByZXF1aXJlKFwiLi9kaWprc3RyYVwiKSxcbiAgZGlqa3N0cmFBbGw6IHJlcXVpcmUoXCIuL2RpamtzdHJhLWFsbFwiKSxcbiAgZmluZEN5Y2xlczogcmVxdWlyZShcIi4vZmluZC1jeWNsZXNcIiksXG4gIGZsb3lkV2Fyc2hhbGw6IHJlcXVpcmUoXCIuL2Zsb3lkLXdhcnNoYWxsXCIpLFxuICBpc0FjeWNsaWM6IHJlcXVpcmUoXCIuL2lzLWFjeWNsaWNcIiksXG4gIHBvc3RvcmRlcjogcmVxdWlyZShcIi4vcG9zdG9yZGVyXCIpLFxuICBwcmVvcmRlcjogcmVxdWlyZShcIi4vcHJlb3JkZXJcIiksXG4gIHByaW06IHJlcXVpcmUoXCIuL3ByaW1cIiksXG4gIHRhcmphbjogcmVxdWlyZShcIi4vdGFyamFuXCIpLFxuICB0b3Bzb3J0OiByZXF1aXJlKFwiLi90b3Bzb3J0XCIpXG59O1xuIiwidmFyIHRvcHNvcnQgPSByZXF1aXJlKFwiLi90b3Bzb3J0XCIpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGlzQWN5Y2xpYztcblxuZnVuY3Rpb24gaXNBY3ljbGljKGcpIHtcbiAgdHJ5IHtcbiAgICB0b3Bzb3J0KGcpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgaWYgKGUgaW5zdGFuY2VvZiB0b3Bzb3J0LkN5Y2xlRXhjZXB0aW9uKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHRocm93IGU7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG4iLCJ2YXIgZGZzID0gcmVxdWlyZShcIi4vZGZzXCIpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHBvc3RvcmRlcjtcblxuZnVuY3Rpb24gcG9zdG9yZGVyKGcsIHZzKSB7XG4gIHJldHVybiBkZnMoZywgdnMsIFwicG9zdFwiKTtcbn1cbiIsInZhciBkZnMgPSByZXF1aXJlKFwiLi9kZnNcIik7XG5cbm1vZHVsZS5leHBvcnRzID0gcHJlb3JkZXI7XG5cbmZ1bmN0aW9uIHByZW9yZGVyKGcsIHZzKSB7XG4gIHJldHVybiBkZnMoZywgdnMsIFwicHJlXCIpO1xufVxuIiwidmFyIF8gPSByZXF1aXJlKFwiLi4vbG9kYXNoXCIpO1xudmFyIEdyYXBoID0gcmVxdWlyZShcIi4uL2dyYXBoXCIpO1xudmFyIFByaW9yaXR5UXVldWUgPSByZXF1aXJlKFwiLi4vZGF0YS9wcmlvcml0eS1xdWV1ZVwiKTtcblxubW9kdWxlLmV4cG9ydHMgPSBwcmltO1xuXG5mdW5jdGlvbiBwcmltKGcsIHdlaWdodEZ1bmMpIHtcbiAgdmFyIHJlc3VsdCA9IG5ldyBHcmFwaCgpO1xuICB2YXIgcGFyZW50cyA9IHt9O1xuICB2YXIgcHEgPSBuZXcgUHJpb3JpdHlRdWV1ZSgpO1xuICB2YXIgdjtcblxuICBmdW5jdGlvbiB1cGRhdGVOZWlnaGJvcnMoZWRnZSkge1xuICAgIHZhciB3ID0gZWRnZS52ID09PSB2ID8gZWRnZS53IDogZWRnZS52O1xuICAgIHZhciBwcmkgPSBwcS5wcmlvcml0eSh3KTtcbiAgICBpZiAocHJpICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHZhciBlZGdlV2VpZ2h0ID0gd2VpZ2h0RnVuYyhlZGdlKTtcbiAgICAgIGlmIChlZGdlV2VpZ2h0IDwgcHJpKSB7XG4gICAgICAgIHBhcmVudHNbd10gPSB2O1xuICAgICAgICBwcS5kZWNyZWFzZSh3LCBlZGdlV2VpZ2h0KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAoZy5ub2RlQ291bnQoKSA9PT0gMCkge1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBfLmVhY2goZy5ub2RlcygpLCBmdW5jdGlvbih2KSB7XG4gICAgcHEuYWRkKHYsIE51bWJlci5QT1NJVElWRV9JTkZJTklUWSk7XG4gICAgcmVzdWx0LnNldE5vZGUodik7XG4gIH0pO1xuXG4gIC8vIFN0YXJ0IGZyb20gYW4gYXJiaXRyYXJ5IG5vZGVcbiAgcHEuZGVjcmVhc2UoZy5ub2RlcygpWzBdLCAwKTtcblxuICB2YXIgaW5pdCA9IGZhbHNlO1xuICB3aGlsZSAocHEuc2l6ZSgpID4gMCkge1xuICAgIHYgPSBwcS5yZW1vdmVNaW4oKTtcbiAgICBpZiAoXy5oYXMocGFyZW50cywgdikpIHtcbiAgICAgIHJlc3VsdC5zZXRFZGdlKHYsIHBhcmVudHNbdl0pO1xuICAgIH0gZWxzZSBpZiAoaW5pdCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW5wdXQgZ3JhcGggaXMgbm90IGNvbm5lY3RlZDogXCIgKyBnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaW5pdCA9IHRydWU7XG4gICAgfVxuXG4gICAgZy5ub2RlRWRnZXModikuZm9yRWFjaCh1cGRhdGVOZWlnaGJvcnMpO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cbiIsInZhciBfID0gcmVxdWlyZShcIi4uL2xvZGFzaFwiKTtcblxubW9kdWxlLmV4cG9ydHMgPSB0YXJqYW47XG5cbmZ1bmN0aW9uIHRhcmphbihnKSB7XG4gIHZhciBpbmRleCA9IDA7XG4gIHZhciBzdGFjayA9IFtdO1xuICB2YXIgdmlzaXRlZCA9IHt9OyAvLyBub2RlIGlkIC0+IHsgb25TdGFjaywgbG93bGluaywgaW5kZXggfVxuICB2YXIgcmVzdWx0cyA9IFtdO1xuXG4gIGZ1bmN0aW9uIGRmcyh2KSB7XG4gICAgdmFyIGVudHJ5ID0gdmlzaXRlZFt2XSA9IHtcbiAgICAgIG9uU3RhY2s6IHRydWUsXG4gICAgICBsb3dsaW5rOiBpbmRleCxcbiAgICAgIGluZGV4OiBpbmRleCsrXG4gICAgfTtcbiAgICBzdGFjay5wdXNoKHYpO1xuXG4gICAgZy5zdWNjZXNzb3JzKHYpLmZvckVhY2goZnVuY3Rpb24odykge1xuICAgICAgaWYgKCFfLmhhcyh2aXNpdGVkLCB3KSkge1xuICAgICAgICBkZnModyk7XG4gICAgICAgIGVudHJ5Lmxvd2xpbmsgPSBNYXRoLm1pbihlbnRyeS5sb3dsaW5rLCB2aXNpdGVkW3ddLmxvd2xpbmspO1xuICAgICAgfSBlbHNlIGlmICh2aXNpdGVkW3ddLm9uU3RhY2spIHtcbiAgICAgICAgZW50cnkubG93bGluayA9IE1hdGgubWluKGVudHJ5Lmxvd2xpbmssIHZpc2l0ZWRbd10uaW5kZXgpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgaWYgKGVudHJ5Lmxvd2xpbmsgPT09IGVudHJ5LmluZGV4KSB7XG4gICAgICB2YXIgY21wdCA9IFtdO1xuICAgICAgdmFyIHc7XG4gICAgICBkbyB7XG4gICAgICAgIHcgPSBzdGFjay5wb3AoKTtcbiAgICAgICAgdmlzaXRlZFt3XS5vblN0YWNrID0gZmFsc2U7XG4gICAgICAgIGNtcHQucHVzaCh3KTtcbiAgICAgIH0gd2hpbGUgKHYgIT09IHcpO1xuICAgICAgcmVzdWx0cy5wdXNoKGNtcHQpO1xuICAgIH1cbiAgfVxuXG4gIGcubm9kZXMoKS5mb3JFYWNoKGZ1bmN0aW9uKHYpIHtcbiAgICBpZiAoIV8uaGFzKHZpc2l0ZWQsIHYpKSB7XG4gICAgICBkZnModik7XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gcmVzdWx0cztcbn1cbiIsInZhciBfID0gcmVxdWlyZShcIi4uL2xvZGFzaFwiKTtcblxubW9kdWxlLmV4cG9ydHMgPSB0b3Bzb3J0O1xudG9wc29ydC5DeWNsZUV4Y2VwdGlvbiA9IEN5Y2xlRXhjZXB0aW9uO1xuXG5mdW5jdGlvbiB0b3Bzb3J0KGcpIHtcbiAgdmFyIHZpc2l0ZWQgPSB7fTtcbiAgdmFyIHN0YWNrID0ge307XG4gIHZhciByZXN1bHRzID0gW107XG5cbiAgZnVuY3Rpb24gdmlzaXQobm9kZSkge1xuICAgIGlmIChfLmhhcyhzdGFjaywgbm9kZSkpIHtcbiAgICAgIHRocm93IG5ldyBDeWNsZUV4Y2VwdGlvbigpO1xuICAgIH1cblxuICAgIGlmICghXy5oYXModmlzaXRlZCwgbm9kZSkpIHtcbiAgICAgIHN0YWNrW25vZGVdID0gdHJ1ZTtcbiAgICAgIHZpc2l0ZWRbbm9kZV0gPSB0cnVlO1xuICAgICAgXy5lYWNoKGcucHJlZGVjZXNzb3JzKG5vZGUpLCB2aXNpdCk7XG4gICAgICBkZWxldGUgc3RhY2tbbm9kZV07XG4gICAgICByZXN1bHRzLnB1c2gobm9kZSk7XG4gICAgfVxuICB9XG5cbiAgXy5lYWNoKGcuc2lua3MoKSwgdmlzaXQpO1xuXG4gIGlmIChfLnNpemUodmlzaXRlZCkgIT09IGcubm9kZUNvdW50KCkpIHtcbiAgICB0aHJvdyBuZXcgQ3ljbGVFeGNlcHRpb24oKTtcbiAgfVxuXG4gIHJldHVybiByZXN1bHRzO1xufVxuXG5mdW5jdGlvbiBDeWNsZUV4Y2VwdGlvbigpIHt9XG5DeWNsZUV4Y2VwdGlvbi5wcm90b3R5cGUgPSBuZXcgRXJyb3IoKTsgLy8gbXVzdCBiZSBhbiBpbnN0YW5jZSBvZiBFcnJvciB0byBwYXNzIHRlc3RpbmciLCJ2YXIgXyA9IHJlcXVpcmUoXCIuLi9sb2Rhc2hcIik7XG5cbm1vZHVsZS5leHBvcnRzID0gUHJpb3JpdHlRdWV1ZTtcblxuLyoqXG4gKiBBIG1pbi1wcmlvcml0eSBxdWV1ZSBkYXRhIHN0cnVjdHVyZS4gVGhpcyBhbGdvcml0aG0gaXMgZGVyaXZlZCBmcm9tIENvcm1lbixcbiAqIGV0IGFsLiwgXCJJbnRyb2R1Y3Rpb24gdG8gQWxnb3JpdGhtc1wiLiBUaGUgYmFzaWMgaWRlYSBvZiBhIG1pbi1wcmlvcml0eVxuICogcXVldWUgaXMgdGhhdCB5b3UgY2FuIGVmZmljaWVudGx5IChpbiBPKDEpIHRpbWUpIGdldCB0aGUgc21hbGxlc3Qga2V5IGluXG4gKiB0aGUgcXVldWUuIEFkZGluZyBhbmQgcmVtb3ZpbmcgZWxlbWVudHMgdGFrZXMgTyhsb2cgbikgdGltZS4gQSBrZXkgY2FuXG4gKiBoYXZlIGl0cyBwcmlvcml0eSBkZWNyZWFzZWQgaW4gTyhsb2cgbikgdGltZS5cbiAqL1xuZnVuY3Rpb24gUHJpb3JpdHlRdWV1ZSgpIHtcbiAgdGhpcy5fYXJyID0gW107XG4gIHRoaXMuX2tleUluZGljZXMgPSB7fTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBudW1iZXIgb2YgZWxlbWVudHMgaW4gdGhlIHF1ZXVlLiBUYWtlcyBgTygxKWAgdGltZS5cbiAqL1xuUHJpb3JpdHlRdWV1ZS5wcm90b3R5cGUuc2l6ZSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5fYXJyLmxlbmd0aDtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGUga2V5cyB0aGF0IGFyZSBpbiB0aGUgcXVldWUuIFRha2VzIGBPKG4pYCB0aW1lLlxuICovXG5Qcmlvcml0eVF1ZXVlLnByb3RvdHlwZS5rZXlzID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLl9hcnIubWFwKGZ1bmN0aW9uKHgpIHsgcmV0dXJuIHgua2V5OyB9KTtcbn07XG5cbi8qKlxuICogUmV0dXJucyBgdHJ1ZWAgaWYgKiprZXkqKiBpcyBpbiB0aGUgcXVldWUgYW5kIGBmYWxzZWAgaWYgbm90LlxuICovXG5Qcmlvcml0eVF1ZXVlLnByb3RvdHlwZS5oYXMgPSBmdW5jdGlvbihrZXkpIHtcbiAgcmV0dXJuIF8uaGFzKHRoaXMuX2tleUluZGljZXMsIGtleSk7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIHByaW9yaXR5IGZvciAqKmtleSoqLiBJZiAqKmtleSoqIGlzIG5vdCBwcmVzZW50IGluIHRoZSBxdWV1ZVxuICogdGhlbiB0aGlzIGZ1bmN0aW9uIHJldHVybnMgYHVuZGVmaW5lZGAuIFRha2VzIGBPKDEpYCB0aW1lLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBrZXlcbiAqL1xuUHJpb3JpdHlRdWV1ZS5wcm90b3R5cGUucHJpb3JpdHkgPSBmdW5jdGlvbihrZXkpIHtcbiAgdmFyIGluZGV4ID0gdGhpcy5fa2V5SW5kaWNlc1trZXldO1xuICBpZiAoaW5kZXggIT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiB0aGlzLl9hcnJbaW5kZXhdLnByaW9yaXR5O1xuICB9XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIGtleSBmb3IgdGhlIG1pbmltdW0gZWxlbWVudCBpbiB0aGlzIHF1ZXVlLiBJZiB0aGUgcXVldWUgaXNcbiAqIGVtcHR5IHRoaXMgZnVuY3Rpb24gdGhyb3dzIGFuIEVycm9yLiBUYWtlcyBgTygxKWAgdGltZS5cbiAqL1xuUHJpb3JpdHlRdWV1ZS5wcm90b3R5cGUubWluID0gZnVuY3Rpb24oKSB7XG4gIGlmICh0aGlzLnNpemUoKSA9PT0gMCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIlF1ZXVlIHVuZGVyZmxvd1wiKTtcbiAgfVxuICByZXR1cm4gdGhpcy5fYXJyWzBdLmtleTtcbn07XG5cbi8qKlxuICogSW5zZXJ0cyBhIG5ldyBrZXkgaW50byB0aGUgcHJpb3JpdHkgcXVldWUuIElmIHRoZSBrZXkgYWxyZWFkeSBleGlzdHMgaW5cbiAqIHRoZSBxdWV1ZSB0aGlzIGZ1bmN0aW9uIHJldHVybnMgYGZhbHNlYDsgb3RoZXJ3aXNlIGl0IHdpbGwgcmV0dXJuIGB0cnVlYC5cbiAqIFRha2VzIGBPKG4pYCB0aW1lLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBrZXkgdGhlIGtleSB0byBhZGRcbiAqIEBwYXJhbSB7TnVtYmVyfSBwcmlvcml0eSB0aGUgaW5pdGlhbCBwcmlvcml0eSBmb3IgdGhlIGtleVxuICovXG5Qcmlvcml0eVF1ZXVlLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbihrZXksIHByaW9yaXR5KSB7XG4gIHZhciBrZXlJbmRpY2VzID0gdGhpcy5fa2V5SW5kaWNlcztcbiAga2V5ID0gU3RyaW5nKGtleSk7XG4gIGlmICghXy5oYXMoa2V5SW5kaWNlcywga2V5KSkge1xuICAgIHZhciBhcnIgPSB0aGlzLl9hcnI7XG4gICAgdmFyIGluZGV4ID0gYXJyLmxlbmd0aDtcbiAgICBrZXlJbmRpY2VzW2tleV0gPSBpbmRleDtcbiAgICBhcnIucHVzaCh7a2V5OiBrZXksIHByaW9yaXR5OiBwcmlvcml0eX0pO1xuICAgIHRoaXMuX2RlY3JlYXNlKGluZGV4KTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59O1xuXG4vKipcbiAqIFJlbW92ZXMgYW5kIHJldHVybnMgdGhlIHNtYWxsZXN0IGtleSBpbiB0aGUgcXVldWUuIFRha2VzIGBPKGxvZyBuKWAgdGltZS5cbiAqL1xuUHJpb3JpdHlRdWV1ZS5wcm90b3R5cGUucmVtb3ZlTWluID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuX3N3YXAoMCwgdGhpcy5fYXJyLmxlbmd0aCAtIDEpO1xuICB2YXIgbWluID0gdGhpcy5fYXJyLnBvcCgpO1xuICBkZWxldGUgdGhpcy5fa2V5SW5kaWNlc1ttaW4ua2V5XTtcbiAgdGhpcy5faGVhcGlmeSgwKTtcbiAgcmV0dXJuIG1pbi5rZXk7XG59O1xuXG4vKipcbiAqIERlY3JlYXNlcyB0aGUgcHJpb3JpdHkgZm9yICoqa2V5KiogdG8gKipwcmlvcml0eSoqLiBJZiB0aGUgbmV3IHByaW9yaXR5IGlzXG4gKiBncmVhdGVyIHRoYW4gdGhlIHByZXZpb3VzIHByaW9yaXR5LCB0aGlzIGZ1bmN0aW9uIHdpbGwgdGhyb3cgYW4gRXJyb3IuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGtleSB0aGUga2V5IGZvciB3aGljaCB0byByYWlzZSBwcmlvcml0eVxuICogQHBhcmFtIHtOdW1iZXJ9IHByaW9yaXR5IHRoZSBuZXcgcHJpb3JpdHkgZm9yIHRoZSBrZXlcbiAqL1xuUHJpb3JpdHlRdWV1ZS5wcm90b3R5cGUuZGVjcmVhc2UgPSBmdW5jdGlvbihrZXksIHByaW9yaXR5KSB7XG4gIHZhciBpbmRleCA9IHRoaXMuX2tleUluZGljZXNba2V5XTtcbiAgaWYgKHByaW9yaXR5ID4gdGhpcy5fYXJyW2luZGV4XS5wcmlvcml0eSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIk5ldyBwcmlvcml0eSBpcyBncmVhdGVyIHRoYW4gY3VycmVudCBwcmlvcml0eS4gXCIgK1xuICAgICAgICBcIktleTogXCIgKyBrZXkgKyBcIiBPbGQ6IFwiICsgdGhpcy5fYXJyW2luZGV4XS5wcmlvcml0eSArIFwiIE5ldzogXCIgKyBwcmlvcml0eSk7XG4gIH1cbiAgdGhpcy5fYXJyW2luZGV4XS5wcmlvcml0eSA9IHByaW9yaXR5O1xuICB0aGlzLl9kZWNyZWFzZShpbmRleCk7XG59O1xuXG5Qcmlvcml0eVF1ZXVlLnByb3RvdHlwZS5faGVhcGlmeSA9IGZ1bmN0aW9uKGkpIHtcbiAgdmFyIGFyciA9IHRoaXMuX2FycjtcbiAgdmFyIGwgPSAyICogaTtcbiAgdmFyIHIgPSBsICsgMTtcbiAgdmFyIGxhcmdlc3QgPSBpO1xuICBpZiAobCA8IGFyci5sZW5ndGgpIHtcbiAgICBsYXJnZXN0ID0gYXJyW2xdLnByaW9yaXR5IDwgYXJyW2xhcmdlc3RdLnByaW9yaXR5ID8gbCA6IGxhcmdlc3Q7XG4gICAgaWYgKHIgPCBhcnIubGVuZ3RoKSB7XG4gICAgICBsYXJnZXN0ID0gYXJyW3JdLnByaW9yaXR5IDwgYXJyW2xhcmdlc3RdLnByaW9yaXR5ID8gciA6IGxhcmdlc3Q7XG4gICAgfVxuICAgIGlmIChsYXJnZXN0ICE9PSBpKSB7XG4gICAgICB0aGlzLl9zd2FwKGksIGxhcmdlc3QpO1xuICAgICAgdGhpcy5faGVhcGlmeShsYXJnZXN0KTtcbiAgICB9XG4gIH1cbn07XG5cblByaW9yaXR5UXVldWUucHJvdG90eXBlLl9kZWNyZWFzZSA9IGZ1bmN0aW9uKGluZGV4KSB7XG4gIHZhciBhcnIgPSB0aGlzLl9hcnI7XG4gIHZhciBwcmlvcml0eSA9IGFycltpbmRleF0ucHJpb3JpdHk7XG4gIHZhciBwYXJlbnQ7XG4gIHdoaWxlIChpbmRleCAhPT0gMCkge1xuICAgIHBhcmVudCA9IGluZGV4ID4+IDE7XG4gICAgaWYgKGFycltwYXJlbnRdLnByaW9yaXR5IDwgcHJpb3JpdHkpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICB0aGlzLl9zd2FwKGluZGV4LCBwYXJlbnQpO1xuICAgIGluZGV4ID0gcGFyZW50O1xuICB9XG59O1xuXG5Qcmlvcml0eVF1ZXVlLnByb3RvdHlwZS5fc3dhcCA9IGZ1bmN0aW9uKGksIGopIHtcbiAgdmFyIGFyciA9IHRoaXMuX2FycjtcbiAgdmFyIGtleUluZGljZXMgPSB0aGlzLl9rZXlJbmRpY2VzO1xuICB2YXIgb3JpZ0FyckkgPSBhcnJbaV07XG4gIHZhciBvcmlnQXJySiA9IGFycltqXTtcbiAgYXJyW2ldID0gb3JpZ0Fycko7XG4gIGFycltqXSA9IG9yaWdBcnJJO1xuICBrZXlJbmRpY2VzW29yaWdBcnJKLmtleV0gPSBpO1xuICBrZXlJbmRpY2VzW29yaWdBcnJJLmtleV0gPSBqO1xufTtcbiIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgXyA9IHJlcXVpcmUoXCIuL2xvZGFzaFwiKTtcblxubW9kdWxlLmV4cG9ydHMgPSBHcmFwaDtcblxudmFyIERFRkFVTFRfRURHRV9OQU1FID0gXCJcXHgwMFwiO1xudmFyIEdSQVBIX05PREUgPSBcIlxceDAwXCI7XG52YXIgRURHRV9LRVlfREVMSU0gPSBcIlxceDAxXCI7XG5cbi8vIEltcGxlbWVudGF0aW9uIG5vdGVzOlxuLy9cbi8vICAqIE5vZGUgaWQgcXVlcnkgZnVuY3Rpb25zIHNob3VsZCByZXR1cm4gc3RyaW5nIGlkcyBmb3IgdGhlIG5vZGVzXG4vLyAgKiBFZGdlIGlkIHF1ZXJ5IGZ1bmN0aW9ucyBzaG91bGQgcmV0dXJuIGFuIFwiZWRnZU9ialwiLCBlZGdlIG9iamVjdCwgdGhhdCBpc1xuLy8gICAgY29tcG9zZWQgb2YgZW5vdWdoIGluZm9ybWF0aW9uIHRvIHVuaXF1ZWx5IGlkZW50aWZ5IGFuIGVkZ2U6IHt2LCB3LCBuYW1lfS5cbi8vICAqIEludGVybmFsbHkgd2UgdXNlIGFuIFwiZWRnZUlkXCIsIGEgc3RyaW5naWZpZWQgZm9ybSBvZiB0aGUgZWRnZU9iaiwgdG9cbi8vICAgIHJlZmVyZW5jZSBlZGdlcy4gVGhpcyBpcyBiZWNhdXNlIHdlIG5lZWQgYSBwZXJmb3JtYW50IHdheSB0byBsb29rIHRoZXNlXG4vLyAgICBlZGdlcyB1cCBhbmQsIG9iamVjdCBwcm9wZXJ0aWVzLCB3aGljaCBoYXZlIHN0cmluZyBrZXlzLCBhcmUgdGhlIGNsb3Nlc3Rcbi8vICAgIHdlJ3JlIGdvaW5nIHRvIGdldCB0byBhIHBlcmZvcm1hbnQgaGFzaHRhYmxlIGluIEphdmFTY3JpcHQuXG5cbmZ1bmN0aW9uIEdyYXBoKG9wdHMpIHtcbiAgdGhpcy5faXNEaXJlY3RlZCA9IF8uaGFzKG9wdHMsIFwiZGlyZWN0ZWRcIikgPyBvcHRzLmRpcmVjdGVkIDogdHJ1ZTtcbiAgdGhpcy5faXNNdWx0aWdyYXBoID0gXy5oYXMob3B0cywgXCJtdWx0aWdyYXBoXCIpID8gb3B0cy5tdWx0aWdyYXBoIDogZmFsc2U7XG4gIHRoaXMuX2lzQ29tcG91bmQgPSBfLmhhcyhvcHRzLCBcImNvbXBvdW5kXCIpID8gb3B0cy5jb21wb3VuZCA6IGZhbHNlO1xuXG4gIC8vIExhYmVsIGZvciB0aGUgZ3JhcGggaXRzZWxmXG4gIHRoaXMuX2xhYmVsID0gdW5kZWZpbmVkO1xuXG4gIC8vIERlZmF1bHRzIHRvIGJlIHNldCB3aGVuIGNyZWF0aW5nIGEgbmV3IG5vZGVcbiAgdGhpcy5fZGVmYXVsdE5vZGVMYWJlbEZuID0gXy5jb25zdGFudCh1bmRlZmluZWQpO1xuXG4gIC8vIERlZmF1bHRzIHRvIGJlIHNldCB3aGVuIGNyZWF0aW5nIGEgbmV3IGVkZ2VcbiAgdGhpcy5fZGVmYXVsdEVkZ2VMYWJlbEZuID0gXy5jb25zdGFudCh1bmRlZmluZWQpO1xuXG4gIC8vIHYgLT4gbGFiZWxcbiAgdGhpcy5fbm9kZXMgPSB7fTtcblxuICBpZiAodGhpcy5faXNDb21wb3VuZCkge1xuICAgIC8vIHYgLT4gcGFyZW50XG4gICAgdGhpcy5fcGFyZW50ID0ge307XG5cbiAgICAvLyB2IC0+IGNoaWxkcmVuXG4gICAgdGhpcy5fY2hpbGRyZW4gPSB7fTtcbiAgICB0aGlzLl9jaGlsZHJlbltHUkFQSF9OT0RFXSA9IHt9O1xuICB9XG5cbiAgLy8gdiAtPiBlZGdlT2JqXG4gIHRoaXMuX2luID0ge307XG5cbiAgLy8gdSAtPiB2IC0+IE51bWJlclxuICB0aGlzLl9wcmVkcyA9IHt9O1xuXG4gIC8vIHYgLT4gZWRnZU9ialxuICB0aGlzLl9vdXQgPSB7fTtcblxuICAvLyB2IC0+IHcgLT4gTnVtYmVyXG4gIHRoaXMuX3N1Y3MgPSB7fTtcblxuICAvLyBlIC0+IGVkZ2VPYmpcbiAgdGhpcy5fZWRnZU9ianMgPSB7fTtcblxuICAvLyBlIC0+IGxhYmVsXG4gIHRoaXMuX2VkZ2VMYWJlbHMgPSB7fTtcbn1cblxuLyogTnVtYmVyIG9mIG5vZGVzIGluIHRoZSBncmFwaC4gU2hvdWxkIG9ubHkgYmUgY2hhbmdlZCBieSB0aGUgaW1wbGVtZW50YXRpb24uICovXG5HcmFwaC5wcm90b3R5cGUuX25vZGVDb3VudCA9IDA7XG5cbi8qIE51bWJlciBvZiBlZGdlcyBpbiB0aGUgZ3JhcGguIFNob3VsZCBvbmx5IGJlIGNoYW5nZWQgYnkgdGhlIGltcGxlbWVudGF0aW9uLiAqL1xuR3JhcGgucHJvdG90eXBlLl9lZGdlQ291bnQgPSAwO1xuXG5cbi8qID09PSBHcmFwaCBmdW5jdGlvbnMgPT09PT09PT09ICovXG5cbkdyYXBoLnByb3RvdHlwZS5pc0RpcmVjdGVkID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLl9pc0RpcmVjdGVkO1xufTtcblxuR3JhcGgucHJvdG90eXBlLmlzTXVsdGlncmFwaCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5faXNNdWx0aWdyYXBoO1xufTtcblxuR3JhcGgucHJvdG90eXBlLmlzQ29tcG91bmQgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuX2lzQ29tcG91bmQ7XG59O1xuXG5HcmFwaC5wcm90b3R5cGUuc2V0R3JhcGggPSBmdW5jdGlvbihsYWJlbCkge1xuICB0aGlzLl9sYWJlbCA9IGxhYmVsO1xuICByZXR1cm4gdGhpcztcbn07XG5cbkdyYXBoLnByb3RvdHlwZS5ncmFwaCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5fbGFiZWw7XG59O1xuXG5cbi8qID09PSBOb2RlIGZ1bmN0aW9ucyA9PT09PT09PT09ICovXG5cbkdyYXBoLnByb3RvdHlwZS5zZXREZWZhdWx0Tm9kZUxhYmVsID0gZnVuY3Rpb24obmV3RGVmYXVsdCkge1xuICBpZiAoIV8uaXNGdW5jdGlvbihuZXdEZWZhdWx0KSkge1xuICAgIG5ld0RlZmF1bHQgPSBfLmNvbnN0YW50KG5ld0RlZmF1bHQpO1xuICB9XG4gIHRoaXMuX2RlZmF1bHROb2RlTGFiZWxGbiA9IG5ld0RlZmF1bHQ7XG4gIHJldHVybiB0aGlzO1xufTtcblxuR3JhcGgucHJvdG90eXBlLm5vZGVDb3VudCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5fbm9kZUNvdW50O1xufTtcblxuR3JhcGgucHJvdG90eXBlLm5vZGVzID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBfLmtleXModGhpcy5fbm9kZXMpO1xufTtcblxuR3JhcGgucHJvdG90eXBlLnNvdXJjZXMgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICByZXR1cm4gXy5maWx0ZXIodGhpcy5ub2RlcygpLCBmdW5jdGlvbih2KSB7XG4gICAgcmV0dXJuIF8uaXNFbXB0eShzZWxmLl9pblt2XSk7XG4gIH0pO1xufTtcblxuR3JhcGgucHJvdG90eXBlLnNpbmtzID0gZnVuY3Rpb24oKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgcmV0dXJuIF8uZmlsdGVyKHRoaXMubm9kZXMoKSwgZnVuY3Rpb24odikge1xuICAgIHJldHVybiBfLmlzRW1wdHkoc2VsZi5fb3V0W3ZdKTtcbiAgfSk7XG59O1xuXG5HcmFwaC5wcm90b3R5cGUuc2V0Tm9kZXMgPSBmdW5jdGlvbih2cywgdmFsdWUpIHtcbiAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgXy5lYWNoKHZzLCBmdW5jdGlvbih2KSB7XG4gICAgaWYgKGFyZ3MubGVuZ3RoID4gMSkge1xuICAgICAgc2VsZi5zZXROb2RlKHYsIHZhbHVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2VsZi5zZXROb2RlKHYpO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuR3JhcGgucHJvdG90eXBlLnNldE5vZGUgPSBmdW5jdGlvbih2LCB2YWx1ZSkge1xuICBpZiAoXy5oYXModGhpcy5fbm9kZXMsIHYpKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICB0aGlzLl9ub2Rlc1t2XSA9IHZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIHRoaXMuX25vZGVzW3ZdID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgPyB2YWx1ZSA6IHRoaXMuX2RlZmF1bHROb2RlTGFiZWxGbih2KTtcbiAgaWYgKHRoaXMuX2lzQ29tcG91bmQpIHtcbiAgICB0aGlzLl9wYXJlbnRbdl0gPSBHUkFQSF9OT0RFO1xuICAgIHRoaXMuX2NoaWxkcmVuW3ZdID0ge307XG4gICAgdGhpcy5fY2hpbGRyZW5bR1JBUEhfTk9ERV1bdl0gPSB0cnVlO1xuICB9XG4gIHRoaXMuX2luW3ZdID0ge307XG4gIHRoaXMuX3ByZWRzW3ZdID0ge307XG4gIHRoaXMuX291dFt2XSA9IHt9O1xuICB0aGlzLl9zdWNzW3ZdID0ge307XG4gICsrdGhpcy5fbm9kZUNvdW50O1xuICByZXR1cm4gdGhpcztcbn07XG5cbkdyYXBoLnByb3RvdHlwZS5ub2RlID0gZnVuY3Rpb24odikge1xuICByZXR1cm4gdGhpcy5fbm9kZXNbdl07XG59O1xuXG5HcmFwaC5wcm90b3R5cGUuaGFzTm9kZSA9IGZ1bmN0aW9uKHYpIHtcbiAgcmV0dXJuIF8uaGFzKHRoaXMuX25vZGVzLCB2KTtcbn07XG5cbkdyYXBoLnByb3RvdHlwZS5yZW1vdmVOb2RlID0gIGZ1bmN0aW9uKHYpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBpZiAoXy5oYXModGhpcy5fbm9kZXMsIHYpKSB7XG4gICAgdmFyIHJlbW92ZUVkZ2UgPSBmdW5jdGlvbihlKSB7IHNlbGYucmVtb3ZlRWRnZShzZWxmLl9lZGdlT2Jqc1tlXSk7IH07XG4gICAgZGVsZXRlIHRoaXMuX25vZGVzW3ZdO1xuICAgIGlmICh0aGlzLl9pc0NvbXBvdW5kKSB7XG4gICAgICB0aGlzLl9yZW1vdmVGcm9tUGFyZW50c0NoaWxkTGlzdCh2KTtcbiAgICAgIGRlbGV0ZSB0aGlzLl9wYXJlbnRbdl07XG4gICAgICBfLmVhY2godGhpcy5jaGlsZHJlbih2KSwgZnVuY3Rpb24oY2hpbGQpIHtcbiAgICAgICAgc2VsZi5zZXRQYXJlbnQoY2hpbGQpO1xuICAgICAgfSk7XG4gICAgICBkZWxldGUgdGhpcy5fY2hpbGRyZW5bdl07XG4gICAgfVxuICAgIF8uZWFjaChfLmtleXModGhpcy5faW5bdl0pLCByZW1vdmVFZGdlKTtcbiAgICBkZWxldGUgdGhpcy5faW5bdl07XG4gICAgZGVsZXRlIHRoaXMuX3ByZWRzW3ZdO1xuICAgIF8uZWFjaChfLmtleXModGhpcy5fb3V0W3ZdKSwgcmVtb3ZlRWRnZSk7XG4gICAgZGVsZXRlIHRoaXMuX291dFt2XTtcbiAgICBkZWxldGUgdGhpcy5fc3Vjc1t2XTtcbiAgICAtLXRoaXMuX25vZGVDb3VudDtcbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG5cbkdyYXBoLnByb3RvdHlwZS5zZXRQYXJlbnQgPSBmdW5jdGlvbih2LCBwYXJlbnQpIHtcbiAgaWYgKCF0aGlzLl9pc0NvbXBvdW5kKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IHNldCBwYXJlbnQgaW4gYSBub24tY29tcG91bmQgZ3JhcGhcIik7XG4gIH1cblxuICBpZiAoXy5pc1VuZGVmaW5lZChwYXJlbnQpKSB7XG4gICAgcGFyZW50ID0gR1JBUEhfTk9ERTtcbiAgfSBlbHNlIHtcbiAgICAvLyBDb2VyY2UgcGFyZW50IHRvIHN0cmluZ1xuICAgIHBhcmVudCArPSBcIlwiO1xuICAgIGZvciAodmFyIGFuY2VzdG9yID0gcGFyZW50O1xuICAgICAgIV8uaXNVbmRlZmluZWQoYW5jZXN0b3IpO1xuICAgICAgYW5jZXN0b3IgPSB0aGlzLnBhcmVudChhbmNlc3RvcikpIHtcbiAgICAgIGlmIChhbmNlc3RvciA9PT0gdikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJTZXR0aW5nIFwiICsgcGFyZW50KyBcIiBhcyBwYXJlbnQgb2YgXCIgKyB2ICtcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiIHdvdWxkIGNyZWF0ZSBhIGN5Y2xlXCIpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuc2V0Tm9kZShwYXJlbnQpO1xuICB9XG5cbiAgdGhpcy5zZXROb2RlKHYpO1xuICB0aGlzLl9yZW1vdmVGcm9tUGFyZW50c0NoaWxkTGlzdCh2KTtcbiAgdGhpcy5fcGFyZW50W3ZdID0gcGFyZW50O1xuICB0aGlzLl9jaGlsZHJlbltwYXJlbnRdW3ZdID0gdHJ1ZTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5HcmFwaC5wcm90b3R5cGUuX3JlbW92ZUZyb21QYXJlbnRzQ2hpbGRMaXN0ID0gZnVuY3Rpb24odikge1xuICBkZWxldGUgdGhpcy5fY2hpbGRyZW5bdGhpcy5fcGFyZW50W3ZdXVt2XTtcbn07XG5cbkdyYXBoLnByb3RvdHlwZS5wYXJlbnQgPSBmdW5jdGlvbih2KSB7XG4gIGlmICh0aGlzLl9pc0NvbXBvdW5kKSB7XG4gICAgdmFyIHBhcmVudCA9IHRoaXMuX3BhcmVudFt2XTtcbiAgICBpZiAocGFyZW50ICE9PSBHUkFQSF9OT0RFKSB7XG4gICAgICByZXR1cm4gcGFyZW50O1xuICAgIH1cbiAgfVxufTtcblxuR3JhcGgucHJvdG90eXBlLmNoaWxkcmVuID0gZnVuY3Rpb24odikge1xuICBpZiAoXy5pc1VuZGVmaW5lZCh2KSkge1xuICAgIHYgPSBHUkFQSF9OT0RFO1xuICB9XG5cbiAgaWYgKHRoaXMuX2lzQ29tcG91bmQpIHtcbiAgICB2YXIgY2hpbGRyZW4gPSB0aGlzLl9jaGlsZHJlblt2XTtcbiAgICBpZiAoY2hpbGRyZW4pIHtcbiAgICAgIHJldHVybiBfLmtleXMoY2hpbGRyZW4pO1xuICAgIH1cbiAgfSBlbHNlIGlmICh2ID09PSBHUkFQSF9OT0RFKSB7XG4gICAgcmV0dXJuIHRoaXMubm9kZXMoKTtcbiAgfSBlbHNlIGlmICh0aGlzLmhhc05vZGUodikpIHtcbiAgICByZXR1cm4gW107XG4gIH1cbn07XG5cbkdyYXBoLnByb3RvdHlwZS5wcmVkZWNlc3NvcnMgPSBmdW5jdGlvbih2KSB7XG4gIHZhciBwcmVkc1YgPSB0aGlzLl9wcmVkc1t2XTtcbiAgaWYgKHByZWRzVikge1xuICAgIHJldHVybiBfLmtleXMocHJlZHNWKTtcbiAgfVxufTtcblxuR3JhcGgucHJvdG90eXBlLnN1Y2Nlc3NvcnMgPSBmdW5jdGlvbih2KSB7XG4gIHZhciBzdWNzViA9IHRoaXMuX3N1Y3Nbdl07XG4gIGlmIChzdWNzVikge1xuICAgIHJldHVybiBfLmtleXMoc3Vjc1YpO1xuICB9XG59O1xuXG5HcmFwaC5wcm90b3R5cGUubmVpZ2hib3JzID0gZnVuY3Rpb24odikge1xuICB2YXIgcHJlZHMgPSB0aGlzLnByZWRlY2Vzc29ycyh2KTtcbiAgaWYgKHByZWRzKSB7XG4gICAgcmV0dXJuIF8udW5pb24ocHJlZHMsIHRoaXMuc3VjY2Vzc29ycyh2KSk7XG4gIH1cbn07XG5cbkdyYXBoLnByb3RvdHlwZS5pc0xlYWYgPSBmdW5jdGlvbiAodikge1xuICB2YXIgbmVpZ2hib3JzO1xuICBpZiAodGhpcy5pc0RpcmVjdGVkKCkpIHtcbiAgICBuZWlnaGJvcnMgPSB0aGlzLnN1Y2Nlc3NvcnModik7XG4gIH0gZWxzZSB7XG4gICAgbmVpZ2hib3JzID0gdGhpcy5uZWlnaGJvcnModik7XG4gIH1cbiAgcmV0dXJuIG5laWdoYm9ycy5sZW5ndGggPT09IDA7XG59O1xuXG5HcmFwaC5wcm90b3R5cGUuZmlsdGVyTm9kZXMgPSBmdW5jdGlvbihmaWx0ZXIpIHtcbiAgdmFyIGNvcHkgPSBuZXcgdGhpcy5jb25zdHJ1Y3Rvcih7XG4gICAgZGlyZWN0ZWQ6IHRoaXMuX2lzRGlyZWN0ZWQsXG4gICAgbXVsdGlncmFwaDogdGhpcy5faXNNdWx0aWdyYXBoLFxuICAgIGNvbXBvdW5kOiB0aGlzLl9pc0NvbXBvdW5kXG4gIH0pO1xuXG4gIGNvcHkuc2V0R3JhcGgodGhpcy5ncmFwaCgpKTtcblxuICB2YXIgc2VsZiA9IHRoaXM7XG4gIF8uZWFjaCh0aGlzLl9ub2RlcywgZnVuY3Rpb24odmFsdWUsIHYpIHtcbiAgICBpZiAoZmlsdGVyKHYpKSB7XG4gICAgICBjb3B5LnNldE5vZGUodiwgdmFsdWUpO1xuICAgIH1cbiAgfSk7XG5cbiAgXy5lYWNoKHRoaXMuX2VkZ2VPYmpzLCBmdW5jdGlvbihlKSB7XG4gICAgaWYgKGNvcHkuaGFzTm9kZShlLnYpICYmIGNvcHkuaGFzTm9kZShlLncpKSB7XG4gICAgICBjb3B5LnNldEVkZ2UoZSwgc2VsZi5lZGdlKGUpKTtcbiAgICB9XG4gIH0pO1xuXG4gIHZhciBwYXJlbnRzID0ge307XG4gIGZ1bmN0aW9uIGZpbmRQYXJlbnQodikge1xuICAgIHZhciBwYXJlbnQgPSBzZWxmLnBhcmVudCh2KTtcbiAgICBpZiAocGFyZW50ID09PSB1bmRlZmluZWQgfHwgY29weS5oYXNOb2RlKHBhcmVudCkpIHtcbiAgICAgIHBhcmVudHNbdl0gPSBwYXJlbnQ7XG4gICAgICByZXR1cm4gcGFyZW50O1xuICAgIH0gZWxzZSBpZiAocGFyZW50IGluIHBhcmVudHMpIHtcbiAgICAgIHJldHVybiBwYXJlbnRzW3BhcmVudF07XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBmaW5kUGFyZW50KHBhcmVudCk7XG4gICAgfVxuICB9XG5cbiAgaWYgKHRoaXMuX2lzQ29tcG91bmQpIHtcbiAgICBfLmVhY2goY29weS5ub2RlcygpLCBmdW5jdGlvbih2KSB7XG4gICAgICBjb3B5LnNldFBhcmVudCh2LCBmaW5kUGFyZW50KHYpKTtcbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiBjb3B5O1xufTtcblxuLyogPT09IEVkZ2UgZnVuY3Rpb25zID09PT09PT09PT0gKi9cblxuR3JhcGgucHJvdG90eXBlLnNldERlZmF1bHRFZGdlTGFiZWwgPSBmdW5jdGlvbihuZXdEZWZhdWx0KSB7XG4gIGlmICghXy5pc0Z1bmN0aW9uKG5ld0RlZmF1bHQpKSB7XG4gICAgbmV3RGVmYXVsdCA9IF8uY29uc3RhbnQobmV3RGVmYXVsdCk7XG4gIH1cbiAgdGhpcy5fZGVmYXVsdEVkZ2VMYWJlbEZuID0gbmV3RGVmYXVsdDtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5HcmFwaC5wcm90b3R5cGUuZWRnZUNvdW50ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLl9lZGdlQ291bnQ7XG59O1xuXG5HcmFwaC5wcm90b3R5cGUuZWRnZXMgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIF8udmFsdWVzKHRoaXMuX2VkZ2VPYmpzKTtcbn07XG5cbkdyYXBoLnByb3RvdHlwZS5zZXRQYXRoID0gZnVuY3Rpb24odnMsIHZhbHVlKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XG4gIF8ucmVkdWNlKHZzLCBmdW5jdGlvbih2LCB3KSB7XG4gICAgaWYgKGFyZ3MubGVuZ3RoID4gMSkge1xuICAgICAgc2VsZi5zZXRFZGdlKHYsIHcsIHZhbHVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2VsZi5zZXRFZGdlKHYsIHcpO1xuICAgIH1cbiAgICByZXR1cm4gdztcbiAgfSk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLypcbiAqIHNldEVkZ2UodiwgdywgW3ZhbHVlLCBbbmFtZV1dKVxuICogc2V0RWRnZSh7IHYsIHcsIFtuYW1lXSB9LCBbdmFsdWVdKVxuICovXG5HcmFwaC5wcm90b3R5cGUuc2V0RWRnZSA9IGZ1bmN0aW9uKCkge1xuICB2YXIgdiwgdywgbmFtZSwgdmFsdWU7XG4gIHZhciB2YWx1ZVNwZWNpZmllZCA9IGZhbHNlO1xuICB2YXIgYXJnMCA9IGFyZ3VtZW50c1swXTtcblxuICBpZiAodHlwZW9mIGFyZzAgPT09IFwib2JqZWN0XCIgJiYgYXJnMCAhPT0gbnVsbCAmJiBcInZcIiBpbiBhcmcwKSB7XG4gICAgdiA9IGFyZzAudjtcbiAgICB3ID0gYXJnMC53O1xuICAgIG5hbWUgPSBhcmcwLm5hbWU7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIHtcbiAgICAgIHZhbHVlID0gYXJndW1lbnRzWzFdO1xuICAgICAgdmFsdWVTcGVjaWZpZWQgPSB0cnVlO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2ID0gYXJnMDtcbiAgICB3ID0gYXJndW1lbnRzWzFdO1xuICAgIG5hbWUgPSBhcmd1bWVudHNbM107XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAyKSB7XG4gICAgICB2YWx1ZSA9IGFyZ3VtZW50c1syXTtcbiAgICAgIHZhbHVlU3BlY2lmaWVkID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICB2ID0gXCJcIiArIHY7XG4gIHcgPSBcIlwiICsgdztcbiAgaWYgKCFfLmlzVW5kZWZpbmVkKG5hbWUpKSB7XG4gICAgbmFtZSA9IFwiXCIgKyBuYW1lO1xuICB9XG5cbiAgdmFyIGUgPSBlZGdlQXJnc1RvSWQodGhpcy5faXNEaXJlY3RlZCwgdiwgdywgbmFtZSk7XG4gIGlmIChfLmhhcyh0aGlzLl9lZGdlTGFiZWxzLCBlKSkge1xuICAgIGlmICh2YWx1ZVNwZWNpZmllZCkge1xuICAgICAgdGhpcy5fZWRnZUxhYmVsc1tlXSA9IHZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIGlmICghXy5pc1VuZGVmaW5lZChuYW1lKSAmJiAhdGhpcy5faXNNdWx0aWdyYXBoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IHNldCBhIG5hbWVkIGVkZ2Ugd2hlbiBpc011bHRpZ3JhcGggPSBmYWxzZVwiKTtcbiAgfVxuXG4gIC8vIEl0IGRpZG4ndCBleGlzdCwgc28gd2UgbmVlZCB0byBjcmVhdGUgaXQuXG4gIC8vIEZpcnN0IGVuc3VyZSB0aGUgbm9kZXMgZXhpc3QuXG4gIHRoaXMuc2V0Tm9kZSh2KTtcbiAgdGhpcy5zZXROb2RlKHcpO1xuXG4gIHRoaXMuX2VkZ2VMYWJlbHNbZV0gPSB2YWx1ZVNwZWNpZmllZCA/IHZhbHVlIDogdGhpcy5fZGVmYXVsdEVkZ2VMYWJlbEZuKHYsIHcsIG5hbWUpO1xuXG4gIHZhciBlZGdlT2JqID0gZWRnZUFyZ3NUb09iaih0aGlzLl9pc0RpcmVjdGVkLCB2LCB3LCBuYW1lKTtcbiAgLy8gRW5zdXJlIHdlIGFkZCB1bmRpcmVjdGVkIGVkZ2VzIGluIGEgY29uc2lzdGVudCB3YXkuXG4gIHYgPSBlZGdlT2JqLnY7XG4gIHcgPSBlZGdlT2JqLnc7XG5cbiAgT2JqZWN0LmZyZWV6ZShlZGdlT2JqKTtcbiAgdGhpcy5fZWRnZU9ianNbZV0gPSBlZGdlT2JqO1xuICBpbmNyZW1lbnRPckluaXRFbnRyeSh0aGlzLl9wcmVkc1t3XSwgdik7XG4gIGluY3JlbWVudE9ySW5pdEVudHJ5KHRoaXMuX3N1Y3Nbdl0sIHcpO1xuICB0aGlzLl9pblt3XVtlXSA9IGVkZ2VPYmo7XG4gIHRoaXMuX291dFt2XVtlXSA9IGVkZ2VPYmo7XG4gIHRoaXMuX2VkZ2VDb3VudCsrO1xuICByZXR1cm4gdGhpcztcbn07XG5cbkdyYXBoLnByb3RvdHlwZS5lZGdlID0gZnVuY3Rpb24odiwgdywgbmFtZSkge1xuICB2YXIgZSA9IChhcmd1bWVudHMubGVuZ3RoID09PSAxXG4gICAgPyBlZGdlT2JqVG9JZCh0aGlzLl9pc0RpcmVjdGVkLCBhcmd1bWVudHNbMF0pXG4gICAgOiBlZGdlQXJnc1RvSWQodGhpcy5faXNEaXJlY3RlZCwgdiwgdywgbmFtZSkpO1xuICByZXR1cm4gdGhpcy5fZWRnZUxhYmVsc1tlXTtcbn07XG5cbkdyYXBoLnByb3RvdHlwZS5oYXNFZGdlID0gZnVuY3Rpb24odiwgdywgbmFtZSkge1xuICB2YXIgZSA9IChhcmd1bWVudHMubGVuZ3RoID09PSAxXG4gICAgPyBlZGdlT2JqVG9JZCh0aGlzLl9pc0RpcmVjdGVkLCBhcmd1bWVudHNbMF0pXG4gICAgOiBlZGdlQXJnc1RvSWQodGhpcy5faXNEaXJlY3RlZCwgdiwgdywgbmFtZSkpO1xuICByZXR1cm4gXy5oYXModGhpcy5fZWRnZUxhYmVscywgZSk7XG59O1xuXG5HcmFwaC5wcm90b3R5cGUucmVtb3ZlRWRnZSA9IGZ1bmN0aW9uKHYsIHcsIG5hbWUpIHtcbiAgdmFyIGUgPSAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMVxuICAgID8gZWRnZU9ialRvSWQodGhpcy5faXNEaXJlY3RlZCwgYXJndW1lbnRzWzBdKVxuICAgIDogZWRnZUFyZ3NUb0lkKHRoaXMuX2lzRGlyZWN0ZWQsIHYsIHcsIG5hbWUpKTtcbiAgdmFyIGVkZ2UgPSB0aGlzLl9lZGdlT2Jqc1tlXTtcbiAgaWYgKGVkZ2UpIHtcbiAgICB2ID0gZWRnZS52O1xuICAgIHcgPSBlZGdlLnc7XG4gICAgZGVsZXRlIHRoaXMuX2VkZ2VMYWJlbHNbZV07XG4gICAgZGVsZXRlIHRoaXMuX2VkZ2VPYmpzW2VdO1xuICAgIGRlY3JlbWVudE9yUmVtb3ZlRW50cnkodGhpcy5fcHJlZHNbd10sIHYpO1xuICAgIGRlY3JlbWVudE9yUmVtb3ZlRW50cnkodGhpcy5fc3Vjc1t2XSwgdyk7XG4gICAgZGVsZXRlIHRoaXMuX2luW3ddW2VdO1xuICAgIGRlbGV0ZSB0aGlzLl9vdXRbdl1bZV07XG4gICAgdGhpcy5fZWRnZUNvdW50LS07XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5HcmFwaC5wcm90b3R5cGUuaW5FZGdlcyA9IGZ1bmN0aW9uKHYsIHUpIHtcbiAgdmFyIGluViA9IHRoaXMuX2luW3ZdO1xuICBpZiAoaW5WKSB7XG4gICAgdmFyIGVkZ2VzID0gXy52YWx1ZXMoaW5WKTtcbiAgICBpZiAoIXUpIHtcbiAgICAgIHJldHVybiBlZGdlcztcbiAgICB9XG4gICAgcmV0dXJuIF8uZmlsdGVyKGVkZ2VzLCBmdW5jdGlvbihlZGdlKSB7IHJldHVybiBlZGdlLnYgPT09IHU7IH0pO1xuICB9XG59O1xuXG5HcmFwaC5wcm90b3R5cGUub3V0RWRnZXMgPSBmdW5jdGlvbih2LCB3KSB7XG4gIHZhciBvdXRWID0gdGhpcy5fb3V0W3ZdO1xuICBpZiAob3V0Vikge1xuICAgIHZhciBlZGdlcyA9IF8udmFsdWVzKG91dFYpO1xuICAgIGlmICghdykge1xuICAgICAgcmV0dXJuIGVkZ2VzO1xuICAgIH1cbiAgICByZXR1cm4gXy5maWx0ZXIoZWRnZXMsIGZ1bmN0aW9uKGVkZ2UpIHsgcmV0dXJuIGVkZ2UudyA9PT0gdzsgfSk7XG4gIH1cbn07XG5cbkdyYXBoLnByb3RvdHlwZS5ub2RlRWRnZXMgPSBmdW5jdGlvbih2LCB3KSB7XG4gIHZhciBpbkVkZ2VzID0gdGhpcy5pbkVkZ2VzKHYsIHcpO1xuICBpZiAoaW5FZGdlcykge1xuICAgIHJldHVybiBpbkVkZ2VzLmNvbmNhdCh0aGlzLm91dEVkZ2VzKHYsIHcpKTtcbiAgfVxufTtcblxuZnVuY3Rpb24gaW5jcmVtZW50T3JJbml0RW50cnkobWFwLCBrKSB7XG4gIGlmIChtYXBba10pIHtcbiAgICBtYXBba10rKztcbiAgfSBlbHNlIHtcbiAgICBtYXBba10gPSAxO1xuICB9XG59XG5cbmZ1bmN0aW9uIGRlY3JlbWVudE9yUmVtb3ZlRW50cnkobWFwLCBrKSB7XG4gIGlmICghLS1tYXBba10pIHsgZGVsZXRlIG1hcFtrXTsgfVxufVxuXG5mdW5jdGlvbiBlZGdlQXJnc1RvSWQoaXNEaXJlY3RlZCwgdl8sIHdfLCBuYW1lKSB7XG4gIHZhciB2ID0gXCJcIiArIHZfO1xuICB2YXIgdyA9IFwiXCIgKyB3XztcbiAgaWYgKCFpc0RpcmVjdGVkICYmIHYgPiB3KSB7XG4gICAgdmFyIHRtcCA9IHY7XG4gICAgdiA9IHc7XG4gICAgdyA9IHRtcDtcbiAgfVxuICByZXR1cm4gdiArIEVER0VfS0VZX0RFTElNICsgdyArIEVER0VfS0VZX0RFTElNICtcbiAgICAgICAgICAgICAoXy5pc1VuZGVmaW5lZChuYW1lKSA/IERFRkFVTFRfRURHRV9OQU1FIDogbmFtZSk7XG59XG5cbmZ1bmN0aW9uIGVkZ2VBcmdzVG9PYmooaXNEaXJlY3RlZCwgdl8sIHdfLCBuYW1lKSB7XG4gIHZhciB2ID0gXCJcIiArIHZfO1xuICB2YXIgdyA9IFwiXCIgKyB3XztcbiAgaWYgKCFpc0RpcmVjdGVkICYmIHYgPiB3KSB7XG4gICAgdmFyIHRtcCA9IHY7XG4gICAgdiA9IHc7XG4gICAgdyA9IHRtcDtcbiAgfVxuICB2YXIgZWRnZU9iaiA9ICB7IHY6IHYsIHc6IHcgfTtcbiAgaWYgKG5hbWUpIHtcbiAgICBlZGdlT2JqLm5hbWUgPSBuYW1lO1xuICB9XG4gIHJldHVybiBlZGdlT2JqO1xufVxuXG5mdW5jdGlvbiBlZGdlT2JqVG9JZChpc0RpcmVjdGVkLCBlZGdlT2JqKSB7XG4gIHJldHVybiBlZGdlQXJnc1RvSWQoaXNEaXJlY3RlZCwgZWRnZU9iai52LCBlZGdlT2JqLncsIGVkZ2VPYmoubmFtZSk7XG59XG4iLCIvLyBJbmNsdWRlcyBvbmx5IHRoZSBcImNvcmVcIiBvZiBncmFwaGxpYlxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIEdyYXBoOiByZXF1aXJlKFwiLi9ncmFwaFwiKSxcbiAgdmVyc2lvbjogcmVxdWlyZShcIi4vdmVyc2lvblwiKVxufTtcbiIsInZhciBfID0gcmVxdWlyZShcIi4vbG9kYXNoXCIpO1xudmFyIEdyYXBoID0gcmVxdWlyZShcIi4vZ3JhcGhcIik7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICB3cml0ZTogd3JpdGUsXG4gIHJlYWQ6IHJlYWRcbn07XG5cbmZ1bmN0aW9uIHdyaXRlKGcpIHtcbiAgdmFyIGpzb24gPSB7XG4gICAgb3B0aW9uczoge1xuICAgICAgZGlyZWN0ZWQ6IGcuaXNEaXJlY3RlZCgpLFxuICAgICAgbXVsdGlncmFwaDogZy5pc011bHRpZ3JhcGgoKSxcbiAgICAgIGNvbXBvdW5kOiBnLmlzQ29tcG91bmQoKVxuICAgIH0sXG4gICAgbm9kZXM6IHdyaXRlTm9kZXMoZyksXG4gICAgZWRnZXM6IHdyaXRlRWRnZXMoZylcbiAgfTtcbiAgaWYgKCFfLmlzVW5kZWZpbmVkKGcuZ3JhcGgoKSkpIHtcbiAgICBqc29uLnZhbHVlID0gXy5jbG9uZShnLmdyYXBoKCkpO1xuICB9XG4gIHJldHVybiBqc29uO1xufVxuXG5mdW5jdGlvbiB3cml0ZU5vZGVzKGcpIHtcbiAgcmV0dXJuIF8ubWFwKGcubm9kZXMoKSwgZnVuY3Rpb24odikge1xuICAgIHZhciBub2RlVmFsdWUgPSBnLm5vZGUodik7XG4gICAgdmFyIHBhcmVudCA9IGcucGFyZW50KHYpO1xuICAgIHZhciBub2RlID0geyB2OiB2IH07XG4gICAgaWYgKCFfLmlzVW5kZWZpbmVkKG5vZGVWYWx1ZSkpIHtcbiAgICAgIG5vZGUudmFsdWUgPSBub2RlVmFsdWU7XG4gICAgfVxuICAgIGlmICghXy5pc1VuZGVmaW5lZChwYXJlbnQpKSB7XG4gICAgICBub2RlLnBhcmVudCA9IHBhcmVudDtcbiAgICB9XG4gICAgcmV0dXJuIG5vZGU7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiB3cml0ZUVkZ2VzKGcpIHtcbiAgcmV0dXJuIF8ubWFwKGcuZWRnZXMoKSwgZnVuY3Rpb24oZSkge1xuICAgIHZhciBlZGdlVmFsdWUgPSBnLmVkZ2UoZSk7XG4gICAgdmFyIGVkZ2UgPSB7IHY6IGUudiwgdzogZS53IH07XG4gICAgaWYgKCFfLmlzVW5kZWZpbmVkKGUubmFtZSkpIHtcbiAgICAgIGVkZ2UubmFtZSA9IGUubmFtZTtcbiAgICB9XG4gICAgaWYgKCFfLmlzVW5kZWZpbmVkKGVkZ2VWYWx1ZSkpIHtcbiAgICAgIGVkZ2UudmFsdWUgPSBlZGdlVmFsdWU7XG4gICAgfVxuICAgIHJldHVybiBlZGdlO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gcmVhZChqc29uKSB7XG4gIHZhciBnID0gbmV3IEdyYXBoKGpzb24ub3B0aW9ucykuc2V0R3JhcGgoanNvbi52YWx1ZSk7XG4gIF8uZWFjaChqc29uLm5vZGVzLCBmdW5jdGlvbihlbnRyeSkge1xuICAgIGcuc2V0Tm9kZShlbnRyeS52LCBlbnRyeS52YWx1ZSk7XG4gICAgaWYgKGVudHJ5LnBhcmVudCkge1xuICAgICAgZy5zZXRQYXJlbnQoZW50cnkudiwgZW50cnkucGFyZW50KTtcbiAgICB9XG4gIH0pO1xuICBfLmVhY2goanNvbi5lZGdlcywgZnVuY3Rpb24oZW50cnkpIHtcbiAgICBnLnNldEVkZ2UoeyB2OiBlbnRyeS52LCB3OiBlbnRyeS53LCBuYW1lOiBlbnRyeS5uYW1lIH0sIGVudHJ5LnZhbHVlKTtcbiAgfSk7XG4gIHJldHVybiBnO1xufVxuIiwiLyogZ2xvYmFsIHdpbmRvdyAqL1xuXG52YXIgbG9kYXNoO1xuXG5pZiAodHlwZW9mIHJlcXVpcmUgPT09IFwiZnVuY3Rpb25cIikge1xuICB0cnkge1xuICAgIGxvZGFzaCA9IHtcbiAgICAgIGNsb25lOiByZXF1aXJlKFwibG9kYXNoL2Nsb25lXCIpLFxuICAgICAgY29uc3RhbnQ6IHJlcXVpcmUoXCJsb2Rhc2gvY29uc3RhbnRcIiksXG4gICAgICBlYWNoOiByZXF1aXJlKFwibG9kYXNoL2VhY2hcIiksXG4gICAgICBmaWx0ZXI6IHJlcXVpcmUoXCJsb2Rhc2gvZmlsdGVyXCIpLFxuICAgICAgaGFzOiAgcmVxdWlyZShcImxvZGFzaC9oYXNcIiksXG4gICAgICBpc0FycmF5OiByZXF1aXJlKFwibG9kYXNoL2lzQXJyYXlcIiksXG4gICAgICBpc0VtcHR5OiByZXF1aXJlKFwibG9kYXNoL2lzRW1wdHlcIiksXG4gICAgICBpc0Z1bmN0aW9uOiByZXF1aXJlKFwibG9kYXNoL2lzRnVuY3Rpb25cIiksXG4gICAgICBpc1VuZGVmaW5lZDogcmVxdWlyZShcImxvZGFzaC9pc1VuZGVmaW5lZFwiKSxcbiAgICAgIGtleXM6IHJlcXVpcmUoXCJsb2Rhc2gva2V5c1wiKSxcbiAgICAgIG1hcDogcmVxdWlyZShcImxvZGFzaC9tYXBcIiksXG4gICAgICByZWR1Y2U6IHJlcXVpcmUoXCJsb2Rhc2gvcmVkdWNlXCIpLFxuICAgICAgc2l6ZTogcmVxdWlyZShcImxvZGFzaC9zaXplXCIpLFxuICAgICAgdHJhbnNmb3JtOiByZXF1aXJlKFwibG9kYXNoL3RyYW5zZm9ybVwiKSxcbiAgICAgIHVuaW9uOiByZXF1aXJlKFwibG9kYXNoL3VuaW9uXCIpLFxuICAgICAgdmFsdWVzOiByZXF1aXJlKFwibG9kYXNoL3ZhbHVlc1wiKVxuICAgIH07XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICAvLyBjb250aW51ZSByZWdhcmRsZXNzIG9mIGVycm9yXG4gIH1cbn1cblxuaWYgKCFsb2Rhc2gpIHtcbiAgbG9kYXNoID0gd2luZG93Ll87XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbG9kYXNoO1xuIiwibW9kdWxlLmV4cG9ydHMgPSAnMi4xLjgnO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuZXhwb3J0cy5jcmVhdGVEZXBlbmRlbmN5RGlhZ3JhbSA9IHZvaWQgMDtcclxuY29uc3QgdHQgPSByZXF1aXJlKFwidGFpdHRvXCIpO1xyXG5sZXQgc3ZnID0gdHQuc3ZnO1xyXG5sZXQgYXJyb3cgPSB7XHJcbiAgICBjbG9zZWQ6IGZhbHNlLFxyXG4gICAgY2xhc3NOYW1lOiBcImFycm93XCIsXHJcbiAgICBwb3NpdGlvbnM6IFt0dC5BcnJvd1Bvcy5EZXN0aW5hdGlvbl0sXHJcbiAgICB3aWR0aDogNSxcclxuICAgIGxlbmd0aDogNVxyXG59O1xyXG5hc3luYyBmdW5jdGlvbiBsb2FkRGVwZW5kZW5jaWVzKHVybCkge1xyXG4gICAgbGV0IHJlc3AgPSBhd2FpdCBmZXRjaCh1cmwpO1xyXG4gICAgcmV0dXJuIHJlc3Aub2sgPyBKU09OLnBhcnNlKGF3YWl0IHJlc3AudGV4dCgpKSA6IG51bGw7XHJcbn1cclxuYXN5bmMgZnVuY3Rpb24gY3JlYXRlRGVwZW5kZW5jeURpYWdyYW0ocGFyYW1zLCBwYXJlbnQpIHtcclxuICAgIGxldCBwYXJzID0gcGFyYW1zLnNwbGl0KC9cXHMrLyk7XHJcbiAgICBsZXQgdXJsID0gcGFyc1swXTtcclxuICAgIGxldCBmaWx0ZXIgPSBwYXJzWzFdICYmIG5ldyBSZWdFeHAocGFyc1sxXSk7XHJcbiAgICBsZXQgcmVkaXIgPSB1cmwuc3Vic3RyKDAsIHVybC5sYXN0SW5kZXhPZihcIi9cIikpO1xyXG4gICAgbGV0IGRncmFwaCA9IGF3YWl0IGxvYWREZXBlbmRlbmNpZXModXJsKTtcclxuICAgIGlmICghZGdyYXBoKVxyXG4gICAgICAgIHRocm93IEVycm9yKGBDb3VsZCBub3QgbG9hZCBkZXBlbmRlbmN5IGdyYXBoIGZyb20gXCIke3VybH1cImApO1xyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgbGV0IG1vZHVsZXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhkZ3JhcGgpXHJcbiAgICAgICAgICAgIC5maWx0ZXIobiA9PiAhZmlsdGVyIHx8IG4ubWF0Y2goZmlsdGVyKSk7XHJcbiAgICAgICAgbGV0IG5vZGVzID0gbW9kdWxlcy5tYXAobmFtZSA9PiB7XHJcbiAgICAgICAgICAgIGxldCBtb2R1bGUgPSBkZ3JhcGhbbmFtZV07XHJcbiAgICAgICAgICAgIGxldCBub2RlID0ge1xyXG4gICAgICAgICAgICAgICAgbmFtZSxcclxuICAgICAgICAgICAgICAgIGxhYmVsOiBuYW1lLFxyXG4gICAgICAgICAgICAgICAgbGluazogbW9kdWxlLnVybCA/IHJlZGlyICsgXCIvXCIgKyBtb2R1bGUudXJsIDogdW5kZWZpbmVkLFxyXG4gICAgICAgICAgICAgICAgc2hhcGU6IChwLCB4LCB5LCB3LCBoKSA9PiBzdmcucmVjdChwLCB4LCB5LCB3LCBoLCA4LCA4KVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBtb2R1bGUubm9kZSA9IG5vZGU7XHJcbiAgICAgICAgICAgIHJldHVybiBub2RlO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGxldCBlZGdlcyA9IHR0LmVkZ2VzKG1vZHVsZXMubWFwKG5hbWUgPT4gZGdyYXBoW25hbWVdLmRlcGVuZGVuY2llcy5maWx0ZXIoZGVwID0+IGRncmFwaFtkZXBdLm5vZGUpXHJcbiAgICAgICAgICAgIC5tYXAoZGVwID0+IFtkZ3JhcGhbbmFtZV0ubm9kZSwgZGdyYXBoW2RlcF0ubm9kZV0pKVxyXG4gICAgICAgICAgICAucmVkdWNlKChhLCBiKSA9PiBhLmNvbmNhdChiKSksIGFycm93KTtcclxuICAgICAgICB0dC5kaWdyYXBoKHtcclxuICAgICAgICAgICAgbm9kZXMsXHJcbiAgICAgICAgICAgIGVkZ2VzLFxyXG4gICAgICAgICAgICBkaXJlY3Rpb246ICdMUicsXHJcbiAgICAgICAgICAgIGN1cnZlZEVkZ2VzOiB0cnVlLFxyXG4gICAgICAgICAgICByYW5rc2VwOiAxNixcclxuICAgICAgICAgICAgbm9kZXNlcDogMzJcclxuICAgICAgICB9LCBwYXJlbnQpO1xyXG4gICAgfVxyXG59XHJcbmV4cG9ydHMuY3JlYXRlRGVwZW5kZW5jeURpYWdyYW0gPSBjcmVhdGVEZXBlbmRlbmN5RGlhZ3JhbTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGVwZW5kZW5jeS1kaWFnLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xyXG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XHJcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH0pO1xyXG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xyXG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcclxuICAgIG9bazJdID0gbVtrXTtcclxufSkpO1xyXG52YXIgX19leHBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2V4cG9ydFN0YXIpIHx8IGZ1bmN0aW9uKG0sIGV4cG9ydHMpIHtcclxuICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKHAgIT09IFwiZGVmYXVsdFwiICYmICFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZXhwb3J0cywgcCkpIF9fY3JlYXRlQmluZGluZyhleHBvcnRzLCBtLCBwKTtcclxufTtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vZGVwZW5kZW5jeS1kaWFnXCIpLCBleHBvcnRzKTtcclxuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL3Rlc3QtdmlzdWFsaXplclwiKSwgZXhwb3J0cyk7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmV4cG9ydHMuY3JlYXRlUmVwb3J0ZXIgPSB2b2lkIDA7XHJcbmZ1bmN0aW9uIGNyZWF0ZVRlc3QobmFtZSkge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBuYW1lLFxyXG4gICAgICAgIHBhc3NlczogMCxcclxuICAgICAgICBmYWlsczogMCxcclxuICAgICAgICBkdXJhdGlvbjogMCxcclxuICAgICAgICB0ZXN0czogW10sXHJcbiAgICAgICAgYXNzZXJ0aW9uczogW11cclxuICAgIH07XHJcbn1cclxuZnVuY3Rpb24gY3JlYXRlUmVwb3J0ZXIobmFtZSwgcmVuZGVyKSB7XHJcbiAgICBsZXQgcm9vdFRlc3QgPSBjcmVhdGVUZXN0KG5hbWUpO1xyXG4gICAgbGV0IHRlc3RzdGFjayA9IFtyb290VGVzdF07XHJcbiAgICByZXR1cm4gYXN5bmMgKHN0cmVhbSkgPT4ge1xyXG4gICAgICAgIGZvciBhd2FpdCAobGV0IG1lc3NhZ2Ugb2Ygc3RyZWFtKSB7XHJcbiAgICAgICAgICAgIHN3aXRjaCAobWVzc2FnZS50eXBlKSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlIFwiVEVTVF9TVEFSVFwiIC8qIFRFU1RfU1RBUlQgKi86XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IG5ld3Rlc3QgPSBjcmVhdGVUZXN0KG1lc3NhZ2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgLmRhdGEuZGVzY3JpcHRpb24pO1xyXG4gICAgICAgICAgICAgICAgICAgIHRlc3RzdGFja1t0ZXN0c3RhY2subGVuZ3RoIC0gMV0udGVzdHMucHVzaChuZXd0ZXN0KTtcclxuICAgICAgICAgICAgICAgICAgICB0ZXN0c3RhY2sucHVzaChuZXd0ZXN0KTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgXCJURVNUX0VORFwiIC8qIFRFU1RfRU5EICovOlxyXG4gICAgICAgICAgICAgICAgICAgIGxldCB6dGVzdCA9IG1lc3NhZ2UuZGF0YTtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgdGVzdCA9IHRlc3RzdGFjay5wb3AoKTtcclxuICAgICAgICAgICAgICAgICAgICB0ZXN0LnBhc3MgPSB6dGVzdC5wYXNzO1xyXG4gICAgICAgICAgICAgICAgICAgIHRlc3QucGFzc2VzID0genRlc3Quc3VjY2Vzc0NvdW50O1xyXG4gICAgICAgICAgICAgICAgICAgIHRlc3QuZmFpbHMgPSB6dGVzdC5mYWlsdXJlQ291bnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgdGVzdC5lcnJvciA9IHp0ZXN0LmVycm9yO1xyXG4gICAgICAgICAgICAgICAgICAgIHRlc3QuZHVyYXRpb24gPSB6dGVzdC5leGVjdXRpb25UaW1lO1xyXG4gICAgICAgICAgICAgICAgICAgIHJlbmRlcihyb290VGVzdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIFwiQVNTRVJUSU9OXCIgLyogQVNTRVJUSU9OICovOlxyXG4gICAgICAgICAgICAgICAgICAgIGxldCB6YXNzID0gbWVzc2FnZS5kYXRhO1xyXG4gICAgICAgICAgICAgICAgICAgIHRlc3RzdGFja1t0ZXN0c3RhY2subGVuZ3RoIC0gMV0uYXNzZXJ0aW9ucy5wdXNoKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogemFzcy5kZXNjcmlwdGlvbixcclxuICAgICAgICAgICAgICAgICAgICAgICAgcGFzczogemFzcy5wYXNzXHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIFwiQkFJTF9PVVRcIiAvKiBCQUlMX09VVCAqLzpcclxuICAgICAgICAgICAgICAgICAgICB0ZXN0c3RhY2tbdGVzdHN0YWNrLmxlbmd0aCAtIDFdLmVycm9yID1cclxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5kYXRhO1xyXG4gICAgICAgICAgICAgICAgICAgIHJlbmRlcihyb290VGVzdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG59XHJcbmV4cG9ydHMuY3JlYXRlUmVwb3J0ZXIgPSBjcmVhdGVSZXBvcnRlcjtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dGVzdC1yZXBvcnRlci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5leHBvcnRzLnJ1blRlc3RzID0gdm9pZCAwO1xyXG5jb25zdCB0ciA9IHJlcXVpcmUoXCIuL3Rlc3QtcmVwb3J0ZXJcIik7XHJcbmNvbnN0IHRlc3RlciA9IHJlcXVpcmUoXCIuL3Rlc3RlclwiKTtcclxuZnVuY3Rpb24gcnVuVGVzdHMocGFyYW1zLCBwYXJlbnQpIHtcclxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdsb2FkJywgKCkgPT4gdGVzdGVyLmdldEhhcm5lc3MoKS5yZXBvcnQodHIuY3JlYXRlUmVwb3J0ZXIocGFyYW1zLCBzdGF0dXMgPT4ge1xyXG4gICAgICAgIHdoaWxlIChwYXJlbnQuZmlyc3RDaGlsZClcclxuICAgICAgICAgICAgcGFyZW50LmZpcnN0Q2hpbGQucmVtb3ZlKCk7XHJcbiAgICAgICAgcGFyZW50LmFwcGVuZENoaWxkKHRlc3RTdGF0dXMoc3RhdHVzKSk7XHJcbiAgICB9KSkpO1xyXG59XHJcbmV4cG9ydHMucnVuVGVzdHMgPSBydW5UZXN0cztcclxuZnVuY3Rpb24gZWxlbSh0YWdOYW1lLCBjbHMsIHRleHQpIHtcclxuICAgIGxldCByZXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHRhZ05hbWUpO1xyXG4gICAgaWYgKGNscylcclxuICAgICAgICByZXMuY2xhc3NMaXN0LmFkZChjbHMpO1xyXG4gICAgaWYgKHRleHQpXHJcbiAgICAgICAgcmVzLmlubmVyVGV4dCA9IHRleHQ7XHJcbiAgICByZXR1cm4gcmVzO1xyXG59XHJcbmZ1bmN0aW9uIHN0YXR1c0ljb24oYXNzZXJ0aW9uKSB7XHJcbiAgICByZXR1cm4gYXNzZXJ0aW9uLnBhc3MgPyBcIuKchVwiIDogXCLinYxcIjtcclxufVxyXG5mdW5jdGlvbiB0ZXN0U3R5bGUodGVzdCkge1xyXG4gICAgcmV0dXJuIHRlc3QucGFzcyA/ICcjZjhmZmY4JyA6ICcjZmZmOGY4JztcclxufVxyXG5mdW5jdGlvbiB0ZXN0U3RhdHVzKHJvb3RUZXN0KSB7XHJcbiAgICBsZXQgdmlzID0gZWxlbShcImRpdlwiLCBcInRlc3QtdmlzdWFsaXplclwiKTtcclxuICAgIHZpcy5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSB0ZXN0U3R5bGUocm9vdFRlc3QpO1xyXG4gICAgbGV0IHN1bSA9IGVsZW0oXCJkaXZcIiwgXCJzdW1tYXJ5XCIsIGAke3N0YXR1c0ljb24ocm9vdFRlc3QpfSAke3Jvb3RUZXN0Lm5hbWV9YCk7XHJcbiAgICBzdW0uYXBwZW5kQ2hpbGQoZWxlbShcInNwYW5cIiwgXCJjb3VudFwiLCBgUGFzczogJHtyb290VGVzdC5wYXNzZXN9YCkpO1xyXG4gICAgc3VtLmFwcGVuZENoaWxkKGVsZW0oXCJzcGFuXCIsIFwiY291bnRcIiwgYEZhaWw6ICR7cm9vdFRlc3QuZmFpbHN9YCkpO1xyXG4gICAgdmlzLmFwcGVuZENoaWxkKHN1bSk7XHJcbiAgICB2aXMuYXBwZW5kQ2hpbGQodGVzdExpc3Qocm9vdFRlc3QudGVzdHMpKTtcclxuICAgIHJldHVybiB2aXM7XHJcbn1cclxuZnVuY3Rpb24gdGVzdExpc3QodGVzdHMpIHtcclxuICAgIGxldCBsc3QgPSBlbGVtKFwib2xcIiwgXCJ0ZXN0LWxpc3RcIik7XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRlc3RzLmxlbmd0aDsgaSsrKVxyXG4gICAgICAgIGxzdC5hcHBlbmRDaGlsZCh0ZXN0KHRlc3RzW2ldKSk7XHJcbiAgICByZXR1cm4gbHN0O1xyXG59XHJcbmZ1bmN0aW9uIGFzc2VydGlvbihhc3NlcnRpb24pIHtcclxuICAgIHJldHVybiBlbGVtKFwibGlcIiwgdW5kZWZpbmVkLCBgJHtzdGF0dXNJY29uKGFzc2VydGlvbil9ICR7YXNzZXJ0aW9uLm5hbWV9YCk7XHJcbn1cclxuZnVuY3Rpb24gYXNzZXJ0aW9ucyhhc3NlcnRpb25zKSB7XHJcbiAgICBsZXQgZGV0ID0gZWxlbShcImRldGFpbHNcIik7XHJcbiAgICBkZXQuYXBwZW5kQ2hpbGQoZWxlbShcInN1bW1hcnlcIiwgdW5kZWZpbmVkLCBgJHthc3NlcnRpb25zLmxlbmd0aH0gYXNzZXJ0aW9uc2ApKTtcclxuICAgIGxldCBvbCA9IGVsZW0oXCJvbFwiKTtcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXNzZXJ0aW9ucy5sZW5ndGg7IGkrKylcclxuICAgICAgICBvbC5hcHBlbmRDaGlsZChhc3NlcnRpb24oYXNzZXJ0aW9uc1tpXSkpO1xyXG4gICAgZGV0LmFwcGVuZENoaWxkKG9sKTtcclxuICAgIHJldHVybiBkZXQ7XHJcbn1cclxuZnVuY3Rpb24gdGVzdCh0ZXN0KSB7XHJcbiAgICBpZiAodGVzdC5lcnJvcilcclxuICAgICAgICByZXR1cm4gYmFpbGVkT3V0VGVzdCh0ZXN0KTtcclxuICAgIGxldCBsaSA9IGVsZW0oXCJsaVwiLCB1bmRlZmluZWQsIGAke3N0YXR1c0ljb24odGVzdCl9ICR7dGVzdC5uYW1lfSBpbiAke3Rlc3QuZHVyYXRpb259bXNgKTtcclxuICAgIGlmICh0ZXN0LmFzc2VydGlvbnMpXHJcbiAgICAgICAgbGkuYXBwZW5kQ2hpbGQoYXNzZXJ0aW9ucyh0ZXN0LmFzc2VydGlvbnMpKTtcclxuICAgIGlmICh0ZXN0LnRlc3RzKVxyXG4gICAgICAgIGxpLmFwcGVuZENoaWxkKHRlc3RMaXN0KHRlc3QudGVzdHMpKTtcclxuICAgIHJldHVybiBsaTtcclxufVxyXG5mdW5jdGlvbiBiYWlsZWRPdXRUZXN0KHRlc3QpIHtcclxuICAgIGxldCByZXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwibGlcIik7XHJcbiAgICByZXMuaW5uZXJIVE1MID1cclxuICAgICAgICBgJHtzdGF0dXNJY29uKHRlc3QpfSAke3Rlc3QubmFtZX0gdGhyZXcgPGI+JHt0ZXN0LmVycm9yLm5hbWV9PC9iPiBleGNlcHRpb246XHJcbiAgICAgICAgPGJyLz48Yj4ke3Rlc3QuZXJyb3IubWVzc2FnZX08L2I+XHJcbiAgICAgICAgPHByZT4ke3Rlc3QuZXJyb3Iuc3RhY2t9PC9wcmU+YDtcclxuICAgIHJldHVybiByZXM7XHJcbn1cclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dGVzdC12aXN1YWxpemVyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmV4cG9ydHMudGVzdCA9IGV4cG9ydHMuZ2V0SGFybmVzcyA9IHZvaWQgMDtcclxuY29uc3Qgem9yYSA9IHJlcXVpcmUoXCJ6b3JhXCIpO1xyXG5sZXQgaGFybmVzcyA9IHpvcmEuY3JlYXRlSGFybmVzcygpO1xyXG5pZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpXHJcbiAgICBzZXRUaW1lb3V0KHJ1blRlc3RzLCAwKTtcclxuZnVuY3Rpb24gZ2V0SGFybmVzcygpIHtcclxuICAgIHJldHVybiBoYXJuZXNzO1xyXG59XHJcbmV4cG9ydHMuZ2V0SGFybmVzcyA9IGdldEhhcm5lc3M7XHJcbmFzeW5jIGZ1bmN0aW9uIHJ1blRlc3RzKCkge1xyXG4gICAgdHJ5IHtcclxuICAgICAgICBhd2FpdCBoYXJuZXNzLnJlcG9ydCh6b3JhLm1vY2hhVGFwTGlrZSk7XHJcbiAgICB9XHJcbiAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgIGhhcm5lc3MucGFzcyA9IGZhbHNlO1xyXG4gICAgICAgIGlmIChlIGluc3RhbmNlb2YgRXJyb3IpIHtcclxuICAgICAgICAgICAgY29uc29sZS5lcnJvcihlLm5hbWUgKyBcIiBleGNlcHRpb24gdGhyb3duOiBcIiArIGUubWVzc2FnZSk7XHJcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZS5zdGFjayk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKGhhcm5lc3MucGFzcylcclxuICAgICAgICBjb25zb2xlLmxvZygnVGVzdHMgUEFTU0VEJyk7XHJcbiAgICBlbHNlXHJcbiAgICAgICAgY29uc29sZS5sb2coJ1Rlc3RzIEZBSUxFRCcpO1xyXG4gICAgcHJvY2Vzcy5leGl0KGhhcm5lc3MucGFzcyA/IDAgOiAxKTtcclxufVxyXG5mdW5jdGlvbiB0ZXN0KGRlc2NyaXB0aW9uLCBzcGVjLCBvcHRpb25zKSB7XHJcbiAgICByZXR1cm4gaGFybmVzcy50ZXN0KGRlc2NyaXB0aW9uLCBzcGVjLCBvcHRpb25zKTtcclxufVxyXG5leHBvcnRzLnRlc3QgPSB0ZXN0O1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD10ZXN0ZXIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuZXhwb3J0cy5lcnJvciA9IGV4cG9ydHMuY29uc29sZSA9IGV4cG9ydHMuaHRtbCA9IGV4cG9ydHMucmVnaXN0ZXJWaXN1YWxpemVyID0gdm9pZCAwO1xyXG5jb25zdCB2aXN1YWxpemVycyA9IHt9O1xyXG4vKipcclxuICogIyMgUmVnaXN0ZXJpbmcgVmlzdWFsaXplcnNcclxuICpcclxuICogQmVmb3JlIHlvdSBjYW4gdXNlIGEgdmlzdWFsaXplciB5b3UgbmVlZCB0byByZWdpc3RlciBpdCB1c2luZyB0aGUgZnVuY3Rpb25cclxuICogYmVsb3cuIEFub3RoZXIgc3RlcCB0aGF0IGlzIHJlcXVpcmVkIGlzIHRvIHNwZWNpZnkgdGhlIGZpbGUgd2hlcmUgdGhlXHJcbiAqIHZpc3VhbGl6ZXIgcmVzaWRlcyBpbiB0aGUgYGNvZGVGaWxlYCBzZXR0aW5nIG9mIHRoZSBmcm9udCBtYXR0ZXIuIFRoZSBjb2RlXHJcbiAqIGZpbGUgY2FuIGltcG9ydCBvdGhlciBtb2R1bGVzIGFuZCBpdCBtaWdodCBiZSB3cml0dGVuIGluIEphdmFTY3JpcHQgb3JcclxuICogVHlwZVNjcmlwdC4gVGhlIGJ1bmRsZXIgdHJhbnNwaWxlcyBUUyBtb2R1bGVzIHRvIEpTIGFuZCBwYWNrcyB0aGVtIHRvIGFcclxuICogc2luZ2xlIGZpbGUuXHJcbiAqL1xyXG5mdW5jdGlvbiByZWdpc3RlclZpc3VhbGl6ZXIobmFtZSwgdmlzdWFsKSB7XHJcbiAgICBpZiAobmFtZS5tYXRjaCgvXFxzLykpXHJcbiAgICAgICAgdGhyb3cgU3ludGF4RXJyb3IoYFZpc3VhbGl6ZXIgbmFtZSBcIiR7bmFtZX1cIiBjb250YWlucyB3aGl0ZXNwYWNlLmApO1xyXG4gICAgdmlzdWFsaXplcnNbbmFtZV0gPSB2aXN1YWw7XHJcbn1cclxuZXhwb3J0cy5yZWdpc3RlclZpc3VhbGl6ZXIgPSByZWdpc3RlclZpc3VhbGl6ZXI7XHJcbi8qKlxyXG4gKiAjIyBDcmVhdGluZyBWaXN1YWxpemVyc1xyXG4gKlxyXG4gKiBJdCBpcyBwb3NzaWJsZSB0byBjcmVhdGUgeW91ciB2aXN1YWxpemVycyBmcm9tIHNjcmF0Y2ggYnkgZGVmaW5pbmcgYVxyXG4gKiBmdW5jdGlvbiB0aGF0IGltcGxlbWVudHMgdGhlIHNpZ25hdHVyZSBkZWZpbmVkIGFib3ZlLiBIb3dldmVyLCB1c3VhbGx5XHJcbiAqIGl0IGlzIGVhc2llciB0byB1c2Ugc29tZSBvZiB0aGUgaGVscGVyIGZ1bmN0aW9ucyBkZWZpbmVkIGJlbG93LlxyXG4gKlxyXG4gKiBUaGUgZmlyc3QgaGVscGVyIGNyZWF0ZXMgYSBuZXcgSFRNTCBlbGVtZW5lbnQgYW5kIHBsYWNlcyBpdCB1bmRlciB0aGVcclxuICogcGFyZW50IGVsZW1lbnQuIFlvdSBjYW4gc3BlY2lmeSB0aGUgdHlwZSBvZiB0aGUgZWxlbWVudCwgaXRzIGF0dHJpYnV0ZXMsXHJcbiAqIGFuZCBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0aGUgY29udGVudCBpbnNpZGUgdGhlIGVsZW1lbnQuIFRoZSBjb250ZW50XHJcbiAqIGlzIGFzc3VtZWQgdG8gY29udGFpbiBhIHZhbGlkIEhUTUwgc3RyaW5nLlxyXG4gKi9cclxuZnVuY3Rpb24gaHRtbChyZW5kZXIsIHRhZywgYXR0cnMpIHtcclxuICAgIHJldHVybiAoaW5wdXQsIHBhcmVudCkgPT4ge1xyXG4gICAgICAgIGxldCByZXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHRhZyk7XHJcbiAgICAgICAgZm9yIChsZXQgYXR0ciBpbiBhdHRycylcclxuICAgICAgICAgICAgaWYgKGF0dHJzLmhhc093blByb3BlcnR5KGF0dHIpKVxyXG4gICAgICAgICAgICAgICAgcmVzLnNldEF0dHJpYnV0ZShhdHRyLCBhdHRyc1thdHRyXSk7XHJcbiAgICAgICAgcmVzLmlubmVySFRNTCA9IHJlbmRlcihpbnB1dCk7XHJcbiAgICAgICAgcGFyZW50LmFwcGVuZENoaWxkKHJlcyk7XHJcbiAgICB9O1xyXG59XHJcbmV4cG9ydHMuaHRtbCA9IGh0bWw7XHJcbi8qKlxyXG4gKiBBcm1lZCB3aXRoIHRoZSBgaHRtbGAgZnVuY3Rpb24gd2UgY2FuIGRlZmluZSBtb3JlIGhlbHBlcnMgdGhhdCBvdXRwdXRcclxuICogdGhlIHJlc3VsdCBvZiBhIGZ1bmN0aW9uIGluIGEgc3BlY2lmaWMgZWxlbWVudCB3aXRoIGEgc3BlY2lmaWMgc3R5bGUuXHJcbiAqIFRoZSBmaXJzdCBvbmUgc2hvd3MgdGhlIHJlc3VsdCBpbnNpZGUgYSBgPHByZT5gIHRhZyB3aGljaCBpcyBzdHlsZWRcclxuICogYXMgY29uc29sZSBvdXB1dC5cclxuICovXHJcbmZ1bmN0aW9uIGNvbnNvbGUob3V0cHV0KSB7XHJcbiAgICByZXR1cm4gaHRtbChvdXRwdXQsICdwcmUnLCB7IGNsYXNzOiBcImNvbnNvbGVcIiB9KTtcclxufVxyXG5leHBvcnRzLmNvbnNvbGUgPSBjb25zb2xlO1xyXG4vKipcclxuICogVGhlIHNlY29uZCBmdW5jdGlvbiBzaG93cyBhIHN0eWxlZCBlcnJvciBtZXNzYWdlLiBUaGUgc3R5bGUgdXNlZCBoZXJlXHJcbiAqIGlzIGRlZmluZWQgaW4gdGhlIGRlZmF1bHQgdGVtcGxhdGUuIEl0IGlzIHBvc3NpYmxlIGFsc28gdG8gaW1wb3J0IHlvdXJcclxuICogb3duIHN0eWxlIHNoZWV0cyAoTGVzcyBvciBDU1MpIGluIHRoZSBjb2RlIGZpbGVzIHlvdSBpbmNsdWRlLiBUaGV5IGFyZVxyXG4gKiBzZXBhcmF0ZWQsIGNvbXBpbGVkIGFuZCBwYWNrZWQgYnkgdGhlIGJ1bmRsZXIuXHJcbiAqL1xyXG5mdW5jdGlvbiBlcnJvcihtZXNzYWdlKSB7XHJcbiAgICByZXR1cm4gaHRtbChfID0+IG1lc3NhZ2UsICdkaXYnLCB7IGNsYXNzOiBcImVycm9yXCIgfSk7XHJcbn1cclxuZXhwb3J0cy5lcnJvciA9IGVycm9yO1xyXG4vKipcclxuICogIyMgUnVubmluZyBWaXN1YWxpemVyc1xyXG4gKlxyXG4gKiBUaGUgYHJ1blZpc3VhbGl6ZXJgIGZ1bmN0aW9uIGlzIGV4cG9ydGVkIGFzIGEgcHJvcGVydHkgb2YgdGhlIGB3aW5kb3dgXHJcbiAqIG9iamVjdC4gSXQgcnVucyB0aGUgbmFtZWQgdmlzdWFsaXplciB3aXRoIHRoZSBnaXZlbiBwYXJhbWV0ZXJzLiBMaVRTY3JpcHRcclxuICogZ2VuZXJhdGVzIGNvZGUgdGhhdCBjYWxscyB0aGlzIGZ1bmN0aW9uIGZyb20gYSBIVE1MIHBhZ2UuXHJcbiAqL1xyXG5hc3luYyBmdW5jdGlvbiBydW5WaXN1YWxpemVyKG5hbWUsIHBhcmFtcywgcGFyZW50SWQpIHtcclxuICAgIGxldCBwYXJlbnQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChwYXJlbnRJZCk7XHJcbiAgICBpZiAoIXBhcmVudClcclxuICAgICAgICB0aHJvdyBFcnJvcihgVmlzdWFsaXplciBwYXJlbnQgaWQgXCIke3BhcmVudElkfVwiIG5vdCBmb3VuZC5gKTtcclxuICAgIGxldCB2aXN1YWxpemUgPSB2aXN1YWxpemVyc1tuYW1lXSB8fFxyXG4gICAgICAgIGVycm9yKGBWaXN1YWxpemVyIFwiJHtuYW1lfVwiIGlzIG5vdCByZWdpc3RlcmVkLmApO1xyXG4gICAgdHJ5IHtcclxuICAgICAgICBhd2FpdCB2aXN1YWxpemUocGFyYW1zLCBwYXJlbnQpO1xyXG4gICAgfVxyXG4gICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICBlcnJvcihgRXhjZXB0aW9uIHRocm93biBieSB2aXN1YWxpemVyIFwiJHtuYW1lfVwiLjxCUi8+XHJcbiAgICAgICAgJHtlLnRvU3RyaW5nKCl9YCkoXCJcIiwgcGFyZW50KTtcclxuICAgIH1cclxufVxyXG5pZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpXHJcbiAgICB3aW5kb3dbXCJydW5WaXN1YWxpemVyXCJdID0gcnVuVmlzdWFsaXplcjtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dmlzdWFsaXplci5qcy5tYXAiLCJ2YXIgZ2V0TmF0aXZlID0gcmVxdWlyZSgnLi9fZ2V0TmF0aXZlJyksXG4gICAgcm9vdCA9IHJlcXVpcmUoJy4vX3Jvb3QnKTtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgdGhhdCBhcmUgdmVyaWZpZWQgdG8gYmUgbmF0aXZlLiAqL1xudmFyIERhdGFWaWV3ID0gZ2V0TmF0aXZlKHJvb3QsICdEYXRhVmlldycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IERhdGFWaWV3O1xuIiwidmFyIGhhc2hDbGVhciA9IHJlcXVpcmUoJy4vX2hhc2hDbGVhcicpLFxuICAgIGhhc2hEZWxldGUgPSByZXF1aXJlKCcuL19oYXNoRGVsZXRlJyksXG4gICAgaGFzaEdldCA9IHJlcXVpcmUoJy4vX2hhc2hHZXQnKSxcbiAgICBoYXNoSGFzID0gcmVxdWlyZSgnLi9faGFzaEhhcycpLFxuICAgIGhhc2hTZXQgPSByZXF1aXJlKCcuL19oYXNoU2V0Jyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGhhc2ggb2JqZWN0LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7QXJyYXl9IFtlbnRyaWVzXSBUaGUga2V5LXZhbHVlIHBhaXJzIHRvIGNhY2hlLlxuICovXG5mdW5jdGlvbiBIYXNoKGVudHJpZXMpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBlbnRyaWVzID09IG51bGwgPyAwIDogZW50cmllcy5sZW5ndGg7XG5cbiAgdGhpcy5jbGVhcigpO1xuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciBlbnRyeSA9IGVudHJpZXNbaW5kZXhdO1xuICAgIHRoaXMuc2V0KGVudHJ5WzBdLCBlbnRyeVsxXSk7XG4gIH1cbn1cblxuLy8gQWRkIG1ldGhvZHMgdG8gYEhhc2hgLlxuSGFzaC5wcm90b3R5cGUuY2xlYXIgPSBoYXNoQ2xlYXI7XG5IYXNoLnByb3RvdHlwZVsnZGVsZXRlJ10gPSBoYXNoRGVsZXRlO1xuSGFzaC5wcm90b3R5cGUuZ2V0ID0gaGFzaEdldDtcbkhhc2gucHJvdG90eXBlLmhhcyA9IGhhc2hIYXM7XG5IYXNoLnByb3RvdHlwZS5zZXQgPSBoYXNoU2V0O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEhhc2g7XG4iLCJ2YXIgbGlzdENhY2hlQ2xlYXIgPSByZXF1aXJlKCcuL19saXN0Q2FjaGVDbGVhcicpLFxuICAgIGxpc3RDYWNoZURlbGV0ZSA9IHJlcXVpcmUoJy4vX2xpc3RDYWNoZURlbGV0ZScpLFxuICAgIGxpc3RDYWNoZUdldCA9IHJlcXVpcmUoJy4vX2xpc3RDYWNoZUdldCcpLFxuICAgIGxpc3RDYWNoZUhhcyA9IHJlcXVpcmUoJy4vX2xpc3RDYWNoZUhhcycpLFxuICAgIGxpc3RDYWNoZVNldCA9IHJlcXVpcmUoJy4vX2xpc3RDYWNoZVNldCcpO1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gbGlzdCBjYWNoZSBvYmplY3QuXG4gKlxuICogQHByaXZhdGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtBcnJheX0gW2VudHJpZXNdIFRoZSBrZXktdmFsdWUgcGFpcnMgdG8gY2FjaGUuXG4gKi9cbmZ1bmN0aW9uIExpc3RDYWNoZShlbnRyaWVzKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gZW50cmllcyA9PSBudWxsID8gMCA6IGVudHJpZXMubGVuZ3RoO1xuXG4gIHRoaXMuY2xlYXIoKTtcbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIgZW50cnkgPSBlbnRyaWVzW2luZGV4XTtcbiAgICB0aGlzLnNldChlbnRyeVswXSwgZW50cnlbMV0pO1xuICB9XG59XG5cbi8vIEFkZCBtZXRob2RzIHRvIGBMaXN0Q2FjaGVgLlxuTGlzdENhY2hlLnByb3RvdHlwZS5jbGVhciA9IGxpc3RDYWNoZUNsZWFyO1xuTGlzdENhY2hlLnByb3RvdHlwZVsnZGVsZXRlJ10gPSBsaXN0Q2FjaGVEZWxldGU7XG5MaXN0Q2FjaGUucHJvdG90eXBlLmdldCA9IGxpc3RDYWNoZUdldDtcbkxpc3RDYWNoZS5wcm90b3R5cGUuaGFzID0gbGlzdENhY2hlSGFzO1xuTGlzdENhY2hlLnByb3RvdHlwZS5zZXQgPSBsaXN0Q2FjaGVTZXQ7XG5cbm1vZHVsZS5leHBvcnRzID0gTGlzdENhY2hlO1xuIiwidmFyIGdldE5hdGl2ZSA9IHJlcXVpcmUoJy4vX2dldE5hdGl2ZScpLFxuICAgIHJvb3QgPSByZXF1aXJlKCcuL19yb290Jyk7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIHRoYXQgYXJlIHZlcmlmaWVkIHRvIGJlIG5hdGl2ZS4gKi9cbnZhciBNYXAgPSBnZXROYXRpdmUocm9vdCwgJ01hcCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IE1hcDtcbiIsInZhciBtYXBDYWNoZUNsZWFyID0gcmVxdWlyZSgnLi9fbWFwQ2FjaGVDbGVhcicpLFxuICAgIG1hcENhY2hlRGVsZXRlID0gcmVxdWlyZSgnLi9fbWFwQ2FjaGVEZWxldGUnKSxcbiAgICBtYXBDYWNoZUdldCA9IHJlcXVpcmUoJy4vX21hcENhY2hlR2V0JyksXG4gICAgbWFwQ2FjaGVIYXMgPSByZXF1aXJlKCcuL19tYXBDYWNoZUhhcycpLFxuICAgIG1hcENhY2hlU2V0ID0gcmVxdWlyZSgnLi9fbWFwQ2FjaGVTZXQnKTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbWFwIGNhY2hlIG9iamVjdCB0byBzdG9yZSBrZXktdmFsdWUgcGFpcnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtBcnJheX0gW2VudHJpZXNdIFRoZSBrZXktdmFsdWUgcGFpcnMgdG8gY2FjaGUuXG4gKi9cbmZ1bmN0aW9uIE1hcENhY2hlKGVudHJpZXMpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBlbnRyaWVzID09IG51bGwgPyAwIDogZW50cmllcy5sZW5ndGg7XG5cbiAgdGhpcy5jbGVhcigpO1xuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciBlbnRyeSA9IGVudHJpZXNbaW5kZXhdO1xuICAgIHRoaXMuc2V0KGVudHJ5WzBdLCBlbnRyeVsxXSk7XG4gIH1cbn1cblxuLy8gQWRkIG1ldGhvZHMgdG8gYE1hcENhY2hlYC5cbk1hcENhY2hlLnByb3RvdHlwZS5jbGVhciA9IG1hcENhY2hlQ2xlYXI7XG5NYXBDYWNoZS5wcm90b3R5cGVbJ2RlbGV0ZSddID0gbWFwQ2FjaGVEZWxldGU7XG5NYXBDYWNoZS5wcm90b3R5cGUuZ2V0ID0gbWFwQ2FjaGVHZXQ7XG5NYXBDYWNoZS5wcm90b3R5cGUuaGFzID0gbWFwQ2FjaGVIYXM7XG5NYXBDYWNoZS5wcm90b3R5cGUuc2V0ID0gbWFwQ2FjaGVTZXQ7XG5cbm1vZHVsZS5leHBvcnRzID0gTWFwQ2FjaGU7XG4iLCJ2YXIgZ2V0TmF0aXZlID0gcmVxdWlyZSgnLi9fZ2V0TmF0aXZlJyksXG4gICAgcm9vdCA9IHJlcXVpcmUoJy4vX3Jvb3QnKTtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgdGhhdCBhcmUgdmVyaWZpZWQgdG8gYmUgbmF0aXZlLiAqL1xudmFyIFByb21pc2UgPSBnZXROYXRpdmUocm9vdCwgJ1Byb21pc2UnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBQcm9taXNlO1xuIiwidmFyIGdldE5hdGl2ZSA9IHJlcXVpcmUoJy4vX2dldE5hdGl2ZScpLFxuICAgIHJvb3QgPSByZXF1aXJlKCcuL19yb290Jyk7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIHRoYXQgYXJlIHZlcmlmaWVkIHRvIGJlIG5hdGl2ZS4gKi9cbnZhciBTZXQgPSBnZXROYXRpdmUocm9vdCwgJ1NldCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFNldDtcbiIsInZhciBNYXBDYWNoZSA9IHJlcXVpcmUoJy4vX01hcENhY2hlJyksXG4gICAgc2V0Q2FjaGVBZGQgPSByZXF1aXJlKCcuL19zZXRDYWNoZUFkZCcpLFxuICAgIHNldENhY2hlSGFzID0gcmVxdWlyZSgnLi9fc2V0Q2FjaGVIYXMnKTtcblxuLyoqXG4gKlxuICogQ3JlYXRlcyBhbiBhcnJheSBjYWNoZSBvYmplY3QgdG8gc3RvcmUgdW5pcXVlIHZhbHVlcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0FycmF5fSBbdmFsdWVzXSBUaGUgdmFsdWVzIHRvIGNhY2hlLlxuICovXG5mdW5jdGlvbiBTZXRDYWNoZSh2YWx1ZXMpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSB2YWx1ZXMgPT0gbnVsbCA/IDAgOiB2YWx1ZXMubGVuZ3RoO1xuXG4gIHRoaXMuX19kYXRhX18gPSBuZXcgTWFwQ2FjaGU7XG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdGhpcy5hZGQodmFsdWVzW2luZGV4XSk7XG4gIH1cbn1cblxuLy8gQWRkIG1ldGhvZHMgdG8gYFNldENhY2hlYC5cblNldENhY2hlLnByb3RvdHlwZS5hZGQgPSBTZXRDYWNoZS5wcm90b3R5cGUucHVzaCA9IHNldENhY2hlQWRkO1xuU2V0Q2FjaGUucHJvdG90eXBlLmhhcyA9IHNldENhY2hlSGFzO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFNldENhY2hlO1xuIiwidmFyIExpc3RDYWNoZSA9IHJlcXVpcmUoJy4vX0xpc3RDYWNoZScpLFxuICAgIHN0YWNrQ2xlYXIgPSByZXF1aXJlKCcuL19zdGFja0NsZWFyJyksXG4gICAgc3RhY2tEZWxldGUgPSByZXF1aXJlKCcuL19zdGFja0RlbGV0ZScpLFxuICAgIHN0YWNrR2V0ID0gcmVxdWlyZSgnLi9fc3RhY2tHZXQnKSxcbiAgICBzdGFja0hhcyA9IHJlcXVpcmUoJy4vX3N0YWNrSGFzJyksXG4gICAgc3RhY2tTZXQgPSByZXF1aXJlKCcuL19zdGFja1NldCcpO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBzdGFjayBjYWNoZSBvYmplY3QgdG8gc3RvcmUga2V5LXZhbHVlIHBhaXJzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7QXJyYXl9IFtlbnRyaWVzXSBUaGUga2V5LXZhbHVlIHBhaXJzIHRvIGNhY2hlLlxuICovXG5mdW5jdGlvbiBTdGFjayhlbnRyaWVzKSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXyA9IG5ldyBMaXN0Q2FjaGUoZW50cmllcyk7XG4gIHRoaXMuc2l6ZSA9IGRhdGEuc2l6ZTtcbn1cblxuLy8gQWRkIG1ldGhvZHMgdG8gYFN0YWNrYC5cblN0YWNrLnByb3RvdHlwZS5jbGVhciA9IHN0YWNrQ2xlYXI7XG5TdGFjay5wcm90b3R5cGVbJ2RlbGV0ZSddID0gc3RhY2tEZWxldGU7XG5TdGFjay5wcm90b3R5cGUuZ2V0ID0gc3RhY2tHZXQ7XG5TdGFjay5wcm90b3R5cGUuaGFzID0gc3RhY2tIYXM7XG5TdGFjay5wcm90b3R5cGUuc2V0ID0gc3RhY2tTZXQ7XG5cbm1vZHVsZS5leHBvcnRzID0gU3RhY2s7XG4iLCJ2YXIgcm9vdCA9IHJlcXVpcmUoJy4vX3Jvb3QnKTtcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgU3ltYm9sID0gcm9vdC5TeW1ib2w7XG5cbm1vZHVsZS5leHBvcnRzID0gU3ltYm9sO1xuIiwidmFyIHJvb3QgPSByZXF1aXJlKCcuL19yb290Jyk7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIFVpbnQ4QXJyYXkgPSByb290LlVpbnQ4QXJyYXk7XG5cbm1vZHVsZS5leHBvcnRzID0gVWludDhBcnJheTtcbiIsInZhciBnZXROYXRpdmUgPSByZXF1aXJlKCcuL19nZXROYXRpdmUnKSxcbiAgICByb290ID0gcmVxdWlyZSgnLi9fcm9vdCcpO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyB0aGF0IGFyZSB2ZXJpZmllZCB0byBiZSBuYXRpdmUuICovXG52YXIgV2Vha01hcCA9IGdldE5hdGl2ZShyb290LCAnV2Vha01hcCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFdlYWtNYXA7XG4iLCIvKipcbiAqIEEgZmFzdGVyIGFsdGVybmF0aXZlIHRvIGBGdW5jdGlvbiNhcHBseWAsIHRoaXMgZnVuY3Rpb24gaW52b2tlcyBgZnVuY2BcbiAqIHdpdGggdGhlIGB0aGlzYCBiaW5kaW5nIG9mIGB0aGlzQXJnYCBhbmQgdGhlIGFyZ3VtZW50cyBvZiBgYXJnc2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGludm9rZS5cbiAqIEBwYXJhbSB7Kn0gdGhpc0FyZyBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGZ1bmNgLlxuICogQHBhcmFtIHtBcnJheX0gYXJncyBUaGUgYXJndW1lbnRzIHRvIGludm9rZSBgZnVuY2Agd2l0aC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSByZXN1bHQgb2YgYGZ1bmNgLlxuICovXG5mdW5jdGlvbiBhcHBseShmdW5jLCB0aGlzQXJnLCBhcmdzKSB7XG4gIHN3aXRjaCAoYXJncy5sZW5ndGgpIHtcbiAgICBjYXNlIDA6IHJldHVybiBmdW5jLmNhbGwodGhpc0FyZyk7XG4gICAgY2FzZSAxOiByZXR1cm4gZnVuYy5jYWxsKHRoaXNBcmcsIGFyZ3NbMF0pO1xuICAgIGNhc2UgMjogcmV0dXJuIGZ1bmMuY2FsbCh0aGlzQXJnLCBhcmdzWzBdLCBhcmdzWzFdKTtcbiAgICBjYXNlIDM6IHJldHVybiBmdW5jLmNhbGwodGhpc0FyZywgYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSk7XG4gIH1cbiAgcmV0dXJuIGZ1bmMuYXBwbHkodGhpc0FyZywgYXJncyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYXBwbHk7XG4iLCIvKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5mb3JFYWNoYCBmb3IgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydCBmb3JcbiAqIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IFthcnJheV0gVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC5cbiAqL1xuZnVuY3Rpb24gYXJyYXlFYWNoKGFycmF5LCBpdGVyYXRlZSkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgaWYgKGl0ZXJhdGVlKGFycmF5W2luZGV4XSwgaW5kZXgsIGFycmF5KSA9PT0gZmFsc2UpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICByZXR1cm4gYXJyYXk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYXJyYXlFYWNoO1xuIiwiLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8uZmlsdGVyYCBmb3IgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydCBmb3JcbiAqIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IFthcnJheV0gVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWRpY2F0ZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZmlsdGVyZWQgYXJyYXkuXG4gKi9cbmZ1bmN0aW9uIGFycmF5RmlsdGVyKGFycmF5LCBwcmVkaWNhdGUpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aCxcbiAgICAgIHJlc0luZGV4ID0gMCxcbiAgICAgIHJlc3VsdCA9IFtdO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIHZhbHVlID0gYXJyYXlbaW5kZXhdO1xuICAgIGlmIChwcmVkaWNhdGUodmFsdWUsIGluZGV4LCBhcnJheSkpIHtcbiAgICAgIHJlc3VsdFtyZXNJbmRleCsrXSA9IHZhbHVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGFycmF5RmlsdGVyO1xuIiwidmFyIGJhc2VJbmRleE9mID0gcmVxdWlyZSgnLi9fYmFzZUluZGV4T2YnKTtcblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8uaW5jbHVkZXNgIGZvciBhcnJheXMgd2l0aG91dCBzdXBwb3J0IGZvclxuICogc3BlY2lmeWluZyBhbiBpbmRleCB0byBzZWFyY2ggZnJvbS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gW2FycmF5XSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAqIEBwYXJhbSB7Kn0gdGFyZ2V0IFRoZSB2YWx1ZSB0byBzZWFyY2ggZm9yLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB0YXJnZXRgIGlzIGZvdW5kLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGFycmF5SW5jbHVkZXMoYXJyYXksIHZhbHVlKSB7XG4gIHZhciBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcbiAgcmV0dXJuICEhbGVuZ3RoICYmIGJhc2VJbmRleE9mKGFycmF5LCB2YWx1ZSwgMCkgPiAtMTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBhcnJheUluY2x1ZGVzO1xuIiwiLyoqXG4gKiBUaGlzIGZ1bmN0aW9uIGlzIGxpa2UgYGFycmF5SW5jbHVkZXNgIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYSBjb21wYXJhdG9yLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBbYXJyYXldIFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICogQHBhcmFtIHsqfSB0YXJnZXQgVGhlIHZhbHVlIHRvIHNlYXJjaCBmb3IuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjb21wYXJhdG9yIFRoZSBjb21wYXJhdG9yIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHRhcmdldGAgaXMgZm91bmQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYXJyYXlJbmNsdWRlc1dpdGgoYXJyYXksIHZhbHVlLCBjb21wYXJhdG9yKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICBpZiAoY29tcGFyYXRvcih2YWx1ZSwgYXJyYXlbaW5kZXhdKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBhcnJheUluY2x1ZGVzV2l0aDtcbiIsInZhciBiYXNlVGltZXMgPSByZXF1aXJlKCcuL19iYXNlVGltZXMnKSxcbiAgICBpc0FyZ3VtZW50cyA9IHJlcXVpcmUoJy4vaXNBcmd1bWVudHMnKSxcbiAgICBpc0FycmF5ID0gcmVxdWlyZSgnLi9pc0FycmF5JyksXG4gICAgaXNCdWZmZXIgPSByZXF1aXJlKCcuL2lzQnVmZmVyJyksXG4gICAgaXNJbmRleCA9IHJlcXVpcmUoJy4vX2lzSW5kZXgnKSxcbiAgICBpc1R5cGVkQXJyYXkgPSByZXF1aXJlKCcuL2lzVHlwZWRBcnJheScpO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgb2YgdGhlIGFycmF5LWxpa2UgYHZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGluaGVyaXRlZCBTcGVjaWZ5IHJldHVybmluZyBpbmhlcml0ZWQgcHJvcGVydHkgbmFtZXMuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICovXG5mdW5jdGlvbiBhcnJheUxpa2VLZXlzKHZhbHVlLCBpbmhlcml0ZWQpIHtcbiAgdmFyIGlzQXJyID0gaXNBcnJheSh2YWx1ZSksXG4gICAgICBpc0FyZyA9ICFpc0FyciAmJiBpc0FyZ3VtZW50cyh2YWx1ZSksXG4gICAgICBpc0J1ZmYgPSAhaXNBcnIgJiYgIWlzQXJnICYmIGlzQnVmZmVyKHZhbHVlKSxcbiAgICAgIGlzVHlwZSA9ICFpc0FyciAmJiAhaXNBcmcgJiYgIWlzQnVmZiAmJiBpc1R5cGVkQXJyYXkodmFsdWUpLFxuICAgICAgc2tpcEluZGV4ZXMgPSBpc0FyciB8fCBpc0FyZyB8fCBpc0J1ZmYgfHwgaXNUeXBlLFxuICAgICAgcmVzdWx0ID0gc2tpcEluZGV4ZXMgPyBiYXNlVGltZXModmFsdWUubGVuZ3RoLCBTdHJpbmcpIDogW10sXG4gICAgICBsZW5ndGggPSByZXN1bHQubGVuZ3RoO1xuXG4gIGZvciAodmFyIGtleSBpbiB2YWx1ZSkge1xuICAgIGlmICgoaW5oZXJpdGVkIHx8IGhhc093blByb3BlcnR5LmNhbGwodmFsdWUsIGtleSkpICYmXG4gICAgICAgICEoc2tpcEluZGV4ZXMgJiYgKFxuICAgICAgICAgICAvLyBTYWZhcmkgOSBoYXMgZW51bWVyYWJsZSBgYXJndW1lbnRzLmxlbmd0aGAgaW4gc3RyaWN0IG1vZGUuXG4gICAgICAgICAgIGtleSA9PSAnbGVuZ3RoJyB8fFxuICAgICAgICAgICAvLyBOb2RlLmpzIDAuMTAgaGFzIGVudW1lcmFibGUgbm9uLWluZGV4IHByb3BlcnRpZXMgb24gYnVmZmVycy5cbiAgICAgICAgICAgKGlzQnVmZiAmJiAoa2V5ID09ICdvZmZzZXQnIHx8IGtleSA9PSAncGFyZW50JykpIHx8XG4gICAgICAgICAgIC8vIFBoYW50b21KUyAyIGhhcyBlbnVtZXJhYmxlIG5vbi1pbmRleCBwcm9wZXJ0aWVzIG9uIHR5cGVkIGFycmF5cy5cbiAgICAgICAgICAgKGlzVHlwZSAmJiAoa2V5ID09ICdidWZmZXInIHx8IGtleSA9PSAnYnl0ZUxlbmd0aCcgfHwga2V5ID09ICdieXRlT2Zmc2V0JykpIHx8XG4gICAgICAgICAgIC8vIFNraXAgaW5kZXggcHJvcGVydGllcy5cbiAgICAgICAgICAgaXNJbmRleChrZXksIGxlbmd0aClcbiAgICAgICAgKSkpIHtcbiAgICAgIHJlc3VsdC5wdXNoKGtleSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYXJyYXlMaWtlS2V5cztcbiIsIi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLm1hcGAgZm9yIGFycmF5cyB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlXG4gKiBzaG9ydGhhbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBbYXJyYXldIFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgbWFwcGVkIGFycmF5LlxuICovXG5mdW5jdGlvbiBhcnJheU1hcChhcnJheSwgaXRlcmF0ZWUpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aCxcbiAgICAgIHJlc3VsdCA9IEFycmF5KGxlbmd0aCk7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICByZXN1bHRbaW5kZXhdID0gaXRlcmF0ZWUoYXJyYXlbaW5kZXhdLCBpbmRleCwgYXJyYXkpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYXJyYXlNYXA7XG4iLCIvKipcbiAqIEFwcGVuZHMgdGhlIGVsZW1lbnRzIG9mIGB2YWx1ZXNgIHRvIGBhcnJheWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBtb2RpZnkuXG4gKiBAcGFyYW0ge0FycmF5fSB2YWx1ZXMgVGhlIHZhbHVlcyB0byBhcHBlbmQuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC5cbiAqL1xuZnVuY3Rpb24gYXJyYXlQdXNoKGFycmF5LCB2YWx1ZXMpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSB2YWx1ZXMubGVuZ3RoLFxuICAgICAgb2Zmc2V0ID0gYXJyYXkubGVuZ3RoO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgYXJyYXlbb2Zmc2V0ICsgaW5kZXhdID0gdmFsdWVzW2luZGV4XTtcbiAgfVxuICByZXR1cm4gYXJyYXk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYXJyYXlQdXNoO1xuIiwiLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8ucmVkdWNlYCBmb3IgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydCBmb3JcbiAqIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IFthcnJheV0gVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcGFyYW0geyp9IFthY2N1bXVsYXRvcl0gVGhlIGluaXRpYWwgdmFsdWUuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtpbml0QWNjdW1dIFNwZWNpZnkgdXNpbmcgdGhlIGZpcnN0IGVsZW1lbnQgb2YgYGFycmF5YCBhc1xuICogIHRoZSBpbml0aWFsIHZhbHVlLlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGFjY3VtdWxhdGVkIHZhbHVlLlxuICovXG5mdW5jdGlvbiBhcnJheVJlZHVjZShhcnJheSwgaXRlcmF0ZWUsIGFjY3VtdWxhdG9yLCBpbml0QWNjdW0pIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcblxuICBpZiAoaW5pdEFjY3VtICYmIGxlbmd0aCkge1xuICAgIGFjY3VtdWxhdG9yID0gYXJyYXlbKytpbmRleF07XG4gIH1cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICBhY2N1bXVsYXRvciA9IGl0ZXJhdGVlKGFjY3VtdWxhdG9yLCBhcnJheVtpbmRleF0sIGluZGV4LCBhcnJheSk7XG4gIH1cbiAgcmV0dXJuIGFjY3VtdWxhdG9yO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGFycmF5UmVkdWNlO1xuIiwiLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8uc29tZWAgZm9yIGFycmF5cyB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlXG4gKiBzaG9ydGhhbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBbYXJyYXldIFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkaWNhdGUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbnkgZWxlbWVudCBwYXNzZXMgdGhlIHByZWRpY2F0ZSBjaGVjayxcbiAqICBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGFycmF5U29tZShhcnJheSwgcHJlZGljYXRlKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICBpZiAocHJlZGljYXRlKGFycmF5W2luZGV4XSwgaW5kZXgsIGFycmF5KSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBhcnJheVNvbWU7XG4iLCJ2YXIgYmFzZVByb3BlcnR5ID0gcmVxdWlyZSgnLi9fYmFzZVByb3BlcnR5Jyk7XG5cbi8qKlxuICogR2V0cyB0aGUgc2l6ZSBvZiBhbiBBU0NJSSBgc3RyaW5nYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBUaGUgc3RyaW5nIGluc3BlY3QuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBzdHJpbmcgc2l6ZS5cbiAqL1xudmFyIGFzY2lpU2l6ZSA9IGJhc2VQcm9wZXJ0eSgnbGVuZ3RoJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gYXNjaWlTaXplO1xuIiwidmFyIGJhc2VBc3NpZ25WYWx1ZSA9IHJlcXVpcmUoJy4vX2Jhc2VBc3NpZ25WYWx1ZScpLFxuICAgIGVxID0gcmVxdWlyZSgnLi9lcScpO1xuXG4vKipcbiAqIFRoaXMgZnVuY3Rpb24gaXMgbGlrZSBgYXNzaWduVmFsdWVgIGV4Y2VwdCB0aGF0IGl0IGRvZXNuJ3QgYXNzaWduXG4gKiBgdW5kZWZpbmVkYCB2YWx1ZXMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBtb2RpZnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGFzc2lnbi5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGFzc2lnbi5cbiAqL1xuZnVuY3Rpb24gYXNzaWduTWVyZ2VWYWx1ZShvYmplY3QsIGtleSwgdmFsdWUpIHtcbiAgaWYgKCh2YWx1ZSAhPT0gdW5kZWZpbmVkICYmICFlcShvYmplY3Rba2V5XSwgdmFsdWUpKSB8fFxuICAgICAgKHZhbHVlID09PSB1bmRlZmluZWQgJiYgIShrZXkgaW4gb2JqZWN0KSkpIHtcbiAgICBiYXNlQXNzaWduVmFsdWUob2JqZWN0LCBrZXksIHZhbHVlKTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGFzc2lnbk1lcmdlVmFsdWU7XG4iLCJ2YXIgYmFzZUFzc2lnblZhbHVlID0gcmVxdWlyZSgnLi9fYmFzZUFzc2lnblZhbHVlJyksXG4gICAgZXEgPSByZXF1aXJlKCcuL2VxJyk7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogQXNzaWducyBgdmFsdWVgIHRvIGBrZXlgIG9mIGBvYmplY3RgIGlmIHRoZSBleGlzdGluZyB2YWx1ZSBpcyBub3QgZXF1aXZhbGVudFxuICogdXNpbmcgW2BTYW1lVmFsdWVaZXJvYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtc2FtZXZhbHVlemVybylcbiAqIGZvciBlcXVhbGl0eSBjb21wYXJpc29ucy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIG1vZGlmeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gYXNzaWduLlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gYXNzaWduLlxuICovXG5mdW5jdGlvbiBhc3NpZ25WYWx1ZShvYmplY3QsIGtleSwgdmFsdWUpIHtcbiAgdmFyIG9ialZhbHVlID0gb2JqZWN0W2tleV07XG4gIGlmICghKGhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBrZXkpICYmIGVxKG9ialZhbHVlLCB2YWx1ZSkpIHx8XG4gICAgICAodmFsdWUgPT09IHVuZGVmaW5lZCAmJiAhKGtleSBpbiBvYmplY3QpKSkge1xuICAgIGJhc2VBc3NpZ25WYWx1ZShvYmplY3QsIGtleSwgdmFsdWUpO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYXNzaWduVmFsdWU7XG4iLCJ2YXIgZXEgPSByZXF1aXJlKCcuL2VxJyk7XG5cbi8qKlxuICogR2V0cyB0aGUgaW5kZXggYXQgd2hpY2ggdGhlIGBrZXlgIGlzIGZvdW5kIGluIGBhcnJheWAgb2Yga2V5LXZhbHVlIHBhaXJzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAqIEBwYXJhbSB7Kn0ga2V5IFRoZSBrZXkgdG8gc2VhcmNoIGZvci5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBtYXRjaGVkIHZhbHVlLCBlbHNlIGAtMWAuXG4gKi9cbmZ1bmN0aW9uIGFzc29jSW5kZXhPZihhcnJheSwga2V5KSB7XG4gIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG4gIHdoaWxlIChsZW5ndGgtLSkge1xuICAgIGlmIChlcShhcnJheVtsZW5ndGhdWzBdLCBrZXkpKSB7XG4gICAgICByZXR1cm4gbGVuZ3RoO1xuICAgIH1cbiAgfVxuICByZXR1cm4gLTE7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYXNzb2NJbmRleE9mO1xuIiwidmFyIGNvcHlPYmplY3QgPSByZXF1aXJlKCcuL19jb3B5T2JqZWN0JyksXG4gICAga2V5cyA9IHJlcXVpcmUoJy4va2V5cycpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmFzc2lnbmAgd2l0aG91dCBzdXBwb3J0IGZvciBtdWx0aXBsZSBzb3VyY2VzXG4gKiBvciBgY3VzdG9taXplcmAgZnVuY3Rpb25zLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBzb3VyY2Ugb2JqZWN0LlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAqL1xuZnVuY3Rpb24gYmFzZUFzc2lnbihvYmplY3QsIHNvdXJjZSkge1xuICByZXR1cm4gb2JqZWN0ICYmIGNvcHlPYmplY3Qoc291cmNlLCBrZXlzKHNvdXJjZSksIG9iamVjdCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUFzc2lnbjtcbiIsInZhciBjb3B5T2JqZWN0ID0gcmVxdWlyZSgnLi9fY29weU9iamVjdCcpLFxuICAgIGtleXNJbiA9IHJlcXVpcmUoJy4va2V5c0luJyk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uYXNzaWduSW5gIHdpdGhvdXQgc3VwcG9ydCBmb3IgbXVsdGlwbGUgc291cmNlc1xuICogb3IgYGN1c3RvbWl6ZXJgIGZ1bmN0aW9ucy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgc291cmNlIG9iamVjdC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VBc3NpZ25JbihvYmplY3QsIHNvdXJjZSkge1xuICByZXR1cm4gb2JqZWN0ICYmIGNvcHlPYmplY3Qoc291cmNlLCBrZXlzSW4oc291cmNlKSwgb2JqZWN0KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlQXNzaWduSW47XG4iLCJ2YXIgZGVmaW5lUHJvcGVydHkgPSByZXF1aXJlKCcuL19kZWZpbmVQcm9wZXJ0eScpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBhc3NpZ25WYWx1ZWAgYW5kIGBhc3NpZ25NZXJnZVZhbHVlYCB3aXRob3V0XG4gKiB2YWx1ZSBjaGVja3MuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBtb2RpZnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGFzc2lnbi5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGFzc2lnbi5cbiAqL1xuZnVuY3Rpb24gYmFzZUFzc2lnblZhbHVlKG9iamVjdCwga2V5LCB2YWx1ZSkge1xuICBpZiAoa2V5ID09ICdfX3Byb3RvX18nICYmIGRlZmluZVByb3BlcnR5KSB7XG4gICAgZGVmaW5lUHJvcGVydHkob2JqZWN0LCBrZXksIHtcbiAgICAgICdjb25maWd1cmFibGUnOiB0cnVlLFxuICAgICAgJ2VudW1lcmFibGUnOiB0cnVlLFxuICAgICAgJ3ZhbHVlJzogdmFsdWUsXG4gICAgICAnd3JpdGFibGUnOiB0cnVlXG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0W2tleV0gPSB2YWx1ZTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VBc3NpZ25WYWx1ZTtcbiIsInZhciBTdGFjayA9IHJlcXVpcmUoJy4vX1N0YWNrJyksXG4gICAgYXJyYXlFYWNoID0gcmVxdWlyZSgnLi9fYXJyYXlFYWNoJyksXG4gICAgYXNzaWduVmFsdWUgPSByZXF1aXJlKCcuL19hc3NpZ25WYWx1ZScpLFxuICAgIGJhc2VBc3NpZ24gPSByZXF1aXJlKCcuL19iYXNlQXNzaWduJyksXG4gICAgYmFzZUFzc2lnbkluID0gcmVxdWlyZSgnLi9fYmFzZUFzc2lnbkluJyksXG4gICAgY2xvbmVCdWZmZXIgPSByZXF1aXJlKCcuL19jbG9uZUJ1ZmZlcicpLFxuICAgIGNvcHlBcnJheSA9IHJlcXVpcmUoJy4vX2NvcHlBcnJheScpLFxuICAgIGNvcHlTeW1ib2xzID0gcmVxdWlyZSgnLi9fY29weVN5bWJvbHMnKSxcbiAgICBjb3B5U3ltYm9sc0luID0gcmVxdWlyZSgnLi9fY29weVN5bWJvbHNJbicpLFxuICAgIGdldEFsbEtleXMgPSByZXF1aXJlKCcuL19nZXRBbGxLZXlzJyksXG4gICAgZ2V0QWxsS2V5c0luID0gcmVxdWlyZSgnLi9fZ2V0QWxsS2V5c0luJyksXG4gICAgZ2V0VGFnID0gcmVxdWlyZSgnLi9fZ2V0VGFnJyksXG4gICAgaW5pdENsb25lQXJyYXkgPSByZXF1aXJlKCcuL19pbml0Q2xvbmVBcnJheScpLFxuICAgIGluaXRDbG9uZUJ5VGFnID0gcmVxdWlyZSgnLi9faW5pdENsb25lQnlUYWcnKSxcbiAgICBpbml0Q2xvbmVPYmplY3QgPSByZXF1aXJlKCcuL19pbml0Q2xvbmVPYmplY3QnKSxcbiAgICBpc0FycmF5ID0gcmVxdWlyZSgnLi9pc0FycmF5JyksXG4gICAgaXNCdWZmZXIgPSByZXF1aXJlKCcuL2lzQnVmZmVyJyksXG4gICAgaXNNYXAgPSByZXF1aXJlKCcuL2lzTWFwJyksXG4gICAgaXNPYmplY3QgPSByZXF1aXJlKCcuL2lzT2JqZWN0JyksXG4gICAgaXNTZXQgPSByZXF1aXJlKCcuL2lzU2V0JyksXG4gICAga2V5cyA9IHJlcXVpcmUoJy4va2V5cycpLFxuICAgIGtleXNJbiA9IHJlcXVpcmUoJy4va2V5c0luJyk7XG5cbi8qKiBVc2VkIHRvIGNvbXBvc2UgYml0bWFza3MgZm9yIGNsb25pbmcuICovXG52YXIgQ0xPTkVfREVFUF9GTEFHID0gMSxcbiAgICBDTE9ORV9GTEFUX0ZMQUcgPSAyLFxuICAgIENMT05FX1NZTUJPTFNfRkxBRyA9IDQ7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBhcmdzVGFnID0gJ1tvYmplY3QgQXJndW1lbnRzXScsXG4gICAgYXJyYXlUYWcgPSAnW29iamVjdCBBcnJheV0nLFxuICAgIGJvb2xUYWcgPSAnW29iamVjdCBCb29sZWFuXScsXG4gICAgZGF0ZVRhZyA9ICdbb2JqZWN0IERhdGVdJyxcbiAgICBlcnJvclRhZyA9ICdbb2JqZWN0IEVycm9yXScsXG4gICAgZnVuY1RhZyA9ICdbb2JqZWN0IEZ1bmN0aW9uXScsXG4gICAgZ2VuVGFnID0gJ1tvYmplY3QgR2VuZXJhdG9yRnVuY3Rpb25dJyxcbiAgICBtYXBUYWcgPSAnW29iamVjdCBNYXBdJyxcbiAgICBudW1iZXJUYWcgPSAnW29iamVjdCBOdW1iZXJdJyxcbiAgICBvYmplY3RUYWcgPSAnW29iamVjdCBPYmplY3RdJyxcbiAgICByZWdleHBUYWcgPSAnW29iamVjdCBSZWdFeHBdJyxcbiAgICBzZXRUYWcgPSAnW29iamVjdCBTZXRdJyxcbiAgICBzdHJpbmdUYWcgPSAnW29iamVjdCBTdHJpbmddJyxcbiAgICBzeW1ib2xUYWcgPSAnW29iamVjdCBTeW1ib2xdJyxcbiAgICB3ZWFrTWFwVGFnID0gJ1tvYmplY3QgV2Vha01hcF0nO1xuXG52YXIgYXJyYXlCdWZmZXJUYWcgPSAnW29iamVjdCBBcnJheUJ1ZmZlcl0nLFxuICAgIGRhdGFWaWV3VGFnID0gJ1tvYmplY3QgRGF0YVZpZXddJyxcbiAgICBmbG9hdDMyVGFnID0gJ1tvYmplY3QgRmxvYXQzMkFycmF5XScsXG4gICAgZmxvYXQ2NFRhZyA9ICdbb2JqZWN0IEZsb2F0NjRBcnJheV0nLFxuICAgIGludDhUYWcgPSAnW29iamVjdCBJbnQ4QXJyYXldJyxcbiAgICBpbnQxNlRhZyA9ICdbb2JqZWN0IEludDE2QXJyYXldJyxcbiAgICBpbnQzMlRhZyA9ICdbb2JqZWN0IEludDMyQXJyYXldJyxcbiAgICB1aW50OFRhZyA9ICdbb2JqZWN0IFVpbnQ4QXJyYXldJyxcbiAgICB1aW50OENsYW1wZWRUYWcgPSAnW29iamVjdCBVaW50OENsYW1wZWRBcnJheV0nLFxuICAgIHVpbnQxNlRhZyA9ICdbb2JqZWN0IFVpbnQxNkFycmF5XScsXG4gICAgdWludDMyVGFnID0gJ1tvYmplY3QgVWludDMyQXJyYXldJztcblxuLyoqIFVzZWQgdG8gaWRlbnRpZnkgYHRvU3RyaW5nVGFnYCB2YWx1ZXMgc3VwcG9ydGVkIGJ5IGBfLmNsb25lYC4gKi9cbnZhciBjbG9uZWFibGVUYWdzID0ge307XG5jbG9uZWFibGVUYWdzW2FyZ3NUYWddID0gY2xvbmVhYmxlVGFnc1thcnJheVRhZ10gPVxuY2xvbmVhYmxlVGFnc1thcnJheUJ1ZmZlclRhZ10gPSBjbG9uZWFibGVUYWdzW2RhdGFWaWV3VGFnXSA9XG5jbG9uZWFibGVUYWdzW2Jvb2xUYWddID0gY2xvbmVhYmxlVGFnc1tkYXRlVGFnXSA9XG5jbG9uZWFibGVUYWdzW2Zsb2F0MzJUYWddID0gY2xvbmVhYmxlVGFnc1tmbG9hdDY0VGFnXSA9XG5jbG9uZWFibGVUYWdzW2ludDhUYWddID0gY2xvbmVhYmxlVGFnc1tpbnQxNlRhZ10gPVxuY2xvbmVhYmxlVGFnc1tpbnQzMlRhZ10gPSBjbG9uZWFibGVUYWdzW21hcFRhZ10gPVxuY2xvbmVhYmxlVGFnc1tudW1iZXJUYWddID0gY2xvbmVhYmxlVGFnc1tvYmplY3RUYWddID1cbmNsb25lYWJsZVRhZ3NbcmVnZXhwVGFnXSA9IGNsb25lYWJsZVRhZ3Nbc2V0VGFnXSA9XG5jbG9uZWFibGVUYWdzW3N0cmluZ1RhZ10gPSBjbG9uZWFibGVUYWdzW3N5bWJvbFRhZ10gPVxuY2xvbmVhYmxlVGFnc1t1aW50OFRhZ10gPSBjbG9uZWFibGVUYWdzW3VpbnQ4Q2xhbXBlZFRhZ10gPVxuY2xvbmVhYmxlVGFnc1t1aW50MTZUYWddID0gY2xvbmVhYmxlVGFnc1t1aW50MzJUYWddID0gdHJ1ZTtcbmNsb25lYWJsZVRhZ3NbZXJyb3JUYWddID0gY2xvbmVhYmxlVGFnc1tmdW5jVGFnXSA9XG5jbG9uZWFibGVUYWdzW3dlYWtNYXBUYWddID0gZmFsc2U7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uY2xvbmVgIGFuZCBgXy5jbG9uZURlZXBgIHdoaWNoIHRyYWNrc1xuICogdHJhdmVyc2VkIG9iamVjdHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNsb25lLlxuICogQHBhcmFtIHtib29sZWFufSBiaXRtYXNrIFRoZSBiaXRtYXNrIGZsYWdzLlxuICogIDEgLSBEZWVwIGNsb25lXG4gKiAgMiAtIEZsYXR0ZW4gaW5oZXJpdGVkIHByb3BlcnRpZXNcbiAqICA0IC0gQ2xvbmUgc3ltYm9sc1xuICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY2xvbmluZy5cbiAqIEBwYXJhbSB7c3RyaW5nfSBba2V5XSBUaGUga2V5IG9mIGB2YWx1ZWAuXG4gKiBAcGFyYW0ge09iamVjdH0gW29iamVjdF0gVGhlIHBhcmVudCBvYmplY3Qgb2YgYHZhbHVlYC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbc3RhY2tdIFRyYWNrcyB0cmF2ZXJzZWQgb2JqZWN0cyBhbmQgdGhlaXIgY2xvbmUgY291bnRlcnBhcnRzLlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGNsb25lZCB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gYmFzZUNsb25lKHZhbHVlLCBiaXRtYXNrLCBjdXN0b21pemVyLCBrZXksIG9iamVjdCwgc3RhY2spIHtcbiAgdmFyIHJlc3VsdCxcbiAgICAgIGlzRGVlcCA9IGJpdG1hc2sgJiBDTE9ORV9ERUVQX0ZMQUcsXG4gICAgICBpc0ZsYXQgPSBiaXRtYXNrICYgQ0xPTkVfRkxBVF9GTEFHLFxuICAgICAgaXNGdWxsID0gYml0bWFzayAmIENMT05FX1NZTUJPTFNfRkxBRztcblxuICBpZiAoY3VzdG9taXplcikge1xuICAgIHJlc3VsdCA9IG9iamVjdCA/IGN1c3RvbWl6ZXIodmFsdWUsIGtleSwgb2JqZWN0LCBzdGFjaykgOiBjdXN0b21pemVyKHZhbHVlKTtcbiAgfVxuICBpZiAocmVzdWx0ICE9PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIGlmICghaXNPYmplY3QodmFsdWUpKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIHZhciBpc0FyciA9IGlzQXJyYXkodmFsdWUpO1xuICBpZiAoaXNBcnIpIHtcbiAgICByZXN1bHQgPSBpbml0Q2xvbmVBcnJheSh2YWx1ZSk7XG4gICAgaWYgKCFpc0RlZXApIHtcbiAgICAgIHJldHVybiBjb3B5QXJyYXkodmFsdWUsIHJlc3VsdCk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhciB0YWcgPSBnZXRUYWcodmFsdWUpLFxuICAgICAgICBpc0Z1bmMgPSB0YWcgPT0gZnVuY1RhZyB8fCB0YWcgPT0gZ2VuVGFnO1xuXG4gICAgaWYgKGlzQnVmZmVyKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIGNsb25lQnVmZmVyKHZhbHVlLCBpc0RlZXApO1xuICAgIH1cbiAgICBpZiAodGFnID09IG9iamVjdFRhZyB8fCB0YWcgPT0gYXJnc1RhZyB8fCAoaXNGdW5jICYmICFvYmplY3QpKSB7XG4gICAgICByZXN1bHQgPSAoaXNGbGF0IHx8IGlzRnVuYykgPyB7fSA6IGluaXRDbG9uZU9iamVjdCh2YWx1ZSk7XG4gICAgICBpZiAoIWlzRGVlcCkge1xuICAgICAgICByZXR1cm4gaXNGbGF0XG4gICAgICAgICAgPyBjb3B5U3ltYm9sc0luKHZhbHVlLCBiYXNlQXNzaWduSW4ocmVzdWx0LCB2YWx1ZSkpXG4gICAgICAgICAgOiBjb3B5U3ltYm9scyh2YWx1ZSwgYmFzZUFzc2lnbihyZXN1bHQsIHZhbHVlKSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICghY2xvbmVhYmxlVGFnc1t0YWddKSB7XG4gICAgICAgIHJldHVybiBvYmplY3QgPyB2YWx1ZSA6IHt9O1xuICAgICAgfVxuICAgICAgcmVzdWx0ID0gaW5pdENsb25lQnlUYWcodmFsdWUsIHRhZywgaXNEZWVwKTtcbiAgICB9XG4gIH1cbiAgLy8gQ2hlY2sgZm9yIGNpcmN1bGFyIHJlZmVyZW5jZXMgYW5kIHJldHVybiBpdHMgY29ycmVzcG9uZGluZyBjbG9uZS5cbiAgc3RhY2sgfHwgKHN0YWNrID0gbmV3IFN0YWNrKTtcbiAgdmFyIHN0YWNrZWQgPSBzdGFjay5nZXQodmFsdWUpO1xuICBpZiAoc3RhY2tlZCkge1xuICAgIHJldHVybiBzdGFja2VkO1xuICB9XG4gIHN0YWNrLnNldCh2YWx1ZSwgcmVzdWx0KTtcblxuICBpZiAoaXNTZXQodmFsdWUpKSB7XG4gICAgdmFsdWUuZm9yRWFjaChmdW5jdGlvbihzdWJWYWx1ZSkge1xuICAgICAgcmVzdWx0LmFkZChiYXNlQ2xvbmUoc3ViVmFsdWUsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIHN1YlZhbHVlLCB2YWx1ZSwgc3RhY2spKTtcbiAgICB9KTtcbiAgfSBlbHNlIGlmIChpc01hcCh2YWx1ZSkpIHtcbiAgICB2YWx1ZS5mb3JFYWNoKGZ1bmN0aW9uKHN1YlZhbHVlLCBrZXkpIHtcbiAgICAgIHJlc3VsdC5zZXQoa2V5LCBiYXNlQ2xvbmUoc3ViVmFsdWUsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGtleSwgdmFsdWUsIHN0YWNrKSk7XG4gICAgfSk7XG4gIH1cblxuICB2YXIga2V5c0Z1bmMgPSBpc0Z1bGxcbiAgICA/IChpc0ZsYXQgPyBnZXRBbGxLZXlzSW4gOiBnZXRBbGxLZXlzKVxuICAgIDogKGlzRmxhdCA/IGtleXNJbiA6IGtleXMpO1xuXG4gIHZhciBwcm9wcyA9IGlzQXJyID8gdW5kZWZpbmVkIDoga2V5c0Z1bmModmFsdWUpO1xuICBhcnJheUVhY2gocHJvcHMgfHwgdmFsdWUsIGZ1bmN0aW9uKHN1YlZhbHVlLCBrZXkpIHtcbiAgICBpZiAocHJvcHMpIHtcbiAgICAgIGtleSA9IHN1YlZhbHVlO1xuICAgICAgc3ViVmFsdWUgPSB2YWx1ZVtrZXldO1xuICAgIH1cbiAgICAvLyBSZWN1cnNpdmVseSBwb3B1bGF0ZSBjbG9uZSAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpLlxuICAgIGFzc2lnblZhbHVlKHJlc3VsdCwga2V5LCBiYXNlQ2xvbmUoc3ViVmFsdWUsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGtleSwgdmFsdWUsIHN0YWNrKSk7XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VDbG9uZTtcbiIsInZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vaXNPYmplY3QnKTtcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0Q3JlYXRlID0gT2JqZWN0LmNyZWF0ZTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5jcmVhdGVgIHdpdGhvdXQgc3VwcG9ydCBmb3IgYXNzaWduaW5nXG4gKiBwcm9wZXJ0aWVzIHRvIHRoZSBjcmVhdGVkIG9iamVjdC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IHByb3RvIFRoZSBvYmplY3QgdG8gaW5oZXJpdCBmcm9tLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IG9iamVjdC5cbiAqL1xudmFyIGJhc2VDcmVhdGUgPSAoZnVuY3Rpb24oKSB7XG4gIGZ1bmN0aW9uIG9iamVjdCgpIHt9XG4gIHJldHVybiBmdW5jdGlvbihwcm90bykge1xuICAgIGlmICghaXNPYmplY3QocHJvdG8pKSB7XG4gICAgICByZXR1cm4ge307XG4gICAgfVxuICAgIGlmIChvYmplY3RDcmVhdGUpIHtcbiAgICAgIHJldHVybiBvYmplY3RDcmVhdGUocHJvdG8pO1xuICAgIH1cbiAgICBvYmplY3QucHJvdG90eXBlID0gcHJvdG87XG4gICAgdmFyIHJlc3VsdCA9IG5ldyBvYmplY3Q7XG4gICAgb2JqZWN0LnByb3RvdHlwZSA9IHVuZGVmaW5lZDtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xufSgpKTtcblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlQ3JlYXRlO1xuIiwidmFyIGJhc2VGb3JPd24gPSByZXF1aXJlKCcuL19iYXNlRm9yT3duJyksXG4gICAgY3JlYXRlQmFzZUVhY2ggPSByZXF1aXJlKCcuL19jcmVhdGVCYXNlRWFjaCcpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmZvckVhY2hgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtBcnJheXxPYmplY3R9IFJldHVybnMgYGNvbGxlY3Rpb25gLlxuICovXG52YXIgYmFzZUVhY2ggPSBjcmVhdGVCYXNlRWFjaChiYXNlRm9yT3duKTtcblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlRWFjaDtcbiIsInZhciBpc1N5bWJvbCA9IHJlcXVpcmUoJy4vaXNTeW1ib2wnKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBtZXRob2RzIGxpa2UgYF8ubWF4YCBhbmQgYF8ubWluYCB3aGljaCBhY2NlcHRzIGFcbiAqIGBjb21wYXJhdG9yYCB0byBkZXRlcm1pbmUgdGhlIGV4dHJlbXVtIHZhbHVlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGl0ZXJhdGVlIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNvbXBhcmF0b3IgVGhlIGNvbXBhcmF0b3IgdXNlZCB0byBjb21wYXJlIHZhbHVlcy5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBleHRyZW11bSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gYmFzZUV4dHJlbXVtKGFycmF5LCBpdGVyYXRlZSwgY29tcGFyYXRvcikge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciB2YWx1ZSA9IGFycmF5W2luZGV4XSxcbiAgICAgICAgY3VycmVudCA9IGl0ZXJhdGVlKHZhbHVlKTtcblxuICAgIGlmIChjdXJyZW50ICE9IG51bGwgJiYgKGNvbXB1dGVkID09PSB1bmRlZmluZWRcbiAgICAgICAgICA/IChjdXJyZW50ID09PSBjdXJyZW50ICYmICFpc1N5bWJvbChjdXJyZW50KSlcbiAgICAgICAgICA6IGNvbXBhcmF0b3IoY3VycmVudCwgY29tcHV0ZWQpXG4gICAgICAgICkpIHtcbiAgICAgIHZhciBjb21wdXRlZCA9IGN1cnJlbnQsXG4gICAgICAgICAgcmVzdWx0ID0gdmFsdWU7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUV4dHJlbXVtO1xuIiwidmFyIGJhc2VFYWNoID0gcmVxdWlyZSgnLi9fYmFzZUVhY2gnKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5maWx0ZXJgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gcHJlZGljYXRlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBmaWx0ZXJlZCBhcnJheS5cbiAqL1xuZnVuY3Rpb24gYmFzZUZpbHRlcihjb2xsZWN0aW9uLCBwcmVkaWNhdGUpIHtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuICBiYXNlRWFjaChjb2xsZWN0aW9uLCBmdW5jdGlvbih2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pIHtcbiAgICBpZiAocHJlZGljYXRlKHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbikpIHtcbiAgICAgIHJlc3VsdC5wdXNoKHZhbHVlKTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VGaWx0ZXI7XG4iLCIvKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmZpbmRJbmRleGAgYW5kIGBfLmZpbmRMYXN0SW5kZXhgIHdpdGhvdXRcbiAqIHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICogQHBhcmFtIHtGdW5jdGlvbn0gcHJlZGljYXRlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcGFyYW0ge251bWJlcn0gZnJvbUluZGV4IFRoZSBpbmRleCB0byBzZWFyY2ggZnJvbS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2Zyb21SaWdodF0gU3BlY2lmeSBpdGVyYXRpbmcgZnJvbSByaWdodCB0byBsZWZ0LlxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIG1hdGNoZWQgdmFsdWUsIGVsc2UgYC0xYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUZpbmRJbmRleChhcnJheSwgcHJlZGljYXRlLCBmcm9tSW5kZXgsIGZyb21SaWdodCkge1xuICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoLFxuICAgICAgaW5kZXggPSBmcm9tSW5kZXggKyAoZnJvbVJpZ2h0ID8gMSA6IC0xKTtcblxuICB3aGlsZSAoKGZyb21SaWdodCA/IGluZGV4LS0gOiArK2luZGV4IDwgbGVuZ3RoKSkge1xuICAgIGlmIChwcmVkaWNhdGUoYXJyYXlbaW5kZXhdLCBpbmRleCwgYXJyYXkpKSB7XG4gICAgICByZXR1cm4gaW5kZXg7XG4gICAgfVxuICB9XG4gIHJldHVybiAtMTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlRmluZEluZGV4O1xuIiwidmFyIGFycmF5UHVzaCA9IHJlcXVpcmUoJy4vX2FycmF5UHVzaCcpLFxuICAgIGlzRmxhdHRlbmFibGUgPSByZXF1aXJlKCcuL19pc0ZsYXR0ZW5hYmxlJyk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZmxhdHRlbmAgd2l0aCBzdXBwb3J0IGZvciByZXN0cmljdGluZyBmbGF0dGVuaW5nLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gZmxhdHRlbi5cbiAqIEBwYXJhbSB7bnVtYmVyfSBkZXB0aCBUaGUgbWF4aW11bSByZWN1cnNpb24gZGVwdGguXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtwcmVkaWNhdGU9aXNGbGF0dGVuYWJsZV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzU3RyaWN0XSBSZXN0cmljdCB0byB2YWx1ZXMgdGhhdCBwYXNzIGBwcmVkaWNhdGVgIGNoZWNrcy5cbiAqIEBwYXJhbSB7QXJyYXl9IFtyZXN1bHQ9W11dIFRoZSBpbml0aWFsIHJlc3VsdCB2YWx1ZS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGZsYXR0ZW5lZCBhcnJheS5cbiAqL1xuZnVuY3Rpb24gYmFzZUZsYXR0ZW4oYXJyYXksIGRlcHRoLCBwcmVkaWNhdGUsIGlzU3RyaWN0LCByZXN1bHQpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG5cbiAgcHJlZGljYXRlIHx8IChwcmVkaWNhdGUgPSBpc0ZsYXR0ZW5hYmxlKTtcbiAgcmVzdWx0IHx8IChyZXN1bHQgPSBbXSk7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIgdmFsdWUgPSBhcnJheVtpbmRleF07XG4gICAgaWYgKGRlcHRoID4gMCAmJiBwcmVkaWNhdGUodmFsdWUpKSB7XG4gICAgICBpZiAoZGVwdGggPiAxKSB7XG4gICAgICAgIC8vIFJlY3Vyc2l2ZWx5IGZsYXR0ZW4gYXJyYXlzIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cykuXG4gICAgICAgIGJhc2VGbGF0dGVuKHZhbHVlLCBkZXB0aCAtIDEsIHByZWRpY2F0ZSwgaXNTdHJpY3QsIHJlc3VsdCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhcnJheVB1c2gocmVzdWx0LCB2YWx1ZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICghaXNTdHJpY3QpIHtcbiAgICAgIHJlc3VsdFtyZXN1bHQubGVuZ3RoXSA9IHZhbHVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VGbGF0dGVuO1xuIiwidmFyIGNyZWF0ZUJhc2VGb3IgPSByZXF1aXJlKCcuL19jcmVhdGVCYXNlRm9yJyk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYGJhc2VGb3JPd25gIHdoaWNoIGl0ZXJhdGVzIG92ZXIgYG9iamVjdGBcbiAqIHByb3BlcnRpZXMgcmV0dXJuZWQgYnkgYGtleXNGdW5jYCBhbmQgaW52b2tlcyBgaXRlcmF0ZWVgIGZvciBlYWNoIHByb3BlcnR5LlxuICogSXRlcmF0ZWUgZnVuY3Rpb25zIG1heSBleGl0IGl0ZXJhdGlvbiBlYXJseSBieSBleHBsaWNpdGx5IHJldHVybmluZyBgZmFsc2VgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGtleXNGdW5jIFRoZSBmdW5jdGlvbiB0byBnZXQgdGhlIGtleXMgb2YgYG9iamVjdGAuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICovXG52YXIgYmFzZUZvciA9IGNyZWF0ZUJhc2VGb3IoKTtcblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlRm9yO1xuIiwidmFyIGJhc2VGb3IgPSByZXF1aXJlKCcuL19iYXNlRm9yJyksXG4gICAga2V5cyA9IHJlcXVpcmUoJy4va2V5cycpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmZvck93bmAgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VGb3JPd24ob2JqZWN0LCBpdGVyYXRlZSkge1xuICByZXR1cm4gb2JqZWN0ICYmIGJhc2VGb3Iob2JqZWN0LCBpdGVyYXRlZSwga2V5cyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUZvck93bjtcbiIsInZhciBjYXN0UGF0aCA9IHJlcXVpcmUoJy4vX2Nhc3RQYXRoJyksXG4gICAgdG9LZXkgPSByZXF1aXJlKCcuL190b0tleScpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmdldGAgd2l0aG91dCBzdXBwb3J0IGZvciBkZWZhdWx0IHZhbHVlcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSByZXNvbHZlZCB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gYmFzZUdldChvYmplY3QsIHBhdGgpIHtcbiAgcGF0aCA9IGNhc3RQYXRoKHBhdGgsIG9iamVjdCk7XG5cbiAgdmFyIGluZGV4ID0gMCxcbiAgICAgIGxlbmd0aCA9IHBhdGgubGVuZ3RoO1xuXG4gIHdoaWxlIChvYmplY3QgIT0gbnVsbCAmJiBpbmRleCA8IGxlbmd0aCkge1xuICAgIG9iamVjdCA9IG9iamVjdFt0b0tleShwYXRoW2luZGV4KytdKV07XG4gIH1cbiAgcmV0dXJuIChpbmRleCAmJiBpbmRleCA9PSBsZW5ndGgpID8gb2JqZWN0IDogdW5kZWZpbmVkO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VHZXQ7XG4iLCJ2YXIgYXJyYXlQdXNoID0gcmVxdWlyZSgnLi9fYXJyYXlQdXNoJyksXG4gICAgaXNBcnJheSA9IHJlcXVpcmUoJy4vaXNBcnJheScpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBnZXRBbGxLZXlzYCBhbmQgYGdldEFsbEtleXNJbmAgd2hpY2ggdXNlc1xuICogYGtleXNGdW5jYCBhbmQgYHN5bWJvbHNGdW5jYCB0byBnZXQgdGhlIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgYW5kXG4gKiBzeW1ib2xzIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBrZXlzRnVuYyBUaGUgZnVuY3Rpb24gdG8gZ2V0IHRoZSBrZXlzIG9mIGBvYmplY3RgLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gc3ltYm9sc0Z1bmMgVGhlIGZ1bmN0aW9uIHRvIGdldCB0aGUgc3ltYm9scyBvZiBgb2JqZWN0YC5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMgYW5kIHN5bWJvbHMuXG4gKi9cbmZ1bmN0aW9uIGJhc2VHZXRBbGxLZXlzKG9iamVjdCwga2V5c0Z1bmMsIHN5bWJvbHNGdW5jKSB7XG4gIHZhciByZXN1bHQgPSBrZXlzRnVuYyhvYmplY3QpO1xuICByZXR1cm4gaXNBcnJheShvYmplY3QpID8gcmVzdWx0IDogYXJyYXlQdXNoKHJlc3VsdCwgc3ltYm9sc0Z1bmMob2JqZWN0KSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUdldEFsbEtleXM7XG4iLCJ2YXIgU3ltYm9sID0gcmVxdWlyZSgnLi9fU3ltYm9sJyksXG4gICAgZ2V0UmF3VGFnID0gcmVxdWlyZSgnLi9fZ2V0UmF3VGFnJyksXG4gICAgb2JqZWN0VG9TdHJpbmcgPSByZXF1aXJlKCcuL19vYmplY3RUb1N0cmluZycpO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgbnVsbFRhZyA9ICdbb2JqZWN0IE51bGxdJyxcbiAgICB1bmRlZmluZWRUYWcgPSAnW29iamVjdCBVbmRlZmluZWRdJztcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgc3ltVG9TdHJpbmdUYWcgPSBTeW1ib2wgPyBTeW1ib2wudG9TdHJpbmdUYWcgOiB1bmRlZmluZWQ7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYGdldFRhZ2Agd2l0aG91dCBmYWxsYmFja3MgZm9yIGJ1Z2d5IGVudmlyb25tZW50cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBgdG9TdHJpbmdUYWdgLlxuICovXG5mdW5jdGlvbiBiYXNlR2V0VGFnKHZhbHVlKSB7XG4gIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgcmV0dXJuIHZhbHVlID09PSB1bmRlZmluZWQgPyB1bmRlZmluZWRUYWcgOiBudWxsVGFnO1xuICB9XG4gIHJldHVybiAoc3ltVG9TdHJpbmdUYWcgJiYgc3ltVG9TdHJpbmdUYWcgaW4gT2JqZWN0KHZhbHVlKSlcbiAgICA/IGdldFJhd1RhZyh2YWx1ZSlcbiAgICA6IG9iamVjdFRvU3RyaW5nKHZhbHVlKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlR2V0VGFnO1xuIiwiLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5ndGAgd2hpY2ggZG9lc24ndCBjb2VyY2UgYXJndW1lbnRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb21wYXJlLlxuICogQHBhcmFtIHsqfSBvdGhlciBUaGUgb3RoZXIgdmFsdWUgdG8gY29tcGFyZS5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGdyZWF0ZXIgdGhhbiBgb3RoZXJgLFxuICogIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUd0KHZhbHVlLCBvdGhlcikge1xuICByZXR1cm4gdmFsdWUgPiBvdGhlcjtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlR3Q7XG4iLCIvKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmhhc2Agd2l0aG91dCBzdXBwb3J0IGZvciBkZWVwIHBhdGhzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gW29iamVjdF0gVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBrZXkgVGhlIGtleSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUhhcyhvYmplY3QsIGtleSkge1xuICByZXR1cm4gb2JqZWN0ICE9IG51bGwgJiYgaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIGtleSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUhhcztcbiIsIi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaGFzSW5gIHdpdGhvdXQgc3VwcG9ydCBmb3IgZGVlcCBwYXRocy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3RdIFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge0FycmF5fHN0cmluZ30ga2V5IFRoZSBrZXkgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VIYXNJbihvYmplY3QsIGtleSkge1xuICByZXR1cm4gb2JqZWN0ICE9IG51bGwgJiYga2V5IGluIE9iamVjdChvYmplY3QpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VIYXNJbjtcbiIsInZhciBiYXNlRmluZEluZGV4ID0gcmVxdWlyZSgnLi9fYmFzZUZpbmRJbmRleCcpLFxuICAgIGJhc2VJc05hTiA9IHJlcXVpcmUoJy4vX2Jhc2VJc05hTicpLFxuICAgIHN0cmljdEluZGV4T2YgPSByZXF1aXJlKCcuL19zdHJpY3RJbmRleE9mJyk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaW5kZXhPZmAgd2l0aG91dCBgZnJvbUluZGV4YCBib3VuZHMgY2hlY2tzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNlYXJjaCBmb3IuXG4gKiBAcGFyYW0ge251bWJlcn0gZnJvbUluZGV4IFRoZSBpbmRleCB0byBzZWFyY2ggZnJvbS5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBtYXRjaGVkIHZhbHVlLCBlbHNlIGAtMWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VJbmRleE9mKGFycmF5LCB2YWx1ZSwgZnJvbUluZGV4KSB7XG4gIHJldHVybiB2YWx1ZSA9PT0gdmFsdWVcbiAgICA/IHN0cmljdEluZGV4T2YoYXJyYXksIHZhbHVlLCBmcm9tSW5kZXgpXG4gICAgOiBiYXNlRmluZEluZGV4KGFycmF5LCBiYXNlSXNOYU4sIGZyb21JbmRleCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUluZGV4T2Y7XG4iLCJ2YXIgYmFzZUdldFRhZyA9IHJlcXVpcmUoJy4vX2Jhc2VHZXRUYWcnKSxcbiAgICBpc09iamVjdExpa2UgPSByZXF1aXJlKCcuL2lzT2JqZWN0TGlrZScpO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgYXJnc1RhZyA9ICdbb2JqZWN0IEFyZ3VtZW50c10nO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzQXJndW1lbnRzYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBgYXJndW1lbnRzYCBvYmplY3QsXG4gKi9cbmZ1bmN0aW9uIGJhc2VJc0FyZ3VtZW50cyh2YWx1ZSkge1xuICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBiYXNlR2V0VGFnKHZhbHVlKSA9PSBhcmdzVGFnO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VJc0FyZ3VtZW50cztcbiIsInZhciBiYXNlSXNFcXVhbERlZXAgPSByZXF1aXJlKCcuL19iYXNlSXNFcXVhbERlZXAnKSxcbiAgICBpc09iamVjdExpa2UgPSByZXF1aXJlKCcuL2lzT2JqZWN0TGlrZScpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzRXF1YWxgIHdoaWNoIHN1cHBvcnRzIHBhcnRpYWwgY29tcGFyaXNvbnNcbiAqIGFuZCB0cmFja3MgdHJhdmVyc2VkIG9iamVjdHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0geyp9IG90aGVyIFRoZSBvdGhlciB2YWx1ZSB0byBjb21wYXJlLlxuICogQHBhcmFtIHtib29sZWFufSBiaXRtYXNrIFRoZSBiaXRtYXNrIGZsYWdzLlxuICogIDEgLSBVbm9yZGVyZWQgY29tcGFyaXNvblxuICogIDIgLSBQYXJ0aWFsIGNvbXBhcmlzb25cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmlzb25zLlxuICogQHBhcmFtIHtPYmplY3R9IFtzdGFja10gVHJhY2tzIHRyYXZlcnNlZCBgdmFsdWVgIGFuZCBgb3RoZXJgIG9iamVjdHMuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHZhbHVlcyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBiYXNlSXNFcXVhbCh2YWx1ZSwgb3RoZXIsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIHN0YWNrKSB7XG4gIGlmICh2YWx1ZSA9PT0gb3RoZXIpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAodmFsdWUgPT0gbnVsbCB8fCBvdGhlciA9PSBudWxsIHx8ICghaXNPYmplY3RMaWtlKHZhbHVlKSAmJiAhaXNPYmplY3RMaWtlKG90aGVyKSkpIHtcbiAgICByZXR1cm4gdmFsdWUgIT09IHZhbHVlICYmIG90aGVyICE9PSBvdGhlcjtcbiAgfVxuICByZXR1cm4gYmFzZUlzRXF1YWxEZWVwKHZhbHVlLCBvdGhlciwgYml0bWFzaywgY3VzdG9taXplciwgYmFzZUlzRXF1YWwsIHN0YWNrKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlSXNFcXVhbDtcbiIsInZhciBTdGFjayA9IHJlcXVpcmUoJy4vX1N0YWNrJyksXG4gICAgZXF1YWxBcnJheXMgPSByZXF1aXJlKCcuL19lcXVhbEFycmF5cycpLFxuICAgIGVxdWFsQnlUYWcgPSByZXF1aXJlKCcuL19lcXVhbEJ5VGFnJyksXG4gICAgZXF1YWxPYmplY3RzID0gcmVxdWlyZSgnLi9fZXF1YWxPYmplY3RzJyksXG4gICAgZ2V0VGFnID0gcmVxdWlyZSgnLi9fZ2V0VGFnJyksXG4gICAgaXNBcnJheSA9IHJlcXVpcmUoJy4vaXNBcnJheScpLFxuICAgIGlzQnVmZmVyID0gcmVxdWlyZSgnLi9pc0J1ZmZlcicpLFxuICAgIGlzVHlwZWRBcnJheSA9IHJlcXVpcmUoJy4vaXNUeXBlZEFycmF5Jyk7XG5cbi8qKiBVc2VkIHRvIGNvbXBvc2UgYml0bWFza3MgZm9yIHZhbHVlIGNvbXBhcmlzb25zLiAqL1xudmFyIENPTVBBUkVfUEFSVElBTF9GTEFHID0gMTtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIGFyZ3NUYWcgPSAnW29iamVjdCBBcmd1bWVudHNdJyxcbiAgICBhcnJheVRhZyA9ICdbb2JqZWN0IEFycmF5XScsXG4gICAgb2JqZWN0VGFnID0gJ1tvYmplY3QgT2JqZWN0XSc7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlSXNFcXVhbGAgZm9yIGFycmF5cyBhbmQgb2JqZWN0cyB3aGljaCBwZXJmb3Jtc1xuICogZGVlcCBjb21wYXJpc29ucyBhbmQgdHJhY2tzIHRyYXZlcnNlZCBvYmplY3RzIGVuYWJsaW5nIG9iamVjdHMgd2l0aCBjaXJjdWxhclxuICogcmVmZXJlbmNlcyB0byBiZSBjb21wYXJlZC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge09iamVjdH0gb3RoZXIgVGhlIG90aGVyIG9iamVjdCB0byBjb21wYXJlLlxuICogQHBhcmFtIHtudW1iZXJ9IGJpdG1hc2sgVGhlIGJpdG1hc2sgZmxhZ3MuIFNlZSBgYmFzZUlzRXF1YWxgIGZvciBtb3JlIGRldGFpbHMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjdXN0b21pemVyIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29tcGFyaXNvbnMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBlcXVhbEZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGRldGVybWluZSBlcXVpdmFsZW50cyBvZiB2YWx1ZXMuXG4gKiBAcGFyYW0ge09iamVjdH0gW3N0YWNrXSBUcmFja3MgdHJhdmVyc2VkIGBvYmplY3RgIGFuZCBgb3RoZXJgIG9iamVjdHMuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIG9iamVjdHMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUlzRXF1YWxEZWVwKG9iamVjdCwgb3RoZXIsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGVxdWFsRnVuYywgc3RhY2spIHtcbiAgdmFyIG9iaklzQXJyID0gaXNBcnJheShvYmplY3QpLFxuICAgICAgb3RoSXNBcnIgPSBpc0FycmF5KG90aGVyKSxcbiAgICAgIG9ialRhZyA9IG9iaklzQXJyID8gYXJyYXlUYWcgOiBnZXRUYWcob2JqZWN0KSxcbiAgICAgIG90aFRhZyA9IG90aElzQXJyID8gYXJyYXlUYWcgOiBnZXRUYWcob3RoZXIpO1xuXG4gIG9ialRhZyA9IG9ialRhZyA9PSBhcmdzVGFnID8gb2JqZWN0VGFnIDogb2JqVGFnO1xuICBvdGhUYWcgPSBvdGhUYWcgPT0gYXJnc1RhZyA/IG9iamVjdFRhZyA6IG90aFRhZztcblxuICB2YXIgb2JqSXNPYmogPSBvYmpUYWcgPT0gb2JqZWN0VGFnLFxuICAgICAgb3RoSXNPYmogPSBvdGhUYWcgPT0gb2JqZWN0VGFnLFxuICAgICAgaXNTYW1lVGFnID0gb2JqVGFnID09IG90aFRhZztcblxuICBpZiAoaXNTYW1lVGFnICYmIGlzQnVmZmVyKG9iamVjdCkpIHtcbiAgICBpZiAoIWlzQnVmZmVyKG90aGVyKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBvYmpJc0FyciA9IHRydWU7XG4gICAgb2JqSXNPYmogPSBmYWxzZTtcbiAgfVxuICBpZiAoaXNTYW1lVGFnICYmICFvYmpJc09iaikge1xuICAgIHN0YWNrIHx8IChzdGFjayA9IG5ldyBTdGFjayk7XG4gICAgcmV0dXJuIChvYmpJc0FyciB8fCBpc1R5cGVkQXJyYXkob2JqZWN0KSlcbiAgICAgID8gZXF1YWxBcnJheXMob2JqZWN0LCBvdGhlciwgYml0bWFzaywgY3VzdG9taXplciwgZXF1YWxGdW5jLCBzdGFjaylcbiAgICAgIDogZXF1YWxCeVRhZyhvYmplY3QsIG90aGVyLCBvYmpUYWcsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGVxdWFsRnVuYywgc3RhY2spO1xuICB9XG4gIGlmICghKGJpdG1hc2sgJiBDT01QQVJFX1BBUlRJQUxfRkxBRykpIHtcbiAgICB2YXIgb2JqSXNXcmFwcGVkID0gb2JqSXNPYmogJiYgaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsICdfX3dyYXBwZWRfXycpLFxuICAgICAgICBvdGhJc1dyYXBwZWQgPSBvdGhJc09iaiAmJiBoYXNPd25Qcm9wZXJ0eS5jYWxsKG90aGVyLCAnX193cmFwcGVkX18nKTtcblxuICAgIGlmIChvYmpJc1dyYXBwZWQgfHwgb3RoSXNXcmFwcGVkKSB7XG4gICAgICB2YXIgb2JqVW53cmFwcGVkID0gb2JqSXNXcmFwcGVkID8gb2JqZWN0LnZhbHVlKCkgOiBvYmplY3QsXG4gICAgICAgICAgb3RoVW53cmFwcGVkID0gb3RoSXNXcmFwcGVkID8gb3RoZXIudmFsdWUoKSA6IG90aGVyO1xuXG4gICAgICBzdGFjayB8fCAoc3RhY2sgPSBuZXcgU3RhY2spO1xuICAgICAgcmV0dXJuIGVxdWFsRnVuYyhvYmpVbndyYXBwZWQsIG90aFVud3JhcHBlZCwgYml0bWFzaywgY3VzdG9taXplciwgc3RhY2spO1xuICAgIH1cbiAgfVxuICBpZiAoIWlzU2FtZVRhZykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBzdGFjayB8fCAoc3RhY2sgPSBuZXcgU3RhY2spO1xuICByZXR1cm4gZXF1YWxPYmplY3RzKG9iamVjdCwgb3RoZXIsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGVxdWFsRnVuYywgc3RhY2spO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VJc0VxdWFsRGVlcDtcbiIsInZhciBnZXRUYWcgPSByZXF1aXJlKCcuL19nZXRUYWcnKSxcbiAgICBpc09iamVjdExpa2UgPSByZXF1aXJlKCcuL2lzT2JqZWN0TGlrZScpO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgbWFwVGFnID0gJ1tvYmplY3QgTWFwXSc7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNNYXBgIHdpdGhvdXQgTm9kZS5qcyBvcHRpbWl6YXRpb25zLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgbWFwLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VJc01hcCh2YWx1ZSkge1xuICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBnZXRUYWcodmFsdWUpID09IG1hcFRhZztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlSXNNYXA7XG4iLCJ2YXIgU3RhY2sgPSByZXF1aXJlKCcuL19TdGFjaycpLFxuICAgIGJhc2VJc0VxdWFsID0gcmVxdWlyZSgnLi9fYmFzZUlzRXF1YWwnKTtcblxuLyoqIFVzZWQgdG8gY29tcG9zZSBiaXRtYXNrcyBmb3IgdmFsdWUgY29tcGFyaXNvbnMuICovXG52YXIgQ09NUEFSRV9QQVJUSUFMX0ZMQUcgPSAxLFxuICAgIENPTVBBUkVfVU5PUkRFUkVEX0ZMQUcgPSAyO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzTWF0Y2hgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGluc3BlY3QuXG4gKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBvYmplY3Qgb2YgcHJvcGVydHkgdmFsdWVzIHRvIG1hdGNoLlxuICogQHBhcmFtIHtBcnJheX0gbWF0Y2hEYXRhIFRoZSBwcm9wZXJ0eSBuYW1lcywgdmFsdWVzLCBhbmQgY29tcGFyZSBmbGFncyB0byBtYXRjaC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmlzb25zLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBvYmplY3RgIGlzIGEgbWF0Y2gsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUlzTWF0Y2gob2JqZWN0LCBzb3VyY2UsIG1hdGNoRGF0YSwgY3VzdG9taXplcikge1xuICB2YXIgaW5kZXggPSBtYXRjaERhdGEubGVuZ3RoLFxuICAgICAgbGVuZ3RoID0gaW5kZXgsXG4gICAgICBub0N1c3RvbWl6ZXIgPSAhY3VzdG9taXplcjtcblxuICBpZiAob2JqZWN0ID09IG51bGwpIHtcbiAgICByZXR1cm4gIWxlbmd0aDtcbiAgfVxuICBvYmplY3QgPSBPYmplY3Qob2JqZWN0KTtcbiAgd2hpbGUgKGluZGV4LS0pIHtcbiAgICB2YXIgZGF0YSA9IG1hdGNoRGF0YVtpbmRleF07XG4gICAgaWYgKChub0N1c3RvbWl6ZXIgJiYgZGF0YVsyXSlcbiAgICAgICAgICA/IGRhdGFbMV0gIT09IG9iamVjdFtkYXRhWzBdXVxuICAgICAgICAgIDogIShkYXRhWzBdIGluIG9iamVjdClcbiAgICAgICAgKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgZGF0YSA9IG1hdGNoRGF0YVtpbmRleF07XG4gICAgdmFyIGtleSA9IGRhdGFbMF0sXG4gICAgICAgIG9ialZhbHVlID0gb2JqZWN0W2tleV0sXG4gICAgICAgIHNyY1ZhbHVlID0gZGF0YVsxXTtcblxuICAgIGlmIChub0N1c3RvbWl6ZXIgJiYgZGF0YVsyXSkge1xuICAgICAgaWYgKG9ialZhbHVlID09PSB1bmRlZmluZWQgJiYgIShrZXkgaW4gb2JqZWN0KSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBzdGFjayA9IG5ldyBTdGFjaztcbiAgICAgIGlmIChjdXN0b21pemVyKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBjdXN0b21pemVyKG9ialZhbHVlLCBzcmNWYWx1ZSwga2V5LCBvYmplY3QsIHNvdXJjZSwgc3RhY2spO1xuICAgICAgfVxuICAgICAgaWYgKCEocmVzdWx0ID09PSB1bmRlZmluZWRcbiAgICAgICAgICAgID8gYmFzZUlzRXF1YWwoc3JjVmFsdWUsIG9ialZhbHVlLCBDT01QQVJFX1BBUlRJQUxfRkxBRyB8IENPTVBBUkVfVU5PUkRFUkVEX0ZMQUcsIGN1c3RvbWl6ZXIsIHN0YWNrKVxuICAgICAgICAgICAgOiByZXN1bHRcbiAgICAgICAgICApKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUlzTWF0Y2g7XG4iLCIvKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzTmFOYCB3aXRob3V0IHN1cHBvcnQgZm9yIG51bWJlciBvYmplY3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGBOYU5gLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VJc05hTih2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgIT09IHZhbHVlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VJc05hTjtcbiIsInZhciBpc0Z1bmN0aW9uID0gcmVxdWlyZSgnLi9pc0Z1bmN0aW9uJyksXG4gICAgaXNNYXNrZWQgPSByZXF1aXJlKCcuL19pc01hc2tlZCcpLFxuICAgIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9pc09iamVjdCcpLFxuICAgIHRvU291cmNlID0gcmVxdWlyZSgnLi9fdG9Tb3VyY2UnKTtcblxuLyoqXG4gKiBVc2VkIHRvIG1hdGNoIGBSZWdFeHBgXG4gKiBbc3ludGF4IGNoYXJhY3RlcnNdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXBhdHRlcm5zKS5cbiAqL1xudmFyIHJlUmVnRXhwQ2hhciA9IC9bXFxcXF4kLiorPygpW1xcXXt9fF0vZztcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IGhvc3QgY29uc3RydWN0b3JzIChTYWZhcmkpLiAqL1xudmFyIHJlSXNIb3N0Q3RvciA9IC9eXFxbb2JqZWN0IC4rP0NvbnN0cnVjdG9yXFxdJC87XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBmdW5jUHJvdG8gPSBGdW5jdGlvbi5wcm90b3R5cGUsXG4gICAgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byByZXNvbHZlIHRoZSBkZWNvbXBpbGVkIHNvdXJjZSBvZiBmdW5jdGlvbnMuICovXG52YXIgZnVuY1RvU3RyaW5nID0gZnVuY1Byb3RvLnRvU3RyaW5nO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKiogVXNlZCB0byBkZXRlY3QgaWYgYSBtZXRob2QgaXMgbmF0aXZlLiAqL1xudmFyIHJlSXNOYXRpdmUgPSBSZWdFeHAoJ14nICtcbiAgZnVuY1RvU3RyaW5nLmNhbGwoaGFzT3duUHJvcGVydHkpLnJlcGxhY2UocmVSZWdFeHBDaGFyLCAnXFxcXCQmJylcbiAgLnJlcGxhY2UoL2hhc093blByb3BlcnR5fChmdW5jdGlvbikuKj8oPz1cXFxcXFwoKXwgZm9yIC4rPyg/PVxcXFxcXF0pL2csICckMS4qPycpICsgJyQnXG4pO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzTmF0aXZlYCB3aXRob3V0IGJhZCBzaGltIGNoZWNrcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIG5hdGl2ZSBmdW5jdGlvbixcbiAqICBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VJc05hdGl2ZSh2YWx1ZSkge1xuICBpZiAoIWlzT2JqZWN0KHZhbHVlKSB8fCBpc01hc2tlZCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIHBhdHRlcm4gPSBpc0Z1bmN0aW9uKHZhbHVlKSA/IHJlSXNOYXRpdmUgOiByZUlzSG9zdEN0b3I7XG4gIHJldHVybiBwYXR0ZXJuLnRlc3QodG9Tb3VyY2UodmFsdWUpKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlSXNOYXRpdmU7XG4iLCJ2YXIgZ2V0VGFnID0gcmVxdWlyZSgnLi9fZ2V0VGFnJyksXG4gICAgaXNPYmplY3RMaWtlID0gcmVxdWlyZSgnLi9pc09iamVjdExpa2UnKTtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIHNldFRhZyA9ICdbb2JqZWN0IFNldF0nO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzU2V0YCB3aXRob3V0IE5vZGUuanMgb3B0aW1pemF0aW9ucy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHNldCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBiYXNlSXNTZXQodmFsdWUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgZ2V0VGFnKHZhbHVlKSA9PSBzZXRUYWc7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUlzU2V0O1xuIiwidmFyIGJhc2VHZXRUYWcgPSByZXF1aXJlKCcuL19iYXNlR2V0VGFnJyksXG4gICAgaXNMZW5ndGggPSByZXF1aXJlKCcuL2lzTGVuZ3RoJyksXG4gICAgaXNPYmplY3RMaWtlID0gcmVxdWlyZSgnLi9pc09iamVjdExpa2UnKTtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIGFyZ3NUYWcgPSAnW29iamVjdCBBcmd1bWVudHNdJyxcbiAgICBhcnJheVRhZyA9ICdbb2JqZWN0IEFycmF5XScsXG4gICAgYm9vbFRhZyA9ICdbb2JqZWN0IEJvb2xlYW5dJyxcbiAgICBkYXRlVGFnID0gJ1tvYmplY3QgRGF0ZV0nLFxuICAgIGVycm9yVGFnID0gJ1tvYmplY3QgRXJyb3JdJyxcbiAgICBmdW5jVGFnID0gJ1tvYmplY3QgRnVuY3Rpb25dJyxcbiAgICBtYXBUYWcgPSAnW29iamVjdCBNYXBdJyxcbiAgICBudW1iZXJUYWcgPSAnW29iamVjdCBOdW1iZXJdJyxcbiAgICBvYmplY3RUYWcgPSAnW29iamVjdCBPYmplY3RdJyxcbiAgICByZWdleHBUYWcgPSAnW29iamVjdCBSZWdFeHBdJyxcbiAgICBzZXRUYWcgPSAnW29iamVjdCBTZXRdJyxcbiAgICBzdHJpbmdUYWcgPSAnW29iamVjdCBTdHJpbmddJyxcbiAgICB3ZWFrTWFwVGFnID0gJ1tvYmplY3QgV2Vha01hcF0nO1xuXG52YXIgYXJyYXlCdWZmZXJUYWcgPSAnW29iamVjdCBBcnJheUJ1ZmZlcl0nLFxuICAgIGRhdGFWaWV3VGFnID0gJ1tvYmplY3QgRGF0YVZpZXddJyxcbiAgICBmbG9hdDMyVGFnID0gJ1tvYmplY3QgRmxvYXQzMkFycmF5XScsXG4gICAgZmxvYXQ2NFRhZyA9ICdbb2JqZWN0IEZsb2F0NjRBcnJheV0nLFxuICAgIGludDhUYWcgPSAnW29iamVjdCBJbnQ4QXJyYXldJyxcbiAgICBpbnQxNlRhZyA9ICdbb2JqZWN0IEludDE2QXJyYXldJyxcbiAgICBpbnQzMlRhZyA9ICdbb2JqZWN0IEludDMyQXJyYXldJyxcbiAgICB1aW50OFRhZyA9ICdbb2JqZWN0IFVpbnQ4QXJyYXldJyxcbiAgICB1aW50OENsYW1wZWRUYWcgPSAnW29iamVjdCBVaW50OENsYW1wZWRBcnJheV0nLFxuICAgIHVpbnQxNlRhZyA9ICdbb2JqZWN0IFVpbnQxNkFycmF5XScsXG4gICAgdWludDMyVGFnID0gJ1tvYmplY3QgVWludDMyQXJyYXldJztcblxuLyoqIFVzZWQgdG8gaWRlbnRpZnkgYHRvU3RyaW5nVGFnYCB2YWx1ZXMgb2YgdHlwZWQgYXJyYXlzLiAqL1xudmFyIHR5cGVkQXJyYXlUYWdzID0ge307XG50eXBlZEFycmF5VGFnc1tmbG9hdDMyVGFnXSA9IHR5cGVkQXJyYXlUYWdzW2Zsb2F0NjRUYWddID1cbnR5cGVkQXJyYXlUYWdzW2ludDhUYWddID0gdHlwZWRBcnJheVRhZ3NbaW50MTZUYWddID1cbnR5cGVkQXJyYXlUYWdzW2ludDMyVGFnXSA9IHR5cGVkQXJyYXlUYWdzW3VpbnQ4VGFnXSA9XG50eXBlZEFycmF5VGFnc1t1aW50OENsYW1wZWRUYWddID0gdHlwZWRBcnJheVRhZ3NbdWludDE2VGFnXSA9XG50eXBlZEFycmF5VGFnc1t1aW50MzJUYWddID0gdHJ1ZTtcbnR5cGVkQXJyYXlUYWdzW2FyZ3NUYWddID0gdHlwZWRBcnJheVRhZ3NbYXJyYXlUYWddID1cbnR5cGVkQXJyYXlUYWdzW2FycmF5QnVmZmVyVGFnXSA9IHR5cGVkQXJyYXlUYWdzW2Jvb2xUYWddID1cbnR5cGVkQXJyYXlUYWdzW2RhdGFWaWV3VGFnXSA9IHR5cGVkQXJyYXlUYWdzW2RhdGVUYWddID1cbnR5cGVkQXJyYXlUYWdzW2Vycm9yVGFnXSA9IHR5cGVkQXJyYXlUYWdzW2Z1bmNUYWddID1cbnR5cGVkQXJyYXlUYWdzW21hcFRhZ10gPSB0eXBlZEFycmF5VGFnc1tudW1iZXJUYWddID1cbnR5cGVkQXJyYXlUYWdzW29iamVjdFRhZ10gPSB0eXBlZEFycmF5VGFnc1tyZWdleHBUYWddID1cbnR5cGVkQXJyYXlUYWdzW3NldFRhZ10gPSB0eXBlZEFycmF5VGFnc1tzdHJpbmdUYWddID1cbnR5cGVkQXJyYXlUYWdzW3dlYWtNYXBUYWddID0gZmFsc2U7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNUeXBlZEFycmF5YCB3aXRob3V0IE5vZGUuanMgb3B0aW1pemF0aW9ucy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHR5cGVkIGFycmF5LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VJc1R5cGVkQXJyYXkodmFsdWUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiZcbiAgICBpc0xlbmd0aCh2YWx1ZS5sZW5ndGgpICYmICEhdHlwZWRBcnJheVRhZ3NbYmFzZUdldFRhZyh2YWx1ZSldO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VJc1R5cGVkQXJyYXk7XG4iLCJ2YXIgYmFzZU1hdGNoZXMgPSByZXF1aXJlKCcuL19iYXNlTWF0Y2hlcycpLFxuICAgIGJhc2VNYXRjaGVzUHJvcGVydHkgPSByZXF1aXJlKCcuL19iYXNlTWF0Y2hlc1Byb3BlcnR5JyksXG4gICAgaWRlbnRpdHkgPSByZXF1aXJlKCcuL2lkZW50aXR5JyksXG4gICAgaXNBcnJheSA9IHJlcXVpcmUoJy4vaXNBcnJheScpLFxuICAgIHByb3BlcnR5ID0gcmVxdWlyZSgnLi9wcm9wZXJ0eScpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLml0ZXJhdGVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSBbdmFsdWU9Xy5pZGVudGl0eV0gVGhlIHZhbHVlIHRvIGNvbnZlcnQgdG8gYW4gaXRlcmF0ZWUuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIGl0ZXJhdGVlLlxuICovXG5mdW5jdGlvbiBiYXNlSXRlcmF0ZWUodmFsdWUpIHtcbiAgLy8gRG9uJ3Qgc3RvcmUgdGhlIGB0eXBlb2ZgIHJlc3VsdCBpbiBhIHZhcmlhYmxlIHRvIGF2b2lkIGEgSklUIGJ1ZyBpbiBTYWZhcmkgOS5cbiAgLy8gU2VlIGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3dfYnVnLmNnaT9pZD0xNTYwMzQgZm9yIG1vcmUgZGV0YWlscy5cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgcmV0dXJuIGlkZW50aXR5O1xuICB9XG4gIGlmICh0eXBlb2YgdmFsdWUgPT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm4gaXNBcnJheSh2YWx1ZSlcbiAgICAgID8gYmFzZU1hdGNoZXNQcm9wZXJ0eSh2YWx1ZVswXSwgdmFsdWVbMV0pXG4gICAgICA6IGJhc2VNYXRjaGVzKHZhbHVlKTtcbiAgfVxuICByZXR1cm4gcHJvcGVydHkodmFsdWUpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VJdGVyYXRlZTtcbiIsInZhciBpc1Byb3RvdHlwZSA9IHJlcXVpcmUoJy4vX2lzUHJvdG90eXBlJyksXG4gICAgbmF0aXZlS2V5cyA9IHJlcXVpcmUoJy4vX25hdGl2ZUtleXMnKTtcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5rZXlzYCB3aGljaCBkb2Vzbid0IHRyZWF0IHNwYXJzZSBhcnJheXMgYXMgZGVuc2UuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gKi9cbmZ1bmN0aW9uIGJhc2VLZXlzKG9iamVjdCkge1xuICBpZiAoIWlzUHJvdG90eXBlKG9iamVjdCkpIHtcbiAgICByZXR1cm4gbmF0aXZlS2V5cyhvYmplY3QpO1xuICB9XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgZm9yICh2YXIga2V5IGluIE9iamVjdChvYmplY3QpKSB7XG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBrZXkpICYmIGtleSAhPSAnY29uc3RydWN0b3InKSB7XG4gICAgICByZXN1bHQucHVzaChrZXkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VLZXlzO1xuIiwidmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9pc09iamVjdCcpLFxuICAgIGlzUHJvdG90eXBlID0gcmVxdWlyZSgnLi9faXNQcm90b3R5cGUnKSxcbiAgICBuYXRpdmVLZXlzSW4gPSByZXF1aXJlKCcuL19uYXRpdmVLZXlzSW4nKTtcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5rZXlzSW5gIHdoaWNoIGRvZXNuJ3QgdHJlYXQgc3BhcnNlIGFycmF5cyBhcyBkZW5zZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAqL1xuZnVuY3Rpb24gYmFzZUtleXNJbihvYmplY3QpIHtcbiAgaWYgKCFpc09iamVjdChvYmplY3QpKSB7XG4gICAgcmV0dXJuIG5hdGl2ZUtleXNJbihvYmplY3QpO1xuICB9XG4gIHZhciBpc1Byb3RvID0gaXNQcm90b3R5cGUob2JqZWN0KSxcbiAgICAgIHJlc3VsdCA9IFtdO1xuXG4gIGZvciAodmFyIGtleSBpbiBvYmplY3QpIHtcbiAgICBpZiAoIShrZXkgPT0gJ2NvbnN0cnVjdG9yJyAmJiAoaXNQcm90byB8fCAhaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIGtleSkpKSkge1xuICAgICAgcmVzdWx0LnB1c2goa2V5KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlS2V5c0luO1xuIiwiLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5sdGAgd2hpY2ggZG9lc24ndCBjb2VyY2UgYXJndW1lbnRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb21wYXJlLlxuICogQHBhcmFtIHsqfSBvdGhlciBUaGUgb3RoZXIgdmFsdWUgdG8gY29tcGFyZS5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGxlc3MgdGhhbiBgb3RoZXJgLFxuICogIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUx0KHZhbHVlLCBvdGhlcikge1xuICByZXR1cm4gdmFsdWUgPCBvdGhlcjtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlTHQ7XG4iLCJ2YXIgYmFzZUVhY2ggPSByZXF1aXJlKCcuL19iYXNlRWFjaCcpLFxuICAgIGlzQXJyYXlMaWtlID0gcmVxdWlyZSgnLi9pc0FycmF5TGlrZScpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLm1hcGAgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgbWFwcGVkIGFycmF5LlxuICovXG5mdW5jdGlvbiBiYXNlTWFwKGNvbGxlY3Rpb24sIGl0ZXJhdGVlKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgcmVzdWx0ID0gaXNBcnJheUxpa2UoY29sbGVjdGlvbikgPyBBcnJheShjb2xsZWN0aW9uLmxlbmd0aCkgOiBbXTtcblxuICBiYXNlRWFjaChjb2xsZWN0aW9uLCBmdW5jdGlvbih2YWx1ZSwga2V5LCBjb2xsZWN0aW9uKSB7XG4gICAgcmVzdWx0WysraW5kZXhdID0gaXRlcmF0ZWUodmFsdWUsIGtleSwgY29sbGVjdGlvbik7XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VNYXA7XG4iLCJ2YXIgYmFzZUlzTWF0Y2ggPSByZXF1aXJlKCcuL19iYXNlSXNNYXRjaCcpLFxuICAgIGdldE1hdGNoRGF0YSA9IHJlcXVpcmUoJy4vX2dldE1hdGNoRGF0YScpLFxuICAgIG1hdGNoZXNTdHJpY3RDb21wYXJhYmxlID0gcmVxdWlyZSgnLi9fbWF0Y2hlc1N0cmljdENvbXBhcmFibGUnKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5tYXRjaGVzYCB3aGljaCBkb2Vzbid0IGNsb25lIGBzb3VyY2VgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBvYmplY3Qgb2YgcHJvcGVydHkgdmFsdWVzIHRvIG1hdGNoLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgc3BlYyBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gYmFzZU1hdGNoZXMoc291cmNlKSB7XG4gIHZhciBtYXRjaERhdGEgPSBnZXRNYXRjaERhdGEoc291cmNlKTtcbiAgaWYgKG1hdGNoRGF0YS5sZW5ndGggPT0gMSAmJiBtYXRjaERhdGFbMF1bMl0pIHtcbiAgICByZXR1cm4gbWF0Y2hlc1N0cmljdENvbXBhcmFibGUobWF0Y2hEYXRhWzBdWzBdLCBtYXRjaERhdGFbMF1bMV0pO1xuICB9XG4gIHJldHVybiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICByZXR1cm4gb2JqZWN0ID09PSBzb3VyY2UgfHwgYmFzZUlzTWF0Y2gob2JqZWN0LCBzb3VyY2UsIG1hdGNoRGF0YSk7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZU1hdGNoZXM7XG4iLCJ2YXIgYmFzZUlzRXF1YWwgPSByZXF1aXJlKCcuL19iYXNlSXNFcXVhbCcpLFxuICAgIGdldCA9IHJlcXVpcmUoJy4vZ2V0JyksXG4gICAgaGFzSW4gPSByZXF1aXJlKCcuL2hhc0luJyksXG4gICAgaXNLZXkgPSByZXF1aXJlKCcuL19pc0tleScpLFxuICAgIGlzU3RyaWN0Q29tcGFyYWJsZSA9IHJlcXVpcmUoJy4vX2lzU3RyaWN0Q29tcGFyYWJsZScpLFxuICAgIG1hdGNoZXNTdHJpY3RDb21wYXJhYmxlID0gcmVxdWlyZSgnLi9fbWF0Y2hlc1N0cmljdENvbXBhcmFibGUnKSxcbiAgICB0b0tleSA9IHJlcXVpcmUoJy4vX3RvS2V5Jyk7XG5cbi8qKiBVc2VkIHRvIGNvbXBvc2UgYml0bWFza3MgZm9yIHZhbHVlIGNvbXBhcmlzb25zLiAqL1xudmFyIENPTVBBUkVfUEFSVElBTF9GTEFHID0gMSxcbiAgICBDT01QQVJFX1VOT1JERVJFRF9GTEFHID0gMjtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5tYXRjaGVzUHJvcGVydHlgIHdoaWNoIGRvZXNuJ3QgY2xvbmUgYHNyY1ZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAqIEBwYXJhbSB7Kn0gc3JjVmFsdWUgVGhlIHZhbHVlIHRvIG1hdGNoLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgc3BlYyBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gYmFzZU1hdGNoZXNQcm9wZXJ0eShwYXRoLCBzcmNWYWx1ZSkge1xuICBpZiAoaXNLZXkocGF0aCkgJiYgaXNTdHJpY3RDb21wYXJhYmxlKHNyY1ZhbHVlKSkge1xuICAgIHJldHVybiBtYXRjaGVzU3RyaWN0Q29tcGFyYWJsZSh0b0tleShwYXRoKSwgc3JjVmFsdWUpO1xuICB9XG4gIHJldHVybiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICB2YXIgb2JqVmFsdWUgPSBnZXQob2JqZWN0LCBwYXRoKTtcbiAgICByZXR1cm4gKG9ialZhbHVlID09PSB1bmRlZmluZWQgJiYgb2JqVmFsdWUgPT09IHNyY1ZhbHVlKVxuICAgICAgPyBoYXNJbihvYmplY3QsIHBhdGgpXG4gICAgICA6IGJhc2VJc0VxdWFsKHNyY1ZhbHVlLCBvYmpWYWx1ZSwgQ09NUEFSRV9QQVJUSUFMX0ZMQUcgfCBDT01QQVJFX1VOT1JERVJFRF9GTEFHKTtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlTWF0Y2hlc1Byb3BlcnR5O1xuIiwidmFyIFN0YWNrID0gcmVxdWlyZSgnLi9fU3RhY2snKSxcbiAgICBhc3NpZ25NZXJnZVZhbHVlID0gcmVxdWlyZSgnLi9fYXNzaWduTWVyZ2VWYWx1ZScpLFxuICAgIGJhc2VGb3IgPSByZXF1aXJlKCcuL19iYXNlRm9yJyksXG4gICAgYmFzZU1lcmdlRGVlcCA9IHJlcXVpcmUoJy4vX2Jhc2VNZXJnZURlZXAnKSxcbiAgICBpc09iamVjdCA9IHJlcXVpcmUoJy4vaXNPYmplY3QnKSxcbiAgICBrZXlzSW4gPSByZXF1aXJlKCcuL2tleXNJbicpLFxuICAgIHNhZmVHZXQgPSByZXF1aXJlKCcuL19zYWZlR2V0Jyk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ubWVyZ2VgIHdpdGhvdXQgc3VwcG9ydCBmb3IgbXVsdGlwbGUgc291cmNlcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgc291cmNlIG9iamVjdC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzcmNJbmRleCBUaGUgaW5kZXggb2YgYHNvdXJjZWAuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBtZXJnZWQgdmFsdWVzLlxuICogQHBhcmFtIHtPYmplY3R9IFtzdGFja10gVHJhY2tzIHRyYXZlcnNlZCBzb3VyY2UgdmFsdWVzIGFuZCB0aGVpciBtZXJnZWRcbiAqICBjb3VudGVycGFydHMuXG4gKi9cbmZ1bmN0aW9uIGJhc2VNZXJnZShvYmplY3QsIHNvdXJjZSwgc3JjSW5kZXgsIGN1c3RvbWl6ZXIsIHN0YWNrKSB7XG4gIGlmIChvYmplY3QgPT09IHNvdXJjZSkge1xuICAgIHJldHVybjtcbiAgfVxuICBiYXNlRm9yKHNvdXJjZSwgZnVuY3Rpb24oc3JjVmFsdWUsIGtleSkge1xuICAgIHN0YWNrIHx8IChzdGFjayA9IG5ldyBTdGFjayk7XG4gICAgaWYgKGlzT2JqZWN0KHNyY1ZhbHVlKSkge1xuICAgICAgYmFzZU1lcmdlRGVlcChvYmplY3QsIHNvdXJjZSwga2V5LCBzcmNJbmRleCwgYmFzZU1lcmdlLCBjdXN0b21pemVyLCBzdGFjayk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgdmFyIG5ld1ZhbHVlID0gY3VzdG9taXplclxuICAgICAgICA/IGN1c3RvbWl6ZXIoc2FmZUdldChvYmplY3QsIGtleSksIHNyY1ZhbHVlLCAoa2V5ICsgJycpLCBvYmplY3QsIHNvdXJjZSwgc3RhY2spXG4gICAgICAgIDogdW5kZWZpbmVkO1xuXG4gICAgICBpZiAobmV3VmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBuZXdWYWx1ZSA9IHNyY1ZhbHVlO1xuICAgICAgfVxuICAgICAgYXNzaWduTWVyZ2VWYWx1ZShvYmplY3QsIGtleSwgbmV3VmFsdWUpO1xuICAgIH1cbiAgfSwga2V5c0luKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlTWVyZ2U7XG4iLCJ2YXIgYXNzaWduTWVyZ2VWYWx1ZSA9IHJlcXVpcmUoJy4vX2Fzc2lnbk1lcmdlVmFsdWUnKSxcbiAgICBjbG9uZUJ1ZmZlciA9IHJlcXVpcmUoJy4vX2Nsb25lQnVmZmVyJyksXG4gICAgY2xvbmVUeXBlZEFycmF5ID0gcmVxdWlyZSgnLi9fY2xvbmVUeXBlZEFycmF5JyksXG4gICAgY29weUFycmF5ID0gcmVxdWlyZSgnLi9fY29weUFycmF5JyksXG4gICAgaW5pdENsb25lT2JqZWN0ID0gcmVxdWlyZSgnLi9faW5pdENsb25lT2JqZWN0JyksXG4gICAgaXNBcmd1bWVudHMgPSByZXF1aXJlKCcuL2lzQXJndW1lbnRzJyksXG4gICAgaXNBcnJheSA9IHJlcXVpcmUoJy4vaXNBcnJheScpLFxuICAgIGlzQXJyYXlMaWtlT2JqZWN0ID0gcmVxdWlyZSgnLi9pc0FycmF5TGlrZU9iamVjdCcpLFxuICAgIGlzQnVmZmVyID0gcmVxdWlyZSgnLi9pc0J1ZmZlcicpLFxuICAgIGlzRnVuY3Rpb24gPSByZXF1aXJlKCcuL2lzRnVuY3Rpb24nKSxcbiAgICBpc09iamVjdCA9IHJlcXVpcmUoJy4vaXNPYmplY3QnKSxcbiAgICBpc1BsYWluT2JqZWN0ID0gcmVxdWlyZSgnLi9pc1BsYWluT2JqZWN0JyksXG4gICAgaXNUeXBlZEFycmF5ID0gcmVxdWlyZSgnLi9pc1R5cGVkQXJyYXknKSxcbiAgICBzYWZlR2V0ID0gcmVxdWlyZSgnLi9fc2FmZUdldCcpLFxuICAgIHRvUGxhaW5PYmplY3QgPSByZXF1aXJlKCcuL3RvUGxhaW5PYmplY3QnKTtcblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VNZXJnZWAgZm9yIGFycmF5cyBhbmQgb2JqZWN0cyB3aGljaCBwZXJmb3Jtc1xuICogZGVlcCBtZXJnZXMgYW5kIHRyYWNrcyB0cmF2ZXJzZWQgb2JqZWN0cyBlbmFibGluZyBvYmplY3RzIHdpdGggY2lyY3VsYXJcbiAqIHJlZmVyZW5jZXMgdG8gYmUgbWVyZ2VkLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBzb3VyY2Ugb2JqZWN0LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBtZXJnZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzcmNJbmRleCBUaGUgaW5kZXggb2YgYHNvdXJjZWAuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBtZXJnZUZ1bmMgVGhlIGZ1bmN0aW9uIHRvIG1lcmdlIHZhbHVlcy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGFzc2lnbmVkIHZhbHVlcy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbc3RhY2tdIFRyYWNrcyB0cmF2ZXJzZWQgc291cmNlIHZhbHVlcyBhbmQgdGhlaXIgbWVyZ2VkXG4gKiAgY291bnRlcnBhcnRzLlxuICovXG5mdW5jdGlvbiBiYXNlTWVyZ2VEZWVwKG9iamVjdCwgc291cmNlLCBrZXksIHNyY0luZGV4LCBtZXJnZUZ1bmMsIGN1c3RvbWl6ZXIsIHN0YWNrKSB7XG4gIHZhciBvYmpWYWx1ZSA9IHNhZmVHZXQob2JqZWN0LCBrZXkpLFxuICAgICAgc3JjVmFsdWUgPSBzYWZlR2V0KHNvdXJjZSwga2V5KSxcbiAgICAgIHN0YWNrZWQgPSBzdGFjay5nZXQoc3JjVmFsdWUpO1xuXG4gIGlmIChzdGFja2VkKSB7XG4gICAgYXNzaWduTWVyZ2VWYWx1ZShvYmplY3QsIGtleSwgc3RhY2tlZCk7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBuZXdWYWx1ZSA9IGN1c3RvbWl6ZXJcbiAgICA/IGN1c3RvbWl6ZXIob2JqVmFsdWUsIHNyY1ZhbHVlLCAoa2V5ICsgJycpLCBvYmplY3QsIHNvdXJjZSwgc3RhY2spXG4gICAgOiB1bmRlZmluZWQ7XG5cbiAgdmFyIGlzQ29tbW9uID0gbmV3VmFsdWUgPT09IHVuZGVmaW5lZDtcblxuICBpZiAoaXNDb21tb24pIHtcbiAgICB2YXIgaXNBcnIgPSBpc0FycmF5KHNyY1ZhbHVlKSxcbiAgICAgICAgaXNCdWZmID0gIWlzQXJyICYmIGlzQnVmZmVyKHNyY1ZhbHVlKSxcbiAgICAgICAgaXNUeXBlZCA9ICFpc0FyciAmJiAhaXNCdWZmICYmIGlzVHlwZWRBcnJheShzcmNWYWx1ZSk7XG5cbiAgICBuZXdWYWx1ZSA9IHNyY1ZhbHVlO1xuICAgIGlmIChpc0FyciB8fCBpc0J1ZmYgfHwgaXNUeXBlZCkge1xuICAgICAgaWYgKGlzQXJyYXkob2JqVmFsdWUpKSB7XG4gICAgICAgIG5ld1ZhbHVlID0gb2JqVmFsdWU7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChpc0FycmF5TGlrZU9iamVjdChvYmpWYWx1ZSkpIHtcbiAgICAgICAgbmV3VmFsdWUgPSBjb3B5QXJyYXkob2JqVmFsdWUpO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoaXNCdWZmKSB7XG4gICAgICAgIGlzQ29tbW9uID0gZmFsc2U7XG4gICAgICAgIG5ld1ZhbHVlID0gY2xvbmVCdWZmZXIoc3JjVmFsdWUsIHRydWUpO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoaXNUeXBlZCkge1xuICAgICAgICBpc0NvbW1vbiA9IGZhbHNlO1xuICAgICAgICBuZXdWYWx1ZSA9IGNsb25lVHlwZWRBcnJheShzcmNWYWx1ZSwgdHJ1ZSk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgbmV3VmFsdWUgPSBbXTtcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoaXNQbGFpbk9iamVjdChzcmNWYWx1ZSkgfHwgaXNBcmd1bWVudHMoc3JjVmFsdWUpKSB7XG4gICAgICBuZXdWYWx1ZSA9IG9ialZhbHVlO1xuICAgICAgaWYgKGlzQXJndW1lbnRzKG9ialZhbHVlKSkge1xuICAgICAgICBuZXdWYWx1ZSA9IHRvUGxhaW5PYmplY3Qob2JqVmFsdWUpO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoIWlzT2JqZWN0KG9ialZhbHVlKSB8fCBpc0Z1bmN0aW9uKG9ialZhbHVlKSkge1xuICAgICAgICBuZXdWYWx1ZSA9IGluaXRDbG9uZU9iamVjdChzcmNWYWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgaXNDb21tb24gPSBmYWxzZTtcbiAgICB9XG4gIH1cbiAgaWYgKGlzQ29tbW9uKSB7XG4gICAgLy8gUmVjdXJzaXZlbHkgbWVyZ2Ugb2JqZWN0cyBhbmQgYXJyYXlzIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cykuXG4gICAgc3RhY2suc2V0KHNyY1ZhbHVlLCBuZXdWYWx1ZSk7XG4gICAgbWVyZ2VGdW5jKG5ld1ZhbHVlLCBzcmNWYWx1ZSwgc3JjSW5kZXgsIGN1c3RvbWl6ZXIsIHN0YWNrKTtcbiAgICBzdGFja1snZGVsZXRlJ10oc3JjVmFsdWUpO1xuICB9XG4gIGFzc2lnbk1lcmdlVmFsdWUob2JqZWN0LCBrZXksIG5ld1ZhbHVlKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlTWVyZ2VEZWVwO1xuIiwidmFyIGFycmF5TWFwID0gcmVxdWlyZSgnLi9fYXJyYXlNYXAnKSxcbiAgICBiYXNlR2V0ID0gcmVxdWlyZSgnLi9fYmFzZUdldCcpLFxuICAgIGJhc2VJdGVyYXRlZSA9IHJlcXVpcmUoJy4vX2Jhc2VJdGVyYXRlZScpLFxuICAgIGJhc2VNYXAgPSByZXF1aXJlKCcuL19iYXNlTWFwJyksXG4gICAgYmFzZVNvcnRCeSA9IHJlcXVpcmUoJy4vX2Jhc2VTb3J0QnknKSxcbiAgICBiYXNlVW5hcnkgPSByZXF1aXJlKCcuL19iYXNlVW5hcnknKSxcbiAgICBjb21wYXJlTXVsdGlwbGUgPSByZXF1aXJlKCcuL19jb21wYXJlTXVsdGlwbGUnKSxcbiAgICBpZGVudGl0eSA9IHJlcXVpcmUoJy4vaWRlbnRpdHknKSxcbiAgICBpc0FycmF5ID0gcmVxdWlyZSgnLi9pc0FycmF5Jyk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ub3JkZXJCeWAgd2l0aG91dCBwYXJhbSBndWFyZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb25bXXxPYmplY3RbXXxzdHJpbmdbXX0gaXRlcmF0ZWVzIFRoZSBpdGVyYXRlZXMgdG8gc29ydCBieS5cbiAqIEBwYXJhbSB7c3RyaW5nW119IG9yZGVycyBUaGUgc29ydCBvcmRlcnMgb2YgYGl0ZXJhdGVlc2AuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBzb3J0ZWQgYXJyYXkuXG4gKi9cbmZ1bmN0aW9uIGJhc2VPcmRlckJ5KGNvbGxlY3Rpb24sIGl0ZXJhdGVlcywgb3JkZXJzKSB7XG4gIGlmIChpdGVyYXRlZXMubGVuZ3RoKSB7XG4gICAgaXRlcmF0ZWVzID0gYXJyYXlNYXAoaXRlcmF0ZWVzLCBmdW5jdGlvbihpdGVyYXRlZSkge1xuICAgICAgaWYgKGlzQXJyYXkoaXRlcmF0ZWUpKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgIHJldHVybiBiYXNlR2V0KHZhbHVlLCBpdGVyYXRlZS5sZW5ndGggPT09IDEgPyBpdGVyYXRlZVswXSA6IGl0ZXJhdGVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGl0ZXJhdGVlO1xuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIGl0ZXJhdGVlcyA9IFtpZGVudGl0eV07XG4gIH1cblxuICB2YXIgaW5kZXggPSAtMTtcbiAgaXRlcmF0ZWVzID0gYXJyYXlNYXAoaXRlcmF0ZWVzLCBiYXNlVW5hcnkoYmFzZUl0ZXJhdGVlKSk7XG5cbiAgdmFyIHJlc3VsdCA9IGJhc2VNYXAoY29sbGVjdGlvbiwgZnVuY3Rpb24odmFsdWUsIGtleSwgY29sbGVjdGlvbikge1xuICAgIHZhciBjcml0ZXJpYSA9IGFycmF5TWFwKGl0ZXJhdGVlcywgZnVuY3Rpb24oaXRlcmF0ZWUpIHtcbiAgICAgIHJldHVybiBpdGVyYXRlZSh2YWx1ZSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHsgJ2NyaXRlcmlhJzogY3JpdGVyaWEsICdpbmRleCc6ICsraW5kZXgsICd2YWx1ZSc6IHZhbHVlIH07XG4gIH0pO1xuXG4gIHJldHVybiBiYXNlU29ydEJ5KHJlc3VsdCwgZnVuY3Rpb24ob2JqZWN0LCBvdGhlcikge1xuICAgIHJldHVybiBjb21wYXJlTXVsdGlwbGUob2JqZWN0LCBvdGhlciwgb3JkZXJzKTtcbiAgfSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZU9yZGVyQnk7XG4iLCJ2YXIgYmFzZVBpY2tCeSA9IHJlcXVpcmUoJy4vX2Jhc2VQaWNrQnknKSxcbiAgICBoYXNJbiA9IHJlcXVpcmUoJy4vaGFzSW4nKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5waWNrYCB3aXRob3V0IHN1cHBvcnQgZm9yIGluZGl2aWR1YWxcbiAqIHByb3BlcnR5IGlkZW50aWZpZXJzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBzb3VyY2Ugb2JqZWN0LlxuICogQHBhcmFtIHtzdHJpbmdbXX0gcGF0aHMgVGhlIHByb3BlcnR5IHBhdGhzIHRvIHBpY2suXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgb2JqZWN0LlxuICovXG5mdW5jdGlvbiBiYXNlUGljayhvYmplY3QsIHBhdGhzKSB7XG4gIHJldHVybiBiYXNlUGlja0J5KG9iamVjdCwgcGF0aHMsIGZ1bmN0aW9uKHZhbHVlLCBwYXRoKSB7XG4gICAgcmV0dXJuIGhhc0luKG9iamVjdCwgcGF0aCk7XG4gIH0pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VQaWNrO1xuIiwidmFyIGJhc2VHZXQgPSByZXF1aXJlKCcuL19iYXNlR2V0JyksXG4gICAgYmFzZVNldCA9IHJlcXVpcmUoJy4vX2Jhc2VTZXQnKSxcbiAgICBjYXN0UGF0aCA9IHJlcXVpcmUoJy4vX2Nhc3RQYXRoJyk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgIGBfLnBpY2tCeWAgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBzb3VyY2Ugb2JqZWN0LlxuICogQHBhcmFtIHtzdHJpbmdbXX0gcGF0aHMgVGhlIHByb3BlcnR5IHBhdGhzIHRvIHBpY2suXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkaWNhdGUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIHByb3BlcnR5LlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IG9iamVjdC5cbiAqL1xuZnVuY3Rpb24gYmFzZVBpY2tCeShvYmplY3QsIHBhdGhzLCBwcmVkaWNhdGUpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBwYXRocy5sZW5ndGgsXG4gICAgICByZXN1bHQgPSB7fTtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciBwYXRoID0gcGF0aHNbaW5kZXhdLFxuICAgICAgICB2YWx1ZSA9IGJhc2VHZXQob2JqZWN0LCBwYXRoKTtcblxuICAgIGlmIChwcmVkaWNhdGUodmFsdWUsIHBhdGgpKSB7XG4gICAgICBiYXNlU2V0KHJlc3VsdCwgY2FzdFBhdGgocGF0aCwgb2JqZWN0KSwgdmFsdWUpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VQaWNrQnk7XG4iLCIvKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnByb3BlcnR5YCB3aXRob3V0IHN1cHBvcnQgZm9yIGRlZXAgcGF0aHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYWNjZXNzb3IgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGJhc2VQcm9wZXJ0eShrZXkpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCkge1xuICAgIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IG9iamVjdFtrZXldO1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VQcm9wZXJ0eTtcbiIsInZhciBiYXNlR2V0ID0gcmVxdWlyZSgnLi9fYmFzZUdldCcpO1xuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZVByb3BlcnR5YCB3aGljaCBzdXBwb3J0cyBkZWVwIHBhdGhzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYWNjZXNzb3IgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGJhc2VQcm9wZXJ0eURlZXAocGF0aCkge1xuICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgcmV0dXJuIGJhc2VHZXQob2JqZWN0LCBwYXRoKTtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlUHJvcGVydHlEZWVwO1xuIiwiLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgZm9yIHRob3NlIHdpdGggdGhlIHNhbWUgbmFtZSBhcyBvdGhlciBgbG9kYXNoYCBtZXRob2RzLiAqL1xudmFyIG5hdGl2ZUNlaWwgPSBNYXRoLmNlaWwsXG4gICAgbmF0aXZlTWF4ID0gTWF0aC5tYXg7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ucmFuZ2VgIGFuZCBgXy5yYW5nZVJpZ2h0YCB3aGljaCBkb2Vzbid0XG4gKiBjb2VyY2UgYXJndW1lbnRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge251bWJlcn0gc3RhcnQgVGhlIHN0YXJ0IG9mIHRoZSByYW5nZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBlbmQgVGhlIGVuZCBvZiB0aGUgcmFuZ2UuXG4gKiBAcGFyYW0ge251bWJlcn0gc3RlcCBUaGUgdmFsdWUgdG8gaW5jcmVtZW50IG9yIGRlY3JlbWVudCBieS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2Zyb21SaWdodF0gU3BlY2lmeSBpdGVyYXRpbmcgZnJvbSByaWdodCB0byBsZWZ0LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSByYW5nZSBvZiBudW1iZXJzLlxuICovXG5mdW5jdGlvbiBiYXNlUmFuZ2Uoc3RhcnQsIGVuZCwgc3RlcCwgZnJvbVJpZ2h0KSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gbmF0aXZlTWF4KG5hdGl2ZUNlaWwoKGVuZCAtIHN0YXJ0KSAvIChzdGVwIHx8IDEpKSwgMCksXG4gICAgICByZXN1bHQgPSBBcnJheShsZW5ndGgpO1xuXG4gIHdoaWxlIChsZW5ndGgtLSkge1xuICAgIHJlc3VsdFtmcm9tUmlnaHQgPyBsZW5ndGggOiArK2luZGV4XSA9IHN0YXJ0O1xuICAgIHN0YXJ0ICs9IHN0ZXA7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlUmFuZ2U7XG4iLCIvKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnJlZHVjZWAgYW5kIGBfLnJlZHVjZVJpZ2h0YCwgd2l0aG91dCBzdXBwb3J0XG4gKiBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcywgd2hpY2ggaXRlcmF0ZXMgb3ZlciBgY29sbGVjdGlvbmAgdXNpbmcgYGVhY2hGdW5jYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEBwYXJhbSB7Kn0gYWNjdW11bGF0b3IgVGhlIGluaXRpYWwgdmFsdWUuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGluaXRBY2N1bSBTcGVjaWZ5IHVzaW5nIHRoZSBmaXJzdCBvciBsYXN0IGVsZW1lbnQgb2ZcbiAqICBgY29sbGVjdGlvbmAgYXMgdGhlIGluaXRpYWwgdmFsdWUuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBlYWNoRnVuYyBUaGUgZnVuY3Rpb24gdG8gaXRlcmF0ZSBvdmVyIGBjb2xsZWN0aW9uYC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBhY2N1bXVsYXRlZCB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gYmFzZVJlZHVjZShjb2xsZWN0aW9uLCBpdGVyYXRlZSwgYWNjdW11bGF0b3IsIGluaXRBY2N1bSwgZWFjaEZ1bmMpIHtcbiAgZWFjaEZ1bmMoY29sbGVjdGlvbiwgZnVuY3Rpb24odmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKSB7XG4gICAgYWNjdW11bGF0b3IgPSBpbml0QWNjdW1cbiAgICAgID8gKGluaXRBY2N1bSA9IGZhbHNlLCB2YWx1ZSlcbiAgICAgIDogaXRlcmF0ZWUoYWNjdW11bGF0b3IsIHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbik7XG4gIH0pO1xuICByZXR1cm4gYWNjdW11bGF0b3I7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZVJlZHVjZTtcbiIsInZhciBpZGVudGl0eSA9IHJlcXVpcmUoJy4vaWRlbnRpdHknKSxcbiAgICBvdmVyUmVzdCA9IHJlcXVpcmUoJy4vX292ZXJSZXN0JyksXG4gICAgc2V0VG9TdHJpbmcgPSByZXF1aXJlKCcuL19zZXRUb1N0cmluZycpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnJlc3RgIHdoaWNoIGRvZXNuJ3QgdmFsaWRhdGUgb3IgY29lcmNlIGFyZ3VtZW50cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gYXBwbHkgYSByZXN0IHBhcmFtZXRlciB0by5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbc3RhcnQ9ZnVuYy5sZW5ndGgtMV0gVGhlIHN0YXJ0IHBvc2l0aW9uIG9mIHRoZSByZXN0IHBhcmFtZXRlci5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBiYXNlUmVzdChmdW5jLCBzdGFydCkge1xuICByZXR1cm4gc2V0VG9TdHJpbmcob3ZlclJlc3QoZnVuYywgc3RhcnQsIGlkZW50aXR5KSwgZnVuYyArICcnKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlUmVzdDtcbiIsInZhciBhc3NpZ25WYWx1ZSA9IHJlcXVpcmUoJy4vX2Fzc2lnblZhbHVlJyksXG4gICAgY2FzdFBhdGggPSByZXF1aXJlKCcuL19jYXN0UGF0aCcpLFxuICAgIGlzSW5kZXggPSByZXF1aXJlKCcuL19pc0luZGV4JyksXG4gICAgaXNPYmplY3QgPSByZXF1aXJlKCcuL2lzT2JqZWN0JyksXG4gICAgdG9LZXkgPSByZXF1aXJlKCcuL190b0tleScpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnNldGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBtb2RpZnkuXG4gKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgcHJvcGVydHkgdG8gc2V0LlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0LlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgcGF0aCBjcmVhdGlvbi5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VTZXQob2JqZWN0LCBwYXRoLCB2YWx1ZSwgY3VzdG9taXplcikge1xuICBpZiAoIWlzT2JqZWN0KG9iamVjdCkpIHtcbiAgICByZXR1cm4gb2JqZWN0O1xuICB9XG4gIHBhdGggPSBjYXN0UGF0aChwYXRoLCBvYmplY3QpO1xuXG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gcGF0aC5sZW5ndGgsXG4gICAgICBsYXN0SW5kZXggPSBsZW5ndGggLSAxLFxuICAgICAgbmVzdGVkID0gb2JqZWN0O1xuXG4gIHdoaWxlIChuZXN0ZWQgIT0gbnVsbCAmJiArK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIGtleSA9IHRvS2V5KHBhdGhbaW5kZXhdKSxcbiAgICAgICAgbmV3VmFsdWUgPSB2YWx1ZTtcblxuICAgIGlmIChrZXkgPT09ICdfX3Byb3RvX18nIHx8IGtleSA9PT0gJ2NvbnN0cnVjdG9yJyB8fCBrZXkgPT09ICdwcm90b3R5cGUnKSB7XG4gICAgICByZXR1cm4gb2JqZWN0O1xuICAgIH1cblxuICAgIGlmIChpbmRleCAhPSBsYXN0SW5kZXgpIHtcbiAgICAgIHZhciBvYmpWYWx1ZSA9IG5lc3RlZFtrZXldO1xuICAgICAgbmV3VmFsdWUgPSBjdXN0b21pemVyID8gY3VzdG9taXplcihvYmpWYWx1ZSwga2V5LCBuZXN0ZWQpIDogdW5kZWZpbmVkO1xuICAgICAgaWYgKG5ld1ZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgbmV3VmFsdWUgPSBpc09iamVjdChvYmpWYWx1ZSlcbiAgICAgICAgICA/IG9ialZhbHVlXG4gICAgICAgICAgOiAoaXNJbmRleChwYXRoW2luZGV4ICsgMV0pID8gW10gOiB7fSk7XG4gICAgICB9XG4gICAgfVxuICAgIGFzc2lnblZhbHVlKG5lc3RlZCwga2V5LCBuZXdWYWx1ZSk7XG4gICAgbmVzdGVkID0gbmVzdGVkW2tleV07XG4gIH1cbiAgcmV0dXJuIG9iamVjdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlU2V0O1xuIiwidmFyIGNvbnN0YW50ID0gcmVxdWlyZSgnLi9jb25zdGFudCcpLFxuICAgIGRlZmluZVByb3BlcnR5ID0gcmVxdWlyZSgnLi9fZGVmaW5lUHJvcGVydHknKSxcbiAgICBpZGVudGl0eSA9IHJlcXVpcmUoJy4vaWRlbnRpdHknKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgc2V0VG9TdHJpbmdgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaG90IGxvb3Agc2hvcnRpbmcuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIG1vZGlmeS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHN0cmluZyBUaGUgYHRvU3RyaW5nYCByZXN1bHQuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgYGZ1bmNgLlxuICovXG52YXIgYmFzZVNldFRvU3RyaW5nID0gIWRlZmluZVByb3BlcnR5ID8gaWRlbnRpdHkgOiBmdW5jdGlvbihmdW5jLCBzdHJpbmcpIHtcbiAgcmV0dXJuIGRlZmluZVByb3BlcnR5KGZ1bmMsICd0b1N0cmluZycsIHtcbiAgICAnY29uZmlndXJhYmxlJzogdHJ1ZSxcbiAgICAnZW51bWVyYWJsZSc6IGZhbHNlLFxuICAgICd2YWx1ZSc6IGNvbnN0YW50KHN0cmluZyksXG4gICAgJ3dyaXRhYmxlJzogdHJ1ZVxuICB9KTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZVNldFRvU3RyaW5nO1xuIiwiLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5zb3J0QnlgIHdoaWNoIHVzZXMgYGNvbXBhcmVyYCB0byBkZWZpbmUgdGhlXG4gKiBzb3J0IG9yZGVyIG9mIGBhcnJheWAgYW5kIHJlcGxhY2VzIGNyaXRlcmlhIG9iamVjdHMgd2l0aCB0aGVpciBjb3JyZXNwb25kaW5nXG4gKiB2YWx1ZXMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBzb3J0LlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY29tcGFyZXIgVGhlIGZ1bmN0aW9uIHRvIGRlZmluZSBzb3J0IG9yZGVyLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBhcnJheWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VTb3J0QnkoYXJyYXksIGNvbXBhcmVyKSB7XG4gIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG5cbiAgYXJyYXkuc29ydChjb21wYXJlcik7XG4gIHdoaWxlIChsZW5ndGgtLSkge1xuICAgIGFycmF5W2xlbmd0aF0gPSBhcnJheVtsZW5ndGhdLnZhbHVlO1xuICB9XG4gIHJldHVybiBhcnJheTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlU29ydEJ5O1xuIiwiLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy50aW1lc2Agd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzXG4gKiBvciBtYXggYXJyYXkgbGVuZ3RoIGNoZWNrcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtudW1iZXJ9IG4gVGhlIG51bWJlciBvZiB0aW1lcyB0byBpbnZva2UgYGl0ZXJhdGVlYC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHJlc3VsdHMuXG4gKi9cbmZ1bmN0aW9uIGJhc2VUaW1lcyhuLCBpdGVyYXRlZSkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIHJlc3VsdCA9IEFycmF5KG4pO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbikge1xuICAgIHJlc3VsdFtpbmRleF0gPSBpdGVyYXRlZShpbmRleCk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlVGltZXM7XG4iLCJ2YXIgU3ltYm9sID0gcmVxdWlyZSgnLi9fU3ltYm9sJyksXG4gICAgYXJyYXlNYXAgPSByZXF1aXJlKCcuL19hcnJheU1hcCcpLFxuICAgIGlzQXJyYXkgPSByZXF1aXJlKCcuL2lzQXJyYXknKSxcbiAgICBpc1N5bWJvbCA9IHJlcXVpcmUoJy4vaXNTeW1ib2wnKTtcblxuLyoqIFVzZWQgYXMgcmVmZXJlbmNlcyBmb3IgdmFyaW91cyBgTnVtYmVyYCBjb25zdGFudHMuICovXG52YXIgSU5GSU5JVFkgPSAxIC8gMDtcblxuLyoqIFVzZWQgdG8gY29udmVydCBzeW1ib2xzIHRvIHByaW1pdGl2ZXMgYW5kIHN0cmluZ3MuICovXG52YXIgc3ltYm9sUHJvdG8gPSBTeW1ib2wgPyBTeW1ib2wucHJvdG90eXBlIDogdW5kZWZpbmVkLFxuICAgIHN5bWJvbFRvU3RyaW5nID0gc3ltYm9sUHJvdG8gPyBzeW1ib2xQcm90by50b1N0cmluZyA6IHVuZGVmaW5lZDtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy50b1N0cmluZ2Agd2hpY2ggZG9lc24ndCBjb252ZXJ0IG51bGxpc2hcbiAqIHZhbHVlcyB0byBlbXB0eSBzdHJpbmdzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBwcm9jZXNzLlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgc3RyaW5nLlxuICovXG5mdW5jdGlvbiBiYXNlVG9TdHJpbmcodmFsdWUpIHtcbiAgLy8gRXhpdCBlYXJseSBmb3Igc3RyaW5ncyB0byBhdm9pZCBhIHBlcmZvcm1hbmNlIGhpdCBpbiBzb21lIGVudmlyb25tZW50cy5cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnc3RyaW5nJykge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAvLyBSZWN1cnNpdmVseSBjb252ZXJ0IHZhbHVlcyAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpLlxuICAgIHJldHVybiBhcnJheU1hcCh2YWx1ZSwgYmFzZVRvU3RyaW5nKSArICcnO1xuICB9XG4gIGlmIChpc1N5bWJvbCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gc3ltYm9sVG9TdHJpbmcgPyBzeW1ib2xUb1N0cmluZy5jYWxsKHZhbHVlKSA6ICcnO1xuICB9XG4gIHZhciByZXN1bHQgPSAodmFsdWUgKyAnJyk7XG4gIHJldHVybiAocmVzdWx0ID09ICcwJyAmJiAoMSAvIHZhbHVlKSA9PSAtSU5GSU5JVFkpID8gJy0wJyA6IHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlVG9TdHJpbmc7XG4iLCJ2YXIgdHJpbW1lZEVuZEluZGV4ID0gcmVxdWlyZSgnLi9fdHJpbW1lZEVuZEluZGV4Jyk7XG5cbi8qKiBVc2VkIHRvIG1hdGNoIGxlYWRpbmcgd2hpdGVzcGFjZS4gKi9cbnZhciByZVRyaW1TdGFydCA9IC9eXFxzKy87XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8udHJpbWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgVGhlIHN0cmluZyB0byB0cmltLlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgdHJpbW1lZCBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIGJhc2VUcmltKHN0cmluZykge1xuICByZXR1cm4gc3RyaW5nXG4gICAgPyBzdHJpbmcuc2xpY2UoMCwgdHJpbW1lZEVuZEluZGV4KHN0cmluZykgKyAxKS5yZXBsYWNlKHJlVHJpbVN0YXJ0LCAnJylcbiAgICA6IHN0cmluZztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlVHJpbTtcbiIsIi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8udW5hcnlgIHdpdGhvdXQgc3VwcG9ydCBmb3Igc3RvcmluZyBtZXRhZGF0YS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gY2FwIGFyZ3VtZW50cyBmb3IuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBjYXBwZWQgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGJhc2VVbmFyeShmdW5jKSB7XG4gIHJldHVybiBmdW5jdGlvbih2YWx1ZSkge1xuICAgIHJldHVybiBmdW5jKHZhbHVlKTtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlVW5hcnk7XG4iLCJ2YXIgU2V0Q2FjaGUgPSByZXF1aXJlKCcuL19TZXRDYWNoZScpLFxuICAgIGFycmF5SW5jbHVkZXMgPSByZXF1aXJlKCcuL19hcnJheUluY2x1ZGVzJyksXG4gICAgYXJyYXlJbmNsdWRlc1dpdGggPSByZXF1aXJlKCcuL19hcnJheUluY2x1ZGVzV2l0aCcpLFxuICAgIGNhY2hlSGFzID0gcmVxdWlyZSgnLi9fY2FjaGVIYXMnKSxcbiAgICBjcmVhdGVTZXQgPSByZXF1aXJlKCcuL19jcmVhdGVTZXQnKSxcbiAgICBzZXRUb0FycmF5ID0gcmVxdWlyZSgnLi9fc2V0VG9BcnJheScpO1xuXG4vKiogVXNlZCBhcyB0aGUgc2l6ZSB0byBlbmFibGUgbGFyZ2UgYXJyYXkgb3B0aW1pemF0aW9ucy4gKi9cbnZhciBMQVJHRV9BUlJBWV9TSVpFID0gMjAwO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnVuaXFCeWAgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZV0gVGhlIGl0ZXJhdGVlIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY29tcGFyYXRvcl0gVGhlIGNvbXBhcmF0b3IgaW52b2tlZCBwZXIgZWxlbWVudC5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGR1cGxpY2F0ZSBmcmVlIGFycmF5LlxuICovXG5mdW5jdGlvbiBiYXNlVW5pcShhcnJheSwgaXRlcmF0ZWUsIGNvbXBhcmF0b3IpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBpbmNsdWRlcyA9IGFycmF5SW5jbHVkZXMsXG4gICAgICBsZW5ndGggPSBhcnJheS5sZW5ndGgsXG4gICAgICBpc0NvbW1vbiA9IHRydWUsXG4gICAgICByZXN1bHQgPSBbXSxcbiAgICAgIHNlZW4gPSByZXN1bHQ7XG5cbiAgaWYgKGNvbXBhcmF0b3IpIHtcbiAgICBpc0NvbW1vbiA9IGZhbHNlO1xuICAgIGluY2x1ZGVzID0gYXJyYXlJbmNsdWRlc1dpdGg7XG4gIH1cbiAgZWxzZSBpZiAobGVuZ3RoID49IExBUkdFX0FSUkFZX1NJWkUpIHtcbiAgICB2YXIgc2V0ID0gaXRlcmF0ZWUgPyBudWxsIDogY3JlYXRlU2V0KGFycmF5KTtcbiAgICBpZiAoc2V0KSB7XG4gICAgICByZXR1cm4gc2V0VG9BcnJheShzZXQpO1xuICAgIH1cbiAgICBpc0NvbW1vbiA9IGZhbHNlO1xuICAgIGluY2x1ZGVzID0gY2FjaGVIYXM7XG4gICAgc2VlbiA9IG5ldyBTZXRDYWNoZTtcbiAgfVxuICBlbHNlIHtcbiAgICBzZWVuID0gaXRlcmF0ZWUgPyBbXSA6IHJlc3VsdDtcbiAgfVxuICBvdXRlcjpcbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIgdmFsdWUgPSBhcnJheVtpbmRleF0sXG4gICAgICAgIGNvbXB1dGVkID0gaXRlcmF0ZWUgPyBpdGVyYXRlZSh2YWx1ZSkgOiB2YWx1ZTtcblxuICAgIHZhbHVlID0gKGNvbXBhcmF0b3IgfHwgdmFsdWUgIT09IDApID8gdmFsdWUgOiAwO1xuICAgIGlmIChpc0NvbW1vbiAmJiBjb21wdXRlZCA9PT0gY29tcHV0ZWQpIHtcbiAgICAgIHZhciBzZWVuSW5kZXggPSBzZWVuLmxlbmd0aDtcbiAgICAgIHdoaWxlIChzZWVuSW5kZXgtLSkge1xuICAgICAgICBpZiAoc2VlbltzZWVuSW5kZXhdID09PSBjb21wdXRlZCkge1xuICAgICAgICAgIGNvbnRpbnVlIG91dGVyO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoaXRlcmF0ZWUpIHtcbiAgICAgICAgc2Vlbi5wdXNoKGNvbXB1dGVkKTtcbiAgICAgIH1cbiAgICAgIHJlc3VsdC5wdXNoKHZhbHVlKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoIWluY2x1ZGVzKHNlZW4sIGNvbXB1dGVkLCBjb21wYXJhdG9yKSkge1xuICAgICAgaWYgKHNlZW4gIT09IHJlc3VsdCkge1xuICAgICAgICBzZWVuLnB1c2goY29tcHV0ZWQpO1xuICAgICAgfVxuICAgICAgcmVzdWx0LnB1c2godmFsdWUpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VVbmlxO1xuIiwidmFyIGFycmF5TWFwID0gcmVxdWlyZSgnLi9fYXJyYXlNYXAnKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy52YWx1ZXNgIGFuZCBgXy52YWx1ZXNJbmAgd2hpY2ggY3JlYXRlcyBhblxuICogYXJyYXkgb2YgYG9iamVjdGAgcHJvcGVydHkgdmFsdWVzIGNvcnJlc3BvbmRpbmcgdG8gdGhlIHByb3BlcnR5IG5hbWVzXG4gKiBvZiBgcHJvcHNgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge0FycmF5fSBwcm9wcyBUaGUgcHJvcGVydHkgbmFtZXMgdG8gZ2V0IHZhbHVlcyBmb3IuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSB2YWx1ZXMuXG4gKi9cbmZ1bmN0aW9uIGJhc2VWYWx1ZXMob2JqZWN0LCBwcm9wcykge1xuICByZXR1cm4gYXJyYXlNYXAocHJvcHMsIGZ1bmN0aW9uKGtleSkge1xuICAgIHJldHVybiBvYmplY3Rba2V5XTtcbiAgfSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZVZhbHVlcztcbiIsIi8qKlxuICogVGhpcyBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnppcE9iamVjdGAgd2hpY2ggYXNzaWducyB2YWx1ZXMgdXNpbmcgYGFzc2lnbkZ1bmNgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBwcm9wcyBUaGUgcHJvcGVydHkgaWRlbnRpZmllcnMuXG4gKiBAcGFyYW0ge0FycmF5fSB2YWx1ZXMgVGhlIHByb3BlcnR5IHZhbHVlcy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGFzc2lnbkZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGFzc2lnbiB2YWx1ZXMuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgb2JqZWN0LlxuICovXG5mdW5jdGlvbiBiYXNlWmlwT2JqZWN0KHByb3BzLCB2YWx1ZXMsIGFzc2lnbkZ1bmMpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBwcm9wcy5sZW5ndGgsXG4gICAgICB2YWxzTGVuZ3RoID0gdmFsdWVzLmxlbmd0aCxcbiAgICAgIHJlc3VsdCA9IHt9O1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIHZhbHVlID0gaW5kZXggPCB2YWxzTGVuZ3RoID8gdmFsdWVzW2luZGV4XSA6IHVuZGVmaW5lZDtcbiAgICBhc3NpZ25GdW5jKHJlc3VsdCwgcHJvcHNbaW5kZXhdLCB2YWx1ZSk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlWmlwT2JqZWN0O1xuIiwiLyoqXG4gKiBDaGVja3MgaWYgYSBgY2FjaGVgIHZhbHVlIGZvciBga2V5YCBleGlzdHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBjYWNoZSBUaGUgY2FjaGUgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gY2FjaGVIYXMoY2FjaGUsIGtleSkge1xuICByZXR1cm4gY2FjaGUuaGFzKGtleSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY2FjaGVIYXM7XG4iLCJ2YXIgaWRlbnRpdHkgPSByZXF1aXJlKCcuL2lkZW50aXR5Jyk7XG5cbi8qKlxuICogQ2FzdHMgYHZhbHVlYCB0byBgaWRlbnRpdHlgIGlmIGl0J3Mgbm90IGEgZnVuY3Rpb24uXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGluc3BlY3QuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgY2FzdCBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gY2FzdEZ1bmN0aW9uKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ2Z1bmN0aW9uJyA/IHZhbHVlIDogaWRlbnRpdHk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY2FzdEZ1bmN0aW9uO1xuIiwidmFyIGlzQXJyYXkgPSByZXF1aXJlKCcuL2lzQXJyYXknKSxcbiAgICBpc0tleSA9IHJlcXVpcmUoJy4vX2lzS2V5JyksXG4gICAgc3RyaW5nVG9QYXRoID0gcmVxdWlyZSgnLi9fc3RyaW5nVG9QYXRoJyksXG4gICAgdG9TdHJpbmcgPSByZXF1aXJlKCcuL3RvU3RyaW5nJyk7XG5cbi8qKlxuICogQ2FzdHMgYHZhbHVlYCB0byBhIHBhdGggYXJyYXkgaWYgaXQncyBub3Qgb25lLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBpbnNwZWN0LlxuICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3RdIFRoZSBvYmplY3QgdG8gcXVlcnkga2V5cyBvbi5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgY2FzdCBwcm9wZXJ0eSBwYXRoIGFycmF5LlxuICovXG5mdW5jdGlvbiBjYXN0UGF0aCh2YWx1ZSwgb2JqZWN0KSB7XG4gIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICByZXR1cm4gaXNLZXkodmFsdWUsIG9iamVjdCkgPyBbdmFsdWVdIDogc3RyaW5nVG9QYXRoKHRvU3RyaW5nKHZhbHVlKSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY2FzdFBhdGg7XG4iLCJ2YXIgVWludDhBcnJheSA9IHJlcXVpcmUoJy4vX1VpbnQ4QXJyYXknKTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgY2xvbmUgb2YgYGFycmF5QnVmZmVyYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheUJ1ZmZlcn0gYXJyYXlCdWZmZXIgVGhlIGFycmF5IGJ1ZmZlciB0byBjbG9uZS5cbiAqIEByZXR1cm5zIHtBcnJheUJ1ZmZlcn0gUmV0dXJucyB0aGUgY2xvbmVkIGFycmF5IGJ1ZmZlci5cbiAqL1xuZnVuY3Rpb24gY2xvbmVBcnJheUJ1ZmZlcihhcnJheUJ1ZmZlcikge1xuICB2YXIgcmVzdWx0ID0gbmV3IGFycmF5QnVmZmVyLmNvbnN0cnVjdG9yKGFycmF5QnVmZmVyLmJ5dGVMZW5ndGgpO1xuICBuZXcgVWludDhBcnJheShyZXN1bHQpLnNldChuZXcgVWludDhBcnJheShhcnJheUJ1ZmZlcikpO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNsb25lQXJyYXlCdWZmZXI7XG4iLCJ2YXIgcm9vdCA9IHJlcXVpcmUoJy4vX3Jvb3QnKTtcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBleHBvcnRzYC4gKi9cbnZhciBmcmVlRXhwb3J0cyA9IHR5cGVvZiBleHBvcnRzID09ICdvYmplY3QnICYmIGV4cG9ydHMgJiYgIWV4cG9ydHMubm9kZVR5cGUgJiYgZXhwb3J0cztcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBtb2R1bGVgLiAqL1xudmFyIGZyZWVNb2R1bGUgPSBmcmVlRXhwb3J0cyAmJiB0eXBlb2YgbW9kdWxlID09ICdvYmplY3QnICYmIG1vZHVsZSAmJiAhbW9kdWxlLm5vZGVUeXBlICYmIG1vZHVsZTtcblxuLyoqIERldGVjdCB0aGUgcG9wdWxhciBDb21tb25KUyBleHRlbnNpb24gYG1vZHVsZS5leHBvcnRzYC4gKi9cbnZhciBtb2R1bGVFeHBvcnRzID0gZnJlZU1vZHVsZSAmJiBmcmVlTW9kdWxlLmV4cG9ydHMgPT09IGZyZWVFeHBvcnRzO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBCdWZmZXIgPSBtb2R1bGVFeHBvcnRzID8gcm9vdC5CdWZmZXIgOiB1bmRlZmluZWQsXG4gICAgYWxsb2NVbnNhZmUgPSBCdWZmZXIgPyBCdWZmZXIuYWxsb2NVbnNhZmUgOiB1bmRlZmluZWQ7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGNsb25lIG9mICBgYnVmZmVyYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtCdWZmZXJ9IGJ1ZmZlciBUaGUgYnVmZmVyIHRvIGNsb25lLlxuICogQHBhcmFtIHtib29sZWFufSBbaXNEZWVwXSBTcGVjaWZ5IGEgZGVlcCBjbG9uZS5cbiAqIEByZXR1cm5zIHtCdWZmZXJ9IFJldHVybnMgdGhlIGNsb25lZCBidWZmZXIuXG4gKi9cbmZ1bmN0aW9uIGNsb25lQnVmZmVyKGJ1ZmZlciwgaXNEZWVwKSB7XG4gIGlmIChpc0RlZXApIHtcbiAgICByZXR1cm4gYnVmZmVyLnNsaWNlKCk7XG4gIH1cbiAgdmFyIGxlbmd0aCA9IGJ1ZmZlci5sZW5ndGgsXG4gICAgICByZXN1bHQgPSBhbGxvY1Vuc2FmZSA/IGFsbG9jVW5zYWZlKGxlbmd0aCkgOiBuZXcgYnVmZmVyLmNvbnN0cnVjdG9yKGxlbmd0aCk7XG5cbiAgYnVmZmVyLmNvcHkocmVzdWx0KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjbG9uZUJ1ZmZlcjtcbiIsInZhciBjbG9uZUFycmF5QnVmZmVyID0gcmVxdWlyZSgnLi9fY2xvbmVBcnJheUJ1ZmZlcicpO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBjbG9uZSBvZiBgZGF0YVZpZXdgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gZGF0YVZpZXcgVGhlIGRhdGEgdmlldyB0byBjbG9uZS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzRGVlcF0gU3BlY2lmeSBhIGRlZXAgY2xvbmUuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjbG9uZWQgZGF0YSB2aWV3LlxuICovXG5mdW5jdGlvbiBjbG9uZURhdGFWaWV3KGRhdGFWaWV3LCBpc0RlZXApIHtcbiAgdmFyIGJ1ZmZlciA9IGlzRGVlcCA/IGNsb25lQXJyYXlCdWZmZXIoZGF0YVZpZXcuYnVmZmVyKSA6IGRhdGFWaWV3LmJ1ZmZlcjtcbiAgcmV0dXJuIG5ldyBkYXRhVmlldy5jb25zdHJ1Y3RvcihidWZmZXIsIGRhdGFWaWV3LmJ5dGVPZmZzZXQsIGRhdGFWaWV3LmJ5dGVMZW5ndGgpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNsb25lRGF0YVZpZXc7XG4iLCIvKiogVXNlZCB0byBtYXRjaCBgUmVnRXhwYCBmbGFncyBmcm9tIHRoZWlyIGNvZXJjZWQgc3RyaW5nIHZhbHVlcy4gKi9cbnZhciByZUZsYWdzID0gL1xcdyokLztcblxuLyoqXG4gKiBDcmVhdGVzIGEgY2xvbmUgb2YgYHJlZ2V4cGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSByZWdleHAgVGhlIHJlZ2V4cCB0byBjbG9uZS5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGNsb25lZCByZWdleHAuXG4gKi9cbmZ1bmN0aW9uIGNsb25lUmVnRXhwKHJlZ2V4cCkge1xuICB2YXIgcmVzdWx0ID0gbmV3IHJlZ2V4cC5jb25zdHJ1Y3RvcihyZWdleHAuc291cmNlLCByZUZsYWdzLmV4ZWMocmVnZXhwKSk7XG4gIHJlc3VsdC5sYXN0SW5kZXggPSByZWdleHAubGFzdEluZGV4O1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNsb25lUmVnRXhwO1xuIiwidmFyIFN5bWJvbCA9IHJlcXVpcmUoJy4vX1N5bWJvbCcpO1xuXG4vKiogVXNlZCB0byBjb252ZXJ0IHN5bWJvbHMgdG8gcHJpbWl0aXZlcyBhbmQgc3RyaW5ncy4gKi9cbnZhciBzeW1ib2xQcm90byA9IFN5bWJvbCA/IFN5bWJvbC5wcm90b3R5cGUgOiB1bmRlZmluZWQsXG4gICAgc3ltYm9sVmFsdWVPZiA9IHN5bWJvbFByb3RvID8gc3ltYm9sUHJvdG8udmFsdWVPZiA6IHVuZGVmaW5lZDtcblxuLyoqXG4gKiBDcmVhdGVzIGEgY2xvbmUgb2YgdGhlIGBzeW1ib2xgIG9iamVjdC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IHN5bWJvbCBUaGUgc3ltYm9sIG9iamVjdCB0byBjbG9uZS5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGNsb25lZCBzeW1ib2wgb2JqZWN0LlxuICovXG5mdW5jdGlvbiBjbG9uZVN5bWJvbChzeW1ib2wpIHtcbiAgcmV0dXJuIHN5bWJvbFZhbHVlT2YgPyBPYmplY3Qoc3ltYm9sVmFsdWVPZi5jYWxsKHN5bWJvbCkpIDoge307XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY2xvbmVTeW1ib2w7XG4iLCJ2YXIgY2xvbmVBcnJheUJ1ZmZlciA9IHJlcXVpcmUoJy4vX2Nsb25lQXJyYXlCdWZmZXInKTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgY2xvbmUgb2YgYHR5cGVkQXJyYXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gdHlwZWRBcnJheSBUaGUgdHlwZWQgYXJyYXkgdG8gY2xvbmUuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtpc0RlZXBdIFNwZWNpZnkgYSBkZWVwIGNsb25lLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY2xvbmVkIHR5cGVkIGFycmF5LlxuICovXG5mdW5jdGlvbiBjbG9uZVR5cGVkQXJyYXkodHlwZWRBcnJheSwgaXNEZWVwKSB7XG4gIHZhciBidWZmZXIgPSBpc0RlZXAgPyBjbG9uZUFycmF5QnVmZmVyKHR5cGVkQXJyYXkuYnVmZmVyKSA6IHR5cGVkQXJyYXkuYnVmZmVyO1xuICByZXR1cm4gbmV3IHR5cGVkQXJyYXkuY29uc3RydWN0b3IoYnVmZmVyLCB0eXBlZEFycmF5LmJ5dGVPZmZzZXQsIHR5cGVkQXJyYXkubGVuZ3RoKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjbG9uZVR5cGVkQXJyYXk7XG4iLCJ2YXIgaXNTeW1ib2wgPSByZXF1aXJlKCcuL2lzU3ltYm9sJyk7XG5cbi8qKlxuICogQ29tcGFyZXMgdmFsdWVzIHRvIHNvcnQgdGhlbSBpbiBhc2NlbmRpbmcgb3JkZXIuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0geyp9IG90aGVyIFRoZSBvdGhlciB2YWx1ZSB0byBjb21wYXJlLlxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgc29ydCBvcmRlciBpbmRpY2F0b3IgZm9yIGB2YWx1ZWAuXG4gKi9cbmZ1bmN0aW9uIGNvbXBhcmVBc2NlbmRpbmcodmFsdWUsIG90aGVyKSB7XG4gIGlmICh2YWx1ZSAhPT0gb3RoZXIpIHtcbiAgICB2YXIgdmFsSXNEZWZpbmVkID0gdmFsdWUgIT09IHVuZGVmaW5lZCxcbiAgICAgICAgdmFsSXNOdWxsID0gdmFsdWUgPT09IG51bGwsXG4gICAgICAgIHZhbElzUmVmbGV4aXZlID0gdmFsdWUgPT09IHZhbHVlLFxuICAgICAgICB2YWxJc1N5bWJvbCA9IGlzU3ltYm9sKHZhbHVlKTtcblxuICAgIHZhciBvdGhJc0RlZmluZWQgPSBvdGhlciAhPT0gdW5kZWZpbmVkLFxuICAgICAgICBvdGhJc051bGwgPSBvdGhlciA9PT0gbnVsbCxcbiAgICAgICAgb3RoSXNSZWZsZXhpdmUgPSBvdGhlciA9PT0gb3RoZXIsXG4gICAgICAgIG90aElzU3ltYm9sID0gaXNTeW1ib2wob3RoZXIpO1xuXG4gICAgaWYgKCghb3RoSXNOdWxsICYmICFvdGhJc1N5bWJvbCAmJiAhdmFsSXNTeW1ib2wgJiYgdmFsdWUgPiBvdGhlcikgfHxcbiAgICAgICAgKHZhbElzU3ltYm9sICYmIG90aElzRGVmaW5lZCAmJiBvdGhJc1JlZmxleGl2ZSAmJiAhb3RoSXNOdWxsICYmICFvdGhJc1N5bWJvbCkgfHxcbiAgICAgICAgKHZhbElzTnVsbCAmJiBvdGhJc0RlZmluZWQgJiYgb3RoSXNSZWZsZXhpdmUpIHx8XG4gICAgICAgICghdmFsSXNEZWZpbmVkICYmIG90aElzUmVmbGV4aXZlKSB8fFxuICAgICAgICAhdmFsSXNSZWZsZXhpdmUpIHtcbiAgICAgIHJldHVybiAxO1xuICAgIH1cbiAgICBpZiAoKCF2YWxJc051bGwgJiYgIXZhbElzU3ltYm9sICYmICFvdGhJc1N5bWJvbCAmJiB2YWx1ZSA8IG90aGVyKSB8fFxuICAgICAgICAob3RoSXNTeW1ib2wgJiYgdmFsSXNEZWZpbmVkICYmIHZhbElzUmVmbGV4aXZlICYmICF2YWxJc051bGwgJiYgIXZhbElzU3ltYm9sKSB8fFxuICAgICAgICAob3RoSXNOdWxsICYmIHZhbElzRGVmaW5lZCAmJiB2YWxJc1JlZmxleGl2ZSkgfHxcbiAgICAgICAgKCFvdGhJc0RlZmluZWQgJiYgdmFsSXNSZWZsZXhpdmUpIHx8XG4gICAgICAgICFvdGhJc1JlZmxleGl2ZSkge1xuICAgICAgcmV0dXJuIC0xO1xuICAgIH1cbiAgfVxuICByZXR1cm4gMDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjb21wYXJlQXNjZW5kaW5nO1xuIiwidmFyIGNvbXBhcmVBc2NlbmRpbmcgPSByZXF1aXJlKCcuL19jb21wYXJlQXNjZW5kaW5nJyk7XG5cbi8qKlxuICogVXNlZCBieSBgXy5vcmRlckJ5YCB0byBjb21wYXJlIG11bHRpcGxlIHByb3BlcnRpZXMgb2YgYSB2YWx1ZSB0byBhbm90aGVyXG4gKiBhbmQgc3RhYmxlIHNvcnQgdGhlbS5cbiAqXG4gKiBJZiBgb3JkZXJzYCBpcyB1bnNwZWNpZmllZCwgYWxsIHZhbHVlcyBhcmUgc29ydGVkIGluIGFzY2VuZGluZyBvcmRlci4gT3RoZXJ3aXNlLFxuICogc3BlY2lmeSBhbiBvcmRlciBvZiBcImRlc2NcIiBmb3IgZGVzY2VuZGluZyBvciBcImFzY1wiIGZvciBhc2NlbmRpbmcgc29ydCBvcmRlclxuICogb2YgY29ycmVzcG9uZGluZyB2YWx1ZXMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBjb21wYXJlLlxuICogQHBhcmFtIHtPYmplY3R9IG90aGVyIFRoZSBvdGhlciBvYmplY3QgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7Ym9vbGVhbltdfHN0cmluZ1tdfSBvcmRlcnMgVGhlIG9yZGVyIHRvIHNvcnQgYnkgZm9yIGVhY2ggcHJvcGVydHkuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBzb3J0IG9yZGVyIGluZGljYXRvciBmb3IgYG9iamVjdGAuXG4gKi9cbmZ1bmN0aW9uIGNvbXBhcmVNdWx0aXBsZShvYmplY3QsIG90aGVyLCBvcmRlcnMpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBvYmpDcml0ZXJpYSA9IG9iamVjdC5jcml0ZXJpYSxcbiAgICAgIG90aENyaXRlcmlhID0gb3RoZXIuY3JpdGVyaWEsXG4gICAgICBsZW5ndGggPSBvYmpDcml0ZXJpYS5sZW5ndGgsXG4gICAgICBvcmRlcnNMZW5ndGggPSBvcmRlcnMubGVuZ3RoO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIHJlc3VsdCA9IGNvbXBhcmVBc2NlbmRpbmcob2JqQ3JpdGVyaWFbaW5kZXhdLCBvdGhDcml0ZXJpYVtpbmRleF0pO1xuICAgIGlmIChyZXN1bHQpIHtcbiAgICAgIGlmIChpbmRleCA+PSBvcmRlcnNMZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cbiAgICAgIHZhciBvcmRlciA9IG9yZGVyc1tpbmRleF07XG4gICAgICByZXR1cm4gcmVzdWx0ICogKG9yZGVyID09ICdkZXNjJyA/IC0xIDogMSk7XG4gICAgfVxuICB9XG4gIC8vIEZpeGVzIGFuIGBBcnJheSNzb3J0YCBidWcgaW4gdGhlIEpTIGVuZ2luZSBlbWJlZGRlZCBpbiBBZG9iZSBhcHBsaWNhdGlvbnNcbiAgLy8gdGhhdCBjYXVzZXMgaXQsIHVuZGVyIGNlcnRhaW4gY2lyY3Vtc3RhbmNlcywgdG8gcHJvdmlkZSB0aGUgc2FtZSB2YWx1ZSBmb3JcbiAgLy8gYG9iamVjdGAgYW5kIGBvdGhlcmAuIFNlZSBodHRwczovL2dpdGh1Yi5jb20vamFzaGtlbmFzL3VuZGVyc2NvcmUvcHVsbC8xMjQ3XG4gIC8vIGZvciBtb3JlIGRldGFpbHMuXG4gIC8vXG4gIC8vIFRoaXMgYWxzbyBlbnN1cmVzIGEgc3RhYmxlIHNvcnQgaW4gVjggYW5kIG90aGVyIGVuZ2luZXMuXG4gIC8vIFNlZSBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvdjgvaXNzdWVzL2RldGFpbD9pZD05MCBmb3IgbW9yZSBkZXRhaWxzLlxuICByZXR1cm4gb2JqZWN0LmluZGV4IC0gb3RoZXIuaW5kZXg7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY29tcGFyZU11bHRpcGxlO1xuIiwiLyoqXG4gKiBDb3BpZXMgdGhlIHZhbHVlcyBvZiBgc291cmNlYCB0byBgYXJyYXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBzb3VyY2UgVGhlIGFycmF5IHRvIGNvcHkgdmFsdWVzIGZyb20uXG4gKiBAcGFyYW0ge0FycmF5fSBbYXJyYXk9W11dIFRoZSBhcnJheSB0byBjb3B5IHZhbHVlcyB0by5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgYXJyYXlgLlxuICovXG5mdW5jdGlvbiBjb3B5QXJyYXkoc291cmNlLCBhcnJheSkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IHNvdXJjZS5sZW5ndGg7XG5cbiAgYXJyYXkgfHwgKGFycmF5ID0gQXJyYXkobGVuZ3RoKSk7XG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgYXJyYXlbaW5kZXhdID0gc291cmNlW2luZGV4XTtcbiAgfVxuICByZXR1cm4gYXJyYXk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY29weUFycmF5O1xuIiwidmFyIGFzc2lnblZhbHVlID0gcmVxdWlyZSgnLi9fYXNzaWduVmFsdWUnKSxcbiAgICBiYXNlQXNzaWduVmFsdWUgPSByZXF1aXJlKCcuL19iYXNlQXNzaWduVmFsdWUnKTtcblxuLyoqXG4gKiBDb3BpZXMgcHJvcGVydGllcyBvZiBgc291cmNlYCB0byBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgb2JqZWN0IHRvIGNvcHkgcHJvcGVydGllcyBmcm9tLlxuICogQHBhcmFtIHtBcnJheX0gcHJvcHMgVGhlIHByb3BlcnR5IGlkZW50aWZpZXJzIHRvIGNvcHkuXG4gKiBAcGFyYW0ge09iamVjdH0gW29iamVjdD17fV0gVGhlIG9iamVjdCB0byBjb3B5IHByb3BlcnRpZXMgdG8uXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb3BpZWQgdmFsdWVzLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAqL1xuZnVuY3Rpb24gY29weU9iamVjdChzb3VyY2UsIHByb3BzLCBvYmplY3QsIGN1c3RvbWl6ZXIpIHtcbiAgdmFyIGlzTmV3ID0gIW9iamVjdDtcbiAgb2JqZWN0IHx8IChvYmplY3QgPSB7fSk7XG5cbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBwcm9wcy5sZW5ndGg7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIga2V5ID0gcHJvcHNbaW5kZXhdO1xuXG4gICAgdmFyIG5ld1ZhbHVlID0gY3VzdG9taXplclxuICAgICAgPyBjdXN0b21pemVyKG9iamVjdFtrZXldLCBzb3VyY2Vba2V5XSwga2V5LCBvYmplY3QsIHNvdXJjZSlcbiAgICAgIDogdW5kZWZpbmVkO1xuXG4gICAgaWYgKG5ld1ZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIG5ld1ZhbHVlID0gc291cmNlW2tleV07XG4gICAgfVxuICAgIGlmIChpc05ldykge1xuICAgICAgYmFzZUFzc2lnblZhbHVlKG9iamVjdCwga2V5LCBuZXdWYWx1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFzc2lnblZhbHVlKG9iamVjdCwga2V5LCBuZXdWYWx1ZSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBvYmplY3Q7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY29weU9iamVjdDtcbiIsInZhciBjb3B5T2JqZWN0ID0gcmVxdWlyZSgnLi9fY29weU9iamVjdCcpLFxuICAgIGdldFN5bWJvbHMgPSByZXF1aXJlKCcuL19nZXRTeW1ib2xzJyk7XG5cbi8qKlxuICogQ29waWVzIG93biBzeW1ib2xzIG9mIGBzb3VyY2VgIHRvIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBvYmplY3QgdG8gY29weSBzeW1ib2xzIGZyb20uXG4gKiBAcGFyYW0ge09iamVjdH0gW29iamVjdD17fV0gVGhlIG9iamVjdCB0byBjb3B5IHN5bWJvbHMgdG8uXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICovXG5mdW5jdGlvbiBjb3B5U3ltYm9scyhzb3VyY2UsIG9iamVjdCkge1xuICByZXR1cm4gY29weU9iamVjdChzb3VyY2UsIGdldFN5bWJvbHMoc291cmNlKSwgb2JqZWN0KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjb3B5U3ltYm9scztcbiIsInZhciBjb3B5T2JqZWN0ID0gcmVxdWlyZSgnLi9fY29weU9iamVjdCcpLFxuICAgIGdldFN5bWJvbHNJbiA9IHJlcXVpcmUoJy4vX2dldFN5bWJvbHNJbicpO1xuXG4vKipcbiAqIENvcGllcyBvd24gYW5kIGluaGVyaXRlZCBzeW1ib2xzIG9mIGBzb3VyY2VgIHRvIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBvYmplY3QgdG8gY29weSBzeW1ib2xzIGZyb20uXG4gKiBAcGFyYW0ge09iamVjdH0gW29iamVjdD17fV0gVGhlIG9iamVjdCB0byBjb3B5IHN5bWJvbHMgdG8uXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICovXG5mdW5jdGlvbiBjb3B5U3ltYm9sc0luKHNvdXJjZSwgb2JqZWN0KSB7XG4gIHJldHVybiBjb3B5T2JqZWN0KHNvdXJjZSwgZ2V0U3ltYm9sc0luKHNvdXJjZSksIG9iamVjdCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY29weVN5bWJvbHNJbjtcbiIsInZhciByb290ID0gcmVxdWlyZSgnLi9fcm9vdCcpO1xuXG4vKiogVXNlZCB0byBkZXRlY3Qgb3ZlcnJlYWNoaW5nIGNvcmUtanMgc2hpbXMuICovXG52YXIgY29yZUpzRGF0YSA9IHJvb3RbJ19fY29yZS1qc19zaGFyZWRfXyddO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGNvcmVKc0RhdGE7XG4iLCJ2YXIgYmFzZVJlc3QgPSByZXF1aXJlKCcuL19iYXNlUmVzdCcpLFxuICAgIGlzSXRlcmF0ZWVDYWxsID0gcmVxdWlyZSgnLi9faXNJdGVyYXRlZUNhbGwnKTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgZnVuY3Rpb24gbGlrZSBgXy5hc3NpZ25gLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBhc3NpZ25lciBUaGUgZnVuY3Rpb24gdG8gYXNzaWduIHZhbHVlcy5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGFzc2lnbmVyIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBjcmVhdGVBc3NpZ25lcihhc3NpZ25lcikge1xuICByZXR1cm4gYmFzZVJlc3QoZnVuY3Rpb24ob2JqZWN0LCBzb3VyY2VzKSB7XG4gICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgIGxlbmd0aCA9IHNvdXJjZXMubGVuZ3RoLFxuICAgICAgICBjdXN0b21pemVyID0gbGVuZ3RoID4gMSA/IHNvdXJjZXNbbGVuZ3RoIC0gMV0gOiB1bmRlZmluZWQsXG4gICAgICAgIGd1YXJkID0gbGVuZ3RoID4gMiA/IHNvdXJjZXNbMl0gOiB1bmRlZmluZWQ7XG5cbiAgICBjdXN0b21pemVyID0gKGFzc2lnbmVyLmxlbmd0aCA+IDMgJiYgdHlwZW9mIGN1c3RvbWl6ZXIgPT0gJ2Z1bmN0aW9uJylcbiAgICAgID8gKGxlbmd0aC0tLCBjdXN0b21pemVyKVxuICAgICAgOiB1bmRlZmluZWQ7XG5cbiAgICBpZiAoZ3VhcmQgJiYgaXNJdGVyYXRlZUNhbGwoc291cmNlc1swXSwgc291cmNlc1sxXSwgZ3VhcmQpKSB7XG4gICAgICBjdXN0b21pemVyID0gbGVuZ3RoIDwgMyA/IHVuZGVmaW5lZCA6IGN1c3RvbWl6ZXI7XG4gICAgICBsZW5ndGggPSAxO1xuICAgIH1cbiAgICBvYmplY3QgPSBPYmplY3Qob2JqZWN0KTtcbiAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgdmFyIHNvdXJjZSA9IHNvdXJjZXNbaW5kZXhdO1xuICAgICAgaWYgKHNvdXJjZSkge1xuICAgICAgICBhc3NpZ25lcihvYmplY3QsIHNvdXJjZSwgaW5kZXgsIGN1c3RvbWl6ZXIpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb2JqZWN0O1xuICB9KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjcmVhdGVBc3NpZ25lcjtcbiIsInZhciBpc0FycmF5TGlrZSA9IHJlcXVpcmUoJy4vaXNBcnJheUxpa2UnKTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgYGJhc2VFYWNoYCBvciBgYmFzZUVhY2hSaWdodGAgZnVuY3Rpb24uXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGVhY2hGdW5jIFRoZSBmdW5jdGlvbiB0byBpdGVyYXRlIG92ZXIgYSBjb2xsZWN0aW9uLlxuICogQHBhcmFtIHtib29sZWFufSBbZnJvbVJpZ2h0XSBTcGVjaWZ5IGl0ZXJhdGluZyBmcm9tIHJpZ2h0IHRvIGxlZnQuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBiYXNlIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBjcmVhdGVCYXNlRWFjaChlYWNoRnVuYywgZnJvbVJpZ2h0KSB7XG4gIHJldHVybiBmdW5jdGlvbihjb2xsZWN0aW9uLCBpdGVyYXRlZSkge1xuICAgIGlmIChjb2xsZWN0aW9uID09IG51bGwpIHtcbiAgICAgIHJldHVybiBjb2xsZWN0aW9uO1xuICAgIH1cbiAgICBpZiAoIWlzQXJyYXlMaWtlKGNvbGxlY3Rpb24pKSB7XG4gICAgICByZXR1cm4gZWFjaEZ1bmMoY29sbGVjdGlvbiwgaXRlcmF0ZWUpO1xuICAgIH1cbiAgICB2YXIgbGVuZ3RoID0gY29sbGVjdGlvbi5sZW5ndGgsXG4gICAgICAgIGluZGV4ID0gZnJvbVJpZ2h0ID8gbGVuZ3RoIDogLTEsXG4gICAgICAgIGl0ZXJhYmxlID0gT2JqZWN0KGNvbGxlY3Rpb24pO1xuXG4gICAgd2hpbGUgKChmcm9tUmlnaHQgPyBpbmRleC0tIDogKytpbmRleCA8IGxlbmd0aCkpIHtcbiAgICAgIGlmIChpdGVyYXRlZShpdGVyYWJsZVtpbmRleF0sIGluZGV4LCBpdGVyYWJsZSkgPT09IGZhbHNlKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY29sbGVjdGlvbjtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjcmVhdGVCYXNlRWFjaDtcbiIsIi8qKlxuICogQ3JlYXRlcyBhIGJhc2UgZnVuY3Rpb24gZm9yIG1ldGhvZHMgbGlrZSBgXy5mb3JJbmAgYW5kIGBfLmZvck93bmAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2Zyb21SaWdodF0gU3BlY2lmeSBpdGVyYXRpbmcgZnJvbSByaWdodCB0byBsZWZ0LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYmFzZSBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlQmFzZUZvcihmcm9tUmlnaHQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCwgaXRlcmF0ZWUsIGtleXNGdW5jKSB7XG4gICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgIGl0ZXJhYmxlID0gT2JqZWN0KG9iamVjdCksXG4gICAgICAgIHByb3BzID0ga2V5c0Z1bmMob2JqZWN0KSxcbiAgICAgICAgbGVuZ3RoID0gcHJvcHMubGVuZ3RoO1xuXG4gICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICB2YXIga2V5ID0gcHJvcHNbZnJvbVJpZ2h0ID8gbGVuZ3RoIDogKytpbmRleF07XG4gICAgICBpZiAoaXRlcmF0ZWUoaXRlcmFibGVba2V5XSwga2V5LCBpdGVyYWJsZSkgPT09IGZhbHNlKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb2JqZWN0O1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNyZWF0ZUJhc2VGb3I7XG4iLCJ2YXIgYmFzZUl0ZXJhdGVlID0gcmVxdWlyZSgnLi9fYmFzZUl0ZXJhdGVlJyksXG4gICAgaXNBcnJheUxpa2UgPSByZXF1aXJlKCcuL2lzQXJyYXlMaWtlJyksXG4gICAga2V5cyA9IHJlcXVpcmUoJy4va2V5cycpO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBgXy5maW5kYCBvciBgXy5maW5kTGFzdGAgZnVuY3Rpb24uXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZpbmRJbmRleEZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGZpbmQgdGhlIGNvbGxlY3Rpb24gaW5kZXguXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmaW5kIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBjcmVhdGVGaW5kKGZpbmRJbmRleEZ1bmMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKGNvbGxlY3Rpb24sIHByZWRpY2F0ZSwgZnJvbUluZGV4KSB7XG4gICAgdmFyIGl0ZXJhYmxlID0gT2JqZWN0KGNvbGxlY3Rpb24pO1xuICAgIGlmICghaXNBcnJheUxpa2UoY29sbGVjdGlvbikpIHtcbiAgICAgIHZhciBpdGVyYXRlZSA9IGJhc2VJdGVyYXRlZShwcmVkaWNhdGUsIDMpO1xuICAgICAgY29sbGVjdGlvbiA9IGtleXMoY29sbGVjdGlvbik7XG4gICAgICBwcmVkaWNhdGUgPSBmdW5jdGlvbihrZXkpIHsgcmV0dXJuIGl0ZXJhdGVlKGl0ZXJhYmxlW2tleV0sIGtleSwgaXRlcmFibGUpOyB9O1xuICAgIH1cbiAgICB2YXIgaW5kZXggPSBmaW5kSW5kZXhGdW5jKGNvbGxlY3Rpb24sIHByZWRpY2F0ZSwgZnJvbUluZGV4KTtcbiAgICByZXR1cm4gaW5kZXggPiAtMSA/IGl0ZXJhYmxlW2l0ZXJhdGVlID8gY29sbGVjdGlvbltpbmRleF0gOiBpbmRleF0gOiB1bmRlZmluZWQ7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY3JlYXRlRmluZDtcbiIsInZhciBiYXNlUmFuZ2UgPSByZXF1aXJlKCcuL19iYXNlUmFuZ2UnKSxcbiAgICBpc0l0ZXJhdGVlQ2FsbCA9IHJlcXVpcmUoJy4vX2lzSXRlcmF0ZWVDYWxsJyksXG4gICAgdG9GaW5pdGUgPSByZXF1aXJlKCcuL3RvRmluaXRlJyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGBfLnJhbmdlYCBvciBgXy5yYW5nZVJpZ2h0YCBmdW5jdGlvbi5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtib29sZWFufSBbZnJvbVJpZ2h0XSBTcGVjaWZ5IGl0ZXJhdGluZyBmcm9tIHJpZ2h0IHRvIGxlZnQuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyByYW5nZSBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlUmFuZ2UoZnJvbVJpZ2h0KSB7XG4gIHJldHVybiBmdW5jdGlvbihzdGFydCwgZW5kLCBzdGVwKSB7XG4gICAgaWYgKHN0ZXAgJiYgdHlwZW9mIHN0ZXAgIT0gJ251bWJlcicgJiYgaXNJdGVyYXRlZUNhbGwoc3RhcnQsIGVuZCwgc3RlcCkpIHtcbiAgICAgIGVuZCA9IHN0ZXAgPSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIC8vIEVuc3VyZSB0aGUgc2lnbiBvZiBgLTBgIGlzIHByZXNlcnZlZC5cbiAgICBzdGFydCA9IHRvRmluaXRlKHN0YXJ0KTtcbiAgICBpZiAoZW5kID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGVuZCA9IHN0YXJ0O1xuICAgICAgc3RhcnQgPSAwO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbmQgPSB0b0Zpbml0ZShlbmQpO1xuICAgIH1cbiAgICBzdGVwID0gc3RlcCA9PT0gdW5kZWZpbmVkID8gKHN0YXJ0IDwgZW5kID8gMSA6IC0xKSA6IHRvRmluaXRlKHN0ZXApO1xuICAgIHJldHVybiBiYXNlUmFuZ2Uoc3RhcnQsIGVuZCwgc3RlcCwgZnJvbVJpZ2h0KTtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjcmVhdGVSYW5nZTtcbiIsInZhciBTZXQgPSByZXF1aXJlKCcuL19TZXQnKSxcbiAgICBub29wID0gcmVxdWlyZSgnLi9ub29wJyksXG4gICAgc2V0VG9BcnJheSA9IHJlcXVpcmUoJy4vX3NldFRvQXJyYXknKTtcblxuLyoqIFVzZWQgYXMgcmVmZXJlbmNlcyBmb3IgdmFyaW91cyBgTnVtYmVyYCBjb25zdGFudHMuICovXG52YXIgSU5GSU5JVFkgPSAxIC8gMDtcblxuLyoqXG4gKiBDcmVhdGVzIGEgc2V0IG9iamVjdCBvZiBgdmFsdWVzYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gdmFsdWVzIFRoZSB2YWx1ZXMgdG8gYWRkIHRvIHRoZSBzZXQuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgc2V0LlxuICovXG52YXIgY3JlYXRlU2V0ID0gIShTZXQgJiYgKDEgLyBzZXRUb0FycmF5KG5ldyBTZXQoWywtMF0pKVsxXSkgPT0gSU5GSU5JVFkpID8gbm9vcCA6IGZ1bmN0aW9uKHZhbHVlcykge1xuICByZXR1cm4gbmV3IFNldCh2YWx1ZXMpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBjcmVhdGVTZXQ7XG4iLCJ2YXIgZ2V0TmF0aXZlID0gcmVxdWlyZSgnLi9fZ2V0TmF0aXZlJyk7XG5cbnZhciBkZWZpbmVQcm9wZXJ0eSA9IChmdW5jdGlvbigpIHtcbiAgdHJ5IHtcbiAgICB2YXIgZnVuYyA9IGdldE5hdGl2ZShPYmplY3QsICdkZWZpbmVQcm9wZXJ0eScpO1xuICAgIGZ1bmMoe30sICcnLCB7fSk7XG4gICAgcmV0dXJuIGZ1bmM7XG4gIH0gY2F0Y2ggKGUpIHt9XG59KCkpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGRlZmluZVByb3BlcnR5O1xuIiwidmFyIFNldENhY2hlID0gcmVxdWlyZSgnLi9fU2V0Q2FjaGUnKSxcbiAgICBhcnJheVNvbWUgPSByZXF1aXJlKCcuL19hcnJheVNvbWUnKSxcbiAgICBjYWNoZUhhcyA9IHJlcXVpcmUoJy4vX2NhY2hlSGFzJyk7XG5cbi8qKiBVc2VkIHRvIGNvbXBvc2UgYml0bWFza3MgZm9yIHZhbHVlIGNvbXBhcmlzb25zLiAqL1xudmFyIENPTVBBUkVfUEFSVElBTF9GTEFHID0gMSxcbiAgICBDT01QQVJFX1VOT1JERVJFRF9GTEFHID0gMjtcblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VJc0VxdWFsRGVlcGAgZm9yIGFycmF5cyB3aXRoIHN1cHBvcnQgZm9yXG4gKiBwYXJ0aWFsIGRlZXAgY29tcGFyaXNvbnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBjb21wYXJlLlxuICogQHBhcmFtIHtBcnJheX0gb3RoZXIgVGhlIG90aGVyIGFycmF5IHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge251bWJlcn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy4gU2VlIGBiYXNlSXNFcXVhbGAgZm9yIG1vcmUgZGV0YWlscy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGN1c3RvbWl6ZXIgVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb21wYXJpc29ucy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGVxdWFsRnVuYyBUaGUgZnVuY3Rpb24gdG8gZGV0ZXJtaW5lIGVxdWl2YWxlbnRzIG9mIHZhbHVlcy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBzdGFjayBUcmFja3MgdHJhdmVyc2VkIGBhcnJheWAgYW5kIGBvdGhlcmAgb2JqZWN0cy5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgYXJyYXlzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGVxdWFsQXJyYXlzKGFycmF5LCBvdGhlciwgYml0bWFzaywgY3VzdG9taXplciwgZXF1YWxGdW5jLCBzdGFjaykge1xuICB2YXIgaXNQYXJ0aWFsID0gYml0bWFzayAmIENPTVBBUkVfUEFSVElBTF9GTEFHLFxuICAgICAgYXJyTGVuZ3RoID0gYXJyYXkubGVuZ3RoLFxuICAgICAgb3RoTGVuZ3RoID0gb3RoZXIubGVuZ3RoO1xuXG4gIGlmIChhcnJMZW5ndGggIT0gb3RoTGVuZ3RoICYmICEoaXNQYXJ0aWFsICYmIG90aExlbmd0aCA+IGFyckxlbmd0aCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgLy8gQ2hlY2sgdGhhdCBjeWNsaWMgdmFsdWVzIGFyZSBlcXVhbC5cbiAgdmFyIGFyclN0YWNrZWQgPSBzdGFjay5nZXQoYXJyYXkpO1xuICB2YXIgb3RoU3RhY2tlZCA9IHN0YWNrLmdldChvdGhlcik7XG4gIGlmIChhcnJTdGFja2VkICYmIG90aFN0YWNrZWQpIHtcbiAgICByZXR1cm4gYXJyU3RhY2tlZCA9PSBvdGhlciAmJiBvdGhTdGFja2VkID09IGFycmF5O1xuICB9XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgcmVzdWx0ID0gdHJ1ZSxcbiAgICAgIHNlZW4gPSAoYml0bWFzayAmIENPTVBBUkVfVU5PUkRFUkVEX0ZMQUcpID8gbmV3IFNldENhY2hlIDogdW5kZWZpbmVkO1xuXG4gIHN0YWNrLnNldChhcnJheSwgb3RoZXIpO1xuICBzdGFjay5zZXQob3RoZXIsIGFycmF5KTtcblxuICAvLyBJZ25vcmUgbm9uLWluZGV4IHByb3BlcnRpZXMuXG4gIHdoaWxlICgrK2luZGV4IDwgYXJyTGVuZ3RoKSB7XG4gICAgdmFyIGFyclZhbHVlID0gYXJyYXlbaW5kZXhdLFxuICAgICAgICBvdGhWYWx1ZSA9IG90aGVyW2luZGV4XTtcblxuICAgIGlmIChjdXN0b21pemVyKSB7XG4gICAgICB2YXIgY29tcGFyZWQgPSBpc1BhcnRpYWxcbiAgICAgICAgPyBjdXN0b21pemVyKG90aFZhbHVlLCBhcnJWYWx1ZSwgaW5kZXgsIG90aGVyLCBhcnJheSwgc3RhY2spXG4gICAgICAgIDogY3VzdG9taXplcihhcnJWYWx1ZSwgb3RoVmFsdWUsIGluZGV4LCBhcnJheSwgb3RoZXIsIHN0YWNrKTtcbiAgICB9XG4gICAgaWYgKGNvbXBhcmVkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGlmIChjb21wYXJlZCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHJlc3VsdCA9IGZhbHNlO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIC8vIFJlY3Vyc2l2ZWx5IGNvbXBhcmUgYXJyYXlzIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cykuXG4gICAgaWYgKHNlZW4pIHtcbiAgICAgIGlmICghYXJyYXlTb21lKG90aGVyLCBmdW5jdGlvbihvdGhWYWx1ZSwgb3RoSW5kZXgpIHtcbiAgICAgICAgICAgIGlmICghY2FjaGVIYXMoc2Vlbiwgb3RoSW5kZXgpICYmXG4gICAgICAgICAgICAgICAgKGFyclZhbHVlID09PSBvdGhWYWx1ZSB8fCBlcXVhbEZ1bmMoYXJyVmFsdWUsIG90aFZhbHVlLCBiaXRtYXNrLCBjdXN0b21pemVyLCBzdGFjaykpKSB7XG4gICAgICAgICAgICAgIHJldHVybiBzZWVuLnB1c2gob3RoSW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pKSB7XG4gICAgICAgIHJlc3VsdCA9IGZhbHNlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCEoXG4gICAgICAgICAgYXJyVmFsdWUgPT09IG90aFZhbHVlIHx8XG4gICAgICAgICAgICBlcXVhbEZ1bmMoYXJyVmFsdWUsIG90aFZhbHVlLCBiaXRtYXNrLCBjdXN0b21pemVyLCBzdGFjaylcbiAgICAgICAgKSkge1xuICAgICAgcmVzdWx0ID0gZmFsc2U7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgc3RhY2tbJ2RlbGV0ZSddKGFycmF5KTtcbiAgc3RhY2tbJ2RlbGV0ZSddKG90aGVyKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBlcXVhbEFycmF5cztcbiIsInZhciBTeW1ib2wgPSByZXF1aXJlKCcuL19TeW1ib2wnKSxcbiAgICBVaW50OEFycmF5ID0gcmVxdWlyZSgnLi9fVWludDhBcnJheScpLFxuICAgIGVxID0gcmVxdWlyZSgnLi9lcScpLFxuICAgIGVxdWFsQXJyYXlzID0gcmVxdWlyZSgnLi9fZXF1YWxBcnJheXMnKSxcbiAgICBtYXBUb0FycmF5ID0gcmVxdWlyZSgnLi9fbWFwVG9BcnJheScpLFxuICAgIHNldFRvQXJyYXkgPSByZXF1aXJlKCcuL19zZXRUb0FycmF5Jyk7XG5cbi8qKiBVc2VkIHRvIGNvbXBvc2UgYml0bWFza3MgZm9yIHZhbHVlIGNvbXBhcmlzb25zLiAqL1xudmFyIENPTVBBUkVfUEFSVElBTF9GTEFHID0gMSxcbiAgICBDT01QQVJFX1VOT1JERVJFRF9GTEFHID0gMjtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIGJvb2xUYWcgPSAnW29iamVjdCBCb29sZWFuXScsXG4gICAgZGF0ZVRhZyA9ICdbb2JqZWN0IERhdGVdJyxcbiAgICBlcnJvclRhZyA9ICdbb2JqZWN0IEVycm9yXScsXG4gICAgbWFwVGFnID0gJ1tvYmplY3QgTWFwXScsXG4gICAgbnVtYmVyVGFnID0gJ1tvYmplY3QgTnVtYmVyXScsXG4gICAgcmVnZXhwVGFnID0gJ1tvYmplY3QgUmVnRXhwXScsXG4gICAgc2V0VGFnID0gJ1tvYmplY3QgU2V0XScsXG4gICAgc3RyaW5nVGFnID0gJ1tvYmplY3QgU3RyaW5nXScsXG4gICAgc3ltYm9sVGFnID0gJ1tvYmplY3QgU3ltYm9sXSc7XG5cbnZhciBhcnJheUJ1ZmZlclRhZyA9ICdbb2JqZWN0IEFycmF5QnVmZmVyXScsXG4gICAgZGF0YVZpZXdUYWcgPSAnW29iamVjdCBEYXRhVmlld10nO1xuXG4vKiogVXNlZCB0byBjb252ZXJ0IHN5bWJvbHMgdG8gcHJpbWl0aXZlcyBhbmQgc3RyaW5ncy4gKi9cbnZhciBzeW1ib2xQcm90byA9IFN5bWJvbCA/IFN5bWJvbC5wcm90b3R5cGUgOiB1bmRlZmluZWQsXG4gICAgc3ltYm9sVmFsdWVPZiA9IHN5bWJvbFByb3RvID8gc3ltYm9sUHJvdG8udmFsdWVPZiA6IHVuZGVmaW5lZDtcblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VJc0VxdWFsRGVlcGAgZm9yIGNvbXBhcmluZyBvYmplY3RzIG9mXG4gKiB0aGUgc2FtZSBgdG9TdHJpbmdUYWdgLlxuICpcbiAqICoqTm90ZToqKiBUaGlzIGZ1bmN0aW9uIG9ubHkgc3VwcG9ydHMgY29tcGFyaW5nIHZhbHVlcyB3aXRoIHRhZ3Mgb2ZcbiAqIGBCb29sZWFuYCwgYERhdGVgLCBgRXJyb3JgLCBgTnVtYmVyYCwgYFJlZ0V4cGAsIG9yIGBTdHJpbmdgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvdGhlciBUaGUgb3RoZXIgb2JqZWN0IHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge3N0cmluZ30gdGFnIFRoZSBgdG9TdHJpbmdUYWdgIG9mIHRoZSBvYmplY3RzIHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge251bWJlcn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy4gU2VlIGBiYXNlSXNFcXVhbGAgZm9yIG1vcmUgZGV0YWlscy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGN1c3RvbWl6ZXIgVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb21wYXJpc29ucy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGVxdWFsRnVuYyBUaGUgZnVuY3Rpb24gdG8gZGV0ZXJtaW5lIGVxdWl2YWxlbnRzIG9mIHZhbHVlcy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBzdGFjayBUcmFja3MgdHJhdmVyc2VkIGBvYmplY3RgIGFuZCBgb3RoZXJgIG9iamVjdHMuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIG9iamVjdHMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gZXF1YWxCeVRhZyhvYmplY3QsIG90aGVyLCB0YWcsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGVxdWFsRnVuYywgc3RhY2spIHtcbiAgc3dpdGNoICh0YWcpIHtcbiAgICBjYXNlIGRhdGFWaWV3VGFnOlxuICAgICAgaWYgKChvYmplY3QuYnl0ZUxlbmd0aCAhPSBvdGhlci5ieXRlTGVuZ3RoKSB8fFxuICAgICAgICAgIChvYmplY3QuYnl0ZU9mZnNldCAhPSBvdGhlci5ieXRlT2Zmc2V0KSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBvYmplY3QgPSBvYmplY3QuYnVmZmVyO1xuICAgICAgb3RoZXIgPSBvdGhlci5idWZmZXI7XG5cbiAgICBjYXNlIGFycmF5QnVmZmVyVGFnOlxuICAgICAgaWYgKChvYmplY3QuYnl0ZUxlbmd0aCAhPSBvdGhlci5ieXRlTGVuZ3RoKSB8fFxuICAgICAgICAgICFlcXVhbEZ1bmMobmV3IFVpbnQ4QXJyYXkob2JqZWN0KSwgbmV3IFVpbnQ4QXJyYXkob3RoZXIpKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcblxuICAgIGNhc2UgYm9vbFRhZzpcbiAgICBjYXNlIGRhdGVUYWc6XG4gICAgY2FzZSBudW1iZXJUYWc6XG4gICAgICAvLyBDb2VyY2UgYm9vbGVhbnMgdG8gYDFgIG9yIGAwYCBhbmQgZGF0ZXMgdG8gbWlsbGlzZWNvbmRzLlxuICAgICAgLy8gSW52YWxpZCBkYXRlcyBhcmUgY29lcmNlZCB0byBgTmFOYC5cbiAgICAgIHJldHVybiBlcSgrb2JqZWN0LCArb3RoZXIpO1xuXG4gICAgY2FzZSBlcnJvclRhZzpcbiAgICAgIHJldHVybiBvYmplY3QubmFtZSA9PSBvdGhlci5uYW1lICYmIG9iamVjdC5tZXNzYWdlID09IG90aGVyLm1lc3NhZ2U7XG5cbiAgICBjYXNlIHJlZ2V4cFRhZzpcbiAgICBjYXNlIHN0cmluZ1RhZzpcbiAgICAgIC8vIENvZXJjZSByZWdleGVzIHRvIHN0cmluZ3MgYW5kIHRyZWF0IHN0cmluZ3MsIHByaW1pdGl2ZXMgYW5kIG9iamVjdHMsXG4gICAgICAvLyBhcyBlcXVhbC4gU2VlIGh0dHA6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1yZWdleHAucHJvdG90eXBlLnRvc3RyaW5nXG4gICAgICAvLyBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAgcmV0dXJuIG9iamVjdCA9PSAob3RoZXIgKyAnJyk7XG5cbiAgICBjYXNlIG1hcFRhZzpcbiAgICAgIHZhciBjb252ZXJ0ID0gbWFwVG9BcnJheTtcblxuICAgIGNhc2Ugc2V0VGFnOlxuICAgICAgdmFyIGlzUGFydGlhbCA9IGJpdG1hc2sgJiBDT01QQVJFX1BBUlRJQUxfRkxBRztcbiAgICAgIGNvbnZlcnQgfHwgKGNvbnZlcnQgPSBzZXRUb0FycmF5KTtcblxuICAgICAgaWYgKG9iamVjdC5zaXplICE9IG90aGVyLnNpemUgJiYgIWlzUGFydGlhbCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICAvLyBBc3N1bWUgY3ljbGljIHZhbHVlcyBhcmUgZXF1YWwuXG4gICAgICB2YXIgc3RhY2tlZCA9IHN0YWNrLmdldChvYmplY3QpO1xuICAgICAgaWYgKHN0YWNrZWQpIHtcbiAgICAgICAgcmV0dXJuIHN0YWNrZWQgPT0gb3RoZXI7XG4gICAgICB9XG4gICAgICBiaXRtYXNrIHw9IENPTVBBUkVfVU5PUkRFUkVEX0ZMQUc7XG5cbiAgICAgIC8vIFJlY3Vyc2l2ZWx5IGNvbXBhcmUgb2JqZWN0cyAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpLlxuICAgICAgc3RhY2suc2V0KG9iamVjdCwgb3RoZXIpO1xuICAgICAgdmFyIHJlc3VsdCA9IGVxdWFsQXJyYXlzKGNvbnZlcnQob2JqZWN0KSwgY29udmVydChvdGhlciksIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGVxdWFsRnVuYywgc3RhY2spO1xuICAgICAgc3RhY2tbJ2RlbGV0ZSddKG9iamVjdCk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuXG4gICAgY2FzZSBzeW1ib2xUYWc6XG4gICAgICBpZiAoc3ltYm9sVmFsdWVPZikge1xuICAgICAgICByZXR1cm4gc3ltYm9sVmFsdWVPZi5jYWxsKG9iamVjdCkgPT0gc3ltYm9sVmFsdWVPZi5jYWxsKG90aGVyKTtcbiAgICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZXF1YWxCeVRhZztcbiIsInZhciBnZXRBbGxLZXlzID0gcmVxdWlyZSgnLi9fZ2V0QWxsS2V5cycpO1xuXG4vKiogVXNlZCB0byBjb21wb3NlIGJpdG1hc2tzIGZvciB2YWx1ZSBjb21wYXJpc29ucy4gKi9cbnZhciBDT01QQVJFX1BBUlRJQUxfRkxBRyA9IDE7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlSXNFcXVhbERlZXBgIGZvciBvYmplY3RzIHdpdGggc3VwcG9ydCBmb3JcbiAqIHBhcnRpYWwgZGVlcCBjb21wYXJpc29ucy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge09iamVjdH0gb3RoZXIgVGhlIG90aGVyIG9iamVjdCB0byBjb21wYXJlLlxuICogQHBhcmFtIHtudW1iZXJ9IGJpdG1hc2sgVGhlIGJpdG1hc2sgZmxhZ3MuIFNlZSBgYmFzZUlzRXF1YWxgIGZvciBtb3JlIGRldGFpbHMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjdXN0b21pemVyIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29tcGFyaXNvbnMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBlcXVhbEZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGRldGVybWluZSBlcXVpdmFsZW50cyBvZiB2YWx1ZXMuXG4gKiBAcGFyYW0ge09iamVjdH0gc3RhY2sgVHJhY2tzIHRyYXZlcnNlZCBgb2JqZWN0YCBhbmQgYG90aGVyYCBvYmplY3RzLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBvYmplY3RzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGVxdWFsT2JqZWN0cyhvYmplY3QsIG90aGVyLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKSB7XG4gIHZhciBpc1BhcnRpYWwgPSBiaXRtYXNrICYgQ09NUEFSRV9QQVJUSUFMX0ZMQUcsXG4gICAgICBvYmpQcm9wcyA9IGdldEFsbEtleXMob2JqZWN0KSxcbiAgICAgIG9iakxlbmd0aCA9IG9ialByb3BzLmxlbmd0aCxcbiAgICAgIG90aFByb3BzID0gZ2V0QWxsS2V5cyhvdGhlciksXG4gICAgICBvdGhMZW5ndGggPSBvdGhQcm9wcy5sZW5ndGg7XG5cbiAgaWYgKG9iakxlbmd0aCAhPSBvdGhMZW5ndGggJiYgIWlzUGFydGlhbCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgaW5kZXggPSBvYmpMZW5ndGg7XG4gIHdoaWxlIChpbmRleC0tKSB7XG4gICAgdmFyIGtleSA9IG9ialByb3BzW2luZGV4XTtcbiAgICBpZiAoIShpc1BhcnRpYWwgPyBrZXkgaW4gb3RoZXIgOiBoYXNPd25Qcm9wZXJ0eS5jYWxsKG90aGVyLCBrZXkpKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICAvLyBDaGVjayB0aGF0IGN5Y2xpYyB2YWx1ZXMgYXJlIGVxdWFsLlxuICB2YXIgb2JqU3RhY2tlZCA9IHN0YWNrLmdldChvYmplY3QpO1xuICB2YXIgb3RoU3RhY2tlZCA9IHN0YWNrLmdldChvdGhlcik7XG4gIGlmIChvYmpTdGFja2VkICYmIG90aFN0YWNrZWQpIHtcbiAgICByZXR1cm4gb2JqU3RhY2tlZCA9PSBvdGhlciAmJiBvdGhTdGFja2VkID09IG9iamVjdDtcbiAgfVxuICB2YXIgcmVzdWx0ID0gdHJ1ZTtcbiAgc3RhY2suc2V0KG9iamVjdCwgb3RoZXIpO1xuICBzdGFjay5zZXQob3RoZXIsIG9iamVjdCk7XG5cbiAgdmFyIHNraXBDdG9yID0gaXNQYXJ0aWFsO1xuICB3aGlsZSAoKytpbmRleCA8IG9iakxlbmd0aCkge1xuICAgIGtleSA9IG9ialByb3BzW2luZGV4XTtcbiAgICB2YXIgb2JqVmFsdWUgPSBvYmplY3Rba2V5XSxcbiAgICAgICAgb3RoVmFsdWUgPSBvdGhlcltrZXldO1xuXG4gICAgaWYgKGN1c3RvbWl6ZXIpIHtcbiAgICAgIHZhciBjb21wYXJlZCA9IGlzUGFydGlhbFxuICAgICAgICA/IGN1c3RvbWl6ZXIob3RoVmFsdWUsIG9ialZhbHVlLCBrZXksIG90aGVyLCBvYmplY3QsIHN0YWNrKVxuICAgICAgICA6IGN1c3RvbWl6ZXIob2JqVmFsdWUsIG90aFZhbHVlLCBrZXksIG9iamVjdCwgb3RoZXIsIHN0YWNrKTtcbiAgICB9XG4gICAgLy8gUmVjdXJzaXZlbHkgY29tcGFyZSBvYmplY3RzIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cykuXG4gICAgaWYgKCEoY29tcGFyZWQgPT09IHVuZGVmaW5lZFxuICAgICAgICAgID8gKG9ialZhbHVlID09PSBvdGhWYWx1ZSB8fCBlcXVhbEZ1bmMob2JqVmFsdWUsIG90aFZhbHVlLCBiaXRtYXNrLCBjdXN0b21pemVyLCBzdGFjaykpXG4gICAgICAgICAgOiBjb21wYXJlZFxuICAgICAgICApKSB7XG4gICAgICByZXN1bHQgPSBmYWxzZTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBza2lwQ3RvciB8fCAoc2tpcEN0b3IgPSBrZXkgPT0gJ2NvbnN0cnVjdG9yJyk7XG4gIH1cbiAgaWYgKHJlc3VsdCAmJiAhc2tpcEN0b3IpIHtcbiAgICB2YXIgb2JqQ3RvciA9IG9iamVjdC5jb25zdHJ1Y3RvcixcbiAgICAgICAgb3RoQ3RvciA9IG90aGVyLmNvbnN0cnVjdG9yO1xuXG4gICAgLy8gTm9uIGBPYmplY3RgIG9iamVjdCBpbnN0YW5jZXMgd2l0aCBkaWZmZXJlbnQgY29uc3RydWN0b3JzIGFyZSBub3QgZXF1YWwuXG4gICAgaWYgKG9iakN0b3IgIT0gb3RoQ3RvciAmJlxuICAgICAgICAoJ2NvbnN0cnVjdG9yJyBpbiBvYmplY3QgJiYgJ2NvbnN0cnVjdG9yJyBpbiBvdGhlcikgJiZcbiAgICAgICAgISh0eXBlb2Ygb2JqQ3RvciA9PSAnZnVuY3Rpb24nICYmIG9iakN0b3IgaW5zdGFuY2VvZiBvYmpDdG9yICYmXG4gICAgICAgICAgdHlwZW9mIG90aEN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiBvdGhDdG9yIGluc3RhbmNlb2Ygb3RoQ3RvcikpIHtcbiAgICAgIHJlc3VsdCA9IGZhbHNlO1xuICAgIH1cbiAgfVxuICBzdGFja1snZGVsZXRlJ10ob2JqZWN0KTtcbiAgc3RhY2tbJ2RlbGV0ZSddKG90aGVyKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBlcXVhbE9iamVjdHM7XG4iLCJ2YXIgZmxhdHRlbiA9IHJlcXVpcmUoJy4vZmxhdHRlbicpLFxuICAgIG92ZXJSZXN0ID0gcmVxdWlyZSgnLi9fb3ZlclJlc3QnKSxcbiAgICBzZXRUb1N0cmluZyA9IHJlcXVpcmUoJy4vX3NldFRvU3RyaW5nJyk7XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlUmVzdGAgd2hpY2ggZmxhdHRlbnMgdGhlIHJlc3QgYXJyYXkuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGFwcGx5IGEgcmVzdCBwYXJhbWV0ZXIgdG8uXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gZmxhdFJlc3QoZnVuYykge1xuICByZXR1cm4gc2V0VG9TdHJpbmcob3ZlclJlc3QoZnVuYywgdW5kZWZpbmVkLCBmbGF0dGVuKSwgZnVuYyArICcnKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmbGF0UmVzdDtcbiIsIi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgZ2xvYmFsYCBmcm9tIE5vZGUuanMuICovXG52YXIgZnJlZUdsb2JhbCA9IHR5cGVvZiBnbG9iYWwgPT0gJ29iamVjdCcgJiYgZ2xvYmFsICYmIGdsb2JhbC5PYmplY3QgPT09IE9iamVjdCAmJiBnbG9iYWw7XG5cbm1vZHVsZS5leHBvcnRzID0gZnJlZUdsb2JhbDtcbiIsInZhciBiYXNlR2V0QWxsS2V5cyA9IHJlcXVpcmUoJy4vX2Jhc2VHZXRBbGxLZXlzJyksXG4gICAgZ2V0U3ltYm9scyA9IHJlcXVpcmUoJy4vX2dldFN5bWJvbHMnKSxcbiAgICBrZXlzID0gcmVxdWlyZSgnLi9rZXlzJyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiBvd24gZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBhbmQgc3ltYm9scyBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcyBhbmQgc3ltYm9scy5cbiAqL1xuZnVuY3Rpb24gZ2V0QWxsS2V5cyhvYmplY3QpIHtcbiAgcmV0dXJuIGJhc2VHZXRBbGxLZXlzKG9iamVjdCwga2V5cywgZ2V0U3ltYm9scyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0QWxsS2V5cztcbiIsInZhciBiYXNlR2V0QWxsS2V5cyA9IHJlcXVpcmUoJy4vX2Jhc2VHZXRBbGxLZXlzJyksXG4gICAgZ2V0U3ltYm9sc0luID0gcmVxdWlyZSgnLi9fZ2V0U3ltYm9sc0luJyksXG4gICAga2V5c0luID0gcmVxdWlyZSgnLi9rZXlzSW4nKTtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIG93biBhbmQgaW5oZXJpdGVkIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgYW5kXG4gKiBzeW1ib2xzIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzIGFuZCBzeW1ib2xzLlxuICovXG5mdW5jdGlvbiBnZXRBbGxLZXlzSW4ob2JqZWN0KSB7XG4gIHJldHVybiBiYXNlR2V0QWxsS2V5cyhvYmplY3QsIGtleXNJbiwgZ2V0U3ltYm9sc0luKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZXRBbGxLZXlzSW47XG4iLCJ2YXIgaXNLZXlhYmxlID0gcmVxdWlyZSgnLi9faXNLZXlhYmxlJyk7XG5cbi8qKlxuICogR2V0cyB0aGUgZGF0YSBmb3IgYG1hcGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBtYXAgVGhlIG1hcCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIHJlZmVyZW5jZSBrZXkuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgbWFwIGRhdGEuXG4gKi9cbmZ1bmN0aW9uIGdldE1hcERhdGEobWFwLCBrZXkpIHtcbiAgdmFyIGRhdGEgPSBtYXAuX19kYXRhX187XG4gIHJldHVybiBpc0tleWFibGUoa2V5KVxuICAgID8gZGF0YVt0eXBlb2Yga2V5ID09ICdzdHJpbmcnID8gJ3N0cmluZycgOiAnaGFzaCddXG4gICAgOiBkYXRhLm1hcDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZXRNYXBEYXRhO1xuIiwidmFyIGlzU3RyaWN0Q29tcGFyYWJsZSA9IHJlcXVpcmUoJy4vX2lzU3RyaWN0Q29tcGFyYWJsZScpLFxuICAgIGtleXMgPSByZXF1aXJlKCcuL2tleXMnKTtcblxuLyoqXG4gKiBHZXRzIHRoZSBwcm9wZXJ0eSBuYW1lcywgdmFsdWVzLCBhbmQgY29tcGFyZSBmbGFncyBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBtYXRjaCBkYXRhIG9mIGBvYmplY3RgLlxuICovXG5mdW5jdGlvbiBnZXRNYXRjaERhdGEob2JqZWN0KSB7XG4gIHZhciByZXN1bHQgPSBrZXlzKG9iamVjdCksXG4gICAgICBsZW5ndGggPSByZXN1bHQubGVuZ3RoO1xuXG4gIHdoaWxlIChsZW5ndGgtLSkge1xuICAgIHZhciBrZXkgPSByZXN1bHRbbGVuZ3RoXSxcbiAgICAgICAgdmFsdWUgPSBvYmplY3Rba2V5XTtcblxuICAgIHJlc3VsdFtsZW5ndGhdID0gW2tleSwgdmFsdWUsIGlzU3RyaWN0Q29tcGFyYWJsZSh2YWx1ZSldO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0TWF0Y2hEYXRhO1xuIiwidmFyIGJhc2VJc05hdGl2ZSA9IHJlcXVpcmUoJy4vX2Jhc2VJc05hdGl2ZScpLFxuICAgIGdldFZhbHVlID0gcmVxdWlyZSgnLi9fZ2V0VmFsdWUnKTtcblxuLyoqXG4gKiBHZXRzIHRoZSBuYXRpdmUgZnVuY3Rpb24gYXQgYGtleWAgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgbWV0aG9kIHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBmdW5jdGlvbiBpZiBpdCdzIG5hdGl2ZSwgZWxzZSBgdW5kZWZpbmVkYC5cbiAqL1xuZnVuY3Rpb24gZ2V0TmF0aXZlKG9iamVjdCwga2V5KSB7XG4gIHZhciB2YWx1ZSA9IGdldFZhbHVlKG9iamVjdCwga2V5KTtcbiAgcmV0dXJuIGJhc2VJc05hdGl2ZSh2YWx1ZSkgPyB2YWx1ZSA6IHVuZGVmaW5lZDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZXROYXRpdmU7XG4iLCJ2YXIgb3ZlckFyZyA9IHJlcXVpcmUoJy4vX292ZXJBcmcnKTtcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgZ2V0UHJvdG90eXBlID0gb3ZlckFyZyhPYmplY3QuZ2V0UHJvdG90eXBlT2YsIE9iamVjdCk7XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0UHJvdG90eXBlO1xuIiwidmFyIFN5bWJvbCA9IHJlcXVpcmUoJy4vX1N5bWJvbCcpO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIFVzZWQgdG8gcmVzb2x2ZSB0aGVcbiAqIFtgdG9TdHJpbmdUYWdgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1vYmplY3QucHJvdG90eXBlLnRvc3RyaW5nKVxuICogb2YgdmFsdWVzLlxuICovXG52YXIgbmF0aXZlT2JqZWN0VG9TdHJpbmcgPSBvYmplY3RQcm90by50b1N0cmluZztcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgc3ltVG9TdHJpbmdUYWcgPSBTeW1ib2wgPyBTeW1ib2wudG9TdHJpbmdUYWcgOiB1bmRlZmluZWQ7XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlR2V0VGFnYCB3aGljaCBpZ25vcmVzIGBTeW1ib2wudG9TdHJpbmdUYWdgIHZhbHVlcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSByYXcgYHRvU3RyaW5nVGFnYC5cbiAqL1xuZnVuY3Rpb24gZ2V0UmF3VGFnKHZhbHVlKSB7XG4gIHZhciBpc093biA9IGhhc093blByb3BlcnR5LmNhbGwodmFsdWUsIHN5bVRvU3RyaW5nVGFnKSxcbiAgICAgIHRhZyA9IHZhbHVlW3N5bVRvU3RyaW5nVGFnXTtcblxuICB0cnkge1xuICAgIHZhbHVlW3N5bVRvU3RyaW5nVGFnXSA9IHVuZGVmaW5lZDtcbiAgICB2YXIgdW5tYXNrZWQgPSB0cnVlO1xuICB9IGNhdGNoIChlKSB7fVxuXG4gIHZhciByZXN1bHQgPSBuYXRpdmVPYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKTtcbiAgaWYgKHVubWFza2VkKSB7XG4gICAgaWYgKGlzT3duKSB7XG4gICAgICB2YWx1ZVtzeW1Ub1N0cmluZ1RhZ10gPSB0YWc7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlbGV0ZSB2YWx1ZVtzeW1Ub1N0cmluZ1RhZ107XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0UmF3VGFnO1xuIiwidmFyIGFycmF5RmlsdGVyID0gcmVxdWlyZSgnLi9fYXJyYXlGaWx0ZXInKSxcbiAgICBzdHViQXJyYXkgPSByZXF1aXJlKCcuL3N0dWJBcnJheScpO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBwcm9wZXJ0eUlzRW51bWVyYWJsZSA9IG9iamVjdFByb3RvLnByb3BlcnR5SXNFbnVtZXJhYmxlO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyBmb3IgdGhvc2Ugd2l0aCB0aGUgc2FtZSBuYW1lIGFzIG90aGVyIGBsb2Rhc2hgIG1ldGhvZHMuICovXG52YXIgbmF0aXZlR2V0U3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHM7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiB0aGUgb3duIGVudW1lcmFibGUgc3ltYm9scyBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBzeW1ib2xzLlxuICovXG52YXIgZ2V0U3ltYm9scyA9ICFuYXRpdmVHZXRTeW1ib2xzID8gc3R1YkFycmF5IDogZnVuY3Rpb24ob2JqZWN0KSB7XG4gIGlmIChvYmplY3QgPT0gbnVsbCkge1xuICAgIHJldHVybiBbXTtcbiAgfVxuICBvYmplY3QgPSBPYmplY3Qob2JqZWN0KTtcbiAgcmV0dXJuIGFycmF5RmlsdGVyKG5hdGl2ZUdldFN5bWJvbHMob2JqZWN0KSwgZnVuY3Rpb24oc3ltYm9sKSB7XG4gICAgcmV0dXJuIHByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwob2JqZWN0LCBzeW1ib2wpO1xuICB9KTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0U3ltYm9scztcbiIsInZhciBhcnJheVB1c2ggPSByZXF1aXJlKCcuL19hcnJheVB1c2gnKSxcbiAgICBnZXRQcm90b3R5cGUgPSByZXF1aXJlKCcuL19nZXRQcm90b3R5cGUnKSxcbiAgICBnZXRTeW1ib2xzID0gcmVxdWlyZSgnLi9fZ2V0U3ltYm9scycpLFxuICAgIHN0dWJBcnJheSA9IHJlcXVpcmUoJy4vc3R1YkFycmF5Jyk7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIGZvciB0aG9zZSB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgb3RoZXIgYGxvZGFzaGAgbWV0aG9kcy4gKi9cbnZhciBuYXRpdmVHZXRTeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scztcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBvd24gYW5kIGluaGVyaXRlZCBlbnVtZXJhYmxlIHN5bWJvbHMgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2Ygc3ltYm9scy5cbiAqL1xudmFyIGdldFN5bWJvbHNJbiA9ICFuYXRpdmVHZXRTeW1ib2xzID8gc3R1YkFycmF5IDogZnVuY3Rpb24ob2JqZWN0KSB7XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgd2hpbGUgKG9iamVjdCkge1xuICAgIGFycmF5UHVzaChyZXN1bHQsIGdldFN5bWJvbHMob2JqZWN0KSk7XG4gICAgb2JqZWN0ID0gZ2V0UHJvdG90eXBlKG9iamVjdCk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0U3ltYm9sc0luO1xuIiwidmFyIERhdGFWaWV3ID0gcmVxdWlyZSgnLi9fRGF0YVZpZXcnKSxcbiAgICBNYXAgPSByZXF1aXJlKCcuL19NYXAnKSxcbiAgICBQcm9taXNlID0gcmVxdWlyZSgnLi9fUHJvbWlzZScpLFxuICAgIFNldCA9IHJlcXVpcmUoJy4vX1NldCcpLFxuICAgIFdlYWtNYXAgPSByZXF1aXJlKCcuL19XZWFrTWFwJyksXG4gICAgYmFzZUdldFRhZyA9IHJlcXVpcmUoJy4vX2Jhc2VHZXRUYWcnKSxcbiAgICB0b1NvdXJjZSA9IHJlcXVpcmUoJy4vX3RvU291cmNlJyk7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBtYXBUYWcgPSAnW29iamVjdCBNYXBdJyxcbiAgICBvYmplY3RUYWcgPSAnW29iamVjdCBPYmplY3RdJyxcbiAgICBwcm9taXNlVGFnID0gJ1tvYmplY3QgUHJvbWlzZV0nLFxuICAgIHNldFRhZyA9ICdbb2JqZWN0IFNldF0nLFxuICAgIHdlYWtNYXBUYWcgPSAnW29iamVjdCBXZWFrTWFwXSc7XG5cbnZhciBkYXRhVmlld1RhZyA9ICdbb2JqZWN0IERhdGFWaWV3XSc7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBtYXBzLCBzZXRzLCBhbmQgd2Vha21hcHMuICovXG52YXIgZGF0YVZpZXdDdG9yU3RyaW5nID0gdG9Tb3VyY2UoRGF0YVZpZXcpLFxuICAgIG1hcEN0b3JTdHJpbmcgPSB0b1NvdXJjZShNYXApLFxuICAgIHByb21pc2VDdG9yU3RyaW5nID0gdG9Tb3VyY2UoUHJvbWlzZSksXG4gICAgc2V0Q3RvclN0cmluZyA9IHRvU291cmNlKFNldCksXG4gICAgd2Vha01hcEN0b3JTdHJpbmcgPSB0b1NvdXJjZShXZWFrTWFwKTtcblxuLyoqXG4gKiBHZXRzIHRoZSBgdG9TdHJpbmdUYWdgIG9mIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHF1ZXJ5LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgYHRvU3RyaW5nVGFnYC5cbiAqL1xudmFyIGdldFRhZyA9IGJhc2VHZXRUYWc7XG5cbi8vIEZhbGxiYWNrIGZvciBkYXRhIHZpZXdzLCBtYXBzLCBzZXRzLCBhbmQgd2VhayBtYXBzIGluIElFIDExIGFuZCBwcm9taXNlcyBpbiBOb2RlLmpzIDwgNi5cbmlmICgoRGF0YVZpZXcgJiYgZ2V0VGFnKG5ldyBEYXRhVmlldyhuZXcgQXJyYXlCdWZmZXIoMSkpKSAhPSBkYXRhVmlld1RhZykgfHxcbiAgICAoTWFwICYmIGdldFRhZyhuZXcgTWFwKSAhPSBtYXBUYWcpIHx8XG4gICAgKFByb21pc2UgJiYgZ2V0VGFnKFByb21pc2UucmVzb2x2ZSgpKSAhPSBwcm9taXNlVGFnKSB8fFxuICAgIChTZXQgJiYgZ2V0VGFnKG5ldyBTZXQpICE9IHNldFRhZykgfHxcbiAgICAoV2Vha01hcCAmJiBnZXRUYWcobmV3IFdlYWtNYXApICE9IHdlYWtNYXBUYWcpKSB7XG4gIGdldFRhZyA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgdmFyIHJlc3VsdCA9IGJhc2VHZXRUYWcodmFsdWUpLFxuICAgICAgICBDdG9yID0gcmVzdWx0ID09IG9iamVjdFRhZyA/IHZhbHVlLmNvbnN0cnVjdG9yIDogdW5kZWZpbmVkLFxuICAgICAgICBjdG9yU3RyaW5nID0gQ3RvciA/IHRvU291cmNlKEN0b3IpIDogJyc7XG5cbiAgICBpZiAoY3RvclN0cmluZykge1xuICAgICAgc3dpdGNoIChjdG9yU3RyaW5nKSB7XG4gICAgICAgIGNhc2UgZGF0YVZpZXdDdG9yU3RyaW5nOiByZXR1cm4gZGF0YVZpZXdUYWc7XG4gICAgICAgIGNhc2UgbWFwQ3RvclN0cmluZzogcmV0dXJuIG1hcFRhZztcbiAgICAgICAgY2FzZSBwcm9taXNlQ3RvclN0cmluZzogcmV0dXJuIHByb21pc2VUYWc7XG4gICAgICAgIGNhc2Ugc2V0Q3RvclN0cmluZzogcmV0dXJuIHNldFRhZztcbiAgICAgICAgY2FzZSB3ZWFrTWFwQ3RvclN0cmluZzogcmV0dXJuIHdlYWtNYXBUYWc7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0VGFnO1xuIiwiLyoqXG4gKiBHZXRzIHRoZSB2YWx1ZSBhdCBga2V5YCBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3RdIFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBwcm9wZXJ0eSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gZ2V0VmFsdWUob2JqZWN0LCBrZXkpIHtcbiAgcmV0dXJuIG9iamVjdCA9PSBudWxsID8gdW5kZWZpbmVkIDogb2JqZWN0W2tleV07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0VmFsdWU7XG4iLCJ2YXIgY2FzdFBhdGggPSByZXF1aXJlKCcuL19jYXN0UGF0aCcpLFxuICAgIGlzQXJndW1lbnRzID0gcmVxdWlyZSgnLi9pc0FyZ3VtZW50cycpLFxuICAgIGlzQXJyYXkgPSByZXF1aXJlKCcuL2lzQXJyYXknKSxcbiAgICBpc0luZGV4ID0gcmVxdWlyZSgnLi9faXNJbmRleCcpLFxuICAgIGlzTGVuZ3RoID0gcmVxdWlyZSgnLi9pc0xlbmd0aCcpLFxuICAgIHRvS2V5ID0gcmVxdWlyZSgnLi9fdG9LZXknKTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHBhdGhgIGV4aXN0cyBvbiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggdG8gY2hlY2suXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBoYXNGdW5jIFRoZSBmdW5jdGlvbiB0byBjaGVjayBwcm9wZXJ0aWVzLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBwYXRoYCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaGFzUGF0aChvYmplY3QsIHBhdGgsIGhhc0Z1bmMpIHtcbiAgcGF0aCA9IGNhc3RQYXRoKHBhdGgsIG9iamVjdCk7XG5cbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBwYXRoLmxlbmd0aCxcbiAgICAgIHJlc3VsdCA9IGZhbHNlO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIGtleSA9IHRvS2V5KHBhdGhbaW5kZXhdKTtcbiAgICBpZiAoIShyZXN1bHQgPSBvYmplY3QgIT0gbnVsbCAmJiBoYXNGdW5jKG9iamVjdCwga2V5KSkpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBvYmplY3QgPSBvYmplY3Rba2V5XTtcbiAgfVxuICBpZiAocmVzdWx0IHx8ICsraW5kZXggIT0gbGVuZ3RoKSB7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBsZW5ndGggPSBvYmplY3QgPT0gbnVsbCA/IDAgOiBvYmplY3QubGVuZ3RoO1xuICByZXR1cm4gISFsZW5ndGggJiYgaXNMZW5ndGgobGVuZ3RoKSAmJiBpc0luZGV4KGtleSwgbGVuZ3RoKSAmJlxuICAgIChpc0FycmF5KG9iamVjdCkgfHwgaXNBcmd1bWVudHMob2JqZWN0KSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaGFzUGF0aDtcbiIsIi8qKiBVc2VkIHRvIGNvbXBvc2UgdW5pY29kZSBjaGFyYWN0ZXIgY2xhc3Nlcy4gKi9cbnZhciByc0FzdHJhbFJhbmdlID0gJ1xcXFx1ZDgwMC1cXFxcdWRmZmYnLFxuICAgIHJzQ29tYm9NYXJrc1JhbmdlID0gJ1xcXFx1MDMwMC1cXFxcdTAzNmYnLFxuICAgIHJlQ29tYm9IYWxmTWFya3NSYW5nZSA9ICdcXFxcdWZlMjAtXFxcXHVmZTJmJyxcbiAgICByc0NvbWJvU3ltYm9sc1JhbmdlID0gJ1xcXFx1MjBkMC1cXFxcdTIwZmYnLFxuICAgIHJzQ29tYm9SYW5nZSA9IHJzQ29tYm9NYXJrc1JhbmdlICsgcmVDb21ib0hhbGZNYXJrc1JhbmdlICsgcnNDb21ib1N5bWJvbHNSYW5nZSxcbiAgICByc1ZhclJhbmdlID0gJ1xcXFx1ZmUwZVxcXFx1ZmUwZic7XG5cbi8qKiBVc2VkIHRvIGNvbXBvc2UgdW5pY29kZSBjYXB0dXJlIGdyb3Vwcy4gKi9cbnZhciByc1pXSiA9ICdcXFxcdTIwMGQnO1xuXG4vKiogVXNlZCB0byBkZXRlY3Qgc3RyaW5ncyB3aXRoIFt6ZXJvLXdpZHRoIGpvaW5lcnMgb3IgY29kZSBwb2ludHMgZnJvbSB0aGUgYXN0cmFsIHBsYW5lc10oaHR0cDovL2Vldi5lZS9ibG9nLzIwMTUvMDkvMTIvZGFyay1jb3JuZXJzLW9mLXVuaWNvZGUvKS4gKi9cbnZhciByZUhhc1VuaWNvZGUgPSBSZWdFeHAoJ1snICsgcnNaV0ogKyByc0FzdHJhbFJhbmdlICArIHJzQ29tYm9SYW5nZSArIHJzVmFyUmFuZ2UgKyAnXScpO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgc3RyaW5nYCBjb250YWlucyBVbmljb2RlIHN5bWJvbHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgVGhlIHN0cmluZyB0byBpbnNwZWN0LlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGEgc3ltYm9sIGlzIGZvdW5kLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGhhc1VuaWNvZGUoc3RyaW5nKSB7XG4gIHJldHVybiByZUhhc1VuaWNvZGUudGVzdChzdHJpbmcpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGhhc1VuaWNvZGU7XG4iLCJ2YXIgbmF0aXZlQ3JlYXRlID0gcmVxdWlyZSgnLi9fbmF0aXZlQ3JlYXRlJyk7XG5cbi8qKlxuICogUmVtb3ZlcyBhbGwga2V5LXZhbHVlIGVudHJpZXMgZnJvbSB0aGUgaGFzaC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgY2xlYXJcbiAqIEBtZW1iZXJPZiBIYXNoXG4gKi9cbmZ1bmN0aW9uIGhhc2hDbGVhcigpIHtcbiAgdGhpcy5fX2RhdGFfXyA9IG5hdGl2ZUNyZWF0ZSA/IG5hdGl2ZUNyZWF0ZShudWxsKSA6IHt9O1xuICB0aGlzLnNpemUgPSAwO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGhhc2hDbGVhcjtcbiIsIi8qKlxuICogUmVtb3ZlcyBga2V5YCBhbmQgaXRzIHZhbHVlIGZyb20gdGhlIGhhc2guXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGRlbGV0ZVxuICogQG1lbWJlck9mIEhhc2hcbiAqIEBwYXJhbSB7T2JqZWN0fSBoYXNoIFRoZSBoYXNoIHRvIG1vZGlmeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gcmVtb3ZlLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBlbnRyeSB3YXMgcmVtb3ZlZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBoYXNoRGVsZXRlKGtleSkge1xuICB2YXIgcmVzdWx0ID0gdGhpcy5oYXMoa2V5KSAmJiBkZWxldGUgdGhpcy5fX2RhdGFfX1trZXldO1xuICB0aGlzLnNpemUgLT0gcmVzdWx0ID8gMSA6IDA7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaGFzaERlbGV0ZTtcbiIsInZhciBuYXRpdmVDcmVhdGUgPSByZXF1aXJlKCcuL19uYXRpdmVDcmVhdGUnKTtcblxuLyoqIFVzZWQgdG8gc3RhbmQtaW4gZm9yIGB1bmRlZmluZWRgIGhhc2ggdmFsdWVzLiAqL1xudmFyIEhBU0hfVU5ERUZJTkVEID0gJ19fbG9kYXNoX2hhc2hfdW5kZWZpbmVkX18nO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIEdldHMgdGhlIGhhc2ggdmFsdWUgZm9yIGBrZXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBnZXRcbiAqIEBtZW1iZXJPZiBIYXNoXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBlbnRyeSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gaGFzaEdldChrZXkpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fO1xuICBpZiAobmF0aXZlQ3JlYXRlKSB7XG4gICAgdmFyIHJlc3VsdCA9IGRhdGFba2V5XTtcbiAgICByZXR1cm4gcmVzdWx0ID09PSBIQVNIX1VOREVGSU5FRCA/IHVuZGVmaW5lZCA6IHJlc3VsdDtcbiAgfVxuICByZXR1cm4gaGFzT3duUHJvcGVydHkuY2FsbChkYXRhLCBrZXkpID8gZGF0YVtrZXldIDogdW5kZWZpbmVkO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGhhc2hHZXQ7XG4iLCJ2YXIgbmF0aXZlQ3JlYXRlID0gcmVxdWlyZSgnLi9fbmF0aXZlQ3JlYXRlJyk7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGEgaGFzaCB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBoYXNcbiAqIEBtZW1iZXJPZiBIYXNoXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaGFzaEhhcyhrZXkpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fO1xuICByZXR1cm4gbmF0aXZlQ3JlYXRlID8gKGRhdGFba2V5XSAhPT0gdW5kZWZpbmVkKSA6IGhhc093blByb3BlcnR5LmNhbGwoZGF0YSwga2V5KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBoYXNoSGFzO1xuIiwidmFyIG5hdGl2ZUNyZWF0ZSA9IHJlcXVpcmUoJy4vX25hdGl2ZUNyZWF0ZScpO1xuXG4vKiogVXNlZCB0byBzdGFuZC1pbiBmb3IgYHVuZGVmaW5lZGAgaGFzaCB2YWx1ZXMuICovXG52YXIgSEFTSF9VTkRFRklORUQgPSAnX19sb2Rhc2hfaGFzaF91bmRlZmluZWRfXyc7XG5cbi8qKlxuICogU2V0cyB0aGUgaGFzaCBga2V5YCB0byBgdmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBzZXRcbiAqIEBtZW1iZXJPZiBIYXNoXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHNldC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGhhc2ggaW5zdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIGhhc2hTZXQoa2V5LCB2YWx1ZSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX187XG4gIHRoaXMuc2l6ZSArPSB0aGlzLmhhcyhrZXkpID8gMCA6IDE7XG4gIGRhdGFba2V5XSA9IChuYXRpdmVDcmVhdGUgJiYgdmFsdWUgPT09IHVuZGVmaW5lZCkgPyBIQVNIX1VOREVGSU5FRCA6IHZhbHVlO1xuICByZXR1cm4gdGhpcztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBoYXNoU2V0O1xuIiwiLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBJbml0aWFsaXplcyBhbiBhcnJheSBjbG9uZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGNsb25lLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBpbml0aWFsaXplZCBjbG9uZS5cbiAqL1xuZnVuY3Rpb24gaW5pdENsb25lQXJyYXkoYXJyYXkpIHtcbiAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aCxcbiAgICAgIHJlc3VsdCA9IG5ldyBhcnJheS5jb25zdHJ1Y3RvcihsZW5ndGgpO1xuXG4gIC8vIEFkZCBwcm9wZXJ0aWVzIGFzc2lnbmVkIGJ5IGBSZWdFeHAjZXhlY2AuXG4gIGlmIChsZW5ndGggJiYgdHlwZW9mIGFycmF5WzBdID09ICdzdHJpbmcnICYmIGhhc093blByb3BlcnR5LmNhbGwoYXJyYXksICdpbmRleCcpKSB7XG4gICAgcmVzdWx0LmluZGV4ID0gYXJyYXkuaW5kZXg7XG4gICAgcmVzdWx0LmlucHV0ID0gYXJyYXkuaW5wdXQ7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpbml0Q2xvbmVBcnJheTtcbiIsInZhciBjbG9uZUFycmF5QnVmZmVyID0gcmVxdWlyZSgnLi9fY2xvbmVBcnJheUJ1ZmZlcicpLFxuICAgIGNsb25lRGF0YVZpZXcgPSByZXF1aXJlKCcuL19jbG9uZURhdGFWaWV3JyksXG4gICAgY2xvbmVSZWdFeHAgPSByZXF1aXJlKCcuL19jbG9uZVJlZ0V4cCcpLFxuICAgIGNsb25lU3ltYm9sID0gcmVxdWlyZSgnLi9fY2xvbmVTeW1ib2wnKSxcbiAgICBjbG9uZVR5cGVkQXJyYXkgPSByZXF1aXJlKCcuL19jbG9uZVR5cGVkQXJyYXknKTtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIGJvb2xUYWcgPSAnW29iamVjdCBCb29sZWFuXScsXG4gICAgZGF0ZVRhZyA9ICdbb2JqZWN0IERhdGVdJyxcbiAgICBtYXBUYWcgPSAnW29iamVjdCBNYXBdJyxcbiAgICBudW1iZXJUYWcgPSAnW29iamVjdCBOdW1iZXJdJyxcbiAgICByZWdleHBUYWcgPSAnW29iamVjdCBSZWdFeHBdJyxcbiAgICBzZXRUYWcgPSAnW29iamVjdCBTZXRdJyxcbiAgICBzdHJpbmdUYWcgPSAnW29iamVjdCBTdHJpbmddJyxcbiAgICBzeW1ib2xUYWcgPSAnW29iamVjdCBTeW1ib2xdJztcblxudmFyIGFycmF5QnVmZmVyVGFnID0gJ1tvYmplY3QgQXJyYXlCdWZmZXJdJyxcbiAgICBkYXRhVmlld1RhZyA9ICdbb2JqZWN0IERhdGFWaWV3XScsXG4gICAgZmxvYXQzMlRhZyA9ICdbb2JqZWN0IEZsb2F0MzJBcnJheV0nLFxuICAgIGZsb2F0NjRUYWcgPSAnW29iamVjdCBGbG9hdDY0QXJyYXldJyxcbiAgICBpbnQ4VGFnID0gJ1tvYmplY3QgSW50OEFycmF5XScsXG4gICAgaW50MTZUYWcgPSAnW29iamVjdCBJbnQxNkFycmF5XScsXG4gICAgaW50MzJUYWcgPSAnW29iamVjdCBJbnQzMkFycmF5XScsXG4gICAgdWludDhUYWcgPSAnW29iamVjdCBVaW50OEFycmF5XScsXG4gICAgdWludDhDbGFtcGVkVGFnID0gJ1tvYmplY3QgVWludDhDbGFtcGVkQXJyYXldJyxcbiAgICB1aW50MTZUYWcgPSAnW29iamVjdCBVaW50MTZBcnJheV0nLFxuICAgIHVpbnQzMlRhZyA9ICdbb2JqZWN0IFVpbnQzMkFycmF5XSc7XG5cbi8qKlxuICogSW5pdGlhbGl6ZXMgYW4gb2JqZWN0IGNsb25lIGJhc2VkIG9uIGl0cyBgdG9TdHJpbmdUYWdgLlxuICpcbiAqICoqTm90ZToqKiBUaGlzIGZ1bmN0aW9uIG9ubHkgc3VwcG9ydHMgY2xvbmluZyB2YWx1ZXMgd2l0aCB0YWdzIG9mXG4gKiBgQm9vbGVhbmAsIGBEYXRlYCwgYEVycm9yYCwgYE1hcGAsIGBOdW1iZXJgLCBgUmVnRXhwYCwgYFNldGAsIG9yIGBTdHJpbmdgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gY2xvbmUuXG4gKiBAcGFyYW0ge3N0cmluZ30gdGFnIFRoZSBgdG9TdHJpbmdUYWdgIG9mIHRoZSBvYmplY3QgdG8gY2xvbmUuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtpc0RlZXBdIFNwZWNpZnkgYSBkZWVwIGNsb25lLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgaW5pdGlhbGl6ZWQgY2xvbmUuXG4gKi9cbmZ1bmN0aW9uIGluaXRDbG9uZUJ5VGFnKG9iamVjdCwgdGFnLCBpc0RlZXApIHtcbiAgdmFyIEN0b3IgPSBvYmplY3QuY29uc3RydWN0b3I7XG4gIHN3aXRjaCAodGFnKSB7XG4gICAgY2FzZSBhcnJheUJ1ZmZlclRhZzpcbiAgICAgIHJldHVybiBjbG9uZUFycmF5QnVmZmVyKG9iamVjdCk7XG5cbiAgICBjYXNlIGJvb2xUYWc6XG4gICAgY2FzZSBkYXRlVGFnOlxuICAgICAgcmV0dXJuIG5ldyBDdG9yKCtvYmplY3QpO1xuXG4gICAgY2FzZSBkYXRhVmlld1RhZzpcbiAgICAgIHJldHVybiBjbG9uZURhdGFWaWV3KG9iamVjdCwgaXNEZWVwKTtcblxuICAgIGNhc2UgZmxvYXQzMlRhZzogY2FzZSBmbG9hdDY0VGFnOlxuICAgIGNhc2UgaW50OFRhZzogY2FzZSBpbnQxNlRhZzogY2FzZSBpbnQzMlRhZzpcbiAgICBjYXNlIHVpbnQ4VGFnOiBjYXNlIHVpbnQ4Q2xhbXBlZFRhZzogY2FzZSB1aW50MTZUYWc6IGNhc2UgdWludDMyVGFnOlxuICAgICAgcmV0dXJuIGNsb25lVHlwZWRBcnJheShvYmplY3QsIGlzRGVlcCk7XG5cbiAgICBjYXNlIG1hcFRhZzpcbiAgICAgIHJldHVybiBuZXcgQ3RvcjtcblxuICAgIGNhc2UgbnVtYmVyVGFnOlxuICAgIGNhc2Ugc3RyaW5nVGFnOlxuICAgICAgcmV0dXJuIG5ldyBDdG9yKG9iamVjdCk7XG5cbiAgICBjYXNlIHJlZ2V4cFRhZzpcbiAgICAgIHJldHVybiBjbG9uZVJlZ0V4cChvYmplY3QpO1xuXG4gICAgY2FzZSBzZXRUYWc6XG4gICAgICByZXR1cm4gbmV3IEN0b3I7XG5cbiAgICBjYXNlIHN5bWJvbFRhZzpcbiAgICAgIHJldHVybiBjbG9uZVN5bWJvbChvYmplY3QpO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaW5pdENsb25lQnlUYWc7XG4iLCJ2YXIgYmFzZUNyZWF0ZSA9IHJlcXVpcmUoJy4vX2Jhc2VDcmVhdGUnKSxcbiAgICBnZXRQcm90b3R5cGUgPSByZXF1aXJlKCcuL19nZXRQcm90b3R5cGUnKSxcbiAgICBpc1Byb3RvdHlwZSA9IHJlcXVpcmUoJy4vX2lzUHJvdG90eXBlJyk7XG5cbi8qKlxuICogSW5pdGlhbGl6ZXMgYW4gb2JqZWN0IGNsb25lLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gY2xvbmUuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBpbml0aWFsaXplZCBjbG9uZS5cbiAqL1xuZnVuY3Rpb24gaW5pdENsb25lT2JqZWN0KG9iamVjdCkge1xuICByZXR1cm4gKHR5cGVvZiBvYmplY3QuY29uc3RydWN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiAhaXNQcm90b3R5cGUob2JqZWN0KSlcbiAgICA/IGJhc2VDcmVhdGUoZ2V0UHJvdG90eXBlKG9iamVjdCkpXG4gICAgOiB7fTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpbml0Q2xvbmVPYmplY3Q7XG4iLCJ2YXIgU3ltYm9sID0gcmVxdWlyZSgnLi9fU3ltYm9sJyksXG4gICAgaXNBcmd1bWVudHMgPSByZXF1aXJlKCcuL2lzQXJndW1lbnRzJyksXG4gICAgaXNBcnJheSA9IHJlcXVpcmUoJy4vaXNBcnJheScpO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBzcHJlYWRhYmxlU3ltYm9sID0gU3ltYm9sID8gU3ltYm9sLmlzQ29uY2F0U3ByZWFkYWJsZSA6IHVuZGVmaW5lZDtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIGZsYXR0ZW5hYmxlIGBhcmd1bWVudHNgIG9iamVjdCBvciBhcnJheS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBmbGF0dGVuYWJsZSwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc0ZsYXR0ZW5hYmxlKHZhbHVlKSB7XG4gIHJldHVybiBpc0FycmF5KHZhbHVlKSB8fCBpc0FyZ3VtZW50cyh2YWx1ZSkgfHxcbiAgICAhIShzcHJlYWRhYmxlU3ltYm9sICYmIHZhbHVlICYmIHZhbHVlW3NwcmVhZGFibGVTeW1ib2xdKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc0ZsYXR0ZW5hYmxlO1xuIiwiLyoqIFVzZWQgYXMgcmVmZXJlbmNlcyBmb3IgdmFyaW91cyBgTnVtYmVyYCBjb25zdGFudHMuICovXG52YXIgTUFYX1NBRkVfSU5URUdFUiA9IDkwMDcxOTkyNTQ3NDA5OTE7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCB1bnNpZ25lZCBpbnRlZ2VyIHZhbHVlcy4gKi9cbnZhciByZUlzVWludCA9IC9eKD86MHxbMS05XVxcZCopJC87XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBhcnJheS1saWtlIGluZGV4LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbbGVuZ3RoPU1BWF9TQUZFX0lOVEVHRVJdIFRoZSB1cHBlciBib3VuZHMgb2YgYSB2YWxpZCBpbmRleC5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgaW5kZXgsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNJbmRleCh2YWx1ZSwgbGVuZ3RoKSB7XG4gIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICBsZW5ndGggPSBsZW5ndGggPT0gbnVsbCA/IE1BWF9TQUZFX0lOVEVHRVIgOiBsZW5ndGg7XG5cbiAgcmV0dXJuICEhbGVuZ3RoICYmXG4gICAgKHR5cGUgPT0gJ251bWJlcicgfHxcbiAgICAgICh0eXBlICE9ICdzeW1ib2wnICYmIHJlSXNVaW50LnRlc3QodmFsdWUpKSkgJiZcbiAgICAgICAgKHZhbHVlID4gLTEgJiYgdmFsdWUgJSAxID09IDAgJiYgdmFsdWUgPCBsZW5ndGgpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzSW5kZXg7XG4iLCJ2YXIgZXEgPSByZXF1aXJlKCcuL2VxJyksXG4gICAgaXNBcnJheUxpa2UgPSByZXF1aXJlKCcuL2lzQXJyYXlMaWtlJyksXG4gICAgaXNJbmRleCA9IHJlcXVpcmUoJy4vX2lzSW5kZXgnKSxcbiAgICBpc09iamVjdCA9IHJlcXVpcmUoJy4vaXNPYmplY3QnKTtcblxuLyoqXG4gKiBDaGVja3MgaWYgdGhlIGdpdmVuIGFyZ3VtZW50cyBhcmUgZnJvbSBhbiBpdGVyYXRlZSBjYWxsLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSBwb3RlbnRpYWwgaXRlcmF0ZWUgdmFsdWUgYXJndW1lbnQuXG4gKiBAcGFyYW0geyp9IGluZGV4IFRoZSBwb3RlbnRpYWwgaXRlcmF0ZWUgaW5kZXggb3Iga2V5IGFyZ3VtZW50LlxuICogQHBhcmFtIHsqfSBvYmplY3QgVGhlIHBvdGVudGlhbCBpdGVyYXRlZSBvYmplY3QgYXJndW1lbnQuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGFyZ3VtZW50cyBhcmUgZnJvbSBhbiBpdGVyYXRlZSBjYWxsLFxuICogIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNJdGVyYXRlZUNhbGwodmFsdWUsIGluZGV4LCBvYmplY3QpIHtcbiAgaWYgKCFpc09iamVjdChvYmplY3QpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciB0eXBlID0gdHlwZW9mIGluZGV4O1xuICBpZiAodHlwZSA9PSAnbnVtYmVyJ1xuICAgICAgICA/IChpc0FycmF5TGlrZShvYmplY3QpICYmIGlzSW5kZXgoaW5kZXgsIG9iamVjdC5sZW5ndGgpKVxuICAgICAgICA6ICh0eXBlID09ICdzdHJpbmcnICYmIGluZGV4IGluIG9iamVjdClcbiAgICAgICkge1xuICAgIHJldHVybiBlcShvYmplY3RbaW5kZXhdLCB2YWx1ZSk7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzSXRlcmF0ZWVDYWxsO1xuIiwidmFyIGlzQXJyYXkgPSByZXF1aXJlKCcuL2lzQXJyYXknKSxcbiAgICBpc1N5bWJvbCA9IHJlcXVpcmUoJy4vaXNTeW1ib2wnKTtcblxuLyoqIFVzZWQgdG8gbWF0Y2ggcHJvcGVydHkgbmFtZXMgd2l0aGluIHByb3BlcnR5IHBhdGhzLiAqL1xudmFyIHJlSXNEZWVwUHJvcCA9IC9cXC58XFxbKD86W15bXFxdXSp8KFtcIiddKSg/Oig/IVxcMSlbXlxcXFxdfFxcXFwuKSo/XFwxKVxcXS8sXG4gICAgcmVJc1BsYWluUHJvcCA9IC9eXFx3KiQvO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgcHJvcGVydHkgbmFtZSBhbmQgbm90IGEgcHJvcGVydHkgcGF0aC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcGFyYW0ge09iamVjdH0gW29iamVjdF0gVGhlIG9iamVjdCB0byBxdWVyeSBrZXlzIG9uLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBwcm9wZXJ0eSBuYW1lLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzS2V5KHZhbHVlLCBvYmplY3QpIHtcbiAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICBpZiAodHlwZSA9PSAnbnVtYmVyJyB8fCB0eXBlID09ICdzeW1ib2wnIHx8IHR5cGUgPT0gJ2Jvb2xlYW4nIHx8XG4gICAgICB2YWx1ZSA9PSBudWxsIHx8IGlzU3ltYm9sKHZhbHVlKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiByZUlzUGxhaW5Qcm9wLnRlc3QodmFsdWUpIHx8ICFyZUlzRGVlcFByb3AudGVzdCh2YWx1ZSkgfHxcbiAgICAob2JqZWN0ICE9IG51bGwgJiYgdmFsdWUgaW4gT2JqZWN0KG9iamVjdCkpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzS2V5O1xuIiwiLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBzdWl0YWJsZSBmb3IgdXNlIGFzIHVuaXF1ZSBvYmplY3Qga2V5LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIHN1aXRhYmxlLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzS2V5YWJsZSh2YWx1ZSkge1xuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgcmV0dXJuICh0eXBlID09ICdzdHJpbmcnIHx8IHR5cGUgPT0gJ251bWJlcicgfHwgdHlwZSA9PSAnc3ltYm9sJyB8fCB0eXBlID09ICdib29sZWFuJylcbiAgICA/ICh2YWx1ZSAhPT0gJ19fcHJvdG9fXycpXG4gICAgOiAodmFsdWUgPT09IG51bGwpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzS2V5YWJsZTtcbiIsInZhciBjb3JlSnNEYXRhID0gcmVxdWlyZSgnLi9fY29yZUpzRGF0YScpO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgbWV0aG9kcyBtYXNxdWVyYWRpbmcgYXMgbmF0aXZlLiAqL1xudmFyIG1hc2tTcmNLZXkgPSAoZnVuY3Rpb24oKSB7XG4gIHZhciB1aWQgPSAvW14uXSskLy5leGVjKGNvcmVKc0RhdGEgJiYgY29yZUpzRGF0YS5rZXlzICYmIGNvcmVKc0RhdGEua2V5cy5JRV9QUk9UTyB8fCAnJyk7XG4gIHJldHVybiB1aWQgPyAoJ1N5bWJvbChzcmMpXzEuJyArIHVpZCkgOiAnJztcbn0oKSk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGBmdW5jYCBoYXMgaXRzIHNvdXJjZSBtYXNrZWQuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBmdW5jYCBpcyBtYXNrZWQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNNYXNrZWQoZnVuYykge1xuICByZXR1cm4gISFtYXNrU3JjS2V5ICYmIChtYXNrU3JjS2V5IGluIGZ1bmMpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzTWFza2VkO1xuIiwiLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBsaWtlbHkgYSBwcm90b3R5cGUgb2JqZWN0LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgcHJvdG90eXBlLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzUHJvdG90eXBlKHZhbHVlKSB7XG4gIHZhciBDdG9yID0gdmFsdWUgJiYgdmFsdWUuY29uc3RydWN0b3IsXG4gICAgICBwcm90byA9ICh0eXBlb2YgQ3RvciA9PSAnZnVuY3Rpb24nICYmIEN0b3IucHJvdG90eXBlKSB8fCBvYmplY3RQcm90bztcblxuICByZXR1cm4gdmFsdWUgPT09IHByb3RvO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzUHJvdG90eXBlO1xuIiwidmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9pc09iamVjdCcpO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIHN1aXRhYmxlIGZvciBzdHJpY3QgZXF1YWxpdHkgY29tcGFyaXNvbnMsIGkuZS4gYD09PWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaWYgc3VpdGFibGUgZm9yIHN0cmljdFxuICogIGVxdWFsaXR5IGNvbXBhcmlzb25zLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzU3RyaWN0Q29tcGFyYWJsZSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgPT09IHZhbHVlICYmICFpc09iamVjdCh2YWx1ZSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNTdHJpY3RDb21wYXJhYmxlO1xuIiwiLyoqXG4gKiBSZW1vdmVzIGFsbCBrZXktdmFsdWUgZW50cmllcyBmcm9tIHRoZSBsaXN0IGNhY2hlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBjbGVhclxuICogQG1lbWJlck9mIExpc3RDYWNoZVxuICovXG5mdW5jdGlvbiBsaXN0Q2FjaGVDbGVhcigpIHtcbiAgdGhpcy5fX2RhdGFfXyA9IFtdO1xuICB0aGlzLnNpemUgPSAwO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGxpc3RDYWNoZUNsZWFyO1xuIiwidmFyIGFzc29jSW5kZXhPZiA9IHJlcXVpcmUoJy4vX2Fzc29jSW5kZXhPZicpO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgYXJyYXlQcm90byA9IEFycmF5LnByb3RvdHlwZTtcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgc3BsaWNlID0gYXJyYXlQcm90by5zcGxpY2U7XG5cbi8qKlxuICogUmVtb3ZlcyBga2V5YCBhbmQgaXRzIHZhbHVlIGZyb20gdGhlIGxpc3QgY2FjaGUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGRlbGV0ZVxuICogQG1lbWJlck9mIExpc3RDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byByZW1vdmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGVudHJ5IHdhcyByZW1vdmVkLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGxpc3RDYWNoZURlbGV0ZShrZXkpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fLFxuICAgICAgaW5kZXggPSBhc3NvY0luZGV4T2YoZGF0YSwga2V5KTtcblxuICBpZiAoaW5kZXggPCAwKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciBsYXN0SW5kZXggPSBkYXRhLmxlbmd0aCAtIDE7XG4gIGlmIChpbmRleCA9PSBsYXN0SW5kZXgpIHtcbiAgICBkYXRhLnBvcCgpO1xuICB9IGVsc2Uge1xuICAgIHNwbGljZS5jYWxsKGRhdGEsIGluZGV4LCAxKTtcbiAgfVxuICAtLXRoaXMuc2l6ZTtcbiAgcmV0dXJuIHRydWU7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbGlzdENhY2hlRGVsZXRlO1xuIiwidmFyIGFzc29jSW5kZXhPZiA9IHJlcXVpcmUoJy4vX2Fzc29jSW5kZXhPZicpO1xuXG4vKipcbiAqIEdldHMgdGhlIGxpc3QgY2FjaGUgdmFsdWUgZm9yIGBrZXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBnZXRcbiAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGVudHJ5IHZhbHVlLlxuICovXG5mdW5jdGlvbiBsaXN0Q2FjaGVHZXQoa2V5KSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXyxcbiAgICAgIGluZGV4ID0gYXNzb2NJbmRleE9mKGRhdGEsIGtleSk7XG5cbiAgcmV0dXJuIGluZGV4IDwgMCA/IHVuZGVmaW5lZCA6IGRhdGFbaW5kZXhdWzFdO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGxpc3RDYWNoZUdldDtcbiIsInZhciBhc3NvY0luZGV4T2YgPSByZXF1aXJlKCcuL19hc3NvY0luZGV4T2YnKTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYSBsaXN0IGNhY2hlIHZhbHVlIGZvciBga2V5YCBleGlzdHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGhhc1xuICogQG1lbWJlck9mIExpc3RDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlbnRyeSBmb3IgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGxpc3RDYWNoZUhhcyhrZXkpIHtcbiAgcmV0dXJuIGFzc29jSW5kZXhPZih0aGlzLl9fZGF0YV9fLCBrZXkpID4gLTE7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbGlzdENhY2hlSGFzO1xuIiwidmFyIGFzc29jSW5kZXhPZiA9IHJlcXVpcmUoJy4vX2Fzc29jSW5kZXhPZicpO1xuXG4vKipcbiAqIFNldHMgdGhlIGxpc3QgY2FjaGUgYGtleWAgdG8gYHZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgc2V0XG4gKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHNldC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGxpc3QgY2FjaGUgaW5zdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIGxpc3RDYWNoZVNldChrZXksIHZhbHVlKSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXyxcbiAgICAgIGluZGV4ID0gYXNzb2NJbmRleE9mKGRhdGEsIGtleSk7XG5cbiAgaWYgKGluZGV4IDwgMCkge1xuICAgICsrdGhpcy5zaXplO1xuICAgIGRhdGEucHVzaChba2V5LCB2YWx1ZV0pO1xuICB9IGVsc2Uge1xuICAgIGRhdGFbaW5kZXhdWzFdID0gdmFsdWU7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbGlzdENhY2hlU2V0O1xuIiwidmFyIEhhc2ggPSByZXF1aXJlKCcuL19IYXNoJyksXG4gICAgTGlzdENhY2hlID0gcmVxdWlyZSgnLi9fTGlzdENhY2hlJyksXG4gICAgTWFwID0gcmVxdWlyZSgnLi9fTWFwJyk7XG5cbi8qKlxuICogUmVtb3ZlcyBhbGwga2V5LXZhbHVlIGVudHJpZXMgZnJvbSB0aGUgbWFwLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBjbGVhclxuICogQG1lbWJlck9mIE1hcENhY2hlXG4gKi9cbmZ1bmN0aW9uIG1hcENhY2hlQ2xlYXIoKSB7XG4gIHRoaXMuc2l6ZSA9IDA7XG4gIHRoaXMuX19kYXRhX18gPSB7XG4gICAgJ2hhc2gnOiBuZXcgSGFzaCxcbiAgICAnbWFwJzogbmV3IChNYXAgfHwgTGlzdENhY2hlKSxcbiAgICAnc3RyaW5nJzogbmV3IEhhc2hcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBtYXBDYWNoZUNsZWFyO1xuIiwidmFyIGdldE1hcERhdGEgPSByZXF1aXJlKCcuL19nZXRNYXBEYXRhJyk7XG5cbi8qKlxuICogUmVtb3ZlcyBga2V5YCBhbmQgaXRzIHZhbHVlIGZyb20gdGhlIG1hcC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZGVsZXRlXG4gKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gcmVtb3ZlLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBlbnRyeSB3YXMgcmVtb3ZlZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBtYXBDYWNoZURlbGV0ZShrZXkpIHtcbiAgdmFyIHJlc3VsdCA9IGdldE1hcERhdGEodGhpcywga2V5KVsnZGVsZXRlJ10oa2V5KTtcbiAgdGhpcy5zaXplIC09IHJlc3VsdCA/IDEgOiAwO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG1hcENhY2hlRGVsZXRlO1xuIiwidmFyIGdldE1hcERhdGEgPSByZXF1aXJlKCcuL19nZXRNYXBEYXRhJyk7XG5cbi8qKlxuICogR2V0cyB0aGUgbWFwIHZhbHVlIGZvciBga2V5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZ2V0XG4gKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGVudHJ5IHZhbHVlLlxuICovXG5mdW5jdGlvbiBtYXBDYWNoZUdldChrZXkpIHtcbiAgcmV0dXJuIGdldE1hcERhdGEodGhpcywga2V5KS5nZXQoa2V5KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBtYXBDYWNoZUdldDtcbiIsInZhciBnZXRNYXBEYXRhID0gcmVxdWlyZSgnLi9fZ2V0TWFwRGF0YScpO1xuXG4vKipcbiAqIENoZWNrcyBpZiBhIG1hcCB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBoYXNcbiAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlbnRyeSBmb3IgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIG1hcENhY2hlSGFzKGtleSkge1xuICByZXR1cm4gZ2V0TWFwRGF0YSh0aGlzLCBrZXkpLmhhcyhrZXkpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG1hcENhY2hlSGFzO1xuIiwidmFyIGdldE1hcERhdGEgPSByZXF1aXJlKCcuL19nZXRNYXBEYXRhJyk7XG5cbi8qKlxuICogU2V0cyB0aGUgbWFwIGBrZXlgIHRvIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIHNldFxuICogQG1lbWJlck9mIE1hcENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHNldC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG1hcCBjYWNoZSBpbnN0YW5jZS5cbiAqL1xuZnVuY3Rpb24gbWFwQ2FjaGVTZXQoa2V5LCB2YWx1ZSkge1xuICB2YXIgZGF0YSA9IGdldE1hcERhdGEodGhpcywga2V5KSxcbiAgICAgIHNpemUgPSBkYXRhLnNpemU7XG5cbiAgZGF0YS5zZXQoa2V5LCB2YWx1ZSk7XG4gIHRoaXMuc2l6ZSArPSBkYXRhLnNpemUgPT0gc2l6ZSA/IDAgOiAxO1xuICByZXR1cm4gdGhpcztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBtYXBDYWNoZVNldDtcbiIsIi8qKlxuICogQ29udmVydHMgYG1hcGAgdG8gaXRzIGtleS12YWx1ZSBwYWlycy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG1hcCBUaGUgbWFwIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGtleS12YWx1ZSBwYWlycy5cbiAqL1xuZnVuY3Rpb24gbWFwVG9BcnJheShtYXApIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICByZXN1bHQgPSBBcnJheShtYXAuc2l6ZSk7XG5cbiAgbWFwLmZvckVhY2goZnVuY3Rpb24odmFsdWUsIGtleSkge1xuICAgIHJlc3VsdFsrK2luZGV4XSA9IFtrZXksIHZhbHVlXTtcbiAgfSk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbWFwVG9BcnJheTtcbiIsIi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBtYXRjaGVzUHJvcGVydHlgIGZvciBzb3VyY2UgdmFsdWVzIHN1aXRhYmxlXG4gKiBmb3Igc3RyaWN0IGVxdWFsaXR5IGNvbXBhcmlzb25zLCBpLmUuIGA9PT1gLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAqIEBwYXJhbSB7Kn0gc3JjVmFsdWUgVGhlIHZhbHVlIHRvIG1hdGNoLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgc3BlYyBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gbWF0Y2hlc1N0cmljdENvbXBhcmFibGUoa2V5LCBzcmNWYWx1ZSkge1xuICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgaWYgKG9iamVjdCA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiBvYmplY3Rba2V5XSA9PT0gc3JjVmFsdWUgJiZcbiAgICAgIChzcmNWYWx1ZSAhPT0gdW5kZWZpbmVkIHx8IChrZXkgaW4gT2JqZWN0KG9iamVjdCkpKTtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBtYXRjaGVzU3RyaWN0Q29tcGFyYWJsZTtcbiIsInZhciBtZW1vaXplID0gcmVxdWlyZSgnLi9tZW1vaXplJyk7XG5cbi8qKiBVc2VkIGFzIHRoZSBtYXhpbXVtIG1lbW9pemUgY2FjaGUgc2l6ZS4gKi9cbnZhciBNQVhfTUVNT0laRV9TSVpFID0gNTAwO1xuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5tZW1vaXplYCB3aGljaCBjbGVhcnMgdGhlIG1lbW9pemVkIGZ1bmN0aW9uJ3NcbiAqIGNhY2hlIHdoZW4gaXQgZXhjZWVkcyBgTUFYX01FTU9JWkVfU0laRWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGhhdmUgaXRzIG91dHB1dCBtZW1vaXplZC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IG1lbW9pemVkIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBtZW1vaXplQ2FwcGVkKGZ1bmMpIHtcbiAgdmFyIHJlc3VsdCA9IG1lbW9pemUoZnVuYywgZnVuY3Rpb24oa2V5KSB7XG4gICAgaWYgKGNhY2hlLnNpemUgPT09IE1BWF9NRU1PSVpFX1NJWkUpIHtcbiAgICAgIGNhY2hlLmNsZWFyKCk7XG4gICAgfVxuICAgIHJldHVybiBrZXk7XG4gIH0pO1xuXG4gIHZhciBjYWNoZSA9IHJlc3VsdC5jYWNoZTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBtZW1vaXplQ2FwcGVkO1xuIiwidmFyIGdldE5hdGl2ZSA9IHJlcXVpcmUoJy4vX2dldE5hdGl2ZScpO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyB0aGF0IGFyZSB2ZXJpZmllZCB0byBiZSBuYXRpdmUuICovXG52YXIgbmF0aXZlQ3JlYXRlID0gZ2V0TmF0aXZlKE9iamVjdCwgJ2NyZWF0ZScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IG5hdGl2ZUNyZWF0ZTtcbiIsInZhciBvdmVyQXJnID0gcmVxdWlyZSgnLi9fb3ZlckFyZycpO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyBmb3IgdGhvc2Ugd2l0aCB0aGUgc2FtZSBuYW1lIGFzIG90aGVyIGBsb2Rhc2hgIG1ldGhvZHMuICovXG52YXIgbmF0aXZlS2V5cyA9IG92ZXJBcmcoT2JqZWN0LmtleXMsIE9iamVjdCk7XG5cbm1vZHVsZS5leHBvcnRzID0gbmF0aXZlS2V5cztcbiIsIi8qKlxuICogVGhpcyBmdW5jdGlvbiBpcyBsaWtlXG4gKiBbYE9iamVjdC5rZXlzYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtb2JqZWN0LmtleXMpXG4gKiBleGNlcHQgdGhhdCBpdCBpbmNsdWRlcyBpbmhlcml0ZWQgZW51bWVyYWJsZSBwcm9wZXJ0aWVzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICovXG5mdW5jdGlvbiBuYXRpdmVLZXlzSW4ob2JqZWN0KSB7XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgaWYgKG9iamVjdCAhPSBudWxsKSB7XG4gICAgZm9yICh2YXIga2V5IGluIE9iamVjdChvYmplY3QpKSB7XG4gICAgICByZXN1bHQucHVzaChrZXkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG5hdGl2ZUtleXNJbjtcbiIsInZhciBmcmVlR2xvYmFsID0gcmVxdWlyZSgnLi9fZnJlZUdsb2JhbCcpO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGV4cG9ydHNgLiAqL1xudmFyIGZyZWVFeHBvcnRzID0gdHlwZW9mIGV4cG9ydHMgPT0gJ29iamVjdCcgJiYgZXhwb3J0cyAmJiAhZXhwb3J0cy5ub2RlVHlwZSAmJiBleHBvcnRzO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYG1vZHVsZWAuICovXG52YXIgZnJlZU1vZHVsZSA9IGZyZWVFeHBvcnRzICYmIHR5cGVvZiBtb2R1bGUgPT0gJ29iamVjdCcgJiYgbW9kdWxlICYmICFtb2R1bGUubm9kZVR5cGUgJiYgbW9kdWxlO1xuXG4vKiogRGV0ZWN0IHRoZSBwb3B1bGFyIENvbW1vbkpTIGV4dGVuc2lvbiBgbW9kdWxlLmV4cG9ydHNgLiAqL1xudmFyIG1vZHVsZUV4cG9ydHMgPSBmcmVlTW9kdWxlICYmIGZyZWVNb2R1bGUuZXhwb3J0cyA9PT0gZnJlZUV4cG9ydHM7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgcHJvY2Vzc2AgZnJvbSBOb2RlLmpzLiAqL1xudmFyIGZyZWVQcm9jZXNzID0gbW9kdWxlRXhwb3J0cyAmJiBmcmVlR2xvYmFsLnByb2Nlc3M7XG5cbi8qKiBVc2VkIHRvIGFjY2VzcyBmYXN0ZXIgTm9kZS5qcyBoZWxwZXJzLiAqL1xudmFyIG5vZGVVdGlsID0gKGZ1bmN0aW9uKCkge1xuICB0cnkge1xuICAgIC8vIFVzZSBgdXRpbC50eXBlc2AgZm9yIE5vZGUuanMgMTArLlxuICAgIHZhciB0eXBlcyA9IGZyZWVNb2R1bGUgJiYgZnJlZU1vZHVsZS5yZXF1aXJlICYmIGZyZWVNb2R1bGUucmVxdWlyZSgndXRpbCcpLnR5cGVzO1xuXG4gICAgaWYgKHR5cGVzKSB7XG4gICAgICByZXR1cm4gdHlwZXM7XG4gICAgfVxuXG4gICAgLy8gTGVnYWN5IGBwcm9jZXNzLmJpbmRpbmcoJ3V0aWwnKWAgZm9yIE5vZGUuanMgPCAxMC5cbiAgICByZXR1cm4gZnJlZVByb2Nlc3MgJiYgZnJlZVByb2Nlc3MuYmluZGluZyAmJiBmcmVlUHJvY2Vzcy5iaW5kaW5nKCd1dGlsJyk7XG4gIH0gY2F0Y2ggKGUpIHt9XG59KCkpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IG5vZGVVdGlsO1xuIiwiLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqXG4gKiBVc2VkIHRvIHJlc29sdmUgdGhlXG4gKiBbYHRvU3RyaW5nVGFnYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtb2JqZWN0LnByb3RvdHlwZS50b3N0cmluZylcbiAqIG9mIHZhbHVlcy5cbiAqL1xudmFyIG5hdGl2ZU9iamVjdFRvU3RyaW5nID0gb2JqZWN0UHJvdG8udG9TdHJpbmc7XG5cbi8qKlxuICogQ29udmVydHMgYHZhbHVlYCB0byBhIHN0cmluZyB1c2luZyBgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZ2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgc3RyaW5nLlxuICovXG5mdW5jdGlvbiBvYmplY3RUb1N0cmluZyh2YWx1ZSkge1xuICByZXR1cm4gbmF0aXZlT2JqZWN0VG9TdHJpbmcuY2FsbCh2YWx1ZSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gb2JqZWN0VG9TdHJpbmc7XG4iLCIvKipcbiAqIENyZWF0ZXMgYSB1bmFyeSBmdW5jdGlvbiB0aGF0IGludm9rZXMgYGZ1bmNgIHdpdGggaXRzIGFyZ3VtZW50IHRyYW5zZm9ybWVkLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byB3cmFwLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gdHJhbnNmb3JtIFRoZSBhcmd1bWVudCB0cmFuc2Zvcm0uXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gb3ZlckFyZyhmdW5jLCB0cmFuc2Zvcm0pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKGFyZykge1xuICAgIHJldHVybiBmdW5jKHRyYW5zZm9ybShhcmcpKTtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBvdmVyQXJnO1xuIiwidmFyIGFwcGx5ID0gcmVxdWlyZSgnLi9fYXBwbHknKTtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgZm9yIHRob3NlIHdpdGggdGhlIHNhbWUgbmFtZSBhcyBvdGhlciBgbG9kYXNoYCBtZXRob2RzLiAqL1xudmFyIG5hdGl2ZU1heCA9IE1hdGgubWF4O1xuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZVJlc3RgIHdoaWNoIHRyYW5zZm9ybXMgdGhlIHJlc3QgYXJyYXkuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGFwcGx5IGEgcmVzdCBwYXJhbWV0ZXIgdG8uXG4gKiBAcGFyYW0ge251bWJlcn0gW3N0YXJ0PWZ1bmMubGVuZ3RoLTFdIFRoZSBzdGFydCBwb3NpdGlvbiBvZiB0aGUgcmVzdCBwYXJhbWV0ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSB0cmFuc2Zvcm0gVGhlIHJlc3QgYXJyYXkgdHJhbnNmb3JtLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIG92ZXJSZXN0KGZ1bmMsIHN0YXJ0LCB0cmFuc2Zvcm0pIHtcbiAgc3RhcnQgPSBuYXRpdmVNYXgoc3RhcnQgPT09IHVuZGVmaW5lZCA/IChmdW5jLmxlbmd0aCAtIDEpIDogc3RhcnQsIDApO1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGFyZ3MgPSBhcmd1bWVudHMsXG4gICAgICAgIGluZGV4ID0gLTEsXG4gICAgICAgIGxlbmd0aCA9IG5hdGl2ZU1heChhcmdzLmxlbmd0aCAtIHN0YXJ0LCAwKSxcbiAgICAgICAgYXJyYXkgPSBBcnJheShsZW5ndGgpO1xuXG4gICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgIGFycmF5W2luZGV4XSA9IGFyZ3Nbc3RhcnQgKyBpbmRleF07XG4gICAgfVxuICAgIGluZGV4ID0gLTE7XG4gICAgdmFyIG90aGVyQXJncyA9IEFycmF5KHN0YXJ0ICsgMSk7XG4gICAgd2hpbGUgKCsraW5kZXggPCBzdGFydCkge1xuICAgICAgb3RoZXJBcmdzW2luZGV4XSA9IGFyZ3NbaW5kZXhdO1xuICAgIH1cbiAgICBvdGhlckFyZ3Nbc3RhcnRdID0gdHJhbnNmb3JtKGFycmF5KTtcbiAgICByZXR1cm4gYXBwbHkoZnVuYywgdGhpcywgb3RoZXJBcmdzKTtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBvdmVyUmVzdDtcbiIsInZhciBmcmVlR2xvYmFsID0gcmVxdWlyZSgnLi9fZnJlZUdsb2JhbCcpO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYHNlbGZgLiAqL1xudmFyIGZyZWVTZWxmID0gdHlwZW9mIHNlbGYgPT0gJ29iamVjdCcgJiYgc2VsZiAmJiBzZWxmLk9iamVjdCA9PT0gT2JqZWN0ICYmIHNlbGY7XG5cbi8qKiBVc2VkIGFzIGEgcmVmZXJlbmNlIHRvIHRoZSBnbG9iYWwgb2JqZWN0LiAqL1xudmFyIHJvb3QgPSBmcmVlR2xvYmFsIHx8IGZyZWVTZWxmIHx8IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCk7XG5cbm1vZHVsZS5leHBvcnRzID0gcm9vdDtcbiIsIi8qKlxuICogR2V0cyB0aGUgdmFsdWUgYXQgYGtleWAsIHVubGVzcyBga2V5YCBpcyBcIl9fcHJvdG9fX1wiIG9yIFwiY29uc3RydWN0b3JcIi5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcHJvcGVydHkgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIHNhZmVHZXQob2JqZWN0LCBrZXkpIHtcbiAgaWYgKGtleSA9PT0gJ2NvbnN0cnVjdG9yJyAmJiB0eXBlb2Ygb2JqZWN0W2tleV0gPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAoa2V5ID09ICdfX3Byb3RvX18nKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgcmV0dXJuIG9iamVjdFtrZXldO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHNhZmVHZXQ7XG4iLCIvKiogVXNlZCB0byBzdGFuZC1pbiBmb3IgYHVuZGVmaW5lZGAgaGFzaCB2YWx1ZXMuICovXG52YXIgSEFTSF9VTkRFRklORUQgPSAnX19sb2Rhc2hfaGFzaF91bmRlZmluZWRfXyc7XG5cbi8qKlxuICogQWRkcyBgdmFsdWVgIHRvIHRoZSBhcnJheSBjYWNoZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgYWRkXG4gKiBAbWVtYmVyT2YgU2V0Q2FjaGVcbiAqIEBhbGlhcyBwdXNoXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjYWNoZS5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGNhY2hlIGluc3RhbmNlLlxuICovXG5mdW5jdGlvbiBzZXRDYWNoZUFkZCh2YWx1ZSkge1xuICB0aGlzLl9fZGF0YV9fLnNldCh2YWx1ZSwgSEFTSF9VTkRFRklORUQpO1xuICByZXR1cm4gdGhpcztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzZXRDYWNoZUFkZDtcbiIsIi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgaW4gdGhlIGFycmF5IGNhY2hlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBoYXNcbiAqIEBtZW1iZXJPZiBTZXRDYWNoZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2VhcmNoIGZvci5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgZm91bmQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gc2V0Q2FjaGVIYXModmFsdWUpIHtcbiAgcmV0dXJuIHRoaXMuX19kYXRhX18uaGFzKHZhbHVlKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzZXRDYWNoZUhhcztcbiIsIi8qKlxuICogQ29udmVydHMgYHNldGAgdG8gYW4gYXJyYXkgb2YgaXRzIHZhbHVlcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IHNldCBUaGUgc2V0IHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHZhbHVlcy5cbiAqL1xuZnVuY3Rpb24gc2V0VG9BcnJheShzZXQpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICByZXN1bHQgPSBBcnJheShzZXQuc2l6ZSk7XG5cbiAgc2V0LmZvckVhY2goZnVuY3Rpb24odmFsdWUpIHtcbiAgICByZXN1bHRbKytpbmRleF0gPSB2YWx1ZTtcbiAgfSk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc2V0VG9BcnJheTtcbiIsInZhciBiYXNlU2V0VG9TdHJpbmcgPSByZXF1aXJlKCcuL19iYXNlU2V0VG9TdHJpbmcnKSxcbiAgICBzaG9ydE91dCA9IHJlcXVpcmUoJy4vX3Nob3J0T3V0Jyk7XG5cbi8qKlxuICogU2V0cyB0aGUgYHRvU3RyaW5nYCBtZXRob2Qgb2YgYGZ1bmNgIHRvIHJldHVybiBgc3RyaW5nYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gbW9kaWZ5LlxuICogQHBhcmFtIHtGdW5jdGlvbn0gc3RyaW5nIFRoZSBgdG9TdHJpbmdgIHJlc3VsdC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyBgZnVuY2AuXG4gKi9cbnZhciBzZXRUb1N0cmluZyA9IHNob3J0T3V0KGJhc2VTZXRUb1N0cmluZyk7XG5cbm1vZHVsZS5leHBvcnRzID0gc2V0VG9TdHJpbmc7XG4iLCIvKiogVXNlZCB0byBkZXRlY3QgaG90IGZ1bmN0aW9ucyBieSBudW1iZXIgb2YgY2FsbHMgd2l0aGluIGEgc3BhbiBvZiBtaWxsaXNlY29uZHMuICovXG52YXIgSE9UX0NPVU5UID0gODAwLFxuICAgIEhPVF9TUEFOID0gMTY7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIGZvciB0aG9zZSB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgb3RoZXIgYGxvZGFzaGAgbWV0aG9kcy4gKi9cbnZhciBuYXRpdmVOb3cgPSBEYXRlLm5vdztcblxuLyoqXG4gKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCdsbCBzaG9ydCBvdXQgYW5kIGludm9rZSBgaWRlbnRpdHlgIGluc3RlYWRcbiAqIG9mIGBmdW5jYCB3aGVuIGl0J3MgY2FsbGVkIGBIT1RfQ09VTlRgIG9yIG1vcmUgdGltZXMgaW4gYEhPVF9TUEFOYFxuICogbWlsbGlzZWNvbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byByZXN0cmljdC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHNob3J0YWJsZSBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gc2hvcnRPdXQoZnVuYykge1xuICB2YXIgY291bnQgPSAwLFxuICAgICAgbGFzdENhbGxlZCA9IDA7XG5cbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHZhciBzdGFtcCA9IG5hdGl2ZU5vdygpLFxuICAgICAgICByZW1haW5pbmcgPSBIT1RfU1BBTiAtIChzdGFtcCAtIGxhc3RDYWxsZWQpO1xuXG4gICAgbGFzdENhbGxlZCA9IHN0YW1wO1xuICAgIGlmIChyZW1haW5pbmcgPiAwKSB7XG4gICAgICBpZiAoKytjb3VudCA+PSBIT1RfQ09VTlQpIHtcbiAgICAgICAgcmV0dXJuIGFyZ3VtZW50c1swXTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY291bnQgPSAwO1xuICAgIH1cbiAgICByZXR1cm4gZnVuYy5hcHBseSh1bmRlZmluZWQsIGFyZ3VtZW50cyk7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc2hvcnRPdXQ7XG4iLCJ2YXIgTGlzdENhY2hlID0gcmVxdWlyZSgnLi9fTGlzdENhY2hlJyk7XG5cbi8qKlxuICogUmVtb3ZlcyBhbGwga2V5LXZhbHVlIGVudHJpZXMgZnJvbSB0aGUgc3RhY2suXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGNsZWFyXG4gKiBAbWVtYmVyT2YgU3RhY2tcbiAqL1xuZnVuY3Rpb24gc3RhY2tDbGVhcigpIHtcbiAgdGhpcy5fX2RhdGFfXyA9IG5ldyBMaXN0Q2FjaGU7XG4gIHRoaXMuc2l6ZSA9IDA7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc3RhY2tDbGVhcjtcbiIsIi8qKlxuICogUmVtb3ZlcyBga2V5YCBhbmQgaXRzIHZhbHVlIGZyb20gdGhlIHN0YWNrLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBkZWxldGVcbiAqIEBtZW1iZXJPZiBTdGFja1xuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byByZW1vdmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGVudHJ5IHdhcyByZW1vdmVkLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIHN0YWNrRGVsZXRlKGtleSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18sXG4gICAgICByZXN1bHQgPSBkYXRhWydkZWxldGUnXShrZXkpO1xuXG4gIHRoaXMuc2l6ZSA9IGRhdGEuc2l6ZTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzdGFja0RlbGV0ZTtcbiIsIi8qKlxuICogR2V0cyB0aGUgc3RhY2sgdmFsdWUgZm9yIGBrZXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBnZXRcbiAqIEBtZW1iZXJPZiBTdGFja1xuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZW50cnkgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIHN0YWNrR2V0KGtleSkge1xuICByZXR1cm4gdGhpcy5fX2RhdGFfXy5nZXQoa2V5KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzdGFja0dldDtcbiIsIi8qKlxuICogQ2hlY2tzIGlmIGEgc3RhY2sgdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgaGFzXG4gKiBAbWVtYmVyT2YgU3RhY2tcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW4gZW50cnkgZm9yIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBzdGFja0hhcyhrZXkpIHtcbiAgcmV0dXJuIHRoaXMuX19kYXRhX18uaGFzKGtleSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc3RhY2tIYXM7XG4iLCJ2YXIgTGlzdENhY2hlID0gcmVxdWlyZSgnLi9fTGlzdENhY2hlJyksXG4gICAgTWFwID0gcmVxdWlyZSgnLi9fTWFwJyksXG4gICAgTWFwQ2FjaGUgPSByZXF1aXJlKCcuL19NYXBDYWNoZScpO1xuXG4vKiogVXNlZCBhcyB0aGUgc2l6ZSB0byBlbmFibGUgbGFyZ2UgYXJyYXkgb3B0aW1pemF0aW9ucy4gKi9cbnZhciBMQVJHRV9BUlJBWV9TSVpFID0gMjAwO1xuXG4vKipcbiAqIFNldHMgdGhlIHN0YWNrIGBrZXlgIHRvIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIHNldFxuICogQG1lbWJlck9mIFN0YWNrXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHNldC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIHN0YWNrIGNhY2hlIGluc3RhbmNlLlxuICovXG5mdW5jdGlvbiBzdGFja1NldChrZXksIHZhbHVlKSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXztcbiAgaWYgKGRhdGEgaW5zdGFuY2VvZiBMaXN0Q2FjaGUpIHtcbiAgICB2YXIgcGFpcnMgPSBkYXRhLl9fZGF0YV9fO1xuICAgIGlmICghTWFwIHx8IChwYWlycy5sZW5ndGggPCBMQVJHRV9BUlJBWV9TSVpFIC0gMSkpIHtcbiAgICAgIHBhaXJzLnB1c2goW2tleSwgdmFsdWVdKTtcbiAgICAgIHRoaXMuc2l6ZSA9ICsrZGF0YS5zaXplO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGRhdGEgPSB0aGlzLl9fZGF0YV9fID0gbmV3IE1hcENhY2hlKHBhaXJzKTtcbiAgfVxuICBkYXRhLnNldChrZXksIHZhbHVlKTtcbiAgdGhpcy5zaXplID0gZGF0YS5zaXplO1xuICByZXR1cm4gdGhpcztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzdGFja1NldDtcbiIsIi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLmluZGV4T2ZgIHdoaWNoIHBlcmZvcm1zIHN0cmljdCBlcXVhbGl0eVxuICogY29tcGFyaXNvbnMgb2YgdmFsdWVzLCBpLmUuIGA9PT1gLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNlYXJjaCBmb3IuXG4gKiBAcGFyYW0ge251bWJlcn0gZnJvbUluZGV4IFRoZSBpbmRleCB0byBzZWFyY2ggZnJvbS5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBtYXRjaGVkIHZhbHVlLCBlbHNlIGAtMWAuXG4gKi9cbmZ1bmN0aW9uIHN0cmljdEluZGV4T2YoYXJyYXksIHZhbHVlLCBmcm9tSW5kZXgpIHtcbiAgdmFyIGluZGV4ID0gZnJvbUluZGV4IC0gMSxcbiAgICAgIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIGlmIChhcnJheVtpbmRleF0gPT09IHZhbHVlKSB7XG4gICAgICByZXR1cm4gaW5kZXg7XG4gICAgfVxuICB9XG4gIHJldHVybiAtMTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzdHJpY3RJbmRleE9mO1xuIiwidmFyIGFzY2lpU2l6ZSA9IHJlcXVpcmUoJy4vX2FzY2lpU2l6ZScpLFxuICAgIGhhc1VuaWNvZGUgPSByZXF1aXJlKCcuL19oYXNVbmljb2RlJyksXG4gICAgdW5pY29kZVNpemUgPSByZXF1aXJlKCcuL191bmljb2RlU2l6ZScpO1xuXG4vKipcbiAqIEdldHMgdGhlIG51bWJlciBvZiBzeW1ib2xzIGluIGBzdHJpbmdgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIFRoZSBzdHJpbmcgdG8gaW5zcGVjdC5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIHN0cmluZyBzaXplLlxuICovXG5mdW5jdGlvbiBzdHJpbmdTaXplKHN0cmluZykge1xuICByZXR1cm4gaGFzVW5pY29kZShzdHJpbmcpXG4gICAgPyB1bmljb2RlU2l6ZShzdHJpbmcpXG4gICAgOiBhc2NpaVNpemUoc3RyaW5nKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzdHJpbmdTaXplO1xuIiwidmFyIG1lbW9pemVDYXBwZWQgPSByZXF1aXJlKCcuL19tZW1vaXplQ2FwcGVkJyk7XG5cbi8qKiBVc2VkIHRvIG1hdGNoIHByb3BlcnR5IG5hbWVzIHdpdGhpbiBwcm9wZXJ0eSBwYXRocy4gKi9cbnZhciByZVByb3BOYW1lID0gL1teLltcXF1dK3xcXFsoPzooLT9cXGQrKD86XFwuXFxkKyk/KXwoW1wiJ10pKCg/Oig/IVxcMilbXlxcXFxdfFxcXFwuKSo/KVxcMilcXF18KD89KD86XFwufFxcW1xcXSkoPzpcXC58XFxbXFxdfCQpKS9nO1xuXG4vKiogVXNlZCB0byBtYXRjaCBiYWNrc2xhc2hlcyBpbiBwcm9wZXJ0eSBwYXRocy4gKi9cbnZhciByZUVzY2FwZUNoYXIgPSAvXFxcXChcXFxcKT8vZztcblxuLyoqXG4gKiBDb252ZXJ0cyBgc3RyaW5nYCB0byBhIHByb3BlcnR5IHBhdGggYXJyYXkuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgVGhlIHN0cmluZyB0byBjb252ZXJ0LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBwcm9wZXJ0eSBwYXRoIGFycmF5LlxuICovXG52YXIgc3RyaW5nVG9QYXRoID0gbWVtb2l6ZUNhcHBlZChmdW5jdGlvbihzdHJpbmcpIHtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuICBpZiAoc3RyaW5nLmNoYXJDb2RlQXQoMCkgPT09IDQ2IC8qIC4gKi8pIHtcbiAgICByZXN1bHQucHVzaCgnJyk7XG4gIH1cbiAgc3RyaW5nLnJlcGxhY2UocmVQcm9wTmFtZSwgZnVuY3Rpb24obWF0Y2gsIG51bWJlciwgcXVvdGUsIHN1YlN0cmluZykge1xuICAgIHJlc3VsdC5wdXNoKHF1b3RlID8gc3ViU3RyaW5nLnJlcGxhY2UocmVFc2NhcGVDaGFyLCAnJDEnKSA6IChudW1iZXIgfHwgbWF0Y2gpKTtcbiAgfSk7XG4gIHJldHVybiByZXN1bHQ7XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBzdHJpbmdUb1BhdGg7XG4iLCJ2YXIgaXNTeW1ib2wgPSByZXF1aXJlKCcuL2lzU3ltYm9sJyk7XG5cbi8qKiBVc2VkIGFzIHJlZmVyZW5jZXMgZm9yIHZhcmlvdXMgYE51bWJlcmAgY29uc3RhbnRzLiAqL1xudmFyIElORklOSVRZID0gMSAvIDA7XG5cbi8qKlxuICogQ29udmVydHMgYHZhbHVlYCB0byBhIHN0cmluZyBrZXkgaWYgaXQncyBub3QgYSBzdHJpbmcgb3Igc3ltYm9sLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBpbnNwZWN0LlxuICogQHJldHVybnMge3N0cmluZ3xzeW1ib2x9IFJldHVybnMgdGhlIGtleS5cbiAqL1xuZnVuY3Rpb24gdG9LZXkodmFsdWUpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnc3RyaW5nJyB8fCBpc1N5bWJvbCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgdmFyIHJlc3VsdCA9ICh2YWx1ZSArICcnKTtcbiAgcmV0dXJuIChyZXN1bHQgPT0gJzAnICYmICgxIC8gdmFsdWUpID09IC1JTkZJTklUWSkgPyAnLTAnIDogcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHRvS2V5O1xuIiwiLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIGZ1bmNQcm90byA9IEZ1bmN0aW9uLnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gcmVzb2x2ZSB0aGUgZGVjb21waWxlZCBzb3VyY2Ugb2YgZnVuY3Rpb25zLiAqL1xudmFyIGZ1bmNUb1N0cmluZyA9IGZ1bmNQcm90by50b1N0cmluZztcblxuLyoqXG4gKiBDb252ZXJ0cyBgZnVuY2AgdG8gaXRzIHNvdXJjZSBjb2RlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBjb252ZXJ0LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgc291cmNlIGNvZGUuXG4gKi9cbmZ1bmN0aW9uIHRvU291cmNlKGZ1bmMpIHtcbiAgaWYgKGZ1bmMgIT0gbnVsbCkge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gZnVuY1RvU3RyaW5nLmNhbGwoZnVuYyk7XG4gICAgfSBjYXRjaCAoZSkge31cbiAgICB0cnkge1xuICAgICAgcmV0dXJuIChmdW5jICsgJycpO1xuICAgIH0gY2F0Y2ggKGUpIHt9XG4gIH1cbiAgcmV0dXJuICcnO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHRvU291cmNlO1xuIiwiLyoqIFVzZWQgdG8gbWF0Y2ggYSBzaW5nbGUgd2hpdGVzcGFjZSBjaGFyYWN0ZXIuICovXG52YXIgcmVXaGl0ZXNwYWNlID0gL1xccy87XG5cbi8qKlxuICogVXNlZCBieSBgXy50cmltYCBhbmQgYF8udHJpbUVuZGAgdG8gZ2V0IHRoZSBpbmRleCBvZiB0aGUgbGFzdCBub24td2hpdGVzcGFjZVxuICogY2hhcmFjdGVyIG9mIGBzdHJpbmdgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIFRoZSBzdHJpbmcgdG8gaW5zcGVjdC5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBsYXN0IG5vbi13aGl0ZXNwYWNlIGNoYXJhY3Rlci5cbiAqL1xuZnVuY3Rpb24gdHJpbW1lZEVuZEluZGV4KHN0cmluZykge1xuICB2YXIgaW5kZXggPSBzdHJpbmcubGVuZ3RoO1xuXG4gIHdoaWxlIChpbmRleC0tICYmIHJlV2hpdGVzcGFjZS50ZXN0KHN0cmluZy5jaGFyQXQoaW5kZXgpKSkge31cbiAgcmV0dXJuIGluZGV4O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHRyaW1tZWRFbmRJbmRleDtcbiIsIi8qKiBVc2VkIHRvIGNvbXBvc2UgdW5pY29kZSBjaGFyYWN0ZXIgY2xhc3Nlcy4gKi9cbnZhciByc0FzdHJhbFJhbmdlID0gJ1xcXFx1ZDgwMC1cXFxcdWRmZmYnLFxuICAgIHJzQ29tYm9NYXJrc1JhbmdlID0gJ1xcXFx1MDMwMC1cXFxcdTAzNmYnLFxuICAgIHJlQ29tYm9IYWxmTWFya3NSYW5nZSA9ICdcXFxcdWZlMjAtXFxcXHVmZTJmJyxcbiAgICByc0NvbWJvU3ltYm9sc1JhbmdlID0gJ1xcXFx1MjBkMC1cXFxcdTIwZmYnLFxuICAgIHJzQ29tYm9SYW5nZSA9IHJzQ29tYm9NYXJrc1JhbmdlICsgcmVDb21ib0hhbGZNYXJrc1JhbmdlICsgcnNDb21ib1N5bWJvbHNSYW5nZSxcbiAgICByc1ZhclJhbmdlID0gJ1xcXFx1ZmUwZVxcXFx1ZmUwZic7XG5cbi8qKiBVc2VkIHRvIGNvbXBvc2UgdW5pY29kZSBjYXB0dXJlIGdyb3Vwcy4gKi9cbnZhciByc0FzdHJhbCA9ICdbJyArIHJzQXN0cmFsUmFuZ2UgKyAnXScsXG4gICAgcnNDb21ibyA9ICdbJyArIHJzQ29tYm9SYW5nZSArICddJyxcbiAgICByc0ZpdHogPSAnXFxcXHVkODNjW1xcXFx1ZGZmYi1cXFxcdWRmZmZdJyxcbiAgICByc01vZGlmaWVyID0gJyg/OicgKyByc0NvbWJvICsgJ3wnICsgcnNGaXR6ICsgJyknLFxuICAgIHJzTm9uQXN0cmFsID0gJ1teJyArIHJzQXN0cmFsUmFuZ2UgKyAnXScsXG4gICAgcnNSZWdpb25hbCA9ICcoPzpcXFxcdWQ4M2NbXFxcXHVkZGU2LVxcXFx1ZGRmZl0pezJ9JyxcbiAgICByc1N1cnJQYWlyID0gJ1tcXFxcdWQ4MDAtXFxcXHVkYmZmXVtcXFxcdWRjMDAtXFxcXHVkZmZmXScsXG4gICAgcnNaV0ogPSAnXFxcXHUyMDBkJztcblxuLyoqIFVzZWQgdG8gY29tcG9zZSB1bmljb2RlIHJlZ2V4ZXMuICovXG52YXIgcmVPcHRNb2QgPSByc01vZGlmaWVyICsgJz8nLFxuICAgIHJzT3B0VmFyID0gJ1snICsgcnNWYXJSYW5nZSArICddPycsXG4gICAgcnNPcHRKb2luID0gJyg/OicgKyByc1pXSiArICcoPzonICsgW3JzTm9uQXN0cmFsLCByc1JlZ2lvbmFsLCByc1N1cnJQYWlyXS5qb2luKCd8JykgKyAnKScgKyByc09wdFZhciArIHJlT3B0TW9kICsgJykqJyxcbiAgICByc1NlcSA9IHJzT3B0VmFyICsgcmVPcHRNb2QgKyByc09wdEpvaW4sXG4gICAgcnNTeW1ib2wgPSAnKD86JyArIFtyc05vbkFzdHJhbCArIHJzQ29tYm8gKyAnPycsIHJzQ29tYm8sIHJzUmVnaW9uYWwsIHJzU3VyclBhaXIsIHJzQXN0cmFsXS5qb2luKCd8JykgKyAnKSc7XG5cbi8qKiBVc2VkIHRvIG1hdGNoIFtzdHJpbmcgc3ltYm9sc10oaHR0cHM6Ly9tYXRoaWFzYnluZW5zLmJlL25vdGVzL2phdmFzY3JpcHQtdW5pY29kZSkuICovXG52YXIgcmVVbmljb2RlID0gUmVnRXhwKHJzRml0eiArICcoPz0nICsgcnNGaXR6ICsgJyl8JyArIHJzU3ltYm9sICsgcnNTZXEsICdnJyk7XG5cbi8qKlxuICogR2V0cyB0aGUgc2l6ZSBvZiBhIFVuaWNvZGUgYHN0cmluZ2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgVGhlIHN0cmluZyBpbnNwZWN0LlxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgc3RyaW5nIHNpemUuXG4gKi9cbmZ1bmN0aW9uIHVuaWNvZGVTaXplKHN0cmluZykge1xuICB2YXIgcmVzdWx0ID0gcmVVbmljb2RlLmxhc3RJbmRleCA9IDA7XG4gIHdoaWxlIChyZVVuaWNvZGUudGVzdChzdHJpbmcpKSB7XG4gICAgKytyZXN1bHQ7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB1bmljb2RlU2l6ZTtcbiIsInZhciBiYXNlQ2xvbmUgPSByZXF1aXJlKCcuL19iYXNlQ2xvbmUnKTtcblxuLyoqIFVzZWQgdG8gY29tcG9zZSBiaXRtYXNrcyBmb3IgY2xvbmluZy4gKi9cbnZhciBDTE9ORV9TWU1CT0xTX0ZMQUcgPSA0O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBzaGFsbG93IGNsb25lIG9mIGB2YWx1ZWAuXG4gKlxuICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGlzIGxvb3NlbHkgYmFzZWQgb24gdGhlXG4gKiBbc3RydWN0dXJlZCBjbG9uZSBhbGdvcml0aG1dKGh0dHBzOi8vbWRuLmlvL1N0cnVjdHVyZWRfY2xvbmVfYWxnb3JpdGhtKVxuICogYW5kIHN1cHBvcnRzIGNsb25pbmcgYXJyYXlzLCBhcnJheSBidWZmZXJzLCBib29sZWFucywgZGF0ZSBvYmplY3RzLCBtYXBzLFxuICogbnVtYmVycywgYE9iamVjdGAgb2JqZWN0cywgcmVnZXhlcywgc2V0cywgc3RyaW5ncywgc3ltYm9scywgYW5kIHR5cGVkXG4gKiBhcnJheXMuIFRoZSBvd24gZW51bWVyYWJsZSBwcm9wZXJ0aWVzIG9mIGBhcmd1bWVudHNgIG9iamVjdHMgYXJlIGNsb25lZFxuICogYXMgcGxhaW4gb2JqZWN0cy4gQW4gZW1wdHkgb2JqZWN0IGlzIHJldHVybmVkIGZvciB1bmNsb25lYWJsZSB2YWx1ZXMgc3VjaFxuICogYXMgZXJyb3Igb2JqZWN0cywgZnVuY3Rpb25zLCBET00gbm9kZXMsIGFuZCBXZWFrTWFwcy5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2xvbmUuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgY2xvbmVkIHZhbHVlLlxuICogQHNlZSBfLmNsb25lRGVlcFxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0cyA9IFt7ICdhJzogMSB9LCB7ICdiJzogMiB9XTtcbiAqXG4gKiB2YXIgc2hhbGxvdyA9IF8uY2xvbmUob2JqZWN0cyk7XG4gKiBjb25zb2xlLmxvZyhzaGFsbG93WzBdID09PSBvYmplY3RzWzBdKTtcbiAqIC8vID0+IHRydWVcbiAqL1xuZnVuY3Rpb24gY2xvbmUodmFsdWUpIHtcbiAgcmV0dXJuIGJhc2VDbG9uZSh2YWx1ZSwgQ0xPTkVfU1lNQk9MU19GTEFHKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjbG9uZTtcbiIsInZhciBiYXNlQ2xvbmUgPSByZXF1aXJlKCcuL19iYXNlQ2xvbmUnKTtcblxuLyoqIFVzZWQgdG8gY29tcG9zZSBiaXRtYXNrcyBmb3IgY2xvbmluZy4gKi9cbnZhciBDTE9ORV9ERUVQX0ZMQUcgPSAxLFxuICAgIENMT05FX1NZTUJPTFNfRkxBRyA9IDQ7XG5cbi8qKlxuICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5jbG9uZWAgZXhjZXB0IHRoYXQgaXQgcmVjdXJzaXZlbHkgY2xvbmVzIGB2YWx1ZWAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAxLjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHJlY3Vyc2l2ZWx5IGNsb25lLlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGRlZXAgY2xvbmVkIHZhbHVlLlxuICogQHNlZSBfLmNsb25lXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3RzID0gW3sgJ2EnOiAxIH0sIHsgJ2InOiAyIH1dO1xuICpcbiAqIHZhciBkZWVwID0gXy5jbG9uZURlZXAob2JqZWN0cyk7XG4gKiBjb25zb2xlLmxvZyhkZWVwWzBdID09PSBvYmplY3RzWzBdKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGNsb25lRGVlcCh2YWx1ZSkge1xuICByZXR1cm4gYmFzZUNsb25lKHZhbHVlLCBDTE9ORV9ERUVQX0ZMQUcgfCBDTE9ORV9TWU1CT0xTX0ZMQUcpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNsb25lRGVlcDtcbiIsIi8qKlxuICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBgdmFsdWVgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMi40LjBcbiAqIEBjYXRlZ29yeSBVdGlsXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byByZXR1cm4gZnJvbSB0aGUgbmV3IGZ1bmN0aW9uLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgY29uc3RhbnQgZnVuY3Rpb24uXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3RzID0gXy50aW1lcygyLCBfLmNvbnN0YW50KHsgJ2EnOiAxIH0pKTtcbiAqXG4gKiBjb25zb2xlLmxvZyhvYmplY3RzKTtcbiAqIC8vID0+IFt7ICdhJzogMSB9LCB7ICdhJzogMSB9XVxuICpcbiAqIGNvbnNvbGUubG9nKG9iamVjdHNbMF0gPT09IG9iamVjdHNbMV0pO1xuICogLy8gPT4gdHJ1ZVxuICovXG5mdW5jdGlvbiBjb25zdGFudCh2YWx1ZSkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNvbnN0YW50O1xuIiwidmFyIGJhc2VSZXN0ID0gcmVxdWlyZSgnLi9fYmFzZVJlc3QnKSxcbiAgICBlcSA9IHJlcXVpcmUoJy4vZXEnKSxcbiAgICBpc0l0ZXJhdGVlQ2FsbCA9IHJlcXVpcmUoJy4vX2lzSXRlcmF0ZWVDYWxsJyksXG4gICAga2V5c0luID0gcmVxdWlyZSgnLi9rZXlzSW4nKTtcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBBc3NpZ25zIG93biBhbmQgaW5oZXJpdGVkIGVudW1lcmFibGUgc3RyaW5nIGtleWVkIHByb3BlcnRpZXMgb2Ygc291cmNlXG4gKiBvYmplY3RzIHRvIHRoZSBkZXN0aW5hdGlvbiBvYmplY3QgZm9yIGFsbCBkZXN0aW5hdGlvbiBwcm9wZXJ0aWVzIHRoYXRcbiAqIHJlc29sdmUgdG8gYHVuZGVmaW5lZGAuIFNvdXJjZSBvYmplY3RzIGFyZSBhcHBsaWVkIGZyb20gbGVmdCB0byByaWdodC5cbiAqIE9uY2UgYSBwcm9wZXJ0eSBpcyBzZXQsIGFkZGl0aW9uYWwgdmFsdWVzIG9mIHRoZSBzYW1lIHByb3BlcnR5IGFyZSBpZ25vcmVkLlxuICpcbiAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBtdXRhdGVzIGBvYmplY3RgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBzaW5jZSAwLjEuMFxuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAqIEBwYXJhbSB7Li4uT2JqZWN0fSBbc291cmNlc10gVGhlIHNvdXJjZSBvYmplY3RzLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAqIEBzZWUgXy5kZWZhdWx0c0RlZXBcbiAqIEBleGFtcGxlXG4gKlxuICogXy5kZWZhdWx0cyh7ICdhJzogMSB9LCB7ICdiJzogMiB9LCB7ICdhJzogMyB9KTtcbiAqIC8vID0+IHsgJ2EnOiAxLCAnYic6IDIgfVxuICovXG52YXIgZGVmYXVsdHMgPSBiYXNlUmVzdChmdW5jdGlvbihvYmplY3QsIHNvdXJjZXMpIHtcbiAgb2JqZWN0ID0gT2JqZWN0KG9iamVjdCk7XG5cbiAgdmFyIGluZGV4ID0gLTE7XG4gIHZhciBsZW5ndGggPSBzb3VyY2VzLmxlbmd0aDtcbiAgdmFyIGd1YXJkID0gbGVuZ3RoID4gMiA/IHNvdXJjZXNbMl0gOiB1bmRlZmluZWQ7XG5cbiAgaWYgKGd1YXJkICYmIGlzSXRlcmF0ZWVDYWxsKHNvdXJjZXNbMF0sIHNvdXJjZXNbMV0sIGd1YXJkKSkge1xuICAgIGxlbmd0aCA9IDE7XG4gIH1cblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciBzb3VyY2UgPSBzb3VyY2VzW2luZGV4XTtcbiAgICB2YXIgcHJvcHMgPSBrZXlzSW4oc291cmNlKTtcbiAgICB2YXIgcHJvcHNJbmRleCA9IC0xO1xuICAgIHZhciBwcm9wc0xlbmd0aCA9IHByb3BzLmxlbmd0aDtcblxuICAgIHdoaWxlICgrK3Byb3BzSW5kZXggPCBwcm9wc0xlbmd0aCkge1xuICAgICAgdmFyIGtleSA9IHByb3BzW3Byb3BzSW5kZXhdO1xuICAgICAgdmFyIHZhbHVlID0gb2JqZWN0W2tleV07XG5cbiAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICAgICAgKGVxKHZhbHVlLCBvYmplY3RQcm90b1trZXldKSAmJiAhaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIGtleSkpKSB7XG4gICAgICAgIG9iamVjdFtrZXldID0gc291cmNlW2tleV07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG9iamVjdDtcbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGRlZmF1bHRzO1xuIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2ZvckVhY2gnKTtcbiIsIi8qKlxuICogUGVyZm9ybXMgYVxuICogW2BTYW1lVmFsdWVaZXJvYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtc2FtZXZhbHVlemVybylcbiAqIGNvbXBhcmlzb24gYmV0d2VlbiB0d28gdmFsdWVzIHRvIGRldGVybWluZSBpZiB0aGV5IGFyZSBlcXVpdmFsZW50LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb21wYXJlLlxuICogQHBhcmFtIHsqfSBvdGhlciBUaGUgb3RoZXIgdmFsdWUgdG8gY29tcGFyZS5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgdmFsdWVzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3QgPSB7ICdhJzogMSB9O1xuICogdmFyIG90aGVyID0geyAnYSc6IDEgfTtcbiAqXG4gKiBfLmVxKG9iamVjdCwgb2JqZWN0KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmVxKG9iamVjdCwgb3RoZXIpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmVxKCdhJywgJ2EnKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmVxKCdhJywgT2JqZWN0KCdhJykpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmVxKE5hTiwgTmFOKTtcbiAqIC8vID0+IHRydWVcbiAqL1xuZnVuY3Rpb24gZXEodmFsdWUsIG90aGVyKSB7XG4gIHJldHVybiB2YWx1ZSA9PT0gb3RoZXIgfHwgKHZhbHVlICE9PSB2YWx1ZSAmJiBvdGhlciAhPT0gb3RoZXIpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGVxO1xuIiwidmFyIGFycmF5RmlsdGVyID0gcmVxdWlyZSgnLi9fYXJyYXlGaWx0ZXInKSxcbiAgICBiYXNlRmlsdGVyID0gcmVxdWlyZSgnLi9fYmFzZUZpbHRlcicpLFxuICAgIGJhc2VJdGVyYXRlZSA9IHJlcXVpcmUoJy4vX2Jhc2VJdGVyYXRlZScpLFxuICAgIGlzQXJyYXkgPSByZXF1aXJlKCcuL2lzQXJyYXknKTtcblxuLyoqXG4gKiBJdGVyYXRlcyBvdmVyIGVsZW1lbnRzIG9mIGBjb2xsZWN0aW9uYCwgcmV0dXJuaW5nIGFuIGFycmF5IG9mIGFsbCBlbGVtZW50c1xuICogYHByZWRpY2F0ZWAgcmV0dXJucyB0cnV0aHkgZm9yLiBUaGUgcHJlZGljYXRlIGlzIGludm9rZWQgd2l0aCB0aHJlZVxuICogYXJndW1lbnRzOiAodmFsdWUsIGluZGV4fGtleSwgY29sbGVjdGlvbikuXG4gKlxuICogKipOb3RlOioqIFVubGlrZSBgXy5yZW1vdmVgLCB0aGlzIG1ldGhvZCByZXR1cm5zIGEgbmV3IGFycmF5LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcHJlZGljYXRlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBmaWx0ZXJlZCBhcnJheS5cbiAqIEBzZWUgXy5yZWplY3RcbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIHVzZXJzID0gW1xuICogICB7ICd1c2VyJzogJ2Jhcm5leScsICdhZ2UnOiAzNiwgJ2FjdGl2ZSc6IHRydWUgfSxcbiAqICAgeyAndXNlcic6ICdmcmVkJywgICAnYWdlJzogNDAsICdhY3RpdmUnOiBmYWxzZSB9XG4gKiBdO1xuICpcbiAqIF8uZmlsdGVyKHVzZXJzLCBmdW5jdGlvbihvKSB7IHJldHVybiAhby5hY3RpdmU7IH0pO1xuICogLy8gPT4gb2JqZWN0cyBmb3IgWydmcmVkJ11cbiAqXG4gKiAvLyBUaGUgYF8ubWF0Y2hlc2AgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICogXy5maWx0ZXIodXNlcnMsIHsgJ2FnZSc6IDM2LCAnYWN0aXZlJzogdHJ1ZSB9KTtcbiAqIC8vID0+IG9iamVjdHMgZm9yIFsnYmFybmV5J11cbiAqXG4gKiAvLyBUaGUgYF8ubWF0Y2hlc1Byb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gKiBfLmZpbHRlcih1c2VycywgWydhY3RpdmUnLCBmYWxzZV0pO1xuICogLy8gPT4gb2JqZWN0cyBmb3IgWydmcmVkJ11cbiAqXG4gKiAvLyBUaGUgYF8ucHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAqIF8uZmlsdGVyKHVzZXJzLCAnYWN0aXZlJyk7XG4gKiAvLyA9PiBvYmplY3RzIGZvciBbJ2Jhcm5leSddXG4gKlxuICogLy8gQ29tYmluaW5nIHNldmVyYWwgcHJlZGljYXRlcyB1c2luZyBgXy5vdmVyRXZlcnlgIG9yIGBfLm92ZXJTb21lYC5cbiAqIF8uZmlsdGVyKHVzZXJzLCBfLm92ZXJTb21lKFt7ICdhZ2UnOiAzNiB9LCBbJ2FnZScsIDQwXV0pKTtcbiAqIC8vID0+IG9iamVjdHMgZm9yIFsnZnJlZCcsICdiYXJuZXknXVxuICovXG5mdW5jdGlvbiBmaWx0ZXIoY29sbGVjdGlvbiwgcHJlZGljYXRlKSB7XG4gIHZhciBmdW5jID0gaXNBcnJheShjb2xsZWN0aW9uKSA/IGFycmF5RmlsdGVyIDogYmFzZUZpbHRlcjtcbiAgcmV0dXJuIGZ1bmMoY29sbGVjdGlvbiwgYmFzZUl0ZXJhdGVlKHByZWRpY2F0ZSwgMykpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZpbHRlcjtcbiIsInZhciBjcmVhdGVGaW5kID0gcmVxdWlyZSgnLi9fY3JlYXRlRmluZCcpLFxuICAgIGZpbmRJbmRleCA9IHJlcXVpcmUoJy4vZmluZEluZGV4Jyk7XG5cbi8qKlxuICogSXRlcmF0ZXMgb3ZlciBlbGVtZW50cyBvZiBgY29sbGVjdGlvbmAsIHJldHVybmluZyB0aGUgZmlyc3QgZWxlbWVudFxuICogYHByZWRpY2F0ZWAgcmV0dXJucyB0cnV0aHkgZm9yLiBUaGUgcHJlZGljYXRlIGlzIGludm9rZWQgd2l0aCB0aHJlZVxuICogYXJndW1lbnRzOiAodmFsdWUsIGluZGV4fGtleSwgY29sbGVjdGlvbikuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGluc3BlY3QuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcHJlZGljYXRlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcGFyYW0ge251bWJlcn0gW2Zyb21JbmRleD0wXSBUaGUgaW5kZXggdG8gc2VhcmNoIGZyb20uXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgbWF0Y2hlZCBlbGVtZW50LCBlbHNlIGB1bmRlZmluZWRgLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgdXNlcnMgPSBbXG4gKiAgIHsgJ3VzZXInOiAnYmFybmV5JywgICdhZ2UnOiAzNiwgJ2FjdGl2ZSc6IHRydWUgfSxcbiAqICAgeyAndXNlcic6ICdmcmVkJywgICAgJ2FnZSc6IDQwLCAnYWN0aXZlJzogZmFsc2UgfSxcbiAqICAgeyAndXNlcic6ICdwZWJibGVzJywgJ2FnZSc6IDEsICAnYWN0aXZlJzogdHJ1ZSB9XG4gKiBdO1xuICpcbiAqIF8uZmluZCh1c2VycywgZnVuY3Rpb24obykgeyByZXR1cm4gby5hZ2UgPCA0MDsgfSk7XG4gKiAvLyA9PiBvYmplY3QgZm9yICdiYXJuZXknXG4gKlxuICogLy8gVGhlIGBfLm1hdGNoZXNgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAqIF8uZmluZCh1c2VycywgeyAnYWdlJzogMSwgJ2FjdGl2ZSc6IHRydWUgfSk7XG4gKiAvLyA9PiBvYmplY3QgZm9yICdwZWJibGVzJ1xuICpcbiAqIC8vIFRoZSBgXy5tYXRjaGVzUHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAqIF8uZmluZCh1c2VycywgWydhY3RpdmUnLCBmYWxzZV0pO1xuICogLy8gPT4gb2JqZWN0IGZvciAnZnJlZCdcbiAqXG4gKiAvLyBUaGUgYF8ucHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAqIF8uZmluZCh1c2VycywgJ2FjdGl2ZScpO1xuICogLy8gPT4gb2JqZWN0IGZvciAnYmFybmV5J1xuICovXG52YXIgZmluZCA9IGNyZWF0ZUZpbmQoZmluZEluZGV4KTtcblxubW9kdWxlLmV4cG9ydHMgPSBmaW5kO1xuIiwidmFyIGJhc2VGaW5kSW5kZXggPSByZXF1aXJlKCcuL19iYXNlRmluZEluZGV4JyksXG4gICAgYmFzZUl0ZXJhdGVlID0gcmVxdWlyZSgnLi9fYmFzZUl0ZXJhdGVlJyksXG4gICAgdG9JbnRlZ2VyID0gcmVxdWlyZSgnLi90b0ludGVnZXInKTtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgZm9yIHRob3NlIHdpdGggdGhlIHNhbWUgbmFtZSBhcyBvdGhlciBgbG9kYXNoYCBtZXRob2RzLiAqL1xudmFyIG5hdGl2ZU1heCA9IE1hdGgubWF4O1xuXG4vKipcbiAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uZmluZGAgZXhjZXB0IHRoYXQgaXQgcmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIGZpcnN0XG4gKiBlbGVtZW50IGBwcmVkaWNhdGVgIHJldHVybnMgdHJ1dGh5IGZvciBpbnN0ZWFkIG9mIHRoZSBlbGVtZW50IGl0c2VsZi5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDEuMS4wXG4gKiBAY2F0ZWdvcnkgQXJyYXlcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW3ByZWRpY2F0ZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHBhcmFtIHtudW1iZXJ9IFtmcm9tSW5kZXg9MF0gVGhlIGluZGV4IHRvIHNlYXJjaCBmcm9tLlxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIGZvdW5kIGVsZW1lbnQsIGVsc2UgYC0xYC5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIHVzZXJzID0gW1xuICogICB7ICd1c2VyJzogJ2Jhcm5leScsICAnYWN0aXZlJzogZmFsc2UgfSxcbiAqICAgeyAndXNlcic6ICdmcmVkJywgICAgJ2FjdGl2ZSc6IGZhbHNlIH0sXG4gKiAgIHsgJ3VzZXInOiAncGViYmxlcycsICdhY3RpdmUnOiB0cnVlIH1cbiAqIF07XG4gKlxuICogXy5maW5kSW5kZXgodXNlcnMsIGZ1bmN0aW9uKG8pIHsgcmV0dXJuIG8udXNlciA9PSAnYmFybmV5JzsgfSk7XG4gKiAvLyA9PiAwXG4gKlxuICogLy8gVGhlIGBfLm1hdGNoZXNgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAqIF8uZmluZEluZGV4KHVzZXJzLCB7ICd1c2VyJzogJ2ZyZWQnLCAnYWN0aXZlJzogZmFsc2UgfSk7XG4gKiAvLyA9PiAxXG4gKlxuICogLy8gVGhlIGBfLm1hdGNoZXNQcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICogXy5maW5kSW5kZXgodXNlcnMsIFsnYWN0aXZlJywgZmFsc2VdKTtcbiAqIC8vID0+IDBcbiAqXG4gKiAvLyBUaGUgYF8ucHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAqIF8uZmluZEluZGV4KHVzZXJzLCAnYWN0aXZlJyk7XG4gKiAvLyA9PiAyXG4gKi9cbmZ1bmN0aW9uIGZpbmRJbmRleChhcnJheSwgcHJlZGljYXRlLCBmcm9tSW5kZXgpIHtcbiAgdmFyIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuICBpZiAoIWxlbmd0aCkge1xuICAgIHJldHVybiAtMTtcbiAgfVxuICB2YXIgaW5kZXggPSBmcm9tSW5kZXggPT0gbnVsbCA/IDAgOiB0b0ludGVnZXIoZnJvbUluZGV4KTtcbiAgaWYgKGluZGV4IDwgMCkge1xuICAgIGluZGV4ID0gbmF0aXZlTWF4KGxlbmd0aCArIGluZGV4LCAwKTtcbiAgfVxuICByZXR1cm4gYmFzZUZpbmRJbmRleChhcnJheSwgYmFzZUl0ZXJhdGVlKHByZWRpY2F0ZSwgMyksIGluZGV4KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmaW5kSW5kZXg7XG4iLCJ2YXIgYmFzZUZsYXR0ZW4gPSByZXF1aXJlKCcuL19iYXNlRmxhdHRlbicpO1xuXG4vKipcbiAqIEZsYXR0ZW5zIGBhcnJheWAgYSBzaW5nbGUgbGV2ZWwgZGVlcC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgQXJyYXlcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBmbGF0dGVuLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZmxhdHRlbmVkIGFycmF5LlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmZsYXR0ZW4oWzEsIFsyLCBbMywgWzRdXSwgNV1dKTtcbiAqIC8vID0+IFsxLCAyLCBbMywgWzRdXSwgNV1cbiAqL1xuZnVuY3Rpb24gZmxhdHRlbihhcnJheSkge1xuICB2YXIgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG4gIHJldHVybiBsZW5ndGggPyBiYXNlRmxhdHRlbihhcnJheSwgMSkgOiBbXTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmbGF0dGVuO1xuIiwidmFyIGFycmF5RWFjaCA9IHJlcXVpcmUoJy4vX2FycmF5RWFjaCcpLFxuICAgIGJhc2VFYWNoID0gcmVxdWlyZSgnLi9fYmFzZUVhY2gnKSxcbiAgICBjYXN0RnVuY3Rpb24gPSByZXF1aXJlKCcuL19jYXN0RnVuY3Rpb24nKSxcbiAgICBpc0FycmF5ID0gcmVxdWlyZSgnLi9pc0FycmF5Jyk7XG5cbi8qKlxuICogSXRlcmF0ZXMgb3ZlciBlbGVtZW50cyBvZiBgY29sbGVjdGlvbmAgYW5kIGludm9rZXMgYGl0ZXJhdGVlYCBmb3IgZWFjaCBlbGVtZW50LlxuICogVGhlIGl0ZXJhdGVlIGlzIGludm9rZWQgd2l0aCB0aHJlZSBhcmd1bWVudHM6ICh2YWx1ZSwgaW5kZXh8a2V5LCBjb2xsZWN0aW9uKS5cbiAqIEl0ZXJhdGVlIGZ1bmN0aW9ucyBtYXkgZXhpdCBpdGVyYXRpb24gZWFybHkgYnkgZXhwbGljaXRseSByZXR1cm5pbmcgYGZhbHNlYC5cbiAqXG4gKiAqKk5vdGU6KiogQXMgd2l0aCBvdGhlciBcIkNvbGxlY3Rpb25zXCIgbWV0aG9kcywgb2JqZWN0cyB3aXRoIGEgXCJsZW5ndGhcIlxuICogcHJvcGVydHkgYXJlIGl0ZXJhdGVkIGxpa2UgYXJyYXlzLiBUbyBhdm9pZCB0aGlzIGJlaGF2aW9yIHVzZSBgXy5mb3JJbmBcbiAqIG9yIGBfLmZvck93bmAgZm9yIG9iamVjdCBpdGVyYXRpb24uXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGFsaWFzIGVhY2hcbiAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtBcnJheXxPYmplY3R9IFJldHVybnMgYGNvbGxlY3Rpb25gLlxuICogQHNlZSBfLmZvckVhY2hSaWdodFxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmZvckVhY2goWzEsIDJdLCBmdW5jdGlvbih2YWx1ZSkge1xuICogICBjb25zb2xlLmxvZyh2YWx1ZSk7XG4gKiB9KTtcbiAqIC8vID0+IExvZ3MgYDFgIHRoZW4gYDJgLlxuICpcbiAqIF8uZm9yRWFjaCh7ICdhJzogMSwgJ2InOiAyIH0sIGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHtcbiAqICAgY29uc29sZS5sb2coa2V5KTtcbiAqIH0pO1xuICogLy8gPT4gTG9ncyAnYScgdGhlbiAnYicgKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZCkuXG4gKi9cbmZ1bmN0aW9uIGZvckVhY2goY29sbGVjdGlvbiwgaXRlcmF0ZWUpIHtcbiAgdmFyIGZ1bmMgPSBpc0FycmF5KGNvbGxlY3Rpb24pID8gYXJyYXlFYWNoIDogYmFzZUVhY2g7XG4gIHJldHVybiBmdW5jKGNvbGxlY3Rpb24sIGNhc3RGdW5jdGlvbihpdGVyYXRlZSkpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZvckVhY2g7XG4iLCJ2YXIgYmFzZUZvciA9IHJlcXVpcmUoJy4vX2Jhc2VGb3InKSxcbiAgICBjYXN0RnVuY3Rpb24gPSByZXF1aXJlKCcuL19jYXN0RnVuY3Rpb24nKSxcbiAgICBrZXlzSW4gPSByZXF1aXJlKCcuL2tleXNJbicpO1xuXG4vKipcbiAqIEl0ZXJhdGVzIG92ZXIgb3duIGFuZCBpbmhlcml0ZWQgZW51bWVyYWJsZSBzdHJpbmcga2V5ZWQgcHJvcGVydGllcyBvZiBhblxuICogb2JqZWN0IGFuZCBpbnZva2VzIGBpdGVyYXRlZWAgZm9yIGVhY2ggcHJvcGVydHkuIFRoZSBpdGVyYXRlZSBpcyBpbnZva2VkXG4gKiB3aXRoIHRocmVlIGFyZ3VtZW50czogKHZhbHVlLCBrZXksIG9iamVjdCkuIEl0ZXJhdGVlIGZ1bmN0aW9ucyBtYXkgZXhpdFxuICogaXRlcmF0aW9uIGVhcmx5IGJ5IGV4cGxpY2l0bHkgcmV0dXJuaW5nIGBmYWxzZWAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjMuMFxuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAqIEBzZWUgXy5mb3JJblJpZ2h0XG4gKiBAZXhhbXBsZVxuICpcbiAqIGZ1bmN0aW9uIEZvbygpIHtcbiAqICAgdGhpcy5hID0gMTtcbiAqICAgdGhpcy5iID0gMjtcbiAqIH1cbiAqXG4gKiBGb28ucHJvdG90eXBlLmMgPSAzO1xuICpcbiAqIF8uZm9ySW4obmV3IEZvbywgZnVuY3Rpb24odmFsdWUsIGtleSkge1xuICogICBjb25zb2xlLmxvZyhrZXkpO1xuICogfSk7XG4gKiAvLyA9PiBMb2dzICdhJywgJ2InLCB0aGVuICdjJyAoaXRlcmF0aW9uIG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKS5cbiAqL1xuZnVuY3Rpb24gZm9ySW4ob2JqZWN0LCBpdGVyYXRlZSkge1xuICByZXR1cm4gb2JqZWN0ID09IG51bGxcbiAgICA/IG9iamVjdFxuICAgIDogYmFzZUZvcihvYmplY3QsIGNhc3RGdW5jdGlvbihpdGVyYXRlZSksIGtleXNJbik7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZm9ySW47XG4iLCJ2YXIgYmFzZUdldCA9IHJlcXVpcmUoJy4vX2Jhc2VHZXQnKTtcblxuLyoqXG4gKiBHZXRzIHRoZSB2YWx1ZSBhdCBgcGF0aGAgb2YgYG9iamVjdGAuIElmIHRoZSByZXNvbHZlZCB2YWx1ZSBpc1xuICogYHVuZGVmaW5lZGAsIHRoZSBgZGVmYXVsdFZhbHVlYCBpcyByZXR1cm5lZCBpbiBpdHMgcGxhY2UuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAzLjcuMFxuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAqIEBwYXJhbSB7Kn0gW2RlZmF1bHRWYWx1ZV0gVGhlIHZhbHVlIHJldHVybmVkIGZvciBgdW5kZWZpbmVkYCByZXNvbHZlZCB2YWx1ZXMuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcmVzb2x2ZWQgdmFsdWUuXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3QgPSB7ICdhJzogW3sgJ2InOiB7ICdjJzogMyB9IH1dIH07XG4gKlxuICogXy5nZXQob2JqZWN0LCAnYVswXS5iLmMnKTtcbiAqIC8vID0+IDNcbiAqXG4gKiBfLmdldChvYmplY3QsIFsnYScsICcwJywgJ2InLCAnYyddKTtcbiAqIC8vID0+IDNcbiAqXG4gKiBfLmdldChvYmplY3QsICdhLmIuYycsICdkZWZhdWx0Jyk7XG4gKiAvLyA9PiAnZGVmYXVsdCdcbiAqL1xuZnVuY3Rpb24gZ2V0KG9iamVjdCwgcGF0aCwgZGVmYXVsdFZhbHVlKSB7XG4gIHZhciByZXN1bHQgPSBvYmplY3QgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IGJhc2VHZXQob2JqZWN0LCBwYXRoKTtcbiAgcmV0dXJuIHJlc3VsdCA9PT0gdW5kZWZpbmVkID8gZGVmYXVsdFZhbHVlIDogcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldDtcbiIsInZhciBiYXNlSGFzID0gcmVxdWlyZSgnLi9fYmFzZUhhcycpLFxuICAgIGhhc1BhdGggPSByZXF1aXJlKCcuL19oYXNQYXRoJyk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGBwYXRoYCBpcyBhIGRpcmVjdCBwcm9wZXJ0eSBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBtZW1iZXJPZiBfXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgcGF0aGAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3QgPSB7ICdhJzogeyAnYic6IDIgfSB9O1xuICogdmFyIG90aGVyID0gXy5jcmVhdGUoeyAnYSc6IF8uY3JlYXRlKHsgJ2InOiAyIH0pIH0pO1xuICpcbiAqIF8uaGFzKG9iamVjdCwgJ2EnKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmhhcyhvYmplY3QsICdhLmInKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmhhcyhvYmplY3QsIFsnYScsICdiJ10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaGFzKG90aGVyLCAnYScpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaGFzKG9iamVjdCwgcGF0aCkge1xuICByZXR1cm4gb2JqZWN0ICE9IG51bGwgJiYgaGFzUGF0aChvYmplY3QsIHBhdGgsIGJhc2VIYXMpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGhhcztcbiIsInZhciBiYXNlSGFzSW4gPSByZXF1aXJlKCcuL19iYXNlSGFzSW4nKSxcbiAgICBoYXNQYXRoID0gcmVxdWlyZSgnLi9faGFzUGF0aCcpO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgcGF0aGAgaXMgYSBkaXJlY3Qgb3IgaW5oZXJpdGVkIHByb3BlcnR5IG9mIGBvYmplY3RgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBwYXRoYCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdCA9IF8uY3JlYXRlKHsgJ2EnOiBfLmNyZWF0ZSh7ICdiJzogMiB9KSB9KTtcbiAqXG4gKiBfLmhhc0luKG9iamVjdCwgJ2EnKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmhhc0luKG9iamVjdCwgJ2EuYicpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaGFzSW4ob2JqZWN0LCBbJ2EnLCAnYiddKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmhhc0luKG9iamVjdCwgJ2InKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGhhc0luKG9iamVjdCwgcGF0aCkge1xuICByZXR1cm4gb2JqZWN0ICE9IG51bGwgJiYgaGFzUGF0aChvYmplY3QsIHBhdGgsIGJhc2VIYXNJbik7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaGFzSW47XG4iLCIvKipcbiAqIFRoaXMgbWV0aG9kIHJldHVybnMgdGhlIGZpcnN0IGFyZ3VtZW50IGl0IHJlY2VpdmVzLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBzaW5jZSAwLjEuMFxuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBVdGlsXG4gKiBAcGFyYW0geyp9IHZhbHVlIEFueSB2YWx1ZS5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIGB2YWx1ZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3QgPSB7ICdhJzogMSB9O1xuICpcbiAqIGNvbnNvbGUubG9nKF8uaWRlbnRpdHkob2JqZWN0KSA9PT0gb2JqZWN0KTtcbiAqIC8vID0+IHRydWVcbiAqL1xuZnVuY3Rpb24gaWRlbnRpdHkodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlkZW50aXR5O1xuIiwidmFyIGJhc2VJc0FyZ3VtZW50cyA9IHJlcXVpcmUoJy4vX2Jhc2VJc0FyZ3VtZW50cycpLFxuICAgIGlzT2JqZWN0TGlrZSA9IHJlcXVpcmUoJy4vaXNPYmplY3RMaWtlJyk7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIHByb3BlcnR5SXNFbnVtZXJhYmxlID0gb2JqZWN0UHJvdG8ucHJvcGVydHlJc0VudW1lcmFibGU7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgbGlrZWx5IGFuIGBhcmd1bWVudHNgIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBgYXJndW1lbnRzYCBvYmplY3QsXG4gKiAgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzQXJndW1lbnRzKGZ1bmN0aW9uKCkgeyByZXR1cm4gYXJndW1lbnRzOyB9KCkpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcmd1bWVudHMoWzEsIDIsIDNdKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbnZhciBpc0FyZ3VtZW50cyA9IGJhc2VJc0FyZ3VtZW50cyhmdW5jdGlvbigpIHsgcmV0dXJuIGFyZ3VtZW50czsgfSgpKSA/IGJhc2VJc0FyZ3VtZW50cyA6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmIGhhc093blByb3BlcnR5LmNhbGwodmFsdWUsICdjYWxsZWUnKSAmJlxuICAgICFwcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHZhbHVlLCAnY2FsbGVlJyk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGlzQXJndW1lbnRzO1xuIiwiLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGFuIGBBcnJheWAgb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGFycmF5LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNBcnJheShbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheShkb2N1bWVudC5ib2R5LmNoaWxkcmVuKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0FycmF5KCdhYmMnKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0FycmF5KF8ubm9vcCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG52YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXk7XG5cbm1vZHVsZS5leHBvcnRzID0gaXNBcnJheTtcbiIsInZhciBpc0Z1bmN0aW9uID0gcmVxdWlyZSgnLi9pc0Z1bmN0aW9uJyksXG4gICAgaXNMZW5ndGggPSByZXF1aXJlKCcuL2lzTGVuZ3RoJyk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYXJyYXktbGlrZS4gQSB2YWx1ZSBpcyBjb25zaWRlcmVkIGFycmF5LWxpa2UgaWYgaXQnc1xuICogbm90IGEgZnVuY3Rpb24gYW5kIGhhcyBhIGB2YWx1ZS5sZW5ndGhgIHRoYXQncyBhbiBpbnRlZ2VyIGdyZWF0ZXIgdGhhbiBvclxuICogZXF1YWwgdG8gYDBgIGFuZCBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gYE51bWJlci5NQVhfU0FGRV9JTlRFR0VSYC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhcnJheS1saWtlLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNBcnJheUxpa2UoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlKGRvY3VtZW50LmJvZHkuY2hpbGRyZW4pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheUxpa2UoJ2FiYycpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheUxpa2UoXy5ub29wKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzQXJyYXlMaWtlKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAhPSBudWxsICYmIGlzTGVuZ3RoKHZhbHVlLmxlbmd0aCkgJiYgIWlzRnVuY3Rpb24odmFsdWUpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzQXJyYXlMaWtlO1xuIiwidmFyIGlzQXJyYXlMaWtlID0gcmVxdWlyZSgnLi9pc0FycmF5TGlrZScpLFxuICAgIGlzT2JqZWN0TGlrZSA9IHJlcXVpcmUoJy4vaXNPYmplY3RMaWtlJyk7XG5cbi8qKlxuICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5pc0FycmF5TGlrZWAgZXhjZXB0IHRoYXQgaXQgYWxzbyBjaGVja3MgaWYgYHZhbHVlYFxuICogaXMgYW4gb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGFycmF5LWxpa2Ugb2JqZWN0LFxuICogIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0FycmF5TGlrZU9iamVjdChbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheUxpa2VPYmplY3QoZG9jdW1lbnQuYm9keS5jaGlsZHJlbik7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5TGlrZU9iamVjdCgnYWJjJyk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNBcnJheUxpa2VPYmplY3QoXy5ub29wKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzQXJyYXlMaWtlT2JqZWN0KHZhbHVlKSB7XG4gIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmIGlzQXJyYXlMaWtlKHZhbHVlKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc0FycmF5TGlrZU9iamVjdDtcbiIsInZhciByb290ID0gcmVxdWlyZSgnLi9fcm9vdCcpLFxuICAgIHN0dWJGYWxzZSA9IHJlcXVpcmUoJy4vc3R1YkZhbHNlJyk7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgZXhwb3J0c2AuICovXG52YXIgZnJlZUV4cG9ydHMgPSB0eXBlb2YgZXhwb3J0cyA9PSAnb2JqZWN0JyAmJiBleHBvcnRzICYmICFleHBvcnRzLm5vZGVUeXBlICYmIGV4cG9ydHM7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgbW9kdWxlYC4gKi9cbnZhciBmcmVlTW9kdWxlID0gZnJlZUV4cG9ydHMgJiYgdHlwZW9mIG1vZHVsZSA9PSAnb2JqZWN0JyAmJiBtb2R1bGUgJiYgIW1vZHVsZS5ub2RlVHlwZSAmJiBtb2R1bGU7XG5cbi8qKiBEZXRlY3QgdGhlIHBvcHVsYXIgQ29tbW9uSlMgZXh0ZW5zaW9uIGBtb2R1bGUuZXhwb3J0c2AuICovXG52YXIgbW9kdWxlRXhwb3J0cyA9IGZyZWVNb2R1bGUgJiYgZnJlZU1vZHVsZS5leHBvcnRzID09PSBmcmVlRXhwb3J0cztcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgQnVmZmVyID0gbW9kdWxlRXhwb3J0cyA/IHJvb3QuQnVmZmVyIDogdW5kZWZpbmVkO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyBmb3IgdGhvc2Ugd2l0aCB0aGUgc2FtZSBuYW1lIGFzIG90aGVyIGBsb2Rhc2hgIG1ldGhvZHMuICovXG52YXIgbmF0aXZlSXNCdWZmZXIgPSBCdWZmZXIgPyBCdWZmZXIuaXNCdWZmZXIgOiB1bmRlZmluZWQ7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSBidWZmZXIuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjMuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBidWZmZXIsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0J1ZmZlcihuZXcgQnVmZmVyKDIpKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQnVmZmVyKG5ldyBVaW50OEFycmF5KDIpKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbnZhciBpc0J1ZmZlciA9IG5hdGl2ZUlzQnVmZmVyIHx8IHN0dWJGYWxzZTtcblxubW9kdWxlLmV4cG9ydHMgPSBpc0J1ZmZlcjtcbiIsInZhciBiYXNlS2V5cyA9IHJlcXVpcmUoJy4vX2Jhc2VLZXlzJyksXG4gICAgZ2V0VGFnID0gcmVxdWlyZSgnLi9fZ2V0VGFnJyksXG4gICAgaXNBcmd1bWVudHMgPSByZXF1aXJlKCcuL2lzQXJndW1lbnRzJyksXG4gICAgaXNBcnJheSA9IHJlcXVpcmUoJy4vaXNBcnJheScpLFxuICAgIGlzQXJyYXlMaWtlID0gcmVxdWlyZSgnLi9pc0FycmF5TGlrZScpLFxuICAgIGlzQnVmZmVyID0gcmVxdWlyZSgnLi9pc0J1ZmZlcicpLFxuICAgIGlzUHJvdG90eXBlID0gcmVxdWlyZSgnLi9faXNQcm90b3R5cGUnKSxcbiAgICBpc1R5cGVkQXJyYXkgPSByZXF1aXJlKCcuL2lzVHlwZWRBcnJheScpO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgbWFwVGFnID0gJ1tvYmplY3QgTWFwXScsXG4gICAgc2V0VGFnID0gJ1tvYmplY3QgU2V0XSc7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYW4gZW1wdHkgb2JqZWN0LCBjb2xsZWN0aW9uLCBtYXAsIG9yIHNldC5cbiAqXG4gKiBPYmplY3RzIGFyZSBjb25zaWRlcmVkIGVtcHR5IGlmIHRoZXkgaGF2ZSBubyBvd24gZW51bWVyYWJsZSBzdHJpbmcga2V5ZWRcbiAqIHByb3BlcnRpZXMuXG4gKlxuICogQXJyYXktbGlrZSB2YWx1ZXMgc3VjaCBhcyBgYXJndW1lbnRzYCBvYmplY3RzLCBhcnJheXMsIGJ1ZmZlcnMsIHN0cmluZ3MsIG9yXG4gKiBqUXVlcnktbGlrZSBjb2xsZWN0aW9ucyBhcmUgY29uc2lkZXJlZCBlbXB0eSBpZiB0aGV5IGhhdmUgYSBgbGVuZ3RoYCBvZiBgMGAuXG4gKiBTaW1pbGFybHksIG1hcHMgYW5kIHNldHMgYXJlIGNvbnNpZGVyZWQgZW1wdHkgaWYgdGhleSBoYXZlIGEgYHNpemVgIG9mIGAwYC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBlbXB0eSwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzRW1wdHkobnVsbCk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0VtcHR5KHRydWUpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNFbXB0eSgxKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzRW1wdHkoWzEsIDIsIDNdKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0VtcHR5KHsgJ2EnOiAxIH0pO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNFbXB0eSh2YWx1ZSkge1xuICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmIChpc0FycmF5TGlrZSh2YWx1ZSkgJiZcbiAgICAgIChpc0FycmF5KHZhbHVlKSB8fCB0eXBlb2YgdmFsdWUgPT0gJ3N0cmluZycgfHwgdHlwZW9mIHZhbHVlLnNwbGljZSA9PSAnZnVuY3Rpb24nIHx8XG4gICAgICAgIGlzQnVmZmVyKHZhbHVlKSB8fCBpc1R5cGVkQXJyYXkodmFsdWUpIHx8IGlzQXJndW1lbnRzKHZhbHVlKSkpIHtcbiAgICByZXR1cm4gIXZhbHVlLmxlbmd0aDtcbiAgfVxuICB2YXIgdGFnID0gZ2V0VGFnKHZhbHVlKTtcbiAgaWYgKHRhZyA9PSBtYXBUYWcgfHwgdGFnID09IHNldFRhZykge1xuICAgIHJldHVybiAhdmFsdWUuc2l6ZTtcbiAgfVxuICBpZiAoaXNQcm90b3R5cGUodmFsdWUpKSB7XG4gICAgcmV0dXJuICFiYXNlS2V5cyh2YWx1ZSkubGVuZ3RoO1xuICB9XG4gIGZvciAodmFyIGtleSBpbiB2YWx1ZSkge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCBrZXkpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzRW1wdHk7XG4iLCJ2YXIgYmFzZUdldFRhZyA9IHJlcXVpcmUoJy4vX2Jhc2VHZXRUYWcnKSxcbiAgICBpc09iamVjdCA9IHJlcXVpcmUoJy4vaXNPYmplY3QnKTtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIGFzeW5jVGFnID0gJ1tvYmplY3QgQXN5bmNGdW5jdGlvbl0nLFxuICAgIGZ1bmNUYWcgPSAnW29iamVjdCBGdW5jdGlvbl0nLFxuICAgIGdlblRhZyA9ICdbb2JqZWN0IEdlbmVyYXRvckZ1bmN0aW9uXScsXG4gICAgcHJveHlUYWcgPSAnW29iamVjdCBQcm94eV0nO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgRnVuY3Rpb25gIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIGZ1bmN0aW9uLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNGdW5jdGlvbihfKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzRnVuY3Rpb24oL2FiYy8pO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNGdW5jdGlvbih2YWx1ZSkge1xuICBpZiAoIWlzT2JqZWN0KHZhbHVlKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICAvLyBUaGUgdXNlIG9mIGBPYmplY3QjdG9TdHJpbmdgIGF2b2lkcyBpc3N1ZXMgd2l0aCB0aGUgYHR5cGVvZmAgb3BlcmF0b3JcbiAgLy8gaW4gU2FmYXJpIDkgd2hpY2ggcmV0dXJucyAnb2JqZWN0JyBmb3IgdHlwZWQgYXJyYXlzIGFuZCBvdGhlciBjb25zdHJ1Y3RvcnMuXG4gIHZhciB0YWcgPSBiYXNlR2V0VGFnKHZhbHVlKTtcbiAgcmV0dXJuIHRhZyA9PSBmdW5jVGFnIHx8IHRhZyA9PSBnZW5UYWcgfHwgdGFnID09IGFzeW5jVGFnIHx8IHRhZyA9PSBwcm94eVRhZztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc0Z1bmN0aW9uO1xuIiwiLyoqIFVzZWQgYXMgcmVmZXJlbmNlcyBmb3IgdmFyaW91cyBgTnVtYmVyYCBjb25zdGFudHMuICovXG52YXIgTUFYX1NBRkVfSU5URUdFUiA9IDkwMDcxOTkyNTQ3NDA5OTE7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBhcnJheS1saWtlIGxlbmd0aC5cbiAqXG4gKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgaXMgbG9vc2VseSBiYXNlZCBvblxuICogW2BUb0xlbmd0aGBdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXRvbGVuZ3RoKS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGxlbmd0aCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzTGVuZ3RoKDMpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNMZW5ndGgoTnVtYmVyLk1JTl9WQUxVRSk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNMZW5ndGgoSW5maW5pdHkpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzTGVuZ3RoKCczJyk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0xlbmd0aCh2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09ICdudW1iZXInICYmXG4gICAgdmFsdWUgPiAtMSAmJiB2YWx1ZSAlIDEgPT0gMCAmJiB2YWx1ZSA8PSBNQVhfU0FGRV9JTlRFR0VSO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzTGVuZ3RoO1xuIiwidmFyIGJhc2VJc01hcCA9IHJlcXVpcmUoJy4vX2Jhc2VJc01hcCcpLFxuICAgIGJhc2VVbmFyeSA9IHJlcXVpcmUoJy4vX2Jhc2VVbmFyeScpLFxuICAgIG5vZGVVdGlsID0gcmVxdWlyZSgnLi9fbm9kZVV0aWwnKTtcblxuLyogTm9kZS5qcyBoZWxwZXIgcmVmZXJlbmNlcy4gKi9cbnZhciBub2RlSXNNYXAgPSBub2RlVXRpbCAmJiBub2RlVXRpbC5pc01hcDtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYE1hcGAgb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4zLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgbWFwLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNNYXAobmV3IE1hcCk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc01hcChuZXcgV2Vha01hcCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG52YXIgaXNNYXAgPSBub2RlSXNNYXAgPyBiYXNlVW5hcnkobm9kZUlzTWFwKSA6IGJhc2VJc01hcDtcblxubW9kdWxlLmV4cG9ydHMgPSBpc01hcDtcbiIsIi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgdGhlXG4gKiBbbGFuZ3VhZ2UgdHlwZV0oaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLWVjbWFzY3JpcHQtbGFuZ3VhZ2UtdHlwZXMpXG4gKiBvZiBgT2JqZWN0YC4gKGUuZy4gYXJyYXlzLCBmdW5jdGlvbnMsIG9iamVjdHMsIHJlZ2V4ZXMsIGBuZXcgTnVtYmVyKDApYCwgYW5kIGBuZXcgU3RyaW5nKCcnKWApXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNPYmplY3Qoe30pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KF8ubm9vcCk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdChudWxsKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzT2JqZWN0KHZhbHVlKSB7XG4gIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICByZXR1cm4gdmFsdWUgIT0gbnVsbCAmJiAodHlwZSA9PSAnb2JqZWN0JyB8fCB0eXBlID09ICdmdW5jdGlvbicpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzT2JqZWN0O1xuIiwiLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBvYmplY3QtbGlrZS4gQSB2YWx1ZSBpcyBvYmplY3QtbGlrZSBpZiBpdCdzIG5vdCBgbnVsbGBcbiAqIGFuZCBoYXMgYSBgdHlwZW9mYCByZXN1bHQgb2YgXCJvYmplY3RcIi5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBvYmplY3QtbGlrZSwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZSh7fSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdExpa2UoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZShfLm5vb3ApO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZShudWxsKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzT2JqZWN0TGlrZSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgIT0gbnVsbCAmJiB0eXBlb2YgdmFsdWUgPT0gJ29iamVjdCc7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNPYmplY3RMaWtlO1xuIiwidmFyIGJhc2VHZXRUYWcgPSByZXF1aXJlKCcuL19iYXNlR2V0VGFnJyksXG4gICAgZ2V0UHJvdG90eXBlID0gcmVxdWlyZSgnLi9fZ2V0UHJvdG90eXBlJyksXG4gICAgaXNPYmplY3RMaWtlID0gcmVxdWlyZSgnLi9pc09iamVjdExpa2UnKTtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFRhZyA9ICdbb2JqZWN0IE9iamVjdF0nO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgZnVuY1Byb3RvID0gRnVuY3Rpb24ucHJvdG90eXBlLFxuICAgIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gcmVzb2x2ZSB0aGUgZGVjb21waWxlZCBzb3VyY2Ugb2YgZnVuY3Rpb25zLiAqL1xudmFyIGZ1bmNUb1N0cmluZyA9IGZ1bmNQcm90by50b1N0cmluZztcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqIFVzZWQgdG8gaW5mZXIgdGhlIGBPYmplY3RgIGNvbnN0cnVjdG9yLiAqL1xudmFyIG9iamVjdEN0b3JTdHJpbmcgPSBmdW5jVG9TdHJpbmcuY2FsbChPYmplY3QpO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgcGxhaW4gb2JqZWN0LCB0aGF0IGlzLCBhbiBvYmplY3QgY3JlYXRlZCBieSB0aGVcbiAqIGBPYmplY3RgIGNvbnN0cnVjdG9yIG9yIG9uZSB3aXRoIGEgYFtbUHJvdG90eXBlXV1gIG9mIGBudWxsYC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuOC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHBsYWluIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBmdW5jdGlvbiBGb28oKSB7XG4gKiAgIHRoaXMuYSA9IDE7XG4gKiB9XG4gKlxuICogXy5pc1BsYWluT2JqZWN0KG5ldyBGb28pO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzUGxhaW5PYmplY3QoWzEsIDIsIDNdKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc1BsYWluT2JqZWN0KHsgJ3gnOiAwLCAneSc6IDAgfSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc1BsYWluT2JqZWN0KE9iamVjdC5jcmVhdGUobnVsbCkpO1xuICogLy8gPT4gdHJ1ZVxuICovXG5mdW5jdGlvbiBpc1BsYWluT2JqZWN0KHZhbHVlKSB7XG4gIGlmICghaXNPYmplY3RMaWtlKHZhbHVlKSB8fCBiYXNlR2V0VGFnKHZhbHVlKSAhPSBvYmplY3RUYWcpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIHByb3RvID0gZ2V0UHJvdG90eXBlKHZhbHVlKTtcbiAgaWYgKHByb3RvID09PSBudWxsKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgdmFyIEN0b3IgPSBoYXNPd25Qcm9wZXJ0eS5jYWxsKHByb3RvLCAnY29uc3RydWN0b3InKSAmJiBwcm90by5jb25zdHJ1Y3RvcjtcbiAgcmV0dXJuIHR5cGVvZiBDdG9yID09ICdmdW5jdGlvbicgJiYgQ3RvciBpbnN0YW5jZW9mIEN0b3IgJiZcbiAgICBmdW5jVG9TdHJpbmcuY2FsbChDdG9yKSA9PSBvYmplY3RDdG9yU3RyaW5nO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzUGxhaW5PYmplY3Q7XG4iLCJ2YXIgYmFzZUlzU2V0ID0gcmVxdWlyZSgnLi9fYmFzZUlzU2V0JyksXG4gICAgYmFzZVVuYXJ5ID0gcmVxdWlyZSgnLi9fYmFzZVVuYXJ5JyksXG4gICAgbm9kZVV0aWwgPSByZXF1aXJlKCcuL19ub2RlVXRpbCcpO1xuXG4vKiBOb2RlLmpzIGhlbHBlciByZWZlcmVuY2VzLiAqL1xudmFyIG5vZGVJc1NldCA9IG5vZGVVdGlsICYmIG5vZGVVdGlsLmlzU2V0O1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgU2V0YCBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjMuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBzZXQsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc1NldChuZXcgU2V0KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzU2V0KG5ldyBXZWFrU2V0KTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbnZhciBpc1NldCA9IG5vZGVJc1NldCA/IGJhc2VVbmFyeShub2RlSXNTZXQpIDogYmFzZUlzU2V0O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGlzU2V0O1xuIiwidmFyIGJhc2VHZXRUYWcgPSByZXF1aXJlKCcuL19iYXNlR2V0VGFnJyksXG4gICAgaXNBcnJheSA9IHJlcXVpcmUoJy4vaXNBcnJheScpLFxuICAgIGlzT2JqZWN0TGlrZSA9IHJlcXVpcmUoJy4vaXNPYmplY3RMaWtlJyk7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBzdHJpbmdUYWcgPSAnW29iamVjdCBTdHJpbmddJztcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYFN0cmluZ2AgcHJpbWl0aXZlIG9yIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBtZW1iZXJPZiBfXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHN0cmluZywgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzU3RyaW5nKCdhYmMnKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzU3RyaW5nKDEpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNTdHJpbmcodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnc3RyaW5nJyB8fFxuICAgICghaXNBcnJheSh2YWx1ZSkgJiYgaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBiYXNlR2V0VGFnKHZhbHVlKSA9PSBzdHJpbmdUYWcpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzU3RyaW5nO1xuIiwidmFyIGJhc2VHZXRUYWcgPSByZXF1aXJlKCcuL19iYXNlR2V0VGFnJyksXG4gICAgaXNPYmplY3RMaWtlID0gcmVxdWlyZSgnLi9pc09iamVjdExpa2UnKTtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIHN5bWJvbFRhZyA9ICdbb2JqZWN0IFN5bWJvbF0nO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgU3ltYm9sYCBwcmltaXRpdmUgb3Igb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgc3ltYm9sLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNTeW1ib2woU3ltYm9sLml0ZXJhdG9yKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzU3ltYm9sKCdhYmMnKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzU3ltYm9sKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ3N5bWJvbCcgfHxcbiAgICAoaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBiYXNlR2V0VGFnKHZhbHVlKSA9PSBzeW1ib2xUYWcpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzU3ltYm9sO1xuIiwidmFyIGJhc2VJc1R5cGVkQXJyYXkgPSByZXF1aXJlKCcuL19iYXNlSXNUeXBlZEFycmF5JyksXG4gICAgYmFzZVVuYXJ5ID0gcmVxdWlyZSgnLi9fYmFzZVVuYXJ5JyksXG4gICAgbm9kZVV0aWwgPSByZXF1aXJlKCcuL19ub2RlVXRpbCcpO1xuXG4vKiBOb2RlLmpzIGhlbHBlciByZWZlcmVuY2VzLiAqL1xudmFyIG5vZGVJc1R5cGVkQXJyYXkgPSBub2RlVXRpbCAmJiBub2RlVXRpbC5pc1R5cGVkQXJyYXk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIHR5cGVkIGFycmF5LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMy4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgdHlwZWQgYXJyYXksIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc1R5cGVkQXJyYXkobmV3IFVpbnQ4QXJyYXkpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNUeXBlZEFycmF5KFtdKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbnZhciBpc1R5cGVkQXJyYXkgPSBub2RlSXNUeXBlZEFycmF5ID8gYmFzZVVuYXJ5KG5vZGVJc1R5cGVkQXJyYXkpIDogYmFzZUlzVHlwZWRBcnJheTtcblxubW9kdWxlLmV4cG9ydHMgPSBpc1R5cGVkQXJyYXk7XG4iLCIvKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGB1bmRlZmluZWRgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBzaW5jZSAwLjEuMFxuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGB1bmRlZmluZWRgLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNVbmRlZmluZWQodm9pZCAwKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzVW5kZWZpbmVkKG51bGwpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNVbmRlZmluZWQodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlID09PSB1bmRlZmluZWQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNVbmRlZmluZWQ7XG4iLCJ2YXIgYXJyYXlMaWtlS2V5cyA9IHJlcXVpcmUoJy4vX2FycmF5TGlrZUtleXMnKSxcbiAgICBiYXNlS2V5cyA9IHJlcXVpcmUoJy4vX2Jhc2VLZXlzJyksXG4gICAgaXNBcnJheUxpa2UgPSByZXF1aXJlKCcuL2lzQXJyYXlMaWtlJyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiB0aGUgb3duIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgb2YgYG9iamVjdGAuXG4gKlxuICogKipOb3RlOioqIE5vbi1vYmplY3QgdmFsdWVzIGFyZSBjb2VyY2VkIHRvIG9iamVjdHMuIFNlZSB0aGVcbiAqIFtFUyBzcGVjXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1vYmplY3Qua2V5cylcbiAqIGZvciBtb3JlIGRldGFpbHMuXG4gKlxuICogQHN0YXRpY1xuICogQHNpbmNlIDAuMS4wXG4gKiBAbWVtYmVyT2YgX1xuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAqIEBleGFtcGxlXG4gKlxuICogZnVuY3Rpb24gRm9vKCkge1xuICogICB0aGlzLmEgPSAxO1xuICogICB0aGlzLmIgPSAyO1xuICogfVxuICpcbiAqIEZvby5wcm90b3R5cGUuYyA9IDM7XG4gKlxuICogXy5rZXlzKG5ldyBGb28pO1xuICogLy8gPT4gWydhJywgJ2InXSAoaXRlcmF0aW9uIG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKVxuICpcbiAqIF8ua2V5cygnaGknKTtcbiAqIC8vID0+IFsnMCcsICcxJ11cbiAqL1xuZnVuY3Rpb24ga2V5cyhvYmplY3QpIHtcbiAgcmV0dXJuIGlzQXJyYXlMaWtlKG9iamVjdCkgPyBhcnJheUxpa2VLZXlzKG9iamVjdCkgOiBiYXNlS2V5cyhvYmplY3QpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGtleXM7XG4iLCJ2YXIgYXJyYXlMaWtlS2V5cyA9IHJlcXVpcmUoJy4vX2FycmF5TGlrZUtleXMnKSxcbiAgICBiYXNlS2V5c0luID0gcmVxdWlyZSgnLi9fYmFzZUtleXNJbicpLFxuICAgIGlzQXJyYXlMaWtlID0gcmVxdWlyZSgnLi9pc0FycmF5TGlrZScpO1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIG93biBhbmQgaW5oZXJpdGVkIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgb2YgYG9iamVjdGAuXG4gKlxuICogKipOb3RlOioqIE5vbi1vYmplY3QgdmFsdWVzIGFyZSBjb2VyY2VkIHRvIG9iamVjdHMuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAzLjAuMFxuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAqIEBleGFtcGxlXG4gKlxuICogZnVuY3Rpb24gRm9vKCkge1xuICogICB0aGlzLmEgPSAxO1xuICogICB0aGlzLmIgPSAyO1xuICogfVxuICpcbiAqIEZvby5wcm90b3R5cGUuYyA9IDM7XG4gKlxuICogXy5rZXlzSW4obmV3IEZvbyk7XG4gKiAvLyA9PiBbJ2EnLCAnYicsICdjJ10gKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZClcbiAqL1xuZnVuY3Rpb24ga2V5c0luKG9iamVjdCkge1xuICByZXR1cm4gaXNBcnJheUxpa2Uob2JqZWN0KSA/IGFycmF5TGlrZUtleXMob2JqZWN0LCB0cnVlKSA6IGJhc2VLZXlzSW4ob2JqZWN0KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBrZXlzSW47XG4iLCIvKipcbiAqIEdldHMgdGhlIGxhc3QgZWxlbWVudCBvZiBgYXJyYXlgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBBcnJheVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHF1ZXJ5LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGxhc3QgZWxlbWVudCBvZiBgYXJyYXlgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmxhc3QoWzEsIDIsIDNdKTtcbiAqIC8vID0+IDNcbiAqL1xuZnVuY3Rpb24gbGFzdChhcnJheSkge1xuICB2YXIgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG4gIHJldHVybiBsZW5ndGggPyBhcnJheVtsZW5ndGggLSAxXSA6IHVuZGVmaW5lZDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBsYXN0O1xuIiwidmFyIGFycmF5TWFwID0gcmVxdWlyZSgnLi9fYXJyYXlNYXAnKSxcbiAgICBiYXNlSXRlcmF0ZWUgPSByZXF1aXJlKCcuL19iYXNlSXRlcmF0ZWUnKSxcbiAgICBiYXNlTWFwID0gcmVxdWlyZSgnLi9fYmFzZU1hcCcpLFxuICAgIGlzQXJyYXkgPSByZXF1aXJlKCcuL2lzQXJyYXknKTtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIHZhbHVlcyBieSBydW5uaW5nIGVhY2ggZWxlbWVudCBpbiBgY29sbGVjdGlvbmAgdGhydVxuICogYGl0ZXJhdGVlYC4gVGhlIGl0ZXJhdGVlIGlzIGludm9rZWQgd2l0aCB0aHJlZSBhcmd1bWVudHM6XG4gKiAodmFsdWUsIGluZGV4fGtleSwgY29sbGVjdGlvbikuXG4gKlxuICogTWFueSBsb2Rhc2ggbWV0aG9kcyBhcmUgZ3VhcmRlZCB0byB3b3JrIGFzIGl0ZXJhdGVlcyBmb3IgbWV0aG9kcyBsaWtlXG4gKiBgXy5ldmVyeWAsIGBfLmZpbHRlcmAsIGBfLm1hcGAsIGBfLm1hcFZhbHVlc2AsIGBfLnJlamVjdGAsIGFuZCBgXy5zb21lYC5cbiAqXG4gKiBUaGUgZ3VhcmRlZCBtZXRob2RzIGFyZTpcbiAqIGBhcnlgLCBgY2h1bmtgLCBgY3VycnlgLCBgY3VycnlSaWdodGAsIGBkcm9wYCwgYGRyb3BSaWdodGAsIGBldmVyeWAsXG4gKiBgZmlsbGAsIGBpbnZlcnRgLCBgcGFyc2VJbnRgLCBgcmFuZG9tYCwgYHJhbmdlYCwgYHJhbmdlUmlnaHRgLCBgcmVwZWF0YCxcbiAqIGBzYW1wbGVTaXplYCwgYHNsaWNlYCwgYHNvbWVgLCBgc29ydEJ5YCwgYHNwbGl0YCwgYHRha2VgLCBgdGFrZVJpZ2h0YCxcbiAqIGB0ZW1wbGF0ZWAsIGB0cmltYCwgYHRyaW1FbmRgLCBgdHJpbVN0YXJ0YCwgYW5kIGB3b3Jkc2BcbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBtYXBwZWQgYXJyYXkuXG4gKiBAZXhhbXBsZVxuICpcbiAqIGZ1bmN0aW9uIHNxdWFyZShuKSB7XG4gKiAgIHJldHVybiBuICogbjtcbiAqIH1cbiAqXG4gKiBfLm1hcChbNCwgOF0sIHNxdWFyZSk7XG4gKiAvLyA9PiBbMTYsIDY0XVxuICpcbiAqIF8ubWFwKHsgJ2EnOiA0LCAnYic6IDggfSwgc3F1YXJlKTtcbiAqIC8vID0+IFsxNiwgNjRdIChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpXG4gKlxuICogdmFyIHVzZXJzID0gW1xuICogICB7ICd1c2VyJzogJ2Jhcm5leScgfSxcbiAqICAgeyAndXNlcic6ICdmcmVkJyB9XG4gKiBdO1xuICpcbiAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICogXy5tYXAodXNlcnMsICd1c2VyJyk7XG4gKiAvLyA9PiBbJ2Jhcm5leScsICdmcmVkJ11cbiAqL1xuZnVuY3Rpb24gbWFwKGNvbGxlY3Rpb24sIGl0ZXJhdGVlKSB7XG4gIHZhciBmdW5jID0gaXNBcnJheShjb2xsZWN0aW9uKSA/IGFycmF5TWFwIDogYmFzZU1hcDtcbiAgcmV0dXJuIGZ1bmMoY29sbGVjdGlvbiwgYmFzZUl0ZXJhdGVlKGl0ZXJhdGVlLCAzKSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbWFwO1xuIiwidmFyIGJhc2VBc3NpZ25WYWx1ZSA9IHJlcXVpcmUoJy4vX2Jhc2VBc3NpZ25WYWx1ZScpLFxuICAgIGJhc2VGb3JPd24gPSByZXF1aXJlKCcuL19iYXNlRm9yT3duJyksXG4gICAgYmFzZUl0ZXJhdGVlID0gcmVxdWlyZSgnLi9fYmFzZUl0ZXJhdGVlJyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBvYmplY3Qgd2l0aCB0aGUgc2FtZSBrZXlzIGFzIGBvYmplY3RgIGFuZCB2YWx1ZXMgZ2VuZXJhdGVkXG4gKiBieSBydW5uaW5nIGVhY2ggb3duIGVudW1lcmFibGUgc3RyaW5nIGtleWVkIHByb3BlcnR5IG9mIGBvYmplY3RgIHRocnVcbiAqIGBpdGVyYXRlZWAuIFRoZSBpdGVyYXRlZSBpcyBpbnZva2VkIHdpdGggdGhyZWUgYXJndW1lbnRzOlxuICogKHZhbHVlLCBrZXksIG9iamVjdCkuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAyLjQuMFxuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IG1hcHBlZCBvYmplY3QuXG4gKiBAc2VlIF8ubWFwS2V5c1xuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgdXNlcnMgPSB7XG4gKiAgICdmcmVkJzogICAgeyAndXNlcic6ICdmcmVkJywgICAgJ2FnZSc6IDQwIH0sXG4gKiAgICdwZWJibGVzJzogeyAndXNlcic6ICdwZWJibGVzJywgJ2FnZSc6IDEgfVxuICogfTtcbiAqXG4gKiBfLm1hcFZhbHVlcyh1c2VycywgZnVuY3Rpb24obykgeyByZXR1cm4gby5hZ2U7IH0pO1xuICogLy8gPT4geyAnZnJlZCc6IDQwLCAncGViYmxlcyc6IDEgfSAoaXRlcmF0aW9uIG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKVxuICpcbiAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICogXy5tYXBWYWx1ZXModXNlcnMsICdhZ2UnKTtcbiAqIC8vID0+IHsgJ2ZyZWQnOiA0MCwgJ3BlYmJsZXMnOiAxIH0gKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZClcbiAqL1xuZnVuY3Rpb24gbWFwVmFsdWVzKG9iamVjdCwgaXRlcmF0ZWUpIHtcbiAgdmFyIHJlc3VsdCA9IHt9O1xuICBpdGVyYXRlZSA9IGJhc2VJdGVyYXRlZShpdGVyYXRlZSwgMyk7XG5cbiAgYmFzZUZvck93bihvYmplY3QsIGZ1bmN0aW9uKHZhbHVlLCBrZXksIG9iamVjdCkge1xuICAgIGJhc2VBc3NpZ25WYWx1ZShyZXN1bHQsIGtleSwgaXRlcmF0ZWUodmFsdWUsIGtleSwgb2JqZWN0KSk7XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG1hcFZhbHVlcztcbiIsInZhciBiYXNlRXh0cmVtdW0gPSByZXF1aXJlKCcuL19iYXNlRXh0cmVtdW0nKSxcbiAgICBiYXNlR3QgPSByZXF1aXJlKCcuL19iYXNlR3QnKSxcbiAgICBpZGVudGl0eSA9IHJlcXVpcmUoJy4vaWRlbnRpdHknKTtcblxuLyoqXG4gKiBDb21wdXRlcyB0aGUgbWF4aW11bSB2YWx1ZSBvZiBgYXJyYXlgLiBJZiBgYXJyYXlgIGlzIGVtcHR5IG9yIGZhbHNleSxcbiAqIGB1bmRlZmluZWRgIGlzIHJldHVybmVkLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBzaW5jZSAwLjEuMFxuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBNYXRoXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIG1heGltdW0gdmFsdWUuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8ubWF4KFs0LCAyLCA4LCA2XSk7XG4gKiAvLyA9PiA4XG4gKlxuICogXy5tYXgoW10pO1xuICogLy8gPT4gdW5kZWZpbmVkXG4gKi9cbmZ1bmN0aW9uIG1heChhcnJheSkge1xuICByZXR1cm4gKGFycmF5ICYmIGFycmF5Lmxlbmd0aClcbiAgICA/IGJhc2VFeHRyZW11bShhcnJheSwgaWRlbnRpdHksIGJhc2VHdClcbiAgICA6IHVuZGVmaW5lZDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBtYXg7XG4iLCJ2YXIgTWFwQ2FjaGUgPSByZXF1aXJlKCcuL19NYXBDYWNoZScpO1xuXG4vKiogRXJyb3IgbWVzc2FnZSBjb25zdGFudHMuICovXG52YXIgRlVOQ19FUlJPUl9URVhUID0gJ0V4cGVjdGVkIGEgZnVuY3Rpb24nO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IG1lbW9pemVzIHRoZSByZXN1bHQgb2YgYGZ1bmNgLiBJZiBgcmVzb2x2ZXJgIGlzXG4gKiBwcm92aWRlZCwgaXQgZGV0ZXJtaW5lcyB0aGUgY2FjaGUga2V5IGZvciBzdG9yaW5nIHRoZSByZXN1bHQgYmFzZWQgb24gdGhlXG4gKiBhcmd1bWVudHMgcHJvdmlkZWQgdG8gdGhlIG1lbW9pemVkIGZ1bmN0aW9uLiBCeSBkZWZhdWx0LCB0aGUgZmlyc3QgYXJndW1lbnRcbiAqIHByb3ZpZGVkIHRvIHRoZSBtZW1vaXplZCBmdW5jdGlvbiBpcyB1c2VkIGFzIHRoZSBtYXAgY2FjaGUga2V5LiBUaGUgYGZ1bmNgXG4gKiBpcyBpbnZva2VkIHdpdGggdGhlIGB0aGlzYCBiaW5kaW5nIG9mIHRoZSBtZW1vaXplZCBmdW5jdGlvbi5cbiAqXG4gKiAqKk5vdGU6KiogVGhlIGNhY2hlIGlzIGV4cG9zZWQgYXMgdGhlIGBjYWNoZWAgcHJvcGVydHkgb24gdGhlIG1lbW9pemVkXG4gKiBmdW5jdGlvbi4gSXRzIGNyZWF0aW9uIG1heSBiZSBjdXN0b21pemVkIGJ5IHJlcGxhY2luZyB0aGUgYF8ubWVtb2l6ZS5DYWNoZWBcbiAqIGNvbnN0cnVjdG9yIHdpdGggb25lIHdob3NlIGluc3RhbmNlcyBpbXBsZW1lbnQgdGhlXG4gKiBbYE1hcGBdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXByb3BlcnRpZXMtb2YtdGhlLW1hcC1wcm90b3R5cGUtb2JqZWN0KVxuICogbWV0aG9kIGludGVyZmFjZSBvZiBgY2xlYXJgLCBgZGVsZXRlYCwgYGdldGAsIGBoYXNgLCBhbmQgYHNldGAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBoYXZlIGl0cyBvdXRwdXQgbWVtb2l6ZWQuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcmVzb2x2ZXJdIFRoZSBmdW5jdGlvbiB0byByZXNvbHZlIHRoZSBjYWNoZSBrZXkuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBtZW1vaXplZCBmdW5jdGlvbi5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdCA9IHsgJ2EnOiAxLCAnYic6IDIgfTtcbiAqIHZhciBvdGhlciA9IHsgJ2MnOiAzLCAnZCc6IDQgfTtcbiAqXG4gKiB2YXIgdmFsdWVzID0gXy5tZW1vaXplKF8udmFsdWVzKTtcbiAqIHZhbHVlcyhvYmplY3QpO1xuICogLy8gPT4gWzEsIDJdXG4gKlxuICogdmFsdWVzKG90aGVyKTtcbiAqIC8vID0+IFszLCA0XVxuICpcbiAqIG9iamVjdC5hID0gMjtcbiAqIHZhbHVlcyhvYmplY3QpO1xuICogLy8gPT4gWzEsIDJdXG4gKlxuICogLy8gTW9kaWZ5IHRoZSByZXN1bHQgY2FjaGUuXG4gKiB2YWx1ZXMuY2FjaGUuc2V0KG9iamVjdCwgWydhJywgJ2InXSk7XG4gKiB2YWx1ZXMob2JqZWN0KTtcbiAqIC8vID0+IFsnYScsICdiJ11cbiAqXG4gKiAvLyBSZXBsYWNlIGBfLm1lbW9pemUuQ2FjaGVgLlxuICogXy5tZW1vaXplLkNhY2hlID0gV2Vha01hcDtcbiAqL1xuZnVuY3Rpb24gbWVtb2l6ZShmdW5jLCByZXNvbHZlcikge1xuICBpZiAodHlwZW9mIGZ1bmMgIT0gJ2Z1bmN0aW9uJyB8fCAocmVzb2x2ZXIgIT0gbnVsbCAmJiB0eXBlb2YgcmVzb2x2ZXIgIT0gJ2Z1bmN0aW9uJykpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKEZVTkNfRVJST1JfVEVYVCk7XG4gIH1cbiAgdmFyIG1lbW9pemVkID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGFyZ3MgPSBhcmd1bWVudHMsXG4gICAgICAgIGtleSA9IHJlc29sdmVyID8gcmVzb2x2ZXIuYXBwbHkodGhpcywgYXJncykgOiBhcmdzWzBdLFxuICAgICAgICBjYWNoZSA9IG1lbW9pemVkLmNhY2hlO1xuXG4gICAgaWYgKGNhY2hlLmhhcyhrZXkpKSB7XG4gICAgICByZXR1cm4gY2FjaGUuZ2V0KGtleSk7XG4gICAgfVxuICAgIHZhciByZXN1bHQgPSBmdW5jLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgIG1lbW9pemVkLmNhY2hlID0gY2FjaGUuc2V0KGtleSwgcmVzdWx0KSB8fCBjYWNoZTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuICBtZW1vaXplZC5jYWNoZSA9IG5ldyAobWVtb2l6ZS5DYWNoZSB8fCBNYXBDYWNoZSk7XG4gIHJldHVybiBtZW1vaXplZDtcbn1cblxuLy8gRXhwb3NlIGBNYXBDYWNoZWAuXG5tZW1vaXplLkNhY2hlID0gTWFwQ2FjaGU7XG5cbm1vZHVsZS5leHBvcnRzID0gbWVtb2l6ZTtcbiIsInZhciBiYXNlTWVyZ2UgPSByZXF1aXJlKCcuL19iYXNlTWVyZ2UnKSxcbiAgICBjcmVhdGVBc3NpZ25lciA9IHJlcXVpcmUoJy4vX2NyZWF0ZUFzc2lnbmVyJyk7XG5cbi8qKlxuICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5hc3NpZ25gIGV4Y2VwdCB0aGF0IGl0IHJlY3Vyc2l2ZWx5IG1lcmdlcyBvd24gYW5kXG4gKiBpbmhlcml0ZWQgZW51bWVyYWJsZSBzdHJpbmcga2V5ZWQgcHJvcGVydGllcyBvZiBzb3VyY2Ugb2JqZWN0cyBpbnRvIHRoZVxuICogZGVzdGluYXRpb24gb2JqZWN0LiBTb3VyY2UgcHJvcGVydGllcyB0aGF0IHJlc29sdmUgdG8gYHVuZGVmaW5lZGAgYXJlXG4gKiBza2lwcGVkIGlmIGEgZGVzdGluYXRpb24gdmFsdWUgZXhpc3RzLiBBcnJheSBhbmQgcGxhaW4gb2JqZWN0IHByb3BlcnRpZXNcbiAqIGFyZSBtZXJnZWQgcmVjdXJzaXZlbHkuIE90aGVyIG9iamVjdHMgYW5kIHZhbHVlIHR5cGVzIGFyZSBvdmVycmlkZGVuIGJ5XG4gKiBhc3NpZ25tZW50LiBTb3VyY2Ugb2JqZWN0cyBhcmUgYXBwbGllZCBmcm9tIGxlZnQgdG8gcmlnaHQuIFN1YnNlcXVlbnRcbiAqIHNvdXJjZXMgb3ZlcndyaXRlIHByb3BlcnR5IGFzc2lnbm1lbnRzIG9mIHByZXZpb3VzIHNvdXJjZXMuXG4gKlxuICogKipOb3RlOioqIFRoaXMgbWV0aG9kIG11dGF0ZXMgYG9iamVjdGAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjUuMFxuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICogQHBhcmFtIHsuLi5PYmplY3R9IFtzb3VyY2VzXSBUaGUgc291cmNlIG9iamVjdHMuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0ID0ge1xuICogICAnYSc6IFt7ICdiJzogMiB9LCB7ICdkJzogNCB9XVxuICogfTtcbiAqXG4gKiB2YXIgb3RoZXIgPSB7XG4gKiAgICdhJzogW3sgJ2MnOiAzIH0sIHsgJ2UnOiA1IH1dXG4gKiB9O1xuICpcbiAqIF8ubWVyZ2Uob2JqZWN0LCBvdGhlcik7XG4gKiAvLyA9PiB7ICdhJzogW3sgJ2InOiAyLCAnYyc6IDMgfSwgeyAnZCc6IDQsICdlJzogNSB9XSB9XG4gKi9cbnZhciBtZXJnZSA9IGNyZWF0ZUFzc2lnbmVyKGZ1bmN0aW9uKG9iamVjdCwgc291cmNlLCBzcmNJbmRleCkge1xuICBiYXNlTWVyZ2Uob2JqZWN0LCBzb3VyY2UsIHNyY0luZGV4KTtcbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IG1lcmdlO1xuIiwidmFyIGJhc2VFeHRyZW11bSA9IHJlcXVpcmUoJy4vX2Jhc2VFeHRyZW11bScpLFxuICAgIGJhc2VMdCA9IHJlcXVpcmUoJy4vX2Jhc2VMdCcpLFxuICAgIGlkZW50aXR5ID0gcmVxdWlyZSgnLi9pZGVudGl0eScpO1xuXG4vKipcbiAqIENvbXB1dGVzIHRoZSBtaW5pbXVtIHZhbHVlIG9mIGBhcnJheWAuIElmIGBhcnJheWAgaXMgZW1wdHkgb3IgZmFsc2V5LFxuICogYHVuZGVmaW5lZGAgaXMgcmV0dXJuZWQuXG4gKlxuICogQHN0YXRpY1xuICogQHNpbmNlIDAuMS4wXG4gKiBAbWVtYmVyT2YgX1xuICogQGNhdGVnb3J5IE1hdGhcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgbWluaW11bSB2YWx1ZS5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5taW4oWzQsIDIsIDgsIDZdKTtcbiAqIC8vID0+IDJcbiAqXG4gKiBfLm1pbihbXSk7XG4gKiAvLyA9PiB1bmRlZmluZWRcbiAqL1xuZnVuY3Rpb24gbWluKGFycmF5KSB7XG4gIHJldHVybiAoYXJyYXkgJiYgYXJyYXkubGVuZ3RoKVxuICAgID8gYmFzZUV4dHJlbXVtKGFycmF5LCBpZGVudGl0eSwgYmFzZUx0KVxuICAgIDogdW5kZWZpbmVkO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG1pbjtcbiIsInZhciBiYXNlRXh0cmVtdW0gPSByZXF1aXJlKCcuL19iYXNlRXh0cmVtdW0nKSxcbiAgICBiYXNlSXRlcmF0ZWUgPSByZXF1aXJlKCcuL19iYXNlSXRlcmF0ZWUnKSxcbiAgICBiYXNlTHQgPSByZXF1aXJlKCcuL19iYXNlTHQnKTtcblxuLyoqXG4gKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLm1pbmAgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyBgaXRlcmF0ZWVgIHdoaWNoIGlzXG4gKiBpbnZva2VkIGZvciBlYWNoIGVsZW1lbnQgaW4gYGFycmF5YCB0byBnZW5lcmF0ZSB0aGUgY3JpdGVyaW9uIGJ5IHdoaWNoXG4gKiB0aGUgdmFsdWUgaXMgcmFua2VkLiBUaGUgaXRlcmF0ZWUgaXMgaW52b2tlZCB3aXRoIG9uZSBhcmd1bWVudDogKHZhbHVlKS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTWF0aFxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgaXRlcmF0ZWUgaW52b2tlZCBwZXIgZWxlbWVudC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBtaW5pbXVtIHZhbHVlLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0cyA9IFt7ICduJzogMSB9LCB7ICduJzogMiB9XTtcbiAqXG4gKiBfLm1pbkJ5KG9iamVjdHMsIGZ1bmN0aW9uKG8pIHsgcmV0dXJuIG8ubjsgfSk7XG4gKiAvLyA9PiB7ICduJzogMSB9XG4gKlxuICogLy8gVGhlIGBfLnByb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gKiBfLm1pbkJ5KG9iamVjdHMsICduJyk7XG4gKiAvLyA9PiB7ICduJzogMSB9XG4gKi9cbmZ1bmN0aW9uIG1pbkJ5KGFycmF5LCBpdGVyYXRlZSkge1xuICByZXR1cm4gKGFycmF5ICYmIGFycmF5Lmxlbmd0aClcbiAgICA/IGJhc2VFeHRyZW11bShhcnJheSwgYmFzZUl0ZXJhdGVlKGl0ZXJhdGVlLCAyKSwgYmFzZUx0KVxuICAgIDogdW5kZWZpbmVkO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG1pbkJ5O1xuIiwiLyoqXG4gKiBUaGlzIG1ldGhvZCByZXR1cm5zIGB1bmRlZmluZWRgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMi4zLjBcbiAqIEBjYXRlZ29yeSBVdGlsXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8udGltZXMoMiwgXy5ub29wKTtcbiAqIC8vID0+IFt1bmRlZmluZWQsIHVuZGVmaW5lZF1cbiAqL1xuZnVuY3Rpb24gbm9vcCgpIHtcbiAgLy8gTm8gb3BlcmF0aW9uIHBlcmZvcm1lZC5cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBub29wO1xuIiwidmFyIHJvb3QgPSByZXF1aXJlKCcuL19yb290Jyk7XG5cbi8qKlxuICogR2V0cyB0aGUgdGltZXN0YW1wIG9mIHRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHRoYXQgaGF2ZSBlbGFwc2VkIHNpbmNlXG4gKiB0aGUgVW5peCBlcG9jaCAoMSBKYW51YXJ5IDE5NzAgMDA6MDA6MDAgVVRDKS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDIuNC4wXG4gKiBAY2F0ZWdvcnkgRGF0ZVxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgdGltZXN0YW1wLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmRlZmVyKGZ1bmN0aW9uKHN0YW1wKSB7XG4gKiAgIGNvbnNvbGUubG9nKF8ubm93KCkgLSBzdGFtcCk7XG4gKiB9LCBfLm5vdygpKTtcbiAqIC8vID0+IExvZ3MgdGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgaXQgdG9vayBmb3IgdGhlIGRlZmVycmVkIGludm9jYXRpb24uXG4gKi9cbnZhciBub3cgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHJvb3QuRGF0ZS5ub3coKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gbm93O1xuIiwidmFyIGJhc2VQaWNrID0gcmVxdWlyZSgnLi9fYmFzZVBpY2snKSxcbiAgICBmbGF0UmVzdCA9IHJlcXVpcmUoJy4vX2ZsYXRSZXN0Jyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBvYmplY3QgY29tcG9zZWQgb2YgdGhlIHBpY2tlZCBgb2JqZWN0YCBwcm9wZXJ0aWVzLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBzaW5jZSAwLjEuMFxuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIHNvdXJjZSBvYmplY3QuXG4gKiBAcGFyYW0gey4uLihzdHJpbmd8c3RyaW5nW10pfSBbcGF0aHNdIFRoZSBwcm9wZXJ0eSBwYXRocyB0byBwaWNrLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IG9iamVjdC5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdCA9IHsgJ2EnOiAxLCAnYic6ICcyJywgJ2MnOiAzIH07XG4gKlxuICogXy5waWNrKG9iamVjdCwgWydhJywgJ2MnXSk7XG4gKiAvLyA9PiB7ICdhJzogMSwgJ2MnOiAzIH1cbiAqL1xudmFyIHBpY2sgPSBmbGF0UmVzdChmdW5jdGlvbihvYmplY3QsIHBhdGhzKSB7XG4gIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IHt9IDogYmFzZVBpY2sob2JqZWN0LCBwYXRocyk7XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBwaWNrO1xuIiwidmFyIGJhc2VQcm9wZXJ0eSA9IHJlcXVpcmUoJy4vX2Jhc2VQcm9wZXJ0eScpLFxuICAgIGJhc2VQcm9wZXJ0eURlZXAgPSByZXF1aXJlKCcuL19iYXNlUHJvcGVydHlEZWVwJyksXG4gICAgaXNLZXkgPSByZXF1aXJlKCcuL19pc0tleScpLFxuICAgIHRvS2V5ID0gcmVxdWlyZSgnLi9fdG9LZXknKTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRoZSB2YWx1ZSBhdCBgcGF0aGAgb2YgYSBnaXZlbiBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAyLjQuMFxuICogQGNhdGVnb3J5IFV0aWxcbiAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBhY2Nlc3NvciBmdW5jdGlvbi5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdHMgPSBbXG4gKiAgIHsgJ2EnOiB7ICdiJzogMiB9IH0sXG4gKiAgIHsgJ2EnOiB7ICdiJzogMSB9IH1cbiAqIF07XG4gKlxuICogXy5tYXAob2JqZWN0cywgXy5wcm9wZXJ0eSgnYS5iJykpO1xuICogLy8gPT4gWzIsIDFdXG4gKlxuICogXy5tYXAoXy5zb3J0Qnkob2JqZWN0cywgXy5wcm9wZXJ0eShbJ2EnLCAnYiddKSksICdhLmInKTtcbiAqIC8vID0+IFsxLCAyXVxuICovXG5mdW5jdGlvbiBwcm9wZXJ0eShwYXRoKSB7XG4gIHJldHVybiBpc0tleShwYXRoKSA/IGJhc2VQcm9wZXJ0eSh0b0tleShwYXRoKSkgOiBiYXNlUHJvcGVydHlEZWVwKHBhdGgpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHByb3BlcnR5O1xuIiwidmFyIGNyZWF0ZVJhbmdlID0gcmVxdWlyZSgnLi9fY3JlYXRlUmFuZ2UnKTtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIG51bWJlcnMgKHBvc2l0aXZlIGFuZC9vciBuZWdhdGl2ZSkgcHJvZ3Jlc3NpbmcgZnJvbVxuICogYHN0YXJ0YCB1cCB0bywgYnV0IG5vdCBpbmNsdWRpbmcsIGBlbmRgLiBBIHN0ZXAgb2YgYC0xYCBpcyB1c2VkIGlmIGEgbmVnYXRpdmVcbiAqIGBzdGFydGAgaXMgc3BlY2lmaWVkIHdpdGhvdXQgYW4gYGVuZGAgb3IgYHN0ZXBgLiBJZiBgZW5kYCBpcyBub3Qgc3BlY2lmaWVkLFxuICogaXQncyBzZXQgdG8gYHN0YXJ0YCB3aXRoIGBzdGFydGAgdGhlbiBzZXQgdG8gYDBgLlxuICpcbiAqICoqTm90ZToqKiBKYXZhU2NyaXB0IGZvbGxvd3MgdGhlIElFRUUtNzU0IHN0YW5kYXJkIGZvciByZXNvbHZpbmdcbiAqIGZsb2F0aW5nLXBvaW50IHZhbHVlcyB3aGljaCBjYW4gcHJvZHVjZSB1bmV4cGVjdGVkIHJlc3VsdHMuXG4gKlxuICogQHN0YXRpY1xuICogQHNpbmNlIDAuMS4wXG4gKiBAbWVtYmVyT2YgX1xuICogQGNhdGVnb3J5IFV0aWxcbiAqIEBwYXJhbSB7bnVtYmVyfSBbc3RhcnQ9MF0gVGhlIHN0YXJ0IG9mIHRoZSByYW5nZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBlbmQgVGhlIGVuZCBvZiB0aGUgcmFuZ2UuXG4gKiBAcGFyYW0ge251bWJlcn0gW3N0ZXA9MV0gVGhlIHZhbHVlIHRvIGluY3JlbWVudCBvciBkZWNyZW1lbnQgYnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHJhbmdlIG9mIG51bWJlcnMuXG4gKiBAc2VlIF8uaW5SYW5nZSwgXy5yYW5nZVJpZ2h0XG4gKiBAZXhhbXBsZVxuICpcbiAqIF8ucmFuZ2UoNCk7XG4gKiAvLyA9PiBbMCwgMSwgMiwgM11cbiAqXG4gKiBfLnJhbmdlKC00KTtcbiAqIC8vID0+IFswLCAtMSwgLTIsIC0zXVxuICpcbiAqIF8ucmFuZ2UoMSwgNSk7XG4gKiAvLyA9PiBbMSwgMiwgMywgNF1cbiAqXG4gKiBfLnJhbmdlKDAsIDIwLCA1KTtcbiAqIC8vID0+IFswLCA1LCAxMCwgMTVdXG4gKlxuICogXy5yYW5nZSgwLCAtNCwgLTEpO1xuICogLy8gPT4gWzAsIC0xLCAtMiwgLTNdXG4gKlxuICogXy5yYW5nZSgxLCA0LCAwKTtcbiAqIC8vID0+IFsxLCAxLCAxXVxuICpcbiAqIF8ucmFuZ2UoMCk7XG4gKiAvLyA9PiBbXVxuICovXG52YXIgcmFuZ2UgPSBjcmVhdGVSYW5nZSgpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJhbmdlO1xuIiwidmFyIGFycmF5UmVkdWNlID0gcmVxdWlyZSgnLi9fYXJyYXlSZWR1Y2UnKSxcbiAgICBiYXNlRWFjaCA9IHJlcXVpcmUoJy4vX2Jhc2VFYWNoJyksXG4gICAgYmFzZUl0ZXJhdGVlID0gcmVxdWlyZSgnLi9fYmFzZUl0ZXJhdGVlJyksXG4gICAgYmFzZVJlZHVjZSA9IHJlcXVpcmUoJy4vX2Jhc2VSZWR1Y2UnKSxcbiAgICBpc0FycmF5ID0gcmVxdWlyZSgnLi9pc0FycmF5Jyk7XG5cbi8qKlxuICogUmVkdWNlcyBgY29sbGVjdGlvbmAgdG8gYSB2YWx1ZSB3aGljaCBpcyB0aGUgYWNjdW11bGF0ZWQgcmVzdWx0IG9mIHJ1bm5pbmdcbiAqIGVhY2ggZWxlbWVudCBpbiBgY29sbGVjdGlvbmAgdGhydSBgaXRlcmF0ZWVgLCB3aGVyZSBlYWNoIHN1Y2Nlc3NpdmVcbiAqIGludm9jYXRpb24gaXMgc3VwcGxpZWQgdGhlIHJldHVybiB2YWx1ZSBvZiB0aGUgcHJldmlvdXMuIElmIGBhY2N1bXVsYXRvcmBcbiAqIGlzIG5vdCBnaXZlbiwgdGhlIGZpcnN0IGVsZW1lbnQgb2YgYGNvbGxlY3Rpb25gIGlzIHVzZWQgYXMgdGhlIGluaXRpYWxcbiAqIHZhbHVlLiBUaGUgaXRlcmF0ZWUgaXMgaW52b2tlZCB3aXRoIGZvdXIgYXJndW1lbnRzOlxuICogKGFjY3VtdWxhdG9yLCB2YWx1ZSwgaW5kZXh8a2V5LCBjb2xsZWN0aW9uKS5cbiAqXG4gKiBNYW55IGxvZGFzaCBtZXRob2RzIGFyZSBndWFyZGVkIHRvIHdvcmsgYXMgaXRlcmF0ZWVzIGZvciBtZXRob2RzIGxpa2VcbiAqIGBfLnJlZHVjZWAsIGBfLnJlZHVjZVJpZ2h0YCwgYW5kIGBfLnRyYW5zZm9ybWAuXG4gKlxuICogVGhlIGd1YXJkZWQgbWV0aG9kcyBhcmU6XG4gKiBgYXNzaWduYCwgYGRlZmF1bHRzYCwgYGRlZmF1bHRzRGVlcGAsIGBpbmNsdWRlc2AsIGBtZXJnZWAsIGBvcmRlckJ5YCxcbiAqIGFuZCBgc29ydEJ5YFxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEBwYXJhbSB7Kn0gW2FjY3VtdWxhdG9yXSBUaGUgaW5pdGlhbCB2YWx1ZS5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBhY2N1bXVsYXRlZCB2YWx1ZS5cbiAqIEBzZWUgXy5yZWR1Y2VSaWdodFxuICogQGV4YW1wbGVcbiAqXG4gKiBfLnJlZHVjZShbMSwgMl0sIGZ1bmN0aW9uKHN1bSwgbikge1xuICogICByZXR1cm4gc3VtICsgbjtcbiAqIH0sIDApO1xuICogLy8gPT4gM1xuICpcbiAqIF8ucmVkdWNlKHsgJ2EnOiAxLCAnYic6IDIsICdjJzogMSB9LCBmdW5jdGlvbihyZXN1bHQsIHZhbHVlLCBrZXkpIHtcbiAqICAgKHJlc3VsdFt2YWx1ZV0gfHwgKHJlc3VsdFt2YWx1ZV0gPSBbXSkpLnB1c2goa2V5KTtcbiAqICAgcmV0dXJuIHJlc3VsdDtcbiAqIH0sIHt9KTtcbiAqIC8vID0+IHsgJzEnOiBbJ2EnLCAnYyddLCAnMic6IFsnYiddIH0gKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZClcbiAqL1xuZnVuY3Rpb24gcmVkdWNlKGNvbGxlY3Rpb24sIGl0ZXJhdGVlLCBhY2N1bXVsYXRvcikge1xuICB2YXIgZnVuYyA9IGlzQXJyYXkoY29sbGVjdGlvbikgPyBhcnJheVJlZHVjZSA6IGJhc2VSZWR1Y2UsXG4gICAgICBpbml0QWNjdW0gPSBhcmd1bWVudHMubGVuZ3RoIDwgMztcblxuICByZXR1cm4gZnVuYyhjb2xsZWN0aW9uLCBiYXNlSXRlcmF0ZWUoaXRlcmF0ZWUsIDQpLCBhY2N1bXVsYXRvciwgaW5pdEFjY3VtLCBiYXNlRWFjaCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gcmVkdWNlO1xuIiwidmFyIGJhc2VLZXlzID0gcmVxdWlyZSgnLi9fYmFzZUtleXMnKSxcbiAgICBnZXRUYWcgPSByZXF1aXJlKCcuL19nZXRUYWcnKSxcbiAgICBpc0FycmF5TGlrZSA9IHJlcXVpcmUoJy4vaXNBcnJheUxpa2UnKSxcbiAgICBpc1N0cmluZyA9IHJlcXVpcmUoJy4vaXNTdHJpbmcnKSxcbiAgICBzdHJpbmdTaXplID0gcmVxdWlyZSgnLi9fc3RyaW5nU2l6ZScpO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgbWFwVGFnID0gJ1tvYmplY3QgTWFwXScsXG4gICAgc2V0VGFnID0gJ1tvYmplY3QgU2V0XSc7XG5cbi8qKlxuICogR2V0cyB0aGUgc2l6ZSBvZiBgY29sbGVjdGlvbmAgYnkgcmV0dXJuaW5nIGl0cyBsZW5ndGggZm9yIGFycmF5LWxpa2VcbiAqIHZhbHVlcyBvciB0aGUgbnVtYmVyIG9mIG93biBlbnVtZXJhYmxlIHN0cmluZyBrZXllZCBwcm9wZXJ0aWVzIGZvciBvYmplY3RzLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gKiBAcGFyYW0ge0FycmF5fE9iamVjdHxzdHJpbmd9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaW5zcGVjdC5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGNvbGxlY3Rpb24gc2l6ZS5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5zaXplKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiAzXG4gKlxuICogXy5zaXplKHsgJ2EnOiAxLCAnYic6IDIgfSk7XG4gKiAvLyA9PiAyXG4gKlxuICogXy5zaXplKCdwZWJibGVzJyk7XG4gKiAvLyA9PiA3XG4gKi9cbmZ1bmN0aW9uIHNpemUoY29sbGVjdGlvbikge1xuICBpZiAoY29sbGVjdGlvbiA9PSBudWxsKSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cbiAgaWYgKGlzQXJyYXlMaWtlKGNvbGxlY3Rpb24pKSB7XG4gICAgcmV0dXJuIGlzU3RyaW5nKGNvbGxlY3Rpb24pID8gc3RyaW5nU2l6ZShjb2xsZWN0aW9uKSA6IGNvbGxlY3Rpb24ubGVuZ3RoO1xuICB9XG4gIHZhciB0YWcgPSBnZXRUYWcoY29sbGVjdGlvbik7XG4gIGlmICh0YWcgPT0gbWFwVGFnIHx8IHRhZyA9PSBzZXRUYWcpIHtcbiAgICByZXR1cm4gY29sbGVjdGlvbi5zaXplO1xuICB9XG4gIHJldHVybiBiYXNlS2V5cyhjb2xsZWN0aW9uKS5sZW5ndGg7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc2l6ZTtcbiIsInZhciBiYXNlRmxhdHRlbiA9IHJlcXVpcmUoJy4vX2Jhc2VGbGF0dGVuJyksXG4gICAgYmFzZU9yZGVyQnkgPSByZXF1aXJlKCcuL19iYXNlT3JkZXJCeScpLFxuICAgIGJhc2VSZXN0ID0gcmVxdWlyZSgnLi9fYmFzZVJlc3QnKSxcbiAgICBpc0l0ZXJhdGVlQ2FsbCA9IHJlcXVpcmUoJy4vX2lzSXRlcmF0ZWVDYWxsJyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiBlbGVtZW50cywgc29ydGVkIGluIGFzY2VuZGluZyBvcmRlciBieSB0aGUgcmVzdWx0cyBvZlxuICogcnVubmluZyBlYWNoIGVsZW1lbnQgaW4gYSBjb2xsZWN0aW9uIHRocnUgZWFjaCBpdGVyYXRlZS4gVGhpcyBtZXRob2RcbiAqIHBlcmZvcm1zIGEgc3RhYmxlIHNvcnQsIHRoYXQgaXMsIGl0IHByZXNlcnZlcyB0aGUgb3JpZ2luYWwgc29ydCBvcmRlciBvZlxuICogZXF1YWwgZWxlbWVudHMuIFRoZSBpdGVyYXRlZXMgYXJlIGludm9rZWQgd2l0aCBvbmUgYXJndW1lbnQ6ICh2YWx1ZSkuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7Li4uKEZ1bmN0aW9ufEZ1bmN0aW9uW10pfSBbaXRlcmF0ZWVzPVtfLmlkZW50aXR5XV1cbiAqICBUaGUgaXRlcmF0ZWVzIHRvIHNvcnQgYnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBzb3J0ZWQgYXJyYXkuXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciB1c2VycyA9IFtcbiAqICAgeyAndXNlcic6ICdmcmVkJywgICAnYWdlJzogNDggfSxcbiAqICAgeyAndXNlcic6ICdiYXJuZXknLCAnYWdlJzogMzYgfSxcbiAqICAgeyAndXNlcic6ICdmcmVkJywgICAnYWdlJzogMzAgfSxcbiAqICAgeyAndXNlcic6ICdiYXJuZXknLCAnYWdlJzogMzQgfVxuICogXTtcbiAqXG4gKiBfLnNvcnRCeSh1c2VycywgW2Z1bmN0aW9uKG8pIHsgcmV0dXJuIG8udXNlcjsgfV0pO1xuICogLy8gPT4gb2JqZWN0cyBmb3IgW1snYmFybmV5JywgMzZdLCBbJ2Jhcm5leScsIDM0XSwgWydmcmVkJywgNDhdLCBbJ2ZyZWQnLCAzMF1dXG4gKlxuICogXy5zb3J0QnkodXNlcnMsIFsndXNlcicsICdhZ2UnXSk7XG4gKiAvLyA9PiBvYmplY3RzIGZvciBbWydiYXJuZXknLCAzNF0sIFsnYmFybmV5JywgMzZdLCBbJ2ZyZWQnLCAzMF0sIFsnZnJlZCcsIDQ4XV1cbiAqL1xudmFyIHNvcnRCeSA9IGJhc2VSZXN0KGZ1bmN0aW9uKGNvbGxlY3Rpb24sIGl0ZXJhdGVlcykge1xuICBpZiAoY29sbGVjdGlvbiA9PSBudWxsKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG4gIHZhciBsZW5ndGggPSBpdGVyYXRlZXMubGVuZ3RoO1xuICBpZiAobGVuZ3RoID4gMSAmJiBpc0l0ZXJhdGVlQ2FsbChjb2xsZWN0aW9uLCBpdGVyYXRlZXNbMF0sIGl0ZXJhdGVlc1sxXSkpIHtcbiAgICBpdGVyYXRlZXMgPSBbXTtcbiAgfSBlbHNlIGlmIChsZW5ndGggPiAyICYmIGlzSXRlcmF0ZWVDYWxsKGl0ZXJhdGVlc1swXSwgaXRlcmF0ZWVzWzFdLCBpdGVyYXRlZXNbMl0pKSB7XG4gICAgaXRlcmF0ZWVzID0gW2l0ZXJhdGVlc1swXV07XG4gIH1cbiAgcmV0dXJuIGJhc2VPcmRlckJ5KGNvbGxlY3Rpb24sIGJhc2VGbGF0dGVuKGl0ZXJhdGVlcywgMSksIFtdKTtcbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHNvcnRCeTtcbiIsIi8qKlxuICogVGhpcyBtZXRob2QgcmV0dXJucyBhIG5ldyBlbXB0eSBhcnJheS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMTMuMFxuICogQGNhdGVnb3J5IFV0aWxcbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGVtcHR5IGFycmF5LlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgYXJyYXlzID0gXy50aW1lcygyLCBfLnN0dWJBcnJheSk7XG4gKlxuICogY29uc29sZS5sb2coYXJyYXlzKTtcbiAqIC8vID0+IFtbXSwgW11dXG4gKlxuICogY29uc29sZS5sb2coYXJyYXlzWzBdID09PSBhcnJheXNbMV0pO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gc3R1YkFycmF5KCkge1xuICByZXR1cm4gW107XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc3R1YkFycmF5O1xuIiwiLyoqXG4gKiBUaGlzIG1ldGhvZCByZXR1cm5zIGBmYWxzZWAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjEzLjBcbiAqIEBjYXRlZ29yeSBVdGlsXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLnRpbWVzKDIsIF8uc3R1YkZhbHNlKTtcbiAqIC8vID0+IFtmYWxzZSwgZmFsc2VdXG4gKi9cbmZ1bmN0aW9uIHN0dWJGYWxzZSgpIHtcbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHN0dWJGYWxzZTtcbiIsInZhciB0b051bWJlciA9IHJlcXVpcmUoJy4vdG9OdW1iZXInKTtcblxuLyoqIFVzZWQgYXMgcmVmZXJlbmNlcyBmb3IgdmFyaW91cyBgTnVtYmVyYCBjb25zdGFudHMuICovXG52YXIgSU5GSU5JVFkgPSAxIC8gMCxcbiAgICBNQVhfSU5URUdFUiA9IDEuNzk3NjkzMTM0ODYyMzE1N2UrMzA4O1xuXG4vKipcbiAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBmaW5pdGUgbnVtYmVyLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4xMi4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBudW1iZXIuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8udG9GaW5pdGUoMy4yKTtcbiAqIC8vID0+IDMuMlxuICpcbiAqIF8udG9GaW5pdGUoTnVtYmVyLk1JTl9WQUxVRSk7XG4gKiAvLyA9PiA1ZS0zMjRcbiAqXG4gKiBfLnRvRmluaXRlKEluZmluaXR5KTtcbiAqIC8vID0+IDEuNzk3NjkzMTM0ODYyMzE1N2UrMzA4XG4gKlxuICogXy50b0Zpbml0ZSgnMy4yJyk7XG4gKiAvLyA9PiAzLjJcbiAqL1xuZnVuY3Rpb24gdG9GaW5pdGUodmFsdWUpIHtcbiAgaWYgKCF2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSA9PT0gMCA/IHZhbHVlIDogMDtcbiAgfVxuICB2YWx1ZSA9IHRvTnVtYmVyKHZhbHVlKTtcbiAgaWYgKHZhbHVlID09PSBJTkZJTklUWSB8fCB2YWx1ZSA9PT0gLUlORklOSVRZKSB7XG4gICAgdmFyIHNpZ24gPSAodmFsdWUgPCAwID8gLTEgOiAxKTtcbiAgICByZXR1cm4gc2lnbiAqIE1BWF9JTlRFR0VSO1xuICB9XG4gIHJldHVybiB2YWx1ZSA9PT0gdmFsdWUgPyB2YWx1ZSA6IDA7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gdG9GaW5pdGU7XG4iLCJ2YXIgdG9GaW5pdGUgPSByZXF1aXJlKCcuL3RvRmluaXRlJyk7XG5cbi8qKlxuICogQ29udmVydHMgYHZhbHVlYCB0byBhbiBpbnRlZ2VyLlxuICpcbiAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBpcyBsb29zZWx5IGJhc2VkIG9uXG4gKiBbYFRvSW50ZWdlcmBdKGh0dHA6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy10b2ludGVnZXIpLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb252ZXJ0LlxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgY29udmVydGVkIGludGVnZXIuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8udG9JbnRlZ2VyKDMuMik7XG4gKiAvLyA9PiAzXG4gKlxuICogXy50b0ludGVnZXIoTnVtYmVyLk1JTl9WQUxVRSk7XG4gKiAvLyA9PiAwXG4gKlxuICogXy50b0ludGVnZXIoSW5maW5pdHkpO1xuICogLy8gPT4gMS43OTc2OTMxMzQ4NjIzMTU3ZSszMDhcbiAqXG4gKiBfLnRvSW50ZWdlcignMy4yJyk7XG4gKiAvLyA9PiAzXG4gKi9cbmZ1bmN0aW9uIHRvSW50ZWdlcih2YWx1ZSkge1xuICB2YXIgcmVzdWx0ID0gdG9GaW5pdGUodmFsdWUpLFxuICAgICAgcmVtYWluZGVyID0gcmVzdWx0ICUgMTtcblxuICByZXR1cm4gcmVzdWx0ID09PSByZXN1bHQgPyAocmVtYWluZGVyID8gcmVzdWx0IC0gcmVtYWluZGVyIDogcmVzdWx0KSA6IDA7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gdG9JbnRlZ2VyO1xuIiwidmFyIGJhc2VUcmltID0gcmVxdWlyZSgnLi9fYmFzZVRyaW0nKSxcbiAgICBpc09iamVjdCA9IHJlcXVpcmUoJy4vaXNPYmplY3QnKSxcbiAgICBpc1N5bWJvbCA9IHJlcXVpcmUoJy4vaXNTeW1ib2wnKTtcblxuLyoqIFVzZWQgYXMgcmVmZXJlbmNlcyBmb3IgdmFyaW91cyBgTnVtYmVyYCBjb25zdGFudHMuICovXG52YXIgTkFOID0gMCAvIDA7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBiYWQgc2lnbmVkIGhleGFkZWNpbWFsIHN0cmluZyB2YWx1ZXMuICovXG52YXIgcmVJc0JhZEhleCA9IC9eWy0rXTB4WzAtOWEtZl0rJC9pO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgYmluYXJ5IHN0cmluZyB2YWx1ZXMuICovXG52YXIgcmVJc0JpbmFyeSA9IC9eMGJbMDFdKyQvaTtcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IG9jdGFsIHN0cmluZyB2YWx1ZXMuICovXG52YXIgcmVJc09jdGFsID0gL14wb1swLTddKyQvaTtcblxuLyoqIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIHdpdGhvdXQgYSBkZXBlbmRlbmN5IG9uIGByb290YC4gKi9cbnZhciBmcmVlUGFyc2VJbnQgPSBwYXJzZUludDtcblxuLyoqXG4gKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGEgbnVtYmVyLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBwcm9jZXNzLlxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgbnVtYmVyLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLnRvTnVtYmVyKDMuMik7XG4gKiAvLyA9PiAzLjJcbiAqXG4gKiBfLnRvTnVtYmVyKE51bWJlci5NSU5fVkFMVUUpO1xuICogLy8gPT4gNWUtMzI0XG4gKlxuICogXy50b051bWJlcihJbmZpbml0eSk7XG4gKiAvLyA9PiBJbmZpbml0eVxuICpcbiAqIF8udG9OdW1iZXIoJzMuMicpO1xuICogLy8gPT4gMy4yXG4gKi9cbmZ1bmN0aW9uIHRvTnVtYmVyKHZhbHVlKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgPT0gJ251bWJlcicpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgaWYgKGlzU3ltYm9sKHZhbHVlKSkge1xuICAgIHJldHVybiBOQU47XG4gIH1cbiAgaWYgKGlzT2JqZWN0KHZhbHVlKSkge1xuICAgIHZhciBvdGhlciA9IHR5cGVvZiB2YWx1ZS52YWx1ZU9mID09ICdmdW5jdGlvbicgPyB2YWx1ZS52YWx1ZU9mKCkgOiB2YWx1ZTtcbiAgICB2YWx1ZSA9IGlzT2JqZWN0KG90aGVyKSA/IChvdGhlciArICcnKSA6IG90aGVyO1xuICB9XG4gIGlmICh0eXBlb2YgdmFsdWUgIT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gdmFsdWUgPT09IDAgPyB2YWx1ZSA6ICt2YWx1ZTtcbiAgfVxuICB2YWx1ZSA9IGJhc2VUcmltKHZhbHVlKTtcbiAgdmFyIGlzQmluYXJ5ID0gcmVJc0JpbmFyeS50ZXN0KHZhbHVlKTtcbiAgcmV0dXJuIChpc0JpbmFyeSB8fCByZUlzT2N0YWwudGVzdCh2YWx1ZSkpXG4gICAgPyBmcmVlUGFyc2VJbnQodmFsdWUuc2xpY2UoMiksIGlzQmluYXJ5ID8gMiA6IDgpXG4gICAgOiAocmVJc0JhZEhleC50ZXN0KHZhbHVlKSA/IE5BTiA6ICt2YWx1ZSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gdG9OdW1iZXI7XG4iLCJ2YXIgY29weU9iamVjdCA9IHJlcXVpcmUoJy4vX2NvcHlPYmplY3QnKSxcbiAgICBrZXlzSW4gPSByZXF1aXJlKCcuL2tleXNJbicpO1xuXG4vKipcbiAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBwbGFpbiBvYmplY3QgZmxhdHRlbmluZyBpbmhlcml0ZWQgZW51bWVyYWJsZSBzdHJpbmdcbiAqIGtleWVkIHByb3BlcnRpZXMgb2YgYHZhbHVlYCB0byBvd24gcHJvcGVydGllcyBvZiB0aGUgcGxhaW4gb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMy4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb252ZXJ0LlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY29udmVydGVkIHBsYWluIG9iamVjdC5cbiAqIEBleGFtcGxlXG4gKlxuICogZnVuY3Rpb24gRm9vKCkge1xuICogICB0aGlzLmIgPSAyO1xuICogfVxuICpcbiAqIEZvby5wcm90b3R5cGUuYyA9IDM7XG4gKlxuICogXy5hc3NpZ24oeyAnYSc6IDEgfSwgbmV3IEZvbyk7XG4gKiAvLyA9PiB7ICdhJzogMSwgJ2InOiAyIH1cbiAqXG4gKiBfLmFzc2lnbih7ICdhJzogMSB9LCBfLnRvUGxhaW5PYmplY3QobmV3IEZvbykpO1xuICogLy8gPT4geyAnYSc6IDEsICdiJzogMiwgJ2MnOiAzIH1cbiAqL1xuZnVuY3Rpb24gdG9QbGFpbk9iamVjdCh2YWx1ZSkge1xuICByZXR1cm4gY29weU9iamVjdCh2YWx1ZSwga2V5c0luKHZhbHVlKSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gdG9QbGFpbk9iamVjdDtcbiIsInZhciBiYXNlVG9TdHJpbmcgPSByZXF1aXJlKCcuL19iYXNlVG9TdHJpbmcnKTtcblxuLyoqXG4gKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGEgc3RyaW5nLiBBbiBlbXB0eSBzdHJpbmcgaXMgcmV0dXJuZWQgZm9yIGBudWxsYFxuICogYW5kIGB1bmRlZmluZWRgIHZhbHVlcy4gVGhlIHNpZ24gb2YgYC0wYCBpcyBwcmVzZXJ2ZWQuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgc3RyaW5nLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLnRvU3RyaW5nKG51bGwpO1xuICogLy8gPT4gJydcbiAqXG4gKiBfLnRvU3RyaW5nKC0wKTtcbiAqIC8vID0+ICctMCdcbiAqXG4gKiBfLnRvU3RyaW5nKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiAnMSwyLDMnXG4gKi9cbmZ1bmN0aW9uIHRvU3RyaW5nKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSA9PSBudWxsID8gJycgOiBiYXNlVG9TdHJpbmcodmFsdWUpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHRvU3RyaW5nO1xuIiwidmFyIGFycmF5RWFjaCA9IHJlcXVpcmUoJy4vX2FycmF5RWFjaCcpLFxuICAgIGJhc2VDcmVhdGUgPSByZXF1aXJlKCcuL19iYXNlQ3JlYXRlJyksXG4gICAgYmFzZUZvck93biA9IHJlcXVpcmUoJy4vX2Jhc2VGb3JPd24nKSxcbiAgICBiYXNlSXRlcmF0ZWUgPSByZXF1aXJlKCcuL19iYXNlSXRlcmF0ZWUnKSxcbiAgICBnZXRQcm90b3R5cGUgPSByZXF1aXJlKCcuL19nZXRQcm90b3R5cGUnKSxcbiAgICBpc0FycmF5ID0gcmVxdWlyZSgnLi9pc0FycmF5JyksXG4gICAgaXNCdWZmZXIgPSByZXF1aXJlKCcuL2lzQnVmZmVyJyksXG4gICAgaXNGdW5jdGlvbiA9IHJlcXVpcmUoJy4vaXNGdW5jdGlvbicpLFxuICAgIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9pc09iamVjdCcpLFxuICAgIGlzVHlwZWRBcnJheSA9IHJlcXVpcmUoJy4vaXNUeXBlZEFycmF5Jyk7XG5cbi8qKlxuICogQW4gYWx0ZXJuYXRpdmUgdG8gYF8ucmVkdWNlYDsgdGhpcyBtZXRob2QgdHJhbnNmb3JtcyBgb2JqZWN0YCB0byBhIG5ld1xuICogYGFjY3VtdWxhdG9yYCBvYmplY3Qgd2hpY2ggaXMgdGhlIHJlc3VsdCBvZiBydW5uaW5nIGVhY2ggb2YgaXRzIG93blxuICogZW51bWVyYWJsZSBzdHJpbmcga2V5ZWQgcHJvcGVydGllcyB0aHJ1IGBpdGVyYXRlZWAsIHdpdGggZWFjaCBpbnZvY2F0aW9uXG4gKiBwb3RlbnRpYWxseSBtdXRhdGluZyB0aGUgYGFjY3VtdWxhdG9yYCBvYmplY3QuIElmIGBhY2N1bXVsYXRvcmAgaXMgbm90XG4gKiBwcm92aWRlZCwgYSBuZXcgb2JqZWN0IHdpdGggdGhlIHNhbWUgYFtbUHJvdG90eXBlXV1gIHdpbGwgYmUgdXNlZC4gVGhlXG4gKiBpdGVyYXRlZSBpcyBpbnZva2VkIHdpdGggZm91ciBhcmd1bWVudHM6IChhY2N1bXVsYXRvciwgdmFsdWUsIGtleSwgb2JqZWN0KS5cbiAqIEl0ZXJhdGVlIGZ1bmN0aW9ucyBtYXkgZXhpdCBpdGVyYXRpb24gZWFybHkgYnkgZXhwbGljaXRseSByZXR1cm5pbmcgYGZhbHNlYC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDEuMy4wXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcGFyYW0geyp9IFthY2N1bXVsYXRvcl0gVGhlIGN1c3RvbSBhY2N1bXVsYXRvciB2YWx1ZS5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBhY2N1bXVsYXRlZCB2YWx1ZS5cbiAqIEBleGFtcGxlXG4gKlxuICogXy50cmFuc2Zvcm0oWzIsIDMsIDRdLCBmdW5jdGlvbihyZXN1bHQsIG4pIHtcbiAqICAgcmVzdWx0LnB1c2gobiAqPSBuKTtcbiAqICAgcmV0dXJuIG4gJSAyID09IDA7XG4gKiB9LCBbXSk7XG4gKiAvLyA9PiBbNCwgOV1cbiAqXG4gKiBfLnRyYW5zZm9ybSh7ICdhJzogMSwgJ2InOiAyLCAnYyc6IDEgfSwgZnVuY3Rpb24ocmVzdWx0LCB2YWx1ZSwga2V5KSB7XG4gKiAgIChyZXN1bHRbdmFsdWVdIHx8IChyZXN1bHRbdmFsdWVdID0gW10pKS5wdXNoKGtleSk7XG4gKiB9LCB7fSk7XG4gKiAvLyA9PiB7ICcxJzogWydhJywgJ2MnXSwgJzInOiBbJ2InXSB9XG4gKi9cbmZ1bmN0aW9uIHRyYW5zZm9ybShvYmplY3QsIGl0ZXJhdGVlLCBhY2N1bXVsYXRvcikge1xuICB2YXIgaXNBcnIgPSBpc0FycmF5KG9iamVjdCksXG4gICAgICBpc0Fyckxpa2UgPSBpc0FyciB8fCBpc0J1ZmZlcihvYmplY3QpIHx8IGlzVHlwZWRBcnJheShvYmplY3QpO1xuXG4gIGl0ZXJhdGVlID0gYmFzZUl0ZXJhdGVlKGl0ZXJhdGVlLCA0KTtcbiAgaWYgKGFjY3VtdWxhdG9yID09IG51bGwpIHtcbiAgICB2YXIgQ3RvciA9IG9iamVjdCAmJiBvYmplY3QuY29uc3RydWN0b3I7XG4gICAgaWYgKGlzQXJyTGlrZSkge1xuICAgICAgYWNjdW11bGF0b3IgPSBpc0FyciA/IG5ldyBDdG9yIDogW107XG4gICAgfVxuICAgIGVsc2UgaWYgKGlzT2JqZWN0KG9iamVjdCkpIHtcbiAgICAgIGFjY3VtdWxhdG9yID0gaXNGdW5jdGlvbihDdG9yKSA/IGJhc2VDcmVhdGUoZ2V0UHJvdG90eXBlKG9iamVjdCkpIDoge307XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgYWNjdW11bGF0b3IgPSB7fTtcbiAgICB9XG4gIH1cbiAgKGlzQXJyTGlrZSA/IGFycmF5RWFjaCA6IGJhc2VGb3JPd24pKG9iamVjdCwgZnVuY3Rpb24odmFsdWUsIGluZGV4LCBvYmplY3QpIHtcbiAgICByZXR1cm4gaXRlcmF0ZWUoYWNjdW11bGF0b3IsIHZhbHVlLCBpbmRleCwgb2JqZWN0KTtcbiAgfSk7XG4gIHJldHVybiBhY2N1bXVsYXRvcjtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB0cmFuc2Zvcm07XG4iLCJ2YXIgYmFzZUZsYXR0ZW4gPSByZXF1aXJlKCcuL19iYXNlRmxhdHRlbicpLFxuICAgIGJhc2VSZXN0ID0gcmVxdWlyZSgnLi9fYmFzZVJlc3QnKSxcbiAgICBiYXNlVW5pcSA9IHJlcXVpcmUoJy4vX2Jhc2VVbmlxJyksXG4gICAgaXNBcnJheUxpa2VPYmplY3QgPSByZXF1aXJlKCcuL2lzQXJyYXlMaWtlT2JqZWN0Jyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiB1bmlxdWUgdmFsdWVzLCBpbiBvcmRlciwgZnJvbSBhbGwgZ2l2ZW4gYXJyYXlzIHVzaW5nXG4gKiBbYFNhbWVWYWx1ZVplcm9gXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1zYW1ldmFsdWV6ZXJvKVxuICogZm9yIGVxdWFsaXR5IGNvbXBhcmlzb25zLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBBcnJheVxuICogQHBhcmFtIHsuLi5BcnJheX0gW2FycmF5c10gVGhlIGFycmF5cyB0byBpbnNwZWN0LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2YgY29tYmluZWQgdmFsdWVzLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLnVuaW9uKFsyXSwgWzEsIDJdKTtcbiAqIC8vID0+IFsyLCAxXVxuICovXG52YXIgdW5pb24gPSBiYXNlUmVzdChmdW5jdGlvbihhcnJheXMpIHtcbiAgcmV0dXJuIGJhc2VVbmlxKGJhc2VGbGF0dGVuKGFycmF5cywgMSwgaXNBcnJheUxpa2VPYmplY3QsIHRydWUpKTtcbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHVuaW9uO1xuIiwidmFyIHRvU3RyaW5nID0gcmVxdWlyZSgnLi90b1N0cmluZycpO1xuXG4vKiogVXNlZCB0byBnZW5lcmF0ZSB1bmlxdWUgSURzLiAqL1xudmFyIGlkQ291bnRlciA9IDA7XG5cbi8qKlxuICogR2VuZXJhdGVzIGEgdW5pcXVlIElELiBJZiBgcHJlZml4YCBpcyBnaXZlbiwgdGhlIElEIGlzIGFwcGVuZGVkIHRvIGl0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBzaW5jZSAwLjEuMFxuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBVdGlsXG4gKiBAcGFyYW0ge3N0cmluZ30gW3ByZWZpeD0nJ10gVGhlIHZhbHVlIHRvIHByZWZpeCB0aGUgSUQgd2l0aC5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHVuaXF1ZSBJRC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy51bmlxdWVJZCgnY29udGFjdF8nKTtcbiAqIC8vID0+ICdjb250YWN0XzEwNCdcbiAqXG4gKiBfLnVuaXF1ZUlkKCk7XG4gKiAvLyA9PiAnMTA1J1xuICovXG5mdW5jdGlvbiB1bmlxdWVJZChwcmVmaXgpIHtcbiAgdmFyIGlkID0gKytpZENvdW50ZXI7XG4gIHJldHVybiB0b1N0cmluZyhwcmVmaXgpICsgaWQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gdW5pcXVlSWQ7XG4iLCJ2YXIgYmFzZVZhbHVlcyA9IHJlcXVpcmUoJy4vX2Jhc2VWYWx1ZXMnKSxcbiAgICBrZXlzID0gcmVxdWlyZSgnLi9rZXlzJyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiB0aGUgb3duIGVudW1lcmFibGUgc3RyaW5nIGtleWVkIHByb3BlcnR5IHZhbHVlcyBvZiBgb2JqZWN0YC5cbiAqXG4gKiAqKk5vdGU6KiogTm9uLW9iamVjdCB2YWx1ZXMgYXJlIGNvZXJjZWQgdG8gb2JqZWN0cy5cbiAqXG4gKiBAc3RhdGljXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBtZW1iZXJPZiBfXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IHZhbHVlcy5cbiAqIEBleGFtcGxlXG4gKlxuICogZnVuY3Rpb24gRm9vKCkge1xuICogICB0aGlzLmEgPSAxO1xuICogICB0aGlzLmIgPSAyO1xuICogfVxuICpcbiAqIEZvby5wcm90b3R5cGUuYyA9IDM7XG4gKlxuICogXy52YWx1ZXMobmV3IEZvbyk7XG4gKiAvLyA9PiBbMSwgMl0gKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZClcbiAqXG4gKiBfLnZhbHVlcygnaGknKTtcbiAqIC8vID0+IFsnaCcsICdpJ11cbiAqL1xuZnVuY3Rpb24gdmFsdWVzKG9iamVjdCkge1xuICByZXR1cm4gb2JqZWN0ID09IG51bGwgPyBbXSA6IGJhc2VWYWx1ZXMob2JqZWN0LCBrZXlzKG9iamVjdCkpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHZhbHVlcztcbiIsInZhciBhc3NpZ25WYWx1ZSA9IHJlcXVpcmUoJy4vX2Fzc2lnblZhbHVlJyksXG4gICAgYmFzZVppcE9iamVjdCA9IHJlcXVpcmUoJy4vX2Jhc2VaaXBPYmplY3QnKTtcblxuLyoqXG4gKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmZyb21QYWlyc2AgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyB0d28gYXJyYXlzLFxuICogb25lIG9mIHByb3BlcnR5IGlkZW50aWZpZXJzIGFuZCBvbmUgb2YgY29ycmVzcG9uZGluZyB2YWx1ZXMuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjQuMFxuICogQGNhdGVnb3J5IEFycmF5XG4gKiBAcGFyYW0ge0FycmF5fSBbcHJvcHM9W11dIFRoZSBwcm9wZXJ0eSBpZGVudGlmaWVycy5cbiAqIEBwYXJhbSB7QXJyYXl9IFt2YWx1ZXM9W11dIFRoZSBwcm9wZXJ0eSB2YWx1ZXMuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgb2JqZWN0LlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLnppcE9iamVjdChbJ2EnLCAnYiddLCBbMSwgMl0pO1xuICogLy8gPT4geyAnYSc6IDEsICdiJzogMiB9XG4gKi9cbmZ1bmN0aW9uIHppcE9iamVjdChwcm9wcywgdmFsdWVzKSB7XG4gIHJldHVybiBiYXNlWmlwT2JqZWN0KHByb3BzIHx8IFtdLCB2YWx1ZXMgfHwgW10sIGFzc2lnblZhbHVlKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB6aXBPYmplY3Q7XG4iLCIvLyBleHRyYWN0ZWQgYnkgbWluaS1jc3MtZXh0cmFjdC1wbHVnaW5cbmV4cG9ydCB7fTsiLCJcInVzZSBzdHJpY3RcIjtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5leHBvcnRzLkFuaW1TZXF1ZW5jZSA9IGV4cG9ydHMuQW5pbSA9IHZvaWQgMDtcclxuY2xhc3MgQW5pbSB7XHJcbiAgICBjb25zdHJ1Y3Rvcih0YXJnZXQsIGR1cmF0aW9uID0gMTAwMCkge1xyXG4gICAgICAgIHRoaXMudGFyZ2V0ID0gdGFyZ2V0O1xyXG4gICAgICAgIHRoaXMuZHVyYXRpb24gPSBkdXJhdGlvbjtcclxuICAgICAgICB0aGlzLnN0YXJ0ID0gMDtcclxuICAgIH1cclxuICAgIGdldCBzdG9wKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnN0YXJ0ICsgdGhpcy5kdXJhdGlvbjtcclxuICAgIH1cclxuICAgIHBsYXkoKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKHJlc29sdmUgPT4gdGhpcy5zdGFydCAhPSAwID9cclxuICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB0aGlzLnJ1bihyZXNvbHZlKSwgdGhpcy5zdGFydCkgOlxyXG4gICAgICAgICAgICB0aGlzLnJ1bihyZXNvbHZlKSk7XHJcbiAgICB9XHJcbn1cclxuZXhwb3J0cy5BbmltID0gQW5pbTtcclxuY2xhc3MgQW5pbVNlcXVlbmNlIHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHRoaXMuYW5pbXMgPSBbXTtcclxuICAgIH1cclxuICAgIHBsYXkoKSB7XHJcbiAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKHRoaXMuYW5pbXMubWFwKGEgPT4gYS5wbGF5KCkpKTtcclxuICAgIH1cclxuICAgIGFkZChhbmltLCBzdGFydCkge1xyXG4gICAgICAgIGFuaW0uc3RhcnQgPSBzdGFydDtcclxuICAgICAgICBsZXQgaSA9IHRoaXMuYW5pbXMuZmluZEluZGV4KGEgPT4gYS5zdGFydCA+IHN0YXJ0KTtcclxuICAgICAgICBpZiAoaSA8IDApXHJcbiAgICAgICAgICAgIHRoaXMuYW5pbXMucHVzaChhbmltKTtcclxuICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIHRoaXMuYW5pbXMuc3BsaWNlKGksIDAsIGFuaW0pO1xyXG4gICAgfVxyXG4gICAgYWRkQXQoYW5pbSwgc3RhcnQpIHtcclxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShhbmltKSlcclxuICAgICAgICAgICAgYW5pbS5mb3JFYWNoKGEgPT4gdGhpcy5hZGQoYSwgc3RhcnQpKTtcclxuICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIHRoaXMuYWRkKGFuaW0sIHN0YXJ0KTtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuICAgIGFkZEFmdGVyKGFuaW0sIGFmdGVyLCBkZWxheSA9IDApIHtcclxuICAgICAgICBpZiAodHlwZW9mIGFmdGVyID09PSBcIm51bWJlclwiKVxyXG4gICAgICAgICAgICBhZnRlciA9IHRoaXMuYW5pbXNbYWZ0ZXJdO1xyXG4gICAgICAgIHRoaXMuYWRkQXQoYW5pbSwgYWZ0ZXIuc3RvcCArIGRlbGF5KTtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuICAgIGFkZFRvRW5kKGFuaW0sIGRlbGF5ID0gMCkge1xyXG4gICAgICAgIGxldCBtYXhzdG9wID0gdGhpcy5hbmltcy5sZW5ndGggPT0gMCA/IDAgOlxyXG4gICAgICAgICAgICBNYXRoLm1heCguLi50aGlzLmFuaW1zLm1hcChhID0+IGEuc3RvcCkpO1xyXG4gICAgICAgIHRoaXMuYWRkQXQoYW5pbSwgbWF4c3RvcCArIGRlbGF5KTtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuICAgIGFkZFRvRW5kU3RhZ2dlcmVkKGFuaW1zLCBnYXAsIGRlbGF5ID0gMCkge1xyXG4gICAgICAgIGxldCBtYXhzdG9wID0gdGhpcy5hbmltcy5sZW5ndGggPT0gMCA/IDAgOlxyXG4gICAgICAgICAgICBNYXRoLm1heCguLi50aGlzLmFuaW1zLm1hcChhID0+IGEuc3RvcCkpO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYW5pbXMubGVuZ3RoOyArK2kpXHJcbiAgICAgICAgICAgIHRoaXMuYWRkQXQoYW5pbXNbaV0sIG1heHN0b3AgKyBkZWxheSArIChpICogZ2FwKSk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcbn1cclxuZXhwb3J0cy5BbmltU2VxdWVuY2UgPSBBbmltU2VxdWVuY2U7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFuaW0uanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcclxuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfSk7XHJcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XHJcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xyXG4gICAgb1trMl0gPSBtW2tdO1xyXG59KSk7XHJcbnZhciBfX3NldE1vZHVsZURlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9fc2V0TW9kdWxlRGVmYXVsdCkgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgdikge1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIFwiZGVmYXVsdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2IH0pO1xyXG59KSA6IGZ1bmN0aW9uKG8sIHYpIHtcclxuICAgIG9bXCJkZWZhdWx0XCJdID0gdjtcclxufSk7XHJcbnZhciBfX2ltcG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0U3RhcikgfHwgZnVuY3Rpb24gKG1vZCkge1xyXG4gICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcclxuICAgIHZhciByZXN1bHQgPSB7fTtcclxuICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChrICE9PSBcImRlZmF1bHRcIiAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgX19jcmVhdGVCaW5kaW5nKHJlc3VsdCwgbW9kLCBrKTtcclxuICAgIF9fc2V0TW9kdWxlRGVmYXVsdChyZXN1bHQsIG1vZCk7XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG59O1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmV4cG9ydHMuYW5pbWF0ZWRWaWV3ID0gZXhwb3J0cy5BbmltYXRlZFZpZXcgPSB2b2lkIDA7XHJcbmNvbnN0IGVsID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCIuLi9zdmcvZWxlbVwiKSk7XHJcbmNvbnN0IGFkID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCIuL2FuaW1hdGVkXCIpKTtcclxuY29uc3Qga2ZhID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCIuL2tleWZyYW1lLWFuaW1cIikpO1xyXG5jbGFzcyBBbmltYXRlZFZpZXcgZXh0ZW5kcyBhZC5BbmltYXRlZCB7XHJcbiAgICBjb25zdHJ1Y3RvcihwYXJlbnQpIHtcclxuICAgICAgICBzdXBlcihwYXJlbnQuZWxlbWVudCk7XHJcbiAgICAgICAgdGhpcy5zdmdwYXJlbnQgPSBwYXJlbnQ7XHJcbiAgICB9XHJcbiAgICBnZXQgcGFyZW50VkJveCgpIHtcclxuICAgICAgICByZXR1cm4gZWwuZ2V0Vmlld0JveCh0aGlzLnN2Z3BhcmVudCk7XHJcbiAgICB9XHJcbiAgICB6b29tKHRvLCBkdXJhdGlvbiA9IDEwMDApIHtcclxuICAgICAgICBsZXQgdmJveCA9IHRoaXMucGFyZW50VkJveDtcclxuICAgICAgICBsZXQgc2NhbGUgPSBNYXRoLm1pbih2Ym94LndpZHRoIC8gdG8ud2lkdGgsIHZib3guaGVpZ2h0IC8gdG8uaGVpZ2h0KTtcclxuICAgICAgICBsZXQgeCA9IHZib3gubGVmdCAtIHRvLmxlZnQ7XHJcbiAgICAgICAgbGV0IHkgPSB2Ym94LnRvcCAtIHRvLnRvcDtcclxuICAgICAgICByZXR1cm4gbmV3IGtmYS5LZXlmcmFtZUFuaW0odGhpcywgW2FkLmN1cnJlbnQsIGEgPT4gYS5zdGF0ZS5zY2FsZShzY2FsZSwgc2NhbGUpLm1vdmUoeCwgeSldLCBkdXJhdGlvbik7XHJcbiAgICB9XHJcbiAgICB6b29tRmFjdG9yKHNjYWxlLCB4LCB5LCBkdXJhdGlvbiA9IDEwMDApIHtcclxuICAgICAgICBsZXQgdmJveCA9IHRoaXMucGFyZW50VkJveDtcclxuICAgICAgICBsZXQgc3ggPSB2Ym94LmNlbnRlclggLSB4O1xyXG4gICAgICAgIGxldCBzeSA9IHZib3guY2VudGVyWSAtIHk7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBrZmEuS2V5ZnJhbWVBbmltKHRoaXMsIFthZC5jdXJyZW50LCBhID0+IGEuc3RhdGUuc2NhbGUoc2NhbGUsIHNjYWxlKS5tb3ZlKHN4LCBzeSldLCBkdXJhdGlvbik7XHJcbiAgICB9XHJcbiAgICB6b29tSG9tZShkdXJhdGlvbiA9IDEwMDApIHtcclxuICAgICAgICByZXR1cm4gbmV3IGtmYS5LZXlmcmFtZUFuaW0odGhpcywgW2FkLmN1cnJlbnQsIGEgPT4gYS5zdGF0ZS5zY2FsZSgxLCAxKS5tb3ZlKDAsIDApXSwgZHVyYXRpb24pO1xyXG4gICAgfVxyXG4gICAgcGFuKHgsIHksIGR1cmF0aW9uID0gMTAwMCkge1xyXG4gICAgICAgIHJldHVybiBuZXcga2ZhLktleWZyYW1lQW5pbSh0aGlzLCBbYWQuY3VycmVudCxcclxuICAgICAgICAgICAgYWQubW92ZVJlbGF0aXZlKC14LCAteSldLCBkdXJhdGlvbik7XHJcbiAgICB9XHJcbiAgICBwYW5Ubyh4LCB5LCBkdXJhdGlvbiA9IDEwMDApIHtcclxuICAgICAgICByZXR1cm4gbmV3IGtmYS5LZXlmcmFtZUFuaW0odGhpcywgW2FkLmN1cnJlbnQsIGFkLm1vdmUoeCwgeSldLCBkdXJhdGlvbik7XHJcbiAgICB9XHJcbn1cclxuZXhwb3J0cy5BbmltYXRlZFZpZXcgPSBBbmltYXRlZFZpZXc7XHJcbmZ1bmN0aW9uIGFuaW1hdGVkVmlldyhwYXJlbnQpIHtcclxuICAgIHJldHVybiBuZXcgQW5pbWF0ZWRWaWV3KHBhcmVudCk7XHJcbn1cclxuZXhwb3J0cy5hbmltYXRlZFZpZXcgPSBhbmltYXRlZFZpZXc7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFuaW1hdGVkLXZpZXcuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcclxuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfSk7XHJcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XHJcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xyXG4gICAgb1trMl0gPSBtW2tdO1xyXG59KSk7XHJcbnZhciBfX3NldE1vZHVsZURlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9fc2V0TW9kdWxlRGVmYXVsdCkgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgdikge1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIFwiZGVmYXVsdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2IH0pO1xyXG59KSA6IGZ1bmN0aW9uKG8sIHYpIHtcclxuICAgIG9bXCJkZWZhdWx0XCJdID0gdjtcclxufSk7XHJcbnZhciBfX2ltcG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0U3RhcikgfHwgZnVuY3Rpb24gKG1vZCkge1xyXG4gICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcclxuICAgIHZhciByZXN1bHQgPSB7fTtcclxuICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChrICE9PSBcImRlZmF1bHRcIiAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgX19jcmVhdGVCaW5kaW5nKHJlc3VsdCwgbW9kLCBrKTtcclxuICAgIF9fc2V0TW9kdWxlRGVmYXVsdChyZXN1bHQsIG1vZCk7XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG59O1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmV4cG9ydHMuYm91bmNlRG93biA9IGV4cG9ydHMuYm91bmNlVXAgPSBleHBvcnRzLmJvdW5jZVJpZ2h0ID0gZXhwb3J0cy5ib3VuY2VMZWZ0ID0gZXhwb3J0cy53b2JibGVYWSA9IGV4cG9ydHMud29iYmxlWSA9IGV4cG9ydHMud29iYmxlWCA9IGV4cG9ydHMuc2NhbGVYWSA9IGV4cG9ydHMuc2NhbGVZID0gZXhwb3J0cy5zY2FsZVggPSBleHBvcnRzLnNoaWZ0RG93biA9IGV4cG9ydHMuc2hpZnRVcCA9IGV4cG9ydHMuc2hpZnRSaWdodCA9IGV4cG9ydHMuc2hpZnRMZWZ0ID0gZXhwb3J0cy5zaGlmdCA9IGV4cG9ydHMubW92ZVJlbGF0aXZlID0gZXhwb3J0cy5tb3ZlID0gZXhwb3J0cy5ub3JtYWxTaXplID0gZXhwb3J0cy56ZXJvU2l6ZSA9IGV4cG9ydHMuY3VycmVudCA9IGV4cG9ydHMucmVzZXQgPSBleHBvcnRzLm9mZnNldCA9IGV4cG9ydHMuYW5pbWF0ZWQgPSBleHBvcnRzLkFuaW1hdGVkID0gZXhwb3J0cy5BbmltU3RhdGUgPSB2b2lkIDA7XHJcbi8qKlxyXG4gKiAjIEFuaW1hdGluZyBTVkcgRWxlbWVudHNcclxuICovXHJcbmNvbnN0IGVsID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCIuLi9zdmcvZWxlbVwiKSk7XHJcbmNvbnN0IHZlYyA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwiLi4vc3ZnL3ZlY3RvclwiKSk7XHJcbmNsYXNzIEFuaW1TdGF0ZSB7XHJcbiAgICBjb25zdHJ1Y3RvcihzY2FsaW5nLCByb3RhdGlvbiwgcG9zaXRpb24sIHNoaWZ0KSB7XHJcbiAgICAgICAgdGhpcy5zY2FsaW5nID0gc2NhbGluZztcclxuICAgICAgICB0aGlzLnJvdGF0aW9uID0gcm90YXRpb247XHJcbiAgICAgICAgdGhpcy5wb3NpdGlvbiA9IHBvc2l0aW9uO1xyXG4gICAgICAgIHRoaXMuc2hpZnQgPSBzaGlmdDtcclxuICAgIH1cclxuICAgIHNjYWxlKHgsIHkpIHtcclxuICAgICAgICByZXR1cm4gbmV3IEFuaW1TdGF0ZShbeCwgeV0sIHRoaXMucm90YXRpb24sIHRoaXMucG9zaXRpb24sIHRoaXMuc2hpZnQpO1xyXG4gICAgfVxyXG4gICAgcm90YXRlKGFuZ2xlKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBBbmltU3RhdGUodGhpcy5zY2FsaW5nLCBhbmdsZSwgdGhpcy5wb3NpdGlvbiwgdGhpcy5zaGlmdCk7XHJcbiAgICB9XHJcbiAgICBtb3ZlKHgsIHkpIHtcclxuICAgICAgICByZXR1cm4gbmV3IEFuaW1TdGF0ZSh0aGlzLnNjYWxpbmcsIHRoaXMucm90YXRpb24sIFt4LCB5XSwgdGhpcy5zaGlmdCk7XHJcbiAgICB9XHJcbiAgICBtb3ZlUmVsYXRpdmUoZHgsIGR5KSB7XHJcbiAgICAgICAgbGV0IFt4LCB5XSA9IHRoaXMucG9zaXRpb247XHJcbiAgICAgICAgcmV0dXJuIG5ldyBBbmltU3RhdGUodGhpcy5zY2FsaW5nLCB0aGlzLnJvdGF0aW9uLCBbeCArIGR4LCB5ICsgZHldLCB0aGlzLnNoaWZ0KTtcclxuICAgIH1cclxuICAgIHNoaWZ0UG9zaXRpb24oeCwgeSkge1xyXG4gICAgICAgIHJldHVybiBuZXcgQW5pbVN0YXRlKHRoaXMuc2NhbGluZywgdGhpcy5yb3RhdGlvbiwgdGhpcy5wb3NpdGlvbiwgW3gsIHldKTtcclxuICAgIH1cclxuICAgIGdldCBtYXRyaXgoKSB7XHJcbiAgICAgICAgbGV0IFtzeCwgc3ldID0gdGhpcy5zY2FsaW5nO1xyXG4gICAgICAgIGxldCBbeCwgeV0gPSB2ZWMuYWRkVmVjKHRoaXMucG9zaXRpb24sIHRoaXMuc2hpZnQpO1xyXG4gICAgICAgIHJldHVybiBuZXcgRE9NTWF0cml4KClcclxuICAgICAgICAgICAgLnNjYWxlKHN4LCBzeSlcclxuICAgICAgICAgICAgLnJvdGF0ZSgwLCAwLCB0aGlzLnJvdGF0aW9uKVxyXG4gICAgICAgICAgICAudHJhbnNsYXRlKHgsIHkpO1xyXG4gICAgfVxyXG4gICAgdG9LZXlmcmFtZSgpIHtcclxuICAgICAgICBsZXQgW3N4LCBzeV0gPSB0aGlzLnNjYWxpbmc7XHJcbiAgICAgICAgbGV0IFt4LCB5XSA9IHZlYy5hZGRWZWModGhpcy5wb3NpdGlvbiwgdGhpcy5zaGlmdCk7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgdHJhbnNmb3JtOiBgcm90YXRlWigke3RoaXMucm90YXRpb259ZGVnKSBgICtcclxuICAgICAgICAgICAgICAgIGB0cmFuc2xhdGUzZCgke3h9cHgsICR7eX1weCwgMCkgYCArXHJcbiAgICAgICAgICAgICAgICBgc2NhbGUzZCgke3N4fSwgJHtzeX0sIDEpYCxcclxuICAgICAgICAgICAgb2Zmc2V0OiB0aGlzLm9mZnNldFxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbn1cclxuZXhwb3J0cy5BbmltU3RhdGUgPSBBbmltU3RhdGU7XHJcbkFuaW1TdGF0ZS56ZXJvID0gbmV3IEFuaW1TdGF0ZSh2ZWMub25lVmVjdG9yLCAwLCB2ZWMuemVyb1ZlY3RvciwgdmVjLnplcm9WZWN0b3IpO1xyXG5jbGFzcyBBbmltYXRlZCBleHRlbmRzIGVsLkdyYXBoRWxlbSB7XHJcbiAgICBjb25zdHJ1Y3RvcihwYXJlbnQpIHtcclxuICAgICAgICBzdXBlcihkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoZWwubnMsICdnJyksIHBhcmVudCk7XHJcbiAgICAgICAgdGhpcy5zdGF0ZSA9IEFuaW1TdGF0ZS56ZXJvO1xyXG4gICAgICAgIHRoaXMuc3R5bGVzKHtcclxuICAgICAgICAgICAgdHJhbnNmb3JtT3JpZ2luOiAnY2VudGVyJyxcclxuICAgICAgICAgICAgdHJhbnNmb3JtQm94OiAnZmlsbC1ib3gnXHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBnZXQgYW5pbWF0ZWRCQm94KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmJib3gudHJhbnNmb3JtKHRoaXMuc3RhdGUubWF0cml4KTtcclxuICAgIH1cclxuICAgIHBvc2l0aW9uKHBvcykge1xyXG4gICAgICAgIGxldCBbeCwgeV0gPSBwb3M7XHJcbiAgICAgICAgdGhpcy5zdGF0ZSA9IHRoaXMuc3RhdGUubW92ZSh4LCB5KTtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxufVxyXG5leHBvcnRzLkFuaW1hdGVkID0gQW5pbWF0ZWQ7XHJcbmZ1bmN0aW9uIGFuaW1hdGVkKHBhcmVudCkge1xyXG4gICAgcmV0dXJuIG5ldyBBbmltYXRlZChwYXJlbnQgaW5zdGFuY2VvZiBlbC5FbGVtID8gcGFyZW50LmVsZW1lbnQgOiBwYXJlbnQpO1xyXG59XHJcbmV4cG9ydHMuYW5pbWF0ZWQgPSBhbmltYXRlZDtcclxuZnVuY3Rpb24gb2Zmc2V0KGdldFN0YXRlLCBvZmZzZXQpIHtcclxuICAgIHJldHVybiBhID0+IHtcclxuICAgICAgICBsZXQgc3RhdGUgPSBnZXRTdGF0ZShhKTtcclxuICAgICAgICBzdGF0ZS5vZmZzZXQgPSBvZmZzZXQ7XHJcbiAgICAgICAgcmV0dXJuIHN0YXRlO1xyXG4gICAgfTtcclxufVxyXG5leHBvcnRzLm9mZnNldCA9IG9mZnNldDtcclxuY29uc3QgcmVzZXQgPSBhID0+IG5ldyBBbmltU3RhdGUoWzEsIDFdLCAwLCBbMCwgMF0sIFswLCAwXSk7XHJcbmV4cG9ydHMucmVzZXQgPSByZXNldDtcclxuY29uc3QgY3VycmVudCA9IGEgPT4gYS5zdGF0ZTtcclxuZXhwb3J0cy5jdXJyZW50ID0gY3VycmVudDtcclxuY29uc3QgemVyb1NpemUgPSBhID0+IGEuc3RhdGUuc2NhbGUoMCwgMCk7XHJcbmV4cG9ydHMuemVyb1NpemUgPSB6ZXJvU2l6ZTtcclxuY29uc3Qgbm9ybWFsU2l6ZSA9IGEgPT4gYS5zdGF0ZS5zY2FsZSgxLCAxKTtcclxuZXhwb3J0cy5ub3JtYWxTaXplID0gbm9ybWFsU2l6ZTtcclxuZnVuY3Rpb24gbW92ZSh4LCB5KSB7XHJcbiAgICByZXR1cm4gYSA9PiBhLnN0YXRlLm1vdmUoeCwgeSk7XHJcbn1cclxuZXhwb3J0cy5tb3ZlID0gbW92ZTtcclxuZnVuY3Rpb24gbW92ZVJlbGF0aXZlKHgsIHkpIHtcclxuICAgIHJldHVybiBhID0+IGEuc3RhdGUubW92ZVJlbGF0aXZlKHgsIHkpO1xyXG59XHJcbmV4cG9ydHMubW92ZVJlbGF0aXZlID0gbW92ZVJlbGF0aXZlO1xyXG5mdW5jdGlvbiBzaGlmdCh4LCB5KSB7XHJcbiAgICByZXR1cm4gYSA9PiBhLnN0YXRlLnNoaWZ0UG9zaXRpb24oeCwgeSk7XHJcbn1cclxuZXhwb3J0cy5zaGlmdCA9IHNoaWZ0O1xyXG5mdW5jdGlvbiBzaGlmdExlZnQoZGlzdCkge1xyXG4gICAgcmV0dXJuIGEgPT4gYS5zdGF0ZS5zaGlmdFBvc2l0aW9uKC1kaXN0ICogMTAwLCAwKTtcclxufVxyXG5leHBvcnRzLnNoaWZ0TGVmdCA9IHNoaWZ0TGVmdDtcclxuZnVuY3Rpb24gc2hpZnRSaWdodChkaXN0KSB7XHJcbiAgICByZXR1cm4gYSA9PiBhLnN0YXRlLnNoaWZ0UG9zaXRpb24oZGlzdCAqIDEwMCwgMCk7XHJcbn1cclxuZXhwb3J0cy5zaGlmdFJpZ2h0ID0gc2hpZnRSaWdodDtcclxuZnVuY3Rpb24gc2hpZnRVcChkaXN0KSB7XHJcbiAgICByZXR1cm4gYSA9PiBhLnN0YXRlLnNoaWZ0UG9zaXRpb24oMCwgLWRpc3QgKiAxMDApO1xyXG59XHJcbmV4cG9ydHMuc2hpZnRVcCA9IHNoaWZ0VXA7XHJcbmZ1bmN0aW9uIHNoaWZ0RG93bihkaXN0KSB7XHJcbiAgICByZXR1cm4gYSA9PiBhLnN0YXRlLnNoaWZ0UG9zaXRpb24oMCwgZGlzdCAqIDEwMCk7XHJcbn1cclxuZXhwb3J0cy5zaGlmdERvd24gPSBzaGlmdERvd247XHJcbmZ1bmN0aW9uIHNjYWxlWChzY2FsZSkge1xyXG4gICAgcmV0dXJuIGEgPT4gYS5zdGF0ZS5zY2FsZShzY2FsZSwgMSk7XHJcbn1cclxuZXhwb3J0cy5zY2FsZVggPSBzY2FsZVg7XHJcbmZ1bmN0aW9uIHNjYWxlWShzY2FsZSkge1xyXG4gICAgcmV0dXJuIGEgPT4gYS5zdGF0ZS5zY2FsZSgxLCBzY2FsZSk7XHJcbn1cclxuZXhwb3J0cy5zY2FsZVkgPSBzY2FsZVk7XHJcbmZ1bmN0aW9uIHNjYWxlWFkoc2NhbGUpIHtcclxuICAgIHJldHVybiBhID0+IGEuc3RhdGUuc2NhbGUoc2NhbGUsIHNjYWxlKTtcclxufVxyXG5leHBvcnRzLnNjYWxlWFkgPSBzY2FsZVhZO1xyXG5mdW5jdGlvbiogcHVsc2F0ZSh0aW1lcywgYW1wbGl0dWRlKSB7XHJcbiAgICB0aW1lcyAqPSAyO1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aW1lczsgaSsrKVxyXG4gICAgICAgIHlpZWxkIGkgJSAyID09IDEgPyAxIDogKDEgLSBhbXBsaXR1ZGUpICsgKChpIC8gdGltZXMpICogYW1wbGl0dWRlKTtcclxufVxyXG5mdW5jdGlvbiBwdWxzYXRlVHJhbnNmb3JtKHRpbWVzLCBhbXBsaXR1ZGUsIHRyYW5zZm9ybSkge1xyXG4gICAgcmV0dXJuIEFycmF5LmZyb20ocHVsc2F0ZSh0aW1lcywgYW1wbGl0dWRlKSkubWFwKHRyYW5zZm9ybSk7XHJcbn1cclxuZnVuY3Rpb24gb25lTWludXModHJhbnNmb3JtKSB7XHJcbiAgICByZXR1cm4gc2NhbGUgPT4gdHJhbnNmb3JtKDEgLSBzY2FsZSk7XHJcbn1cclxuZnVuY3Rpb24gY3JlYXRlUHVsc2F0b3IodHJhbnNmb3JtKSB7XHJcbiAgICByZXR1cm4gKHRpbWVzID0gNSwgYW1wbGl0dWRlID0gdGltZXMgLyAxMCkgPT4gcHVsc2F0ZVRyYW5zZm9ybSh0aW1lcywgYW1wbGl0dWRlLCB0cmFuc2Zvcm0pO1xyXG59XHJcbmV4cG9ydHMud29iYmxlWCA9IGNyZWF0ZVB1bHNhdG9yKHNjYWxlWCk7XHJcbmV4cG9ydHMud29iYmxlWSA9IGNyZWF0ZVB1bHNhdG9yKHNjYWxlWSk7XHJcbmV4cG9ydHMud29iYmxlWFkgPSBjcmVhdGVQdWxzYXRvcihzY2FsZVhZKTtcclxuZXhwb3J0cy5ib3VuY2VMZWZ0ID0gY3JlYXRlUHVsc2F0b3Iob25lTWludXMoc2hpZnRMZWZ0KSk7XHJcbmV4cG9ydHMuYm91bmNlUmlnaHQgPSBjcmVhdGVQdWxzYXRvcihvbmVNaW51cyhzaGlmdFJpZ2h0KSk7XHJcbmV4cG9ydHMuYm91bmNlVXAgPSBjcmVhdGVQdWxzYXRvcihvbmVNaW51cyhzaGlmdFVwKSk7XHJcbmV4cG9ydHMuYm91bmNlRG93biA9IGNyZWF0ZVB1bHNhdG9yKG9uZU1pbnVzKHNoaWZ0RG93bikpO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1hbmltYXRlZC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcclxudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xyXG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9KTtcclxufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcclxuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XHJcbiAgICBvW2syXSA9IG1ba107XHJcbn0pKTtcclxudmFyIF9fc2V0TW9kdWxlRGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19zZXRNb2R1bGVEZWZhdWx0KSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCB2KSB7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgXCJkZWZhdWx0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHYgfSk7XHJcbn0pIDogZnVuY3Rpb24obywgdikge1xyXG4gICAgb1tcImRlZmF1bHRcIl0gPSB2O1xyXG59KTtcclxudmFyIF9faW1wb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnRTdGFyKSB8fCBmdW5jdGlvbiAobW9kKSB7XHJcbiAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xyXG4gICAgdmFyIHJlc3VsdCA9IHt9O1xyXG4gICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkgaWYgKGsgIT09IFwiZGVmYXVsdFwiICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSBfX2NyZWF0ZUJpbmRpbmcocmVzdWx0LCBtb2QsIGspO1xyXG4gICAgX19zZXRNb2R1bGVEZWZhdWx0KHJlc3VsdCwgbW9kKTtcclxuICAgIHJldHVybiByZXN1bHQ7XHJcbn07XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuZXhwb3J0cy5jdXN0b21BbmltID0gZXhwb3J0cy5DdXN0b21BbmltID0gdm9pZCAwO1xyXG5jb25zdCBhbiA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwiLi9hbmltXCIpKTtcclxuY2xhc3MgQ3VzdG9tQW5pbSBleHRlbmRzIGFuLkFuaW0ge1xyXG4gICAgY29uc3RydWN0b3IodGFyZ2V0LCBhY3Rpb24sIGR1cmF0aW9uID0gMTAwMCkge1xyXG4gICAgICAgIHN1cGVyKHRhcmdldCwgZHVyYXRpb24pO1xyXG4gICAgICAgIHRoaXMuYWN0aW9uID0gYWN0aW9uO1xyXG4gICAgfVxyXG4gICAgcnVuKHJlc29sdmUpIHtcclxuICAgICAgICB0aGlzLmFjdGlvbih0aGlzKTtcclxuICAgICAgICByZXNvbHZlKHRoaXMpO1xyXG4gICAgfVxyXG59XHJcbmV4cG9ydHMuQ3VzdG9tQW5pbSA9IEN1c3RvbUFuaW07XHJcbmZ1bmN0aW9uIGN1c3RvbUFuaW0odGFyZ2V0LCBhY3Rpb24sIGR1cmF0aW9uID0gMTAwMCkge1xyXG4gICAgcmV0dXJuIG5ldyBDdXN0b21BbmltKHRhcmdldCwgYWN0aW9uLCBkdXJhdGlvbik7XHJcbn1cclxuZXhwb3J0cy5jdXN0b21BbmltID0gY3VzdG9tQW5pbTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y3VzdG9tLWFuaW0uanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcclxuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfSk7XHJcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XHJcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xyXG4gICAgb1trMl0gPSBtW2tdO1xyXG59KSk7XHJcbnZhciBfX2V4cG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9fZXhwb3J0U3RhcikgfHwgZnVuY3Rpb24obSwgZXhwb3J0cykge1xyXG4gICAgZm9yICh2YXIgcCBpbiBtKSBpZiAocCAhPT0gXCJkZWZhdWx0XCIgJiYgIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChleHBvcnRzLCBwKSkgX19jcmVhdGVCaW5kaW5nKGV4cG9ydHMsIG0sIHApO1xyXG59O1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9hbmltYXRlZFwiKSwgZXhwb3J0cyk7XHJcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9hbmltXCIpLCBleHBvcnRzKTtcclxuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2tleWZyYW1lLWFuaW1cIiksIGV4cG9ydHMpO1xyXG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vY3VzdG9tLWFuaW1cIiksIGV4cG9ydHMpO1xyXG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vYW5pbWF0ZWQtdmlld1wiKSwgZXhwb3J0cyk7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xyXG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XHJcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH0pO1xyXG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xyXG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcclxuICAgIG9bazJdID0gbVtrXTtcclxufSkpO1xyXG52YXIgX19zZXRNb2R1bGVEZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX3NldE1vZHVsZURlZmF1bHQpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIHYpIHtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBcImRlZmF1bHRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdiB9KTtcclxufSkgOiBmdW5jdGlvbihvLCB2KSB7XHJcbiAgICBvW1wiZGVmYXVsdFwiXSA9IHY7XHJcbn0pO1xyXG52YXIgX19pbXBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydFN0YXIpIHx8IGZ1bmN0aW9uIChtb2QpIHtcclxuICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XHJcbiAgICB2YXIgcmVzdWx0ID0ge307XHJcbiAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoayAhPT0gXCJkZWZhdWx0XCIgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIF9fY3JlYXRlQmluZGluZyhyZXN1bHQsIG1vZCwgayk7XHJcbiAgICBfX3NldE1vZHVsZURlZmF1bHQocmVzdWx0LCBtb2QpO1xyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxufTtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5leHBvcnRzLnNwcmVhZEFyb3VuZCA9IGV4cG9ydHMuZmFkZUluT3V0ID0gZXhwb3J0cy5mYWRlT3V0ID0gZXhwb3J0cy5mYWRlSW4gPSBleHBvcnRzLnpvb21JbiA9IGV4cG9ydHMuc2xpZGVPdXRCb3R0b20gPSBleHBvcnRzLnNsaWRlT3V0VG9wID0gZXhwb3J0cy5zbGlkZU91dFJpZ2h0ID0gZXhwb3J0cy5zbGlkZU91dExlZnQgPSBleHBvcnRzLnNsaWRlSW5Cb3R0b20gPSBleHBvcnRzLnNsaWRlSW5Ub3AgPSBleHBvcnRzLnNsaWRlSW5SaWdodCA9IGV4cG9ydHMuc2xpZGVJbkxlZnQgPSBleHBvcnRzLnNsaWRlVG8gPSBleHBvcnRzLnZpc2libGUgPSBleHBvcnRzLmludmlzaWJsZSA9IGV4cG9ydHMuS2V5ZnJhbWVBbmltID0gdm9pZCAwO1xyXG5jb25zdCBhZCA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwiLi9hbmltYXRlZFwiKSk7XHJcbmNvbnN0IGFuID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCIuL2FuaW1cIikpO1xyXG5jbGFzcyBLZXlmcmFtZUFuaW0gZXh0ZW5kcyBhbi5BbmltIHtcclxuICAgIGNvbnN0cnVjdG9yKHRhcmdldCwga2V5ZnJhbWVzLCBkdXJhdGlvbiA9IDEwMDAsIGZpbGwgPSBcImJvdGhcIiwgZGlyZWN0aW9uID0gXCJub3JtYWxcIiwgaXRlcmF0aW9ucyA9IDEpIHtcclxuICAgICAgICBzdXBlcih0YXJnZXQsIGR1cmF0aW9uKTtcclxuICAgICAgICB0aGlzLmtleWZyYW1lcyA9IGtleWZyYW1lcztcclxuICAgICAgICB0aGlzLmZpbGwgPSBmaWxsO1xyXG4gICAgICAgIHRoaXMuZGlyZWN0aW9uID0gZGlyZWN0aW9uO1xyXG4gICAgICAgIHRoaXMuaXRlcmF0aW9ucyA9IGl0ZXJhdGlvbnM7XHJcbiAgICB9XHJcbiAgICBzdG9wT24oZXZlbnQpIHtcclxuICAgICAgICB0aGlzLnN0b3BFdmVudCA9IGV2ZW50O1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG4gICAgZ2V0S2V5ZnJhbWUoa2YpIHtcclxuICAgICAgICBpZiAodHlwZW9mIGtmID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgICAgIGlmICghKHRoaXMudGFyZ2V0IGluc3RhbmNlb2YgYWQuQW5pbWF0ZWQpKVxyXG4gICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJUYXJnZXQgbm90IG9mIHR5cGUgQW5pbWF0ZWRcIik7XHJcbiAgICAgICAgICAgIGxldCBzdGF0ZSA9IGtmKHRoaXMudGFyZ2V0KTtcclxuICAgICAgICAgICAgdGhpcy50YXJnZXQuc3RhdGUgPSBzdGF0ZTtcclxuICAgICAgICAgICAgcmV0dXJuIHN0YXRlLnRvS2V5ZnJhbWUoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGtmO1xyXG4gICAgfVxyXG4gICAgcnVuKHJlc29sdmUpIHtcclxuICAgICAgICBsZXQgYSA9IHRoaXMudGFyZ2V0LmVsZW1lbnQuYW5pbWF0ZSh0aGlzLmtleWZyYW1lcy5tYXAoa2YgPT4gdGhpcy5nZXRLZXlmcmFtZShrZikpLCB7XHJcbiAgICAgICAgICAgIGR1cmF0aW9uOiB0aGlzLmR1cmF0aW9uLFxyXG4gICAgICAgICAgICBmaWxsOiB0aGlzLmZpbGwsXHJcbiAgICAgICAgICAgIGRpcmVjdGlvbjogdGhpcy5kaXJlY3Rpb24sXHJcbiAgICAgICAgICAgIGl0ZXJhdGlvbnM6IHRoaXMuaXRlcmF0aW9uc1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGEub25maW5pc2ggPSAoKSA9PiByZXNvbHZlKHRoaXMpO1xyXG4gICAgICAgIGEub25jYW5jZWwgPSAoKSA9PiByZXNvbHZlKHRoaXMpO1xyXG4gICAgICAgIGlmICh0aGlzLnN0b3BFdmVudClcclxuICAgICAgICAgICAgdGhpcy50YXJnZXQuZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKHRoaXMuc3RvcEV2ZW50LCAoKSA9PiBhLmNhbmNlbCgpKTtcclxuICAgIH1cclxufVxyXG5leHBvcnRzLktleWZyYW1lQW5pbSA9IEtleWZyYW1lQW5pbTtcclxuZnVuY3Rpb24gaW52aXNpYmxlKCkgeyByZXR1cm4geyBvcGFjaXR5OiAwIH07IH1cclxuZXhwb3J0cy5pbnZpc2libGUgPSBpbnZpc2libGU7XHJcbmZ1bmN0aW9uIHZpc2libGUoKSB7IHJldHVybiB7IG9wYWNpdHk6IDEgfTsgfVxyXG5leHBvcnRzLnZpc2libGUgPSB2aXNpYmxlO1xyXG5mdW5jdGlvbiBzbGlkZVRvKGVsZW0sIHBvcywgZHVyYXRpb24gPSAxMDAwKSB7XHJcbiAgICBsZXQgW3gsIHldID0gcG9zO1xyXG4gICAgcmV0dXJuIG5ldyBLZXlmcmFtZUFuaW0oZWxlbSwgW2FkLmN1cnJlbnQsIGFkLm1vdmUoeCwgeSldLCBkdXJhdGlvbik7XHJcbn1cclxuZXhwb3J0cy5zbGlkZVRvID0gc2xpZGVUbztcclxuZnVuY3Rpb24gY3JlYXRlU2xpZGVJbihtb3ZlLCBib3VuY2UpIHtcclxuICAgIHJldHVybiAoZWxlbSwgZGlzdGFuY2UgPSAxLCBkdXJhdGlvbiA9IDEwMDApID0+IHtcclxuICAgICAgICBsZXQga2ZzID0gW21vdmUoZGlzdGFuY2UpLCBtb3ZlKDApXS5jb25jYXQoYm91bmNlKDIpKTtcclxuICAgICAgICBrZnNbMV0gPSBhZC5vZmZzZXQoa2ZzWzFdLCAwLjUgKyBNYXRoLm1pbihkdXJhdGlvbiAvIDEwMDAwLCAwLjUpKTtcclxuICAgICAgICByZXR1cm4gbmV3IEtleWZyYW1lQW5pbShlbGVtLCBrZnMsIGR1cmF0aW9uKTtcclxuICAgIH07XHJcbn1cclxuZnVuY3Rpb24gY3JlYXRlU2xpZGVPdXQobW92ZSkge1xyXG4gICAgcmV0dXJuIChlbGVtLCBkaXN0YW5jZSA9IDEsIGR1cmF0aW9uID0gMTAwMCkgPT4ge1xyXG4gICAgICAgIGxldCBrZnMgPSAoW21vdmUoMCksIG1vdmUoLWRpc3RhbmNlIC8gMjApLCBtb3ZlKGRpc3RhbmNlKV0pO1xyXG4gICAgICAgIGtmc1sxXSA9IGFkLm9mZnNldChrZnNbMV0sIDAuMik7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBLZXlmcmFtZUFuaW0oZWxlbSwga2ZzLCBkdXJhdGlvbik7XHJcbiAgICB9O1xyXG59XHJcbmV4cG9ydHMuc2xpZGVJbkxlZnQgPSBjcmVhdGVTbGlkZUluKGFkLnNoaWZ0TGVmdCwgYWQuYm91bmNlTGVmdCk7XHJcbmV4cG9ydHMuc2xpZGVJblJpZ2h0ID0gY3JlYXRlU2xpZGVJbihhZC5zaGlmdFJpZ2h0LCBhZC5ib3VuY2VSaWdodCk7XHJcbmV4cG9ydHMuc2xpZGVJblRvcCA9IGNyZWF0ZVNsaWRlSW4oYWQuc2hpZnRVcCwgYWQuYm91bmNlVXApO1xyXG5leHBvcnRzLnNsaWRlSW5Cb3R0b20gPSBjcmVhdGVTbGlkZUluKGFkLnNoaWZ0RG93biwgYWQuYm91bmNlRG93bik7XHJcbmV4cG9ydHMuc2xpZGVPdXRMZWZ0ID0gY3JlYXRlU2xpZGVPdXQoYWQuc2hpZnRMZWZ0KTtcclxuZXhwb3J0cy5zbGlkZU91dFJpZ2h0ID0gY3JlYXRlU2xpZGVPdXQoYWQuc2hpZnRSaWdodCk7XHJcbmV4cG9ydHMuc2xpZGVPdXRUb3AgPSBjcmVhdGVTbGlkZU91dChhZC5zaGlmdFVwKTtcclxuZXhwb3J0cy5zbGlkZU91dEJvdHRvbSA9IGNyZWF0ZVNsaWRlT3V0KGFkLnNoaWZ0RG93bik7XHJcbmZ1bmN0aW9uIHpvb21JbihlbGVtLCBkdXJhdGlvbiA9IDEwMDApIHtcclxuICAgIGxldCBrZnMgPSBbYWQuc2NhbGVYWSgwKSwgYWQuc2NhbGVYWSgxKV0uY29uY2F0KGFkLndvYmJsZVhZKDIpKTtcclxuICAgIGtmc1sxXSA9IGFkLm9mZnNldChrZnNbMV0sIDAuNSArIE1hdGgubWluKGR1cmF0aW9uIC8gMTAwMDAsIDAuNSkpO1xyXG4gICAgcmV0dXJuIG5ldyBLZXlmcmFtZUFuaW0oZWxlbSwga2ZzLCBkdXJhdGlvbik7XHJcbn1cclxuZXhwb3J0cy56b29tSW4gPSB6b29tSW47XHJcbmZ1bmN0aW9uIGZhZGVJbihlbGVtLCBkdXJhdGlvbiA9IDEwMDApIHtcclxuICAgIHJldHVybiBuZXcgS2V5ZnJhbWVBbmltKGVsZW0sIFtpbnZpc2libGUoKSwgdmlzaWJsZSgpXSwgZHVyYXRpb24pO1xyXG59XHJcbmV4cG9ydHMuZmFkZUluID0gZmFkZUluO1xyXG5mdW5jdGlvbiBmYWRlT3V0KGVsZW0sIGR1cmF0aW9uID0gMTAwMCkge1xyXG4gICAgcmV0dXJuIG5ldyBLZXlmcmFtZUFuaW0oZWxlbSwgW3Zpc2libGUoKSwgaW52aXNpYmxlKCldLCBkdXJhdGlvbik7XHJcbn1cclxuZXhwb3J0cy5mYWRlT3V0ID0gZmFkZU91dDtcclxuZnVuY3Rpb24gZmFkZUluT3V0KGVsZW0sIGR1cmF0aW9uID0gMTAwMCwgaXRlcmF0aW9ucyA9IDEpIHtcclxuICAgIHJldHVybiBuZXcgS2V5ZnJhbWVBbmltKGVsZW0sIFtpbnZpc2libGUoKSwgdmlzaWJsZSgpXSwgZHVyYXRpb24sIFwiYXV0b1wiLCBcImFsdGVybmF0ZVwiLCBpdGVyYXRpb25zICogMik7XHJcbn1cclxuZXhwb3J0cy5mYWRlSW5PdXQgPSBmYWRlSW5PdXQ7XHJcbmZ1bmN0aW9uIHNlbWlDaXJjbGVQb3NpdGlvbnMoY291bnQsIHJhZGl1cykge1xyXG4gICAgbGV0IHJlcyA9IG5ldyBBcnJheShjb3VudCk7XHJcbiAgICBsZXQgYW5nbGUgPSBNYXRoLlBJIC8gKGNvdW50ICsgMSk7XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvdW50OyBpKyspIHtcclxuICAgICAgICBsZXQgeCA9IC1NYXRoLmNvcygoaSArIDEpICogYW5nbGUpICogcmFkaXVzO1xyXG4gICAgICAgIGxldCB5ID0gLU1hdGguc2luKChpICsgMSkgKiBhbmdsZSkgKiByYWRpdXM7XHJcbiAgICAgICAgcmVzW2ldID0gW3gsIHldO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJlcztcclxufVxyXG5mdW5jdGlvbiBzcHJlYWRBcm91bmQoZWxlbXMsIHJhZGl1cywgZHVyYXRpb24pIHtcclxuICAgIGxldCBwb3MgPSBzZW1pQ2lyY2xlUG9zaXRpb25zKGVsZW1zLmxlbmd0aCwgcmFkaXVzKTtcclxuICAgIHJldHVybiBlbGVtcy5tYXAoKGUsIGkpID0+IHtcclxuICAgICAgICBsZXQgW3gsIHldID0gcG9zW2ldO1xyXG4gICAgICAgIHJldHVybiBuZXcgS2V5ZnJhbWVBbmltKGUsIFthZC5tb3ZlUmVsYXRpdmUoMCwgMCksIGFkLm1vdmVSZWxhdGl2ZSh4LCB5KV0sIGR1cmF0aW9uKTtcclxuICAgIH0pO1xyXG59XHJcbmV4cG9ydHMuc3ByZWFkQXJvdW5kID0gc3ByZWFkQXJvdW5kO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1rZXlmcmFtZS1hbmltLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xyXG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XHJcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH0pO1xyXG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xyXG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcclxuICAgIG9bazJdID0gbVtrXTtcclxufSkpO1xyXG52YXIgX19zZXRNb2R1bGVEZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX3NldE1vZHVsZURlZmF1bHQpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIHYpIHtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBcImRlZmF1bHRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdiB9KTtcclxufSkgOiBmdW5jdGlvbihvLCB2KSB7XHJcbiAgICBvW1wiZGVmYXVsdFwiXSA9IHY7XHJcbn0pO1xyXG52YXIgX19pbXBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydFN0YXIpIHx8IGZ1bmN0aW9uIChtb2QpIHtcclxuICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XHJcbiAgICB2YXIgcmVzdWx0ID0ge307XHJcbiAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoayAhPT0gXCJkZWZhdWx0XCIgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIF9fY3JlYXRlQmluZGluZyhyZXN1bHQsIG1vZCwgayk7XHJcbiAgICBfX3NldE1vZHVsZURlZmF1bHQocmVzdWx0LCBtb2QpO1xyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxufTtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5leHBvcnRzLmRpZ3JhcGggPSBleHBvcnRzLmVkZ2VzID0gZXhwb3J0cy5ub2RlcyA9IGV4cG9ydHMuQXJyb3dQb3MgPSB2b2lkIDA7XHJcbmNvbnN0IHN2ZyA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwiLi9zdmdcIikpO1xyXG5jb25zdCBhbmltID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCIuL2FuaW1cIikpO1xyXG5jb25zdCBkYWdyZSA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwiZGFncmVcIikpO1xyXG52YXIgQXJyb3dQb3M7XHJcbihmdW5jdGlvbiAoQXJyb3dQb3MpIHtcclxuICAgIEFycm93UG9zW0Fycm93UG9zW1wiU291cmNlXCJdID0gMF0gPSBcIlNvdXJjZVwiO1xyXG4gICAgQXJyb3dQb3NbQXJyb3dQb3NbXCJEZXN0aW5hdGlvblwiXSA9IDFdID0gXCJEZXN0aW5hdGlvblwiO1xyXG59KShBcnJvd1BvcyA9IGV4cG9ydHMuQXJyb3dQb3MgfHwgKGV4cG9ydHMuQXJyb3dQb3MgPSB7fSkpO1xyXG5jb25zdCBkZWZhdWx0Tm9kZXNlcCA9IDE2O1xyXG5jb25zdCBkZWZhdWx0UmFua3NlcCA9IDE2O1xyXG5mdW5jdGlvbiBub2RlcyguLi5ub2Rlcykge1xyXG4gICAgcmV0dXJuIG5vZGVzLm1hcChuID0+IHtcclxuICAgICAgICByZXR1cm4gdHlwZW9mIChuKSA9PSAnc3RyaW5nJyA/XHJcbiAgICAgICAgICAgIHsgbmFtZTogbiwgbGFiZWw6IG4gfSA6XHJcbiAgICAgICAgICAgIHsgbmFtZTogblswXSwgbGFiZWw6IG5bMV0gfTtcclxuICAgIH0pO1xyXG59XHJcbmV4cG9ydHMubm9kZXMgPSBub2RlcztcclxuZnVuY3Rpb24gZWRnZXMoZWRnZXMsIGFycm93KSB7XHJcbiAgICByZXR1cm4gZWRnZXMubWFwKGUgPT4ge1xyXG4gICAgICAgIHJldHVybiBlLmxlbmd0aCA8IDMgP1xyXG4gICAgICAgICAgICB7IGFycm93LCBzb3VyY2U6IGVbMF0sIGRlc3RpbmF0aW9uOiBlWzFdIH0gOlxyXG4gICAgICAgICAgICB7IGFycm93LCBzb3VyY2U6IGVbMF0sIGRlc3RpbmF0aW9uOiBlWzFdLCBsYWJlbDogZVsyXSB9O1xyXG4gICAgfSk7XHJcbn1cclxuZXhwb3J0cy5lZGdlcyA9IGVkZ2VzO1xyXG5mdW5jdGlvbiBkcmF3Tm9kZShub2RlLCBwYXJlbnQsIG1hcmdpbiA9IDEwKSB7XHJcbiAgICBsZXQgZ3JvdXAgPSBzdmcuZ3JvdXAocGFyZW50KTtcclxuICAgIGxldCBwID0gbm9kZS5saW5rID8gc3ZnLmxpbmsoZ3JvdXAsIG5vZGUubGluaykgOiBncm91cDtcclxuICAgIGxldCB0ZXh0ID0gc3ZnLnRleHQocCwgbm9kZS5sYWJlbCk7XHJcbiAgICBsZXQgYmIgPSB0ZXh0LmJib3guaW5mbGF0ZShtYXJnaW4sIG1hcmdpbik7XHJcbiAgICBsZXQgc2hhcGUgPSBub2RlLnNoYXBlIHx8IHN2Zy5yZWN0O1xyXG4gICAgc2hhcGUocCwgYmIubGVmdCwgYmIudG9wLCBiYi53aWR0aCwgYmIuaGVpZ2h0KS5tb3ZlVG9CYWNrKCk7XHJcbiAgICBncm91cC50cmFuc2xhdGUoc3ZnLlJlY3RQb3MuQ2VudGVyKTtcclxuICAgIG5vZGUuZWxlbSA9IGdyb3VwLmFkZENsYXNzKFwibm9kZVwiKTtcclxufVxyXG5mdW5jdGlvbiBkcmF3RWRnZUxhYmVsKGVkZ2UsIHBhcmVudCkge1xyXG4gICAgbGV0IHRleHQgPSBzdmcudGV4dChwYXJlbnQsIGVkZ2UubGFiZWwpO1xyXG4gICAgdGV4dC50cmFuc2xhdGUoc3ZnLlJlY3RQb3MuQ2VudGVyKTtcclxuICAgIGVkZ2UuZWxlbSA9IHRleHQuYWRkQ2xhc3MoXCJlZGdlbGFiZWxcIik7XHJcbn1cclxuZnVuY3Rpb24gYWRkQXJyb3coYXJyb3csIHN2Z3Jvb3QsIHBhdGgpIHtcclxuICAgIGlmICghYXJyb3cuZWxlbSlcclxuICAgICAgICBhcnJvdy5lbGVtID0gc3ZnLmFycm93KHN2Z3Jvb3QuY2hpbGQoJ2RlZnMnKSwgYXJyb3cud2lkdGgsIGFycm93Lmxlbmd0aCwgYXJyb3cuY2xvc2VkKS5hZGRDbGFzcyhhcnJvdy5jbGFzc05hbWUpO1xyXG4gICAgaWYgKGFycm93LnBvc2l0aW9ucy5pbmNsdWRlcyhBcnJvd1Bvcy5Tb3VyY2UpKVxyXG4gICAgICAgIHN2Zy5zZXRNYXJrZXIocGF0aCwgYXJyb3cuZWxlbSwgc3ZnLk1hcmtlclBvcy5TdGFydCk7XHJcbiAgICBpZiAoYXJyb3cucG9zaXRpb25zLmluY2x1ZGVzKEFycm93UG9zLkRlc3RpbmF0aW9uKSlcclxuICAgICAgICBzdmcuc2V0TWFya2VyKHBhdGgsIGFycm93LmVsZW0sIHN2Zy5NYXJrZXJQb3MuRW5kKTtcclxufVxyXG5mdW5jdGlvbiBkaXN0KHB0MSwgcHQyKSB7XHJcbiAgICBsZXQgZHggPSBwdDEueCAtIHB0Mi54O1xyXG4gICAgbGV0IGR5ID0gcHQxLnkgLSBwdDIueTtcclxuICAgIHJldHVybiBNYXRoLnNxcnQoZHggKiBkeCArIGR5ICogZHkpO1xyXG59XHJcbmZ1bmN0aW9uIGRyYXdFZGdlKGVkZ2UsIHN2Z3Jvb3QsIHBhcmVudCwgYXJyb3csIGN1cnZlZEVkZ2VzLCByYW5rc2VwKSB7XHJcbiAgICBsZXQgcCA9IGVkZ2UucG9pbnRzO1xyXG4gICAgbGV0IGNtZHMgPSBbbmV3IHN2Zy5Nb3ZlVG8oJ00nLCBwWzBdLngsIHBbMF0ueSldO1xyXG4gICAgbGV0IGxlbiA9IHAubGVuZ3RoO1xyXG4gICAgbGV0IGkgPSAxO1xyXG4gICAgd2hpbGUgKGkgPCBsZW4pXHJcbiAgICAgICAgaWYgKCFjdXJ2ZWRFZGdlcyB8fFxyXG4gICAgICAgICAgICAobGVuIDw9IDMgJiYgKGkgPT0gbGVuIC0gMSB8fCBkaXN0KHBbaV0sIHBbaSArIDFdKSA8IHJhbmtzZXApKSkge1xyXG4gICAgICAgICAgICBjbWRzLnB1c2gobmV3IHN2Zy5MaW5lVG8oJ0wnLCBwW2ldLngsIHBbaV0ueSkpO1xyXG4gICAgICAgICAgICBpKys7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGkgPCBsZW4gLSAxKSB7XHJcbiAgICAgICAgICAgIGNtZHMucHVzaChuZXcgc3ZnLkNvbnRDdWJpY0N1cnZlVG8oJ1MnLCBwW2ldLngsIHBbaV0ueSwgcFtpICsgMV0ueCwgcFtpICsgMV0ueSkpO1xyXG4gICAgICAgICAgICBpICs9IDI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBjbWRzLnB1c2gobmV3IHN2Zy5Db250UXVhZEN1cnZlVG8oJ1QnLCBwW2ldLngsIHBbaV0ueSkpO1xyXG4gICAgICAgICAgICBpKys7XHJcbiAgICAgICAgfVxyXG4gICAgbGV0IHJlcyA9IHN2Zy5wYXRoKHBhcmVudCwgY21kcykuYWRkQ2xhc3MoXCJlZGdlXCIpO1xyXG4gICAgaWYgKGFycm93KVxyXG4gICAgICAgIGFkZEFycm93KGFycm93LCBzdmdyb290LCByZXMpO1xyXG4gICAgcmV0dXJuIHJlcy5tb3ZlVG9CYWNrKCk7XHJcbn1cclxuZnVuY3Rpb24gZGVmaW5lRGlncmFwaChkaWdyYXBoLCBzdmdyb290LCB2aWV3cG9ydCwgZGcpIHtcclxuICAgIGRpZ3JhcGgubm9kZXMuZm9yRWFjaChub2RlID0+IHtcclxuICAgICAgICBkcmF3Tm9kZShub2RlLCB2aWV3cG9ydCwgZGlncmFwaC5ub2RlTWFyZ2luKTtcclxuICAgICAgICBsZXQgYmJveCA9IG5vZGUuZWxlbS5iYm94O1xyXG4gICAgICAgIGRnLnNldE5vZGUobm9kZS5uYW1lLCB7XHJcbiAgICAgICAgICAgIGxhYmVsOiBub2RlLmxhYmVsLFxyXG4gICAgICAgICAgICB3aWR0aDogYmJveC53aWR0aCxcclxuICAgICAgICAgICAgaGVpZ2h0OiBiYm94LmhlaWdodFxyXG4gICAgICAgIH0pO1xyXG4gICAgfSk7XHJcbiAgICBkaWdyYXBoLmVkZ2VzLmZvckVhY2goZWRnZSA9PiB7XHJcbiAgICAgICAgaWYgKGVkZ2UubGFiZWwpIHtcclxuICAgICAgICAgICAgZHJhd0VkZ2VMYWJlbChlZGdlLCB2aWV3cG9ydCk7XHJcbiAgICAgICAgICAgIGxldCB7IHdpZHRoLCBoZWlnaHQgfSA9IGVkZ2UuZWxlbS5iYm94O1xyXG4gICAgICAgICAgICBkZy5zZXRFZGdlKGVkZ2Uuc291cmNlLm5hbWUsIGVkZ2UuZGVzdGluYXRpb24ubmFtZSwge1xyXG4gICAgICAgICAgICAgICAgbGFiZWw6IGVkZ2UubGFiZWwsXHJcbiAgICAgICAgICAgICAgICBsYWJlbHBvczogZGlncmFwaC5lZGdlTGFiZWxQb3MgfHwgJ3InLFxyXG4gICAgICAgICAgICAgICAgd2lkdGgsIGhlaWdodFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICBkZy5zZXRFZGdlKGVkZ2Uuc291cmNlLm5hbWUsIGVkZ2UuZGVzdGluYXRpb24ubmFtZSk7XHJcbiAgICB9KTtcclxufVxyXG5mdW5jdGlvbiBsYXlvdXREaWdyYXBoKGRpZ3JhcGgsIHN2Z3Jvb3QsIHZpZXdwb3J0LCBkZykge1xyXG4gICAgZGlncmFwaC5ub2Rlcy5mb3JFYWNoKG5vZGUgPT4ge1xyXG4gICAgICAgIGxldCBkbiA9IGRnLm5vZGUobm9kZS5uYW1lKTtcclxuICAgICAgICBsZXQgZSA9IG5vZGUuZWxlbTtcclxuICAgICAgICBlLnRyYW5zZm9ybSA9IGUudHJhbnNmb3JtLnRyYW5zbGF0ZShkbi54LCBkbi55KTtcclxuICAgIH0pO1xyXG4gICAgZGlncmFwaC5lZGdlcy5mb3JFYWNoKGVkZ2UgPT4ge1xyXG4gICAgICAgIGxldCBkZSA9IGRnLmVkZ2UoZWRnZS5zb3VyY2UubmFtZSwgZWRnZS5kZXN0aW5hdGlvbi5uYW1lKTtcclxuICAgICAgICBkcmF3RWRnZShkZSwgc3Zncm9vdCwgdmlld3BvcnQsIGVkZ2UuYXJyb3csIGRpZ3JhcGguY3VydmVkRWRnZXMsIGRpZ3JhcGgucmFua3NlcCB8fCBkZWZhdWx0UmFua3NlcCk7XHJcbiAgICAgICAgbGV0IGUgPSBlZGdlLmVsZW07XHJcbiAgICAgICAgaWYgKGUpXHJcbiAgICAgICAgICAgIGUudHJhbnNmb3JtID0gZS50cmFuc2Zvcm0udHJhbnNsYXRlKGRlLngsIGRlLnkpO1xyXG4gICAgfSk7XHJcbn1cclxuZnVuY3Rpb24gY3JlYXRlRGlncmFwaChkaWdyYXBoLCBwYXJlbnQpIHtcclxuICAgIGxldCBzdmdyb290ID0gc3ZnLmNyZWF0ZSgnc3ZnJywgcGFyZW50KS5hZGRDbGFzcyhcImRpZ3JhcGhcIilcclxuICAgICAgICAuc3R5bGVzKHsgY3Vyc29yOiBcInpvb20taW5cIiB9KTtcclxuICAgIHN2Zy5kZWZzKHN2Z3Jvb3QpO1xyXG4gICAgbGV0IGdyYXBoID0gbmV3IGRhZ3JlLmdyYXBobGliLkdyYXBoKCk7XHJcbiAgICBncmFwaC5zZXRHcmFwaCh7XHJcbiAgICAgICAgcmFua2RpcjogZGlncmFwaC5kaXJlY3Rpb24gfHwgJ1RCJyxcclxuICAgICAgICBub2Rlc2VwOiBkaWdyYXBoLm5vZGVzZXAgfHwgZGVmYXVsdE5vZGVzZXAsXHJcbiAgICAgICAgcmFua3NlcDogZGlncmFwaC5yYW5rc2VwIHx8IGRlZmF1bHRSYW5rc2VwXHJcbiAgICB9KTtcclxuICAgIGdyYXBoLnNldERlZmF1bHRFZGdlTGFiZWwoKHYsIHcpID0+IHsgcmV0dXJuIHt9OyB9KTtcclxuICAgIGxldCB2aWV3cG9ydCA9IGFuaW0uYW5pbWF0ZWRWaWV3KHN2Z3Jvb3QpLnN0eWxlcyh7IGN1cnNvcjogXCJ6b29tLWluXCIgfSk7XHJcbiAgICBkZWZpbmVEaWdyYXBoKGRpZ3JhcGgsIHN2Z3Jvb3QsIHZpZXdwb3J0LCBncmFwaCk7XHJcbiAgICBkYWdyZS5sYXlvdXQoZ3JhcGgpO1xyXG4gICAgbGF5b3V0RGlncmFwaChkaWdyYXBoLCBzdmdyb290LCB2aWV3cG9ydCwgZ3JhcGgpO1xyXG4gICAgc3ZnLnNldEJvdW5kcyhzdmdyb290LCBkaWdyYXBoLm1hcmdpbiB8fCAxMCk7XHJcbiAgICByZXR1cm4gc3Zncm9vdC5jbGlja2VkKGUgPT4gem9vbUluT3V0KHN2Z3Jvb3QsIHZpZXdwb3J0LCBlKSk7XHJcbn1cclxubGV0IHpvb21lZCA9IGZhbHNlO1xyXG5jb25zdCB6b29tU3BlZWQgPSAzMDA7XHJcbmZ1bmN0aW9uIHpvb21Jbk91dChzdmdyb290LCB2aWV3cG9ydCwgZXZlbnQpIHtcclxuICAgIGxldCB6b29tQW5pbSA9IG51bGw7XHJcbiAgICBpZiAoIXpvb21lZCkge1xyXG4gICAgICAgIGxldCBzID0gc3Zncm9vdC5lbGVtZW50O1xyXG4gICAgICAgIGxldCBwdCA9IHMuY3JlYXRlU1ZHUG9pbnQoKTtcclxuICAgICAgICBwdC54ID0gZXZlbnQuY2xpZW50WDtcclxuICAgICAgICBwdC55ID0gZXZlbnQuY2xpZW50WTtcclxuICAgICAgICBsZXQgeyB4LCB5IH0gPSBwdC5tYXRyaXhUcmFuc2Zvcm0ocy5nZXRTY3JlZW5DVE0oKS5pbnZlcnNlKCkpO1xyXG4gICAgICAgIHpvb21BbmltID0gdmlld3BvcnQuem9vbUZhY3RvcigyLCB4LCB5LCB6b29tU3BlZWQpO1xyXG4gICAgfVxyXG4gICAgZWxzZVxyXG4gICAgICAgIHpvb21BbmltID0gdmlld3BvcnQuem9vbUhvbWUoem9vbVNwZWVkKTtcclxuICAgIHpvb21lZCA9ICF6b29tZWQ7XHJcbiAgICBzdmdyb290LnN0eWxlcyh7IGN1cnNvcjogem9vbWVkID8gXCJ6b29tLW91dFwiIDogXCJ6b29tLWluXCIgfSk7XHJcbiAgICBuZXcgYW5pbS5BbmltU2VxdWVuY2UoKS5hZGRBdCh6b29tQW5pbSwgMCkucGxheSgpO1xyXG59XHJcbmZ1bmN0aW9uIGRpZ3JhcGgoZGcsIHBhcmVudCkge1xyXG4gICAgbGV0IHN2Z3Jvb3QgPSBudWxsO1xyXG4gICAgaWYgKCFkb2N1bWVudC5mb250cyB8fCBkb2N1bWVudC5mb250cy5zdGF0dXMgPT0gXCJsb2FkZWRcIilcclxuICAgICAgICBzdmdyb290ID0gY3JlYXRlRGlncmFwaChkZywgcGFyZW50KTtcclxuICAgIGVsc2VcclxuICAgICAgICBkb2N1bWVudC5mb250cy5vbmxvYWRpbmdkb25lID0gKCkgPT4ge1xyXG4gICAgICAgICAgICBpZiAoc3Zncm9vdClcclxuICAgICAgICAgICAgICAgIHN2Z3Jvb3QuZGVsZXRlKCk7XHJcbiAgICAgICAgICAgIHN2Z3Jvb3QgPSBjcmVhdGVEaWdyYXBoKGRnLCBwYXJlbnQpO1xyXG4gICAgICAgIH07XHJcbn1cclxuZXhwb3J0cy5kaWdyYXBoID0gZGlncmFwaDtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGlncmFwaC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcclxudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xyXG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9KTtcclxufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcclxuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XHJcbiAgICBvW2syXSA9IG1ba107XHJcbn0pKTtcclxudmFyIF9fc2V0TW9kdWxlRGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19zZXRNb2R1bGVEZWZhdWx0KSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCB2KSB7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgXCJkZWZhdWx0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHYgfSk7XHJcbn0pIDogZnVuY3Rpb24obywgdikge1xyXG4gICAgb1tcImRlZmF1bHRcIl0gPSB2O1xyXG59KTtcclxudmFyIF9faW1wb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnRTdGFyKSB8fCBmdW5jdGlvbiAobW9kKSB7XHJcbiAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xyXG4gICAgdmFyIHJlc3VsdCA9IHt9O1xyXG4gICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkgaWYgKGsgIT09IFwiZGVmYXVsdFwiICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSBfX2NyZWF0ZUJpbmRpbmcocmVzdWx0LCBtb2QsIGspO1xyXG4gICAgX19zZXRNb2R1bGVEZWZhdWx0KHJlc3VsdCwgbW9kKTtcclxuICAgIHJldHVybiByZXN1bHQ7XHJcbn07XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuZXhwb3J0cy5maWxlRGlhZ3JhbSA9IGV4cG9ydHMudGVybWluYWwgPSBleHBvcnRzLmZpbGUgPSBleHBvcnRzLmZvbGRlciA9IGV4cG9ydHMudGVybWluYWxEaW1lbnNpb25zID0gZXhwb3J0cy5maWxlRGltZW5zaW9ucyA9IGV4cG9ydHMuZm9sZGVyRGltZW5zaW9ucyA9IHZvaWQgMDtcclxuY29uc3Qgc3ZnID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCIuL3N2Z1wiKSk7XHJcbmNvbnN0IGFuaW0gPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcIi4vYW5pbVwiKSk7XHJcbmV4cG9ydHMuZm9sZGVyRGltZW5zaW9ucyA9IHtcclxuICAgIHdpZHRoOiA4MCxcclxuICAgIGhlaWdodDogNjAsXHJcbiAgICByYWRpdXM6IDRcclxufTtcclxuZXhwb3J0cy5maWxlRGltZW5zaW9ucyA9IHtcclxuICAgIHdpZHRoOiA2MCxcclxuICAgIGhlaWdodDogODAsXHJcbiAgICByYWRpdXM6IDRcclxufTtcclxuZXhwb3J0cy50ZXJtaW5hbERpbWVuc2lvbnMgPSB7XHJcbiAgICB3aWR0aDogMTAwLFxyXG4gICAgaGVpZ2h0OiA4MCxcclxuICAgIHJhZGl1czogNFxyXG59O1xyXG5mdW5jdGlvbiBjb250YWluZXIzRChwYXJlbnQpIHtcclxuICAgIHJldHVybiBzdmcuZ3JvdXAocGFyZW50KS5hZGRDbGFzcyhcImNvbnRhaW5lcjNEXCIpO1xyXG59XHJcbmZ1bmN0aW9uIGljb25SZWN0KHBhcmVudCwgZGltcykge1xyXG4gICAgbGV0IHggPSBkaW1zLndpZHRoIC8gMjtcclxuICAgIGxldCB5ID0gZGltcy5oZWlnaHQgLyAyO1xyXG4gICAgcmV0dXJuIHN2Zy5yZWN0KHBhcmVudCwgLXgsIC15LCBkaW1zLndpZHRoLCBkaW1zLmhlaWdodCwgZGltcy5yYWRpdXMpO1xyXG59XHJcbmZ1bmN0aW9uIGZvbGRlcihwYXJlbnQsIGNhcHRpb24sIGRpbXMgPSBleHBvcnRzLmZvbGRlckRpbWVuc2lvbnMpIHtcclxuICAgIGxldCByZXMgPSBjb250YWluZXIzRChwYXJlbnQpO1xyXG4gICAgbGV0IGJhY2sgPSBzdmcuZ3JvdXAocmVzKS5hZGRDbGFzcyhcImZvbGRlci1iYWNrXCIpO1xyXG4gICAgaWNvblJlY3QoYmFjaywgZGltcyk7XHJcbiAgICBsZXQgeCA9IGRpbXMud2lkdGggLyAyO1xyXG4gICAgbGV0IHkgPSBkaW1zLmhlaWdodCAvIDI7XHJcbiAgICBsZXQgdHcgPSAwLjMwICogZGltcy53aWR0aDtcclxuICAgIGxldCB0aCA9IDAuMjUgKiBkaW1zLmhlaWdodDtcclxuICAgIHN2Zy5yZWN0KGJhY2ssIC14LCAteSAtICh0aCAvIDIpLCB0dywgdGgsIGRpbXMucmFkaXVzKTtcclxuICAgIGxldCBmcm9udCA9IHN2Zy5ncm91cChyZXMpLmFkZENsYXNzKFwiZm9sZGVyLWZyb250XCIpXHJcbiAgICAgICAgLnN0eWxlcyh7XHJcbiAgICAgICAgdHJhbnNmb3JtT3JpZ2luOiBgJHt4fXB4ICR7eX1weGBcclxuICAgIH0pO1xyXG4gICAgaWNvblJlY3QoZnJvbnQsIGRpbXMpO1xyXG4gICAgc3ZnLnRleHQoZnJvbnQsIGNhcHRpb24pLnRyYW5zbGF0ZShzdmcuUmVjdFBvcy5DZW50ZXIpO1xyXG4gICAgbGV0IGtmcyA9IFtcclxuICAgICAgICB7IHRyYW5zZm9ybTogJ3JvdGF0ZVgoMGRlZyknIH0sXHJcbiAgICAgICAgeyB0cmFuc2Zvcm06ICdyb3RhdGVYKDMwZGVnKScgfVxyXG4gICAgXTtcclxuICAgIHJlcy5vcGVuID0gbmV3IGFuaW0uS2V5ZnJhbWVBbmltKGZyb250LCBrZnMsIDIwMCk7XHJcbiAgICByZXMuY2xvc2UgPSBuZXcgYW5pbS5LZXlmcmFtZUFuaW0oZnJvbnQsIGtmcy5zbGljZSgpLnJldmVyc2UoKSwgMjAwKTtcclxuICAgIHJldHVybiByZXM7XHJcbn1cclxuZXhwb3J0cy5mb2xkZXIgPSBmb2xkZXI7XHJcbmZ1bmN0aW9uIGRvY0xpbmVzKGRpbXMpIHtcclxuICAgIGxldCB3ID0gZGltcy53aWR0aCAtIDIwO1xyXG4gICAgbGV0IGggPSBkaW1zLmhlaWdodCAtIDIwO1xyXG4gICAgbGV0IHJlcyA9IFtdO1xyXG4gICAgZm9yIChsZXQgeSA9IDA7IHkgPCBoOyB5ICs9IDUpIHtcclxuICAgICAgICBpZiAoTWF0aC5yYW5kb20oKSA+IDAuMikge1xyXG4gICAgICAgICAgICByZXMucHVzaChuZXcgc3ZnLk1vdmVUbyhcIk1cIiwgMCwgeSkpO1xyXG4gICAgICAgICAgICByZXMucHVzaChuZXcgc3ZnLkhMaW5lVG8oXCJoXCIsIHcgLSAoTWF0aC5yYW5kb20oKSAqIDUpKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJlcztcclxufVxyXG5mdW5jdGlvbiBmaWxlKHBhcmVudCwgdHlwZVN0ciwgY2FwdGlvbiwgZGltcyA9IGV4cG9ydHMuZmlsZURpbWVuc2lvbnMpIHtcclxuICAgIGxldCBjb250YWluZXIgPSBjb250YWluZXIzRChwYXJlbnQpO1xyXG4gICAgbGV0IGRvYyA9IHN2Zy5ncm91cChjb250YWluZXIpLmFkZENsYXNzKFwiZG9jdW1lbnRcIik7XHJcbiAgICBsZXQgbWFzayA9IHN2Zy5tYXNrKGRvYyk7XHJcbiAgICBpY29uUmVjdChtYXNrLCBkaW1zKS5hdHRycyh7XHJcbiAgICAgICAgZmlsbDogXCJ3aGl0ZVwiLFxyXG4gICAgICAgIHN0cm9rZTogXCJ3aGl0ZVwiXHJcbiAgICB9KTtcclxuICAgIGxldCBtdyA9IGRpbXMud2lkdGggLyAyO1xyXG4gICAgbGV0IG1oID0gZGltcy5oZWlnaHQgLyAyO1xyXG4gICAgbGV0IGZzaXplID0gbXcgLyAyO1xyXG4gICAgc3ZnLnBhdGgobWFzaywgYE0wIC0xIGgke213fSB2JHttd30gemApLmF0dHJzKHtcclxuICAgICAgICB0cmFuc2Zvcm06IGB0cmFuc2xhdGUoJHtmc2l6ZX0gJHstbWh9KWAsXHJcbiAgICAgICAgZmlsbDogXCJibGFja1wiLFxyXG4gICAgICAgIHN0cm9rZTogXCJibGFja1wiXHJcbiAgICB9KTtcclxuICAgIGxldCBncm91cCA9IHN2Zy5ncm91cChkb2MpLmF0dHJzKHtcclxuICAgICAgICBtYXNrOiBgdXJsKCMke21hc2suaWR9KWBcclxuICAgIH0pO1xyXG4gICAgaWNvblJlY3QoZ3JvdXAsIGRpbXMpO1xyXG4gICAgc3ZnLnBhdGgoZ3JvdXAsIGRvY0xpbmVzKGRpbXMpKS5hdHRycyh7XHJcbiAgICAgICAgXCJzdHJva2Utd2lkdGhcIjogMlxyXG4gICAgfSlcclxuICAgICAgICAudHJhbnNsYXRlKHN2Zy5SZWN0UG9zLkNlbnRlcik7XHJcbiAgICBzdmcudGV4dChncm91cCwgdHlwZVN0cikuYWRkQ2xhc3MoXCJkb2MtYmdcIik7XHJcbiAgICBzdmcucmVjdChncm91cCwgZnNpemUsIC1taCwgZnNpemUsIGZzaXplLCBkaW1zLnJhZGl1cyAvIDIpO1xyXG4gICAgc3ZnLnRleHQoZG9jLCBjYXB0aW9uKS5hZGRDbGFzcyhcImRvYy10ZXh0XCIpXHJcbiAgICAgICAgLnRyYW5zbGF0ZShzdmcuUmVjdFBvcy5DZW50ZXIsIFswLCBmc2l6ZV0pO1xyXG4gICAgcmV0dXJuIGNvbnRhaW5lcjtcclxufVxyXG5leHBvcnRzLmZpbGUgPSBmaWxlO1xyXG5mdW5jdGlvbiB0aXRsZUJ1dHRvbihwYXJlbnQsIHgsIHksIHRoKSB7XHJcbiAgICBsZXQgYmQgPSB0aCAvIDI7XHJcbiAgICBsZXQgYnIgPSB0aCAvIDQ7XHJcbiAgICByZXR1cm4gc3ZnLmVsbGlwc2UocGFyZW50LCB4IC0gYmQsIC15ICsgYmQsIGJyLCBicik7XHJcbn1cclxuZnVuY3Rpb24gdGVybWluYWwocGFyZW50LCBjYXB0aW9uLCBkaW1zID0gZXhwb3J0cy50ZXJtaW5hbERpbWVuc2lvbnMpIHtcclxuICAgIGxldCBjb250YWluZXIgPSBjb250YWluZXIzRChwYXJlbnQpO1xyXG4gICAgbGV0IHRlcm0gPSBzdmcuZ3JvdXAoY29udGFpbmVyKS5hZGRDbGFzcyhcInRlcm1pbmFsXCIpO1xyXG4gICAgaWNvblJlY3QodGVybSwgZGltcyk7XHJcbiAgICBsZXQgeCA9IGRpbXMud2lkdGggLyAyO1xyXG4gICAgbGV0IHkgPSBkaW1zLmhlaWdodCAvIDI7XHJcbiAgICBsZXQgdGggPSBkaW1zLmhlaWdodCAvIDg7XHJcbiAgICBzdmcucmVjdCh0ZXJtLCAteCwgLXksIGRpbXMud2lkdGgsIHRoLCBkaW1zLnJhZGl1cyAvIDIpXHJcbiAgICAgICAgLmFkZENsYXNzKFwidGl0bGUtYmFyXCIpO1xyXG4gICAgbGV0IHNwID0gdGggKiAwLjc1O1xyXG4gICAgdGl0bGVCdXR0b24odGVybSwgeCwgeSwgdGgpO1xyXG4gICAgdGl0bGVCdXR0b24odGVybSwgeCAtIHNwLCB5LCB0aCk7XHJcbiAgICB0aXRsZUJ1dHRvbih0ZXJtLCB4IC0gKHNwICogMiksIHksIHRoKTtcclxuICAgIGNhcHRpb24gPSBcIj5cIiArIGNhcHRpb24gKyBcIl9cIjtcclxuICAgIGxldCB0ZXh0ID0gc3ZnLnRleHQodGVybSwgY2FwdGlvbikuYWRkQ2xhc3MoXCJ0ZXJtaW5hbC10ZXh0XCIpXHJcbiAgICAgICAgLnRyYW5zbGF0ZShzdmcuUmVjdFBvcy5DZW50ZXIpO1xyXG4gICAgY29udGFpbmVyLnNldENhcHRpb24gPSB2YWx1ZSA9PiBBcnJheS5mcm9tKHsgbGVuZ3RoOiB2YWx1ZS5sZW5ndGggKyAxIH0pXHJcbiAgICAgICAgLm1hcCgoXywgaSkgPT4gYW5pbS5jdXN0b21BbmltKHRleHQsIGEgPT4gYS50YXJnZXQudGV4dCA9IFwiPlwiICsgdmFsdWUuc2xpY2UoMCwgaSkgKyBcIl9cIiwgMCkpO1xyXG4gICAgcmV0dXJuIGNvbnRhaW5lcjtcclxufVxyXG5leHBvcnRzLnRlcm1pbmFsID0gdGVybWluYWw7XHJcbmZ1bmN0aW9uIGZpbGVEaWFncmFtKHBhcmVudCwgd2lkdGgsIGhlaWdodCkge1xyXG4gICAgbGV0IHZiID0gbmV3IHN2Zy5SZWN0KDAsIDAsIHdpZHRoLCBoZWlnaHQpO1xyXG4gICAgbGV0IHJlcyA9IHN2Zy5jcmVhdGUoJ3N2ZycsIHBhcmVudCkuYWRkQ2xhc3MoXCJmaWxlLWRpYWdyYW1cIikuYXR0cnMoeyB3aWR0aDogdmIud2lkdGgsIGhlaWdodDogdmIuaGVpZ2h0IH0pO1xyXG4gICAgc3ZnLnNldFZpZXdCb3gocmVzLCB2Yik7XHJcbiAgICByZXR1cm4gcmVzO1xyXG59XHJcbmV4cG9ydHMuZmlsZURpYWdyYW0gPSBmaWxlRGlhZ3JhbTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZmlsZS1kaWFncmFtLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xyXG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XHJcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH0pO1xyXG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xyXG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcclxuICAgIG9bazJdID0gbVtrXTtcclxufSkpO1xyXG52YXIgX19zZXRNb2R1bGVEZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX3NldE1vZHVsZURlZmF1bHQpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIHYpIHtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBcImRlZmF1bHRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdiB9KTtcclxufSkgOiBmdW5jdGlvbihvLCB2KSB7XHJcbiAgICBvW1wiZGVmYXVsdFwiXSA9IHY7XHJcbn0pO1xyXG52YXIgX19pbXBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydFN0YXIpIHx8IGZ1bmN0aW9uIChtb2QpIHtcclxuICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XHJcbiAgICB2YXIgcmVzdWx0ID0ge307XHJcbiAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoayAhPT0gXCJkZWZhdWx0XCIgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIF9fY3JlYXRlQmluZGluZyhyZXN1bHQsIG1vZCwgayk7XHJcbiAgICBfX3NldE1vZHVsZURlZmF1bHQocmVzdWx0LCBtb2QpO1xyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxufTtcclxudmFyIF9fZXhwb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19leHBvcnRTdGFyKSB8fCBmdW5jdGlvbihtLCBleHBvcnRzKSB7XHJcbiAgICBmb3IgKHZhciBwIGluIG0pIGlmIChwICE9PSBcImRlZmF1bHRcIiAmJiAhT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGV4cG9ydHMsIHApKSBfX2NyZWF0ZUJpbmRpbmcoZXhwb3J0cywgbSwgcCk7XHJcbn07XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuZXhwb3J0cy5hbmltID0gZXhwb3J0cy5zdmcgPSB2b2lkIDA7XHJcbmNvbnN0IHN2ZyA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwiLi9zdmdcIikpO1xyXG5leHBvcnRzLnN2ZyA9IHN2ZztcclxuY29uc3QgYW5pbSA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwiLi9hbmltXCIpKTtcclxuZXhwb3J0cy5hbmltID0gYW5pbTtcclxuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2RpZ3JhcGhcIiksIGV4cG9ydHMpO1xyXG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vZmlsZS1kaWFncmFtXCIpLCBleHBvcnRzKTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcclxuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfSk7XHJcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XHJcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xyXG4gICAgb1trMl0gPSBtW2tdO1xyXG59KSk7XHJcbnZhciBfX3NldE1vZHVsZURlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9fc2V0TW9kdWxlRGVmYXVsdCkgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgdikge1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIFwiZGVmYXVsdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2IH0pO1xyXG59KSA6IGZ1bmN0aW9uKG8sIHYpIHtcclxuICAgIG9bXCJkZWZhdWx0XCJdID0gdjtcclxufSk7XHJcbnZhciBfX2ltcG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0U3RhcikgfHwgZnVuY3Rpb24gKG1vZCkge1xyXG4gICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcclxuICAgIHZhciByZXN1bHQgPSB7fTtcclxuICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChrICE9PSBcImRlZmF1bHRcIiAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgX19jcmVhdGVCaW5kaW5nKHJlc3VsdCwgbW9kLCBrKTtcclxuICAgIF9fc2V0TW9kdWxlRGVmYXVsdChyZXN1bHQsIG1vZCk7XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG59O1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmV4cG9ydHMubGluayA9IGV4cG9ydHMubWFzayA9IGV4cG9ydHMucG9seWdvbiA9IGV4cG9ydHMucG9seWxpbmUgPSBleHBvcnRzLnBhdGggPSBleHBvcnRzLmVsbGlwc2UgPSBleHBvcnRzLmNpcmNsZSA9IGV4cG9ydHMucmVjdCA9IGV4cG9ydHMudHNwYW4gPSBleHBvcnRzLnRleHQgPSBleHBvcnRzLmdyb3VwID0gZXhwb3J0cy5jc3MgPSBleHBvcnRzLnNldFZpZXdCb3ggPSBleHBvcnRzLmdldFZpZXdCb3ggPSBleHBvcnRzLnNldEJvdW5kcyA9IGV4cG9ydHMuZGVmcyA9IGV4cG9ydHMuY3JlYXRlID0gZXhwb3J0cy5HcmFwaEVsZW0gPSBleHBvcnRzLkVsZW0gPSBleHBvcnRzLnhsaW5rID0gZXhwb3J0cy5ucyA9IHZvaWQgMDtcclxuY29uc3QgcnQgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcIi4vcmVjdFwiKSk7XHJcbmV4cG9ydHMubnMgPSAnaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnO1xyXG5leHBvcnRzLnhsaW5rID0gJ2h0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsnO1xyXG52YXIgbGFzdEdlbklkID0gMDtcclxuY2xhc3MgRWxlbSB7XHJcbiAgICBjb25zdHJ1Y3RvcihlbGVtLCBwYXJlbnQpIHtcclxuICAgICAgICB0aGlzLmVsZW0gPSBlbGVtO1xyXG4gICAgICAgIHBhcmVudC5hcHBlbmRDaGlsZCh0aGlzLmVsZW0pO1xyXG4gICAgfVxyXG4gICAgZ2V0IGVsZW1lbnQoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZWxlbTtcclxuICAgIH1cclxuICAgIGdldCBpZCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5lbGVtLmlkO1xyXG4gICAgfVxyXG4gICAgc2V0IGlkKHZhbHVlKSB7XHJcbiAgICAgICAgdGhpcy5lbGVtLmlkID0gdmFsdWU7XHJcbiAgICB9XHJcbiAgICBnZXQgcGFyZW50KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmVsZW0ucGFyZW50RWxlbWVudDtcclxuICAgIH1cclxuICAgIGdldCBjbGFzc2VzKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmVsZW0uY2xhc3NMaXN0O1xyXG4gICAgfVxyXG4gICAgZ2V0IHN0eWxlKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmVsZW0uc3R5bGU7XHJcbiAgICB9XHJcbiAgICBnZXQgdGV4dCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5lbGVtLnRleHRDb250ZW50O1xyXG4gICAgfVxyXG4gICAgc2V0IHRleHQoY29udGVudCkge1xyXG4gICAgICAgIHRoaXMuZWxlbS50ZXh0Q29udGVudCA9IGNvbnRlbnQ7XHJcbiAgICB9XHJcbiAgICBhZGRDbGFzcyhuYW1lKSB7XHJcbiAgICAgICAgdGhpcy5lbGVtLmNsYXNzTGlzdC5hZGQobmFtZSk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcbiAgICByZW1vdmVDbGFzcyhuYW1lKSB7XHJcbiAgICAgICAgdGhpcy5lbGVtLmNsYXNzTGlzdC5yZW1vdmUobmFtZSk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcbiAgICB0b2dnbGVDbGFzcyhuYW1lKSB7XHJcbiAgICAgICAgdGhpcy5lbGVtLmNsYXNzTGlzdC50b2dnbGUobmFtZSk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcbiAgICBhdHRyKG5hbWUpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5lbGVtLmdldEF0dHJpYnV0ZShuYW1lKTtcclxuICAgIH1cclxuICAgIGF0dHJzKG9iaiwgbmFtZXNwYWNlID0gbnVsbCkge1xyXG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIG9iailcclxuICAgICAgICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgdmFsID0gb2JqW2tleV07XHJcbiAgICAgICAgICAgICAgICBpZiAodmFsIGluc3RhbmNlb2YgQXJyYXkpXHJcbiAgICAgICAgICAgICAgICAgICAgdmFsID0gdmFsLmpvaW4oXCIgXCIpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5lbGVtLnNldEF0dHJpYnV0ZU5TKG5hbWVzcGFjZSwga2V5LCB2YWwpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcbiAgICBjaGlsZCh0YWcpIHtcclxuICAgICAgICBsZXQgZWwgPSB0aGlzLmVsZW0ucXVlcnlTZWxlY3Rvcih0YWcpO1xyXG4gICAgICAgIHJldHVybiAoZWwgaW5zdGFuY2VvZiBTVkdHcmFwaGljc0VsZW1lbnQgPyBuZXcgR3JhcGhFbGVtKGVsLCB0aGlzLmVsZW0pIDpcclxuICAgICAgICAgICAgZWwgaW5zdGFuY2VvZiBTVkdFbGVtZW50ID8gbmV3IEVsZW0oZWwsIHRoaXMuZWxlbSkgOlxyXG4gICAgICAgICAgICAgICAgbnVsbCk7XHJcbiAgICB9XHJcbiAgICBzdHlsZXMob2JqKSB7XHJcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gb2JqKVxyXG4gICAgICAgICAgICBpZiAob2JqLmhhc093blByb3BlcnR5KGtleSkpXHJcbiAgICAgICAgICAgICAgICB0aGlzLmVsZW0uc3R5bGVba2V5XSA9IG9ialtrZXldO1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG4gICAgZGVsZXRlKCkge1xyXG4gICAgICAgIHRoaXMuZWxlbS5wYXJlbnRFbGVtZW50LnJlbW92ZUNoaWxkKHRoaXMuZWxlbSk7XHJcbiAgICB9XHJcbiAgICBkZWxldGVDaGlsZHJlbigpIHtcclxuICAgICAgICB3aGlsZSAodGhpcy5lbGVtLmZpcnN0Q2hpbGQpXHJcbiAgICAgICAgICAgIHRoaXMuZWxlbS5yZW1vdmVDaGlsZCh0aGlzLmVsZW0uZmlyc3RDaGlsZCk7XHJcbiAgICB9XHJcbiAgICBtb3ZlVW5kZXIocGFyZW50KSB7XHJcbiAgICAgICAgcGFyZW50LmVsZW0uYXBwZW5kQ2hpbGQodGhpcy5lbGVtKTtcclxuICAgIH1cclxuICAgIG1vdmVUb0JhY2soKSB7XHJcbiAgICAgICAgbGV0IHBhcmVudCA9IHRoaXMuZWxlbS5wYXJlbnRFbGVtZW50O1xyXG4gICAgICAgIHBhcmVudC5pbnNlcnRCZWZvcmUodGhpcy5lbGVtLCBwYXJlbnQuY2hpbGRyZW5bMF0pO1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG4gICAgbW92ZVRvRnJvbnQoKSB7XHJcbiAgICAgICAgdGhpcy5lbGVtLnBhcmVudEVsZW1lbnQuYXBwZW5kQ2hpbGQodGhpcy5lbGVtKTtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxufVxyXG5leHBvcnRzLkVsZW0gPSBFbGVtO1xyXG5jbGFzcyBHcmFwaEVsZW0gZXh0ZW5kcyBFbGVtIHtcclxuICAgIGdldCBiYm94KCkge1xyXG4gICAgICAgIHJldHVybiBydC5SZWN0LmZyb21ET01SZWN0KHRoaXMuZWxlbS5nZXRCQm94KHsgc3Ryb2tlOiB0cnVlIH0pKTtcclxuICAgIH1cclxuICAgIGdldCB0cmFuc2Zvcm0oKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZWxlbS5nZXRDVE0oKTtcclxuICAgIH1cclxuICAgIHNldCB0cmFuc2Zvcm0obWF0KSB7XHJcbiAgICAgICAgbGV0IHRyID0gdGhpcy5lbGVtLm93bmVyU1ZHRWxlbWVudC5jcmVhdGVTVkdUcmFuc2Zvcm1Gcm9tTWF0cml4KG1hdCk7XHJcbiAgICAgICAgdGhpcy5lbGVtLnRyYW5zZm9ybS5iYXNlVmFsLmluaXRpYWxpemUodHIpO1xyXG4gICAgfVxyXG4gICAgaGlkZSgpIHtcclxuICAgICAgICB0aGlzLnN0eWxlcyh7IG9wYWNpdHk6ICcwJyB9KTtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuICAgIHNob3coKSB7XHJcbiAgICAgICAgdGhpcy5zdHlsZXMoeyBvcGFjaXR5OiAnMScgfSk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcbiAgICB0cmFuc2xhdGUocG9zLCB0byA9IFswLCAwXSkge1xyXG4gICAgICAgIHRoaXMudHJhbnNmb3JtID0gdGhpcy5iYm94LnRyYW5zbGF0ZVRvKHRoaXMudHJhbnNmb3JtLCBwb3MsIHRvKTtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuICAgIGNsaWNrZWQoaGFuZGxlcikge1xyXG4gICAgICAgIHRoaXMuZWxlbS5vbmNsaWNrID0gaGFuZGxlcjtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuICAgIG1vdXNlb3ZlcihoYW5kbGVyKSB7XHJcbiAgICAgICAgdGhpcy5lbGVtLm9ubW91c2VvdmVyID0gaGFuZGxlcjtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuICAgIG1vdXNlbW92ZShoYW5kbGVyKSB7XHJcbiAgICAgICAgdGhpcy5lbGVtLm9ubW91c2Vtb3ZlID0gaGFuZGxlcjtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxufVxyXG5leHBvcnRzLkdyYXBoRWxlbSA9IEdyYXBoRWxlbTtcclxuZnVuY3Rpb24gY3JlYXRlKHRhZywgcGFyZW50KSB7XHJcbiAgICBsZXQgZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhleHBvcnRzLm5zLCB0YWcpO1xyXG4gICAgbGV0IHAgPSBwYXJlbnQgaW5zdGFuY2VvZiBFbGVtID8gcGFyZW50LmVsZW1lbnQgOiBwYXJlbnQ7XHJcbiAgICByZXR1cm4gKGUgaW5zdGFuY2VvZiBTVkdHcmFwaGljc0VsZW1lbnQgP1xyXG4gICAgICAgIG5ldyBHcmFwaEVsZW0oZSwgcCkgOiBuZXcgRWxlbShlLCBwKSk7XHJcbn1cclxuZXhwb3J0cy5jcmVhdGUgPSBjcmVhdGU7XHJcbmZ1bmN0aW9uIGRlZnMoc3Zncm9vdCkge1xyXG4gICAgcmV0dXJuIGNyZWF0ZSgnZGVmcycsIHN2Z3Jvb3QpO1xyXG59XHJcbmV4cG9ydHMuZGVmcyA9IGRlZnM7XHJcbmZ1bmN0aW9uIHNldEJvdW5kcyhzdmdyb290LCBobWFyZ2luLCB2bWFyZ2luID0gaG1hcmdpbikge1xyXG4gICAgbGV0IHZiID0gc3Zncm9vdC5iYm94LmluZmxhdGUoaG1hcmdpbiwgdm1hcmdpbik7XHJcbiAgICBzZXRWaWV3Qm94KHN2Z3Jvb3QsIHZiKTtcclxuICAgIHN2Z3Jvb3QuYXR0cnMoeyB3aWR0aDogdmIud2lkdGgsIGhlaWdodDogdmIuaGVpZ2h0IH0pO1xyXG59XHJcbmV4cG9ydHMuc2V0Qm91bmRzID0gc2V0Qm91bmRzO1xyXG5mdW5jdGlvbiBnZXRWaWV3Qm94KGVsZW0pIHtcclxuICAgIHJldHVybiBydC5SZWN0LmZyb21ET01SZWN0KGVsZW0uZWxlbWVudC52aWV3Qm94LmJhc2VWYWwpO1xyXG59XHJcbmV4cG9ydHMuZ2V0Vmlld0JveCA9IGdldFZpZXdCb3g7XHJcbmZ1bmN0aW9uIHNldFZpZXdCb3goZWxlbSwgdmlld0JveCkge1xyXG4gICAgbGV0IHsgbGVmdCwgdG9wLCB3aWR0aCwgaGVpZ2h0IH0gPSB2aWV3Qm94O1xyXG4gICAgZWxlbS5hdHRycyh7IHZpZXdCb3g6IGAke2xlZnR9ICR7dG9wfSAke3dpZHRofSAke2hlaWdodH1gIH0pO1xyXG59XHJcbmV4cG9ydHMuc2V0Vmlld0JveCA9IHNldFZpZXdCb3g7XHJcbmZ1bmN0aW9uIGNzcyhwYXJlbnQpIHtcclxuICAgIHJldHVybiBwYXJlbnQuY2hpbGQoJ3N0eWxlJykgfHwgY3JlYXRlKCdzdHlsZScsIHBhcmVudCk7XHJcbn1cclxuZXhwb3J0cy5jc3MgPSBjc3M7XHJcbmZ1bmN0aW9uIGdyb3VwKHBhcmVudCkge1xyXG4gICAgcmV0dXJuIGNyZWF0ZSgnZycsIHBhcmVudCk7XHJcbn1cclxuZXhwb3J0cy5ncm91cCA9IGdyb3VwO1xyXG5mdW5jdGlvbiB0ZXh0KHBhcmVudCwgY2FwdGlvbikge1xyXG4gICAgbGV0IHJlcyA9IGNyZWF0ZSgndGV4dCcsIHBhcmVudCk7XHJcbiAgICBpZiAoY2FwdGlvbilcclxuICAgICAgICByZXMudGV4dCA9IGNhcHRpb247XHJcbiAgICByZXR1cm4gcmVzO1xyXG59XHJcbmV4cG9ydHMudGV4dCA9IHRleHQ7XHJcbmZ1bmN0aW9uIHRzcGFuKHBhcmVudCwgY2FwdGlvbikge1xyXG4gICAgbGV0IHJlcyA9IGNyZWF0ZSgndHNwYW4nLCBwYXJlbnQpO1xyXG4gICAgaWYgKGNhcHRpb24pXHJcbiAgICAgICAgcmVzLnRleHQgPSBjYXB0aW9uO1xyXG4gICAgcmV0dXJuIHJlcztcclxufVxyXG5leHBvcnRzLnRzcGFuID0gdHNwYW47XHJcbmZ1bmN0aW9uIHJlY3QocGFyZW50LCB4LCB5LCB3aWR0aCwgaGVpZ2h0LCByeCA9IDAsIHJ5ID0gcngpIHtcclxuICAgIHJldHVybiBjcmVhdGUoJ3JlY3QnLCBwYXJlbnQpLmF0dHJzKHsgeCwgeSwgd2lkdGgsIGhlaWdodCwgcngsIHJ5IH0pO1xyXG59XHJcbmV4cG9ydHMucmVjdCA9IHJlY3Q7XHJcbmZ1bmN0aW9uIGNpcmNsZShwYXJlbnQsIGN4LCBjeSwgcikge1xyXG4gICAgcmV0dXJuIGNyZWF0ZSgnY2lyY2xlJywgcGFyZW50KS5hdHRycyh7IGN4LCBjeSwgciB9KTtcclxufVxyXG5leHBvcnRzLmNpcmNsZSA9IGNpcmNsZTtcclxuZnVuY3Rpb24gZWxsaXBzZShwYXJlbnQsIGN4LCBjeSwgcngsIHJ5KSB7XHJcbiAgICByZXR1cm4gY3JlYXRlKCdlbGxpcHNlJywgcGFyZW50KS5hdHRycyh7IGN4LCBjeSwgcngsIHJ5IH0pO1xyXG59XHJcbmV4cG9ydHMuZWxsaXBzZSA9IGVsbGlwc2U7XHJcbmZ1bmN0aW9uIHBhdGgocGFyZW50LCBjb21tYW5kcykge1xyXG4gICAgcmV0dXJuIGNyZWF0ZSgncGF0aCcsIHBhcmVudCkuYXR0cnMoe1xyXG4gICAgICAgIGQ6IHR5cGVvZiBjb21tYW5kcyA9PT0gJ3N0cmluZycgPyBjb21tYW5kcyA6IGNvbW1hbmRzLmpvaW4oJyAnKVxyXG4gICAgfSk7XHJcbn1cclxuZXhwb3J0cy5wYXRoID0gcGF0aDtcclxuZnVuY3Rpb24gcG9seWxpbmUocGFyZW50LCBwb2ludHMpIHtcclxuICAgIHJldHVybiBjcmVhdGUoJ3BvbHlsaW5lJywgcGFyZW50KS5hdHRycyh7IHBvaW50czogcG9pbnRzLmpvaW4oJyAnKSB9KTtcclxufVxyXG5leHBvcnRzLnBvbHlsaW5lID0gcG9seWxpbmU7XHJcbmZ1bmN0aW9uIHBvbHlnb24ocGFyZW50LCBwb2ludHMpIHtcclxuICAgIHJldHVybiBjcmVhdGUoJ3BvbHlnb24nLCBwYXJlbnQpLmF0dHJzKHsgcG9pbnRzOiBwb2ludHMuam9pbignICcpIH0pO1xyXG59XHJcbmV4cG9ydHMucG9seWdvbiA9IHBvbHlnb247XHJcbmZ1bmN0aW9uIG1hc2socGFyZW50KSB7XHJcbiAgICBsZXQgcmVzID0gY3JlYXRlKFwibWFza1wiLCBwYXJlbnQpO1xyXG4gICAgcmVzLmlkID0gXCJtYXNrXCIgKyAoKytsYXN0R2VuSWQpO1xyXG4gICAgcmV0dXJuIHJlcztcclxufVxyXG5leHBvcnRzLm1hc2sgPSBtYXNrO1xyXG5mdW5jdGlvbiBsaW5rKHBhcmVudCwgaHJlZikge1xyXG4gICAgcmV0dXJuIGNyZWF0ZSgnYScsIHBhcmVudCkuYXR0cnMoeyBocmVmIH0sIGV4cG9ydHMueGxpbmspO1xyXG59XHJcbmV4cG9ydHMubGluayA9IGxpbms7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWVsZW0uanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcclxuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfSk7XHJcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XHJcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xyXG4gICAgb1trMl0gPSBtW2tdO1xyXG59KSk7XHJcbnZhciBfX3NldE1vZHVsZURlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9fc2V0TW9kdWxlRGVmYXVsdCkgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgdikge1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIFwiZGVmYXVsdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2IH0pO1xyXG59KSA6IGZ1bmN0aW9uKG8sIHYpIHtcclxuICAgIG9bXCJkZWZhdWx0XCJdID0gdjtcclxufSk7XHJcbnZhciBfX2ltcG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0U3RhcikgfHwgZnVuY3Rpb24gKG1vZCkge1xyXG4gICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcclxuICAgIHZhciByZXN1bHQgPSB7fTtcclxuICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChrICE9PSBcImRlZmF1bHRcIiAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgX19jcmVhdGVCaW5kaW5nKHJlc3VsdCwgbW9kLCBrKTtcclxuICAgIF9fc2V0TW9kdWxlRGVmYXVsdChyZXN1bHQsIG1vZCk7XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG59O1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmV4cG9ydHMuc2hhZG93ID0gZXhwb3J0cy5zZXRGaWx0ZXIgPSBleHBvcnRzLmZpbHRlciA9IHZvaWQgMDtcclxuY29uc3QgZWwgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcIi4vZWxlbVwiKSk7XHJcbnZhciBsYXN0SWQgPSAwO1xyXG5mdW5jdGlvbiBmaWx0ZXIocGFyZW50LCBpZCkge1xyXG4gICAgcmV0dXJuIGVsLmNyZWF0ZSgnZmlsdGVyJywgcGFyZW50KS5hdHRycyh7IGlkIH0pO1xyXG59XHJcbmV4cG9ydHMuZmlsdGVyID0gZmlsdGVyO1xyXG5mdW5jdGlvbiBzZXRGaWx0ZXIoZWxlbSwgZmlsdGVyKSB7XHJcbiAgICBlbGVtLmF0dHJzKHsgZmlsdGVyOiBgdXJsKCMke3R5cGVvZiBmaWx0ZXIgPT09ICdzdHJpbmcnID9cclxuICAgICAgICAgICAgZmlsdGVyIDogZmlsdGVyLmlkfSlgIH0pO1xyXG4gICAgcmV0dXJuIGVsZW07XHJcbn1cclxuZXhwb3J0cy5zZXRGaWx0ZXIgPSBzZXRGaWx0ZXI7XHJcbmZ1bmN0aW9uIHNoYWRvdyhwYXJlbnQsIGR4LCBkeSA9IGR4LCBzdGREZXZpYXRpb24gPSBkeCkge1xyXG4gICAgbGV0IHJlcyA9IGZpbHRlcihwYXJlbnQsIFwiZmlsdGVyXCIgKyArK2xhc3RJZCk7XHJcbiAgICBlbC5jcmVhdGUoJ2ZlT2Zmc2V0JywgcmVzKS5hdHRycyh7XHJcbiAgICAgICAgcmVzdWx0OiAnb2ZmT3V0JywgaW46ICdzb3VyY2VHcmFwaGljJywgZHg6IDQsIGR5OiA0XHJcbiAgICB9KTtcclxuICAgIGVsLmNyZWF0ZSgnZmVCbGVuZCcsIHJlcykuYXR0cnMoe1xyXG4gICAgICAgIGluOiAnc291cmNlR3JhcGhpYycsIGluMjogJ29mZk91dCcsIG1vZGU6ICdub3JtYWwnXHJcbiAgICB9KTtcclxuICAgIHJldHVybiByZXM7XHJcbn1cclxuZXhwb3J0cy5zaGFkb3cgPSBzaGFkb3c7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWZpbHRlci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcclxudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xyXG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9KTtcclxufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcclxuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XHJcbiAgICBvW2syXSA9IG1ba107XHJcbn0pKTtcclxudmFyIF9fZXhwb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19leHBvcnRTdGFyKSB8fCBmdW5jdGlvbihtLCBleHBvcnRzKSB7XHJcbiAgICBmb3IgKHZhciBwIGluIG0pIGlmIChwICE9PSBcImRlZmF1bHRcIiAmJiAhT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGV4cG9ydHMsIHApKSBfX2NyZWF0ZUJpbmRpbmcoZXhwb3J0cywgbSwgcCk7XHJcbn07XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL3ZlY3RvclwiKSwgZXhwb3J0cyk7XHJcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9yZWN0XCIpLCBleHBvcnRzKTtcclxuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL3BhdGhcIiksIGV4cG9ydHMpO1xyXG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vZWxlbVwiKSwgZXhwb3J0cyk7XHJcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9tYXJrZXJcIiksIGV4cG9ydHMpO1xyXG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vZmlsdGVyXCIpLCBleHBvcnRzKTtcclxuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL3RleHRcIiksIGV4cG9ydHMpO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcclxudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xyXG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9KTtcclxufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcclxuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XHJcbiAgICBvW2syXSA9IG1ba107XHJcbn0pKTtcclxudmFyIF9fc2V0TW9kdWxlRGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19zZXRNb2R1bGVEZWZhdWx0KSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCB2KSB7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgXCJkZWZhdWx0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHYgfSk7XHJcbn0pIDogZnVuY3Rpb24obywgdikge1xyXG4gICAgb1tcImRlZmF1bHRcIl0gPSB2O1xyXG59KTtcclxudmFyIF9faW1wb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnRTdGFyKSB8fCBmdW5jdGlvbiAobW9kKSB7XHJcbiAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xyXG4gICAgdmFyIHJlc3VsdCA9IHt9O1xyXG4gICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkgaWYgKGsgIT09IFwiZGVmYXVsdFwiICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSBfX2NyZWF0ZUJpbmRpbmcocmVzdWx0LCBtb2QsIGspO1xyXG4gICAgX19zZXRNb2R1bGVEZWZhdWx0KHJlc3VsdCwgbW9kKTtcclxuICAgIHJldHVybiByZXN1bHQ7XHJcbn07XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuZXhwb3J0cy5hcnJvdyA9IGV4cG9ydHMuc2V0TWFya2VyID0gZXhwb3J0cy5tYXJrZXIgPSBleHBvcnRzLk1hcmtlclBvcyA9IHZvaWQgMDtcclxuY29uc3QgZWwgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcIi4vZWxlbVwiKSk7XHJcbnZhciBNYXJrZXJQb3M7XHJcbihmdW5jdGlvbiAoTWFya2VyUG9zKSB7XHJcbiAgICBNYXJrZXJQb3NbTWFya2VyUG9zW1wiU3RhcnRcIl0gPSAwXSA9IFwiU3RhcnRcIjtcclxuICAgIE1hcmtlclBvc1tNYXJrZXJQb3NbXCJNaWRcIl0gPSAxXSA9IFwiTWlkXCI7XHJcbiAgICBNYXJrZXJQb3NbTWFya2VyUG9zW1wiRW5kXCJdID0gMl0gPSBcIkVuZFwiO1xyXG59KShNYXJrZXJQb3MgPSBleHBvcnRzLk1hcmtlclBvcyB8fCAoZXhwb3J0cy5NYXJrZXJQb3MgPSB7fSkpO1xyXG52YXIgbGFzdElkID0gMDtcclxuZnVuY3Rpb24gbWFya2VyKHBhcmVudCwgaWQpIHtcclxuICAgIHJldHVybiBlbC5jcmVhdGUoJ21hcmtlcicsIHBhcmVudCkuYXR0cnMoeyBpZCB9KTtcclxufVxyXG5leHBvcnRzLm1hcmtlciA9IG1hcmtlcjtcclxuZnVuY3Rpb24gc2V0TWFya2VyKGVsZW0sIG1hcmtlciwgcG9zKSB7XHJcbiAgICBsZXQgbWFya2VyVXJsID0gYHVybCgjJHt0eXBlb2YgbWFya2VyID09PSAnc3RyaW5nJyA/IG1hcmtlciA6IG1hcmtlci5pZH0pYDtcclxuICAgIHN3aXRjaCAocG9zKSB7XHJcbiAgICAgICAgY2FzZSBNYXJrZXJQb3MuU3RhcnQ6XHJcbiAgICAgICAgICAgIHJldHVybiBlbGVtLmF0dHJzKHsgXCJtYXJrZXItc3RhcnRcIjogbWFya2VyVXJsIH0pO1xyXG4gICAgICAgIGNhc2UgTWFya2VyUG9zLk1pZDpcclxuICAgICAgICAgICAgcmV0dXJuIGVsZW0uYXR0cnMoeyBcIm1hcmtlci1taWRcIjogbWFya2VyVXJsIH0pO1xyXG4gICAgICAgIGNhc2UgTWFya2VyUG9zLkVuZDpcclxuICAgICAgICAgICAgcmV0dXJuIGVsZW0uYXR0cnMoeyBcIm1hcmtlci1lbmRcIjogbWFya2VyVXJsIH0pO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGVsZW07XHJcbn1cclxuZXhwb3J0cy5zZXRNYXJrZXIgPSBzZXRNYXJrZXI7XHJcbmZ1bmN0aW9uIGFycm93KHBhcmVudCwgd2lkdGgsIGxlbmd0aCA9IHdpZHRoLCBjbG9zZWQgPSB0cnVlKSB7XHJcbiAgICBsZXQgcmVzID0gbWFya2VyKHBhcmVudCwgXCJhcnJvd1wiICsgKytsYXN0SWQpLmF0dHJzKHtcclxuICAgICAgICB2aWV3Qm94OiBcIi0xIC0xIDEyIDEyXCIsXHJcbiAgICAgICAgcmVmWDogMTAsIHJlZlk6IDUsXHJcbiAgICAgICAgb3JpZW50OiBcImF1dG8tc3RhcnQtcmV2ZXJzZVwiLFxyXG4gICAgICAgIG1hcmtlcldpZHRoOiBsZW5ndGgsIG1hcmtlckhlaWdodDogd2lkdGgsXHJcbiAgICAgICAgcHJlc2VydmVBc3BlY3RSYXRpbzogXCJub25lXCJcclxuICAgIH0pO1xyXG4gICAgZWwucGF0aChyZXMsIFwiTSAwIDAgTCAxMCA1IEwgMCAxMFwiICsgKGNsb3NlZCA/IFwiIHpcIiA6IFwiXCIpKTtcclxuICAgIHJldHVybiByZXM7XHJcbn1cclxuZXhwb3J0cy5hcnJvdyA9IGFycm93O1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1tYXJrZXIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuZXhwb3J0cy5DbG9zZVBhdGggPSBleHBvcnRzLkFyY1RvID0gZXhwb3J0cy5Td2VlcCA9IGV4cG9ydHMuQXJjID0gZXhwb3J0cy5Db250UXVhZEN1cnZlVG8gPSBleHBvcnRzLlF1YWRDdXJ2ZVRvID0gZXhwb3J0cy5Db250Q3ViaWNDdXJ2ZVRvID0gZXhwb3J0cy5DdWJpY0N1cnZlVG8gPSBleHBvcnRzLlZMaW5lVG8gPSBleHBvcnRzLkhMaW5lVG8gPSBleHBvcnRzLkxpbmVUbyA9IGV4cG9ydHMuTW92ZVRvID0gdm9pZCAwO1xyXG5jbGFzcyBNb3ZlVG8ge1xyXG4gICAgY29uc3RydWN0b3IoY29tbWFuZCwgeCwgeSkge1xyXG4gICAgICAgIHRoaXMuY29tbWFuZCA9IGNvbW1hbmQ7XHJcbiAgICAgICAgdGhpcy54ID0geDtcclxuICAgICAgICB0aGlzLnkgPSB5O1xyXG4gICAgICAgIHRoaXMudG9TdHJpbmcgPSAoKSA9PiBgJHt0aGlzLmNvbW1hbmR9JHt0aGlzLnh9ICR7dGhpcy55fWA7XHJcbiAgICB9XHJcbn1cclxuZXhwb3J0cy5Nb3ZlVG8gPSBNb3ZlVG87XHJcbmNsYXNzIExpbmVUbyB7XHJcbiAgICBjb25zdHJ1Y3Rvcihjb21tYW5kLCB4LCB5KSB7XHJcbiAgICAgICAgdGhpcy5jb21tYW5kID0gY29tbWFuZDtcclxuICAgICAgICB0aGlzLnggPSB4O1xyXG4gICAgICAgIHRoaXMueSA9IHk7XHJcbiAgICAgICAgdGhpcy50b1N0cmluZyA9ICgpID0+IGAke3RoaXMuY29tbWFuZH0ke3RoaXMueH0gJHt0aGlzLnl9YDtcclxuICAgIH1cclxufVxyXG5leHBvcnRzLkxpbmVUbyA9IExpbmVUbztcclxuY2xhc3MgSExpbmVUbyB7XHJcbiAgICBjb25zdHJ1Y3Rvcihjb21tYW5kLCB4KSB7XHJcbiAgICAgICAgdGhpcy5jb21tYW5kID0gY29tbWFuZDtcclxuICAgICAgICB0aGlzLnggPSB4O1xyXG4gICAgICAgIHRoaXMudG9TdHJpbmcgPSAoKSA9PiBgJHt0aGlzLmNvbW1hbmR9JHt0aGlzLnh9YDtcclxuICAgIH1cclxufVxyXG5leHBvcnRzLkhMaW5lVG8gPSBITGluZVRvO1xyXG5jbGFzcyBWTGluZVRvIHtcclxuICAgIGNvbnN0cnVjdG9yKGNvbW1hbmQsIHkpIHtcclxuICAgICAgICB0aGlzLmNvbW1hbmQgPSBjb21tYW5kO1xyXG4gICAgICAgIHRoaXMueSA9IHk7XHJcbiAgICAgICAgdGhpcy50b1N0cmluZyA9ICgpID0+IGAke3RoaXMuY29tbWFuZH0ke3RoaXMueX1gO1xyXG4gICAgfVxyXG59XHJcbmV4cG9ydHMuVkxpbmVUbyA9IFZMaW5lVG87XHJcbmNsYXNzIEN1YmljQ3VydmVUbyB7XHJcbiAgICBjb25zdHJ1Y3Rvcihjb21tYW5kLCB4MSwgeTEsIHgyLCB5MiwgeCwgeSkge1xyXG4gICAgICAgIHRoaXMuY29tbWFuZCA9IGNvbW1hbmQ7XHJcbiAgICAgICAgdGhpcy54MSA9IHgxO1xyXG4gICAgICAgIHRoaXMueTEgPSB5MTtcclxuICAgICAgICB0aGlzLngyID0geDI7XHJcbiAgICAgICAgdGhpcy55MiA9IHkyO1xyXG4gICAgICAgIHRoaXMueCA9IHg7XHJcbiAgICAgICAgdGhpcy55ID0geTtcclxuICAgICAgICB0aGlzLnRvU3RyaW5nID0gKCkgPT4gYCR7dGhpcy5jb21tYW5kfSR7dGhpcy54MX0gJHt0aGlzLnkxfSAke3RoaXMueDJ9ICR7dGhpcy55Mn0gJHt0aGlzLnh9ICR7dGhpcy55fWA7XHJcbiAgICB9XHJcbn1cclxuZXhwb3J0cy5DdWJpY0N1cnZlVG8gPSBDdWJpY0N1cnZlVG87XHJcbmNsYXNzIENvbnRDdWJpY0N1cnZlVG8ge1xyXG4gICAgY29uc3RydWN0b3IoY29tbWFuZCwgeDIsIHkyLCB4LCB5KSB7XHJcbiAgICAgICAgdGhpcy5jb21tYW5kID0gY29tbWFuZDtcclxuICAgICAgICB0aGlzLngyID0geDI7XHJcbiAgICAgICAgdGhpcy55MiA9IHkyO1xyXG4gICAgICAgIHRoaXMueCA9IHg7XHJcbiAgICAgICAgdGhpcy55ID0geTtcclxuICAgICAgICB0aGlzLnRvU3RyaW5nID0gKCkgPT4gYCR7dGhpcy5jb21tYW5kfSR7dGhpcy54Mn0gJHt0aGlzLnkyfSAke3RoaXMueH0gJHt0aGlzLnl9YDtcclxuICAgIH1cclxufVxyXG5leHBvcnRzLkNvbnRDdWJpY0N1cnZlVG8gPSBDb250Q3ViaWNDdXJ2ZVRvO1xyXG5jbGFzcyBRdWFkQ3VydmVUbyB7XHJcbiAgICBjb25zdHJ1Y3Rvcihjb21tYW5kLCB4MSwgeTEsIHgsIHkpIHtcclxuICAgICAgICB0aGlzLmNvbW1hbmQgPSBjb21tYW5kO1xyXG4gICAgICAgIHRoaXMueDEgPSB4MTtcclxuICAgICAgICB0aGlzLnkxID0geTE7XHJcbiAgICAgICAgdGhpcy54ID0geDtcclxuICAgICAgICB0aGlzLnkgPSB5O1xyXG4gICAgICAgIHRoaXMudG9TdHJpbmcgPSAoKSA9PiBgJHt0aGlzLmNvbW1hbmR9JHt0aGlzLngxfSAke3RoaXMueTF9ICR7dGhpcy54fSAke3RoaXMueX1gO1xyXG4gICAgfVxyXG59XHJcbmV4cG9ydHMuUXVhZEN1cnZlVG8gPSBRdWFkQ3VydmVUbztcclxuY2xhc3MgQ29udFF1YWRDdXJ2ZVRvIHtcclxuICAgIGNvbnN0cnVjdG9yKGNvbW1hbmQsIHgsIHkpIHtcclxuICAgICAgICB0aGlzLmNvbW1hbmQgPSBjb21tYW5kO1xyXG4gICAgICAgIHRoaXMueCA9IHg7XHJcbiAgICAgICAgdGhpcy55ID0geTtcclxuICAgICAgICB0aGlzLnRvU3RyaW5nID0gKCkgPT4gYCR7dGhpcy5jb21tYW5kfSR7dGhpcy54fSAke3RoaXMueX1gO1xyXG4gICAgfVxyXG59XHJcbmV4cG9ydHMuQ29udFF1YWRDdXJ2ZVRvID0gQ29udFF1YWRDdXJ2ZVRvO1xyXG52YXIgQXJjO1xyXG4oZnVuY3Rpb24gKEFyYykge1xyXG4gICAgQXJjW0FyY1tcIlNtYWxsXCJdID0gMF0gPSBcIlNtYWxsXCI7XHJcbiAgICBBcmNbQXJjW1wiTGFyZ2VcIl0gPSAxXSA9IFwiTGFyZ2VcIjtcclxufSkoQXJjID0gZXhwb3J0cy5BcmMgfHwgKGV4cG9ydHMuQXJjID0ge30pKTtcclxudmFyIFN3ZWVwO1xyXG4oZnVuY3Rpb24gKFN3ZWVwKSB7XHJcbiAgICBTd2VlcFtTd2VlcFtcIkNXXCJdID0gMF0gPSBcIkNXXCI7XHJcbiAgICBTd2VlcFtTd2VlcFtcIkNDV1wiXSA9IDFdID0gXCJDQ1dcIjtcclxufSkoU3dlZXAgPSBleHBvcnRzLlN3ZWVwIHx8IChleHBvcnRzLlN3ZWVwID0ge30pKTtcclxuY2xhc3MgQXJjVG8ge1xyXG4gICAgY29uc3RydWN0b3IoY29tbWFuZCwgcngsIHJ5LCByb3QsIGFyYywgc3dlZXAsIHgsIHkpIHtcclxuICAgICAgICB0aGlzLmNvbW1hbmQgPSBjb21tYW5kO1xyXG4gICAgICAgIHRoaXMucnggPSByeDtcclxuICAgICAgICB0aGlzLnJ5ID0gcnk7XHJcbiAgICAgICAgdGhpcy5yb3QgPSByb3Q7XHJcbiAgICAgICAgdGhpcy5hcmMgPSBhcmM7XHJcbiAgICAgICAgdGhpcy5zd2VlcCA9IHN3ZWVwO1xyXG4gICAgICAgIHRoaXMueCA9IHg7XHJcbiAgICAgICAgdGhpcy55ID0geTtcclxuICAgICAgICB0aGlzLnRvU3RyaW5nID0gKCkgPT4gYCR7dGhpcy5jb21tYW5kfSR7dGhpcy5yeH0gJHt0aGlzLnJ5fSAke3RoaXMucm90fSAke3RoaXMuYXJjfSAke3RoaXMuc3dlZXB9ICR7dGhpcy54fSAke3RoaXMueX1gO1xyXG4gICAgfVxyXG59XHJcbmV4cG9ydHMuQXJjVG8gPSBBcmNUbztcclxuY2xhc3MgQ2xvc2VQYXRoIHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHRoaXMudG9TdHJpbmcgPSAoKSA9PiB0aGlzLmNvbW1hbmQ7XHJcbiAgICB9XHJcbn1cclxuZXhwb3J0cy5DbG9zZVBhdGggPSBDbG9zZVBhdGg7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBhdGguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcclxuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfSk7XHJcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XHJcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xyXG4gICAgb1trMl0gPSBtW2tdO1xyXG59KSk7XHJcbnZhciBfX3NldE1vZHVsZURlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9fc2V0TW9kdWxlRGVmYXVsdCkgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgdikge1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIFwiZGVmYXVsdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2IH0pO1xyXG59KSA6IGZ1bmN0aW9uKG8sIHYpIHtcclxuICAgIG9bXCJkZWZhdWx0XCJdID0gdjtcclxufSk7XHJcbnZhciBfX2ltcG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0U3RhcikgfHwgZnVuY3Rpb24gKG1vZCkge1xyXG4gICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcclxuICAgIHZhciByZXN1bHQgPSB7fTtcclxuICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChrICE9PSBcImRlZmF1bHRcIiAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgX19jcmVhdGVCaW5kaW5nKHJlc3VsdCwgbW9kLCBrKTtcclxuICAgIF9fc2V0TW9kdWxlRGVmYXVsdChyZXN1bHQsIG1vZCk7XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG59O1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmV4cG9ydHMuUmVjdCA9IGV4cG9ydHMuUmVjdFBvcyA9IHZvaWQgMDtcclxuY29uc3QgdmVjID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCIuL3ZlY3RvclwiKSk7XHJcbnZhciBSZWN0UG9zO1xyXG4oZnVuY3Rpb24gKFJlY3RQb3MpIHtcclxuICAgIFJlY3RQb3NbUmVjdFBvc1tcIkNlbnRlclwiXSA9IDBdID0gXCJDZW50ZXJcIjtcclxuICAgIFJlY3RQb3NbUmVjdFBvc1tcIlRvcExlZnRcIl0gPSAxXSA9IFwiVG9wTGVmdFwiO1xyXG4gICAgUmVjdFBvc1tSZWN0UG9zW1wiVG9wUmlnaHRcIl0gPSAyXSA9IFwiVG9wUmlnaHRcIjtcclxuICAgIFJlY3RQb3NbUmVjdFBvc1tcIkJvdHRvbUxlZnRcIl0gPSAzXSA9IFwiQm90dG9tTGVmdFwiO1xyXG4gICAgUmVjdFBvc1tSZWN0UG9zW1wiQm90dG9tUmlnaHRcIl0gPSA0XSA9IFwiQm90dG9tUmlnaHRcIjtcclxufSkoUmVjdFBvcyA9IGV4cG9ydHMuUmVjdFBvcyB8fCAoZXhwb3J0cy5SZWN0UG9zID0ge30pKTtcclxuLyoqXHJcbiAqIERlZmluZXMgYSByZWN0YW5nbGUgd2hpY2ggY292ZXJzIGFyZWEgW2xlZnQsIHJpZ2h0KSBhbG9uZyB4LWF4aXNcclxuICogYW5kIFt0b3AsIGJvdHRvbSkgYWxvbmcgeS1heGlzLlxyXG4gKi9cclxuY2xhc3MgUmVjdCB7XHJcbiAgICBjb25zdHJ1Y3RvcihsZWZ0LCB0b3AsIHJpZ2h0LCBib3R0b20pIHtcclxuICAgICAgICB0aGlzLmxlZnQgPSBsZWZ0O1xyXG4gICAgICAgIHRoaXMudG9wID0gdG9wO1xyXG4gICAgICAgIHRoaXMucmlnaHQgPSByaWdodDtcclxuICAgICAgICB0aGlzLmJvdHRvbSA9IGJvdHRvbTtcclxuICAgIH1cclxuICAgIGdldCB3aWR0aCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5yaWdodCAtIHRoaXMubGVmdDtcclxuICAgIH1cclxuICAgIGdldCBoZWlnaHQoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuYm90dG9tIC0gdGhpcy50b3A7XHJcbiAgICB9XHJcbiAgICBnZXQgY2VudGVyWCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5sZWZ0ICsgKHRoaXMud2lkdGggLyAyKTtcclxuICAgIH1cclxuICAgIGdldCBjZW50ZXJZKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnRvcCArICh0aGlzLmhlaWdodCAvIDIpO1xyXG4gICAgfVxyXG4gICAgZ2V0IGlzRW1wdHkoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMud2lkdGggPD0gMCB8fCB0aGlzLmhlaWdodCA8PSAwO1xyXG4gICAgfVxyXG4gICAgY29udGFpbnNQb2ludCh4LCB5KSB7XHJcbiAgICAgICAgcmV0dXJuIHggPj0gdGhpcy5sZWZ0ICYmIHggPCB0aGlzLnJpZ2h0ICYmXHJcbiAgICAgICAgICAgIHkgPj0gdGhpcy50b3AgJiYgeSA8IHRoaXMuYm90dG9tO1xyXG4gICAgfVxyXG4gICAgcmVjdFBvcyhwb3MpIHtcclxuICAgICAgICBzd2l0Y2ggKHBvcykge1xyXG4gICAgICAgICAgICBjYXNlIFJlY3RQb3MuQ2VudGVyOiByZXR1cm4gW3RoaXMuY2VudGVyWCwgdGhpcy5jZW50ZXJZXTtcclxuICAgICAgICAgICAgY2FzZSBSZWN0UG9zLlRvcExlZnQ6IHJldHVybiBbdGhpcy5sZWZ0LCB0aGlzLnRvcF07XHJcbiAgICAgICAgICAgIGNhc2UgUmVjdFBvcy5Ub3BSaWdodDogcmV0dXJuIFt0aGlzLnJpZ2h0LCB0aGlzLnRvcF07XHJcbiAgICAgICAgICAgIGNhc2UgUmVjdFBvcy5Cb3R0b21MZWZ0OiByZXR1cm4gW3RoaXMubGVmdCwgdGhpcy5ib3R0b21dO1xyXG4gICAgICAgICAgICBjYXNlIFJlY3RQb3MuQm90dG9tUmlnaHQ6IHJldHVybiBbdGhpcy5yaWdodCwgdGhpcy5ib3R0b21dO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGNvcm5lclBvaW50cyhjbG9zZUxvb3AgPSBmYWxzZSkge1xyXG4gICAgICAgIGxldCByZXMgPSBbXHJcbiAgICAgICAgICAgIHRoaXMucmVjdFBvcyhSZWN0UG9zLlRvcExlZnQpLFxyXG4gICAgICAgICAgICB0aGlzLnJlY3RQb3MoUmVjdFBvcy5Ub3BSaWdodCksXHJcbiAgICAgICAgICAgIHRoaXMucmVjdFBvcyhSZWN0UG9zLkJvdHRvbVJpZ2h0KSxcclxuICAgICAgICAgICAgdGhpcy5yZWN0UG9zKFJlY3RQb3MuQm90dG9tTGVmdClcclxuICAgICAgICBdO1xyXG4gICAgICAgIGlmIChjbG9zZUxvb3ApXHJcbiAgICAgICAgICAgIHJlcy5wdXNoKHJlc1swXSk7XHJcbiAgICAgICAgcmV0dXJuIHJlcztcclxuICAgIH1cclxuICAgIGNvbnRhaW5zUmVjdChvdGhlcikge1xyXG4gICAgICAgIHJldHVybiBvdGhlci5sZWZ0ID49IHRoaXMubGVmdCAmJiBvdGhlci5yaWdodCA8PSB0aGlzLnJpZ2h0ICYmXHJcbiAgICAgICAgICAgIG90aGVyLnRvcCA+PSB0aGlzLnRvcCAmJiBvdGhlci5ib3R0b20gPD0gdGhpcy5ib3R0b207XHJcbiAgICB9XHJcbiAgICBlcXVhbHMob3RoZXIpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5sZWZ0ID09IG90aGVyLmxlZnQgJiYgdGhpcy50b3AgPT0gb3RoZXIudG9wICYmXHJcbiAgICAgICAgICAgIHRoaXMud2lkdGggPT0gb3RoZXIud2lkdGggJiYgdGhpcy5oZWlnaHQgPT0gb3RoZXIuaGVpZ2h0O1xyXG4gICAgfVxyXG4gICAgaW5mbGF0ZShkeCwgZHkpIHtcclxuICAgICAgICByZXR1cm4gbmV3IFJlY3QodGhpcy5sZWZ0IC0gZHgsIHRoaXMudG9wIC0gZHksIHRoaXMucmlnaHQgKyBkeCwgdGhpcy5ib3R0b20gKyBkeSk7XHJcbiAgICB9XHJcbiAgICBpbnRlcnNlY3Qob3RoZXIpIHtcclxuICAgICAgICByZXR1cm4gbmV3IFJlY3QoTWF0aC5tYXgodGhpcy5sZWZ0LCBvdGhlci5sZWZ0KSwgTWF0aC5tYXgodGhpcy50b3AsIG90aGVyLnRvcCksIE1hdGgubWluKHRoaXMucmlnaHQsIG90aGVyLnJpZ2h0KSwgTWF0aC5taW4odGhpcy5ib3R0b20sIG90aGVyLmJvdHRvbSkpO1xyXG4gICAgfVxyXG4gICAgaW50ZXJzZWN0c1dpdGgob3RoZXIpIHtcclxuICAgICAgICByZXR1cm4gIXRoaXMuaW50ZXJzZWN0KG90aGVyKS5pc0VtcHR5O1xyXG4gICAgfVxyXG4gICAgb2Zmc2V0KGR4LCBkeSkge1xyXG4gICAgICAgIHJldHVybiBuZXcgUmVjdCh0aGlzLmxlZnQgKyBkeCwgdGhpcy50b3AgKyBkeSwgdGhpcy5yaWdodCArIGR4LCB0aGlzLmJvdHRvbSArIGR5KTtcclxuICAgIH1cclxuICAgIHRyYW5zbGF0ZVRvKG1hdCwgcG9zLCB0byA9IFswLCAwXSkge1xyXG4gICAgICAgIGxldCBbc3gsIHN5XSA9IHBvcyBpbnN0YW5jZW9mIEFycmF5ID8gcG9zIDogdGhpcy5yZWN0UG9zKHBvcyk7XHJcbiAgICAgICAgbGV0IFt0eCwgdHldID0gdG87XHJcbiAgICAgICAgcmV0dXJuIG1hdC50cmFuc2xhdGUodHggLSBzeCwgdHkgLSBzeSk7XHJcbiAgICB9XHJcbiAgICB0cmFuc2Zvcm0obWF0KSB7XHJcbiAgICAgICAgcmV0dXJuIFJlY3QuZnJvbVBvaW50cyh0aGlzLmNvcm5lclBvaW50cygpLm1hcChwdCA9PiB7XHJcbiAgICAgICAgICAgIGxldCBbeCwgeV0gPSBwdDtcclxuICAgICAgICAgICAgbGV0IHRwID0gbWF0LnRyYW5zZm9ybVBvaW50KHsgeCwgeSB9KTtcclxuICAgICAgICAgICAgcmV0dXJuIFt0cC54LCB0cC55XTtcclxuICAgICAgICB9KSk7XHJcbiAgICB9XHJcbiAgICB1bmlvbihvdGhlcikge1xyXG4gICAgICAgIHJldHVybiBuZXcgUmVjdChNYXRoLm1pbih0aGlzLmxlZnQsIG90aGVyLmxlZnQpLCBNYXRoLm1pbih0aGlzLnRvcCwgb3RoZXIudG9wKSwgTWF0aC5tYXgodGhpcy5yaWdodCwgb3RoZXIucmlnaHQpLCBNYXRoLm1heCh0aGlzLmJvdHRvbSwgb3RoZXIuYm90dG9tKSk7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgZnJvbURPTVJlY3QoZG9tUmVjdCkge1xyXG4gICAgICAgIHJldHVybiBuZXcgUmVjdChkb21SZWN0LngsIGRvbVJlY3QueSwgZG9tUmVjdC54ICsgZG9tUmVjdC53aWR0aCwgZG9tUmVjdC55ICsgZG9tUmVjdC5oZWlnaHQpO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIGZyb21Qb2ludHMocG9pbnRzKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBSZWN0KE1hdGgubWluKC4uLnBvaW50cy5tYXAodmVjLnZlY1gpKSwgTWF0aC5taW4oLi4ucG9pbnRzLm1hcCh2ZWMudmVjWSkpLCBNYXRoLm1heCguLi5wb2ludHMubWFwKHZlYy52ZWNYKSksIE1hdGgubWF4KC4uLnBvaW50cy5tYXAodmVjLnZlY1kpKSk7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgZnJvbVJlY3RzKHJlY3RzKSB7XHJcbiAgICAgICAgcmV0dXJuIHJlY3RzLnJlZHVjZSgociwgYykgPT4gYy51bmlvbihyKSk7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgZnJvbVN0cmluZyh2YWx1ZSkge1xyXG4gICAgICAgIGxldCBbbGVmdCwgdG9wLCB3aWR0aCwgaGVpZ2h0XSA9IHZhbHVlLnNwbGl0KFwiIFwiKS5tYXAoTnVtYmVyKTtcclxuICAgICAgICByZXR1cm4gbmV3IFJlY3QobGVmdCwgdG9wLCBsZWZ0ICsgd2lkdGgsIHRvcCArIGhlaWdodCk7XHJcbiAgICB9XHJcbn1cclxuZXhwb3J0cy5SZWN0ID0gUmVjdDtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmVjdC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcclxudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xyXG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9KTtcclxufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcclxuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XHJcbiAgICBvW2syXSA9IG1ba107XHJcbn0pKTtcclxudmFyIF9fc2V0TW9kdWxlRGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19zZXRNb2R1bGVEZWZhdWx0KSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCB2KSB7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgXCJkZWZhdWx0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHYgfSk7XHJcbn0pIDogZnVuY3Rpb24obywgdikge1xyXG4gICAgb1tcImRlZmF1bHRcIl0gPSB2O1xyXG59KTtcclxudmFyIF9faW1wb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnRTdGFyKSB8fCBmdW5jdGlvbiAobW9kKSB7XHJcbiAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xyXG4gICAgdmFyIHJlc3VsdCA9IHt9O1xyXG4gICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkgaWYgKGsgIT09IFwiZGVmYXVsdFwiICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSBfX2NyZWF0ZUJpbmRpbmcocmVzdWx0LCBtb2QsIGspO1xyXG4gICAgX19zZXRNb2R1bGVEZWZhdWx0KHJlc3VsdCwgbW9kKTtcclxuICAgIHJldHVybiByZXN1bHQ7XHJcbn07XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuZXhwb3J0cy5jaGFuZ2VXb3JkV3JhcFRleHQgPSBleHBvcnRzLndvcmRXcmFwVGV4dCA9IHZvaWQgMDtcclxuY29uc3QgZWwgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcIi4vZWxlbVwiKSk7XHJcbmZ1bmN0aW9uIHdvcmRXcmFwVGV4dChwYXJlbnQsIHgsIHksIHdyYXBBZnRlciwgY2FwdGlvbikge1xyXG4gICAgbGV0IHRleHQgPSBlbC50ZXh0KHBhcmVudCkuYXR0cnMoeyB4LCB5LCBcImRhdGEtd3JhcEFmdGVyXCI6IHdyYXBBZnRlciB9KTtcclxuICAgIGNoYW5nZVdvcmRXcmFwVGV4dCh0ZXh0LCBjYXB0aW9uKTtcclxuICAgIHJldHVybiB0ZXh0O1xyXG59XHJcbmV4cG9ydHMud29yZFdyYXBUZXh0ID0gd29yZFdyYXBUZXh0O1xyXG5mdW5jdGlvbiBjaGFuZ2VXb3JkV3JhcFRleHQodGV4dCwgY2FwdGlvbiwgeCwgd3JhcEFmdGVyKSB7XHJcbiAgICB0ZXh0LmRlbGV0ZUNoaWxkcmVuKCk7XHJcbiAgICBsZXQgd29yZHMgPSBjYXB0aW9uLnNwbGl0KFwiIFwiKTtcclxuICAgIGlmICh4KVxyXG4gICAgICAgIHRleHQuYXR0cnMoeyB4IH0pO1xyXG4gICAgZWxzZVxyXG4gICAgICAgIHggPSBOdW1iZXIodGV4dC5hdHRyKFwieFwiKSk7XHJcbiAgICBpZiAod3JhcEFmdGVyKVxyXG4gICAgICAgIHRleHQuYXR0cnMoeyBcImRhdGEtd3JhcEFmdGVyXCI6IHdyYXBBZnRlciB9KTtcclxuICAgIGVsc2VcclxuICAgICAgICB3cmFwQWZ0ZXIgPSBOdW1iZXIodGV4dC5hdHRyKFwiZGF0YS13cmFwQWZ0ZXJcIikgfHwgMTAwKTtcclxuICAgIGxldCBpID0gMDtcclxuICAgIGxldCBiYiA9IG51bGw7XHJcbiAgICB3aGlsZSAoaSA8IHdvcmRzLmxlbmd0aCkge1xyXG4gICAgICAgIGxldCB0cyA9IGVsLnRzcGFuKHRleHQsIHdvcmRzW2ldKTtcclxuICAgICAgICBsZXQgdyA9IHRzLmVsZW1lbnQuZ2V0Q29tcHV0ZWRUZXh0TGVuZ3RoKCk7XHJcbiAgICAgICAgd2hpbGUgKCsraSA8IHdvcmRzLmxlbmd0aCAmJiB3IDwgd3JhcEFmdGVyKSB7XHJcbiAgICAgICAgICAgIHRzLnRleHQgPSB0cy50ZXh0ICsgXCIgXCIgKyB3b3Jkc1tpXTtcclxuICAgICAgICAgICAgdyA9IHRzLmVsZW1lbnQuZ2V0Q29tcHV0ZWRUZXh0TGVuZ3RoKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghYmIpXHJcbiAgICAgICAgICAgIGJiID0gdGV4dC5iYm94O1xyXG4gICAgICAgIGVsc2VcclxuICAgICAgICAgICAgdHMuYXR0cnMoeyB4LCBkeTogYmIuaGVpZ2h0IH0pO1xyXG4gICAgfVxyXG59XHJcbmV4cG9ydHMuY2hhbmdlV29yZFdyYXBUZXh0ID0gY2hhbmdlV29yZFdyYXBUZXh0O1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD10ZXh0LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmV4cG9ydHMuZGl2VmVjID0gZXhwb3J0cy5tdWxWZWMgPSBleHBvcnRzLnN1YlZlYyA9IGV4cG9ydHMuYWRkVmVjID0gZXhwb3J0cy52ZWNZID0gZXhwb3J0cy52ZWNYID0gZXhwb3J0cy5vbmVWZWN0b3IgPSBleHBvcnRzLnplcm9WZWN0b3IgPSB2b2lkIDA7XHJcbmV4cG9ydHMuemVyb1ZlY3RvciA9IFswLCAwXTtcclxuZXhwb3J0cy5vbmVWZWN0b3IgPSBbMSwgMV07XHJcbmZ1bmN0aW9uIHZlY1godmVjKSB7XHJcbiAgICByZXR1cm4gdmVjWzBdO1xyXG59XHJcbmV4cG9ydHMudmVjWCA9IHZlY1g7XHJcbmZ1bmN0aW9uIHZlY1kodmVjKSB7XHJcbiAgICByZXR1cm4gdmVjWzFdO1xyXG59XHJcbmV4cG9ydHMudmVjWSA9IHZlY1k7XHJcbmZ1bmN0aW9uIGFkZFZlYyh2ZWMxLCB2ZWMyKSB7XHJcbiAgICByZXR1cm4gdmVjMS5tYXAoKGEsIGkpID0+IGEgKyB2ZWMyW2ldKTtcclxufVxyXG5leHBvcnRzLmFkZFZlYyA9IGFkZFZlYztcclxuZnVuY3Rpb24gc3ViVmVjKHZlYzEsIHZlYzIpIHtcclxuICAgIHJldHVybiB2ZWMxLm1hcCgoYSwgaSkgPT4gYSAtIHZlYzJbaV0pO1xyXG59XHJcbmV4cG9ydHMuc3ViVmVjID0gc3ViVmVjO1xyXG5mdW5jdGlvbiBtdWxWZWModmVjMSwgdmVjMikge1xyXG4gICAgcmV0dXJuIHZlYzEubWFwKChhLCBpKSA9PiBhICogdmVjMltpXSk7XHJcbn1cclxuZXhwb3J0cy5tdWxWZWMgPSBtdWxWZWM7XHJcbmZ1bmN0aW9uIGRpdlZlYyh2ZWMxLCB2ZWMyKSB7XHJcbiAgICByZXR1cm4gdmVjMS5tYXAoKGEsIGkpID0+IGEgLyB2ZWMyW2ldKTtcclxufVxyXG5leHBvcnRzLmRpdlZlYyA9IGRpdlZlYztcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dmVjdG9yLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmV4cG9ydHMub3BlcmF0b3JzID0gdm9pZCAwO1xyXG4vKipcclxuICogIyBDb21iaW5hdG9ycyBmb3IgUGFyc2luZyBBcnJheXMgYW5kIEV4cHJlc3Npb25zXHJcbiAqXHJcbiAqIFRoaXMgbW9kdWxlIGNvbnRhaW5zIGFkZGl0aW9uYWwgY29tYmluYXRvcnMgdGhhdCBhcmUgdXNlZnVsIHdoZW4gcGFyc2luZ1xyXG4gKiBzZXF1ZW5jZXMgb3IgZXhwcmVzc2lvbnMuIFRoZXkgYXJlIGFkYXB0ZWQgZnJvbSB0aGUgb3JpZ2luYWxcclxuICogW1BhcnNlY10oaHR0cDovL2hhY2thZ2UuaGFza2VsbC5vcmcvcGFja2FnZS9wYXJzZWMtMy4xLjEzLjAvZG9jcy9UZXh0LVBhcnNlYy1Db21iaW5hdG9yLmh0bWwpXHJcbiAqIGxpYnJhcnkuXHJcbiAqL1xyXG5jb25zdCBwYXIgPSByZXF1aXJlKFwiLi9wYXJzZXJcIik7XHJcbi8qKlxyXG4gKiAjIyBQYXJzaW5nIFNlcGFyYXRlZCBMaXN0c1xyXG4gKlxyXG4gKiBQYXJzZSBhbiBhcnJheSBjb250YWluaW5nIGF0IGxlYXN0IG9uZSBlbGVtZW50LiBUaGUgaXRlbXMgb2YgdGhlIGFycmF5IGFyZVxyXG4gKiByZWNvZ25pemVkIGJ5IGBwYXJzZXJgLiBUaGUgaXRlbXMgYXJlIHNlcGFyYXRlZCBieSBpbnB1dCByZWNvZ25pemVkIGJ5XHJcbiAqIGBzZXBhcmF0b3JgLiBUaGUgZnVuY3Rpb24gcmV0dXJucyBhbiBhcnJheSBvZiBwYXJzZWQgZWxlbWVudHMuXHJcbiAqL1xyXG5wYXIuUGFyc2VyLnByb3RvdHlwZS5vbmVPck1vcmVTZXBhcmF0ZWRCeSA9IGZ1bmN0aW9uIChzZXBhcmF0b3IpIHtcclxuICAgIHJldHVybiB0aGlzLmJpbmQoeCA9PiBzZXBhcmF0b3Iuc2VxKHRoaXMpLnplcm9Pck1vcmUoKS5iaW5kKHhzID0+IHBhci5tcmV0KFt4XS5jb25jYXQoeHMpKSkpO1xyXG59O1xyXG4vKipcclxuICogUGFyc2UgYSBwb3RlbnRpYWxseSBlbXB0eSBhcnJheS4gVGhlIGl0ZW1zIG9mIHRoZSBhcnJheSBhcmUgcmVjb2duaXplZCBieVxyXG4gKiBgcGFyc2VyYC4gVGhlIGl0ZW1zIGFyZSBzZXBhcmF0ZWQgYnkgaW5wdXQgcmVjb2duaXplZCBieSBgc2VwYXJhdG9yYC5cclxuICovXHJcbnBhci5QYXJzZXIucHJvdG90eXBlLnplcm9Pck1vcmVTZXBhcmF0ZWRCeSA9IGZ1bmN0aW9uIChzZXBhcmF0b3IpIHtcclxuICAgIHJldHVybiB0aGlzLm9uZU9yTW9yZVNlcGFyYXRlZEJ5KHNlcGFyYXRvcikub3IocGFyLm1yZXQoW10pKTtcclxufTtcclxuLyoqXHJcbiAqICMjIFRlcm1pbmF0b3JzICYgQnJhY2tldHNcclxuICpcclxuICogUGFyc2UgaXRlbShzKSBmb2xsb3dlZCBieSBhIHRlcm1pbmF0b3IgZ2l2ZW4gaW4gdGhlIGBhZnRlcmAgcGFyc2VyLiBUaGVcclxuICogcmVzdWx0IG9mIGBwYXJzZXJgIGlzIHJldHVybmVkLCBhbmQgcmVzdWx0IG9mIGBhZnRlcmAgaXMgaWdub3JlZC5cclxuICovXHJcbnBhci5QYXJzZXIucHJvdG90eXBlLmZvbGxvd2VkQnkgPSBmdW5jdGlvbiAoYWZ0ZXIpIHtcclxuICAgIHJldHVybiB0aGlzLmJpbmQocCA9PiBhZnRlci5iaW5kKF8gPT4gcGFyLm1yZXQocCkpKTtcclxufTtcclxuLyoqXHJcbiAqIFBhcnNlIGl0ZW0ocykgc3Vycm91bmRlZCBieSBpbnB1dCByZWNvZ25pemVkIGJ5IHRoZSBgc3Vycm91bmRgIHBhcnNlci4gVGhlXHJcbiAqIHJlc3VsdCBvZiBgcGFyc2VyYCBpcyByZXR1cm5lZC5cclxuICovXHJcbnBhci5QYXJzZXIucHJvdG90eXBlLnN1cnJvdW5kZWRCeSA9IGZ1bmN0aW9uIChzdXJyb3VuZCkge1xyXG4gICAgcmV0dXJuIHN1cnJvdW5kLmJpbmQobyA9PiB0aGlzLmJpbmQocCA9PiBzdXJyb3VuZC5iaW5kKGMgPT4gcGFyLm1yZXQocCkpKSk7XHJcbn07XHJcbi8qKlxyXG4gKiBQYXJzZSBpdGVtKHMpIHN1cnJvdW5kZWQgYnkgYW4gb3BlbiBhbmQgY2xvc2luZyBicmFja2V0LiBUaGUgcmVzdWx0IGBwYXJzZXJgXHJcbiAqIGlzIHJldHVybmVkLlxyXG4gKi9cclxucGFyLlBhcnNlci5wcm90b3R5cGUuYnJhY2tldGVkQnkgPSBmdW5jdGlvbiAob3BlbiwgY2xvc2UpIHtcclxuICAgIHJldHVybiBvcGVuLmJpbmQobyA9PiB0aGlzLmJpbmQocCA9PiBjbG9zZS5iaW5kKGMgPT4gcGFyLm1yZXQocCkpKSk7XHJcbn07XHJcbi8qKlxyXG4gKiAjIyBQYXJzaW5nIEV4cHJlc3Npb25zXHJcbiAqXHJcbiAqIFBhcnNlIG9uZSBvciBtb3JlIG9jY3VycmVuY2VzIG9mIGBwYXJzZXJgLCBzZXBhcmF0ZWQgYnkgYG9wZXJhdGlvbmAuXHJcbiAqIFJldHVybiBhIHZhbHVlIG9idGFpbmVkIGJ5IGEgbGVmdCBhc3NvY2lhdGl2ZSBhcHBsaWNhdGlvbiBvZiBhbGwgZnVuY3Rpb25zXHJcbiAqIHJldHVybmVkIGJ5IGBvcGVyYXRpb25gIHRvIHRoZSB2YWx1ZXMgcmV0dXJuZWQgYnkgYHBhcnNlcmAuIFRoaXMgcGFyc2VyIGNhblxyXG4gKiBmb3IgZXhhbXBsZSBiZSB1c2VkIHRvIGVsaW1pbmF0ZSBsZWZ0IHJlY3Vyc2lvbiB3aGljaCB0eXBpY2FsbHkgb2NjdXJzIGluXHJcbiAqIGV4cHJlc3Npb24gZ3JhbW1hcnMuXHJcbiAqL1xyXG5wYXIuUGFyc2VyLnByb3RvdHlwZS5jaGFpbk9uZU9yTW9yZSA9IGZ1bmN0aW9uIChvcGVyYXRpb24pIHtcclxuICAgIHJldHVybiB0aGlzLmJpbmQoeCA9PiBvcGVyYXRpb24uYmluZChmID0+IHRoaXMuYmluZCh5ID0+IHBhci5tcmV0KFtmLCB5XSkpKS56ZXJvT3JNb3JlKCkuYmluZChmeXMgPT4gcGFyLm1yZXQoZnlzLnJlZHVjZSgoeiwgW2YsIHldKSA9PiBmKHosIHkpLCB4KSkpKTtcclxufTtcclxuLyoqXHJcbiAqIFBhcnNlIHplcm8gb3IgbW9yZSBvY2N1cnJlbmNlcyBvZiBgcGFyc2VyYCwgc2VwYXJhdGVkIGJ5IGBvcGVyYXRpb25gLlxyXG4gKiBSZXR1cm4gYSB2YWx1ZSBvYnRhaW5lZCBieSBhIGxlZnQgYXNzb2NpYXRpdmUgYXBwbGljYXRpb24gb2YgYWxsIGZ1bmN0aW9uc1xyXG4gKiByZXR1cm5lZCBieSBgb3BlcmF0aW9uYCB0byB0aGUgdmFsdWVzIHJldHVybmVkIGJ5IGBwYXJzZXJgLiBJZiB0aGVyZSBhcmVcclxuICogemVybyBvY2N1cnJlbmNlcyBvZiBgcGFyc2VyYCwgdGhlIGB2YWx1ZWAgaXMgcmV0dXJuZWQuXHJcbiAqL1xyXG5wYXIuUGFyc2VyLnByb3RvdHlwZS5jaGFpblplcm9Pck1vcmUgPSBmdW5jdGlvbiAob3BlcmF0aW9uLCB2YWx1ZSkge1xyXG4gICAgcmV0dXJuIHRoaXMuY2hhaW5PbmVPck1vcmUob3BlcmF0aW9uKS5vcihwYXIubXJldCh2YWx1ZSkpO1xyXG59O1xyXG4vKipcclxuICogQ29uc3RydWN0IGEgcGFyc2VyIGZvciBvcGVyYXRvciBzZWxlY3Rpb24uIFVzZWQgdHlwaWNhbGx5IGluIGNvbmp1bmN0aW9uXHJcbiAqIHdpdGggYGNoYWluKmAgZnVuY3Rpb25zLlxyXG4gKi9cclxuZnVuY3Rpb24gb3BlcmF0b3JzKC4uLm9wcykge1xyXG4gICAgcmV0dXJuIHBhci5hbnkoLi4ub3BzLm1hcCgoW3AsIG9dKSA9PiBwLm1hcChfID0+IG8pKSk7XHJcbn1cclxuZXhwb3J0cy5vcGVyYXRvcnMgPSBvcGVyYXRvcnM7XHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmV4cG9ydHMuUGFyc2VFcnJvciA9IGV4cG9ydHMuRXJyb3JTb3VyY2UgPSB2b2lkIDA7XHJcbi8qKlxyXG4gKiAjIEVycm9yIFJlcG9ydGluZ1xyXG4gKlxyXG4gKiBXZSBkZWZpbmUgYSBjdXN0b20gRXJyb3IgY2xhc3MgZm9yIHBhcnNpbmcgZXJyb3JzLlxyXG4gKlxyXG4gKiBUaGUgcG9zc2libGUgc291cmNlcyBvZiBlcnJvcnMgYXJlIGRlZmluZWQgaW4gdGhlIGVudW1lcmF0aW9uIGJlbG93LlxyXG4gKi9cclxudmFyIEVycm9yU291cmNlO1xyXG4oZnVuY3Rpb24gKEVycm9yU291cmNlKSB7XHJcbiAgICBFcnJvclNvdXJjZVtcIklucHV0XCJdID0gXCJJbnB1dFwiO1xyXG4gICAgRXJyb3JTb3VyY2VbXCJMZXhlclwiXSA9IFwiTGV4ZXJcIjtcclxuICAgIEVycm9yU291cmNlW1wiUGFyc2VyXCJdID0gXCJQYXJzaW5nXCI7XHJcbn0pKEVycm9yU291cmNlID0gZXhwb3J0cy5FcnJvclNvdXJjZSB8fCAoZXhwb3J0cy5FcnJvclNvdXJjZSA9IHt9KSk7XHJcbi8qKlxyXG4gKiBUaGUgUGFyc2VFcnJvciBjbGFzcyBjb250YWlucyBpbmZvcm1hdGlvbiBhYm91dCB0aGUgcGFyc2luZyBlcnJvciBpblxyXG4gKiBhbiBlYXNpbHkgYWNjZXNzaWJsZSBmb3JtLlxyXG4gKi9cclxuY2xhc3MgUGFyc2VFcnJvciBleHRlbmRzIEVycm9yIHtcclxuICAgIGNvbnN0cnVjdG9yKFxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgc291cmNlIG9mIHRoZSBlcnJvci5cclxuICAgICAqL1xyXG4gICAgc291cmNlLCBcclxuICAgIC8qKlxyXG4gICAgICogVGhlIHBvc2l0aW9uIHdoZXJlIHRoZSBlcnJvciBoYXBwZW5lZC5cclxuICAgICAqL1xyXG4gICAgcG9zaXRpb24sIFxyXG4gICAgLyoqXHJcbiAgICAgKiBJbnB1dCBmb3VuZCBhdCBgcG9zaXRpb25gLlxyXG4gICAgICovXHJcbiAgICBmb3VuZCwgXHJcbiAgICAvKipcclxuICAgICAqIElucHV0IGV4cGVjdGVkIGF0IGBwb3NpdGlvbmAuIFRoZXJlIGNhbiBiZSBtdWx0aXBsZSB0ZXJtaW5hbHMuXHJcbiAgICAgKi9cclxuICAgIGV4cGVjdGVkID0gW10pIHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDb25zdHJ1Y3RvciBmb3JtYXRzIHRoZSBlcnJvciBtZXNzYWdlIHVzaW5nIHRoZSBwYXJhbWV0ZXJzIHByb3ZpZGVkLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHN1cGVyKGAke3NvdXJjZX0gZXJyb3IgYXQgcG9zaXRpb24gJHtwb3NpdGlvbiArIDF9LlxcbmAgK1xyXG4gICAgICAgICAgICBgXFx0Rm91bmQ6IFwiJHtmb3VuZH1cIlxcbmAgK1xyXG4gICAgICAgICAgICBgXFx0RXhwZWN0ZWQ6ICR7ZXhwZWN0ZWQubWFwKHMgPT4gYFwiJHtzfVwiYCkuam9pbihcIiwgXCIpfWApO1xyXG4gICAgICAgIHRoaXMuc291cmNlID0gc291cmNlO1xyXG4gICAgICAgIHRoaXMucG9zaXRpb24gPSBwb3NpdGlvbjtcclxuICAgICAgICB0aGlzLmZvdW5kID0gZm91bmQ7XHJcbiAgICAgICAgdGhpcy5leHBlY3RlZCA9IGV4cGVjdGVkO1xyXG4gICAgfVxyXG59XHJcbmV4cG9ydHMuUGFyc2VFcnJvciA9IFBhcnNlRXJyb3I7XHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XHJcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH0pO1xyXG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xyXG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcclxuICAgIG9bazJdID0gbVtrXTtcclxufSkpO1xyXG52YXIgX19leHBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2V4cG9ydFN0YXIpIHx8IGZ1bmN0aW9uKG0sIGV4cG9ydHMpIHtcclxuICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKHAgIT09IFwiZGVmYXVsdFwiICYmICFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZXhwb3J0cywgcCkpIF9fY3JlYXRlQmluZGluZyhleHBvcnRzLCBtLCBwKTtcclxufTtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG4vKipcclxuICogLS0tXHJcbiAqIHtcclxuICogIFwidmlzdWFsaXplcnNcIjogW1xyXG4gKiAgICAgIHtcclxuICogICAgICAgICAgXCJwYXRoXCI6IFwiLi9zcmMvdmlzdWFsaXplcnMvZGVwZW5kZW5jeS1kaWFnLnRzXCIsXHJcbiAqICAgICAgICAgIFwiaW5jbHVkZVN0eWxlc1wiOiB0cnVlXHJcbiAqICAgICAgfVxyXG4gKiAgXVxyXG4gKiB9XHJcbiAqIC0tLVxyXG4gKiAjIExpYnJhcnkgU3RydWN0dXJlXHJcbiAqXHJcbiAqIEJlbG93IGlzIHRoZSBkZXBlbmRlbmN5IGdyYXBoIHNob3dpbmcgdGhlIG1vZHVsZSBoaWVyYXJjaHkuIE5vdGUgdGhhdCBpdFxyXG4gKiBzaG93cyBhbHNvIHRoZSB0ZXN0aW5nIG1vZHVsZXMgd2hpY2ggYXJlIG5vdCBpbmNsdWRlZCBpbiB0aGUgcHVibGlzaGVkXHJcbiAqIHBhY2thZ2UuIFlvdSBjYW4ganVtcCB0byBhIG1vZHVsZSBieSBjbGlja2luZyBpdCBpbiB0aGUgZGlhZ3JhbS5cclxuICpcclxuICogPDx2OmRlcGVuZGVuY3ktZGlhZyAuLi9kZXBlbmRlbmNpZXMuanNvbiBzcmNcXC8oPyFleHRyYXMpPj5cclxuICpcclxuICogIyMgRXhwb3J0c1xyXG4gKlxyXG4gKiBQYXJ6ZWMgbGlicmFyeSBjb25zaXN0cyBvZiBmb2xsb3dpbmcgbW9kdWxlcy4gQWxsIG9mIHRoZW0gYXJlIGV4cG9ydGVkXHJcbiAqIG91dHNpZGUgdGhlIGxpYnJhcnkuXHJcbiAqL1xyXG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vcmVmXCIpLCBleHBvcnRzKTtcclxuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2Vycm9yXCIpLCBleHBvcnRzKTtcclxuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2lucHV0XCIpLCBleHBvcnRzKTtcclxuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL3Jlc3VsdFwiKSwgZXhwb3J0cyk7XHJcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9lcnJvclwiKSwgZXhwb3J0cyk7XHJcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9sZXhlclwiKSwgZXhwb3J0cyk7XHJcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9wYXJzZXJcIiksIGV4cG9ydHMpO1xyXG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vYXJyYXlwYXJzZXJzXCIpLCBleHBvcnRzKTtcclxuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL3V0aWxzXCIpLCBleHBvcnRzKTtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuZXhwb3J0cy5hcnJheUlucHV0ID0gdm9pZCAwO1xyXG4vKipcclxuICogIyMgQXJyYXkgSW5wdXRcclxuICpcclxuICogQXJyYXlzIGFyZSB0aGUgbW9zdCBjb21tb24gaW5wdXQgZGF0YSB0eXBlLiBUaGVyZWZvcmUgd2UgcHJvdmlkZSBhIGdlbmVyaWNcclxuICogaW1wbGVtZW50YXRpb24gZm9yIHRoZW0uIEFycmF5IGl0ZW1zIG1heSBoYXZlIGFueSB0eXBlIGBTYC4gVGhlIGNsYXNzIGlzXHJcbiAqIG5vdCBleHBvcnRlZCBvdXRzaWRlIHRoZSBtb2R1bGUuIFVzZXJzIGNhbiBjcmVhdGUgaXQgdXNpbmcgdGhlIGBhcnJheUlucHV0YFxyXG4gKiBmdW5jdGlvbi5cclxuICovXHJcbmNsYXNzIEFycmF5SW5wdXQge1xyXG4gICAgLyoqXHJcbiAgICAgKiBXZSBzZXQgdGhlIHBvc2l0aW9uIGluaXRpYWxseSB0byAtMSB0byBpbmRpY2F0ZSB0aGF0IG5vIGlucHV0IGhhcyBiZWVuXHJcbiAgICAgKiBjb25zdW1lZC4gVGhlIGN1cnJlbnQgaXRlbSBpcyBgdW5kZWZpbmVkYC5cclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IoYXJyYXksIGVvZikge1xyXG4gICAgICAgIHRoaXMuYXJyYXkgPSBhcnJheTtcclxuICAgICAgICB0aGlzLnBvc2l0aW9uID0gLTE7XHJcbiAgICAgICAgdGhpcy5jdXJyZW50ID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIHRoaXMuZW9mID0gZW9mO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm4gdGhlIG5leHQgaXRlbSBpbiB0aGUgYXJyYXkuIFVwZGF0ZSBgcG9zaXRpb25gIGFuZFxyXG4gICAgICogYGN1cnJlbnRgIGZpZWxkcy5cclxuICAgICAqL1xyXG4gICAgbmV4dCgpIHtcclxuICAgICAgICBsZXQgcG9zID0gdGhpcy5wb3NpdGlvbiArIDE7XHJcbiAgICAgICAgaWYgKHBvcyA+PSB0aGlzLmFycmF5Lmxlbmd0aClcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZW9mO1xyXG4gICAgICAgIHRoaXMucG9zaXRpb24gPSBwb3M7XHJcbiAgICAgICAgdGhpcy5jdXJyZW50ID0gdGhpcy5hcnJheVtwb3NdO1xyXG4gICAgICAgIHJldHVybiB0aGlzLmN1cnJlbnQ7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqICMjIEV4cG9ydGVkIEZ1bmN0aW9uc1xyXG4gKlxyXG4gKiBDcmVhdGUgYSBQYXJzZXJJbnB1dCB3cmFwcGVyIGZvciBhbiBhcnJheS5cclxuICovXHJcbmZ1bmN0aW9uIGFycmF5SW5wdXQoYXJyYXksIGVvZikge1xyXG4gICAgcmV0dXJuIG5ldyBBcnJheUlucHV0KGFycmF5LCBlb2YpO1xyXG59XHJcbmV4cG9ydHMuYXJyYXlJbnB1dCA9IGFycmF5SW5wdXQ7XHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmV4cG9ydHMubGV4ZXJJbnB1dCA9IGV4cG9ydHMuTGV4ZXIgPSBleHBvcnRzLlRva2VuID0gdm9pZCAwO1xyXG5jb25zdCB1dGlscyA9IHJlcXVpcmUoXCIuL3V0aWxzXCIpO1xyXG5jb25zdCBlcnIgPSByZXF1aXJlKFwiLi9lcnJvclwiKTtcclxuLyoqXHJcbiAqICMjIFJlcHJlc2VudGluZyBhIFRva2VuXHJcbiAqXHJcbiAqIFdoZW4gYSB0b2tlbiBpcyByZWNvZ25pemVkIGl0IGlzIHdyYXBwZWQgaW4gYSBgVG9rZW48Uz5gIG9iamVjdC4gVGhpc1xyXG4gKiBjb250YWlucyBhbHNvIHRoZSByZWNvZ25pemVkIHN0cmluZyBmb3IgZXJyb3IgcmVwb3J0aW5nIGFuZCBkaWFnbm9zdGljcy5cclxuICovXHJcbmNsYXNzIFRva2VuIHtcclxuICAgIGNvbnN0cnVjdG9yKHRva2VuLCB0ZXh0KSB7XHJcbiAgICAgICAgdGhpcy50b2tlbiA9IHRva2VuO1xyXG4gICAgICAgIHRoaXMudGV4dCA9IHRleHQ7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFdlIG92ZXJyaWRlIHRoZSBgdG9TdHJpbmdgIGZ1bmN0aW9uIHNvIHdlIGNhbiBvdXRwdXQgYSB0b2tlblxyXG4gICAgICogdG8gc2NyZWVuLlxyXG4gICAgICovXHJcbiAgICB0b1N0cmluZygpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy50ZXh0ID8gdXRpbHMuZXNjYXBlV2hpdGVzcGFjZSh0aGlzLnRleHQpIDogdGhpcy50b2tlbjtcclxuICAgIH1cclxufVxyXG5leHBvcnRzLlRva2VuID0gVG9rZW47XHJcbi8qKlxyXG4gKiAjIyBMZXhlclxyXG4gKlxyXG4gKiBUaGUgbGV4ZXIgaXRzZWxmIGlzIGEgc2ltcGxlIGNsYXNzIHRoYXQgY29udGFpbnMgYWxsIHRoZSBUb2tlbk1hdGNoZXJzIGFuZFxyXG4gKiByZWNvZ25pemVzIHRoZSBuZXh0IHRva2VuIGluIGEgc3RyaW5nLlxyXG4gKi9cclxuY2xhc3MgTGV4ZXIge1xyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgY29uc3RydWN0b3IgYWRkcyB0d28gZmxhZ3MgdG8gdGhlIHJlZ3VsYXIgZXhwcmVzc2lvbnMgZ2l2ZW4gYXNcclxuICAgICAqIGFyZ3VtZW50cy4gVGhlIGB5YCBmbGFnIG1ha2VzIHRoZSBzZWFyY2ggc3RpY2t5IHNvIHRoYXQgaXQgc2NhbnMgdGhlXHJcbiAgICAgKiBpbnB1dCBzdHJpbmcgZnJvbSB0aGUgcG9zaXRpb24gaW5kaWNhdGVkIGJ5IHRoZSBgbGFzdEluZGV4YCBwcm9wZXJ0eS5cclxuICAgICAqIFRoZSBgdWAgZmxhZyBtYWtlcyB0aGUgc2VhcmNoIHN1cHBvcnQgdW5pY29kZSBjaGFyYWN0ZXJzLlxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3RvciguLi50b2tlbnMpIHtcclxuICAgICAgICB0aGlzLm1hdGNoZXJzID0gdG9rZW5zLm1hcCh0ID0+ICh7XHJcbiAgICAgICAgICAgIHJlZ2V4OiBuZXcgUmVnRXhwKHRbMF0sIFwieXVcIiksXHJcbiAgICAgICAgICAgIHRva2VuOiB0WzFdXHJcbiAgICAgICAgfSkpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBXZSBjaGVjayBtYXRjaGVycyBvbmUtYnktb25lIGluIHRoZSBvcmRlciB0aGV5IHdlcmUgZ2l2ZW4gdG9cclxuICAgICAqIHJlY29nbml6ZSB0aGUgdG9rZW4gaW4gdGhlIGdpdmVuIHBvc2l0aW9uLiBJZiBub25lIG9mIHRoZSBtYXRjaGVyc1xyXG4gICAgICogc3VjY2VlZCwgd2UgcmV0dXJuIGBudWxsYC5cclxuICAgICAqL1xyXG4gICAgbWF0Y2hUb2tlbihpbnB1dCwgcG9zKSB7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLm1hdGNoZXJzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGxldCBtYXRjaGVyID0gdGhpcy5tYXRjaGVyc1tpXTtcclxuICAgICAgICAgICAgbWF0Y2hlci5yZWdleC5sYXN0SW5kZXggPSBwb3M7XHJcbiAgICAgICAgICAgIGxldCBtYXRjaCA9IG1hdGNoZXIucmVnZXguZXhlYyhpbnB1dCk7XHJcbiAgICAgICAgICAgIGlmIChtYXRjaCAhPSBudWxsKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBUb2tlbihtYXRjaGVyLnRva2VuLCBtYXRjaFswXSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG59XHJcbmV4cG9ydHMuTGV4ZXIgPSBMZXhlcjtcclxuLyoqXHJcbiAqICMjIExleGVyIGFzIElucHV0XHJcbiAqXHJcbiAqIFdlIGNhbiBpbnRlZ3JhdGUgbGV4aW5nIGRpcmVjdGx5IGludG8gdGhlIHBhcnNpbmcgcHJvY2VzcyBieSBpbXBsZW1lbnRpbmdcclxuICogdGhlIGBQYXJzZXJJbnB1dGAgaW50ZXJmYWNlIGZvciBhbnkgdG9rZW4uIFdlIGRvbid0IGV4cG9zZSBgTGV4ZXJJbnB1dGBcclxuICogY2xhc3Mgb3V0c2lkZSB0aGUgbW9kdWxlLiBJdCBjYW4gYmUgY3JlYXRlZCB3aXRoIHRoZSBgbGV4ZXJJbnB1dGAgZnVuY3Rpb24uXHJcbiAqL1xyXG5jbGFzcyBMZXhlcklucHV0IHtcclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlIGFuIGlucHV0IHN0cmVhbSBmb3IgZ2l2ZW4gc3RyaW5nIGFuZCBsZXhlci4gSW5pdGlhbGl6ZSB0aGVcclxuICAgICAqIGluc3RhbmNlIHZhcmlhYmxlcy5cclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IoaW5wdXQsIGxleGVyLCBlb2YpIHtcclxuICAgICAgICB0aGlzLmlucHV0ID0gaW5wdXQ7XHJcbiAgICAgICAgdGhpcy5sZXhlciA9IGxleGVyO1xyXG4gICAgICAgIHRoaXMudG9rZW5zID0gbmV3IEFycmF5KGlucHV0Lmxlbmd0aCk7XHJcbiAgICAgICAgdGhpcy5wb3NpdGlvbiA9IC0xO1xyXG4gICAgICAgIHRoaXMuZW9mID0gZW9mO1xyXG4gICAgICAgIHRoaXMuY3VycmVudCA9IHRoaXMuZW9mO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgaXRlcmF0b3IgaW1wbGVtZW50YXRpb24gaXMgZmFpcmx5IHN0cmFpZ2h0Zm9yd2FyZC4gV2UgbmVlZCB0byBtYWtlXHJcbiAgICAgKiBzdXJlIHRoYXQgdGhlIHN0YXRlIHZhcmlhYmxlcyBgcG9zaXRpb25gIGFuZCBgY3VycmVudGAgYXJlIGtlcHQgaW4gc3luY1xyXG4gICAgICogd2hpbGUgd2UgYWR2YW5jZSBpbiB0aGUgaW5wdXQgc3RyaW5nLiBXZSBtdXN0IGFsc28gZG8gYSBsb29rdXAgaW4gdGhlXHJcbiAgICAgKiBjYWNow6kgYmVmb3JlIGNhbGxpbmcgdGhlIGxleGVyIHRvIHJlY29nbml6ZSB0aGUgdG9rZW4uIElmIHRoZSBsZXhlciBmaW5kc1xyXG4gICAgICogYSBtYXRjaCwgd2UgdXBkYXRlIHRoZSBjYWNow6kuIElmIHRoZSBsZXhlciBjYW5ub3QgcmVjb2duaXplIHRoZSBuZXh0XHJcbiAgICAgKiB0b2tlbiwgd2UgdGhyb3cgYSBgUGFyc2VFcnJvcmAuXHJcbiAgICAgKi9cclxuICAgIG5leHQoKSB7XHJcbiAgICAgICAgbGV0IHBvcyA9IHRoaXMucG9zaXRpb247XHJcbiAgICAgICAgcG9zICs9IHRoaXMudG9rZW5zW3Bvc10gPyB0aGlzLnRva2Vuc1twb3NdLnRleHQubGVuZ3RoIDogMTtcclxuICAgICAgICBpZiAocG9zID49IHRoaXMuaW5wdXQubGVuZ3RoKVxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5lb2Y7XHJcbiAgICAgICAgdGhpcy5wb3NpdGlvbiA9IHBvcztcclxuICAgICAgICBsZXQgbWF0Y2ggPSB0aGlzLnRva2Vuc1twb3NdIHx8IHRoaXMubGV4ZXIubWF0Y2hUb2tlbih0aGlzLmlucHV0LCBwb3MpO1xyXG4gICAgICAgIGlmICghbWF0Y2gpXHJcbiAgICAgICAgICAgIHRocm93IG5ldyBlcnIuUGFyc2VFcnJvcihlcnIuRXJyb3JTb3VyY2UuTGV4ZXIsIHBvcywgdGhpcy5pbnB1dC5zdWJzdHIocG9zLCAxMCkgKyBcIi4uLlwiLCBbXCI8dmFsaWQgdG9rZW4+XCJdKTtcclxuICAgICAgICB0aGlzLnRva2Vuc1twb3NdID0gbWF0Y2g7XHJcbiAgICAgICAgdGhpcy5jdXJyZW50ID0gbWF0Y2g7XHJcbiAgICAgICAgcmV0dXJuIG1hdGNoO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBDcmVhdGUgYW4gaW5wdXQgc3RyZWFtIGZvciBnaXZlbiBgdGV4dGAgc3RyaW5nIHVzaW5nIHRoZSBnaXZlbiBgbGV4ZXJgLlxyXG4gKi9cclxuZnVuY3Rpb24gbGV4ZXJJbnB1dCh0ZXh0LCBsZXhlciwgZW9mKSB7XHJcbiAgICByZXR1cm4gbmV3IExleGVySW5wdXQodGV4dCwgbGV4ZXIsIGVvZik7XHJcbn1cclxuZXhwb3J0cy5sZXhlcklucHV0ID0gbGV4ZXJJbnB1dDtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuZXhwb3J0cy50ZXJtaW5hbCA9IGV4cG9ydHMudG9rZW4gPSBleHBvcnRzLmlzID0gZXhwb3J0cy5hbnl0aGluZyA9IGV4cG9ydHMuZm9yd2FyZFJlZiA9IGV4cG9ydHMuY2xlYW51cFN0YXRlID0gZXhwb3J0cy5jaGVja1N0YXRlID0gZXhwb3J0cy5tdXRhdGVTdGF0ZSA9IGV4cG9ydHMuc2V0U3RhdGUgPSBleHBvcnRzLmdldFN0YXRlID0gZXhwb3J0cy5wb3NpdGlvbiA9IGV4cG9ydHMuY2hvb3NlID0gZXhwb3J0cy5wZWVrID0gZXhwb3J0cy5hbnkgPSBleHBvcnRzLm5vdFNhdGlzZnkgPSBleHBvcnRzLnNhdGlzZnkgPSBleHBvcnRzLmZhaWwgPSBleHBvcnRzLm1yZXQgPSBleHBvcnRzLnBhcnNlID0gZXhwb3J0cy50cnlQYXJzZSA9IGV4cG9ydHMucGFyc2VyRGVidWcgPSBleHBvcnRzLlBhcnNlciA9IHZvaWQgMDtcclxuY29uc3QgcHIgPSByZXF1aXJlKFwiLi9yZXN1bHRcIik7XHJcbmNvbnN0IHV0aWxzID0gcmVxdWlyZShcIi4vdXRpbHNcIik7XHJcbmNvbnN0IGVyciA9IHJlcXVpcmUoXCIuL2Vycm9yXCIpO1xyXG4vKipcclxuICogIyMgUGFyc2VyIENsYXNzXHJcbiAqXHJcbiAqIFRoZSBjZW50cmFsIHR5cGUgaW4gdGhlIFBhcnplYyBsaWJyYXJ5IGlzIHRoZSBgUGFyc2VyPFQsIFM+YCBjbGFzcy4gSXQgd3JhcHNcclxuICogYSBwYXJzaW5nIGZ1bmN0aW9uIGFuZCBwcm92aWRlcyB0aGUgY29yZSBjb21iaW5hdG9ycyB0byBjb21iaW5lIHBhcnNlcnMgaW5cclxuICogdmFyaW91cyB3YXlzLlxyXG4gKi9cclxuY2xhc3MgUGFyc2VyIHtcclxuICAgIC8qKlxyXG4gICAgICogQ29uc3RydWN0b3Igd3JhcHMgdGhlIHBhcnNpbmcgZnVuY3Rpb24uXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKHBhcnNlKSB7XHJcbiAgICAgICAgdGhpcy5wYXJzZSA9IHBhcnNlO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgbW9uYWRpYyBiaW5kIHRoYXQgY29ycmVzcG9uZHMgdG8gSGFza2VsbCdzIGA+Pj1gIG9wZXJhdG9yLiBSdW5zXHJcbiAgICAgKiBgdGhpc2AgcGFyc2VyLCBhbmQgaWYgaXQgc3VjY2VlZHMsIGZlZWRzIGl0cyByZXN1bHQgdG8gdGhlIGBiaW5kZXJgXHJcbiAgICAgKiBmdW5jdGlvbiB0aGF0IHJldHVybnMgYSBuZXcgUGFyc2VyLiBUaGlzIGlzIHRoZSBiYXNpYyBvcGVyYXRpb24gdGhhdCBpc1xyXG4gICAgICogdXNlZCBpbiBvdGhlciBjb21iaW5hdG9ycyB0byBnbHVlIHBhcnNlcnMgdG9nZXRoZXIuXHJcbiAgICAgKi9cclxuICAgIGJpbmQoYmluZGVyKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBQYXJzZXIoaW5wdXQgPT4ge1xyXG4gICAgICAgICAgICBsZXQgcG9zID0gaW5wdXQucG9zaXRpb247XHJcbiAgICAgICAgICAgIGxldCByZXMxID0gdGhpcy5wYXJzZShpbnB1dCk7XHJcbiAgICAgICAgICAgIGlmIChyZXMxLmtpbmQgPT0gXCJva1wiKSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgcmVzMiA9IGJpbmRlcihyZXMxLnJlc3VsdCkucGFyc2UoaW5wdXQpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHJlczIua2luZCA9PSBcImZhaWxcIiAmJiBwb3MgIT09IGlucHV0LnBvc2l0aW9uKVxyXG4gICAgICAgICAgICAgICAgICAgIGlucHV0LnBvc2l0aW9uID0gcG9zOyAvLyBiYWNrdHJhY2tcclxuICAgICAgICAgICAgICAgIHJldHVybiByZXMyO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiByZXMxO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgc2VxdWVuY2Ugb3BlcmF0b3IuIFJ1bnMgYHRoaXNgIHBhcnNlciwgYW5kIGlmIGl0IHN1Y2NlZWRzLCBydW5zIHRoZVxyXG4gICAgICogYG90aGVyYCBwYXJzZXIgaWdub3JpbmcgdGhlIHJlc3VsdCBvZiBgdGhpc2Agb25lLlxyXG4gICAgICovXHJcbiAgICBzZXEob3RoZXIpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5iaW5kKF8gPT4gb3RoZXIpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBNYXAgcmVzdWx0IG9mIHRoZSBwYXJzZXIgdG8gYW5vdGhlciB2YWx1ZS4gVGhpcyBmdW5jdGlvbiBpbXBsZW1lbnRzIGFcclxuICAgICAqIFtfZnVuY3Rvcl9dKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0Z1bmN0b3IpIHdoaWNoIGlzIGEgc3VwZXJjbGFzc1xyXG4gICAgICogb2YgbW9uYWQuXHJcbiAgICAgKi9cclxuICAgIG1hcChtYXBwZXIpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5iaW5kKHggPT4gbXJldChtYXBwZXIoeCkpKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogIyMgQ29uZGl0aW9uYWwgUGFyc2luZ1xyXG4gICAgICpcclxuICAgICAqIFRoZSBvcmRlcmVkIGNob2ljZSBvcGVyYXRpb24uIENyZWF0ZXMgYSBwYXJzZXIgdGhhdCBmaXJzdCBydW5zIGB0aGlzYFxyXG4gICAgICogcGFyc2VyLCBhbmQgaWYgdGhhdCBmYWlscywgcnVucyB0aGUgYG90aGVyYCBvbmUuIENvcnJlc3BvbmRzIHRvIHRoZSBgL2BcclxuICAgICAqIG9wZXJhdGlvbiBpbiBbUEVHIGdyYW1tYXJzXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9QYXJzaW5nX2V4cHJlc3Npb25fZ3JhbW1hcikuXHJcbiAgICAgKi9cclxuICAgIG9yKG90aGVyKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBQYXJzZXIoaW5wdXQgPT4ge1xyXG4gICAgICAgICAgICBsZXQgcG9zID0gaW5wdXQucG9zaXRpb247XHJcbiAgICAgICAgICAgIGxldCByZXMxID0gdGhpcy5wYXJzZShpbnB1dCk7XHJcbiAgICAgICAgICAgIGlmIChyZXMxLmtpbmQgPT0gXCJva1wiKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlczE7XHJcbiAgICAgICAgICAgIGlmIChyZXMxLnBvc2l0aW9uID4gcG9zKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlczE7XHJcbiAgICAgICAgICAgIGxldCByZXMyID0gb3RoZXIucGFyc2UoaW5wdXQpO1xyXG4gICAgICAgICAgICBpZiAocmVzMi5raW5kID09IFwib2tcIilcclxuICAgICAgICAgICAgICAgIHJldHVybiByZXMyO1xyXG4gICAgICAgICAgICBwci5qb2luRXhwZWN0ZWQocmVzMiwgcmVzMSk7XHJcbiAgICAgICAgICAgIHJldHVybiByZXMyO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBQYXJzZSBhbiBvcHRpb25hbCB2YWx1ZSwgaWYgdGhlIHBhcnNlciBmYWlscyB0aGVuIHRoZSBkZWZhdWx0IHZhbHVlIGlzXHJcbiAgICAgKiByZXR1cm5lZC5cclxuICAgICAqL1xyXG4gICAgb3B0aW9uYWwoZGVmYXVsdFZhbHVlKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMub3IobXJldChkZWZhdWx0VmFsdWUpKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUGFyc2UgYW4gb3B0aW9uYWwgcmVmZXJlbmNlIHZhbHVlLCBpZiB0aGUgcGFyc2VyIGZhaWxzIHRoZW4gbnVsbCBpc1xyXG4gICAgICogcmV0dXJuZWQuXHJcbiAgICAgKi9cclxuICAgIG9wdGlvbmFsUmVmKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLm9yKG1yZXQobnVsbCkpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSdW5zIHBhcnNlciBhbmQgY2hlY2tzIHRoYXQgaXQgc3VjY2VlZHMgYW5kIHRoYXQgdGhlIHJlc3VsdCBpdCByZXR1cm5zXHJcbiAgICAgKiBzYXRpc2ZpZXMgYSBnaXZlbiBwcmVkaWNhdGUuXHJcbiAgICAgKi9cclxuICAgIHdoZXJlKHByZWRpY2F0ZSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmJpbmQoeCA9PiBwcmVkaWNhdGUoeCkgPyBtcmV0KHgpIDogZmFpbChgJHt4fWAsIFwicHJlZGljYXRlXCIpKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogIyMgUGFyc2luZyBNdWx0aXBsZSBJdGVtc1xyXG4gICAgICpcclxuICAgICAqIENyZWF0ZXMgYSBwYXJzZXIgdGhhdCB3aWxsIHJ1biBgdGhpc2AgcGFyc2VyIHplcm8gb3IgbW9yZSB0aW1lcy4gVGhlXHJcbiAgICAgKiByZXN1bHRzIG9mIHRoZSBpbnB1dCBwYXJzZXIgYXJlIGFkZGVkIHRvIGFuIGFycmF5LlxyXG4gICAgICovXHJcbiAgICB6ZXJvT3JNb3JlKCkge1xyXG4gICAgICAgIHJldHVybiBuZXcgUGFyc2VyKGlucHV0ID0+IHtcclxuICAgICAgICAgICAgbGV0IGxpc3QgPSBbXTtcclxuICAgICAgICAgICAgd2hpbGUgKHRydWUpIHtcclxuICAgICAgICAgICAgICAgIGxldCBwb3MgPSBpbnB1dC5wb3NpdGlvbjtcclxuICAgICAgICAgICAgICAgIGxldCByZXMgPSB0aGlzLnBhcnNlKGlucHV0KTtcclxuICAgICAgICAgICAgICAgIGlmIChyZXMua2luZCA9PSBcImZhaWxcIilcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzLnBvc2l0aW9uID4gcG9zID9cclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzIDogcHIuc3VjY2VlZGVkKHJlcy5wb3NpdGlvbiwgbGlzdCk7XHJcbiAgICAgICAgICAgICAgICBsaXN0LnB1c2gocmVzLnJlc3VsdCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIHBhcnNlciB0aGF0IHJ1bnMgYHRoaXNgIHBhcnNlciBvbmUgb3IgbW9yZSB0aW1lcy5cclxuICAgICAqL1xyXG4gICAgb25lT3JNb3JlKCkge1xyXG4gICAgICAgIHJldHVybiBuZXcgUGFyc2VyKGlucHV0ID0+IHtcclxuICAgICAgICAgICAgbGV0IHJlcyA9IHRoaXMucGFyc2UoaW5wdXQpO1xyXG4gICAgICAgICAgICBpZiAocmVzLmtpbmQgPT0gXCJmYWlsXCIpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzO1xyXG4gICAgICAgICAgICBsZXQgbGlzdCA9IFtyZXMucmVzdWx0XTtcclxuICAgICAgICAgICAgd2hpbGUgKHRydWUpIHtcclxuICAgICAgICAgICAgICAgIGxldCBwb3MgPSBpbnB1dC5wb3NpdGlvbjtcclxuICAgICAgICAgICAgICAgIHJlcyA9IHRoaXMucGFyc2UoaW5wdXQpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHJlcy5raW5kID09IFwiZmFpbFwiKVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXMucG9zaXRpb24gPiBwb3MgP1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXMgOiBwci5zdWNjZWVkZWQocmVzLnBvc2l0aW9uLCBsaXN0KTtcclxuICAgICAgICAgICAgICAgIGxpc3QucHVzaChyZXMucmVzdWx0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBQYXJzaW5nIHN1Y2NlZWRzIGlmIGB0aGlzYCBwYXJzZXIgc3VjY2VlZHMgZnJvbSBgbWluYCB0byBgbWF4YCB0aW1lcy5cclxuICAgICAqL1xyXG4gICAgb2NjdXJyZW5jZXMobWluLCBtYXgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy56ZXJvT3JNb3JlKCkuYmluZChsaXN0ID0+IHtcclxuICAgICAgICAgICAgbGV0IGNudCA9IGxpc3QubGVuZ3RoO1xyXG4gICAgICAgICAgICByZXR1cm4gY250ID49IG1pbiAmJiBjbnQgPD0gbWF4ID9cclxuICAgICAgICAgICAgICAgIG1yZXQobGlzdCkgOlxyXG4gICAgICAgICAgICAgICAgZmFpbChgJHtjbnR9IG9jY3VycmVuY2VzYCwgYCR7bWlufS0ke21heH0gb2NjdXJyZW5jZXNgKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogIyMgTG9va2FoZWFkICYgQmFja3RyYWNraW5nXHJcbiAgICAgKlxyXG4gICAgICogQ2hlY2sgdGhhdCBgdGhpc2AgcGFyc2VyIHN1Y2NlZWRzIHdpdGhvdXQgY29uc3VtaW5nIGFueSBpbnB1dC5cclxuICAgICAqIENvcnJlc3BvbmRzIHRvIHRoZSBgJmAgb3BlcmF0b3IgaW4gUEVHIGdyYW1tYXJzLlxyXG4gICAgICovXHJcbiAgICBhbmQoKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBQYXJzZXIoaW5wdXQgPT4ge1xyXG4gICAgICAgICAgICBsZXQgcG9zID0gaW5wdXQucG9zaXRpb247XHJcbiAgICAgICAgICAgIGxldCByZXMgPSB0aGlzLnBhcnNlKGlucHV0KTtcclxuICAgICAgICAgICAgaW5wdXQucG9zaXRpb24gPSBwb3M7XHJcbiAgICAgICAgICAgIHJldHVybiByZXM7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENoZWNrIHRoYXQgYHRoaXNgIHBhcnNlciBmYWlscyB3aXRob3V0IGNvbnN1bWluZyBhbnkgaW5wdXQuIENvcnJlc3BvbmRzXHJcbiAgICAgKiB0byB0aGUgYCFgIG9wZXJhdG9yIGluIFBFRyBncmFtbWFycy5cclxuICAgICAqL1xyXG4gICAgbm90KCkge1xyXG4gICAgICAgIHJldHVybiBuZXcgUGFyc2VyKGlucHV0ID0+IHtcclxuICAgICAgICAgICAgbGV0IHBvcyA9IGlucHV0LnBvc2l0aW9uO1xyXG4gICAgICAgICAgICBsZXQgcmVzID0gdGhpcy5wYXJzZShpbnB1dCk7XHJcbiAgICAgICAgICAgIGlucHV0LnBvc2l0aW9uID0gcG9zO1xyXG4gICAgICAgICAgICBpZiAocmVzLmtpbmQgPT0gXCJva1wiKSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgZm91bmQgPSBgJHtyZXMucmVzdWx0fWA7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcHIuZmFpbGVkKHJlcy5wb3NpdGlvbiwgZm91bmQsIFtcIm5vdCBcIiArIGZvdW5kXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHByLnN1Y2NlZWRlZChyZXMucG9zaXRpb24sIHVuZGVmaW5lZCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEJhY3RyYWNrIHRvIHRoZSBjdXJyZW50IGlucHV0IHBvc2l0aW9uLCBldmVuIGlmIHRoZSBnaXZlbiBwYXJzZXIgZmFpbHNcclxuICAgICAqIGFuZCBoYXMgYWR2YW5jZWQgdGhlIGlucHV0IHBvc2l0aW9uLiBOb3JtYWxseSB3ZSBkbyBub3QgYmFjdHJhY2sgd2hlbiBhXHJcbiAgICAgKiBwYXJzZXIgaGFzIGFkdmFuY2VkIGluIHRoZSBpbnB1dC4gRG9pbmcgc28gd291bGQgbG9vc2UgdGhlIHBvc2l0aW9uIHdoZXJlXHJcbiAgICAgKiB0aGUgcGFyc2luZyBmYWlsZWQgYW5kIG1ha2UgZXJyb3IgbWVzc2FnZXMgbW9yZSB2YWd1ZS4gU29tZXRpbWVzLFxyXG4gICAgICogaG93ZXZlciwgd2UgbmVlZCBtb3JlIGlucHV0IGxvb2thaGVhZC4gSW4gdGhlc2UgY2FzZXMsIHlvdSBjYW4gdXNlIHRoZVxyXG4gICAgICogYmFja3RyYWNrIG9wZXJhdGlvbiB0byByZXRyeSB0aGUgbmV4dCBydWxlLlxyXG4gICAgICovXHJcbiAgICBiYWNrdHJhY2soKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBQYXJzZXIoaW5wdXQgPT4ge1xyXG4gICAgICAgICAgICBsZXQgcG9zID0gaW5wdXQucG9zaXRpb247XHJcbiAgICAgICAgICAgIGxldCByZXMgPSB0aGlzLnBhcnNlKGlucHV0KTtcclxuICAgICAgICAgICAgaWYgKHJlcy5raW5kID09IFwiZmFpbFwiICYmIHJlcy5wb3NpdGlvbiA+IHBvcylcclxuICAgICAgICAgICAgICAgIHJlcy5wb3NpdGlvbiA9IHBvcztcclxuICAgICAgICAgICAgcmV0dXJuIHJlcztcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogIyMgRXJyb3IgUmVwb3J0aW5nIGFuZCBEZWJ1Z2dpbmdcclxuICAgICAqXHJcbiAgICAgKiBHaXZlIGEgaHVtYW4tcmVhZGFibGUgbmFtZSB0byB0aGUgXCJ0aGluZ1wiIHRoYXQgdGhlIGdpdmVuIHBhcnNlciBtYXRjaGVzLlxyXG4gICAgICogVGhpcyBuYW1lIGlzIHJlcG9ydGVkIGFzIGV4cGVjdGVkIHZhbHVlLCBpZiB0aGUgcGFyc2luZyBmYWlscy5cclxuICAgICAqL1xyXG4gICAgZXhwZWN0KGV4cGVjdGVkKSB7XHJcbiAgICAgICAgaWYgKCFleHBvcnRzLnBhcnNlckRlYnVnLmVycm9yTWVzc2FnZXMpXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgIGxldCByZXNQYXJzZXIgPSBuZXcgUGFyc2VyKChpbnB1dCkgPT4ge1xyXG4gICAgICAgICAgICBsZXQgcmVzID0gdGhpcy5wYXJzZShpbnB1dCk7XHJcbiAgICAgICAgICAgIGlmIChyZXMua2luZCA9PSBcImZhaWxcIilcclxuICAgICAgICAgICAgICAgIHJlcy5leHBlY3RlZC5wdXNoKGV4cGVjdGVkKTtcclxuICAgICAgICAgICAgcmV0dXJuIHJlcztcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gZXhwb3J0cy5wYXJzZXJEZWJ1Zy5kZWJ1Z2dpbmcgPyByZXNQYXJzZXIudHJhY2UoZXhwZWN0ZWQpIDogcmVzUGFyc2VyO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBBdHRhY2ggZGVidWdnaW5nIGluZm9ybWF0aW9uIHRvIGEgcGFyc2VyLiBUbyB0cmFjZSB3aGljaCBydWxlcyBhcmVcclxuICAgICAqIHRyaWdnZXJlZCBkdXJpbmcgcGFyc2luZywgeW91IGNhbiBhZGQgZGVidWdnaW5nIGluZm8gdG8gYW55IHBhcnNlci4gVGhpc1xyXG4gICAgICogY29tYmluYXRvciBwcm9kdWNlcyBhIGhpZXJhcmNoaWNhbCB0cmVlIG9mIHBhcnNlciBpbnZvY2F0aW9ucyB3aGljaFxyXG4gICAgICogaW5jbHVkZXMgaW5mb3JtYXRpb24gYWJvdXQgaW5wdXQgc3ltYm9sIGFuZCBpdHMgcG9zaXRpb24uIElmIGRlYnVnZ2luZ1xyXG4gICAgICogaXMgZGlzYWJsZWQsIHRoaXMgZnVuY3Rpb24gZG9lcyBub3RoaW5nLlxyXG4gICAgICovXHJcbiAgICB0cmFjZShydWxlTmFtZSkge1xyXG4gICAgICAgIGlmICghZXhwb3J0cy5wYXJzZXJEZWJ1Zy5kZWJ1Z2dpbmcpXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgIHJldHVybiBuZXcgUGFyc2VyKGlucHV0ID0+IHtcclxuICAgICAgICAgICAgZXhwb3J0cy5wYXJzZXJEZWJ1Zy53cml0ZShgJHtydWxlTmFtZX0gY2FsbGVkIHdpdGggaW5wdXQgJyR7aW5wdXQuY3VycmVudH0nLmApO1xyXG4gICAgICAgICAgICBleHBvcnRzLnBhcnNlckRlYnVnLmluZGVudCgpO1xyXG4gICAgICAgICAgICBsZXQgcmVzID0gdGhpcy5wYXJzZShpbnB1dCk7XHJcbiAgICAgICAgICAgIGV4cG9ydHMucGFyc2VyRGVidWcucnVsZXNFdmFsdWF0ZWQrKztcclxuICAgICAgICAgICAgZXhwb3J0cy5wYXJzZXJEZWJ1Zy51bmluZGVudCgpO1xyXG4gICAgICAgICAgICBleHBvcnRzLnBhcnNlckRlYnVnLndyaXRlKChyZXMua2luZCA9PSBcIm9rXCIgP1xyXG4gICAgICAgICAgICAgICAgYCR7cnVsZU5hbWV9IFNVQ0NFRURFRCB3aXRoIHZhbHVlICcke3V0aWxzLmVzY2FwZVdoaXRlc3BhY2UoYCR7cmVzLnJlc3VsdH1gKX0nYCA6XHJcbiAgICAgICAgICAgICAgICBgJHtydWxlTmFtZX0gRkFJTEVEIHdpdGggdmFsdWUgJyR7dXRpbHMuZXNjYXBlV2hpdGVzcGFjZShgJHtyZXMuZm91bmR9YCl9Jy4gRXhwZWN0ZWQgdmFsdWVzOiAke3ByLmV4cGVjdGVkQXNDc3YocmVzKX1gKSArXHJcbiAgICAgICAgICAgICAgICBgIGF0IHBvc2l0aW9uICR7cmVzLnBvc2l0aW9ufWApO1xyXG4gICAgICAgICAgICByZXR1cm4gcmVzO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG59XHJcbmV4cG9ydHMuUGFyc2VyID0gUGFyc2VyO1xyXG4vKipcclxuICogIyMgRGVidWdnaW5nIE9wdGlvbnNcclxuICpcclxuICogVGhlIGZvbGxvd2luZyBvYmplY3QgY29udGFpbnMgdGhlIGdsb2JhbCBzZXR0aW5ncyB0aGF0IGNvbnRyb2wgdGhlIHBhcnNlclxyXG4gKiByZXBvcnRpbmcuXHJcbiAqL1xyXG5leHBvcnRzLnBhcnNlckRlYnVnID0ge1xyXG4gICAgLyoqXHJcbiAgICAgKiBXaGVuIGBkZWJ1Z2dpbmdgIGZsYWcgaXMgb24gcGFyc2VycyBjb3VudCB0aGUgbnVtYmVyIG9mIHJ1bGVzIGV2YWx1YXRlZFxyXG4gICAgICogZHVyaW5nIHRoZWlyIG9wZXJhdGlvbi4gVGhlIGBydWxlc0V2YWx1YXRlZGAgZmllbGQgY29udGFpbnMgdGhpc1xyXG4gICAgICogaW5mb3JtYXRpb24uXHJcbiAgICAgKi9cclxuICAgIGRlYnVnZ2luZzogZmFsc2UsXHJcbiAgICBydWxlc0V2YWx1YXRlZDogMCxcclxuICAgIC8qKlxyXG4gICAgICogSWYgZXJyb3JNZXNzYWdlcyBmbGFnIGlzIHR1cm5lZCBvZmYsIHRoZSBleHBlY3RlZCBpbmZvcm1hdGlvbiB3aWxsIG5vdCBiZVxyXG4gICAgICogYXZhaWxhYmxlIGluIHBhcnNlIGVycm9ycy4gVGhpcyBzcGVlZHMgdXAgdGhlIHBhcnNpbmcgbm9taW5hbGx5LlxyXG4gICAgICovXHJcbiAgICBlcnJvck1lc3NhZ2VzOiB0cnVlLFxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgY3VycmVudCBpbmRlbnRhdGlvbiBsZXZlbCBpbiB0aGUgZGVidWdnaW5nIG91dHB1dCBpcyBzdG9yZWQgaW4gdGhpc1xyXG4gICAgICogZmllbGQuXHJcbiAgICAgKi9cclxuICAgIGluZGVudGF0aW9uOiAwLFxyXG4gICAgLyoqXHJcbiAgICAgKiBJbmRlbnQgdGhlIGRlYnVnIG91dHB1dCBieSBvbmUgbGV2ZWwuXHJcbiAgICAgKi9cclxuICAgIGluZGVudCgpIHtcclxuICAgICAgICB0aGlzLmluZGVudGF0aW9uKys7XHJcbiAgICB9LFxyXG4gICAgLyoqXHJcbiAgICAgKiBVbm5kZW50IHRoZSBkZWJ1ZyBvdXRwdXQgYnkgb25lIGxldmVsLlxyXG4gICAgICovXHJcbiAgICB1bmluZGVudCgpIHtcclxuICAgICAgICB0aGlzLmluZGVudGF0aW9uLS07XHJcbiAgICB9LFxyXG4gICAgLyoqXHJcbiAgICAgKiBXcml0ZSBhIHN0cmluZyB0byB0aGUgZGVidWcgb3V0cHV0LlxyXG4gICAgICovXHJcbiAgICB3cml0ZSh0ZXh0KSB7XHJcbiAgICAgICAgbGV0IHRhYnMgPSBcIiAgXCIucmVwZWF0KHRoaXMuaW5kZW50YXRpb24pO1xyXG4gICAgICAgIGNvbnNvbGUubG9nKHRhYnMgKyB0ZXh0KTtcclxuICAgIH1cclxufTtcclxuLyoqXHJcbiAqICMjIE1haW4gRnVuY3Rpb25zXHJcbiAqXHJcbiAqIEF0dGVtcHQgdG8gcGFyc2UgYW4gaW5wdXQgd2l0aCBhIGdpdmVuIHBhcnNlci4gVGFrZXMgYSBQYXJzZXIgYW5kIGFcclxuICogUGFyc2VySW5wdXQgYXMgYXJndW1lbnRzIGFuZCByZXR1cm4gYSBQYXJzZVJlc3VsdC5cclxuICovXHJcbmZ1bmN0aW9uIHRyeVBhcnNlKHBhcnNlciwgaW5wdXQpIHtcclxuICAgIGV4cG9ydHMucGFyc2VyRGVidWcucnVsZXNFdmFsdWF0ZWQgPSAwO1xyXG4gICAgbGV0IHJlcyA9IHBhcnNlci5wYXJzZShpbnB1dCk7XHJcbiAgICBpZiAoZXhwb3J0cy5wYXJzZXJEZWJ1Zy5kZWJ1Z2dpbmcpXHJcbiAgICAgICAgY29uc29sZS5pbmZvKFwiTnVtYmVyIG9mIHJ1bGVzIGV2YWx1YXRlZDogXCIgKyBleHBvcnRzLnBhcnNlckRlYnVnLnJ1bGVzRXZhbHVhdGVkKTtcclxuICAgIHJldHVybiByZXM7XHJcbn1cclxuZXhwb3J0cy50cnlQYXJzZSA9IHRyeVBhcnNlO1xyXG4vKipcclxuICogUGFyc2UgYW4gaW5wdXQgdXNpbmcgYSBnaXZlbiBwYXJzZXIsIG9yIHRocm93IGFuIGV4Y2VwdGlvbiwgaWYgcGFyc2luZyBmYWlscy5cclxuICovXHJcbmZ1bmN0aW9uIHBhcnNlKHBhcnNlciwgaW5wdXQpIHtcclxuICAgIHZhciByZXMgPSB0cnlQYXJzZShwYXJzZXIsIGlucHV0KTtcclxuICAgIGlmIChyZXMua2luZCA9PSBcImZhaWxcIilcclxuICAgICAgICB0aHJvdyBuZXcgZXJyLlBhcnNlRXJyb3IoZXJyLkVycm9yU291cmNlLlBhcnNlciwgcmVzLnBvc2l0aW9uLCByZXMuZm91bmQsIHJlcy5leHBlY3RlZCk7XHJcbiAgICByZXR1cm4gcmVzLnJlc3VsdDtcclxufVxyXG5leHBvcnRzLnBhcnNlID0gcGFyc2U7XHJcbi8qKlxyXG4gKiAjIyBNb25hZGljIFJldHVybnNcclxuICpcclxuICogQ3JlYXRlIGEgcGFyc2VyIHRoYXQgYWx3YXlzIHN1Y2NlZWRzIGFuZCByZXR1cm5zIHRoZSBnaXZlbiB2YWx1ZSB3aXRob3V0XHJcbiAqIGNvbnN1bWluZyBhbnkgaW5wdXQuIFRoaXMgZnVuY3Rpb24gaW1wbGVtZW50cyB0aGUgbW9uYWRpYyByZXR1cm4sIHRoYXQgaXMsXHJcbiAqIGl0IGxpZnRzIGEgdmFsdWUgdG8gdGhlIHBhcnNlciBtb25hZC5cclxuICovXHJcbmZ1bmN0aW9uIG1yZXQodmFsdWUpIHtcclxuICAgIHJldHVybiBuZXcgUGFyc2VyKGlucHV0ID0+IHByLnN1Y2NlZWRlZChpbnB1dC5wb3NpdGlvbiwgdmFsdWUpKTtcclxufVxyXG5leHBvcnRzLm1yZXQgPSBtcmV0O1xyXG4vKipcclxuICogQ3JlYXRlIGEgcGFyc2VyIHRoYXQgYWx3YXlzIGZhaWxzLiBUaGUgdGVybWluYWxzIHJlcG9ydGVkIGFzXHJcbiAqIGZvdW5kIG9yIGV4cGVjdGVkIGFyZSBnaXZlbiBhcyBhbiBhcmd1bWVudC5cclxuICovXHJcbmZ1bmN0aW9uIGZhaWwoZm91bmQsIC4uLmV4cGVjdGVkKSB7XHJcbiAgICByZXR1cm4gbmV3IFBhcnNlcihpbnB1dCA9PiBwci5mYWlsZWQoaW5wdXQucG9zaXRpb24sIGZvdW5kLCBleHBlY3RlZCkpO1xyXG59XHJcbmV4cG9ydHMuZmFpbCA9IGZhaWw7XHJcbi8qKlxyXG4gKiAjIyBQYXJzaW5nIFRlcm1pbmFsc1xyXG4gKlxyXG4gKiBDcmVhdGVzIGEgcGFyc2VyIHRoYXQgcmVhZHMgb25lIHRlcm1pbmFsIGZyb20gdGhlIGlucHV0IGFuZCByZXR1cm5zIGl0LCBpZiBpdFxyXG4gKiBzYXRpc2ZpZXMgdGhlIGdpdmVuIHByZWRpY2F0ZTsgb3RoZXJ3aXNlIHRoZSBwYXJzZXIgZmFpbHMuXHJcbiAqL1xyXG5mdW5jdGlvbiBzYXRpc2Z5KHByZWRpY2F0ZSkge1xyXG4gICAgcmV0dXJuIG5ldyBQYXJzZXIoaW5wdXQgPT4ge1xyXG4gICAgICAgIGxldCBwb3MgPSBpbnB1dC5wb3NpdGlvbjtcclxuICAgICAgICBsZXQgaXRlbSA9IGlucHV0Lm5leHQoKTtcclxuICAgICAgICBpZiAocHJlZGljYXRlKGl0ZW0pKVxyXG4gICAgICAgICAgICByZXR1cm4gcHIuc3VjY2VlZGVkKGlucHV0LnBvc2l0aW9uLCBpdGVtKTtcclxuICAgICAgICBpbnB1dC5wb3NpdGlvbiA9IHBvcztcclxuICAgICAgICByZXR1cm4gcHIuZmFpbGVkKGlucHV0LnBvc2l0aW9uLCBgJHtpdGVtfWApO1xyXG4gICAgfSk7XHJcbn1cclxuZXhwb3J0cy5zYXRpc2Z5ID0gc2F0aXNmeTtcclxuLyoqXHJcbiAqIENyZWF0ZXMgYSBwYXJzZXIgdGhhdCByZWFkcyBvbmUgdGVybWluYWwgZnJvbSB0aGUgaW5wdXQgYW5kIHJldHVybnMgaXQsIGlmIGl0XHJcbiAqIGRvZXMgKipub3QqKiBzYXRpc2Z5IGEgZ2l2ZW4gcHJlZGljYXRlLlxyXG4gKi9cclxuZnVuY3Rpb24gbm90U2F0aXNmeShwcmVkaWNhdGUpIHtcclxuICAgIHJldHVybiBzYXRpc2Z5KHggPT4gIXByZWRpY2F0ZSh4KSk7XHJcbn1cclxuZXhwb3J0cy5ub3RTYXRpc2Z5ID0gbm90U2F0aXNmeTtcclxuLyoqXHJcbiAqIEFueSBvZiB0aGUgZ2l2ZW4gcGFyc2VycyBtdXN0IHN1Y2NlZWQuIFRoZSBvcGVyYXRpb24gaXMgdGhlIHNhbWVcclxuICogYXMgdGhlIGBvcmAgY29tYmluYXRvciBnZW5lcmFsaXplZCB0byBhcmJpdHJhcnkgbnVtYmVyIG9mIGNob2ljZXMuXHJcbiAqL1xyXG5mdW5jdGlvbiBhbnkoLi4ucGFyc2Vycykge1xyXG4gICAgaWYgKHBhcnNlcnMubGVuZ3RoID09IDApXHJcbiAgICAgICAgdGhyb3cgRXJyb3IoXCJBdCBsZWFzdCBvbmUgcGFyc2VyIG11c3QgYmUgZ2l2ZW4uXCIpO1xyXG4gICAgcmV0dXJuIG5ldyBQYXJzZXIoaW5wdXQgPT4ge1xyXG4gICAgICAgIGxldCByZXMgPSBudWxsO1xyXG4gICAgICAgIGxldCBpID0gMDtcclxuICAgICAgICBsZXQgcG9zID0gaW5wdXQucG9zaXRpb247XHJcbiAgICAgICAgZG8ge1xyXG4gICAgICAgICAgICBsZXQgciA9IHBhcnNlcnNbaSsrXS5wYXJzZShpbnB1dCk7XHJcbiAgICAgICAgICAgIGlmIChyLmtpbmQgPT0gXCJva1wiKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHI7XHJcbiAgICAgICAgICAgIGlmIChyLnBvc2l0aW9uID4gcG9zKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHI7XHJcbiAgICAgICAgICAgIGlmIChyZXMgPT0gbnVsbClcclxuICAgICAgICAgICAgICAgIHJlcyA9IHI7XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgIHByLmpvaW5FeHBlY3RlZChyZXMsIHIpO1xyXG4gICAgICAgIH0gd2hpbGUgKGkgPCBwYXJzZXJzLmxlbmd0aCk7XHJcbiAgICAgICAgcmV0dXJuIHJlcztcclxuICAgIH0pO1xyXG59XHJcbmV4cG9ydHMuYW55ID0gYW55O1xyXG4vKipcclxuICogUGVlayBuZXh0IHN5bWJvbCBpbiB0aGUgaW5wdXQgc3RyZWFtIHdpdGhvdXQgY2hhbmdpbmcgdGhlIHBvc2l0aW9uLlxyXG4gKi9cclxuZnVuY3Rpb24gcGVlaygpIHtcclxuICAgIHJldHVybiBuZXcgUGFyc2VyKGlucHV0ID0+IHtcclxuICAgICAgICBsZXQgcG9zID0gaW5wdXQucG9zaXRpb247XHJcbiAgICAgICAgbGV0IG5leHQgPSBpbnB1dC5uZXh0KCk7XHJcbiAgICAgICAgaW5wdXQucG9zaXRpb24gPSBwb3M7XHJcbiAgICAgICAgcmV0dXJuIHByLnN1Y2NlZWRlZChwb3MsIG5leHQpO1xyXG4gICAgfSk7XHJcbn1cclxuZXhwb3J0cy5wZWVrID0gcGVlaztcclxuLyoqXHJcbiAqIFNlbGVjdCBhIHBhcnNlciB0byBiZSB1c2VkIGJhc2VkIG9uIHRoZSBuZXh0IHN5bWJvbCBpbiB0aGUgaW5wdXQuIFRoaXNcclxuICogZnVuY3Rpb24gaXMgYW4gYWx0ZXJuYXRpdmUgdG8gdGhlIHRoZSBcImFueVwiIGNvbWJpbmF0b3IuIEl0IHJlZHVjZXNcclxuICogYmFja3RyYWNraW5nIHdoZW4gdGhlIHBhcnNlciB0byBiZSBhcHBsaWVkIGNhbiBiZSBkZWR1Y2VkIGZyb20gdGhlIG5leHRcclxuICogc3ltYm9sLlxyXG4gKi9cclxuZnVuY3Rpb24gY2hvb3NlKHNlbGVjdG9yKSB7XHJcbiAgICByZXR1cm4gcGVlaygpLmJpbmQoc2VsZWN0b3IpO1xyXG59XHJcbmV4cG9ydHMuY2hvb3NlID0gY2hvb3NlO1xyXG4vKipcclxuICogIyMgR2V0dGluZyBDdXJyZW50IFBvc2l0aW9uXHJcbiAqXHJcbiAqIEEgcGFyc2VyIHRoYXQgcmV0dXJucyB0aGUgY3VycmVudCBwb3NpdGlvbiBvZiB0aGUgaW5wdXQuIFRoaXMgaXMgdXNlZnVsXHJcbiAqIHdoZW4gYmluZGluZyBwYXJzZXJzIHRvZ2V0aGVyIGFuZCB5b3Ugd2FudCB0byBrbm93IHRoZSBwb3NpdGlvbiB3aGVyZSB5b3VcclxuICogY3VycmVudGx5IGFyZS4gVGhlIHBvc2l0aW9uIGNhbiBiZSBhbHNvIHVzZWQgZm9yIGJhY2t0cmFja2luZy5cclxuICovXHJcbmZ1bmN0aW9uIHBvc2l0aW9uKCkge1xyXG4gICAgcmV0dXJuIG5ldyBQYXJzZXIoaW5wdXQgPT4gcHIuc3VjY2VlZGVkKGlucHV0LnBvc2l0aW9uLCBpbnB1dC5wb3NpdGlvbikpO1xyXG59XHJcbmV4cG9ydHMucG9zaXRpb24gPSBwb3NpdGlvbjtcclxuLyoqXHJcbiAqICMjIFVzZXItTWFuYWdlZCBTdGF0ZVxyXG4gKlxyXG4gKiBHZXQgdGhlIGN1cnJlbnQgc2F0ZWxsaXRlIHN0YXRlIHN0b3JlZCBpbiB0aGUgaW5wdXQuXHJcbiAqL1xyXG5mdW5jdGlvbiBnZXRTdGF0ZSgpIHtcclxuICAgIHJldHVybiBuZXcgUGFyc2VyKGlucHV0ID0+IHByLnN1Y2NlZWRlZChpbnB1dC5wb3NpdGlvbiwgaW5wdXQuc3RhdGUpKTtcclxufVxyXG5leHBvcnRzLmdldFN0YXRlID0gZ2V0U3RhdGU7XHJcbi8qKlxyXG4gKiBTZXQgdGhlIGN1cnJlbnQgc2F0ZWxsaXRlIHN0YXRlIHN0b3JlZCBpbiB0aGUgaW5wdXQuIFRoZSBuZXcgc3RhdGVcclxuICogaXMgbm90IGdpdmVuIGV4cGxpY2l0bHkuIFJhdGhlciwgYSBmdW5jaW9uIHdoaWNoIHJldHVybnMgdGhlIG5ld1xyXG4gKiBzdGF0ZSBpcyBzcGVjaWZpZWQuXHJcbiAqL1xyXG5mdW5jdGlvbiBzZXRTdGF0ZShuZXdWYWx1ZSkge1xyXG4gICAgcmV0dXJuIG5ldyBQYXJzZXIoaW5wdXQgPT4gcHIuc3VjY2VlZGVkKGlucHV0LnBvc2l0aW9uLCBpbnB1dC5zdGF0ZSA9IG5ld1ZhbHVlKCkpKTtcclxufVxyXG5leHBvcnRzLnNldFN0YXRlID0gc2V0U3RhdGU7XHJcbi8qKlxyXG4gKiBNdXRhdGUgdGhlIHNhdGVsbGl0ZSBzdGF0ZSBzdG9yZWQgaW4gdGhlIGlucHV0LiBUaGUgbXV0YXRpb24gaXMgZG9uZVxyXG4gKiB3aXRoIGEgZnVuY3Rpb24gZ2l2ZW4gYXMgYW4gYXJndW1lbnQuXHJcbiAqL1xyXG5mdW5jdGlvbiBtdXRhdGVTdGF0ZShtdXRhdGUpIHtcclxuICAgIHJldHVybiBuZXcgUGFyc2VyKGlucHV0ID0+IHtcclxuICAgICAgICBtdXRhdGUoaW5wdXQuc3RhdGUpO1xyXG4gICAgICAgIHJldHVybiBwci5zdWNjZWVkZWQoaW5wdXQucG9zaXRpb24sIGlucHV0LnN0YXRlKTtcclxuICAgIH0pO1xyXG59XHJcbmV4cG9ydHMubXV0YXRlU3RhdGUgPSBtdXRhdGVTdGF0ZTtcclxuLyoqXHJcbiAqIENoZWNrIHRoYXQgdGhlIGN1cnJlbnQgc3RhdGUgbWF0Y2hlcyBhIHByZWRpY2F0ZS4gSWYgbm90LCB0aGUgcmVzdWx0IHBhcnNlclxyXG4gKiBmYWlscy5cclxuICovXHJcbmZ1bmN0aW9uIGNoZWNrU3RhdGUocHJlZGljYXRlKSB7XHJcbiAgICByZXR1cm4gbmV3IFBhcnNlcihpbnB1dCA9PiBwcmVkaWNhdGUoaW5wdXQuc3RhdGUpID9cclxuICAgICAgICBwci5zdWNjZWVkZWQoaW5wdXQucG9zaXRpb24sIGlucHV0LnN0YXRlKSA6XHJcbiAgICAgICAgcHIuZmFpbGVkKGlucHV0LnBvc2l0aW9uLCBcIk1hdGNoaW5nIHByZWRpY2F0ZS5cIikpO1xyXG59XHJcbmV4cG9ydHMuY2hlY2tTdGF0ZSA9IGNoZWNrU3RhdGU7XHJcbi8qKlxyXG4gKiBDbGVhbiB1cCB0aGUgY3VycmVudCBzdGF0ZSBhZnRlciBhIHBhcnNlciBoYXMgYmVlbiBleGVjdXRlZC4gVGhlIGNsZWFuLXVwXHJcbiAqIGZ1bmN0aW9uIGlzIHJ1biByZWdhcmRsZXNzIG9mIHdoZXRoZXIgdGhlIHBhcnNlciBzdWNjZWVkcyBvciBmYWlscy5cclxuICovXHJcbmZ1bmN0aW9uIGNsZWFudXBTdGF0ZShwYXJzZXIsIGNsZWFudXApIHtcclxuICAgIHJldHVybiBuZXcgUGFyc2VyKGlucHV0ID0+IHtcclxuICAgICAgICBsZXQgcmVzID0gcGFyc2VyLnBhcnNlKGlucHV0KTtcclxuICAgICAgICBjbGVhbnVwKGlucHV0LnN0YXRlKTtcclxuICAgICAgICByZXR1cm4gcmVzO1xyXG4gICAgfSk7XHJcbn1cclxuZXhwb3J0cy5jbGVhbnVwU3RhdGUgPSBjbGVhbnVwU3RhdGU7XHJcbi8qKlxyXG4gKiAjIyBEZWZpbmluZyBNdXR1YWxseSBSZWN1cnNpdmUgUGFyc2Vyc1xyXG4gKlxyXG4gKiBPZnRlbiBncmFtbWFyIHJ1bGVzIGFyZSBtdXR1YWxseSByZWN1cnNpdmUsIHdoaWNoIG1lYW5zIHRoYXQgdGhlcmUgaXMgbm8gd2F5XHJcbiAqIHRvIHdyaXRlIHRoZW0gaW4gYW4gb3JkZXIgd2hlcmUgYWxsIHRoZSBkZXBlbmRlbnQgcnVsZXMgYXJlIGRlZmluZWQuIEluIHRoZXNlXHJcbiAqIG9jY2FzaW9ucywgeW91IGNhbiBqdXN0IGNyZWF0ZSBhIF9yZWZlcmVuY2VfIHRvIGEgcGFyc2VyIGFuZCBzZXQgaXRzXHJcbiAqIGltcGxlbWVudGF0aW9uIGxhdGVyLiBUbyByZWZlciB0byB0aGUgcGFyc2VyIHRoYXQgaXMgbm90IHlldCBkZWZpbmVkLCB5b3UgY2FuXHJcbiAqIHVzZSB0aGlzIGZ1bmN0aW9uLlxyXG4gKi9cclxuZnVuY3Rpb24gZm9yd2FyZFJlZihwYXJzZXIpIHtcclxuICAgIHJldHVybiBuZXcgUGFyc2VyKGlucHV0ID0+IHBhcnNlci50YXJnZXQucGFyc2UoaW5wdXQpKTtcclxufVxyXG5leHBvcnRzLmZvcndhcmRSZWYgPSBmb3J3YXJkUmVmO1xyXG4vKipcclxuICogIyMgR2VuZXJhbCBQYXJzZXJzXHJcbiAqXHJcbiAqIFRoZSBjYXRjaC1hbGwgcGFyc2VyIHRoYXQgd2lsbCBtYXRjaCBhbnkgc3ltYm9sIHJlYWQgZnJvbSB0aGUgaW5wdXQuXHJcbiAqL1xyXG5mdW5jdGlvbiBhbnl0aGluZygpIHtcclxuICAgIHJldHVybiBzYXRpc2Z5KF8gPT4gdHJ1ZSk7XHJcbn1cclxuZXhwb3J0cy5hbnl0aGluZyA9IGFueXRoaW5nO1xyXG4vKipcclxuICogUGFyc2VyIHRoYXQgc3VjY2VlZHMgaWYgdGhlIHN5bWJvbCByZWFkIGZyb20gdGhlIGlucHV0IGlzIGVxdWFsICg9PT0pIHRvXHJcbiAqIGdpdmVuIHBhcmFtZXRlcjsgb3RoZXJ3aXNlIHBhcnNpbmcgZmFpbHMuXHJcbiAqL1xyXG5mdW5jdGlvbiBpcyh2YWx1ZSkge1xyXG4gICAgcmV0dXJuIHNhdGlzZnkoeCA9PiB4ID09PSB2YWx1ZSk7XHJcbn1cclxuZXhwb3J0cy5pcyA9IGlzO1xyXG4vKipcclxuICogUGFyc2UgYSBzcGVjaWZpYyB0b2tlbiBmcm9tIHRoZSBsZXhlciBpbnB1dCBzdHJlYW0uXHJcbiAqL1xyXG5mdW5jdGlvbiB0b2tlbih0b2tlbikge1xyXG4gICAgcmV0dXJuIHNhdGlzZnkodCA9PiB0LnRva2VuID09PSB0b2tlbik7XHJcbn1cclxuZXhwb3J0cy50b2tlbiA9IHRva2VuO1xyXG4vKipcclxuICogSGVscGVyIGZ1bmN0aW9uIHRvIGNyZWF0ZSBhIHRlcm1pbmFsIHBhcnNlci5cclxuICovXHJcbmZ1bmN0aW9uIHRlcm1pbmFsKHRvaywgbmFtZSkge1xyXG4gICAgcmV0dXJuIHRva2VuKHRvaykuZXhwZWN0KG5hbWUpO1xyXG59XHJcbmV4cG9ydHMudGVybWluYWwgPSB0ZXJtaW5hbDtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuZXhwb3J0cy5SZWYgPSB2b2lkIDA7XHJcbi8qKlxyXG4gKiAjIFJlZmVyZW5jZSBDZWxsc1xyXG4gKlxyXG4gKiBgUmVmPFQ+YCBjbGFzcyBwcm92aWRlcyBhIHNpbXBsZSByZWZlcmVuY2UgY2VsbCwgd2hpY2ggY2FuIGJlIHVzZWRcclxuICogYXMgYSBzdXJyb2dhdGUgZm9yIGEgcGFyc2VyIHRoYXQgaXMgZGVmaW5lZCBsYXRlciBvbi4gV2UgY2FuIGRlZmluZVxyXG4gKiBhIF9yZWZlcmVuY2VfIHRvIHBhcnNlciwgYnV0IHdlIGRvbid0IGhhdmUgdG8gZ2l2ZSB0aGUgdGFyZ2V0IHJpZ2h0XHJcbiAqIGF3YXkuIFdoZW4gY29tcG9zaW5nIHBhcnNlcnMgd2UgY2FuIHVzZSB0aGUgYGZvcndhcmRSZWZgIGZ1bmN0aW9uXHJcbiAqIHRvIHBhc3MgYSByZWZlcmVuY2UgdG8gYW55IGNvbWJpbmF0b3IgZXhwZWN0aW5nIGEgYFBhcnNlcjxULCBTPmAuXHJcbiAqIE9mIGNvdXJzZSwgd2UgaGF2ZSB0byBldmVudHVhbGx5IGFzc2lnbiBhIHJlYWwgcGFyc2VyIGFzIHRoZSB0YXJnZXRcclxuICogb2YgdGhlIHJlZmVyZW5jZSBiZWZvcmUgcnVubmluZyB0aGUgcGFyc2VyLlxyXG4gKi9cclxuY2xhc3MgUmVmIHtcclxuICAgIC8qKlxyXG4gICAgICogQ29uc3RydWN0aW5nIGEgcmVmZXJlbmNlLiBUaGUgdGFyZ2V0IHZhbHVlIGlzIG9wdGlvbmFsLlxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3Rvcih2YWx1ZSkge1xyXG4gICAgICAgIHRoaXMuX3RhcmdldCA9IG51bGw7XHJcbiAgICAgICAgaWYgKHZhbHVlKVxyXG4gICAgICAgICAgICB0aGlzLl90YXJnZXQgPSB2YWx1ZTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogR2V0IHRoZSB0YXJnZXQgb2YgdGhlIHJlZmVyZW5jZS4gSWYgbm8gdGFyZ2V0IGlzIHNldCwgYVxyXG4gICAgICogYFJlZmVyZW5jZUVycm9yYCBpcyB0aHJvd24uXHJcbiAgICAgKi9cclxuICAgIGdldCB0YXJnZXQoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX3RhcmdldClcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3RhcmdldDtcclxuICAgICAgICB0aHJvdyBSZWZlcmVuY2VFcnJvcihcIlRhcmdldCBub3Qgc2V0LlwiKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogU2V0IHRoZSB0YXJnZXQuXHJcbiAgICAgKi9cclxuICAgIHNldCB0YXJnZXQodmFsdWUpIHtcclxuICAgICAgICB0aGlzLl90YXJnZXQgPSB2YWx1ZTtcclxuICAgIH1cclxufVxyXG5leHBvcnRzLlJlZiA9IFJlZjtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuZXhwb3J0cy5mYWlsZWQgPSBleHBvcnRzLnN1Y2NlZWRlZCA9IGV4cG9ydHMuZXhwZWN0ZWRBc0NzdiA9IGV4cG9ydHMuam9pbkV4cGVjdGVkID0gdm9pZCAwO1xyXG4vKipcclxuICogIyMgSGVscGVyIEZ1bmN0aW9uc1xyXG4gKlxyXG4gKiBUaGUgYGpvaW5FeHBlY3RlZGAgZnVuY3Rpb24gY29uY2F0ZW5hdGVzIHRoZSBsaXN0IG9mIGV4cGVjdGVkXHJcbiAqIGlucHV0cyBmcm9tIHRoZSBgb3RoZXJgIGZhaWxlZCBwYXJzZSByZXN1bHQgaW50byB0aGUgYGV4cGVjdGVkYFxyXG4gKiBhcnJheSBvZiB0aGUgZmlyc3Qgb25lLlxyXG4gKi9cclxuZnVuY3Rpb24gam9pbkV4cGVjdGVkKHJlc3VsdCwgb3RoZXIpIHtcclxuICAgIGlmIChvdGhlci5leHBlY3RlZC5sZW5ndGggPiAwKVxyXG4gICAgICAgIHJlc3VsdC5leHBlY3RlZCA9IHJlc3VsdC5leHBlY3RlZC5jb25jYXQob3RoZXIuZXhwZWN0ZWQpO1xyXG59XHJcbmV4cG9ydHMuam9pbkV4cGVjdGVkID0gam9pbkV4cGVjdGVkO1xyXG4vKipcclxuICogVGhpcyBmdW5jdGlvbiBmb3JtYXRzIHRoZSBhcnJheSBvZiBleHBlY3RlZCBpbnB1dHMgYXMgYSBzdHJpbmcgZm9yXHJcbiAqIHByaW50aW5nLlxyXG4gKi9cclxuZnVuY3Rpb24gZXhwZWN0ZWRBc0NzdihyZXN1bHQpIHtcclxuICAgIHJldHVybiByZXN1bHQuZXhwZWN0ZWQubWFwKHMgPT4gYFwiJHtzfVwiYCkuam9pbihcIiwgXCIpO1xyXG59XHJcbmV4cG9ydHMuZXhwZWN0ZWRBc0NzdiA9IGV4cGVjdGVkQXNDc3Y7XHJcbi8qKlxyXG4gKiAjIyBDb25zdHJ1Y3RvciBGdW5jdGlvbnNcclxuICpcclxuICogVGhlIGZvbGxvd2luZyBmdW5jdGlvbiBpcyB1c2VkIHRvIGNvbnN0cnVjdCBhbiBgT2s8VD5gIHJlc3VsdC5cclxuICovXHJcbmZ1bmN0aW9uIHN1Y2NlZWRlZChwb3MsIHJlcykge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBraW5kOiBcIm9rXCIsXHJcbiAgICAgICAgcG9zaXRpb246IHBvcyxcclxuICAgICAgICByZXN1bHQ6IHJlc1xyXG4gICAgfTtcclxufVxyXG5leHBvcnRzLnN1Y2NlZWRlZCA9IHN1Y2NlZWRlZDtcclxuLyoqXHJcbiAqIFRoZSBuZXh0IG9uZSBjb25zdHJ1Y3RzIGEgYEZhaWxgIHJlc3VsdC5cclxuICovXHJcbmZ1bmN0aW9uIGZhaWxlZChwb3MsIGZuZCwgZXhwID0gW10pIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAga2luZDogXCJmYWlsXCIsXHJcbiAgICAgICAgcG9zaXRpb246IHBvcyxcclxuICAgICAgICBmb3VuZDogZm5kLFxyXG4gICAgICAgIGV4cGVjdGVkOiBleHBcclxuICAgIH07XHJcbn1cclxuZXhwb3J0cy5mYWlsZWQgPSBmYWlsZWQ7XHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmV4cG9ydHMuZXZhbHVhdGVFeHByZXNzaW9uID0gZXhwb3J0cy5FeHByVG9rZW4gPSB2b2lkIDA7XHJcbi8qKlxyXG4gKiAjIFBhcnNpbmcgQXJpdGhtZXRpYyBFeHByZXNzaW9uc1xyXG4gKlxyXG4gKiBBIGNvbW1vbiB3YXkgdG8gZGVtb25zdHJhdGUgcGFyc2VyIGNvbnN0cnVjdGlvbiBpcyB0byB1c2UgYSBncmFtbWFyIHRoYXRcclxuICogcmVwcmVzZW50cyBhcml0aG1ldGljIGV4cHJlc3Npb25zLiBXZSBidWlsZCBhIHBhcnNlciBmb3Igc2ltcGxlIGV4cHJlc3Npb25zXHJcbiAqIHRoYXQgY29uc2lzdCBvZiBhZGRpdGlvbiwgc3VidHJhY3Rpb24sIG11bHRpcGxpY2F0aW9uLCBhbmQgZGl2aXNpb25cclxuICogb3BlcmF0aW9ucy5cclxuICovXHJcbmNvbnN0IHB6ID0gcmVxdWlyZShcIi4uL1wiKTtcclxuLyoqXHJcbiAqICMjIFRva2Vuc1xyXG4gKlxyXG4gKiBUb2tlbnMgaW5jbHVkZSBudW1iZXJzLCBwYXJlbnRoZXNpcywgb3BlcmF0b3JzLCBhbmQgd2hpdGVzcGFjZS5cclxuICovXHJcbnZhciBFeHByVG9rZW47XHJcbihmdW5jdGlvbiAoRXhwclRva2VuKSB7XHJcbiAgICBFeHByVG9rZW5bRXhwclRva2VuW1wiTnVtYmVyXCJdID0gMF0gPSBcIk51bWJlclwiO1xyXG4gICAgRXhwclRva2VuW0V4cHJUb2tlbltcIk9wZW5QYXJlblwiXSA9IDFdID0gXCJPcGVuUGFyZW5cIjtcclxuICAgIEV4cHJUb2tlbltFeHByVG9rZW5bXCJDbG9zZVBhcmVuXCJdID0gMl0gPSBcIkNsb3NlUGFyZW5cIjtcclxuICAgIEV4cHJUb2tlbltFeHByVG9rZW5bXCJQbHVzXCJdID0gM10gPSBcIlBsdXNcIjtcclxuICAgIEV4cHJUb2tlbltFeHByVG9rZW5bXCJNaW51c1wiXSA9IDRdID0gXCJNaW51c1wiO1xyXG4gICAgRXhwclRva2VuW0V4cHJUb2tlbltcIk11bHRpcGx5XCJdID0gNV0gPSBcIk11bHRpcGx5XCI7XHJcbiAgICBFeHByVG9rZW5bRXhwclRva2VuW1wiRGl2aWRlXCJdID0gNl0gPSBcIkRpdmlkZVwiO1xyXG4gICAgRXhwclRva2VuW0V4cHJUb2tlbltcIldoaXRlc3BhY2VcIl0gPSA3XSA9IFwiV2hpdGVzcGFjZVwiO1xyXG4gICAgRXhwclRva2VuW0V4cHJUb2tlbltcIkVPRlwiXSA9IDhdID0gXCJFT0ZcIjtcclxufSkoRXhwclRva2VuID0gZXhwb3J0cy5FeHByVG9rZW4gfHwgKGV4cG9ydHMuRXhwclRva2VuID0ge30pKTtcclxuLyoqXHJcbiAqIFRvIHR1cm4gb24gZGVidWdnaW5nLCBzZXQgb24gdGhlIGZvbGxvd2luZyBmbGFnLiBJdCBvdXRwdXRzIGV2YWx1YXRlZFxyXG4gKiBwYXJzaW5nIHJ1bGVzLCB3aGljaCBoZWxwcyB1bmRlcnN0YW5kaW5nIHRoZSBvcGVyYXRpb24uXHJcbiAqL1xyXG5wei5wYXJzZXJEZWJ1Zy5kZWJ1Z2dpbmcgPSBmYWxzZTtcclxuLyoqXHJcbiAqICMjIExleGVyXHJcbiAqXHJcbiAqIFRoZSBsZXhlciBjYW4gYmUgY29uc3RydWN0ZWQgd2l0aCBhIHNpbmdsZSBleHByZXNzaW9uLiBXZSBzcGVjaWZ5IHRoZVxyXG4gKiByZWd1bGFyIGV4cHJlc3Npb24gdGhhdCBhY2NlcHRzIGEgZ2l2ZW4gdG9rZW4sIGFuZCBhc3NvY2lhdGUgaXQgdG8gdGhlXHJcbiAqIG1lbWJlciBvZiB0aGUgZW51bWVyYXRpb24gZGVmaW5lZCBhYm92ZS5cclxuICovXHJcbmNvbnN0IGxleGVyID0gbmV3IHB6LkxleGVyKFsvLT9cXGQrKD86XFwuXFxkKyk/KD86W2VFXVsrLV0/XFxkKyk/LywgRXhwclRva2VuLk51bWJlcl0sIFsvXFwoLywgRXhwclRva2VuLk9wZW5QYXJlbl0sIFsvXFwpLywgRXhwclRva2VuLkNsb3NlUGFyZW5dLCBbL1xcKy8sIEV4cHJUb2tlbi5QbHVzXSwgWy8tLywgRXhwclRva2VuLk1pbnVzXSwgWy9cXCovLCBFeHByVG9rZW4uTXVsdGlwbHldLCBbL1xcLy8sIEV4cHJUb2tlbi5EaXZpZGVdLCBbL1tcXHRcXG5cXHIgXSsvLCBFeHByVG9rZW4uV2hpdGVzcGFjZV0pO1xyXG4vKipcclxuICogIyMgUGFyc2VyXHJcbiAqXHJcbiAqIFBhcnNlciBpcyBidWlsdCBmcm9tIHR3byBraW5kcyBvZiBwYXJzaW5nIHJ1bGVzOiBvbmVzIHRoYXQgcmVjb2duaXplXHJcbiAqIF90ZXJtaW5hbHNfIGFuZCBvdGhlcnMgdGhhdCByZWNvZ25pemUgX25vbnRlcm1pbmFsc18uXHJcbiAqXHJcbiAqICMjIyBUZXJtaW5hbHNcclxuICpcclxuICogVGVybWluYWwgcGFyc2VycyByZWNvZ25pemUgdGhlIHRva2VucyByZXR1cm5lZCBieSB0aGUgbGV4ZXIuIFRoZXkgYXJlXHJcbiAqIHN0cmFpZ2h0Zm9yd2FyZCB0byBkZWZpbmUuXHJcbiAqXHJcbiAqIEZpcnN0IHdlIGRlZmluZSBhIHBhcnNlciB0aGF0IHNraXBzIGFueSB3aGl0ZXNwYWNlIGJldHdlZW4gdGhlIHRva2Vucy5cclxuICovXHJcbmNvbnN0IG9wdHdzID0gcHoudGVybWluYWwoRXhwclRva2VuLldoaXRlc3BhY2UsIFwiPHdoaXRlc3BhY2U+XCIpLm9wdGlvbmFsUmVmKCk7XHJcbi8qKlxyXG4gKiBOZXh0IHdlIGRlZmluZSBwYXJzZXIgZm9yIG51bWJlcnMuIFdlIGNvbnZlcnQgdGhlIHJlY29nbml6ZWQgdGV4dCB0byBgbnVtYmVyYFxyXG4gKiB0eXBlLiBXZSBza2lwIHRoZSB0cmFpbGluZyB3aGl0ZXNwYWNlIHdpdGggdGhlIGBmb2xsb3dlZEJ5YCBjb21iaW5hdG9yLlxyXG4gKi9cclxuY29uc3QgbnVtYmVyID0gcHoudGVybWluYWwoRXhwclRva2VuLk51bWJlciwgXCI8bnVtYmVyPlwiKVxyXG4gICAgLm1hcCh0ID0+IE51bWJlcih0LnRleHQpKS5mb2xsb3dlZEJ5KG9wdHdzKTtcclxuLyoqXHJcbiAqIFBhcmVudGhlc2lzIGFuZCBvcGVyYXRvcnMgYXJlIGFsbCByZWNvZ25pemVkIHRoZSBzYW1lIHdheS4gQWdhaW4sIHdlIHNraXAgdGhlXHJcbiAqIHRyYWlsaW5nIHdoaXRlc3BhY2UgdG8ga2VlcCB0aGUgb3RoZXIgcnVsZXMgc2ltcGxlLlxyXG4gKi9cclxuY29uc3Qgb3BlblBhcmVuID0gcHoudGVybWluYWwoRXhwclRva2VuLk9wZW5QYXJlbiwgXCIoXCIpLmZvbGxvd2VkQnkob3B0d3MpO1xyXG5jb25zdCBjbG9zZVBhcmVuID0gcHoudGVybWluYWwoRXhwclRva2VuLkNsb3NlUGFyZW4sIFwiKVwiKS5mb2xsb3dlZEJ5KG9wdHdzKTtcclxuY29uc3QgcGx1cyA9IHB6LnRlcm1pbmFsKEV4cHJUb2tlbi5QbHVzLCBcIitcIikuZm9sbG93ZWRCeShvcHR3cyk7XHJcbmNvbnN0IG1pbnVzID0gcHoudGVybWluYWwoRXhwclRva2VuLk1pbnVzLCBcIi1cIikuZm9sbG93ZWRCeShvcHR3cyk7XHJcbmNvbnN0IG11bHRpcGx5ID0gcHoudGVybWluYWwoRXhwclRva2VuLk11bHRpcGx5LCBcIipcIikuZm9sbG93ZWRCeShvcHR3cyk7XHJcbmNvbnN0IGRpdmlkZSA9IHB6LnRlcm1pbmFsKEV4cHJUb2tlbi5EaXZpZGUsIFwiL1wiKS5mb2xsb3dlZEJ5KG9wdHdzKTtcclxuLyoqXHJcbiAqIGBlb2ZgIGlzIGEgc3BlY2lhbCB0ZXJtaW5hbCBwYXJzZXIgdGhhdCByZWNvZ25pemVzIGVuZCBvZiBpbnB1dC5cclxuICovXHJcbmNvbnN0IGVvZiA9IHB6LnRlcm1pbmFsKEV4cHJUb2tlbi5FT0YsIFwiPGVuZCBvZiBpbnB1dD5cIik7XHJcbi8qKlxyXG4gKiAjIyMgTm9udGVybWluYWxzXHJcbiAqXHJcbiAqIFRoZSBhYnN0cmFjdCBub2RlcyBpbiBhIHN5bnRheCB0cmVlIGFyZSBjYWxsZWQgbm9udGVybWluYWxzLiBXZSBkZWZpbmUgYVxyXG4gKiBwYXJzZXIgZm9yIGVhY2ggbm9udGVybWluYWwuIFNpbmNlIGV4cHJlc3Npb25zIGNhbiB0aGVvcmV0aWNhbGx5IGJlXHJcbiAqIGluZmluaXRlbHkgbG9uZywgdGhlIHBhcnNlcnMgYXJlIHJlY3Vyc2l2ZS5cclxuICpcclxuICogRmlyc3Qgd2UgZGVmaW5lIHBhcnNlcnMgZm9yIG9wZXJhdG9ycy4gV2UgdXRpbGl6ZSB0aGUgYG9wZXJhdG9yc2AgY29tYmluYXRvclxyXG4gKiB3aGljaCBpcyBkZXNpZ25lZCBqdXN0IGZvciB0aGlzIHB1cnBvc2UuIFRoZXNlIHBhcnNlcnMgY2FsY3VsYXRlIHRoZSByZXN1bHRcclxuICogb2YgdGhlIG9wZXJhdGlvbiwgYW5kIHJldHVybiBpdCB0byB0aGUgcGFyZW50IHBhcnNlci5cclxuICovXHJcbmNvbnN0IGFkZG9wID0gcHoub3BlcmF0b3JzKFtwbHVzLCAoYSwgYikgPT4gYSArIGJdLCBbbWludXMsIChhLCBiKSA9PiBhIC0gYl0pO1xyXG5jb25zdCBtdWxvcCA9IHB6Lm9wZXJhdG9ycyhbbXVsdGlwbHksIChhLCBiKSA9PiBhICogYl0sIFtkaXZpZGUsIChhLCBiKSA9PiBhIC8gYl0pO1xyXG4vKipcclxuICogVGVybXMgYXJlIHRoZSByZXN1bHRzIG9mIG11bHRpcGxpY2F0aW9uIG9yIGRpdmlzaW9uIG9wZXJhdG9ycy4gV2UgZGVmaW5lXHJcbiAqIHRoZSB0ZXJtIHBhcnNlciBhcyBhIHJlZmVyZW5jZSBhcyB3ZSBuZWVkIHRoZSBmYWN0b3IgcGFyc2VyIGluIGl0c1xyXG4gKiBkZWZpbml0aW9uLlxyXG4gKi9cclxuY29uc3QgdGVybSA9IG5ldyBwei5SZWYoKTtcclxuLyoqXHJcbiAqIEV4cHJlc3Npb25zIGNvbnNpc3Qgb2YgdGVybXMgdGhhdCBhcmUgYWRkZWQgb3Igc3VidHJhY3RlZCB0b2dldGhlci4gTm90ZSBob3dcclxuICogdGhlIGdyYW1tYXIgaW1wbGljaXRseSBkZWZpbmVzIHRoZSBwcmVjZWRlbmNlIG9yZGVyIGFzIHRlcm1zIGFyZSByZWNvZ25pemVkXHJcbiAqIGJlZm9yZSB0aGUgZXhwcmVzc2lvbnMuXHJcbiAqL1xyXG5jb25zdCBleHByID0gcHouZm9yd2FyZFJlZih0ZXJtKS5jaGFpbk9uZU9yTW9yZShhZGRvcCk7XHJcbi8qKlxyXG4gKiBUbyBjaGFuZ2UgdGhlIHByZWNlZGVuY2Ugb3JkZXIgd2UgdXNlcyBwYXJlbnRoZXNpcyBhcyB1c3VhbC4gV2hlbiBhblxyXG4gKiBleHByZXNzaW9uIGlzIHN1cnJvdW5kZWQgYnkgcGFyZW50ZWhlc2lzIGl0IGJlY29tZXMgYSBmYWN0b3Igd2hpY2ggaXNcclxuICogcmVjb2duaXplZCBiZWZvcmUgdGVybXMuIFNvLCBhIGZhY3RvciBpcyBlaXRoZXIgYSBudW1iZXIgb3IgYW4gZXhwcmVzc2lvblxyXG4gKiBpbiBwYXJlbnRoZXNpcy5cclxuICovXHJcbmNvbnN0IGZhY3RvciA9IGV4cHIuYnJhY2tldGVkQnkob3BlblBhcmVuLCBjbG9zZVBhcmVuKS5vcihudW1iZXIpO1xyXG4vKipcclxuICogTm93IHdlIGNhbiBkZWZpbmUgdGhlIHRlcm0gYXMgc2VxdWVuY2Ugb2YgZmFjdG9ycyBzZXBhcmF0ZWQgYnkgbXVsdGlwbGljYXRpb25cclxuICogb3IgZGl2aXNpb24gb3BlcmF0b3JzLlxyXG4gKi9cclxudGVybS50YXJnZXQgPSBmYWN0b3IuY2hhaW5PbmVPck1vcmUobXVsb3ApO1xyXG4vKipcclxuICogTGFzdCB3ZSBkZWZpbmUgdGhlIHJvb3QgcGFyc2VyLCB3aGljaCBqdXN0IHNraXBzIGFueSBsZWFkaW5nIHdoaXRlc3BhY2VcclxuICogYmVmb3JlIGNhbGxpbmcgdGhlIGV4cHJlc3Npb24gcGFyc2VyLiBXaGl0ZXNwYWNlIGluLWJldHdlZW4gdG9rZW5zIGlzXHJcbiAqIHNraXBwZWQgYnkgdGVybWluYWwgcGFyc2Vycy5cclxuICovXHJcbmNvbnN0IHJvb3RFeHByID0gb3B0d3Muc2VxKGV4cHIpLmZvbGxvd2VkQnkoZW9mKTtcclxuLyoqXHJcbiAqICMjIEV4cG9ydGVkIFBhcnNpbmcgRnVuY3Rpb25cclxuICpcclxuICogTm93IHdlIGNhbiBkZWZpbmUgdGhlIGhlbHBlciBmdW5jdGlvbnMgd2hpY2ggcGFyc2VzIGFuIGV4cHJlc3Npb24gc3RyaW5nIGFuZFxyXG4gKiBjYWxjdWxhdGVzIGl0cyB2YWx1ZS4gVG8gZ2V0IGEgYFBhcnNlcklucHV0PEV4cHJUb2tlbj5gIGludGVyZmFjZSByZXF1aXJlZFxyXG4gKiBieSB0aGUgcGFyc2VyLCB3ZSBjYWxsIHRoZSBgbGV4ZXJJbnB1dGAgZnVuY3Rpb24sIHdoaWNoIHRha2VzIHRoZSBsZXhlciBhbmRcclxuICogaW5wdXQgZXhwcmVzc2lvbiBhcyBhcmd1bWVudHMuXHJcbiAqXHJcbiAqIEFmdGVyIHRoYXQgd2UgY2FuIGNhbGwgdGhlIGBwYXJzZWAgZnVuY3Rpb24gd2hpY2ggdGFrZXMgdGhlIHJvb3QgZ3JhbW1hclxyXG4gKiBydWxlIGFuZCB0aGUgaW5wdXQgYXMgcGFyYW1ldGVycy5cclxuICAqL1xyXG5mdW5jdGlvbiBldmFsdWF0ZUV4cHJlc3Npb24oZXhwcmVzc2lvbikge1xyXG4gICAgcmV0dXJuIHB6LnBhcnNlKHJvb3RFeHByLCBwei5sZXhlcklucHV0KGV4cHJlc3Npb24sIGxleGVyLCBuZXcgcHouVG9rZW4oRXhwclRva2VuLkVPRiwgXCI8ZW5kIG9mIGlucHV0PlwiKSkpO1xyXG59XHJcbmV4cG9ydHMuZXZhbHVhdGVFeHByZXNzaW9uID0gZXZhbHVhdGVFeHByZXNzaW9uO1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxudmFyIF9fYXdhaXRlciA9ICh0aGlzICYmIHRoaXMuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XHJcbiAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cclxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cclxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cclxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxyXG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcclxuICAgIH0pO1xyXG59O1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbi8qKlxyXG4gKiAtLS1cclxuICoge1xyXG4gKiAgXCJ2aXN1YWxpemVyc1wiOiBbXHJcbiAqICAgICAge1xyXG4gKiAgICAgICAgICBcInBhdGhcIjogXCIuL3NyYy92aXN1YWxpemVycy9ydW4tZXhwci10ZXN0cy50c1wiLFxyXG4gKiAgICAgICAgICBcImluY2x1ZGVTdHlsZXNcIjogdHJ1ZVxyXG4gKiAgICAgIH1cclxuICogIF1cclxuICogfVxyXG4gKiAtLS1cclxuICpcclxuICogIyBUZXN0aW5nIHRoZSBFeHByZXNzaW9uIFBhcnNlclxyXG4gKlxyXG4gKiBUaGUgZWFzaWVzdCB3YXkgdG8gdGVzdCBvdXIgcGFyc2VyIGlzIHRvIG1hbnVhbGx5IGlucHV0IHNvbWUgZXhwcmVzc2lvbnNcclxuICogKHByZXNzIGBFbnRlcmAgdG8gY2FsY3VsYXRlKS5cclxuICpcclxuICogPDx2OmNhbGN1bGF0b3I+PlxyXG4gKlxyXG4gKiBCdXQgdGhpcyBiZWNvbWVzIHRlZGlvdXMgc29vbiwgc28gbGV0J3Mgd3JpdGUgc29tZSBhdXRvbWF0aWMgdGVzdHMgYXMgd2VsbC5cclxuICogV2UgdXNlIHRoZSBgdGVzdGAgZnVuY3Rpb24gZnJvbSB0aGUgKipsaXRzLWV4dHJhcyoqIHBhY2thZ2UuXHJcbiAqL1xyXG5jb25zdCB0ZXN0ZXJfMSA9IHJlcXVpcmUoXCJsaXRzLWV4dHJhcy9saWIvdGVzdGVyXCIpO1xyXG5jb25zdCBlcCA9IHJlcXVpcmUoXCIuL2V4cHJwYXJzZXJcIik7XHJcbmNvbnN0IGZjID0gcmVxdWlyZShcImZhc3QtY2hlY2tcIik7XHJcbmNvbnN0IHB6ID0gcmVxdWlyZShcIi4uXCIpO1xyXG4vKipcclxuICogRmlyc3QsIGxldCdzIHRlc3Qgc29tZSB2YWxpZCBleHByZXNzaW9ucy4gU2luY2Ugb3VyIGV4cHJlc3Npb25zIGFyZSB2YWxpZFxyXG4gKiBpbiBKYXZhU2NyaXB0IHRvbywgd2UgY2FuIHVzZSB0aGUgYGV2YWxgIGZ1bmN0aW9uIGFzIHRoZSBiYXNlbGluZS5cclxuICovXHJcbnRlc3Rlcl8xLnRlc3QoXCJUZXN0IHBhcnNpbmcgb2YgcHJlZGVmaW5lZCBleHByZXNzaW9uc1wiLCAodCkgPT4gX19hd2FpdGVyKHZvaWQgMCwgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICBsZXQgdGVzdHNldCA9IFtcclxuICAgICAgICBcIjEgKyAtMVwiLFxyXG4gICAgICAgIFwiMiArIDMgKiAzXCIsXHJcbiAgICAgICAgXCIxIC0gMSAvIDJcIixcclxuICAgICAgICBcIigxIC0gMSkgLyAyXCIsXHJcbiAgICAgICAgXCIoMSkgKyAoKCgyKSkgKyAzKVwiXHJcbiAgICBdO1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0ZXN0c2V0Lmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgbGV0IGV4cHIgPSB0ZXN0c2V0W2ldO1xyXG4gICAgICAgIGxldCByZXMgPSBldmFsKGV4cHIpO1xyXG4gICAgICAgIGxldCBjYWxjcmVzID0gZXAuZXZhbHVhdGVFeHByZXNzaW9uKGV4cHIpO1xyXG4gICAgICAgIHQuZXF1YWwoY2FsY3JlcywgcmVzLCBgZXhwcmVzc2lvbiAnJHtleHByfScgc2hvdWxkIGV2YWx1YXRlIHRvICR7cmVzfWApO1xyXG4gICAgfVxyXG59KSk7XHJcbi8qKlxyXG4gKiBUaGVuIHdlIHRlc3QgZXhwcmVzc2lvbiB0aGF0IHNob3VsZCBub3QgYmUgdmFsaWQuXHJcbiAqL1xyXG50ZXN0ZXJfMS50ZXN0KFwiVGVzdCBmYWlsaW5nIGV4cHJlc3Npb25zXCIsICh0KSA9PiBfX2F3YWl0ZXIodm9pZCAwLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgIGxldCB0ZXN0c2V0ID0gW1xyXG4gICAgICAgIFwiMSArIFwiLFxyXG4gICAgICAgIFwiMiArKyAzICogM1wiLFxyXG4gICAgICAgIFwiLSAxIC0gMVwiLFxyXG4gICAgICAgIFwiXCIsXHJcbiAgICAgICAgXCJhICsgMVwiXHJcbiAgICBdO1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0ZXN0c2V0Lmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgbGV0IGV4cHIgPSB0ZXN0c2V0W2ldO1xyXG4gICAgICAgIHQudGhyb3dzKCgpID0+IGVwLmV2YWx1YXRlRXhwcmVzc2lvbihleHByKSwgcHouUGFyc2VFcnJvciwgYGV4cHJlc3Npb24gJyR7ZXhwcn0nIHNob3VsZCBub3QgcGFyc2VgKTtcclxuICAgIH1cclxufSkpO1xyXG4vKipcclxuICogIyMgUHJvcGVydHkgQmFzZWQgVGVzdHNcclxuICpcclxuICogQ29taW5nIHVwIHdpdGggdGVzdCBjYXNlcyBhbHNvIGJlY29tZXMgdGVkaW91cyBxdWlja2x5LCBzbyBsZXQncyBhdXRvbWF0ZVxyXG4gKiB0ZXN0IGNhc2UgZ2VuZXJhdGlvbiB3aXRoIFtmYXN0LWNoZWNrXVtdIGxpYnJhcnkuIFRoaXMga2luZCBvZiBhcHByb2FjaCBpc1xyXG4gKiBjYWxsZWQgX3Byb3BlcnR5IGJhc2VkIHRlc3RpbmdfLCBhbmQgaXQgaGVscHMgdXMgZ2V0IGNvbmZpZGVuY2UgdGhhdCBvdXJcclxuICogaW1wbGVtZW50YXRpb24gd29ya3MgY29ycmVjdGx5LlxyXG4gKlxyXG4gKiBbZmFzdC1jaGVja106IGh0dHBzOi8vZ2l0aHViLmNvbS9kdWJ6enovZmFzdC1jaGVja1xyXG4gKlxyXG4gKiAjIyMgUnVubmluZyBUZXN0c1xyXG4gKlxyXG4gKiBXaGVuIHdlIHJ1biB0aGUgdGVzdHMsIHdlIGNhbiBzZWUgaG93IGNyYXp5IGlucHV0IGRhdGEgd2UgZ2V0IHdoZW4gd2VcclxuICogZ2VuZXJhdGUgaXQgd2l0aCBmYXN0LWNoZWNrLiBJdCBwcm9kdWNlcyB0ZXN0IGNhc2VzIHdlIHdvdWxkIHZlcnkgdW5saWtlbHlcclxuICogY29tZSB1cCB3aXRoIG91cnNlbHZlcy4gWW91IGNhbiBwcmVzcyBgRjVgIHRvIHJlcnVuIHRoZSB0ZXN0cy5cclxuICpcclxuICogPDx2OnJ1bi1leHByLXRlc3RzIEV4cHJlc3Npb24gdGVzdHM+PlxyXG4gKlxyXG4gKiAjIyMgR2VuZXJhdGluZyBBcmJpdHJhcnkgRXhwcmVzc2lvbnNcclxuICpcclxuICogU28sIGhvdyBkbyB3ZSBnZW5lcmF0ZSB0aGVzZSBhcmJpdHJhcnkgaW5wdXQgZXhwcmVzc2lvbnM/IFdlIGNvbnN0cnVjdCB0aGVtXHJcbiAqIGJvdHRvbS11cCBzdGFydGluZyBmcm9tIG51bWJlcnMgYW5kIG9wZXJhdG9ycy4gTnVtYmVycyB3ZSBzZWxlY3QgcmFuZG9tbHlcclxuICogZnJvbSByYW5nZSBbLTEwMDAsIDEwMDBdLlxyXG4gKi9cclxuY29uc3QgYXJiTnVtID0gZmMuaW50ZWdlcigtMTAwMCwgMTAwMCkubWFwKG4gPT4gbi50b1N0cmluZygpKTtcclxuLyoqXHJcbiAqIE9wZXJhdG9ycyBhcmUgcmFuZG9tbHkgc2VsZWN0ZWQgZnJvbSBhIHByZWRlZmluZWQgbGlzdC5cclxuICovXHJcbmNvbnN0IGFyYk9wZXIgPSBmYy5jb25zdGFudEZyb20oXCIrXCIsIFwiLVwiLCBcIipcIiwgXCIvXCIpO1xyXG4vKipcclxuICogU2luY2UgZXhwcmVzc2lvbiBpcyBhIHRyZWUtbGlrZSBzdHJ1Y3R1cmUsIHdlIG5lZWQgdG8gdXNlIGEgY29tYmluYXRvciB0aGF0XHJcbiAqIGNvbnN0cnVjdHMgZGF0YSByZWN1cnNpdmVseS4gSW4gZmFzdC1jaGVjayB0aGlzIGNvbWJpbmF0b3IgaXMgY2FsbGVkXHJcbiAqIGBsZXRyZWNgLiBJdCB0YWtlcyBhIHJlY3Vyc2l2ZSBmdW5jdGlvbiB0aGF0IHJldHVybnMgYW4gb2JqZWN0IHdoaWNoXHJcbiAqIHByb3BlcnRpZXMgZ2VuZXJhdGUgYXJiaXRyYXJ5IGVsZW1lbnQgb2YgZGlmZmVyZW50IHR5cGVzLiBXZSBjYW4gZGVzY2VuZCB0b1xyXG4gKiB0aGUgbmV4dCBsZXZlbCBpbiB0aGUgZXhwcmVzc2lvbiB0cmVlIGJ5IGNhbGxpbmcgdGhlIGB0aWVgIGZ1bmN0aW9uIHdlIGdldFxyXG4gKiBhcyBhbiBhcmd1bWVudC5cclxuICovXHJcbmNvbnN0IGFyYkV4cHIgPSBmYy5sZXRyZWModGllID0+ICh7XHJcbiAgICBudW06IGFyYk51bSxcclxuICAgIG9wZXI6IGZjLnR1cGxlKHRpZSgnZXhwcicpLCBhcmJPcGVyLCB0aWUoJ2V4cHInKSkubWFwKHQgPT4gYCR7dFswXX0gJHt0WzFdfSAke3RbMl19YCksXHJcbiAgICBwYXI6IHRpZSgnZXhwcicpLm1hcChlID0+IFwiKFwiICsgZSArIFwiKVwiKSxcclxuICAgIGV4cHI6IGZjLm9uZW9mKHRpZSgnbnVtJyksIHRpZSgnb3BlcicpLCB0aWUoJ3BhcicpKVxyXG59KSk7XHJcbi8qKlxyXG4gKiAjIyMgRGVmaW5pbmcgUHJvcGVydGllc1xyXG4gKlxyXG4gKiBBcm1lZCB3aXRoIG91ciBhcmJpdHJhcnkgY29tYmluYXRvcnMsIHdlIGNhbiBkZWZpbmUgdGhlIHByb3BlcnRpZXMgdGhhdCBvdXJcclxuICogZGF0YSBzaG91bGQgaGF2ZSAoaGVuY2UgdGhlIG5hbWUgXCJwcm9wZXJ0eSBiYXNlZCB0ZXN0aW5nXCIpLiBXZSBkbyB0aGF0IHNpbXBseVxyXG4gKiBieSBjaGVja2luZyB0aGF0IEpTIGBldmFsYCBhbmQgb3VyIGBldmFsdWF0ZUV4cHJlc3Npb25gIGZ1bmN0aW9ucyByZXR1cm4gdGhlXHJcbiAqIHNhbWUgcmVzdWx0IGZvciBhbGwgaW5wdXQgZGF0YS5cclxuICovXHJcbnRlc3Rlcl8xLnRlc3QoXCJUZXN0IGFyYml0cmFyeSBleHByZXNzaW9uc1wiLCAodCkgPT4gX19hd2FpdGVyKHZvaWQgMCwgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICByZXR1cm4gZmMuYXNzZXJ0KGZjLnByb3BlcnR5KGFyYkV4cHIuZXhwciwgZSA9PiB7XHJcbiAgICAgICAgbGV0IHJlczEgPSBldmFsKGUpO1xyXG4gICAgICAgIGxldCByZXMyID0gZXAuZXZhbHVhdGVFeHByZXNzaW9uKGUpO1xyXG4gICAgICAgIHQuZXF1YWwocmVzMSwgcmVzMiwgYGV4cHJlc3Npb24gJyR7ZX0nIHNob3VsZCBldmFsdWF0ZSB0byAke3JlczF9YCk7XHJcbiAgICB9KSk7XHJcbn0pKTtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuZXhwb3J0cy5lc2NhcGVXaGl0ZXNwYWNlID0gZXhwb3J0cy5pbml0T2JqZWN0ID0gdm9pZCAwO1xyXG4vKipcclxuICogIyBVdGlsaXR5IEZ1bmN0aW9uc1xyXG4gKlxyXG4gKiBUaGlzIG1vZHVsZSBjb250YWlucyBnZW5lcmFsIGZ1bmN0aW9ucyB1c2VkIGVsc2V3aGVyZSBpbiB0aGUgbGlicmFyeS5cclxuICpcclxuICogVGhlIGZpcnN0IGZ1bmN0aW9uIGluaXRpYWxpemVzIGFuIG9iamVjdCBmcm9tIGFuIGFycmF5IG9mIGBbc3RyaW5nLCBhbnldYFxyXG4gKiBwYWlycy4gSXQgaXMgdXNlZCB0byBwb3B1bGF0ZSBhbiBvYmplY3QgZHluYW1pY2FsbHkuXHJcbiAqL1xyXG5mdW5jdGlvbiBpbml0T2JqZWN0KG1lbWJlcnMpIHtcclxuICAgIGxldCByZXMgPSB7fTtcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbWVtYmVycy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGxldCBbbSwgdl0gPSBtZW1iZXJzW2ldO1xyXG4gICAgICAgIHJlc1ttXSA9IHY7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVzO1xyXG59XHJcbmV4cG9ydHMuaW5pdE9iamVjdCA9IGluaXRPYmplY3Q7XHJcbi8qKlxyXG4gKiBUaGUgYGVzY2FwZVdoaXRlc3BhY2VgIGZ1bmN0aW9uIGhlbHBzIHByaW50aW5nIHN0cmluZ3MgY29udGFpbmluZyB3aGl0ZXNwYWNlXHJcbiAqIGNoYXJhY3RlcnMuIEl0IHJlcGxhY2VzIHRoZW0gd2l0aCB0aGVpciBlc2NhcGUgY29kZXMuXHJcbiAqL1xyXG5mdW5jdGlvbiBlc2NhcGVXaGl0ZXNwYWNlKHRleHQpIHtcclxuICAgIHJldHVybiB0ZXh0LnJlcGxhY2UoXCJcXG5cIiwgXCJcXFxcblwiKS5yZXBsYWNlKFwiXFxyXCIsIFwiXFxcXHJcIikucmVwbGFjZShcIlxcdFwiLCBcIlxcXFx0XCIpO1xyXG59XHJcbmV4cG9ydHMuZXNjYXBlV2hpdGVzcGFjZSA9IGVzY2FwZVdoaXRlc3BhY2U7XHJcbiIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxuY29uc3Qgc3RhcnRUZXN0TWVzc2FnZSA9ICh0ZXN0LCBvZmZzZXQpID0+ICh7XG4gICAgdHlwZTogXCJURVNUX1NUQVJUXCIgLyogVEVTVF9TVEFSVCAqLyxcbiAgICBkYXRhOiB0ZXN0LFxuICAgIG9mZnNldFxufSk7XG5jb25zdCBhc3NlcnRpb25NZXNzYWdlID0gKGFzc2VydGlvbiwgb2Zmc2V0KSA9PiAoe1xuICAgIHR5cGU6IFwiQVNTRVJUSU9OXCIgLyogQVNTRVJUSU9OICovLFxuICAgIGRhdGE6IGFzc2VydGlvbixcbiAgICBvZmZzZXRcbn0pO1xuY29uc3QgZW5kVGVzdE1lc3NhZ2UgPSAodGVzdCwgb2Zmc2V0KSA9PiAoe1xuICAgIHR5cGU6IFwiVEVTVF9FTkRcIiAvKiBURVNUX0VORCAqLyxcbiAgICBkYXRhOiB0ZXN0LFxuICAgIG9mZnNldFxufSk7XG5jb25zdCBiYWlsb3V0ID0gKGVycm9yLCBvZmZzZXQpID0+ICh7XG4gICAgdHlwZTogXCJCQUlMX09VVFwiIC8qIEJBSUxfT1VUICovLFxuICAgIGRhdGE6IGVycm9yLFxuICAgIG9mZnNldFxufSk7XG5cbmNvbnN0IGRlbGVnYXRlVG9Db3VudGVyID0gKGNvdW50ZXIpID0+ICh0YXJnZXQpID0+IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwge1xuICAgIHNraXBDb3VudDoge1xuICAgICAgICBnZXQoKSB7XG4gICAgICAgICAgICByZXR1cm4gY291bnRlci5za2lwQ291bnQ7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIGZhaWx1cmVDb3VudDoge1xuICAgICAgICBnZXQoKSB7XG4gICAgICAgICAgICByZXR1cm4gY291bnRlci5mYWlsdXJlQ291bnQ7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIHN1Y2Nlc3NDb3VudDoge1xuICAgICAgICBnZXQoKSB7XG4gICAgICAgICAgICByZXR1cm4gY291bnRlci5zdWNjZXNzQ291bnQ7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIGNvdW50OiB7XG4gICAgICAgIGdldCgpIHtcbiAgICAgICAgICAgIHJldHVybiBjb3VudGVyLmNvdW50O1xuICAgICAgICB9XG4gICAgfVxufSk7XG5jb25zdCBjb3VudGVyID0gKCkgPT4ge1xuICAgIGxldCBzdWNjZXNzID0gMDtcbiAgICBsZXQgZmFpbHVyZSA9IDA7XG4gICAgbGV0IHNraXAgPSAwO1xuICAgIHJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh7XG4gICAgICAgIHVwZGF0ZShhc3NlcnRpb24pIHtcbiAgICAgICAgICAgIGNvbnN0IHsgcGFzcywgc2tpcDogaXNTa2lwcGVkIH0gPSBhc3NlcnRpb247XG4gICAgICAgICAgICBpZiAoaXNTa2lwcGVkKSB7XG4gICAgICAgICAgICAgICAgc2tpcCsrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoIWlzQXNzZXJ0aW9uUmVzdWx0KGFzc2VydGlvbikpIHtcbiAgICAgICAgICAgICAgICBza2lwICs9IGFzc2VydGlvbi5za2lwQ291bnQ7XG4gICAgICAgICAgICAgICAgc3VjY2VzcyArPSBhc3NlcnRpb24uc3VjY2Vzc0NvdW50O1xuICAgICAgICAgICAgICAgIGZhaWx1cmUgKz0gYXNzZXJ0aW9uLmZhaWx1cmVDb3VudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHBhc3MpIHtcbiAgICAgICAgICAgICAgICBzdWNjZXNzKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBmYWlsdXJlKys7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIHN1Y2Nlc3NDb3VudDoge1xuICAgICAgICAgICAgZ2V0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBzdWNjZXNzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBmYWlsdXJlQ291bnQ6IHtcbiAgICAgICAgICAgIGdldCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFpbHVyZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgc2tpcENvdW50OiB7XG4gICAgICAgICAgICBnZXQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNraXA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGNvdW50OiB7XG4gICAgICAgICAgICBnZXQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNraXAgKyBzdWNjZXNzICsgZmFpbHVyZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xufTtcblxuY29uc3QgZGVmYXVsdFRlc3RPcHRpb25zID0gT2JqZWN0LmZyZWV6ZSh7XG4gICAgb2Zmc2V0OiAwLFxuICAgIHNraXA6IGZhbHNlLFxuICAgIHJ1bk9ubHk6IGZhbHNlXG59KTtcbmNvbnN0IG5vb3AgPSAoKSA9PiB7XG59O1xuY29uc3QgVGVzdGVyUHJvdG90eXBlID0ge1xuICAgIFtTeW1ib2wuYXN5bmNJdGVyYXRvcl06IGFzeW5jIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgIGF3YWl0IHRoaXMucm91dGluZTtcbiAgICAgICAgZm9yIChjb25zdCBhc3NlcnRpb24gb2YgdGhpcy5hc3NlcnRpb25zKSB7XG4gICAgICAgICAgICBpZiAoYXNzZXJ0aW9uW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSkge1xuICAgICAgICAgICAgICAgIC8vIFN1YiB0ZXN0XG4gICAgICAgICAgICAgICAgeWllbGQgc3RhcnRUZXN0TWVzc2FnZSh7IGRlc2NyaXB0aW9uOiBhc3NlcnRpb24uZGVzY3JpcHRpb24gfSwgdGhpcy5vZmZzZXQpO1xuICAgICAgICAgICAgICAgIHlpZWxkKiBhc3NlcnRpb247XG4gICAgICAgICAgICAgICAgaWYgKGFzc2VydGlvbi5lcnJvciAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBCdWJibGUgdXAgdGhlIGVycm9yIGFuZCByZXR1cm5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lcnJvciA9IGFzc2VydGlvbi5lcnJvcjtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wYXNzID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB5aWVsZCBhc3NlcnRpb25NZXNzYWdlKGFzc2VydGlvbiwgdGhpcy5vZmZzZXQpO1xuICAgICAgICAgICAgdGhpcy5wYXNzID0gdGhpcy5wYXNzICYmIGFzc2VydGlvbi5wYXNzO1xuICAgICAgICAgICAgdGhpcy5jb3VudGVyLnVwZGF0ZShhc3NlcnRpb24pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmVycm9yICE9PSBudWxsID9cbiAgICAgICAgICAgIHlpZWxkIGJhaWxvdXQodGhpcy5lcnJvciwgdGhpcy5vZmZzZXQpIDpcbiAgICAgICAgICAgIHlpZWxkIGVuZFRlc3RNZXNzYWdlKHRoaXMsIHRoaXMub2Zmc2V0KTtcbiAgICB9XG59O1xuY29uc3QgdGVzdGVyTGlrZVByb3ZpZGVyID0gKEJhc2VQcm90byA9IFRlc3RlclByb3RvdHlwZSkgPT4gKGFzc2VydGlvbnMsIHJvdXRpbmUsIG9mZnNldCkgPT4ge1xuICAgIGNvbnN0IHRlc3RDb3VudGVyID0gY291bnRlcigpO1xuICAgIGNvbnN0IHdpdGhUZXN0Q291bnRlciA9IGRlbGVnYXRlVG9Db3VudGVyKHRlc3RDb3VudGVyKTtcbiAgICBsZXQgcGFzcyA9IHRydWU7XG4gICAgcmV0dXJuIHdpdGhUZXN0Q291bnRlcihPYmplY3QuY3JlYXRlKEJhc2VQcm90bywge1xuICAgICAgICByb3V0aW5lOiB7XG4gICAgICAgICAgICB2YWx1ZTogcm91dGluZVxuICAgICAgICB9LFxuICAgICAgICBhc3NlcnRpb25zOiB7XG4gICAgICAgICAgICB2YWx1ZTogYXNzZXJ0aW9uc1xuICAgICAgICB9LFxuICAgICAgICBvZmZzZXQ6IHtcbiAgICAgICAgICAgIHZhbHVlOiBvZmZzZXRcbiAgICAgICAgfSxcbiAgICAgICAgY291bnRlcjoge1xuICAgICAgICAgICAgdmFsdWU6IHRlc3RDb3VudGVyXG4gICAgICAgIH0sXG4gICAgICAgIGxlbmd0aDoge1xuICAgICAgICAgICAgZ2V0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBhc3NlcnRpb25zLmxlbmd0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgcGFzczoge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGdldCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFzcztcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzZXQodmFsKSB7XG4gICAgICAgICAgICAgICAgcGFzcyA9IHZhbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pKTtcbn07XG5jb25zdCB0ZXN0ZXJGYWN0b3J5ID0gdGVzdGVyTGlrZVByb3ZpZGVyKCk7XG5cbmNvbnN0IHRlc3RlciA9IChkZXNjcmlwdGlvbiwgc3BlYywgeyBvZmZzZXQgPSAwLCBza2lwID0gZmFsc2UsIHJ1bk9ubHkgPSBmYWxzZSB9ID0gZGVmYXVsdFRlc3RPcHRpb25zKSA9PiB7XG4gICAgbGV0IGV4ZWN1dGlvblRpbWUgPSAwO1xuICAgIGxldCBlcnJvciA9IG51bGw7XG4gICAgbGV0IGRvbmUgPSBmYWxzZTtcbiAgICBjb25zdCBhc3NlcnRpb25zID0gW107XG4gICAgY29uc3QgY29sbGVjdCA9IGl0ZW0gPT4ge1xuICAgICAgICBpZiAoZG9uZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGB0ZXN0IFwiJHtkZXNjcmlwdGlvbn1cIiBcbnRyaWVkIHRvIGNvbGxlY3QgYW4gYXNzZXJ0aW9uIGFmdGVyIGl0IGhhcyBydW4gdG8gaXRzIGNvbXBsZXRpb24uIFxuWW91IG1pZ2h0IGhhdmUgZm9yZ290dGVuIHRvIHdhaXQgZm9yIGFuIGFzeW5jaHJvbm91cyB0YXNrIHRvIGNvbXBsZXRlXG4tLS0tLS1cbiR7c3BlYy50b1N0cmluZygpfVxuYCk7XG4gICAgICAgIH1cbiAgICAgICAgYXNzZXJ0aW9ucy5wdXNoKGl0ZW0pO1xuICAgIH07XG4gICAgY29uc3Qgc3BlY0Z1bmN0aW9uID0gc2tpcCA9PT0gdHJ1ZSA/IG5vb3AgOiBmdW5jdGlvbiB6b3JhX3NwZWNfZm4oKSB7XG4gICAgICAgIHJldHVybiBzcGVjKGFzc2VydChjb2xsZWN0LCBvZmZzZXQsIHJ1bk9ubHkpKTtcbiAgICB9O1xuICAgIGNvbnN0IHRlc3RSb3V0aW5lID0gKGFzeW5jIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHN0YXJ0ID0gRGF0ZS5ub3coKTtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHNwZWNGdW5jdGlvbigpO1xuICAgICAgICAgICAgZXhlY3V0aW9uVGltZSA9IERhdGUubm93KCkgLSBzdGFydDtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGVycm9yID0gZTtcbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgIGRvbmUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfSkoKTtcbiAgICByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGVzdGVyRmFjdG9yeShhc3NlcnRpb25zLCB0ZXN0Um91dGluZSwgb2Zmc2V0KSwge1xuICAgICAgICBlcnJvcjoge1xuICAgICAgICAgICAgZ2V0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBlcnJvcjtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzZXQodmFsKSB7XG4gICAgICAgICAgICAgICAgZXJyb3IgPSB2YWw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGV4ZWN1dGlvblRpbWU6IHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBnZXQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGV4ZWN1dGlvblRpbWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHNraXA6IHtcbiAgICAgICAgICAgIHZhbHVlOiBza2lwXG4gICAgICAgIH0sXG4gICAgICAgIGRlc2NyaXB0aW9uOiB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IGRlc2NyaXB0aW9uXG4gICAgICAgIH1cbiAgICB9KTtcbn07XG5cbi8vIGRvIG5vdCBlZGl0IC5qcyBmaWxlcyBkaXJlY3RseSAtIGVkaXQgc3JjL2luZGV4LmpzdFxuXG5cblxudmFyIGZhc3REZWVwRXF1YWwgPSBmdW5jdGlvbiBlcXVhbChhLCBiKSB7XG4gIGlmIChhID09PSBiKSByZXR1cm4gdHJ1ZTtcblxuICBpZiAoYSAmJiBiICYmIHR5cGVvZiBhID09ICdvYmplY3QnICYmIHR5cGVvZiBiID09ICdvYmplY3QnKSB7XG4gICAgaWYgKGEuY29uc3RydWN0b3IgIT09IGIuY29uc3RydWN0b3IpIHJldHVybiBmYWxzZTtcblxuICAgIHZhciBsZW5ndGgsIGksIGtleXM7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoYSkpIHtcbiAgICAgIGxlbmd0aCA9IGEubGVuZ3RoO1xuICAgICAgaWYgKGxlbmd0aCAhPSBiLmxlbmd0aCkgcmV0dXJuIGZhbHNlO1xuICAgICAgZm9yIChpID0gbGVuZ3RoOyBpLS0gIT09IDA7KVxuICAgICAgICBpZiAoIWVxdWFsKGFbaV0sIGJbaV0pKSByZXR1cm4gZmFsc2U7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cblxuXG4gICAgaWYgKGEuY29uc3RydWN0b3IgPT09IFJlZ0V4cCkgcmV0dXJuIGEuc291cmNlID09PSBiLnNvdXJjZSAmJiBhLmZsYWdzID09PSBiLmZsYWdzO1xuICAgIGlmIChhLnZhbHVlT2YgIT09IE9iamVjdC5wcm90b3R5cGUudmFsdWVPZikgcmV0dXJuIGEudmFsdWVPZigpID09PSBiLnZhbHVlT2YoKTtcbiAgICBpZiAoYS50b1N0cmluZyAhPT0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZykgcmV0dXJuIGEudG9TdHJpbmcoKSA9PT0gYi50b1N0cmluZygpO1xuXG4gICAga2V5cyA9IE9iamVjdC5rZXlzKGEpO1xuICAgIGxlbmd0aCA9IGtleXMubGVuZ3RoO1xuICAgIGlmIChsZW5ndGggIT09IE9iamVjdC5rZXlzKGIpLmxlbmd0aCkgcmV0dXJuIGZhbHNlO1xuXG4gICAgZm9yIChpID0gbGVuZ3RoOyBpLS0gIT09IDA7KVxuICAgICAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYiwga2V5c1tpXSkpIHJldHVybiBmYWxzZTtcblxuICAgIGZvciAoaSA9IGxlbmd0aDsgaS0tICE9PSAwOykge1xuICAgICAgdmFyIGtleSA9IGtleXNbaV07XG5cbiAgICAgIGlmICghZXF1YWwoYVtrZXldLCBiW2tleV0pKSByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvLyB0cnVlIGlmIGJvdGggTmFOLCBmYWxzZSBvdGhlcndpc2VcbiAgcmV0dXJuIGEhPT1hICYmIGIhPT1iO1xufTtcblxuY29uc3QgaXNBc3NlcnRpb25SZXN1bHQgPSAocmVzdWx0KSA9PiB7XG4gICAgcmV0dXJuICdvcGVyYXRvcicgaW4gcmVzdWx0O1xufTtcbmNvbnN0IHNwZWNGblJlZ2V4cCA9IC96b3JhX3NwZWNfZm4vO1xuY29uc3Qgem9yYUludGVybmFsID0gL3pvcmFcXC9kaXN0XFwvYnVuZGxlLztcbmNvbnN0IGZpbHRlclN0YWNrTGluZSA9IGwgPT4gKGwgJiYgIXpvcmFJbnRlcm5hbC50ZXN0KGwpICYmICFsLnN0YXJ0c1dpdGgoJ0Vycm9yJykgfHwgc3BlY0ZuUmVnZXhwLnRlc3QobCkpO1xuY29uc3QgZ2V0QXNzZXJ0aW9uTG9jYXRpb24gPSAoKSA9PiB7XG4gICAgY29uc3QgZXJyID0gbmV3IEVycm9yKCk7XG4gICAgY29uc3Qgc3RhY2sgPSAoZXJyLnN0YWNrIHx8ICcnKVxuICAgICAgICAuc3BsaXQoJ1xcbicpXG4gICAgICAgIC5tYXAobCA9PiBsLnRyaW0oKSlcbiAgICAgICAgLmZpbHRlcihmaWx0ZXJTdGFja0xpbmUpO1xuICAgIGNvbnN0IHVzZXJMYW5kSW5kZXggPSBzdGFjay5maW5kSW5kZXgobCA9PiBzcGVjRm5SZWdleHAudGVzdChsKSk7XG4gICAgY29uc3Qgc3RhY2tsaW5lID0gdXNlckxhbmRJbmRleCA+PSAxID8gc3RhY2tbdXNlckxhbmRJbmRleCAtIDFdIDogKHN0YWNrWzBdIHx8ICdOL0EnKTtcbiAgICByZXR1cm4gc3RhY2tsaW5lXG4gICAgICAgIC5yZXBsYWNlKC9eYXR8XkAvLCAnJyk7XG59O1xuY29uc3QgYXNzZXJ0TWV0aG9kSG9vayA9IChmbikgPT4gZnVuY3Rpb24gKC4uLmFyZ3MpIHtcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgcmV0dXJuIHRoaXMuY29sbGVjdChmbiguLi5hcmdzKSk7XG59O1xuY29uc3QgYWxpYXNNZXRob2RIb29rID0gKG1ldGhvZE5hbWUpID0+IGZ1bmN0aW9uICguLi5hcmdzKSB7XG4gICAgcmV0dXJuIHRoaXNbbWV0aG9kTmFtZV0oLi4uYXJncyk7XG59O1xuY29uc3QgdW5iaW5kQXNzZXJ0ID0gKHRhcmdldCkgPT4gT2JqZWN0LmZyb21FbnRyaWVzKFsuLi5PYmplY3Qua2V5cyhBc3NlcnRQcm90b3R5cGUpLCAnY29sbGVjdCddXG4gICAgLm1hcCgobWV0aG9kTmFtZSkgPT4gW21ldGhvZE5hbWUsICguLi5hcmdzKSA9PiB0YXJnZXRbbWV0aG9kTmFtZV0oLi4uYXJncyldKSk7XG5jb25zdCBBc3NlcnRQcm90b3R5cGUgPSB7XG4gICAgZXF1YWw6IGFzc2VydE1ldGhvZEhvb2soKGFjdHVhbCwgZXhwZWN0ZWQsIGRlc2NyaXB0aW9uID0gJ3Nob3VsZCBiZSBlcXVpdmFsZW50JykgPT4gKHtcbiAgICAgICAgcGFzczogZmFzdERlZXBFcXVhbChhY3R1YWwsIGV4cGVjdGVkKSxcbiAgICAgICAgYWN0dWFsLFxuICAgICAgICBleHBlY3RlZCxcbiAgICAgICAgZGVzY3JpcHRpb24sXG4gICAgICAgIG9wZXJhdG9yOiBcImVxdWFsXCIgLyogRVFVQUwgKi9cbiAgICB9KSksXG4gICAgZXF1YWxzOiBhbGlhc01ldGhvZEhvb2soJ2VxdWFsJyksXG4gICAgZXE6IGFsaWFzTWV0aG9kSG9vaygnZXF1YWwnKSxcbiAgICBkZWVwRXF1YWw6IGFsaWFzTWV0aG9kSG9vaygnZXF1YWwnKSxcbiAgICBzYW1lOiBhbGlhc01ldGhvZEhvb2soJ2VxdWFsJyksXG4gICAgbm90RXF1YWw6IGFzc2VydE1ldGhvZEhvb2soKGFjdHVhbCwgZXhwZWN0ZWQsIGRlc2NyaXB0aW9uID0gJ3Nob3VsZCBub3QgYmUgZXF1aXZhbGVudCcpID0+ICh7XG4gICAgICAgIHBhc3M6ICFmYXN0RGVlcEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQpLFxuICAgICAgICBhY3R1YWwsXG4gICAgICAgIGV4cGVjdGVkLFxuICAgICAgICBkZXNjcmlwdGlvbixcbiAgICAgICAgb3BlcmF0b3I6IFwibm90RXF1YWxcIiAvKiBOT1RfRVFVQUwgKi9cbiAgICB9KSksXG4gICAgbm90RXF1YWxzOiBhbGlhc01ldGhvZEhvb2soJ25vdEVxdWFsJyksXG4gICAgbm90RXE6IGFsaWFzTWV0aG9kSG9vaygnbm90RXF1YWwnKSxcbiAgICBub3REZWVwRXF1YWw6IGFsaWFzTWV0aG9kSG9vaygnbm90RXF1YWwnKSxcbiAgICBpczogYXNzZXJ0TWV0aG9kSG9vaygoYWN0dWFsLCBleHBlY3RlZCwgZGVzY3JpcHRpb24gPSAnc2hvdWxkIGJlIHRoZSBzYW1lJykgPT4gKHtcbiAgICAgICAgcGFzczogT2JqZWN0LmlzKGFjdHVhbCwgZXhwZWN0ZWQpLFxuICAgICAgICBhY3R1YWwsXG4gICAgICAgIGV4cGVjdGVkLFxuICAgICAgICBkZXNjcmlwdGlvbixcbiAgICAgICAgb3BlcmF0b3I6IFwiaXNcIiAvKiBJUyAqL1xuICAgIH0pKSxcbiAgICBpc05vdDogYXNzZXJ0TWV0aG9kSG9vaygoYWN0dWFsLCBleHBlY3RlZCwgZGVzY3JpcHRpb24gPSAnc2hvdWxkIG5vdCBiZSB0aGUgc2FtZScpID0+ICh7XG4gICAgICAgIHBhc3M6ICFPYmplY3QuaXMoYWN0dWFsLCBleHBlY3RlZCksXG4gICAgICAgIGFjdHVhbCxcbiAgICAgICAgZXhwZWN0ZWQsXG4gICAgICAgIGRlc2NyaXB0aW9uLFxuICAgICAgICBvcGVyYXRvcjogXCJpc05vdFwiIC8qIElTX05PVCAqL1xuICAgIH0pKSxcbiAgICBub3RTYW1lOiBhbGlhc01ldGhvZEhvb2soJ2lzTm90JyksXG4gICAgb2s6IGFzc2VydE1ldGhvZEhvb2soKGFjdHVhbCwgZGVzY3JpcHRpb24gPSAnc2hvdWxkIGJlIHRydXRoeScpID0+ICh7XG4gICAgICAgIHBhc3M6IEJvb2xlYW4oYWN0dWFsKSxcbiAgICAgICAgYWN0dWFsLFxuICAgICAgICBleHBlY3RlZDogJ3RydXRoeSB2YWx1ZScsXG4gICAgICAgIGRlc2NyaXB0aW9uLFxuICAgICAgICBvcGVyYXRvcjogXCJva1wiIC8qIE9LICovXG4gICAgfSkpLFxuICAgIHRydXRoeTogYWxpYXNNZXRob2RIb29rKCdvaycpLFxuICAgIG5vdE9rOiBhc3NlcnRNZXRob2RIb29rKChhY3R1YWwsIGRlc2NyaXB0aW9uID0gJ3Nob3VsZCBiZSBmYWxzeScpID0+ICh7XG4gICAgICAgIHBhc3M6ICFCb29sZWFuKGFjdHVhbCksXG4gICAgICAgIGFjdHVhbCxcbiAgICAgICAgZXhwZWN0ZWQ6ICdmYWxzeSB2YWx1ZScsXG4gICAgICAgIGRlc2NyaXB0aW9uLFxuICAgICAgICBvcGVyYXRvcjogXCJub3RPa1wiIC8qIE5PVF9PSyAqL1xuICAgIH0pKSxcbiAgICBmYWxzeTogYWxpYXNNZXRob2RIb29rKCdub3RPaycpLFxuICAgIGZhaWw6IGFzc2VydE1ldGhvZEhvb2soKGRlc2NyaXB0aW9uID0gJ2ZhaWwgY2FsbGVkJykgPT4gKHtcbiAgICAgICAgcGFzczogZmFsc2UsXG4gICAgICAgIGFjdHVhbDogJ2ZhaWwgY2FsbGVkJyxcbiAgICAgICAgZXhwZWN0ZWQ6ICdmYWlsIG5vdCBjYWxsZWQnLFxuICAgICAgICBkZXNjcmlwdGlvbixcbiAgICAgICAgb3BlcmF0b3I6IFwiZmFpbFwiIC8qIEZBSUwgKi9cbiAgICB9KSksXG4gICAgdGhyb3dzOiBhc3NlcnRNZXRob2RIb29rKChmdW5jLCBleHBlY3RlZCwgZGVzY3JpcHRpb24pID0+IHtcbiAgICAgICAgbGV0IGNhdWdodDtcbiAgICAgICAgbGV0IHBhc3M7XG4gICAgICAgIGxldCBhY3R1YWw7XG4gICAgICAgIGlmICh0eXBlb2YgZXhwZWN0ZWQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBbZXhwZWN0ZWQsIGRlc2NyaXB0aW9uXSA9IFtkZXNjcmlwdGlvbiwgZXhwZWN0ZWRdO1xuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBmdW5jKCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgY2F1Z2h0ID0geyBlcnJvcjogZXJyIH07XG4gICAgICAgIH1cbiAgICAgICAgcGFzcyA9IGNhdWdodCAhPT0gdW5kZWZpbmVkO1xuICAgICAgICBhY3R1YWwgPSBjYXVnaHQgJiYgY2F1Z2h0LmVycm9yO1xuICAgICAgICBpZiAoZXhwZWN0ZWQgaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICAgICAgICAgIHBhc3MgPSBleHBlY3RlZC50ZXN0KGFjdHVhbCkgfHwgZXhwZWN0ZWQudGVzdChhY3R1YWwgJiYgYWN0dWFsLm1lc3NhZ2UpO1xuICAgICAgICAgICAgYWN0dWFsID0gYWN0dWFsICYmIGFjdHVhbC5tZXNzYWdlIHx8IGFjdHVhbDtcbiAgICAgICAgICAgIGV4cGVjdGVkID0gU3RyaW5nKGV4cGVjdGVkKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgZXhwZWN0ZWQgPT09ICdmdW5jdGlvbicgJiYgY2F1Z2h0KSB7XG4gICAgICAgICAgICBwYXNzID0gYWN0dWFsIGluc3RhbmNlb2YgZXhwZWN0ZWQ7XG4gICAgICAgICAgICBhY3R1YWwgPSBhY3R1YWwuY29uc3RydWN0b3I7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHBhc3MsXG4gICAgICAgICAgICBhY3R1YWwsXG4gICAgICAgICAgICBleHBlY3RlZCxcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBkZXNjcmlwdGlvbiB8fCAnc2hvdWxkIHRocm93JyxcbiAgICAgICAgICAgIG9wZXJhdG9yOiBcInRocm93c1wiIC8qIFRIUk9XUyAqL1xuICAgICAgICB9O1xuICAgIH0pLFxuICAgIGRvZXNOb3RUaHJvdzogYXNzZXJ0TWV0aG9kSG9vaygoZnVuYywgZXhwZWN0ZWQsIGRlc2NyaXB0aW9uKSA9PiB7XG4gICAgICAgIGxldCBjYXVnaHQ7XG4gICAgICAgIGlmICh0eXBlb2YgZXhwZWN0ZWQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBbZXhwZWN0ZWQsIGRlc2NyaXB0aW9uXSA9IFtkZXNjcmlwdGlvbiwgZXhwZWN0ZWRdO1xuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBmdW5jKCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgY2F1Z2h0ID0geyBlcnJvcjogZXJyIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHBhc3M6IGNhdWdodCA9PT0gdW5kZWZpbmVkLFxuICAgICAgICAgICAgZXhwZWN0ZWQ6ICdubyB0aHJvd24gZXJyb3InLFxuICAgICAgICAgICAgYWN0dWFsOiBjYXVnaHQgJiYgY2F1Z2h0LmVycm9yLFxuICAgICAgICAgICAgb3BlcmF0b3I6IFwiZG9lc05vdFRocm93XCIgLyogRE9FU19OT1RfVEhST1cgKi8sXG4gICAgICAgICAgICBkZXNjcmlwdGlvbjogZGVzY3JpcHRpb24gfHwgJ3Nob3VsZCBub3QgdGhyb3cnXG4gICAgICAgIH07XG4gICAgfSlcbn07XG5jb25zdCBhc3NlcnQgPSAoY29sbGVjdCwgb2Zmc2V0LCBydW5Pbmx5ID0gZmFsc2UpID0+IHtcbiAgICBjb25zdCBhY3R1YWxDb2xsZWN0ID0gaXRlbSA9PiB7XG4gICAgICAgIGlmICghaXRlbS5wYXNzKSB7XG4gICAgICAgICAgICBpdGVtLmF0ID0gZ2V0QXNzZXJ0aW9uTG9jYXRpb24oKTtcbiAgICAgICAgfVxuICAgICAgICBjb2xsZWN0KGl0ZW0pO1xuICAgICAgICByZXR1cm4gaXRlbTtcbiAgICB9O1xuICAgIGNvbnN0IHRlc3QgPSAoZGVzY3JpcHRpb24sIHNwZWMsIG9wdHMpID0+IHtcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIGRlZmF1bHRUZXN0T3B0aW9ucywgb3B0cywgeyBvZmZzZXQ6IG9mZnNldCArIDEsIHJ1bk9ubHkgfSk7XG4gICAgICAgIGNvbnN0IHN1YlRlc3QgPSB0ZXN0ZXIoZGVzY3JpcHRpb24sIHNwZWMsIG9wdGlvbnMpO1xuICAgICAgICBjb2xsZWN0KHN1YlRlc3QpO1xuICAgICAgICByZXR1cm4gc3ViVGVzdC5yb3V0aW5lO1xuICAgIH07XG4gICAgY29uc3Qgc2tpcCA9IChkZXNjcmlwdGlvbiwgc3BlYywgb3B0cykgPT4ge1xuICAgICAgICByZXR1cm4gdGVzdChkZXNjcmlwdGlvbiwgc3BlYywgT2JqZWN0LmFzc2lnbih7fSwgb3B0cywgeyBza2lwOiB0cnVlIH0pKTtcbiAgICB9O1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICByZXR1cm4ge1xuICAgICAgICAuLi51bmJpbmRBc3NlcnQoT2JqZWN0LmNyZWF0ZShBc3NlcnRQcm90b3R5cGUsIHsgY29sbGVjdDogeyB2YWx1ZTogYWN0dWFsQ29sbGVjdCB9IH0pKSxcbiAgICAgICAgdGVzdChkZXNjcmlwdGlvbiwgc3BlYywgb3B0cyA9IHt9KSB7XG4gICAgICAgICAgICBpZiAocnVuT25seSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBza2lwKGRlc2NyaXB0aW9uLCBzcGVjLCBvcHRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0ZXN0KGRlc2NyaXB0aW9uLCBzcGVjLCBvcHRzKTtcbiAgICAgICAgfSxcbiAgICAgICAgc2tpcChkZXNjcmlwdGlvbiwgc3BlYyA9IG5vb3AsIG9wdHMgPSB7fSkge1xuICAgICAgICAgICAgcmV0dXJuIHNraXAoZGVzY3JpcHRpb24sIHNwZWMsIG9wdHMpO1xuICAgICAgICB9LFxuICAgICAgICBvbmx5KGRlc2NyaXB0aW9uLCBzcGVjLCBvcHRzID0ge30pIHtcbiAgICAgICAgICAgIGNvbnN0IHNwZWNGbiA9IHJ1bk9ubHkgPT09IGZhbHNlID8gXyA9PiB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDYW4gbm90IHVzZSBcIm9ubHlcIiBtZXRob2Qgd2hlbiBub3QgaW4gcnVuIG9ubHkgbW9kZWApO1xuICAgICAgICAgICAgfSA6IHNwZWM7XG4gICAgICAgICAgICByZXR1cm4gdGVzdChkZXNjcmlwdGlvbiwgc3BlY0ZuLCBvcHRzKTtcbiAgICAgICAgfVxuICAgIH07XG59O1xuXG5jb25zdCBtYXAgPSAoZm4pID0+IGFzeW5jIGZ1bmN0aW9uKiAoc3RyZWFtKSB7XG4gICAgZm9yIGF3YWl0IChjb25zdCBtIG9mIHN0cmVhbSkge1xuICAgICAgICB5aWVsZCBmbihtKTtcbiAgICB9XG59O1xuLy8gISBpdCBtdXRhdGVzIHRoZSB1bmRlcmx5aW5nIHN0cnVjdHVyZSB5ZXQgaXQgaXMgbW9yZSBlZmZpY2llbnQgcmVnYXJkaW5nIHBlcmZvcm1hbmNlc1xuY29uc3QgZmxhdHRlbiA9IG1hcCgobSkgPT4ge1xuICAgIG0ub2Zmc2V0ID0gMDtcbiAgICByZXR1cm4gbTtcbn0pO1xuY29uc3QgaXNBc3NlcnRpb25SZXN1bHQkMSA9IChyZXN1bHQpID0+IHtcbiAgICByZXR1cm4gJ29wZXJhdG9yJyBpbiByZXN1bHQ7XG59O1xuY29uc3Qgc3RyaW5naWZ5U3ltYm9sID0gKGtleSwgdmFsdWUpID0+IHtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3ltYm9sJykge1xuICAgICAgICByZXR1cm4gdmFsdWUudG9TdHJpbmcoKTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xufTtcblxuLy8gQHRzLWlnbm9yZVxuY29uc3QgZmxhdERpYWdub3N0aWMgPSAoeyBwYXNzLCBkZXNjcmlwdGlvbiwgLi4ucmVzdCB9KSA9PiByZXN0O1xuY29uc3QgVGFwID0ge1xuICAgIHByaW50KG1lc3NhZ2UsIG9mZnNldCA9IDApIHtcbiAgICAgICAgdGhpcy5sb2cobWVzc2FnZS5wYWRTdGFydChtZXNzYWdlLmxlbmd0aCArIChvZmZzZXQgKiA0KSkpOyAvLyA0IHdoaXRlIHNwYWNlIHVzZWQgYXMgaW5kZW50IChzZWUgdGFwLXBhcnNlcilcbiAgICB9LFxuICAgIHByaW50WUFNTChvYmosIG9mZnNldCA9IDApIHtcbiAgICAgICAgY29uc3QgWUFNTE9mZnNldCA9IG9mZnNldCArIDAuNTtcbiAgICAgICAgdGhpcy5wcmludCgnLS0tJywgWUFNTE9mZnNldCk7XG4gICAgICAgIGZvciAoY29uc3QgW3Byb3AsIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhvYmopKSB7XG4gICAgICAgICAgICB0aGlzLnByaW50KGAke3Byb3B9OiAke0pTT04uc3RyaW5naWZ5KHZhbHVlLCBzdHJpbmdpZnlTeW1ib2wpfWAsIFlBTUxPZmZzZXQgKyAwLjUpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucHJpbnQoJy4uLicsIFlBTUxPZmZzZXQpO1xuICAgIH0sXG4gICAgcHJpbnRDb21tZW50KGNvbW1lbnQsIG9mZnNldCA9IDApIHtcbiAgICAgICAgdGhpcy5wcmludChgIyAke2NvbW1lbnR9YCwgb2Zmc2V0KTtcbiAgICB9LFxuICAgIHByaW50QmFpbE91dChtZXNzYWdlKSB7XG4gICAgICAgIHRoaXMucHJpbnQoJ0JhaWwgb3V0ISBVbmhhbmRsZWQgZXJyb3IuJyk7XG4gICAgfSxcbiAgICBwcmludFRlc3RTdGFydChtZXNzYWdlKSB7XG4gICAgICAgIGNvbnN0IHsgZGF0YTogeyBkZXNjcmlwdGlvbiB9LCBvZmZzZXQgfSA9IG1lc3NhZ2U7XG4gICAgICAgIHRoaXMucHJpbnRDb21tZW50KGRlc2NyaXB0aW9uLCBvZmZzZXQpO1xuICAgIH0sXG4gICAgcHJpbnRUZXN0RW5kKG1lc3NhZ2UpIHtcbiAgICAgICAgLy8gZG8gbm90aGluZ1xuICAgIH0sXG4gICAgcHJpbnRBc3NlcnRpb24obWVzc2FnZSkge1xuICAgICAgICBjb25zdCB7IGRhdGEsIG9mZnNldCB9ID0gbWVzc2FnZTtcbiAgICAgICAgY29uc3QgeyBwYXNzLCBkZXNjcmlwdGlvbiB9ID0gZGF0YTtcbiAgICAgICAgY29uc3QgbGFiZWwgPSBwYXNzID09PSB0cnVlID8gJ29rJyA6ICdub3Qgb2snO1xuICAgICAgICBpZiAoaXNBc3NlcnRpb25SZXN1bHQkMShkYXRhKSkge1xuICAgICAgICAgICAgY29uc3QgaWQgPSB0aGlzLm5leHRJZCgpO1xuICAgICAgICAgICAgdGhpcy5wcmludChgJHtsYWJlbH0gJHtpZH0gLSAke2Rlc2NyaXB0aW9ufWAsIG9mZnNldCk7XG4gICAgICAgICAgICBpZiAocGFzcyA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnByaW50WUFNTChmbGF0RGlhZ25vc3RpYyhkYXRhKSwgb2Zmc2V0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChkYXRhLnNraXApIHtcbiAgICAgICAgICAgIGNvbnN0IGlkID0gdGhpcy5uZXh0SWQoKTtcbiAgICAgICAgICAgIHRoaXMucHJpbnQoYCR7cGFzcyA/ICdvaycgOiAnbm90IG9rJ30gJHtpZH0gLSAke2Rlc2NyaXB0aW9ufSAjIFNLSVBgLCBvZmZzZXQpO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBwcmludFN1bW1hcnkoZW5kTWVzc2FnZSkge1xuICAgICAgICB0aGlzLnByaW50KCcnLCAwKTtcbiAgICAgICAgdGhpcy5wcmludENvbW1lbnQoZW5kTWVzc2FnZS5kYXRhLnBhc3MgPyAnb2snIDogJ25vdCBvaycsIDApO1xuICAgICAgICB0aGlzLnByaW50Q29tbWVudChgc3VjY2VzczogJHtlbmRNZXNzYWdlLmRhdGEuc3VjY2Vzc0NvdW50fWAsIDApO1xuICAgICAgICB0aGlzLnByaW50Q29tbWVudChgc2tpcHBlZDogJHtlbmRNZXNzYWdlLmRhdGEuc2tpcENvdW50fWAsIDApO1xuICAgICAgICB0aGlzLnByaW50Q29tbWVudChgZmFpbHVyZTogJHtlbmRNZXNzYWdlLmRhdGEuZmFpbHVyZUNvdW50fWAsIDApO1xuICAgIH0sXG4gICAgYXN5bmMgcmVwb3J0KHN0cmVhbSkge1xuICAgICAgICBjb25zdCBzcmMgPSBmbGF0dGVuKHN0cmVhbSk7XG4gICAgICAgIGxldCBsYXN0TWVzc2FnZSA9IG51bGw7XG4gICAgICAgIHRoaXMucHJpbnQoJ1RBUCB2ZXJzaW9uIDEzJyk7XG4gICAgICAgIGZvciBhd2FpdCAoY29uc3QgbWVzc2FnZSBvZiBzcmMpIHtcbiAgICAgICAgICAgIGxhc3RNZXNzYWdlID0gbWVzc2FnZTtcbiAgICAgICAgICAgIHN3aXRjaCAobWVzc2FnZS50eXBlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSBcIlRFU1RfU1RBUlRcIiAvKiBURVNUX1NUQVJUICovOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLnByaW50VGVzdFN0YXJ0KG1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFwiQVNTRVJUSU9OXCIgLyogQVNTRVJUSU9OICovOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLnByaW50QXNzZXJ0aW9uKG1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFwiQkFJTF9PVVRcIiAvKiBCQUlMX09VVCAqLzpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wcmludEJhaWxPdXQobWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG1lc3NhZ2UuZGF0YTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLnByaW50KGAxLi4ke2xhc3RNZXNzYWdlLmRhdGEuY291bnR9YCwgMCk7XG4gICAgICAgIHRoaXMucHJpbnRTdW1tYXJ5KGxhc3RNZXNzYWdlKTtcbiAgICB9XG59O1xuY29uc3QgZmFjdG9yeSA9IChsb2cpID0+IHtcbiAgICBsZXQgaSA9IDA7XG4gICAgcmV0dXJuIE9iamVjdC5jcmVhdGUoVGFwLCB7XG4gICAgICAgIG5leHRJZDoge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICsraTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgbG9nOiB7IHZhbHVlOiBsb2cgfVxuICAgIH0pO1xufTtcblxuY29uc3QgaW5kZW50ZWREaWFnbm9zdGljID0gKHsgZXhwZWN0ZWQsIHBhc3MsIGRlc2NyaXB0aW9uLCBhY3R1YWwsIG9wZXJhdG9yLCBhdCA9ICdOL0EnLCAuLi5yZXN0IH0pID0+ICh7XG4gICAgd2FudGVkOiBleHBlY3RlZCxcbiAgICBmb3VuZDogYWN0dWFsLFxuICAgIGF0LFxuICAgIG9wZXJhdG9yLFxuICAgIC4uLnJlc3Rcbn0pO1xuY29uc3QgaWQgPSBmdW5jdGlvbiogKCkge1xuICAgIGxldCBpID0gMDtcbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICB5aWVsZCArK2k7XG4gICAgfVxufTtcbmNvbnN0IGlkR2VuID0gKCkgPT4ge1xuICAgIGxldCBzdGFjayA9IFtpZCgpXTtcbiAgICByZXR1cm4ge1xuICAgICAgICBbU3ltYm9sLml0ZXJhdG9yXSgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuICAgICAgICBuZXh0KCkge1xuICAgICAgICAgICAgcmV0dXJuIHN0YWNrWzBdLm5leHQoKTtcbiAgICAgICAgfSxcbiAgICAgICAgZm9yaygpIHtcbiAgICAgICAgICAgIHN0YWNrLnVuc2hpZnQoaWQoKSk7XG4gICAgICAgIH0sXG4gICAgICAgIG1lcmdlKCkge1xuICAgICAgICAgICAgc3RhY2suc2hpZnQoKTtcbiAgICAgICAgfVxuICAgIH07XG59O1xuY29uc3QgSW5kZW50ZWRUYXAgPSBPYmplY3QuYXNzaWduKHt9LCBUYXAsIHtcbiAgICBwcmludFRlc3RTdGFydChtZXNzYWdlKSB7XG4gICAgICAgIGNvbnN0IHsgZGF0YTogeyBkZXNjcmlwdGlvbiB9LCBvZmZzZXQgfSA9IG1lc3NhZ2U7XG4gICAgICAgIHRoaXMucHJpbnRDb21tZW50KGBTdWJ0ZXN0OiAke2Rlc2NyaXB0aW9ufWAsIG9mZnNldCk7XG4gICAgfSxcbiAgICBwcmludEFzc2VydGlvbihtZXNzYWdlKSB7XG4gICAgICAgIGNvbnN0IHsgZGF0YSwgb2Zmc2V0IH0gPSBtZXNzYWdlO1xuICAgICAgICBjb25zdCB7IHBhc3MsIGRlc2NyaXB0aW9uIH0gPSBkYXRhO1xuICAgICAgICBjb25zdCBsYWJlbCA9IHBhc3MgPT09IHRydWUgPyAnb2snIDogJ25vdCBvayc7XG4gICAgICAgIGNvbnN0IGlkID0gdGhpcy5uZXh0SWQoKTtcbiAgICAgICAgaWYgKGlzQXNzZXJ0aW9uUmVzdWx0JDEoZGF0YSkpIHtcbiAgICAgICAgICAgIHRoaXMucHJpbnQoYCR7bGFiZWx9ICR7aWR9IC0gJHtkZXNjcmlwdGlvbn1gLCBvZmZzZXQpO1xuICAgICAgICAgICAgaWYgKHBhc3MgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wcmludFlBTUwoaW5kZW50ZWREaWFnbm9zdGljKGRhdGEpLCBvZmZzZXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgY29tbWVudCA9IGRhdGEuc2tpcCA9PT0gdHJ1ZSA/ICdTS0lQJyA6IGAke2RhdGEuZXhlY3V0aW9uVGltZX1tc2A7XG4gICAgICAgICAgICB0aGlzLnByaW50KGAke3Bhc3MgPyAnb2snIDogJ25vdCBvayd9ICR7aWR9IC0gJHtkZXNjcmlwdGlvbn0gIyAke2NvbW1lbnR9YCwgbWVzc2FnZS5vZmZzZXQpO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBwcmludFRlc3RFbmQobWVzc2FnZSkge1xuICAgICAgICBjb25zdCBsZW5ndGggPSBtZXNzYWdlLmRhdGEubGVuZ3RoO1xuICAgICAgICBjb25zdCB7IG9mZnNldCB9ID0gbWVzc2FnZTtcbiAgICAgICAgdGhpcy5wcmludChgMS4uJHtsZW5ndGh9YCwgb2Zmc2V0KTtcbiAgICB9XG59KTtcbmNvbnN0IGZhY3RvcnkkMSA9IChsb2cpID0+IHtcbiAgICBjb25zdCBpZCA9IGlkR2VuKCk7XG4gICAgcmV0dXJuIE9iamVjdC5jcmVhdGUoSW5kZW50ZWRUYXAsIHtcbiAgICAgICAgbmV4dElkOiB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6ICgpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaWQubmV4dCgpLnZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICByZXBvcnQ6IHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogYXN5bmMgZnVuY3Rpb24gKHN0cmVhbSkge1xuICAgICAgICAgICAgICAgIHRoaXMucHJpbnQoJ1RBUCB2ZXJzaW9uIDEzJyk7XG4gICAgICAgICAgICAgICAgbGV0IGxhc3RNZXNzYWdlID0gbnVsbDtcbiAgICAgICAgICAgICAgICBmb3IgYXdhaXQgKGNvbnN0IG1lc3NhZ2Ugb2Ygc3RyZWFtKSB7XG4gICAgICAgICAgICAgICAgICAgIGxhc3RNZXNzYWdlID0gbWVzc2FnZTtcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChtZXNzYWdlLnR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJURVNUX1NUQVJUXCIgLyogVEVTVF9TVEFSVCAqLzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZC5mb3JrKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wcmludFRlc3RTdGFydChtZXNzYWdlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJBU1NFUlRJT05cIiAvKiBBU1NFUlRJT04gKi86XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wcmludEFzc2VydGlvbihtZXNzYWdlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJURVNUX0VORFwiIC8qIFRFU1RfRU5EICovOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkLm1lcmdlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wcmludFRlc3RFbmQobWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiQkFJTF9PVVRcIiAvKiBCQUlMX09VVCAqLzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnByaW50QmFpbE91dChtZXNzYWdlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBtZXNzYWdlLmRhdGE7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5wcmludFN1bW1hcnkobGFzdE1lc3NhZ2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBsb2c6IHsgdmFsdWU6IGxvZyB9XG4gICAgfSk7XG59O1xuXG5jb25zdCByZXBvcnQgPSAoZmFjdG9yeSkgPT4gKGxvZ2dlciA9IGNvbnNvbGUpID0+IHtcbiAgICBjb25zdCBsb2cgPSBsb2dnZXIubG9nLmJpbmQobG9nZ2VyKTtcbiAgICByZXR1cm4gYXN5bmMgKHN0cmVhbSkgPT4gZmFjdG9yeShsb2cpLnJlcG9ydChzdHJlYW0pO1xufTtcbmNvbnN0IHRhcFJlcG9ydGVyID0gcmVwb3J0KGZhY3RvcnkpO1xuY29uc3QgaW5kZW50ZWRUYXBSZXBvcnRlciA9IHJlcG9ydChmYWN0b3J5JDEpO1xuXG4vL0B0cy1pZ25vcmVcbmNvbnN0IG1vY2hhVGFwTGlrZSA9IGluZGVudGVkVGFwUmVwb3J0ZXIoKTtcbi8vQHRzLWlnbm9yZVxuY29uc3QgdGFwZVRhcExpa2UgPSB0YXBSZXBvcnRlcigpO1xuXG5jb25zdCBoYXJuZXNzRmFjdG9yeSA9ICh7IHJ1bk9ubHkgPSBmYWxzZSwgaW5kZW50ID0gZmFsc2UgfSA9IHtcbiAgICBydW5Pbmx5OiBmYWxzZSxcbiAgICBpbmRlbnQ6IGZhbHNlXG59KSA9PiB7XG4gICAgY29uc3QgdGVzdHMgPSBbXTtcbiAgICBjb25zdCByb290T2Zmc2V0ID0gMDtcbiAgICBjb25zdCBjb2xsZWN0ID0gaXRlbSA9PiB0ZXN0cy5wdXNoKGl0ZW0pO1xuICAgIGNvbnN0IGFwaSA9IGFzc2VydChjb2xsZWN0LCByb290T2Zmc2V0LCBydW5Pbmx5KTtcbiAgICBsZXQgZXJyb3IgPSBudWxsO1xuICAgIGNvbnN0IGZhY3RvcnkgPSB0ZXN0ZXJMaWtlUHJvdmlkZXIoT2JqZWN0LmFzc2lnbihhcGksIFRlc3RlclByb3RvdHlwZSwge1xuICAgICAgICByZXBvcnQ6IGFzeW5jIGZ1bmN0aW9uIChyZXBvcnRlcikge1xuICAgICAgICAgICAgY29uc3QgcmVwID0gcmVwb3J0ZXIgfHwgKGluZGVudCA/IG1vY2hhVGFwTGlrZSA6IHRhcGVUYXBMaWtlKTtcbiAgICAgICAgICAgIHJldHVybiByZXAodGhpcyk7XG4gICAgICAgIH1cbiAgICB9KSk7XG4gICAgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGZhY3RvcnkodGVzdHMsIFByb21pc2UucmVzb2x2ZSgpLCByb290T2Zmc2V0KSwge1xuICAgICAgICBlcnJvcjoge1xuICAgICAgICAgICAgZ2V0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBlcnJvcjtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzZXQodmFsKSB7XG4gICAgICAgICAgICAgICAgZXJyb3IgPSB2YWw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcbn07XG5cbmNvbnN0IGZpbmRDb25maWd1cmF0aW9uRmxhZyA9IChuYW1lKSA9PiB7XG4gICAgaWYgKHR5cGVvZiBwcm9jZXNzICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICByZXR1cm4gcHJvY2Vzcy5lbnZbbmFtZV0gPT09ICd0cnVlJztcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2YgRGVubyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICByZXR1cm4gRGVuby5lbnYuZ2V0KG5hbWUpID09PSAndHJ1ZSc7XG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICByZXR1cm4gQm9vbGVhbih3aW5kb3dbbmFtZV0pO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59O1xuY29uc3QgZGVmYXVsdFRlc3RIYXJuZXNzID0gaGFybmVzc0ZhY3Rvcnkoe1xuICAgIHJ1bk9ubHk6IGZpbmRDb25maWd1cmF0aW9uRmxhZygnUlVOX09OTFknKVxufSk7XG5sZXQgYXV0b1N0YXJ0ID0gdHJ1ZTtcbmxldCBpbmRlbnQgPSBmaW5kQ29uZmlndXJhdGlvbkZsYWcoJ0lOREVOVCcpO1xuY29uc3Qgcm9vdFRlc3QgPSBkZWZhdWx0VGVzdEhhcm5lc3MudGVzdC5iaW5kKGRlZmF1bHRUZXN0SGFybmVzcyk7XG5yb290VGVzdC5pbmRlbnQgPSAoKSA9PiB7XG4gICAgY29uc29sZS53YXJuKCdpbmRlbnQgZnVuY3Rpb24gaXMgZGVwcmVjYXRlZCwgdXNlIFwiSU5ERU5UXCIgY29uZmlndXJhdGlvbiBmbGFnIGluc3RlYWQnKTtcbiAgICBpbmRlbnQgPSB0cnVlO1xufTtcbmNvbnN0IHRlc3QgPSByb290VGVzdDtcbmNvbnN0IHNraXAgPSBkZWZhdWx0VGVzdEhhcm5lc3Muc2tpcC5iaW5kKGRlZmF1bHRUZXN0SGFybmVzcyk7XG5jb25zdCBvbmx5ID0gZGVmYXVsdFRlc3RIYXJuZXNzLm9ubHkuYmluZChkZWZhdWx0VGVzdEhhcm5lc3MpO1xucm9vdFRlc3Quc2tpcCA9IHNraXA7XG5jb25zdCBlcXVhbCA9IGRlZmF1bHRUZXN0SGFybmVzcy5lcXVhbC5iaW5kKGRlZmF1bHRUZXN0SGFybmVzcyk7XG5jb25zdCBlcXVhbHMgPSBlcXVhbDtcbmNvbnN0IGVxID0gZXF1YWw7XG5jb25zdCBkZWVwRXF1YWwgPSBlcXVhbDtcbmNvbnN0IG5vdEVxdWFsID0gZGVmYXVsdFRlc3RIYXJuZXNzLm5vdEVxdWFsLmJpbmQoZGVmYXVsdFRlc3RIYXJuZXNzKTtcbmNvbnN0IG5vdEVxdWFscyA9IG5vdEVxdWFsO1xuY29uc3Qgbm90RXEgPSBub3RFcXVhbDtcbmNvbnN0IG5vdERlZXBFcXVhbCA9IG5vdEVxdWFsO1xuY29uc3QgaXMgPSBkZWZhdWx0VGVzdEhhcm5lc3MuaXMuYmluZChkZWZhdWx0VGVzdEhhcm5lc3MpO1xuY29uc3Qgc2FtZSA9IGlzO1xuY29uc3QgaXNOb3QgPSBkZWZhdWx0VGVzdEhhcm5lc3MuaXNOb3QuYmluZChkZWZhdWx0VGVzdEhhcm5lc3MpO1xuY29uc3Qgbm90U2FtZSA9IGlzTm90O1xuY29uc3Qgb2sgPSBkZWZhdWx0VGVzdEhhcm5lc3Mub2suYmluZChkZWZhdWx0VGVzdEhhcm5lc3MpO1xuY29uc3QgdHJ1dGh5ID0gb2s7XG5jb25zdCBub3RPayA9IGRlZmF1bHRUZXN0SGFybmVzcy5ub3RPay5iaW5kKGRlZmF1bHRUZXN0SGFybmVzcyk7XG5jb25zdCBmYWxzeSA9IG5vdE9rO1xuY29uc3QgZmFpbCA9IGRlZmF1bHRUZXN0SGFybmVzcy5mYWlsLmJpbmQoZGVmYXVsdFRlc3RIYXJuZXNzKTtcbmNvbnN0IHRocm93cyA9IGRlZmF1bHRUZXN0SGFybmVzcy50aHJvd3MuYmluZChkZWZhdWx0VGVzdEhhcm5lc3MpO1xuY29uc3QgZG9lc05vdFRocm93ID0gZGVmYXVsdFRlc3RIYXJuZXNzLmRvZXNOb3RUaHJvdy5iaW5kKGRlZmF1bHRUZXN0SGFybmVzcyk7XG5jb25zdCBjcmVhdGVIYXJuZXNzID0gKG9wdHMgPSB7fSkgPT4ge1xuICAgIGF1dG9TdGFydCA9IGZhbHNlO1xuICAgIHJldHVybiBoYXJuZXNzRmFjdG9yeShvcHRzKTtcbn07XG5jb25zdCBzdGFydCA9ICgpID0+IHtcbiAgICBpZiAoYXV0b1N0YXJ0KSB7XG4gICAgICAgIGRlZmF1bHRUZXN0SGFybmVzcy5yZXBvcnQoaW5kZW50ID8gbW9jaGFUYXBMaWtlIDogdGFwZVRhcExpa2UpO1xuICAgIH1cbn07XG4vLyBvbiBuZXh0IHRpY2sgc3RhcnQgcmVwb3J0aW5nXG4vLyBAdHMtaWdub3JlXG5pZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBzZXRUaW1lb3V0KHN0YXJ0LCAwKTtcbn1cbmVsc2Uge1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignbG9hZCcsIHN0YXJ0KTtcbn1cblxuZXhwb3J0cy5Bc3NlcnRQcm90b3R5cGUgPSBBc3NlcnRQcm90b3R5cGU7XG5leHBvcnRzLmNyZWF0ZUhhcm5lc3MgPSBjcmVhdGVIYXJuZXNzO1xuZXhwb3J0cy5kZWVwRXF1YWwgPSBkZWVwRXF1YWw7XG5leHBvcnRzLmRvZXNOb3RUaHJvdyA9IGRvZXNOb3RUaHJvdztcbmV4cG9ydHMuZXEgPSBlcTtcbmV4cG9ydHMuZXF1YWwgPSBlcXVhbDtcbmV4cG9ydHMuZXF1YWxzID0gZXF1YWxzO1xuZXhwb3J0cy5mYWlsID0gZmFpbDtcbmV4cG9ydHMuZmFsc3kgPSBmYWxzeTtcbmV4cG9ydHMuaXMgPSBpcztcbmV4cG9ydHMuaXNOb3QgPSBpc05vdDtcbmV4cG9ydHMubW9jaGFUYXBMaWtlID0gbW9jaGFUYXBMaWtlO1xuZXhwb3J0cy5ub3REZWVwRXF1YWwgPSBub3REZWVwRXF1YWw7XG5leHBvcnRzLm5vdEVxID0gbm90RXE7XG5leHBvcnRzLm5vdEVxdWFsID0gbm90RXF1YWw7XG5leHBvcnRzLm5vdEVxdWFscyA9IG5vdEVxdWFscztcbmV4cG9ydHMubm90T2sgPSBub3RPaztcbmV4cG9ydHMubm90U2FtZSA9IG5vdFNhbWU7XG5leHBvcnRzLm9rID0gb2s7XG5leHBvcnRzLm9ubHkgPSBvbmx5O1xuZXhwb3J0cy5zYW1lID0gc2FtZTtcbmV4cG9ydHMuc2tpcCA9IHNraXA7XG5leHBvcnRzLnRhcGVUYXBMaWtlID0gdGFwZVRhcExpa2U7XG5leHBvcnRzLnRlc3QgPSB0ZXN0O1xuZXhwb3J0cy50aHJvd3MgPSB0aHJvd3M7XG5leHBvcnRzLnRydXRoeSA9IHRydXRoeTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5BcnJheUFyYml0cmFyeSA9IHZvaWQgMDtcbmNvbnN0IFN0cmVhbV8xID0gcmVxdWlyZShcIi4uLy4uL3N0cmVhbS9TdHJlYW1cIik7XG5jb25zdCBzeW1ib2xzXzEgPSByZXF1aXJlKFwiLi4vLi4vY2hlY2svc3ltYm9sc1wiKTtcbmNvbnN0IGludGVnZXJfMSA9IHJlcXVpcmUoXCIuLi9pbnRlZ2VyXCIpO1xuY29uc3QgTGF6eUl0ZXJhYmxlSXRlcmF0b3JfMSA9IHJlcXVpcmUoXCIuLi8uLi9zdHJlYW0vTGF6eUl0ZXJhYmxlSXRlcmF0b3JcIik7XG5jb25zdCBCdWlsZENvbXBhcmVGaWx0ZXJfMSA9IHJlcXVpcmUoXCIuL2hlbHBlcnMvQnVpbGRDb21wYXJlRmlsdGVyXCIpO1xuY29uc3QgTmV4dEFyYml0cmFyeV8xID0gcmVxdWlyZShcIi4uLy4uL2NoZWNrL2FyYml0cmFyeS9kZWZpbml0aW9uL05leHRBcmJpdHJhcnlcIik7XG5jb25zdCBDb252ZXJ0ZXJzXzEgPSByZXF1aXJlKFwiLi4vLi4vY2hlY2svYXJiaXRyYXJ5L2RlZmluaXRpb24vQ29udmVydGVyc1wiKTtcbmNvbnN0IE5leHRWYWx1ZV8xID0gcmVxdWlyZShcIi4uLy4uL2NoZWNrL2FyYml0cmFyeS9kZWZpbml0aW9uL05leHRWYWx1ZVwiKTtcbmNsYXNzIEFycmF5QXJiaXRyYXJ5IGV4dGVuZHMgTmV4dEFyYml0cmFyeV8xLk5leHRBcmJpdHJhcnkge1xuICAgIGNvbnN0cnVjdG9yKGFyYiwgbWluTGVuZ3RoLCBtYXhMZW5ndGgsIGlzRXF1YWwpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5hcmIgPSBhcmI7XG4gICAgICAgIHRoaXMubWluTGVuZ3RoID0gbWluTGVuZ3RoO1xuICAgICAgICB0aGlzLm1heExlbmd0aCA9IG1heExlbmd0aDtcbiAgICAgICAgdGhpcy5pc0VxdWFsID0gaXNFcXVhbDtcbiAgICAgICAgdGhpcy5sZW5ndGhBcmIgPSBDb252ZXJ0ZXJzXzEuY29udmVydFRvTmV4dChpbnRlZ2VyXzEuaW50ZWdlcihtaW5MZW5ndGgsIG1heExlbmd0aCkpO1xuICAgICAgICB0aGlzLnByZUZpbHRlciA9IHRoaXMuaXNFcXVhbCAhPT0gdW5kZWZpbmVkID8gQnVpbGRDb21wYXJlRmlsdGVyXzEuYnVpbGRDb21wYXJlRmlsdGVyKHRoaXMuaXNFcXVhbCkgOiAodGFiKSA9PiB0YWI7XG4gICAgfVxuICAgIHN0YXRpYyBtYWtlSXRDbG9uZWFibGUodnMsIHNocmlua2FibGVzKSB7XG4gICAgICAgIHZzW3N5bWJvbHNfMS5jbG9uZU1ldGhvZF0gPSAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBjbG9uZWQgPSBbXTtcbiAgICAgICAgICAgIGZvciAobGV0IGlkeCA9IDA7IGlkeCAhPT0gc2hyaW5rYWJsZXMubGVuZ3RoOyArK2lkeCkge1xuICAgICAgICAgICAgICAgIGNsb25lZC5wdXNoKHNocmlua2FibGVzW2lkeF0udmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5tYWtlSXRDbG9uZWFibGUoY2xvbmVkLCBzaHJpbmthYmxlcyk7XG4gICAgICAgICAgICByZXR1cm4gY2xvbmVkO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gdnM7XG4gICAgfVxuICAgIHN0YXRpYyBjYW5BcHBlbmRJdGVtKGl0ZW1zLCBuZXdJdGVtLCBpc0VxdWFsKSB7XG4gICAgICAgIGZvciAobGV0IGlkeCA9IDA7IGlkeCAhPT0gaXRlbXMubGVuZ3RoOyArK2lkeCkge1xuICAgICAgICAgICAgaWYgKGlzRXF1YWwoaXRlbXNbaWR4XS52YWx1ZV8sIG5ld0l0ZW0udmFsdWVfKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgZ2VuZXJhdGVOSXRlbXNOb0R1cGxpY2F0ZXMoTiwgbXJuZywgYmlhc0ZhY3Rvckl0ZW1zKSB7XG4gICAgICAgIGxldCBudW1Ta2lwcGVkSW5Sb3cgPSAwO1xuICAgICAgICBjb25zdCBpdGVtcyA9IFtdO1xuICAgICAgICB3aGlsZSAoaXRlbXMubGVuZ3RoIDwgTiAmJiBudW1Ta2lwcGVkSW5Sb3cgPCB0aGlzLm1heExlbmd0aCkge1xuICAgICAgICAgICAgY29uc3QgY3VycmVudCA9IHRoaXMuYXJiLmdlbmVyYXRlKG1ybmcsIGJpYXNGYWN0b3JJdGVtcyk7XG4gICAgICAgICAgICBpZiAodGhpcy5pc0VxdWFsID09PSB1bmRlZmluZWQgfHwgQXJyYXlBcmJpdHJhcnkuY2FuQXBwZW5kSXRlbShpdGVtcywgY3VycmVudCwgdGhpcy5pc0VxdWFsKSkge1xuICAgICAgICAgICAgICAgIG51bVNraXBwZWRJblJvdyA9IDA7XG4gICAgICAgICAgICAgICAgaXRlbXMucHVzaChjdXJyZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG51bVNraXBwZWRJblJvdyArPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpdGVtcztcbiAgICB9XG4gICAgZ2VuZXJhdGVOSXRlbXMoTiwgbXJuZywgYmlhc0ZhY3Rvckl0ZW1zKSB7XG4gICAgICAgIGNvbnN0IGl0ZW1zID0gW107XG4gICAgICAgIGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggIT09IE47ICsraW5kZXgpIHtcbiAgICAgICAgICAgIGNvbnN0IGN1cnJlbnQgPSB0aGlzLmFyYi5nZW5lcmF0ZShtcm5nLCBiaWFzRmFjdG9ySXRlbXMpO1xuICAgICAgICAgICAgaXRlbXMucHVzaChjdXJyZW50KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaXRlbXM7XG4gICAgfVxuICAgIHdyYXBwZXIoaXRlbXNSYXcsIHNocnVua09uY2UsIGl0ZW1zUmF3TGVuZ3RoQ29udGV4dCkge1xuICAgICAgICBjb25zdCBpdGVtcyA9IHNocnVua09uY2UgPyB0aGlzLnByZUZpbHRlcihpdGVtc1JhdykgOiBpdGVtc1JhdztcbiAgICAgICAgbGV0IGNsb25lYWJsZSA9IGZhbHNlO1xuICAgICAgICBjb25zdCB2cyA9IFtdO1xuICAgICAgICBjb25zdCBpdGVtc0NvbnRleHRzID0gW107XG4gICAgICAgIGZvciAobGV0IGlkeCA9IDA7IGlkeCAhPT0gaXRlbXMubGVuZ3RoOyArK2lkeCkge1xuICAgICAgICAgICAgY29uc3QgcyA9IGl0ZW1zW2lkeF07XG4gICAgICAgICAgICBjbG9uZWFibGUgPSBjbG9uZWFibGUgfHwgcy5oYXNUb0JlQ2xvbmVkO1xuICAgICAgICAgICAgdnMucHVzaChzLnZhbHVlKTtcbiAgICAgICAgICAgIGl0ZW1zQ29udGV4dHMucHVzaChzLmNvbnRleHQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjbG9uZWFibGUpIHtcbiAgICAgICAgICAgIEFycmF5QXJiaXRyYXJ5Lm1ha2VJdENsb25lYWJsZSh2cywgaXRlbXMpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNvbnRleHQgPSB7XG4gICAgICAgICAgICBzaHJ1bmtPbmNlLFxuICAgICAgICAgICAgbGVuZ3RoQ29udGV4dDogaXRlbXNSYXcubGVuZ3RoID09PSBpdGVtcy5sZW5ndGggJiYgaXRlbXNSYXdMZW5ndGhDb250ZXh0ICE9PSB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICA/IGl0ZW1zUmF3TGVuZ3RoQ29udGV4dFxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgaXRlbXNDb250ZXh0cyxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIG5ldyBOZXh0VmFsdWVfMS5OZXh0VmFsdWUodnMsIGNvbnRleHQpO1xuICAgIH1cbiAgICBnZW5lcmF0ZShtcm5nLCBiaWFzRmFjdG9yKSB7XG4gICAgICAgIGNvbnN0IGJpYXNNZXRhID0gdGhpcy5hcHBseUJpYXMobXJuZywgYmlhc0ZhY3Rvcik7XG4gICAgICAgIGNvbnN0IHRhcmdldFNpemUgPSBiaWFzTWV0YS5zaXplO1xuICAgICAgICBjb25zdCBpdGVtcyA9IHRoaXMuaXNFcXVhbCAhPT0gdW5kZWZpbmVkXG4gICAgICAgICAgICA/IHRoaXMuZ2VuZXJhdGVOSXRlbXNOb0R1cGxpY2F0ZXModGFyZ2V0U2l6ZSwgbXJuZywgYmlhc01ldGEuYmlhc0ZhY3Rvckl0ZW1zKVxuICAgICAgICAgICAgOiB0aGlzLmdlbmVyYXRlTkl0ZW1zKHRhcmdldFNpemUsIG1ybmcsIGJpYXNNZXRhLmJpYXNGYWN0b3JJdGVtcyk7XG4gICAgICAgIHJldHVybiB0aGlzLndyYXBwZXIoaXRlbXMsIGZhbHNlLCB1bmRlZmluZWQpO1xuICAgIH1cbiAgICBhcHBseUJpYXMobXJuZywgYmlhc0ZhY3Rvcikge1xuICAgICAgICBpZiAoYmlhc0ZhY3RvciA9PT0gdW5kZWZpbmVkIHx8IG1ybmcubmV4dEludCgxLCBiaWFzRmFjdG9yKSAhPT0gMSkge1xuICAgICAgICAgICAgcmV0dXJuIHsgc2l6ZTogdGhpcy5sZW5ndGhBcmIuZ2VuZXJhdGUobXJuZywgdW5kZWZpbmVkKS52YWx1ZSB9O1xuICAgICAgICB9XG4gICAgICAgIGlmIChtcm5nLm5leHRJbnQoMSwgYmlhc0ZhY3RvcikgIT09IDEgfHwgdGhpcy5taW5MZW5ndGggPT09IHRoaXMubWF4TGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4geyBzaXplOiB0aGlzLmxlbmd0aEFyYi5nZW5lcmF0ZShtcm5nLCB1bmRlZmluZWQpLnZhbHVlLCBiaWFzRmFjdG9ySXRlbXM6IGJpYXNGYWN0b3IgfTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtYXhCaWFzZWRMZW5ndGggPSB0aGlzLm1pbkxlbmd0aCArIE1hdGguZmxvb3IoTWF0aC5sb2codGhpcy5tYXhMZW5ndGggLSB0aGlzLm1pbkxlbmd0aCkgLyBNYXRoLmxvZygyKSk7XG4gICAgICAgIGNvbnN0IHRhcmdldFNpemVWYWx1ZSA9IENvbnZlcnRlcnNfMS5jb252ZXJ0VG9OZXh0KGludGVnZXJfMS5pbnRlZ2VyKHRoaXMubWluTGVuZ3RoLCBtYXhCaWFzZWRMZW5ndGgpKS5nZW5lcmF0ZShtcm5nLCB1bmRlZmluZWQpO1xuICAgICAgICByZXR1cm4geyBzaXplOiB0YXJnZXRTaXplVmFsdWUudmFsdWUsIGJpYXNGYWN0b3JJdGVtczogYmlhc0ZhY3RvciB9O1xuICAgIH1cbiAgICBjYW5TaHJpbmtXaXRob3V0Q29udGV4dCh2YWx1ZSkge1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkodmFsdWUpIHx8IHRoaXMubWluTGVuZ3RoID4gdmFsdWUubGVuZ3RoIHx8IHZhbHVlLmxlbmd0aCA+IHRoaXMubWF4TGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCAhPT0gdmFsdWUubGVuZ3RoOyArK2luZGV4KSB7XG4gICAgICAgICAgICBpZiAoIShpbmRleCBpbiB2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXRoaXMuYXJiLmNhblNocmlua1dpdGhvdXRDb250ZXh0KHZhbHVlW2luZGV4XSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZmlsdGVyZWQgPSB0aGlzLnByZUZpbHRlcih2YWx1ZS5tYXAoKGl0ZW0pID0+IG5ldyBOZXh0VmFsdWVfMS5OZXh0VmFsdWUoaXRlbSwgdW5kZWZpbmVkKSkpO1xuICAgICAgICByZXR1cm4gZmlsdGVyZWQubGVuZ3RoID09PSB2YWx1ZS5sZW5ndGg7XG4gICAgfVxuICAgIHNocmlua0ltcGwodmFsdWUsIGNvbnRleHQpIHtcbiAgICAgICAgaWYgKHZhbHVlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIFN0cmVhbV8xLlN0cmVhbS5uaWwoKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzYWZlQ29udGV4dCA9IGNvbnRleHQgIT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgPyBjb250ZXh0XG4gICAgICAgICAgICA6IHsgc2hydW5rT25jZTogZmFsc2UsIGxlbmd0aENvbnRleHQ6IHVuZGVmaW5lZCwgaXRlbXNDb250ZXh0czogW10gfTtcbiAgICAgICAgcmV0dXJuICh0aGlzLmxlbmd0aEFyYlxuICAgICAgICAgICAgLnNocmluayh2YWx1ZS5sZW5ndGgsIHNhZmVDb250ZXh0Lmxlbmd0aENvbnRleHQpXG4gICAgICAgICAgICAuZHJvcChzYWZlQ29udGV4dC5zaHJ1bmtPbmNlICYmIHNhZmVDb250ZXh0Lmxlbmd0aENvbnRleHQgPT09IHVuZGVmaW5lZCAmJiB2YWx1ZS5sZW5ndGggPiB0aGlzLm1pbkxlbmd0aCArIDEgPyAxIDogMClcbiAgICAgICAgICAgIC5tYXAoKGxlbmd0aFZhbHVlKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBzbGljZVN0YXJ0ID0gdmFsdWUubGVuZ3RoIC0gbGVuZ3RoVmFsdWUudmFsdWU7XG4gICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgIHZhbHVlXG4gICAgICAgICAgICAgICAgICAgIC5zbGljZShzbGljZVN0YXJ0KVxuICAgICAgICAgICAgICAgICAgICAubWFwKCh2LCBpbmRleCkgPT4gbmV3IE5leHRWYWx1ZV8xLk5leHRWYWx1ZShzeW1ib2xzXzEuY2xvbmVJZk5lZWRlZCh2KSwgc2FmZUNvbnRleHQuaXRlbXNDb250ZXh0c1tpbmRleCArIHNsaWNlU3RhcnRdKSksXG4gICAgICAgICAgICAgICAgbGVuZ3RoVmFsdWUuY29udGV4dCxcbiAgICAgICAgICAgIF07XG4gICAgICAgIH0pXG4gICAgICAgICAgICAuam9pbih0aGlzLmFyYi5zaHJpbmsodmFsdWVbMF0sIHNhZmVDb250ZXh0Lml0ZW1zQ29udGV4dHNbMF0pLm1hcCgodikgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICBbdl0uY29uY2F0KHZhbHVlLnNsaWNlKDEpLm1hcCgodiwgaW5kZXgpID0+IG5ldyBOZXh0VmFsdWVfMS5OZXh0VmFsdWUoc3ltYm9sc18xLmNsb25lSWZOZWVkZWQodiksIHNhZmVDb250ZXh0Lml0ZW1zQ29udGV4dHNbaW5kZXggKyAxXSkpKSxcbiAgICAgICAgICAgICAgICB1bmRlZmluZWQsXG4gICAgICAgICAgICBdO1xuICAgICAgICB9KSlcbiAgICAgICAgICAgIC5qb2luKHZhbHVlLmxlbmd0aCA+IHRoaXMubWluTGVuZ3RoXG4gICAgICAgICAgICA/IExhenlJdGVyYWJsZUl0ZXJhdG9yXzEubWFrZUxhenkoKCkgPT4gdGhpcy5zaHJpbmtJbXBsKHZhbHVlLnNsaWNlKDEpLCB7XG4gICAgICAgICAgICAgICAgc2hydW5rT25jZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgbGVuZ3RoQ29udGV4dDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgIGl0ZW1zQ29udGV4dHM6IHNhZmVDb250ZXh0Lml0ZW1zQ29udGV4dHMuc2xpY2UoMSksXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC5maWx0ZXIoKHYpID0+IHRoaXMubWluTGVuZ3RoIDw9IHZbMF0ubGVuZ3RoICsgMSlcbiAgICAgICAgICAgICAgICAubWFwKCh2KSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAgICAgW25ldyBOZXh0VmFsdWVfMS5OZXh0VmFsdWUoc3ltYm9sc18xLmNsb25lSWZOZWVkZWQodmFsdWVbMF0pLCBzYWZlQ29udGV4dC5pdGVtc0NvbnRleHRzWzBdKV0uY29uY2F0KHZbMF0pLFxuICAgICAgICAgICAgICAgICAgICB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIH0pKVxuICAgICAgICAgICAgOiBTdHJlYW1fMS5TdHJlYW0ubmlsKCkpKTtcbiAgICB9XG4gICAgc2hyaW5rKHZhbHVlLCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNocmlua0ltcGwodmFsdWUsIGNvbnRleHQpLm1hcCgoY29udGV4dHVhbFZhbHVlKSA9PiB0aGlzLndyYXBwZXIoY29udGV4dHVhbFZhbHVlWzBdLCB0cnVlLCBjb250ZXh0dWFsVmFsdWVbMV0pKTtcbiAgICB9XG59XG5leHBvcnRzLkFycmF5QXJiaXRyYXJ5ID0gQXJyYXlBcmJpdHJhcnk7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQmlnSW50QXJiaXRyYXJ5ID0gdm9pZCAwO1xuY29uc3QgU3RyZWFtXzEgPSByZXF1aXJlKFwiLi4vLi4vc3RyZWFtL1N0cmVhbVwiKTtcbmNvbnN0IE5leHRBcmJpdHJhcnlfMSA9IHJlcXVpcmUoXCIuLi8uLi9jaGVjay9hcmJpdHJhcnkvZGVmaW5pdGlvbi9OZXh0QXJiaXRyYXJ5XCIpO1xuY29uc3QgTmV4dFZhbHVlXzEgPSByZXF1aXJlKFwiLi4vLi4vY2hlY2svYXJiaXRyYXJ5L2RlZmluaXRpb24vTmV4dFZhbHVlXCIpO1xuY29uc3QgQmlhc051bWVyaWNSYW5nZV8xID0gcmVxdWlyZShcIi4vaGVscGVycy9CaWFzTnVtZXJpY1JhbmdlXCIpO1xuY29uc3QgU2hyaW5rQmlnSW50XzEgPSByZXF1aXJlKFwiLi9oZWxwZXJzL1Nocmlua0JpZ0ludFwiKTtcbmNsYXNzIEJpZ0ludEFyYml0cmFyeSBleHRlbmRzIE5leHRBcmJpdHJhcnlfMS5OZXh0QXJiaXRyYXJ5IHtcbiAgICBjb25zdHJ1Y3RvcihtaW4sIG1heCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLm1pbiA9IG1pbjtcbiAgICAgICAgdGhpcy5tYXggPSBtYXg7XG4gICAgfVxuICAgIGdlbmVyYXRlKG1ybmcsIGJpYXNGYWN0b3IpIHtcbiAgICAgICAgY29uc3QgcmFuZ2UgPSB0aGlzLmNvbXB1dGVHZW5lcmF0ZVJhbmdlKG1ybmcsIGJpYXNGYWN0b3IpO1xuICAgICAgICByZXR1cm4gbmV3IE5leHRWYWx1ZV8xLk5leHRWYWx1ZShtcm5nLm5leHRCaWdJbnQocmFuZ2UubWluLCByYW5nZS5tYXgpLCB1bmRlZmluZWQpO1xuICAgIH1cbiAgICBjb21wdXRlR2VuZXJhdGVSYW5nZShtcm5nLCBiaWFzRmFjdG9yKSB7XG4gICAgICAgIGlmIChiaWFzRmFjdG9yID09PSB1bmRlZmluZWQgfHwgbXJuZy5uZXh0SW50KDEsIGJpYXNGYWN0b3IpICE9PSAxKSB7XG4gICAgICAgICAgICByZXR1cm4geyBtaW46IHRoaXMubWluLCBtYXg6IHRoaXMubWF4IH07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmFuZ2VzID0gQmlhc051bWVyaWNSYW5nZV8xLmJpYXNOdW1lcmljUmFuZ2UodGhpcy5taW4sIHRoaXMubWF4LCBCaWFzTnVtZXJpY1JhbmdlXzEuYmlnSW50TG9nTGlrZSk7XG4gICAgICAgIGlmIChyYW5nZXMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICByZXR1cm4gcmFuZ2VzWzBdO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGlkID0gbXJuZy5uZXh0SW50KC0yICogKHJhbmdlcy5sZW5ndGggLSAxKSwgcmFuZ2VzLmxlbmd0aCAtIDIpO1xuICAgICAgICByZXR1cm4gaWQgPCAwID8gcmFuZ2VzWzBdIDogcmFuZ2VzW2lkICsgMV07XG4gICAgfVxuICAgIGNhblNocmlua1dpdGhvdXRDb250ZXh0KHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdiaWdpbnQnICYmIHRoaXMubWluIDw9IHZhbHVlICYmIHZhbHVlIDw9IHRoaXMubWF4O1xuICAgIH1cbiAgICBzaHJpbmsoY3VycmVudCwgY29udGV4dCkge1xuICAgICAgICBpZiAoIUJpZ0ludEFyYml0cmFyeS5pc1ZhbGlkQ29udGV4dChjdXJyZW50LCBjb250ZXh0KSkge1xuICAgICAgICAgICAgY29uc3QgdGFyZ2V0ID0gdGhpcy5kZWZhdWx0VGFyZ2V0KCk7XG4gICAgICAgICAgICByZXR1cm4gU2hyaW5rQmlnSW50XzEuc2hyaW5rQmlnSW50KGN1cnJlbnQsIHRhcmdldCwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuaXNMYXN0Q2hhbmNlVHJ5KGN1cnJlbnQsIGNvbnRleHQpKSB7XG4gICAgICAgICAgICByZXR1cm4gU3RyZWFtXzEuU3RyZWFtLm9mKG5ldyBOZXh0VmFsdWVfMS5OZXh0VmFsdWUoY29udGV4dCwgdW5kZWZpbmVkKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFNocmlua0JpZ0ludF8xLnNocmlua0JpZ0ludChjdXJyZW50LCBjb250ZXh0LCBmYWxzZSk7XG4gICAgfVxuICAgIGRlZmF1bHRUYXJnZXQoKSB7XG4gICAgICAgIGlmICh0aGlzLm1pbiA8PSAwICYmIHRoaXMubWF4ID49IDApIHtcbiAgICAgICAgICAgIHJldHVybiBCaWdJbnQoMCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMubWluIDwgMCA/IHRoaXMubWF4IDogdGhpcy5taW47XG4gICAgfVxuICAgIGlzTGFzdENoYW5jZVRyeShjdXJyZW50LCBjb250ZXh0KSB7XG4gICAgICAgIGlmIChjdXJyZW50ID4gMClcbiAgICAgICAgICAgIHJldHVybiBjdXJyZW50ID09PSBjb250ZXh0ICsgQmlnSW50KDEpICYmIGN1cnJlbnQgPiB0aGlzLm1pbjtcbiAgICAgICAgaWYgKGN1cnJlbnQgPCAwKVxuICAgICAgICAgICAgcmV0dXJuIGN1cnJlbnQgPT09IGNvbnRleHQgLSBCaWdJbnQoMSkgJiYgY3VycmVudCA8IHRoaXMubWF4O1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHN0YXRpYyBpc1ZhbGlkQ29udGV4dChjdXJyZW50LCBjb250ZXh0KSB7XG4gICAgICAgIGlmIChjb250ZXh0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGNvbnRleHQgIT09ICdiaWdpbnQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgY29udGV4dCB0eXBlIHBhc3NlZCB0byBCaWdJbnRBcmJpdHJhcnkgKCMxKWApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGRpZmZlcmVudFNpZ25zID0gKGN1cnJlbnQgPiAwICYmIGNvbnRleHQgPCAwKSB8fCAoY3VycmVudCA8IDAgJiYgY29udGV4dCA+IDApO1xuICAgICAgICBpZiAoY29udGV4dCAhPT0gQmlnSW50KDApICYmIGRpZmZlcmVudFNpZ25zKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgY29udGV4dCB2YWx1ZSBwYXNzZWQgdG8gQmlnSW50QXJiaXRyYXJ5ICgjMilgKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG59XG5leHBvcnRzLkJpZ0ludEFyYml0cmFyeSA9IEJpZ0ludEFyYml0cmFyeTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5DbG9uZUFyYml0cmFyeSA9IHZvaWQgMDtcbmNvbnN0IE5leHRBcmJpdHJhcnlfMSA9IHJlcXVpcmUoXCIuLi8uLi9jaGVjay9hcmJpdHJhcnkvZGVmaW5pdGlvbi9OZXh0QXJiaXRyYXJ5XCIpO1xuY29uc3QgTmV4dFZhbHVlXzEgPSByZXF1aXJlKFwiLi4vLi4vY2hlY2svYXJiaXRyYXJ5L2RlZmluaXRpb24vTmV4dFZhbHVlXCIpO1xuY29uc3Qgc3ltYm9sc18xID0gcmVxdWlyZShcIi4uLy4uL2NoZWNrL3N5bWJvbHNcIik7XG5jb25zdCBTdHJlYW1fMSA9IHJlcXVpcmUoXCIuLi8uLi9zdHJlYW0vU3RyZWFtXCIpO1xuY2xhc3MgQ2xvbmVBcmJpdHJhcnkgZXh0ZW5kcyBOZXh0QXJiaXRyYXJ5XzEuTmV4dEFyYml0cmFyeSB7XG4gICAgY29uc3RydWN0b3IoYXJiLCBudW1WYWx1ZXMpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5hcmIgPSBhcmI7XG4gICAgICAgIHRoaXMubnVtVmFsdWVzID0gbnVtVmFsdWVzO1xuICAgIH1cbiAgICBnZW5lcmF0ZShtcm5nLCBiaWFzRmFjdG9yKSB7XG4gICAgICAgIGNvbnN0IGl0ZW1zID0gW107XG4gICAgICAgIGlmICh0aGlzLm51bVZhbHVlcyA8PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy53cmFwcGVyKGl0ZW1zKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBpZHggPSAwOyBpZHggIT09IHRoaXMubnVtVmFsdWVzIC0gMTsgKytpZHgpIHtcbiAgICAgICAgICAgIGl0ZW1zLnB1c2godGhpcy5hcmIuZ2VuZXJhdGUobXJuZy5jbG9uZSgpLCBiaWFzRmFjdG9yKSk7XG4gICAgICAgIH1cbiAgICAgICAgaXRlbXMucHVzaCh0aGlzLmFyYi5nZW5lcmF0ZShtcm5nLCBiaWFzRmFjdG9yKSk7XG4gICAgICAgIHJldHVybiB0aGlzLndyYXBwZXIoaXRlbXMpO1xuICAgIH1cbiAgICBjYW5TaHJpbmtXaXRob3V0Q29udGV4dCh2YWx1ZSkge1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkodmFsdWUpIHx8IHZhbHVlLmxlbmd0aCAhPT0gdGhpcy5udW1WYWx1ZXMpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodmFsdWUubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBpbmRleCA9IDE7IGluZGV4IDwgdmFsdWUubGVuZ3RoOyArK2luZGV4KSB7XG4gICAgICAgICAgICBpZiAoIU9iamVjdC5pcyh2YWx1ZVswXSwgdmFsdWVbaW5kZXhdKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5hcmIuY2FuU2hyaW5rV2l0aG91dENvbnRleHQodmFsdWVbMF0pO1xuICAgIH1cbiAgICBzaHJpbmsodmFsdWUsIGNvbnRleHQpIHtcbiAgICAgICAgaWYgKHZhbHVlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIFN0cmVhbV8xLlN0cmVhbS5uaWwoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFN0cmVhbV8xLlN0cmVhbSh0aGlzLnNocmlua0ltcGwodmFsdWUsIGNvbnRleHQgIT09IHVuZGVmaW5lZCA/IGNvbnRleHQgOiBbXSkpLm1hcCgodikgPT4gdGhpcy53cmFwcGVyKHYpKTtcbiAgICB9XG4gICAgKnNocmlua0ltcGwodmFsdWUsIGNvbnRleHRzKSB7XG4gICAgICAgIGNvbnN0IGl0cyA9IHZhbHVlLm1hcCgodiwgaWR4KSA9PiB0aGlzLmFyYi5zaHJpbmsodiwgY29udGV4dHNbaWR4XSlbU3ltYm9sLml0ZXJhdG9yXSgpKTtcbiAgICAgICAgbGV0IGN1ciA9IGl0cy5tYXAoKGl0KSA9PiBpdC5uZXh0KCkpO1xuICAgICAgICB3aGlsZSAoIWN1clswXS5kb25lKSB7XG4gICAgICAgICAgICB5aWVsZCBjdXIubWFwKChjKSA9PiBjLnZhbHVlKTtcbiAgICAgICAgICAgIGN1ciA9IGl0cy5tYXAoKGl0KSA9PiBpdC5uZXh0KCkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHN0YXRpYyBtYWtlSXRDbG9uZWFibGUodnMsIHNocmlua2FibGVzKSB7XG4gICAgICAgIHZzW3N5bWJvbHNfMS5jbG9uZU1ldGhvZF0gPSAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBjbG9uZWQgPSBbXTtcbiAgICAgICAgICAgIGZvciAobGV0IGlkeCA9IDA7IGlkeCAhPT0gc2hyaW5rYWJsZXMubGVuZ3RoOyArK2lkeCkge1xuICAgICAgICAgICAgICAgIGNsb25lZC5wdXNoKHNocmlua2FibGVzW2lkeF0udmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5tYWtlSXRDbG9uZWFibGUoY2xvbmVkLCBzaHJpbmthYmxlcyk7XG4gICAgICAgICAgICByZXR1cm4gY2xvbmVkO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gdnM7XG4gICAgfVxuICAgIHdyYXBwZXIoaXRlbXMpIHtcbiAgICAgICAgbGV0IGNsb25lYWJsZSA9IGZhbHNlO1xuICAgICAgICBjb25zdCB2cyA9IFtdO1xuICAgICAgICBjb25zdCBjb250ZXh0cyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpZHggPSAwOyBpZHggIT09IGl0ZW1zLmxlbmd0aDsgKytpZHgpIHtcbiAgICAgICAgICAgIGNvbnN0IHMgPSBpdGVtc1tpZHhdO1xuICAgICAgICAgICAgY2xvbmVhYmxlID0gY2xvbmVhYmxlIHx8IHMuaGFzVG9CZUNsb25lZDtcbiAgICAgICAgICAgIHZzLnB1c2gocy52YWx1ZSk7XG4gICAgICAgICAgICBjb250ZXh0cy5wdXNoKHMuY29udGV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNsb25lYWJsZSkge1xuICAgICAgICAgICAgQ2xvbmVBcmJpdHJhcnkubWFrZUl0Q2xvbmVhYmxlKHZzLCBpdGVtcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBOZXh0VmFsdWVfMS5OZXh0VmFsdWUodnMsIGNvbnRleHRzKTtcbiAgICB9XG59XG5leHBvcnRzLkNsb25lQXJiaXRyYXJ5ID0gQ2xvbmVBcmJpdHJhcnk7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQ29uc3RhbnRBcmJpdHJhcnkgPSB2b2lkIDA7XG5jb25zdCBTdHJlYW1fMSA9IHJlcXVpcmUoXCIuLi8uLi9zdHJlYW0vU3RyZWFtXCIpO1xuY29uc3QgTmV4dEFyYml0cmFyeV8xID0gcmVxdWlyZShcIi4uLy4uL2NoZWNrL2FyYml0cmFyeS9kZWZpbml0aW9uL05leHRBcmJpdHJhcnlcIik7XG5jb25zdCBOZXh0VmFsdWVfMSA9IHJlcXVpcmUoXCIuLi8uLi9jaGVjay9hcmJpdHJhcnkvZGVmaW5pdGlvbi9OZXh0VmFsdWVcIik7XG5jb25zdCBzeW1ib2xzXzEgPSByZXF1aXJlKFwiLi4vLi4vY2hlY2svc3ltYm9sc1wiKTtcbmNsYXNzIENvbnN0YW50QXJiaXRyYXJ5IGV4dGVuZHMgTmV4dEFyYml0cmFyeV8xLk5leHRBcmJpdHJhcnkge1xuICAgIGNvbnN0cnVjdG9yKHZhbHVlcykge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLnZhbHVlcyA9IHZhbHVlcztcbiAgICB9XG4gICAgZ2VuZXJhdGUobXJuZywgX2JpYXNGYWN0b3IpIHtcbiAgICAgICAgY29uc3QgaWR4ID0gdGhpcy52YWx1ZXMubGVuZ3RoID09PSAxID8gMCA6IG1ybmcubmV4dEludCgwLCB0aGlzLnZhbHVlcy5sZW5ndGggLSAxKTtcbiAgICAgICAgY29uc3QgdmFsdWUgPSB0aGlzLnZhbHVlc1tpZHhdO1xuICAgICAgICBpZiAoIXN5bWJvbHNfMS5oYXNDbG9uZU1ldGhvZCh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgTmV4dFZhbHVlXzEuTmV4dFZhbHVlKHZhbHVlLCBpZHgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgTmV4dFZhbHVlXzEuTmV4dFZhbHVlKHZhbHVlLCBpZHgsICgpID0+IHZhbHVlW3N5bWJvbHNfMS5jbG9uZU1ldGhvZF0oKSk7XG4gICAgfVxuICAgIGNhblNocmlua1dpdGhvdXRDb250ZXh0KHZhbHVlKSB7XG4gICAgICAgIGZvciAobGV0IGlkeCA9IDA7IGlkeCAhPT0gdGhpcy52YWx1ZXMubGVuZ3RoOyArK2lkeCkge1xuICAgICAgICAgICAgaWYgKE9iamVjdC5pcyh0aGlzLnZhbHVlc1tpZHhdLCB2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHNocmluayh2YWx1ZSwgY29udGV4dCkge1xuICAgICAgICBpZiAoY29udGV4dCA9PT0gMCB8fCBPYmplY3QuaXModmFsdWUsIHRoaXMudmFsdWVzWzBdKSkge1xuICAgICAgICAgICAgcmV0dXJuIFN0cmVhbV8xLlN0cmVhbS5uaWwoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gU3RyZWFtXzEuU3RyZWFtLm9mKG5ldyBOZXh0VmFsdWVfMS5OZXh0VmFsdWUodGhpcy52YWx1ZXNbMF0sIDApKTtcbiAgICB9XG59XG5leHBvcnRzLkNvbnN0YW50QXJiaXRyYXJ5ID0gQ29uc3RhbnRBcmJpdHJhcnk7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuRnJlcXVlbmN5QXJiaXRyYXJ5ID0gdm9pZCAwO1xuY29uc3QgU3RyZWFtXzEgPSByZXF1aXJlKFwiLi4vLi4vc3RyZWFtL1N0cmVhbVwiKTtcbmNvbnN0IENvbnZlcnRlcnNfMSA9IHJlcXVpcmUoXCIuLi8uLi9jaGVjay9hcmJpdHJhcnkvZGVmaW5pdGlvbi9Db252ZXJ0ZXJzXCIpO1xuY29uc3QgTmV4dEFyYml0cmFyeV8xID0gcmVxdWlyZShcIi4uLy4uL2NoZWNrL2FyYml0cmFyeS9kZWZpbml0aW9uL05leHRBcmJpdHJhcnlcIik7XG5jb25zdCBOZXh0VmFsdWVfMSA9IHJlcXVpcmUoXCIuLi8uLi9jaGVjay9hcmJpdHJhcnkvZGVmaW5pdGlvbi9OZXh0VmFsdWVcIik7XG5jb25zdCBEZXB0aENvbnRleHRfMSA9IHJlcXVpcmUoXCIuL2hlbHBlcnMvRGVwdGhDb250ZXh0XCIpO1xuY2xhc3MgRnJlcXVlbmN5QXJiaXRyYXJ5IGV4dGVuZHMgTmV4dEFyYml0cmFyeV8xLk5leHRBcmJpdHJhcnkge1xuICAgIGNvbnN0cnVjdG9yKHdhcmJzLCBjb25zdHJhaW50cywgY29udGV4dCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLndhcmJzID0gd2FyYnM7XG4gICAgICAgIHRoaXMuY29uc3RyYWludHMgPSBjb25zdHJhaW50cztcbiAgICAgICAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgICAgICAgbGV0IGN1cnJlbnRXZWlnaHQgPSAwO1xuICAgICAgICB0aGlzLmN1bXVsYXRlZFdlaWdodHMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaWR4ID0gMDsgaWR4ICE9PSB3YXJicy5sZW5ndGg7ICsraWR4KSB7XG4gICAgICAgICAgICBjdXJyZW50V2VpZ2h0ICs9IHdhcmJzW2lkeF0ud2VpZ2h0O1xuICAgICAgICAgICAgdGhpcy5jdW11bGF0ZWRXZWlnaHRzLnB1c2goY3VycmVudFdlaWdodCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy50b3RhbFdlaWdodCA9IGN1cnJlbnRXZWlnaHQ7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tT2xkKHdhcmJzLCBjb25zdHJhaW50cywgbGFiZWwpIHtcbiAgICAgICAgcmV0dXJuIENvbnZlcnRlcnNfMS5jb252ZXJ0RnJvbU5leHQoRnJlcXVlbmN5QXJiaXRyYXJ5LmZyb20od2FyYnMubWFwKCh3KSA9PiAoT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB3KSwgeyBhcmJpdHJhcnk6IENvbnZlcnRlcnNfMS5jb252ZXJ0VG9OZXh0KHcuYXJiaXRyYXJ5KSB9KSkpLCBjb25zdHJhaW50cywgbGFiZWwpKTtcbiAgICB9XG4gICAgc3RhdGljIGZyb20od2FyYnMsIGNvbnN0cmFpbnRzLCBsYWJlbCkge1xuICAgICAgICBpZiAod2FyYnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7bGFiZWx9IGV4cGVjdHMgYXQgbGVhc3Qgb25lIHdlaWd0aGVkIGFyYml0cmFyeWApO1xuICAgICAgICB9XG4gICAgICAgIGxldCB0b3RhbFdlaWdodCA9IDA7XG4gICAgICAgIGZvciAobGV0IGlkeCA9IDA7IGlkeCAhPT0gd2FyYnMubGVuZ3RoOyArK2lkeCkge1xuICAgICAgICAgICAgY29uc3QgY3VycmVudEFyYml0cmFyeSA9IHdhcmJzW2lkeF0uYXJiaXRyYXJ5O1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRBcmJpdHJhcnkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgJHtsYWJlbH0gZXhwZWN0cyBhcmJpdHJhcmllcyB0byBiZSBzcGVjaWZpZWRgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRXZWlnaHQgPSB3YXJic1tpZHhdLndlaWdodDtcbiAgICAgICAgICAgIHRvdGFsV2VpZ2h0ICs9IGN1cnJlbnRXZWlnaHQ7XG4gICAgICAgICAgICBpZiAoIU51bWJlci5pc0ludGVnZXIoY3VycmVudFdlaWdodCkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7bGFiZWx9IGV4cGVjdHMgd2VpZ2h0cyB0byBiZSBpbnRlZ2VyIHZhbHVlc2ApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGN1cnJlbnRXZWlnaHQgPCAwKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAke2xhYmVsfSBleHBlY3RzIHdlaWdodHMgdG8gYmUgc3VwZXJpb3Igb3IgZXF1YWwgdG8gMGApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0b3RhbFdlaWdodCA8PSAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7bGFiZWx9IGV4cGVjdHMgdGhlIHN1bSBvZiB3ZWlnaHRzIHRvIGJlIHN0cmljdGx5IHN1cGVyaW9yIHRvIDBgKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IEZyZXF1ZW5jeUFyYml0cmFyeSh3YXJicywgY29uc3RyYWludHMsIERlcHRoQ29udGV4dF8xLmdldERlcHRoQ29udGV4dEZvcihjb25zdHJhaW50cy5kZXB0aElkZW50aWZpZXIpKTtcbiAgICB9XG4gICAgZ2VuZXJhdGUobXJuZywgYmlhc0ZhY3Rvcikge1xuICAgICAgICBpZiAodGhpcy5tdXN0R2VuZXJhdGVGaXJzdCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zYWZlR2VuZXJhdGVGb3JJbmRleChtcm5nLCAwLCBiaWFzRmFjdG9yKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzZWxlY3RlZCA9IG1ybmcubmV4dEludCh0aGlzLmNvbXB1dGVOZWdEZXB0aEJlbmVmaXQoKSwgdGhpcy50b3RhbFdlaWdodCAtIDEpO1xuICAgICAgICBmb3IgKGxldCBpZHggPSAwOyBpZHggIT09IHRoaXMuY3VtdWxhdGVkV2VpZ2h0cy5sZW5ndGg7ICsraWR4KSB7XG4gICAgICAgICAgICBpZiAoc2VsZWN0ZWQgPCB0aGlzLmN1bXVsYXRlZFdlaWdodHNbaWR4XSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnNhZmVHZW5lcmF0ZUZvckluZGV4KG1ybmcsIGlkeCwgYmlhc0ZhY3Rvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmFibGUgdG8gZ2VuZXJhdGUgZnJvbSBmYy5mcmVxdWVuY3lgKTtcbiAgICB9XG4gICAgY2FuU2hyaW5rV2l0aG91dENvbnRleHQodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FuU2hyaW5rV2l0aG91dENvbnRleHRJbmRleCh2YWx1ZSkgIT09IC0xO1xuICAgIH1cbiAgICBzaHJpbmsodmFsdWUsIGNvbnRleHQpIHtcbiAgICAgICAgaWYgKGNvbnRleHQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY29uc3Qgc2FmZUNvbnRleHQgPSBjb250ZXh0O1xuICAgICAgICAgICAgY29uc3Qgc2VsZWN0ZWRJbmRleCA9IHNhZmVDb250ZXh0LnNlbGVjdGVkSW5kZXg7XG4gICAgICAgICAgICBjb25zdCBvcmlnaW5hbEJpYXMgPSBzYWZlQ29udGV4dC5vcmlnaW5hbEJpYXM7XG4gICAgICAgICAgICBjb25zdCBvcmlnaW5hbEFyYml0cmFyeSA9IHRoaXMud2FyYnNbc2VsZWN0ZWRJbmRleF0uYXJiaXRyYXJ5O1xuICAgICAgICAgICAgY29uc3Qgb3JpZ2luYWxTaHJpbmtzID0gb3JpZ2luYWxBcmJpdHJhcnlcbiAgICAgICAgICAgICAgICAuc2hyaW5rKHZhbHVlLCBzYWZlQ29udGV4dC5vcmlnaW5hbENvbnRleHQpXG4gICAgICAgICAgICAgICAgLm1hcCgodikgPT4gdGhpcy5tYXBJbnRvTmV4dFZhbHVlKHNlbGVjdGVkSW5kZXgsIHYsIG51bGwsIG9yaWdpbmFsQmlhcykpO1xuICAgICAgICAgICAgaWYgKHNhZmVDb250ZXh0LmNsb25lZE1ybmdGb3JGYWxsYmFja0ZpcnN0ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNhZmVDb250ZXh0LmNhY2hlZEdlbmVyYXRlZEZvckZpcnN0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgc2FmZUNvbnRleHQuY2FjaGVkR2VuZXJhdGVkRm9yRmlyc3QgPSB0aGlzLnNhZmVHZW5lcmF0ZUZvckluZGV4KHNhZmVDb250ZXh0LmNsb25lZE1ybmdGb3JGYWxsYmFja0ZpcnN0LCAwLCBvcmlnaW5hbEJpYXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZUZyb21GaXJzdCA9IHNhZmVDb250ZXh0LmNhY2hlZEdlbmVyYXRlZEZvckZpcnN0O1xuICAgICAgICAgICAgICAgIHJldHVybiBTdHJlYW1fMS5TdHJlYW0ub2YodmFsdWVGcm9tRmlyc3QpLmpvaW4ob3JpZ2luYWxTaHJpbmtzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBvcmlnaW5hbFNocmlua3M7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcG90ZW50aWFsU2VsZWN0ZWRJbmRleCA9IHRoaXMuY2FuU2hyaW5rV2l0aG91dENvbnRleHRJbmRleCh2YWx1ZSk7XG4gICAgICAgIGlmIChwb3RlbnRpYWxTZWxlY3RlZEluZGV4ID09PSAtMSkge1xuICAgICAgICAgICAgcmV0dXJuIFN0cmVhbV8xLlN0cmVhbS5uaWwoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5kZWZhdWx0U2hyaW5rRm9yRmlyc3QocG90ZW50aWFsU2VsZWN0ZWRJbmRleCkuam9pbih0aGlzLndhcmJzW3BvdGVudGlhbFNlbGVjdGVkSW5kZXhdLmFyYml0cmFyeVxuICAgICAgICAgICAgLnNocmluayh2YWx1ZSwgdW5kZWZpbmVkKVxuICAgICAgICAgICAgLm1hcCgodikgPT4gdGhpcy5tYXBJbnRvTmV4dFZhbHVlKHBvdGVudGlhbFNlbGVjdGVkSW5kZXgsIHYsIG51bGwsIHVuZGVmaW5lZCkpKTtcbiAgICB9XG4gICAgZGVmYXVsdFNocmlua0ZvckZpcnN0KHNlbGVjdGVkSW5kZXgpIHtcbiAgICAgICAgKyt0aGlzLmNvbnRleHQuZGVwdGg7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMubXVzdEZhbGxiYWNrVG9GaXJzdEluU2hyaW5rKHNlbGVjdGVkSW5kZXgpIHx8IHRoaXMud2FyYnNbMF0uZmFsbGJhY2tWYWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFN0cmVhbV8xLlN0cmVhbS5uaWwoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgIC0tdGhpcy5jb250ZXh0LmRlcHRoO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJhd1Nocmlua1ZhbHVlID0gbmV3IE5leHRWYWx1ZV8xLk5leHRWYWx1ZSh0aGlzLndhcmJzWzBdLmZhbGxiYWNrVmFsdWUuZGVmYXVsdCwgdW5kZWZpbmVkKTtcbiAgICAgICAgcmV0dXJuIFN0cmVhbV8xLlN0cmVhbS5vZih0aGlzLm1hcEludG9OZXh0VmFsdWUoMCwgcmF3U2hyaW5rVmFsdWUsIG51bGwsIHVuZGVmaW5lZCkpO1xuICAgIH1cbiAgICBjYW5TaHJpbmtXaXRob3V0Q29udGV4dEluZGV4KHZhbHVlKSB7XG4gICAgICAgIGlmICh0aGlzLm11c3RHZW5lcmF0ZUZpcnN0KCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLndhcmJzWzBdLmFyYml0cmFyeS5jYW5TaHJpbmtXaXRob3V0Q29udGV4dCh2YWx1ZSkgPyAwIDogLTE7XG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICsrdGhpcy5jb250ZXh0LmRlcHRoO1xuICAgICAgICAgICAgZm9yIChsZXQgaWR4ID0gMDsgaWR4ICE9PSB0aGlzLndhcmJzLmxlbmd0aDsgKytpZHgpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB3YXJiID0gdGhpcy53YXJic1tpZHhdO1xuICAgICAgICAgICAgICAgIGlmICh3YXJiLndlaWdodCAhPT0gMCAmJiB3YXJiLmFyYml0cmFyeS5jYW5TaHJpbmtXaXRob3V0Q29udGV4dCh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGlkeDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICAtLXRoaXMuY29udGV4dC5kZXB0aDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBtYXBJbnRvTmV4dFZhbHVlKGlkeCwgdmFsdWUsIGNsb25lZE1ybmdGb3JGYWxsYmFja0ZpcnN0LCBiaWFzRmFjdG9yKSB7XG4gICAgICAgIGNvbnN0IGNvbnRleHQgPSB7XG4gICAgICAgICAgICBzZWxlY3RlZEluZGV4OiBpZHgsXG4gICAgICAgICAgICBvcmlnaW5hbEJpYXM6IGJpYXNGYWN0b3IsXG4gICAgICAgICAgICBvcmlnaW5hbENvbnRleHQ6IHZhbHVlLmNvbnRleHQsXG4gICAgICAgICAgICBjbG9uZWRNcm5nRm9yRmFsbGJhY2tGaXJzdCxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIG5ldyBOZXh0VmFsdWVfMS5OZXh0VmFsdWUodmFsdWUudmFsdWUsIGNvbnRleHQpO1xuICAgIH1cbiAgICBzYWZlR2VuZXJhdGVGb3JJbmRleChtcm5nLCBpZHgsIGJpYXNGYWN0b3IpIHtcbiAgICAgICAgKyt0aGlzLmNvbnRleHQuZGVwdGg7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IHRoaXMud2FyYnNbaWR4XS5hcmJpdHJhcnkuZ2VuZXJhdGUobXJuZywgYmlhc0ZhY3Rvcik7XG4gICAgICAgICAgICBjb25zdCBjbG9uZWRNcm5nRm9yRmFsbGJhY2tGaXJzdCA9IHRoaXMubXVzdEZhbGxiYWNrVG9GaXJzdEluU2hyaW5rKGlkeCkgPyBtcm5nLmNsb25lKCkgOiBudWxsO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubWFwSW50b05leHRWYWx1ZShpZHgsIHZhbHVlLCBjbG9uZWRNcm5nRm9yRmFsbGJhY2tGaXJzdCwgYmlhc0ZhY3Rvcik7XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICAtLXRoaXMuY29udGV4dC5kZXB0aDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBtdXN0R2VuZXJhdGVGaXJzdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29uc3RyYWludHMubWF4RGVwdGggIT09IHVuZGVmaW5lZCAmJiB0aGlzLmNvbnN0cmFpbnRzLm1heERlcHRoIDw9IHRoaXMuY29udGV4dC5kZXB0aDtcbiAgICB9XG4gICAgbXVzdEZhbGxiYWNrVG9GaXJzdEluU2hyaW5rKGlkeCkge1xuICAgICAgICByZXR1cm4gaWR4ICE9PSAwICYmICEhdGhpcy5jb25zdHJhaW50cy53aXRoQ3Jvc3NTaHJpbmsgJiYgdGhpcy53YXJic1swXS53ZWlnaHQgIT09IDA7XG4gICAgfVxuICAgIGNvbXB1dGVOZWdEZXB0aEJlbmVmaXQoKSB7XG4gICAgICAgIGNvbnN0IGRlcHRoRmFjdG9yID0gdGhpcy5jb25zdHJhaW50cy5kZXB0aEZhY3RvcjtcbiAgICAgICAgaWYgKGRlcHRoRmFjdG9yID09PSB1bmRlZmluZWQgfHwgZGVwdGhGYWN0b3IgPD0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZGVwdGhCZW5lZml0ID0gTWF0aC5mbG9vcihNYXRoLnBvdygxICsgZGVwdGhGYWN0b3IsIHRoaXMuY29udGV4dC5kZXB0aCkpIC0gMTtcbiAgICAgICAgcmV0dXJuIC1NYXRoLm1pbih0aGlzLndhcmJzWzBdLndlaWdodCAqIGRlcHRoQmVuZWZpdCwgTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIpIHx8IDA7XG4gICAgfVxufVxuZXhwb3J0cy5GcmVxdWVuY3lBcmJpdHJhcnkgPSBGcmVxdWVuY3lBcmJpdHJhcnk7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuSW50ZWdlckFyYml0cmFyeSA9IHZvaWQgMDtcbmNvbnN0IE5leHRBcmJpdHJhcnlfMSA9IHJlcXVpcmUoXCIuLi8uLi9jaGVjay9hcmJpdHJhcnkvZGVmaW5pdGlvbi9OZXh0QXJiaXRyYXJ5XCIpO1xuY29uc3QgTmV4dFZhbHVlXzEgPSByZXF1aXJlKFwiLi4vLi4vY2hlY2svYXJiaXRyYXJ5L2RlZmluaXRpb24vTmV4dFZhbHVlXCIpO1xuY29uc3QgU3RyZWFtXzEgPSByZXF1aXJlKFwiLi4vLi4vc3RyZWFtL1N0cmVhbVwiKTtcbmNvbnN0IEJpYXNOdW1lcmljUmFuZ2VfMSA9IHJlcXVpcmUoXCIuL2hlbHBlcnMvQmlhc051bWVyaWNSYW5nZVwiKTtcbmNvbnN0IFNocmlua0ludGVnZXJfMSA9IHJlcXVpcmUoXCIuL2hlbHBlcnMvU2hyaW5rSW50ZWdlclwiKTtcbmNsYXNzIEludGVnZXJBcmJpdHJhcnkgZXh0ZW5kcyBOZXh0QXJiaXRyYXJ5XzEuTmV4dEFyYml0cmFyeSB7XG4gICAgY29uc3RydWN0b3IobWluLCBtYXgpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5taW4gPSBtaW47XG4gICAgICAgIHRoaXMubWF4ID0gbWF4O1xuICAgIH1cbiAgICBnZW5lcmF0ZShtcm5nLCBiaWFzRmFjdG9yKSB7XG4gICAgICAgIGNvbnN0IHJhbmdlID0gdGhpcy5jb21wdXRlR2VuZXJhdGVSYW5nZShtcm5nLCBiaWFzRmFjdG9yKTtcbiAgICAgICAgcmV0dXJuIG5ldyBOZXh0VmFsdWVfMS5OZXh0VmFsdWUobXJuZy5uZXh0SW50KHJhbmdlLm1pbiwgcmFuZ2UubWF4KSwgdW5kZWZpbmVkKTtcbiAgICB9XG4gICAgY2FuU2hyaW5rV2l0aG91dENvbnRleHQodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInICYmXG4gICAgICAgICAgICBOdW1iZXIuaXNJbnRlZ2VyKHZhbHVlKSAmJlxuICAgICAgICAgICAgIU9iamVjdC5pcyh2YWx1ZSwgLTApICYmXG4gICAgICAgICAgICB0aGlzLm1pbiA8PSB2YWx1ZSAmJlxuICAgICAgICAgICAgdmFsdWUgPD0gdGhpcy5tYXgpO1xuICAgIH1cbiAgICBzaHJpbmsoY3VycmVudCwgY29udGV4dCkge1xuICAgICAgICBpZiAoIUludGVnZXJBcmJpdHJhcnkuaXNWYWxpZENvbnRleHQoY3VycmVudCwgY29udGV4dCkpIHtcbiAgICAgICAgICAgIGNvbnN0IHRhcmdldCA9IHRoaXMuZGVmYXVsdFRhcmdldCgpO1xuICAgICAgICAgICAgcmV0dXJuIFNocmlua0ludGVnZXJfMS5zaHJpbmtJbnRlZ2VyKGN1cnJlbnQsIHRhcmdldCwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuaXNMYXN0Q2hhbmNlVHJ5KGN1cnJlbnQsIGNvbnRleHQpKSB7XG4gICAgICAgICAgICByZXR1cm4gU3RyZWFtXzEuU3RyZWFtLm9mKG5ldyBOZXh0VmFsdWVfMS5OZXh0VmFsdWUoY29udGV4dCwgdW5kZWZpbmVkKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFNocmlua0ludGVnZXJfMS5zaHJpbmtJbnRlZ2VyKGN1cnJlbnQsIGNvbnRleHQsIGZhbHNlKTtcbiAgICB9XG4gICAgZGVmYXVsdFRhcmdldCgpIHtcbiAgICAgICAgaWYgKHRoaXMubWluIDw9IDAgJiYgdGhpcy5tYXggPj0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMubWluIDwgMCA/IHRoaXMubWF4IDogdGhpcy5taW47XG4gICAgfVxuICAgIGNvbXB1dGVHZW5lcmF0ZVJhbmdlKG1ybmcsIGJpYXNGYWN0b3IpIHtcbiAgICAgICAgaWYgKGJpYXNGYWN0b3IgPT09IHVuZGVmaW5lZCB8fCBtcm5nLm5leHRJbnQoMSwgYmlhc0ZhY3RvcikgIT09IDEpIHtcbiAgICAgICAgICAgIHJldHVybiB7IG1pbjogdGhpcy5taW4sIG1heDogdGhpcy5tYXggfTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByYW5nZXMgPSBCaWFzTnVtZXJpY1JhbmdlXzEuYmlhc051bWVyaWNSYW5nZSh0aGlzLm1pbiwgdGhpcy5tYXgsIEJpYXNOdW1lcmljUmFuZ2VfMS5pbnRlZ2VyTG9nTGlrZSk7XG4gICAgICAgIGlmIChyYW5nZXMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICByZXR1cm4gcmFuZ2VzWzBdO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGlkID0gbXJuZy5uZXh0SW50KC0yICogKHJhbmdlcy5sZW5ndGggLSAxKSwgcmFuZ2VzLmxlbmd0aCAtIDIpO1xuICAgICAgICByZXR1cm4gaWQgPCAwID8gcmFuZ2VzWzBdIDogcmFuZ2VzW2lkICsgMV07XG4gICAgfVxuICAgIGlzTGFzdENoYW5jZVRyeShjdXJyZW50LCBjb250ZXh0KSB7XG4gICAgICAgIGlmIChjdXJyZW50ID4gMClcbiAgICAgICAgICAgIHJldHVybiBjdXJyZW50ID09PSBjb250ZXh0ICsgMSAmJiBjdXJyZW50ID4gdGhpcy5taW47XG4gICAgICAgIGlmIChjdXJyZW50IDwgMClcbiAgICAgICAgICAgIHJldHVybiBjdXJyZW50ID09PSBjb250ZXh0IC0gMSAmJiBjdXJyZW50IDwgdGhpcy5tYXg7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgc3RhdGljIGlzVmFsaWRDb250ZXh0KGN1cnJlbnQsIGNvbnRleHQpIHtcbiAgICAgICAgaWYgKGNvbnRleHQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgY29udGV4dCAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBjb250ZXh0IHR5cGUgcGFzc2VkIHRvIEludGVnZXJBcmJpdHJhcnkgKCMxKWApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb250ZXh0ICE9PSAwICYmIE1hdGguc2lnbihjdXJyZW50KSAhPT0gTWF0aC5zaWduKGNvbnRleHQpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgY29udGV4dCB2YWx1ZSBwYXNzZWQgdG8gSW50ZWdlckFyYml0cmFyeSAoIzIpYCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxufVxuZXhwb3J0cy5JbnRlZ2VyQXJiaXRyYXJ5ID0gSW50ZWdlckFyYml0cmFyeTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5MYXp5QXJiaXRyYXJ5ID0gdm9pZCAwO1xuY29uc3QgTmV4dEFyYml0cmFyeV8xID0gcmVxdWlyZShcIi4uLy4uL2NoZWNrL2FyYml0cmFyeS9kZWZpbml0aW9uL05leHRBcmJpdHJhcnlcIik7XG5jbGFzcyBMYXp5QXJiaXRyYXJ5IGV4dGVuZHMgTmV4dEFyYml0cmFyeV8xLk5leHRBcmJpdHJhcnkge1xuICAgIGNvbnN0cnVjdG9yKG5hbWUpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgdGhpcy51bmRlcmx5aW5nID0gbnVsbDtcbiAgICB9XG4gICAgZ2VuZXJhdGUobXJuZywgYmlhc0ZhY3Rvcikge1xuICAgICAgICBpZiAoIXRoaXMudW5kZXJseWluZykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBMYXp5IGFyYml0cmFyeSAke0pTT04uc3RyaW5naWZ5KHRoaXMubmFtZSl9IG5vdCBjb3JyZWN0bHkgaW5pdGlhbGl6ZWRgKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy51bmRlcmx5aW5nLmdlbmVyYXRlKG1ybmcsIGJpYXNGYWN0b3IpO1xuICAgIH1cbiAgICBjYW5TaHJpbmtXaXRob3V0Q29udGV4dCh2YWx1ZSkge1xuICAgICAgICBpZiAoIXRoaXMudW5kZXJseWluZykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBMYXp5IGFyYml0cmFyeSAke0pTT04uc3RyaW5naWZ5KHRoaXMubmFtZSl9IG5vdCBjb3JyZWN0bHkgaW5pdGlhbGl6ZWRgKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy51bmRlcmx5aW5nLmNhblNocmlua1dpdGhvdXRDb250ZXh0KHZhbHVlKTtcbiAgICB9XG4gICAgc2hyaW5rKHZhbHVlLCBjb250ZXh0KSB7XG4gICAgICAgIGlmICghdGhpcy51bmRlcmx5aW5nKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYExhenkgYXJiaXRyYXJ5ICR7SlNPTi5zdHJpbmdpZnkodGhpcy5uYW1lKX0gbm90IGNvcnJlY3RseSBpbml0aWFsaXplZGApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnVuZGVybHlpbmcuc2hyaW5rKHZhbHVlLCBjb250ZXh0KTtcbiAgICB9XG59XG5leHBvcnRzLkxhenlBcmJpdHJhcnkgPSBMYXp5QXJiaXRyYXJ5O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLk1peGVkQ2FzZUFyYml0cmFyeSA9IGV4cG9ydHMuY29tcHV0ZU5leHRGbGFncyA9IGV4cG9ydHMuY291bnRUb2dnbGVkQml0cyA9IHZvaWQgMDtcbmNvbnN0IFN0cmVhbV8xID0gcmVxdWlyZShcIi4uLy4uL3N0cmVhbS9TdHJlYW1cIik7XG5jb25zdCBiaWdVaW50Tl8xID0gcmVxdWlyZShcIi4uL2JpZ1VpbnROXCIpO1xuY29uc3QgTmV4dEFyYml0cmFyeV8xID0gcmVxdWlyZShcIi4uLy4uL2NoZWNrL2FyYml0cmFyeS9kZWZpbml0aW9uL05leHRBcmJpdHJhcnlcIik7XG5jb25zdCBDb252ZXJ0ZXJzXzEgPSByZXF1aXJlKFwiLi4vLi4vY2hlY2svYXJiaXRyYXJ5L2RlZmluaXRpb24vQ29udmVydGVyc1wiKTtcbmNvbnN0IE5leHRWYWx1ZV8xID0gcmVxdWlyZShcIi4uLy4uL2NoZWNrL2FyYml0cmFyeS9kZWZpbml0aW9uL05leHRWYWx1ZVwiKTtcbmNvbnN0IExhenlJdGVyYWJsZUl0ZXJhdG9yXzEgPSByZXF1aXJlKFwiLi4vLi4vc3RyZWFtL0xhenlJdGVyYWJsZUl0ZXJhdG9yXCIpO1xuZnVuY3Rpb24gY291bnRUb2dnbGVkQml0cyhuKSB7XG4gICAgbGV0IGNvdW50ID0gMDtcbiAgICB3aGlsZSAobiA+IEJpZ0ludCgwKSkge1xuICAgICAgICBpZiAobiAmIEJpZ0ludCgxKSlcbiAgICAgICAgICAgICsrY291bnQ7XG4gICAgICAgIG4gPj49IEJpZ0ludCgxKTtcbiAgICB9XG4gICAgcmV0dXJuIGNvdW50O1xufVxuZXhwb3J0cy5jb3VudFRvZ2dsZWRCaXRzID0gY291bnRUb2dnbGVkQml0cztcbmZ1bmN0aW9uIGNvbXB1dGVOZXh0RmxhZ3MoZmxhZ3MsIG5leHRTaXplKSB7XG4gICAgY29uc3QgYWxsb3dlZE1hc2sgPSAoQmlnSW50KDEpIDw8IEJpZ0ludChuZXh0U2l6ZSkpIC0gQmlnSW50KDEpO1xuICAgIGNvbnN0IHByZXNlcnZlZEZsYWdzID0gZmxhZ3MgJiBhbGxvd2VkTWFzaztcbiAgICBsZXQgbnVtTWlzc2luZ0ZsYWdzID0gY291bnRUb2dnbGVkQml0cyhmbGFncyAtIHByZXNlcnZlZEZsYWdzKTtcbiAgICBsZXQgbkZsYWdzID0gcHJlc2VydmVkRmxhZ3M7XG4gICAgZm9yIChsZXQgbWFzayA9IEJpZ0ludCgxKTsgbWFzayA8PSBhbGxvd2VkTWFzayAmJiBudW1NaXNzaW5nRmxhZ3MgIT09IDA7IG1hc2sgPDw9IEJpZ0ludCgxKSkge1xuICAgICAgICBpZiAoIShuRmxhZ3MgJiBtYXNrKSkge1xuICAgICAgICAgICAgbkZsYWdzIHw9IG1hc2s7XG4gICAgICAgICAgICAtLW51bU1pc3NpbmdGbGFncztcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbkZsYWdzO1xufVxuZXhwb3J0cy5jb21wdXRlTmV4dEZsYWdzID0gY29tcHV0ZU5leHRGbGFncztcbmNsYXNzIE1peGVkQ2FzZUFyYml0cmFyeSBleHRlbmRzIE5leHRBcmJpdHJhcnlfMS5OZXh0QXJiaXRyYXJ5IHtcbiAgICBjb25zdHJ1Y3RvcihzdHJpbmdBcmIsIHRvZ2dsZUNhc2UpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5zdHJpbmdBcmIgPSBzdHJpbmdBcmI7XG4gICAgICAgIHRoaXMudG9nZ2xlQ2FzZSA9IHRvZ2dsZUNhc2U7XG4gICAgfVxuICAgIGNvbXB1dGVUb2dnbGVQb3NpdGlvbnMoY2hhcnMpIHtcbiAgICAgICAgY29uc3QgcG9zaXRpb25zID0gW107XG4gICAgICAgIGZvciAobGV0IGlkeCA9IDA7IGlkeCAhPT0gY2hhcnMubGVuZ3RoOyArK2lkeCkge1xuICAgICAgICAgICAgaWYgKHRoaXMudG9nZ2xlQ2FzZShjaGFyc1tpZHhdKSAhPT0gY2hhcnNbaWR4XSlcbiAgICAgICAgICAgICAgICBwb3NpdGlvbnMucHVzaChpZHgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwb3NpdGlvbnM7XG4gICAgfVxuICAgIGFwcGx5RmxhZ3NPbkNoYXJzKGNoYXJzLCBmbGFncywgdG9nZ2xlUG9zaXRpb25zKSB7XG4gICAgICAgIGZvciAobGV0IGlkeCA9IDAsIG1hc2sgPSBCaWdJbnQoMSk7IGlkeCAhPT0gdG9nZ2xlUG9zaXRpb25zLmxlbmd0aDsgKytpZHgsIG1hc2sgPDw9IEJpZ0ludCgxKSkge1xuICAgICAgICAgICAgaWYgKGZsYWdzICYgbWFzaylcbiAgICAgICAgICAgICAgICBjaGFyc1t0b2dnbGVQb3NpdGlvbnNbaWR4XV0gPSB0aGlzLnRvZ2dsZUNhc2UoY2hhcnNbdG9nZ2xlUG9zaXRpb25zW2lkeF1dKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2hhcnM7XG4gICAgfVxuICAgIGJ1aWxkQ29udGV4dEZvcihyYXdTdHJpbmdOZXh0VmFsdWUsIGZsYWdzTmV4dFZhbHVlKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICByYXdTdHJpbmc6IHJhd1N0cmluZ05leHRWYWx1ZS52YWx1ZSxcbiAgICAgICAgICAgIHJhd1N0cmluZ0NvbnRleHQ6IHJhd1N0cmluZ05leHRWYWx1ZS5jb250ZXh0LFxuICAgICAgICAgICAgZmxhZ3M6IGZsYWdzTmV4dFZhbHVlLnZhbHVlLFxuICAgICAgICAgICAgZmxhZ3NDb250ZXh0OiBmbGFnc05leHRWYWx1ZS5jb250ZXh0LFxuICAgICAgICB9O1xuICAgIH1cbiAgICBnZW5lcmF0ZShtcm5nLCBiaWFzRmFjdG9yKSB7XG4gICAgICAgIGNvbnN0IHJhd1N0cmluZ05leHRWYWx1ZSA9IHRoaXMuc3RyaW5nQXJiLmdlbmVyYXRlKG1ybmcsIGJpYXNGYWN0b3IpO1xuICAgICAgICBjb25zdCBjaGFycyA9IFsuLi5yYXdTdHJpbmdOZXh0VmFsdWUudmFsdWVdO1xuICAgICAgICBjb25zdCB0b2dnbGVQb3NpdGlvbnMgPSB0aGlzLmNvbXB1dGVUb2dnbGVQb3NpdGlvbnMoY2hhcnMpO1xuICAgICAgICBjb25zdCBmbGFnc0FyYiA9IENvbnZlcnRlcnNfMS5jb252ZXJ0VG9OZXh0KGJpZ1VpbnROXzEuYmlnVWludE4odG9nZ2xlUG9zaXRpb25zLmxlbmd0aCkpO1xuICAgICAgICBjb25zdCBmbGFnc05leHRWYWx1ZSA9IGZsYWdzQXJiLmdlbmVyYXRlKG1ybmcsIHVuZGVmaW5lZCk7XG4gICAgICAgIHRoaXMuYXBwbHlGbGFnc09uQ2hhcnMoY2hhcnMsIGZsYWdzTmV4dFZhbHVlLnZhbHVlLCB0b2dnbGVQb3NpdGlvbnMpO1xuICAgICAgICByZXR1cm4gbmV3IE5leHRWYWx1ZV8xLk5leHRWYWx1ZShjaGFycy5qb2luKCcnKSwgdGhpcy5idWlsZENvbnRleHRGb3IocmF3U3RyaW5nTmV4dFZhbHVlLCBmbGFnc05leHRWYWx1ZSkpO1xuICAgIH1cbiAgICBjYW5TaHJpbmtXaXRob3V0Q29udGV4dCh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHNocmluayhfdmFsdWUsIGNvbnRleHQpIHtcbiAgICAgICAgaWYgKGNvbnRleHQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIFN0cmVhbV8xLlN0cmVhbS5uaWwoKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjb250ZXh0U2FmZSA9IGNvbnRleHQ7XG4gICAgICAgIGNvbnN0IHJhd1N0cmluZyA9IGNvbnRleHRTYWZlLnJhd1N0cmluZztcbiAgICAgICAgY29uc3QgZmxhZ3MgPSBjb250ZXh0U2FmZS5mbGFncztcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RyaW5nQXJiXG4gICAgICAgICAgICAuc2hyaW5rKHJhd1N0cmluZywgY29udGV4dFNhZmUucmF3U3RyaW5nQ29udGV4dClcbiAgICAgICAgICAgIC5tYXAoKG5SYXdTdHJpbmdOZXh0VmFsdWUpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG5DaGFycyA9IFsuLi5uUmF3U3RyaW5nTmV4dFZhbHVlLnZhbHVlXTtcbiAgICAgICAgICAgIGNvbnN0IG5Ub2dnbGVQb3NpdGlvbnMgPSB0aGlzLmNvbXB1dGVUb2dnbGVQb3NpdGlvbnMobkNoYXJzKTtcbiAgICAgICAgICAgIGNvbnN0IG5GbGFncyA9IGNvbXB1dGVOZXh0RmxhZ3MoZmxhZ3MsIG5Ub2dnbGVQb3NpdGlvbnMubGVuZ3RoKTtcbiAgICAgICAgICAgIHRoaXMuYXBwbHlGbGFnc09uQ2hhcnMobkNoYXJzLCBuRmxhZ3MsIG5Ub2dnbGVQb3NpdGlvbnMpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBOZXh0VmFsdWVfMS5OZXh0VmFsdWUobkNoYXJzLmpvaW4oJycpLCB0aGlzLmJ1aWxkQ29udGV4dEZvcihuUmF3U3RyaW5nTmV4dFZhbHVlLCBuZXcgTmV4dFZhbHVlXzEuTmV4dFZhbHVlKG5GbGFncywgdW5kZWZpbmVkKSkpO1xuICAgICAgICB9KVxuICAgICAgICAgICAgLmpvaW4oTGF6eUl0ZXJhYmxlSXRlcmF0b3JfMS5tYWtlTGF6eSgoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBjaGFycyA9IFsuLi5yYXdTdHJpbmddO1xuICAgICAgICAgICAgY29uc3QgdG9nZ2xlUG9zaXRpb25zID0gdGhpcy5jb21wdXRlVG9nZ2xlUG9zaXRpb25zKGNoYXJzKTtcbiAgICAgICAgICAgIHJldHVybiBDb252ZXJ0ZXJzXzEuY29udmVydFRvTmV4dChiaWdVaW50Tl8xLmJpZ1VpbnROKHRvZ2dsZVBvc2l0aW9ucy5sZW5ndGgpKVxuICAgICAgICAgICAgICAgIC5zaHJpbmsoZmxhZ3MsIGNvbnRleHRTYWZlLmZsYWdzQ29udGV4dClcbiAgICAgICAgICAgICAgICAubWFwKChuRmxhZ3NOZXh0VmFsdWUpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBuQ2hhcnMgPSBjaGFycy5zbGljZSgpO1xuICAgICAgICAgICAgICAgIHRoaXMuYXBwbHlGbGFnc09uQ2hhcnMobkNoYXJzLCBuRmxhZ3NOZXh0VmFsdWUudmFsdWUsIHRvZ2dsZVBvc2l0aW9ucyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBOZXh0VmFsdWVfMS5OZXh0VmFsdWUobkNoYXJzLmpvaW4oJycpLCB0aGlzLmJ1aWxkQ29udGV4dEZvcihuZXcgTmV4dFZhbHVlXzEuTmV4dFZhbHVlKHJhd1N0cmluZywgY29udGV4dFNhZmUucmF3U3RyaW5nQ29udGV4dCksIG5GbGFnc05leHRWYWx1ZSkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pKTtcbiAgICB9XG59XG5leHBvcnRzLk1peGVkQ2FzZUFyYml0cmFyeSA9IE1peGVkQ2FzZUFyYml0cmFyeTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5TY2hlZHVsZXJBcmJpdHJhcnkgPSB2b2lkIDA7XG5jb25zdCBOZXh0QXJiaXRyYXJ5XzEgPSByZXF1aXJlKFwiLi4vLi4vY2hlY2svYXJiaXRyYXJ5L2RlZmluaXRpb24vTmV4dEFyYml0cmFyeVwiKTtcbmNvbnN0IE5leHRWYWx1ZV8xID0gcmVxdWlyZShcIi4uLy4uL2NoZWNrL2FyYml0cmFyeS9kZWZpbml0aW9uL05leHRWYWx1ZVwiKTtcbmNvbnN0IFN0cmVhbV8xID0gcmVxdWlyZShcIi4uLy4uL3N0cmVhbS9TdHJlYW1cIik7XG5jb25zdCBTY2hlZHVsZXJJbXBsZW1fMSA9IHJlcXVpcmUoXCIuL2ltcGxlbWVudGF0aW9ucy9TY2hlZHVsZXJJbXBsZW1cIik7XG5mdW5jdGlvbiBidWlsZE5leHRUYXNrSW5kZXgobXJuZykge1xuICAgIGNvbnN0IGNsb25lZE1ybmcgPSBtcm5nLmNsb25lKCk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgY2xvbmU6ICgpID0+IGJ1aWxkTmV4dFRhc2tJbmRleChjbG9uZWRNcm5nKSxcbiAgICAgICAgbmV4dFRhc2tJbmRleDogKHNjaGVkdWxlZFRhc2tzKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gbXJuZy5uZXh0SW50KDAsIHNjaGVkdWxlZFRhc2tzLmxlbmd0aCAtIDEpO1xuICAgICAgICB9LFxuICAgIH07XG59XG5jbGFzcyBTY2hlZHVsZXJBcmJpdHJhcnkgZXh0ZW5kcyBOZXh0QXJiaXRyYXJ5XzEuTmV4dEFyYml0cmFyeSB7XG4gICAgY29uc3RydWN0b3IoYWN0KSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuYWN0ID0gYWN0O1xuICAgIH1cbiAgICBnZW5lcmF0ZShtcm5nLCBfYmlhc0ZhY3Rvcikge1xuICAgICAgICByZXR1cm4gbmV3IE5leHRWYWx1ZV8xLk5leHRWYWx1ZShuZXcgU2NoZWR1bGVySW1wbGVtXzEuU2NoZWR1bGVySW1wbGVtKHRoaXMuYWN0LCBidWlsZE5leHRUYXNrSW5kZXgobXJuZy5jbG9uZSgpKSksIHVuZGVmaW5lZCk7XG4gICAgfVxuICAgIGNhblNocmlua1dpdGhvdXRDb250ZXh0KHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgc2hyaW5rKF92YWx1ZSwgX2NvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIFN0cmVhbV8xLlN0cmVhbS5uaWwoKTtcbiAgICB9XG59XG5leHBvcnRzLlNjaGVkdWxlckFyYml0cmFyeSA9IFNjaGVkdWxlckFyYml0cmFyeTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5TdHJlYW1BcmJpdHJhcnkgPSB2b2lkIDA7XG5jb25zdCBOZXh0QXJiaXRyYXJ5XzEgPSByZXF1aXJlKFwiLi4vLi4vY2hlY2svYXJiaXRyYXJ5L2RlZmluaXRpb24vTmV4dEFyYml0cmFyeVwiKTtcbmNvbnN0IE5leHRWYWx1ZV8xID0gcmVxdWlyZShcIi4uLy4uL2NoZWNrL2FyYml0cmFyeS9kZWZpbml0aW9uL05leHRWYWx1ZVwiKTtcbmNvbnN0IHN5bWJvbHNfMSA9IHJlcXVpcmUoXCIuLi8uLi9jaGVjay9zeW1ib2xzXCIpO1xuY29uc3QgU3RyZWFtXzEgPSByZXF1aXJlKFwiLi4vLi4vc3RyZWFtL1N0cmVhbVwiKTtcbmNvbnN0IHN0cmluZ2lmeV8xID0gcmVxdWlyZShcIi4uLy4uL3V0aWxzL3N0cmluZ2lmeVwiKTtcbmZ1bmN0aW9uIHByZXR0eVByaW50KHNlZW5WYWx1ZXNTdHJpbmdzKSB7XG4gICAgcmV0dXJuIGBTdHJlYW0oJHtzZWVuVmFsdWVzU3RyaW5ncy5qb2luKCcsJyl94oCmKWA7XG59XG5jbGFzcyBTdHJlYW1BcmJpdHJhcnkgZXh0ZW5kcyBOZXh0QXJiaXRyYXJ5XzEuTmV4dEFyYml0cmFyeSB7XG4gICAgY29uc3RydWN0b3IoYXJiKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuYXJiID0gYXJiO1xuICAgIH1cbiAgICBnZW5lcmF0ZShtcm5nLCBiaWFzRmFjdG9yKSB7XG4gICAgICAgIGNvbnN0IGFwcGxpZWRCaWFzRmFjdG9yID0gYmlhc0ZhY3RvciAhPT0gdW5kZWZpbmVkICYmIG1ybmcubmV4dEludCgxLCBiaWFzRmFjdG9yKSA9PT0gMSA/IGJpYXNGYWN0b3IgOiB1bmRlZmluZWQ7XG4gICAgICAgIGNvbnN0IGVucmljaGVkUHJvZHVjZXIgPSAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBzZWVuVmFsdWVzID0gW107XG4gICAgICAgICAgICBjb25zdCBnID0gZnVuY3Rpb24qIChhcmIsIGNsb25lZE1ybmcpIHtcbiAgICAgICAgICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZSA9IGFyYi5nZW5lcmF0ZShjbG9uZWRNcm5nLCBhcHBsaWVkQmlhc0ZhY3RvcikudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIHNlZW5WYWx1ZXMucHVzaCh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIHlpZWxkIHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjb25zdCBzID0gbmV3IFN0cmVhbV8xLlN0cmVhbShnKHRoaXMuYXJiLCBtcm5nLmNsb25lKCkpKTtcbiAgICAgICAgICAgIHJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhzLCB7XG4gICAgICAgICAgICAgICAgdG9TdHJpbmc6IHsgdmFsdWU6ICgpID0+IHByZXR0eVByaW50KHNlZW5WYWx1ZXMubWFwKHN0cmluZ2lmeV8xLnN0cmluZ2lmeSkpIH0sXG4gICAgICAgICAgICAgICAgW3N0cmluZ2lmeV8xLnRvU3RyaW5nTWV0aG9kXTogeyB2YWx1ZTogKCkgPT4gcHJldHR5UHJpbnQoc2VlblZhbHVlcy5tYXAoc3RyaW5naWZ5XzEuc3RyaW5naWZ5KSkgfSxcbiAgICAgICAgICAgICAgICBbc3RyaW5naWZ5XzEuYXN5bmNUb1N0cmluZ01ldGhvZF06IHsgdmFsdWU6IGFzeW5jICgpID0+IHByZXR0eVByaW50KGF3YWl0IFByb21pc2UuYWxsKHNlZW5WYWx1ZXMubWFwKHN0cmluZ2lmeV8xLmFzeW5jU3RyaW5naWZ5KSkpIH0sXG4gICAgICAgICAgICAgICAgW3N5bWJvbHNfMS5jbG9uZU1ldGhvZF06IHsgdmFsdWU6IGVucmljaGVkUHJvZHVjZXIsIGVudW1lcmFibGU6IHRydWUgfSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gbmV3IE5leHRWYWx1ZV8xLk5leHRWYWx1ZShlbnJpY2hlZFByb2R1Y2VyKCksIHVuZGVmaW5lZCk7XG4gICAgfVxuICAgIGNhblNocmlua1dpdGhvdXRDb250ZXh0KHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgc2hyaW5rKF92YWx1ZSwgX2NvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIFN0cmVhbV8xLlN0cmVhbS5uaWwoKTtcbiAgICB9XG59XG5leHBvcnRzLlN0cmVhbUFyYml0cmFyeSA9IFN0cmVhbUFyYml0cmFyeTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5UdXBsZUFyYml0cmFyeSA9IHZvaWQgMDtcbmNvbnN0IFN0cmVhbV8xID0gcmVxdWlyZShcIi4uLy4uL3N0cmVhbS9TdHJlYW1cIik7XG5jb25zdCBzeW1ib2xzXzEgPSByZXF1aXJlKFwiLi4vLi4vY2hlY2svc3ltYm9sc1wiKTtcbmNvbnN0IE5leHRBcmJpdHJhcnlfMSA9IHJlcXVpcmUoXCIuLi8uLi9jaGVjay9hcmJpdHJhcnkvZGVmaW5pdGlvbi9OZXh0QXJiaXRyYXJ5XCIpO1xuY29uc3QgTmV4dFZhbHVlXzEgPSByZXF1aXJlKFwiLi4vLi4vY2hlY2svYXJiaXRyYXJ5L2RlZmluaXRpb24vTmV4dFZhbHVlXCIpO1xuY2xhc3MgVHVwbGVBcmJpdHJhcnkgZXh0ZW5kcyBOZXh0QXJiaXRyYXJ5XzEuTmV4dEFyYml0cmFyeSB7XG4gICAgY29uc3RydWN0b3IoYXJicykge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmFyYnMgPSBhcmJzO1xuICAgICAgICBmb3IgKGxldCBpZHggPSAwOyBpZHggIT09IGFyYnMubGVuZ3RoOyArK2lkeCkge1xuICAgICAgICAgICAgY29uc3QgYXJiID0gYXJic1tpZHhdO1xuICAgICAgICAgICAgaWYgKGFyYiA9PSBudWxsIHx8IGFyYi5nZW5lcmF0ZSA9PSBudWxsKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBwYXJhbWV0ZXIgZW5jb3VudGVyZWQgYXQgaW5kZXggJHtpZHh9OiBleHBlY3RpbmcgYW4gQXJiaXRyYXJ5YCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3RhdGljIG1ha2VJdENsb25lYWJsZSh2cywgdmFsdWVzKSB7XG4gICAgICAgIHJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkodnMsIHN5bWJvbHNfMS5jbG9uZU1ldGhvZCwge1xuICAgICAgICAgICAgdmFsdWU6ICgpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBjbG9uZWQgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpZHggPSAwOyBpZHggIT09IHZhbHVlcy5sZW5ndGg7ICsraWR4KSB7XG4gICAgICAgICAgICAgICAgICAgIGNsb25lZC5wdXNoKHZhbHVlc1tpZHhdLnZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgVHVwbGVBcmJpdHJhcnkubWFrZUl0Q2xvbmVhYmxlKGNsb25lZCwgdmFsdWVzKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2xvbmVkO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHN0YXRpYyB3cmFwcGVyKHZhbHVlcykge1xuICAgICAgICBsZXQgY2xvbmVhYmxlID0gZmFsc2U7XG4gICAgICAgIGNvbnN0IHZzID0gW107XG4gICAgICAgIGNvbnN0IGN0eHMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaWR4ID0gMDsgaWR4ICE9PSB2YWx1ZXMubGVuZ3RoOyArK2lkeCkge1xuICAgICAgICAgICAgY29uc3QgdiA9IHZhbHVlc1tpZHhdO1xuICAgICAgICAgICAgY2xvbmVhYmxlID0gY2xvbmVhYmxlIHx8IHYuaGFzVG9CZUNsb25lZDtcbiAgICAgICAgICAgIHZzLnB1c2godi52YWx1ZSk7XG4gICAgICAgICAgICBjdHhzLnB1c2godi5jb250ZXh0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2xvbmVhYmxlKSB7XG4gICAgICAgICAgICBUdXBsZUFyYml0cmFyeS5tYWtlSXRDbG9uZWFibGUodnMsIHZhbHVlcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBOZXh0VmFsdWVfMS5OZXh0VmFsdWUodnMsIGN0eHMpO1xuICAgIH1cbiAgICBnZW5lcmF0ZShtcm5nLCBiaWFzRmFjdG9yKSB7XG4gICAgICAgIHJldHVybiBUdXBsZUFyYml0cmFyeS53cmFwcGVyKHRoaXMuYXJicy5tYXAoKGEpID0+IGEuZ2VuZXJhdGUobXJuZywgYmlhc0ZhY3RvcikpKTtcbiAgICB9XG4gICAgY2FuU2hyaW5rV2l0aG91dENvbnRleHQodmFsdWUpIHtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHZhbHVlKSB8fCB2YWx1ZS5sZW5ndGggIT09IHRoaXMuYXJicy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4ICE9PSB0aGlzLmFyYnMubGVuZ3RoOyArK2luZGV4KSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuYXJic1tpbmRleF0uY2FuU2hyaW5rV2l0aG91dENvbnRleHQodmFsdWVbaW5kZXhdKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgc2hyaW5rKHZhbHVlLCBjb250ZXh0KSB7XG4gICAgICAgIGxldCBzID0gU3RyZWFtXzEuU3RyZWFtLm5pbCgpO1xuICAgICAgICBjb25zdCBzYWZlQ29udGV4dCA9IEFycmF5LmlzQXJyYXkoY29udGV4dCkgPyBjb250ZXh0IDogW107XG4gICAgICAgIGZvciAobGV0IGlkeCA9IDA7IGlkeCAhPT0gdGhpcy5hcmJzLmxlbmd0aDsgKytpZHgpIHtcbiAgICAgICAgICAgIGNvbnN0IHNocmlua3NGb3JJbmRleCA9IHRoaXMuYXJic1tpZHhdXG4gICAgICAgICAgICAgICAgLnNocmluayh2YWx1ZVtpZHhdLCBzYWZlQ29udGV4dFtpZHhdKVxuICAgICAgICAgICAgICAgIC5tYXAoKHYpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBuZXh0VmFsdWVzID0gdmFsdWUubWFwKCh2LCBpZHgpID0+IG5ldyBOZXh0VmFsdWVfMS5OZXh0VmFsdWUoc3ltYm9sc18xLmNsb25lSWZOZWVkZWQodiksIHNhZmVDb250ZXh0W2lkeF0pKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV4dFZhbHVlc1xuICAgICAgICAgICAgICAgICAgICAuc2xpY2UoMCwgaWR4KVxuICAgICAgICAgICAgICAgICAgICAuY29uY2F0KFt2XSlcbiAgICAgICAgICAgICAgICAgICAgLmNvbmNhdChuZXh0VmFsdWVzLnNsaWNlKGlkeCArIDEpKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLm1hcCgodmFsdWVzKSA9PiBUdXBsZUFyYml0cmFyeS53cmFwcGVyKHZhbHVlcykpO1xuICAgICAgICAgICAgcyA9IHMuam9pbihzaHJpbmtzRm9ySW5kZXgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzO1xuICAgIH1cbn1cbmV4cG9ydHMuVHVwbGVBcmJpdHJhcnkgPSBUdXBsZUFyYml0cmFyeTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5idWlsZENoYXJhY3RlckFyYml0cmFyeSA9IHZvaWQgMDtcbmNvbnN0IENvbnZlcnRlcnNfMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi9jaGVjay9hcmJpdHJhcnkvZGVmaW5pdGlvbi9Db252ZXJ0ZXJzXCIpO1xuY29uc3QgaW50ZWdlcl8xID0gcmVxdWlyZShcIi4uLy4uL2ludGVnZXJcIik7XG5jb25zdCBJbmRleFRvQ2hhclN0cmluZ18xID0gcmVxdWlyZShcIi4uL21hcHBlcnMvSW5kZXhUb0NoYXJTdHJpbmdcIik7XG5mdW5jdGlvbiBidWlsZENoYXJhY3RlckFyYml0cmFyeShtaW4sIG1heCwgbWFwVG9Db2RlLCB1bm1hcEZyb21Db2RlKSB7XG4gICAgcmV0dXJuIENvbnZlcnRlcnNfMS5jb252ZXJ0RnJvbU5leHQoQ29udmVydGVyc18xLmNvbnZlcnRUb05leHQoaW50ZWdlcl8xLmludGVnZXIobWluLCBtYXgpKS5tYXAoKG4pID0+IEluZGV4VG9DaGFyU3RyaW5nXzEuaW5kZXhUb0NoYXJTdHJpbmdNYXBwZXIobWFwVG9Db2RlKG4pKSwgKGMpID0+IHVubWFwRnJvbUNvZGUoSW5kZXhUb0NoYXJTdHJpbmdfMS5pbmRleFRvQ2hhclN0cmluZ1VubWFwcGVyKGMpKSkpO1xufVxuZXhwb3J0cy5idWlsZENoYXJhY3RlckFyYml0cmFyeSA9IGJ1aWxkQ2hhcmFjdGVyQXJiaXRyYXJ5O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmJ1aWxkQ29tcGFyZUZ1bmN0aW9uQXJiaXRyYXJ5ID0gdm9pZCAwO1xuY29uc3QgVGV4dEVzY2FwZXJfMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi9jaGVjay9hcmJpdHJhcnkvaGVscGVycy9UZXh0RXNjYXBlclwiKTtcbmNvbnN0IHN5bWJvbHNfMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi9jaGVjay9zeW1ib2xzXCIpO1xuY29uc3QgaGFzaF8xID0gcmVxdWlyZShcIi4uLy4uLy4uL3V0aWxzL2hhc2hcIik7XG5jb25zdCBzdHJpbmdpZnlfMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi91dGlscy9zdHJpbmdpZnlcIik7XG5jb25zdCBpbnRlZ2VyXzEgPSByZXF1aXJlKFwiLi4vLi4vaW50ZWdlclwiKTtcbmNvbnN0IHR1cGxlXzEgPSByZXF1aXJlKFwiLi4vLi4vdHVwbGVcIik7XG5mdW5jdGlvbiBidWlsZENvbXBhcmVGdW5jdGlvbkFyYml0cmFyeShjbXApIHtcbiAgICByZXR1cm4gdHVwbGVfMS50dXBsZShpbnRlZ2VyXzEuaW50ZWdlcigpLm5vU2hyaW5rKCksIGludGVnZXJfMS5pbnRlZ2VyKDEsIDB4ZmZmZmZmZmYpLm5vU2hyaW5rKCkpLm1hcCgoW3NlZWQsIGhhc2hFbnZTaXplXSkgPT4ge1xuICAgICAgICBjb25zdCBwcm9kdWNlciA9ICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHJlY29yZGVkID0ge307XG4gICAgICAgICAgICBjb25zdCBmID0gKGEsIGIpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXByQSA9IHN0cmluZ2lmeV8xLnN0cmluZ2lmeShhKTtcbiAgICAgICAgICAgICAgICBjb25zdCByZXByQiA9IHN0cmluZ2lmeV8xLnN0cmluZ2lmeShiKTtcbiAgICAgICAgICAgICAgICBjb25zdCBoQSA9IGhhc2hfMS5oYXNoKGAke3NlZWR9JHtyZXByQX1gKSAlIGhhc2hFbnZTaXplO1xuICAgICAgICAgICAgICAgIGNvbnN0IGhCID0gaGFzaF8xLmhhc2goYCR7c2VlZH0ke3JlcHJCfWApICUgaGFzaEVudlNpemU7XG4gICAgICAgICAgICAgICAgY29uc3QgdmFsID0gY21wKGhBLCBoQik7XG4gICAgICAgICAgICAgICAgcmVjb3JkZWRbYFske3JlcHJBfSwke3JlcHJCfV1gXSA9IHZhbDtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKGYsIHtcbiAgICAgICAgICAgICAgICB0b1N0cmluZzogKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBzZWVuVmFsdWVzID0gT2JqZWN0LmtleXMocmVjb3JkZWQpXG4gICAgICAgICAgICAgICAgICAgICAgICAuc29ydCgpXG4gICAgICAgICAgICAgICAgICAgICAgICAubWFwKChrKSA9PiBgJHtrfSA9PiAke3N0cmluZ2lmeV8xLnN0cmluZ2lmeShyZWNvcmRlZFtrXSl9YClcbiAgICAgICAgICAgICAgICAgICAgICAgIC5tYXAoKGxpbmUpID0+IGAvKiAke1RleHRFc2NhcGVyXzEuZXNjYXBlRm9yTXVsdGlsaW5lQ29tbWVudHMobGluZSl9ICovYCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBgZnVuY3Rpb24oYSwgYikge1xuICAvLyBXaXRoIGhhc2ggYW5kIHN0cmluZ2lmeSBjb21pbmcgZnJvbSBmYXN0LWNoZWNrJHtzZWVuVmFsdWVzLmxlbmd0aCAhPT0gMCA/IGBcXG4gICR7c2VlblZhbHVlcy5qb2luKCdcXG4gICcpfWAgOiAnJ31cbiAgY29uc3QgY21wID0gJHtjbXB9O1xuICBjb25zdCBoQSA9IGhhc2goJyR7c2VlZH0nICsgc3RyaW5naWZ5KGEpKSAlICR7aGFzaEVudlNpemV9O1xuICBjb25zdCBoQiA9IGhhc2goJyR7c2VlZH0nICsgc3RyaW5naWZ5KGIpKSAlICR7aGFzaEVudlNpemV9O1xuICByZXR1cm4gY21wKGhBLCBoQik7XG59YDtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIFtzeW1ib2xzXzEuY2xvbmVNZXRob2RdOiBwcm9kdWNlcixcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gcHJvZHVjZXIoKTtcbiAgICB9KTtcbn1cbmV4cG9ydHMuYnVpbGRDb21wYXJlRnVuY3Rpb25BcmJpdHJhcnkgPSBidWlsZENvbXBhcmVGdW5jdGlvbkFyYml0cmFyeTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5idWlsZFBhcnRpYWxSZWNvcmRBcmJpdHJhcnkgPSB2b2lkIDA7XG5jb25zdCBDb252ZXJ0ZXJzXzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vY2hlY2svYXJiaXRyYXJ5L2RlZmluaXRpb24vQ29udmVydGVyc1wiKTtcbmNvbnN0IG9wdGlvbl8xID0gcmVxdWlyZShcIi4uLy4uL29wdGlvblwiKTtcbmNvbnN0IHR1cGxlXzEgPSByZXF1aXJlKFwiLi4vLi4vdHVwbGVcIik7XG5jb25zdCBFbnVtZXJhYmxlS2V5c0V4dHJhY3Rvcl8xID0gcmVxdWlyZShcIi4uL2hlbHBlcnMvRW51bWVyYWJsZUtleXNFeHRyYWN0b3JcIik7XG5jb25zdCBWYWx1ZXNBbmRTZXBhcmF0ZUtleXNUb09iamVjdF8xID0gcmVxdWlyZShcIi4uL21hcHBlcnMvVmFsdWVzQW5kU2VwYXJhdGVLZXlzVG9PYmplY3RcIik7XG5jb25zdCBub0tleVZhbHVlID0gU3ltYm9sKCduby1rZXknKTtcbmZ1bmN0aW9uIGJ1aWxkUGFydGlhbFJlY29yZEFyYml0cmFyeShyZWNvcmRNb2RlbCwgcmVxdWlyZWRLZXlzKSB7XG4gICAgY29uc3Qga2V5cyA9IEVudW1lcmFibGVLZXlzRXh0cmFjdG9yXzEuZXh0cmFjdEVudW1lcmFibGVLZXlzKHJlY29yZE1vZGVsKTtcbiAgICBjb25zdCBhcmJzID0gW107XG4gICAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCAhPT0ga2V5cy5sZW5ndGg7ICsraW5kZXgpIHtcbiAgICAgICAgY29uc3QgayA9IGtleXNbaW5kZXhdO1xuICAgICAgICBjb25zdCByZXF1aXJlZEFyYml0cmFyeSA9IHJlY29yZE1vZGVsW2tdO1xuICAgICAgICBpZiAocmVxdWlyZWRLZXlzID09PSB1bmRlZmluZWQgfHwgcmVxdWlyZWRLZXlzLmluZGV4T2YoaykgIT09IC0xKVxuICAgICAgICAgICAgYXJicy5wdXNoKHJlcXVpcmVkQXJiaXRyYXJ5KTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgYXJicy5wdXNoKG9wdGlvbl8xLm9wdGlvbihyZXF1aXJlZEFyYml0cmFyeSwgeyBuaWw6IG5vS2V5VmFsdWUgfSkpO1xuICAgIH1cbiAgICByZXR1cm4gQ29udmVydGVyc18xLmNvbnZlcnRGcm9tTmV4dChDb252ZXJ0ZXJzXzEuY29udmVydFRvTmV4dCh0dXBsZV8xLnR1cGxlKC4uLmFyYnMpKS5tYXAoVmFsdWVzQW5kU2VwYXJhdGVLZXlzVG9PYmplY3RfMS5idWlsZFZhbHVlc0FuZFNlcGFyYXRlS2V5c1RvT2JqZWN0TWFwcGVyKGtleXMsIG5vS2V5VmFsdWUpLCBWYWx1ZXNBbmRTZXBhcmF0ZUtleXNUb09iamVjdF8xLmJ1aWxkVmFsdWVzQW5kU2VwYXJhdGVLZXlzVG9PYmplY3RVbm1hcHBlcihrZXlzLCBub0tleVZhbHVlKSkpO1xufVxuZXhwb3J0cy5idWlsZFBhcnRpYWxSZWNvcmRBcmJpdHJhcnkgPSBidWlsZFBhcnRpYWxSZWNvcmRBcmJpdHJhcnk7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuYnVpbGRTdHJpbmdpZmllZE5hdEFyYml0cmFyeSA9IHZvaWQgMDtcbmNvbnN0IENvbnZlcnRlcnNfMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi9jaGVjay9hcmJpdHJhcnkvZGVmaW5pdGlvbi9Db252ZXJ0ZXJzXCIpO1xuY29uc3QgY29uc3RhbnRGcm9tXzEgPSByZXF1aXJlKFwiLi4vLi4vY29uc3RhbnRGcm9tXCIpO1xuY29uc3QgbmF0XzEgPSByZXF1aXJlKFwiLi4vLi4vbmF0XCIpO1xuY29uc3QgdHVwbGVfMSA9IHJlcXVpcmUoXCIuLi8uLi90dXBsZVwiKTtcbmNvbnN0IE5hdFRvU3RyaW5naWZpZWROYXRfMSA9IHJlcXVpcmUoXCIuLi9tYXBwZXJzL05hdFRvU3RyaW5naWZpZWROYXRcIik7XG5mdW5jdGlvbiBidWlsZFN0cmluZ2lmaWVkTmF0QXJiaXRyYXJ5KG1heFZhbHVlKSB7XG4gICAgcmV0dXJuIENvbnZlcnRlcnNfMS5jb252ZXJ0RnJvbU5leHQoQ29udmVydGVyc18xLmNvbnZlcnRUb05leHQodHVwbGVfMS50dXBsZShjb25zdGFudEZyb21fMS5jb25zdGFudEZyb20oJ2RlYycsICdvY3QnLCAnaGV4JyksIG5hdF8xLm5hdChtYXhWYWx1ZSkpKS5tYXAoTmF0VG9TdHJpbmdpZmllZE5hdF8xLm5hdFRvU3RyaW5naWZpZWROYXRNYXBwZXIsIE5hdFRvU3RyaW5naWZpZWROYXRfMS5uYXRUb1N0cmluZ2lmaWVkTmF0VW5tYXBwZXIpKTtcbn1cbmV4cG9ydHMuYnVpbGRTdHJpbmdpZmllZE5hdEFyYml0cmFyeSA9IGJ1aWxkU3RyaW5naWZpZWROYXRBcmJpdHJhcnk7XG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX3Jlc3QgPSAodGhpcyAmJiB0aGlzLl9fcmVzdCkgfHwgZnVuY3Rpb24gKHMsIGUpIHtcbiAgICB2YXIgdCA9IHt9O1xuICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSAmJiBlLmluZGV4T2YocCkgPCAwKVxuICAgICAgICB0W3BdID0gc1twXTtcbiAgICBpZiAocyAhPSBudWxsICYmIHR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzID09PSBcImZ1bmN0aW9uXCIpXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBwID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhzKTsgaSA8IHAubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChlLmluZGV4T2YocFtpXSkgPCAwICYmIE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChzLCBwW2ldKSlcbiAgICAgICAgICAgICAgICB0W3BbaV1dID0gc1twW2ldXTtcbiAgICAgICAgfVxuICAgIHJldHVybiB0O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMudHlwZWRJbnRBcnJheUFyYml0cmFyeUFyYml0cmFyeUJ1aWxkZXIgPSB2b2lkIDA7XG5jb25zdCBhcnJheV8xID0gcmVxdWlyZShcIi4uLy4uL2FycmF5XCIpO1xuZnVuY3Rpb24gdHlwZWRJbnRBcnJheUFyYml0cmFyeUFyYml0cmFyeUJ1aWxkZXIoY29uc3RyYWludHMsIGRlZmF1bHRNaW4sIGRlZmF1bHRNYXgsIFR5cGVkQXJyYXlDbGFzcywgYXJiaXRyYXJ5QnVpbGRlcikge1xuICAgIGNvbnN0IGdlbmVyYXRvck5hbWUgPSBUeXBlZEFycmF5Q2xhc3MubmFtZTtcbiAgICBjb25zdCB7IG1pbiA9IGRlZmF1bHRNaW4sIG1heCA9IGRlZmF1bHRNYXggfSA9IGNvbnN0cmFpbnRzLCBhcnJheUNvbnN0cmFpbnRzID0gX19yZXN0KGNvbnN0cmFpbnRzLCBbXCJtaW5cIiwgXCJtYXhcIl0pO1xuICAgIGlmIChtaW4gPiBtYXgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHJhbmdlIHBhc3NlZCB0byAke2dlbmVyYXRvck5hbWV9OiBtaW4gbXVzdCBiZSBsb3dlciB0aGFuIG9yIGVxdWFsIHRvIG1heGApO1xuICAgIH1cbiAgICBpZiAobWluIDwgZGVmYXVsdE1pbikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgbWluIHZhbHVlIHBhc3NlZCB0byAke2dlbmVyYXRvck5hbWV9OiBtaW4gbXVzdCBiZSBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gJHtkZWZhdWx0TWlufWApO1xuICAgIH1cbiAgICBpZiAobWF4ID4gZGVmYXVsdE1heCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgbWF4IHZhbHVlIHBhc3NlZCB0byAke2dlbmVyYXRvck5hbWV9OiBtYXggbXVzdCBiZSBsb3dlciB0aGFuIG9yIGVxdWFsIHRvICR7ZGVmYXVsdE1heH1gKTtcbiAgICB9XG4gICAgcmV0dXJuIGFycmF5XzEuYXJyYXkoYXJiaXRyYXJ5QnVpbGRlcih7IG1pbiwgbWF4IH0pLCBhcnJheUNvbnN0cmFpbnRzKS5tYXAoKGRhdGEpID0+IFR5cGVkQXJyYXlDbGFzcy5mcm9tKGRhdGEpKTtcbn1cbmV4cG9ydHMudHlwZWRJbnRBcnJheUFyYml0cmFyeUFyYml0cmFyeUJ1aWxkZXIgPSB0eXBlZEludEFycmF5QXJiaXRyYXJ5QXJiaXRyYXJ5QnVpbGRlcjtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5iaWFzTnVtZXJpY1JhbmdlID0gZXhwb3J0cy5iaWdJbnRMb2dMaWtlID0gZXhwb3J0cy5pbnRlZ2VyTG9nTGlrZSA9IHZvaWQgMDtcbmZ1bmN0aW9uIGludGVnZXJMb2dMaWtlKHYpIHtcbiAgICByZXR1cm4gTWF0aC5mbG9vcihNYXRoLmxvZyh2KSAvIE1hdGgubG9nKDIpKTtcbn1cbmV4cG9ydHMuaW50ZWdlckxvZ0xpa2UgPSBpbnRlZ2VyTG9nTGlrZTtcbmZ1bmN0aW9uIGJpZ0ludExvZ0xpa2Uodikge1xuICAgIGlmICh2ID09PSBCaWdJbnQoMCkpXG4gICAgICAgIHJldHVybiBCaWdJbnQoMCk7XG4gICAgcmV0dXJuIEJpZ0ludCh2LnRvU3RyaW5nKCkubGVuZ3RoKTtcbn1cbmV4cG9ydHMuYmlnSW50TG9nTGlrZSA9IGJpZ0ludExvZ0xpa2U7XG5mdW5jdGlvbiBiaWFzTnVtZXJpY1JhbmdlKG1pbiwgbWF4LCBsb2dMaWtlKSB7XG4gICAgaWYgKG1pbiA9PT0gbWF4KSB7XG4gICAgICAgIHJldHVybiBbeyBtaW46IG1pbiwgbWF4OiBtYXggfV07XG4gICAgfVxuICAgIGlmIChtaW4gPCAwICYmIG1heCA+IDApIHtcbiAgICAgICAgY29uc3QgbG9nTWluID0gbG9nTGlrZSgtbWluKTtcbiAgICAgICAgY29uc3QgbG9nTWF4ID0gbG9nTGlrZShtYXgpO1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgeyBtaW46IC1sb2dNaW4sIG1heDogbG9nTWF4IH0sXG4gICAgICAgICAgICB7IG1pbjogKG1heCAtIGxvZ01heCksIG1heDogbWF4IH0sXG4gICAgICAgICAgICB7IG1pbjogbWluLCBtYXg6IG1pbiArIGxvZ01pbiB9LFxuICAgICAgICBdO1xuICAgIH1cbiAgICBjb25zdCBsb2dHYXAgPSBsb2dMaWtlKChtYXggLSBtaW4pKTtcbiAgICBjb25zdCBhcmJDbG9zZVRvTWluID0geyBtaW46IG1pbiwgbWF4OiBtaW4gKyBsb2dHYXAgfTtcbiAgICBjb25zdCBhcmJDbG9zZVRvTWF4ID0geyBtaW46IChtYXggLSBsb2dHYXApLCBtYXg6IG1heCB9O1xuICAgIHJldHVybiBtaW4gPCAwXG4gICAgICAgID8gW2FyYkNsb3NlVG9NYXgsIGFyYkNsb3NlVG9NaW5dXG4gICAgICAgIDogW2FyYkNsb3NlVG9NaW4sIGFyYkNsb3NlVG9NYXhdO1xufVxuZXhwb3J0cy5iaWFzTnVtZXJpY1JhbmdlID0gYmlhc051bWVyaWNSYW5nZTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5idWlsZENvbXBhcmVGaWx0ZXIgPSB2b2lkIDA7XG5mdW5jdGlvbiBzdWJBcnJheUNvbnRhaW5zKHRhYiwgdXBwZXJCb3VuZCwgaW5jbHVkZVZhbHVlKSB7XG4gICAgZm9yIChsZXQgaWR4ID0gMDsgaWR4IDwgdXBwZXJCb3VuZDsgKytpZHgpIHtcbiAgICAgICAgaWYgKGluY2x1ZGVWYWx1ZSh0YWJbaWR4XSkpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gc3dhcCh0YWIsIGlkeDEsIGlkeDIpIHtcbiAgICBjb25zdCB0ZW1wID0gdGFiW2lkeDFdO1xuICAgIHRhYltpZHgxXSA9IHRhYltpZHgyXTtcbiAgICB0YWJbaWR4Ml0gPSB0ZW1wO1xufVxuZnVuY3Rpb24gYnVpbGRDb21wYXJlRmlsdGVyKGNvbXBhcmUpIHtcbiAgICByZXR1cm4gKHRhYikgPT4ge1xuICAgICAgICBsZXQgZmluYWxMZW5ndGggPSB0YWIubGVuZ3RoO1xuICAgICAgICBmb3IgKGxldCBpZHggPSB0YWIubGVuZ3RoIC0gMTsgaWR4ICE9PSAtMTsgLS1pZHgpIHtcbiAgICAgICAgICAgIGlmIChzdWJBcnJheUNvbnRhaW5zKHRhYiwgaWR4LCAodCkgPT4gY29tcGFyZSh0LnZhbHVlXywgdGFiW2lkeF0udmFsdWVfKSkpIHtcbiAgICAgICAgICAgICAgICAtLWZpbmFsTGVuZ3RoO1xuICAgICAgICAgICAgICAgIHN3YXAodGFiLCBpZHgsIGZpbmFsTGVuZ3RoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGFiLnNsaWNlKDAsIGZpbmFsTGVuZ3RoKTtcbiAgICB9O1xufVxuZXhwb3J0cy5idWlsZENvbXBhcmVGaWx0ZXIgPSBidWlsZENvbXBhcmVGaWx0ZXI7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuYnVpbGRTY2hlZHVsZXJGb3IgPSB2b2lkIDA7XG5jb25zdCBTY2hlZHVsZXJJbXBsZW1fMSA9IHJlcXVpcmUoXCIuLi9pbXBsZW1lbnRhdGlvbnMvU2NoZWR1bGVySW1wbGVtXCIpO1xuZnVuY3Rpb24gYnVpbGROZXh0VGFza0luZGV4KG9yZGVyaW5nKSB7XG4gICAgbGV0IG51bVRhc2tzID0gMDtcbiAgICByZXR1cm4ge1xuICAgICAgICBjbG9uZTogKCkgPT4gYnVpbGROZXh0VGFza0luZGV4KG9yZGVyaW5nKSxcbiAgICAgICAgbmV4dFRhc2tJbmRleDogKHNjaGVkdWxlZFRhc2tzKSA9PiB7XG4gICAgICAgICAgICBpZiAob3JkZXJpbmcubGVuZ3RoIDw9IG51bVRhc2tzKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHNjaGVkdWxlckZvciBkZWZpbmVkOiB0b28gbWFueSB0YXNrcyBoYXZlIGJlZW4gc2NoZWR1bGVkYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB0YXNrSW5kZXggPSBzY2hlZHVsZWRUYXNrcy5maW5kSW5kZXgoKHQpID0+IHQudGFza0lkID09PSBvcmRlcmluZ1tudW1UYXNrc10pO1xuICAgICAgICAgICAgaWYgKHRhc2tJbmRleCA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgc2NoZWR1bGVyRm9yIGRlZmluZWQ6IHVuYWJsZSB0byBmaW5kIG5leHQgdGFza2ApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgKytudW1UYXNrcztcbiAgICAgICAgICAgIHJldHVybiB0YXNrSW5kZXg7XG4gICAgICAgIH0sXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGJ1aWxkU2NoZWR1bGVyRm9yKGFjdCwgb3JkZXJpbmcpIHtcbiAgICByZXR1cm4gbmV3IFNjaGVkdWxlckltcGxlbV8xLlNjaGVkdWxlckltcGxlbShhY3QsIGJ1aWxkTmV4dFRhc2tJbmRleChvcmRlcmluZykpO1xufVxuZXhwb3J0cy5idWlsZFNjaGVkdWxlckZvciA9IGJ1aWxkU2NoZWR1bGVyRm9yO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmdldERlcHRoQ29udGV4dEZvciA9IHZvaWQgMDtcbmNvbnN0IGRlcHRoQ29udGV4dENhY2hlID0gbmV3IE1hcCgpO1xuZnVuY3Rpb24gZ2V0RGVwdGhDb250ZXh0Rm9yKGNvbnRleHRNZXRhKSB7XG4gICAgaWYgKGNvbnRleHRNZXRhID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIHsgZGVwdGg6IDAgfTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBjb250ZXh0TWV0YSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIGNvbnRleHRNZXRhO1xuICAgIH1cbiAgICBjb25zdCBjYWNoZWRDb250ZXh0ID0gZGVwdGhDb250ZXh0Q2FjaGUuZ2V0KGNvbnRleHRNZXRhKTtcbiAgICBpZiAoY2FjaGVkQ29udGV4dCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBjYWNoZWRDb250ZXh0O1xuICAgIH1cbiAgICBjb25zdCBjb250ZXh0ID0geyBkZXB0aDogMCB9O1xuICAgIGRlcHRoQ29udGV4dENhY2hlLnNldChjb250ZXh0TWV0YSwgY29udGV4dCk7XG4gICAgcmV0dXJuIGNvbnRleHQ7XG59XG5leHBvcnRzLmdldERlcHRoQ29udGV4dEZvciA9IGdldERlcHRoQ29udGV4dEZvcjtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5leHRyYWN0RW51bWVyYWJsZUtleXMgPSB2b2lkIDA7XG5mdW5jdGlvbiBleHRyYWN0RW51bWVyYWJsZUtleXMoaW5zdGFuY2UpIHtcbiAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMoaW5zdGFuY2UpO1xuICAgIGNvbnN0IHN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKGluc3RhbmNlKTtcbiAgICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4ICE9PSBzeW1ib2xzLmxlbmd0aDsgKytpbmRleCkge1xuICAgICAgICBjb25zdCBzeW1ib2wgPSBzeW1ib2xzW2luZGV4XTtcbiAgICAgICAgY29uc3QgZGVzY3JpcHRvciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoaW5zdGFuY2UsIHN5bWJvbCk7XG4gICAgICAgIGlmIChkZXNjcmlwdG9yICYmIGRlc2NyaXB0b3IuZW51bWVyYWJsZSkge1xuICAgICAgICAgICAga2V5cy5wdXNoKHN5bWJvbCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGtleXM7XG59XG5leHBvcnRzLmV4dHJhY3RFbnVtZXJhYmxlS2V5cyA9IGV4dHJhY3RFbnVtZXJhYmxlS2V5cztcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5tYXhMZW5ndGhGcm9tTWluTGVuZ3RoID0gdm9pZCAwO1xuZnVuY3Rpb24gbWF4TGVuZ3RoRnJvbU1pbkxlbmd0aChtaW5MZW5ndGgpIHtcbiAgICByZXR1cm4gMiAqIG1pbkxlbmd0aCArIDEwO1xufVxuZXhwb3J0cy5tYXhMZW5ndGhGcm9tTWluTGVuZ3RoID0gbWF4TGVuZ3RoRnJvbU1pbkxlbmd0aDtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5zaHJpbmtCaWdJbnQgPSB2b2lkIDA7XG5jb25zdCBTdHJlYW1fMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi9zdHJlYW0vU3RyZWFtXCIpO1xuY29uc3QgTmV4dFZhbHVlXzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vY2hlY2svYXJiaXRyYXJ5L2RlZmluaXRpb24vTmV4dFZhbHVlXCIpO1xuZnVuY3Rpb24gaGFsdmVCaWdJbnQobikge1xuICAgIHJldHVybiBuIC8gQmlnSW50KDIpO1xufVxuZnVuY3Rpb24gc2hyaW5rQmlnSW50KGN1cnJlbnQsIHRhcmdldCwgdHJ5VGFyZ2V0QXNhcCkge1xuICAgIGNvbnN0IHJlYWxHYXAgPSBjdXJyZW50IC0gdGFyZ2V0O1xuICAgIGZ1bmN0aW9uKiBzaHJpbmtEZWNyKCkge1xuICAgICAgICBsZXQgcHJldmlvdXMgPSB0cnlUYXJnZXRBc2FwID8gdW5kZWZpbmVkIDogdGFyZ2V0O1xuICAgICAgICBjb25zdCBnYXAgPSB0cnlUYXJnZXRBc2FwID8gcmVhbEdhcCA6IGhhbHZlQmlnSW50KHJlYWxHYXApO1xuICAgICAgICBmb3IgKGxldCB0b3JlbW92ZSA9IGdhcDsgdG9yZW1vdmUgPiAwOyB0b3JlbW92ZSA9IGhhbHZlQmlnSW50KHRvcmVtb3ZlKSkge1xuICAgICAgICAgICAgY29uc3QgbmV4dCA9IGN1cnJlbnQgLSB0b3JlbW92ZTtcbiAgICAgICAgICAgIHlpZWxkIG5ldyBOZXh0VmFsdWVfMS5OZXh0VmFsdWUobmV4dCwgcHJldmlvdXMpO1xuICAgICAgICAgICAgcHJldmlvdXMgPSBuZXh0O1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uKiBzaHJpbmtJbmNyKCkge1xuICAgICAgICBsZXQgcHJldmlvdXMgPSB0cnlUYXJnZXRBc2FwID8gdW5kZWZpbmVkIDogdGFyZ2V0O1xuICAgICAgICBjb25zdCBnYXAgPSB0cnlUYXJnZXRBc2FwID8gcmVhbEdhcCA6IGhhbHZlQmlnSW50KHJlYWxHYXApO1xuICAgICAgICBmb3IgKGxldCB0b3JlbW92ZSA9IGdhcDsgdG9yZW1vdmUgPCAwOyB0b3JlbW92ZSA9IGhhbHZlQmlnSW50KHRvcmVtb3ZlKSkge1xuICAgICAgICAgICAgY29uc3QgbmV4dCA9IGN1cnJlbnQgLSB0b3JlbW92ZTtcbiAgICAgICAgICAgIHlpZWxkIG5ldyBOZXh0VmFsdWVfMS5OZXh0VmFsdWUobmV4dCwgcHJldmlvdXMpO1xuICAgICAgICAgICAgcHJldmlvdXMgPSBuZXh0O1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZWFsR2FwID4gMCA/IFN0cmVhbV8xLnN0cmVhbShzaHJpbmtEZWNyKCkpIDogU3RyZWFtXzEuc3RyZWFtKHNocmlua0luY3IoKSk7XG59XG5leHBvcnRzLnNocmlua0JpZ0ludCA9IHNocmlua0JpZ0ludDtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5zaHJpbmtJbnRlZ2VyID0gdm9pZCAwO1xuY29uc3QgTmV4dFZhbHVlXzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vY2hlY2svYXJiaXRyYXJ5L2RlZmluaXRpb24vTmV4dFZhbHVlXCIpO1xuY29uc3QgU3RyZWFtXzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vc3RyZWFtL1N0cmVhbVwiKTtcbmZ1bmN0aW9uIGhhbHZlUG9zSW50ZWdlcihuKSB7XG4gICAgcmV0dXJuIE1hdGguZmxvb3IobiAvIDIpO1xufVxuZnVuY3Rpb24gaGFsdmVOZWdJbnRlZ2VyKG4pIHtcbiAgICByZXR1cm4gTWF0aC5jZWlsKG4gLyAyKTtcbn1cbmZ1bmN0aW9uIHNocmlua0ludGVnZXIoY3VycmVudCwgdGFyZ2V0LCB0cnlUYXJnZXRBc2FwKSB7XG4gICAgY29uc3QgcmVhbEdhcCA9IGN1cnJlbnQgLSB0YXJnZXQ7XG4gICAgZnVuY3Rpb24qIHNocmlua0RlY3IoKSB7XG4gICAgICAgIGxldCBwcmV2aW91cyA9IHRyeVRhcmdldEFzYXAgPyB1bmRlZmluZWQgOiB0YXJnZXQ7XG4gICAgICAgIGNvbnN0IGdhcCA9IHRyeVRhcmdldEFzYXAgPyByZWFsR2FwIDogaGFsdmVQb3NJbnRlZ2VyKHJlYWxHYXApO1xuICAgICAgICBmb3IgKGxldCB0b3JlbW92ZSA9IGdhcDsgdG9yZW1vdmUgPiAwOyB0b3JlbW92ZSA9IGhhbHZlUG9zSW50ZWdlcih0b3JlbW92ZSkpIHtcbiAgICAgICAgICAgIGNvbnN0IG5leHQgPSB0b3JlbW92ZSA9PT0gcmVhbEdhcCA/IHRhcmdldCA6IGN1cnJlbnQgLSB0b3JlbW92ZTtcbiAgICAgICAgICAgIHlpZWxkIG5ldyBOZXh0VmFsdWVfMS5OZXh0VmFsdWUobmV4dCwgcHJldmlvdXMpO1xuICAgICAgICAgICAgcHJldmlvdXMgPSBuZXh0O1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uKiBzaHJpbmtJbmNyKCkge1xuICAgICAgICBsZXQgcHJldmlvdXMgPSB0cnlUYXJnZXRBc2FwID8gdW5kZWZpbmVkIDogdGFyZ2V0O1xuICAgICAgICBjb25zdCBnYXAgPSB0cnlUYXJnZXRBc2FwID8gcmVhbEdhcCA6IGhhbHZlTmVnSW50ZWdlcihyZWFsR2FwKTtcbiAgICAgICAgZm9yIChsZXQgdG9yZW1vdmUgPSBnYXA7IHRvcmVtb3ZlIDwgMDsgdG9yZW1vdmUgPSBoYWx2ZU5lZ0ludGVnZXIodG9yZW1vdmUpKSB7XG4gICAgICAgICAgICBjb25zdCBuZXh0ID0gdG9yZW1vdmUgPT09IHJlYWxHYXAgPyB0YXJnZXQgOiBjdXJyZW50IC0gdG9yZW1vdmU7XG4gICAgICAgICAgICB5aWVsZCBuZXcgTmV4dFZhbHVlXzEuTmV4dFZhbHVlKG5leHQsIHByZXZpb3VzKTtcbiAgICAgICAgICAgIHByZXZpb3VzID0gbmV4dDtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVhbEdhcCA+IDAgPyBTdHJlYW1fMS5zdHJlYW0oc2hyaW5rRGVjcigpKSA6IFN0cmVhbV8xLnN0cmVhbShzaHJpbmtJbmNyKCkpO1xufVxuZXhwb3J0cy5zaHJpbmtJbnRlZ2VyID0gc2hyaW5rSW50ZWdlcjtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5leHRyYWN0U3RyaW5nQ29uc3RyYWludHMgPSB2b2lkIDA7XG5mdW5jdGlvbiBleHRyYWN0U3RyaW5nQ29uc3RyYWludHMob3B0aW9ucykge1xuICAgIHJldHVybiBvcHRpb25zWzBdICE9PSB1bmRlZmluZWRcbiAgICAgICAgPyB0eXBlb2Ygb3B0aW9uc1swXSA9PT0gJ251bWJlcidcbiAgICAgICAgICAgID8gdHlwZW9mIG9wdGlvbnNbMV0gPT09ICdudW1iZXInXG4gICAgICAgICAgICAgICAgPyB7IG1pbkxlbmd0aDogb3B0aW9uc1swXSwgbWF4TGVuZ3RoOiBvcHRpb25zWzFdIH1cbiAgICAgICAgICAgICAgICA6IHsgbWF4TGVuZ3RoOiBvcHRpb25zWzBdIH1cbiAgICAgICAgICAgIDogb3B0aW9uc1swXVxuICAgICAgICA6IHt9O1xufVxuZXhwb3J0cy5leHRyYWN0U3RyaW5nQ29uc3RyYWludHMgPSBleHRyYWN0U3RyaW5nQ29uc3RyYWludHM7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuU2NoZWR1bGVySW1wbGVtID0gdm9pZCAwO1xuY29uc3QgVGV4dEVzY2FwZXJfMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi9jaGVjay9hcmJpdHJhcnkvaGVscGVycy9UZXh0RXNjYXBlclwiKTtcbmNvbnN0IHN5bWJvbHNfMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi9jaGVjay9zeW1ib2xzXCIpO1xuY29uc3Qgc3RyaW5naWZ5XzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vdXRpbHMvc3RyaW5naWZ5XCIpO1xuY2xhc3MgU2NoZWR1bGVySW1wbGVtIHtcbiAgICBjb25zdHJ1Y3RvcihhY3QsIHRhc2tTZWxlY3Rvcikge1xuICAgICAgICB0aGlzLmFjdCA9IGFjdDtcbiAgICAgICAgdGhpcy50YXNrU2VsZWN0b3IgPSB0YXNrU2VsZWN0b3I7XG4gICAgICAgIHRoaXMubGFzdFRhc2tJZCA9IDA7XG4gICAgICAgIHRoaXMuc291cmNlVGFza1NlbGVjdG9yID0gdGFza1NlbGVjdG9yLmNsb25lKCk7XG4gICAgICAgIHRoaXMuc2NoZWR1bGVkVGFza3MgPSBbXTtcbiAgICAgICAgdGhpcy50cmlnZ2VyZWRUYXNrcyA9IFtdO1xuICAgIH1cbiAgICBzdGF0aWMgYnVpbGRMb2cocmVwb3J0SXRlbSkge1xuICAgICAgICByZXR1cm4gYFt0YXNrXFwkeyR7cmVwb3J0SXRlbS50YXNrSWR9fV0gJHtyZXBvcnRJdGVtLmxhYmVsLmxlbmd0aCAhPT0gMCA/IGAke3JlcG9ydEl0ZW0uc2NoZWR1bGluZ1R5cGV9Ojoke3JlcG9ydEl0ZW0ubGFiZWx9YCA6IHJlcG9ydEl0ZW0uc2NoZWR1bGluZ1R5cGV9ICR7cmVwb3J0SXRlbS5zdGF0dXN9JHtyZXBvcnRJdGVtLm91dHB1dFZhbHVlICE9PSB1bmRlZmluZWQgPyBgIHdpdGggdmFsdWUgJHtUZXh0RXNjYXBlcl8xLmVzY2FwZUZvclRlbXBsYXRlU3RyaW5nKHJlcG9ydEl0ZW0ub3V0cHV0VmFsdWUpfWAgOiAnJ31gO1xuICAgIH1cbiAgICBsb2coc2NoZWR1bGluZ1R5cGUsIHRhc2tJZCwgbGFiZWwsIG1ldGFkYXRhLCBzdGF0dXMsIGRhdGEpIHtcbiAgICAgICAgdGhpcy50cmlnZ2VyZWRUYXNrcy5wdXNoKHtcbiAgICAgICAgICAgIHN0YXR1cyxcbiAgICAgICAgICAgIHNjaGVkdWxpbmdUeXBlLFxuICAgICAgICAgICAgdGFza0lkLFxuICAgICAgICAgICAgbGFiZWwsXG4gICAgICAgICAgICBtZXRhZGF0YSxcbiAgICAgICAgICAgIG91dHB1dFZhbHVlOiBkYXRhICE9PSB1bmRlZmluZWQgPyBzdHJpbmdpZnlfMS5zdHJpbmdpZnkoZGF0YSkgOiB1bmRlZmluZWQsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBzY2hlZHVsZUludGVybmFsKHNjaGVkdWxpbmdUeXBlLCBsYWJlbCwgdGFzaywgbWV0YWRhdGEsIHRoZW5UYXNrVG9CZUF3YWl0ZWQpIHtcbiAgICAgICAgbGV0IHRyaWdnZXIgPSBudWxsO1xuICAgICAgICBjb25zdCB0YXNrSWQgPSArK3RoaXMubGFzdFRhc2tJZDtcbiAgICAgICAgY29uc3Qgc2NoZWR1bGVkUHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIHRyaWdnZXIgPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgKHRoZW5UYXNrVG9CZUF3YWl0ZWQgPyB0YXNrLnRoZW4oKCkgPT4gdGhlblRhc2tUb0JlQXdhaXRlZCgpKSA6IHRhc2spLnRoZW4oKGRhdGEpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5sb2coc2NoZWR1bGluZ1R5cGUsIHRhc2tJZCwgbGFiZWwsIG1ldGFkYXRhLCAncmVzb2x2ZWQnLCBkYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc29sdmUoZGF0YSk7XG4gICAgICAgICAgICAgICAgfSwgKGVycikgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmxvZyhzY2hlZHVsaW5nVHlwZSwgdGFza0lkLCBsYWJlbCwgbWV0YWRhdGEsICdyZWplY3RlZCcsIGVycik7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZWplY3QoZXJyKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnNjaGVkdWxlZFRhc2tzLnB1c2goe1xuICAgICAgICAgICAgb3JpZ2luYWw6IHRhc2ssXG4gICAgICAgICAgICBzY2hlZHVsZWQ6IHNjaGVkdWxlZFByb21pc2UsXG4gICAgICAgICAgICB0cmlnZ2VyOiB0cmlnZ2VyLFxuICAgICAgICAgICAgc2NoZWR1bGluZ1R5cGUsXG4gICAgICAgICAgICB0YXNrSWQsXG4gICAgICAgICAgICBsYWJlbCxcbiAgICAgICAgICAgIG1ldGFkYXRhLFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHNjaGVkdWxlZFByb21pc2U7XG4gICAgfVxuICAgIHNjaGVkdWxlKHRhc2ssIGxhYmVsLCBtZXRhZGF0YSkge1xuICAgICAgICByZXR1cm4gdGhpcy5zY2hlZHVsZUludGVybmFsKCdwcm9taXNlJywgbGFiZWwgfHwgJycsIHRhc2ssIG1ldGFkYXRhKTtcbiAgICB9XG4gICAgc2NoZWR1bGVGdW5jdGlvbihhc3luY0Z1bmN0aW9uKSB7XG4gICAgICAgIHJldHVybiAoLi4uYXJncykgPT4gdGhpcy5zY2hlZHVsZUludGVybmFsKCdmdW5jdGlvbicsIGAke2FzeW5jRnVuY3Rpb24ubmFtZX0oJHthcmdzLm1hcChzdHJpbmdpZnlfMS5zdHJpbmdpZnkpLmpvaW4oJywnKX0pYCwgYXN5bmNGdW5jdGlvbiguLi5hcmdzKSwgdW5kZWZpbmVkKTtcbiAgICB9XG4gICAgc2NoZWR1bGVTZXF1ZW5jZShzZXF1ZW5jZUJ1aWxkZXJzKSB7XG4gICAgICAgIGNvbnN0IHN0YXR1cyA9IHsgZG9uZTogZmFsc2UsIGZhdWx0eTogZmFsc2UgfTtcbiAgICAgICAgY29uc3QgZHVtbXlSZXNvbHZlZFByb21pc2UgPSB7IHRoZW46IChmKSA9PiBmKCkgfTtcbiAgICAgICAgbGV0IHJlc29sdmVTZXF1ZW5jZVRhc2sgPSAoKSA9PiB7IH07XG4gICAgICAgIGNvbnN0IHNlcXVlbmNlVGFzayA9IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiAocmVzb2x2ZVNlcXVlbmNlVGFzayA9IHJlc29sdmUpKTtcbiAgICAgICAgc2VxdWVuY2VCdWlsZGVyc1xuICAgICAgICAgICAgLnJlZHVjZSgocHJldmlvdXNseVNjaGVkdWxlZCwgaXRlbSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgW2J1aWxkZXIsIGxhYmVsLCBtZXRhZGF0YV0gPSB0eXBlb2YgaXRlbSA9PT0gJ2Z1bmN0aW9uJyA/IFtpdGVtLCBpdGVtLm5hbWUsIHVuZGVmaW5lZF0gOiBbaXRlbS5idWlsZGVyLCBpdGVtLmxhYmVsLCBpdGVtLm1ldGFkYXRhXTtcbiAgICAgICAgICAgIHJldHVybiBwcmV2aW91c2x5U2NoZWR1bGVkLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHNjaGVkdWxlZCA9IHRoaXMuc2NoZWR1bGVJbnRlcm5hbCgnc2VxdWVuY2UnLCBsYWJlbCwgZHVtbXlSZXNvbHZlZFByb21pc2UsIG1ldGFkYXRhLCAoKSA9PiBidWlsZGVyKCkpO1xuICAgICAgICAgICAgICAgIHNjaGVkdWxlZC5jYXRjaCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5mYXVsdHkgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlU2VxdWVuY2VUYXNrKCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNjaGVkdWxlZDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LCBkdW1teVJlc29sdmVkUHJvbWlzZSlcbiAgICAgICAgICAgIC50aGVuKCgpID0+IHtcbiAgICAgICAgICAgIHN0YXR1cy5kb25lID0gdHJ1ZTtcbiAgICAgICAgICAgIHJlc29sdmVTZXF1ZW5jZVRhc2soKTtcbiAgICAgICAgfSwgKCkgPT4ge1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oc3RhdHVzLCB7XG4gICAgICAgICAgICB0YXNrOiBQcm9taXNlLnJlc29sdmUoc2VxdWVuY2VUYXNrKS50aGVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBkb25lOiBzdGF0dXMuZG9uZSwgZmF1bHR5OiBzdGF0dXMuZmF1bHR5IH07XG4gICAgICAgICAgICB9KSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGNvdW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zY2hlZHVsZWRUYXNrcy5sZW5ndGg7XG4gICAgfVxuICAgIGFzeW5jIGludGVybmFsV2FpdE9uZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuc2NoZWR1bGVkVGFza3MubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIHRhc2sgc2NoZWR1bGVkJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdGFza0luZGV4ID0gdGhpcy50YXNrU2VsZWN0b3IubmV4dFRhc2tJbmRleCh0aGlzLnNjaGVkdWxlZFRhc2tzKTtcbiAgICAgICAgY29uc3QgW3NjaGVkdWxlZFRhc2tdID0gdGhpcy5zY2hlZHVsZWRUYXNrcy5zcGxpY2UodGFza0luZGV4LCAxKTtcbiAgICAgICAgc2NoZWR1bGVkVGFzay50cmlnZ2VyKCk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBhd2FpdCBzY2hlZHVsZWRUYXNrLnNjaGVkdWxlZDtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoX2Vycikge1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIHdhaXRPbmUoKSB7XG4gICAgICAgIGF3YWl0IHRoaXMuYWN0KGFzeW5jICgpID0+IGF3YWl0IHRoaXMuaW50ZXJuYWxXYWl0T25lKCkpO1xuICAgIH1cbiAgICBhc3luYyB3YWl0QWxsKCkge1xuICAgICAgICB3aGlsZSAodGhpcy5zY2hlZHVsZWRUYXNrcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLndhaXRPbmUoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXBvcnQoKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAuLi50aGlzLnRyaWdnZXJlZFRhc2tzLFxuICAgICAgICAgICAgLi4udGhpcy5zY2hlZHVsZWRUYXNrcy5tYXAoKHQpID0+ICh7XG4gICAgICAgICAgICAgICAgc3RhdHVzOiAncGVuZGluZycsXG4gICAgICAgICAgICAgICAgc2NoZWR1bGluZ1R5cGU6IHQuc2NoZWR1bGluZ1R5cGUsXG4gICAgICAgICAgICAgICAgdGFza0lkOiB0LnRhc2tJZCxcbiAgICAgICAgICAgICAgICBsYWJlbDogdC5sYWJlbCxcbiAgICAgICAgICAgICAgICBtZXRhZGF0YTogdC5tZXRhZGF0YSxcbiAgICAgICAgICAgIH0pKSxcbiAgICAgICAgXTtcbiAgICB9XG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiAoJ3NjaGVkdWxlckZvcigpYFxcbicgK1xuICAgICAgICAgICAgdGhpcy5yZXBvcnQoKVxuICAgICAgICAgICAgICAgIC5tYXAoU2NoZWR1bGVySW1wbGVtLmJ1aWxkTG9nKVxuICAgICAgICAgICAgICAgIC5tYXAoKGxvZykgPT4gYC0+ICR7bG9nfWApXG4gICAgICAgICAgICAgICAgLmpvaW4oJ1xcbicpICtcbiAgICAgICAgICAgICdgJyk7XG4gICAgfVxuICAgIFtzeW1ib2xzXzEuY2xvbmVNZXRob2RdKCkge1xuICAgICAgICByZXR1cm4gbmV3IFNjaGVkdWxlckltcGxlbSh0aGlzLmFjdCwgdGhpcy5zb3VyY2VUYXNrU2VsZWN0b3IpO1xuICAgIH1cbn1cbmV4cG9ydHMuU2NoZWR1bGVySW1wbGVtID0gU2NoZWR1bGVySW1wbGVtO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmNoYXJzVG9TdHJpbmdVbm1hcHBlciA9IGV4cG9ydHMuY2hhcnNUb1N0cmluZ01hcHBlciA9IHZvaWQgMDtcbmZ1bmN0aW9uIGNoYXJzVG9TdHJpbmdNYXBwZXIodGFiKSB7XG4gICAgcmV0dXJuIHRhYi5qb2luKCcnKTtcbn1cbmV4cG9ydHMuY2hhcnNUb1N0cmluZ01hcHBlciA9IGNoYXJzVG9TdHJpbmdNYXBwZXI7XG5mdW5jdGlvbiBjaGFyc1RvU3RyaW5nVW5tYXBwZXIodmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnc3RyaW5nJykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCB1bm1hcCB0aGUgcGFzc2VkIHZhbHVlJyk7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZS5zcGxpdCgnJyk7XG59XG5leHBvcnRzLmNoYXJzVG9TdHJpbmdVbm1hcHBlciA9IGNoYXJzVG9TdHJpbmdVbm1hcHBlcjtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5jb2RlUG9pbnRzVG9TdHJpbmdVbm1hcHBlciA9IGV4cG9ydHMuY29kZVBvaW50c1RvU3RyaW5nTWFwcGVyID0gdm9pZCAwO1xuZnVuY3Rpb24gY29kZVBvaW50c1RvU3RyaW5nTWFwcGVyKHRhYikge1xuICAgIHJldHVybiB0YWIuam9pbignJyk7XG59XG5leHBvcnRzLmNvZGVQb2ludHNUb1N0cmluZ01hcHBlciA9IGNvZGVQb2ludHNUb1N0cmluZ01hcHBlcjtcbmZ1bmN0aW9uIGNvZGVQb2ludHNUb1N0cmluZ1VubWFwcGVyKHZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgdW5tYXAgdGhlIHBhc3NlZCB2YWx1ZScpO1xuICAgIH1cbiAgICByZXR1cm4gWy4uLnZhbHVlXTtcbn1cbmV4cG9ydHMuY29kZVBvaW50c1RvU3RyaW5nVW5tYXBwZXIgPSBjb2RlUG9pbnRzVG9TdHJpbmdVbm1hcHBlcjtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5ub1RyYWlsaW5nVW5tYXBwZXIgPSBleHBvcnRzLm5vVHJhaWxpbmdNYXBwZXIgPSBleHBvcnRzLnNpbmdsZVRyYWlsaW5nVW5tYXBwZXIgPSBleHBvcnRzLnNpbmdsZVRyYWlsaW5nTWFwcGVyID0gZXhwb3J0cy5tdWx0aVRyYWlsaW5nVW5tYXBwZXJPbmUgPSBleHBvcnRzLm11bHRpVHJhaWxpbmdNYXBwZXJPbmUgPSBleHBvcnRzLm11bHRpVHJhaWxpbmdVbm1hcHBlciA9IGV4cG9ydHMubXVsdGlUcmFpbGluZ01hcHBlciA9IGV4cG9ydHMub25seVRyYWlsaW5nVW5tYXBwZXIgPSBleHBvcnRzLm9ubHlUcmFpbGluZ01hcHBlciA9IGV4cG9ydHMuZnVsbHlTcGVjaWZpZWRVbm1hcHBlciA9IGV4cG9ydHMuZnVsbHlTcGVjaWZpZWRNYXBwZXIgPSB2b2lkIDA7XG5mdW5jdGlvbiByZWFkQmgodmFsdWUpIHtcbiAgICBpZiAodmFsdWUubGVuZ3RoID09PSAwKVxuICAgICAgICByZXR1cm4gW107XG4gICAgZWxzZVxuICAgICAgICByZXR1cm4gdmFsdWUuc3BsaXQoJzonKTtcbn1cbmZ1bmN0aW9uIGV4dHJhY3RFaEFuZEwodmFsdWUpIHtcbiAgICBjb25zdCB2YWx1ZVNwbGl0cyA9IHZhbHVlLnNwbGl0KCc6Jyk7XG4gICAgaWYgKHZhbHVlU3BsaXRzLmxlbmd0aCA+PSAyICYmIHZhbHVlU3BsaXRzW3ZhbHVlU3BsaXRzLmxlbmd0aCAtIDFdLmxlbmd0aCA8PSA0KSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB2YWx1ZVNwbGl0cy5zbGljZSgwLCB2YWx1ZVNwbGl0cy5sZW5ndGggLSAyKSxcbiAgICAgICAgICAgIGAke3ZhbHVlU3BsaXRzW3ZhbHVlU3BsaXRzLmxlbmd0aCAtIDJdfToke3ZhbHVlU3BsaXRzW3ZhbHVlU3BsaXRzLmxlbmd0aCAtIDFdfWAsXG4gICAgICAgIF07XG4gICAgfVxuICAgIHJldHVybiBbdmFsdWVTcGxpdHMuc2xpY2UoMCwgdmFsdWVTcGxpdHMubGVuZ3RoIC0gMSksIHZhbHVlU3BsaXRzW3ZhbHVlU3BsaXRzLmxlbmd0aCAtIDFdXTtcbn1cbmZ1bmN0aW9uIGZ1bGx5U3BlY2lmaWVkTWFwcGVyKGRhdGEpIHtcbiAgICByZXR1cm4gYCR7ZGF0YVswXS5qb2luKCc6Jyl9OiR7ZGF0YVsxXX1gO1xufVxuZXhwb3J0cy5mdWxseVNwZWNpZmllZE1hcHBlciA9IGZ1bGx5U3BlY2lmaWVkTWFwcGVyO1xuZnVuY3Rpb24gZnVsbHlTcGVjaWZpZWRVbm1hcHBlcih2YWx1ZSkge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdzdHJpbmcnKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgdHlwZScpO1xuICAgIHJldHVybiBleHRyYWN0RWhBbmRMKHZhbHVlKTtcbn1cbmV4cG9ydHMuZnVsbHlTcGVjaWZpZWRVbm1hcHBlciA9IGZ1bGx5U3BlY2lmaWVkVW5tYXBwZXI7XG5mdW5jdGlvbiBvbmx5VHJhaWxpbmdNYXBwZXIoZGF0YSkge1xuICAgIHJldHVybiBgOjoke2RhdGFbMF0uam9pbignOicpfToke2RhdGFbMV19YDtcbn1cbmV4cG9ydHMub25seVRyYWlsaW5nTWFwcGVyID0gb25seVRyYWlsaW5nTWFwcGVyO1xuZnVuY3Rpb24gb25seVRyYWlsaW5nVW5tYXBwZXIodmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnc3RyaW5nJylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHR5cGUnKTtcbiAgICBpZiAoIXZhbHVlLnN0YXJ0c1dpdGgoJzo6JykpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCB2YWx1ZScpO1xuICAgIHJldHVybiBleHRyYWN0RWhBbmRMKHZhbHVlLnN1YnN0cmluZygyKSk7XG59XG5leHBvcnRzLm9ubHlUcmFpbGluZ1VubWFwcGVyID0gb25seVRyYWlsaW5nVW5tYXBwZXI7XG5mdW5jdGlvbiBtdWx0aVRyYWlsaW5nTWFwcGVyKGRhdGEpIHtcbiAgICByZXR1cm4gYCR7ZGF0YVswXS5qb2luKCc6Jyl9Ojoke2RhdGFbMV0uam9pbignOicpfToke2RhdGFbMl19YDtcbn1cbmV4cG9ydHMubXVsdGlUcmFpbGluZ01hcHBlciA9IG11bHRpVHJhaWxpbmdNYXBwZXI7XG5mdW5jdGlvbiBtdWx0aVRyYWlsaW5nVW5tYXBwZXIodmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnc3RyaW5nJylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHR5cGUnKTtcbiAgICBjb25zdCBbYmhTdHJpbmcsIHRyYWlsaW5nU3RyaW5nXSA9IHZhbHVlLnNwbGl0KCc6OicsIDIpO1xuICAgIGNvbnN0IFtlaCwgbF0gPSBleHRyYWN0RWhBbmRMKHRyYWlsaW5nU3RyaW5nKTtcbiAgICByZXR1cm4gW3JlYWRCaChiaFN0cmluZyksIGVoLCBsXTtcbn1cbmV4cG9ydHMubXVsdGlUcmFpbGluZ1VubWFwcGVyID0gbXVsdGlUcmFpbGluZ1VubWFwcGVyO1xuZnVuY3Rpb24gbXVsdGlUcmFpbGluZ01hcHBlck9uZShkYXRhKSB7XG4gICAgcmV0dXJuIG11bHRpVHJhaWxpbmdNYXBwZXIoW2RhdGFbMF0sIFtkYXRhWzFdXSwgZGF0YVsyXV0pO1xufVxuZXhwb3J0cy5tdWx0aVRyYWlsaW5nTWFwcGVyT25lID0gbXVsdGlUcmFpbGluZ01hcHBlck9uZTtcbmZ1bmN0aW9uIG11bHRpVHJhaWxpbmdVbm1hcHBlck9uZSh2YWx1ZSkge1xuICAgIGNvbnN0IG91dCA9IG11bHRpVHJhaWxpbmdVbm1hcHBlcih2YWx1ZSk7XG4gICAgcmV0dXJuIFtvdXRbMF0sIG91dFsxXS5qb2luKCc6JyksIG91dFsyXV07XG59XG5leHBvcnRzLm11bHRpVHJhaWxpbmdVbm1hcHBlck9uZSA9IG11bHRpVHJhaWxpbmdVbm1hcHBlck9uZTtcbmZ1bmN0aW9uIHNpbmdsZVRyYWlsaW5nTWFwcGVyKGRhdGEpIHtcbiAgICByZXR1cm4gYCR7ZGF0YVswXS5qb2luKCc6Jyl9Ojoke2RhdGFbMV19YDtcbn1cbmV4cG9ydHMuc2luZ2xlVHJhaWxpbmdNYXBwZXIgPSBzaW5nbGVUcmFpbGluZ01hcHBlcjtcbmZ1bmN0aW9uIHNpbmdsZVRyYWlsaW5nVW5tYXBwZXIodmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnc3RyaW5nJylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHR5cGUnKTtcbiAgICBjb25zdCBbYmhTdHJpbmcsIHRyYWlsaW5nXSA9IHZhbHVlLnNwbGl0KCc6OicsIDIpO1xuICAgIHJldHVybiBbcmVhZEJoKGJoU3RyaW5nKSwgdHJhaWxpbmddO1xufVxuZXhwb3J0cy5zaW5nbGVUcmFpbGluZ1VubWFwcGVyID0gc2luZ2xlVHJhaWxpbmdVbm1hcHBlcjtcbmZ1bmN0aW9uIG5vVHJhaWxpbmdNYXBwZXIoZGF0YSkge1xuICAgIHJldHVybiBgJHtkYXRhWzBdLmpvaW4oJzonKX06OmA7XG59XG5leHBvcnRzLm5vVHJhaWxpbmdNYXBwZXIgPSBub1RyYWlsaW5nTWFwcGVyO1xuZnVuY3Rpb24gbm9UcmFpbGluZ1VubWFwcGVyKHZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ3N0cmluZycpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCB0eXBlJyk7XG4gICAgaWYgKCF2YWx1ZS5lbmRzV2l0aCgnOjonKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHZhbHVlJyk7XG4gICAgcmV0dXJuIFtyZWFkQmgodmFsdWUuc3Vic3RyaW5nKDAsIHZhbHVlLmxlbmd0aCAtIDIpKV07XG59XG5leHBvcnRzLm5vVHJhaWxpbmdVbm1hcHBlciA9IG5vVHJhaWxpbmdVbm1hcHBlcjtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5pbmRleFRvQ2hhclN0cmluZ1VubWFwcGVyID0gZXhwb3J0cy5pbmRleFRvQ2hhclN0cmluZ01hcHBlciA9IHZvaWQgMDtcbmV4cG9ydHMuaW5kZXhUb0NoYXJTdHJpbmdNYXBwZXIgPSBTdHJpbmcuZnJvbUNvZGVQb2ludDtcbmZ1bmN0aW9uIGluZGV4VG9DaGFyU3RyaW5nVW5tYXBwZXIoYykge1xuICAgIGlmICh0eXBlb2YgYyAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgdW5tYXAgbm9uLXN0cmluZycpO1xuICAgIH1cbiAgICBpZiAoYy5sZW5ndGggPT09IDAgfHwgYy5sZW5ndGggPiAyKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IHVubWFwIHN0cmluZyB3aXRoIG1vcmUgb3IgbGVzcyB0aGFuIG9uZSBjaGFyYWN0ZXInKTtcbiAgICB9XG4gICAgY29uc3QgYzEgPSBjLmNoYXJDb2RlQXQoMCk7XG4gICAgaWYgKGMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIHJldHVybiBjMTtcbiAgICB9XG4gICAgY29uc3QgYzIgPSBjLmNoYXJDb2RlQXQoMSk7XG4gICAgaWYgKGMxIDwgMHhkODAwIHx8IGMxID4gMHhkYmZmIHx8IGMyIDwgMHhkYzAwIHx8IGMyID4gMHhkZmZmKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IHVubWFwIGludmFsaWQgc3Vycm9nYXRlIHBhaXJzJyk7XG4gICAgfVxuICAgIHJldHVybiBjLmNvZGVQb2ludEF0KDApO1xufVxuZXhwb3J0cy5pbmRleFRvQ2hhclN0cmluZ1VubWFwcGVyID0gaW5kZXhUb0NoYXJTdHJpbmdVbm1hcHBlcjtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5pbmRleFRvTWFwcGVkQ29uc3RhbnRVbm1hcHBlckZvciA9IGV4cG9ydHMuaW5kZXhUb01hcHBlZENvbnN0YW50TWFwcGVyRm9yID0gdm9pZCAwO1xuZnVuY3Rpb24gaW5kZXhUb01hcHBlZENvbnN0YW50TWFwcGVyRm9yKGVudHJpZXMpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gaW5kZXhUb01hcHBlZENvbnN0YW50TWFwcGVyKGNob2ljZUluZGV4KSB7XG4gICAgICAgIGxldCBpZHggPSAtMTtcbiAgICAgICAgbGV0IG51bVNraXBzID0gMDtcbiAgICAgICAgd2hpbGUgKGNob2ljZUluZGV4ID49IG51bVNraXBzKSB7XG4gICAgICAgICAgICBudW1Ta2lwcyArPSBlbnRyaWVzWysraWR4XS5udW07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGVudHJpZXNbaWR4XS5idWlsZChjaG9pY2VJbmRleCAtIG51bVNraXBzICsgZW50cmllc1tpZHhdLm51bSk7XG4gICAgfTtcbn1cbmV4cG9ydHMuaW5kZXhUb01hcHBlZENvbnN0YW50TWFwcGVyRm9yID0gaW5kZXhUb01hcHBlZENvbnN0YW50TWFwcGVyRm9yO1xuZnVuY3Rpb24gYnVpbGRSZXZlcnNlTWFwcGluZyhlbnRyaWVzKSB7XG4gICAgY29uc3QgcmV2ZXJzZU1hcHBpbmcgPSB7IG1hcHBpbmc6IG5ldyBNYXAoKSwgbmVnYXRpdmVaZXJvSW5kZXg6IHVuZGVmaW5lZCB9O1xuICAgIGxldCBjaG9pY2VJbmRleCA9IDA7XG4gICAgZm9yIChsZXQgZW50cnlJZHggPSAwOyBlbnRyeUlkeCAhPT0gZW50cmllcy5sZW5ndGg7ICsrZW50cnlJZHgpIHtcbiAgICAgICAgY29uc3QgZW50cnkgPSBlbnRyaWVzW2VudHJ5SWR4XTtcbiAgICAgICAgZm9yIChsZXQgaWR4SW5FbnRyeSA9IDA7IGlkeEluRW50cnkgIT09IGVudHJ5Lm51bTsgKytpZHhJbkVudHJ5KSB7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IGVudHJ5LmJ1aWxkKGlkeEluRW50cnkpO1xuICAgICAgICAgICAgaWYgKHZhbHVlID09PSAwICYmIDEgLyB2YWx1ZSA9PT0gTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZKSB7XG4gICAgICAgICAgICAgICAgcmV2ZXJzZU1hcHBpbmcubmVnYXRpdmVaZXJvSW5kZXggPSBjaG9pY2VJbmRleDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldmVyc2VNYXBwaW5nLm1hcHBpbmcuc2V0KHZhbHVlLCBjaG9pY2VJbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICArK2Nob2ljZUluZGV4O1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXZlcnNlTWFwcGluZztcbn1cbmZ1bmN0aW9uIGluZGV4VG9NYXBwZWRDb25zdGFudFVubWFwcGVyRm9yKGVudHJpZXMpIHtcbiAgICBsZXQgcmV2ZXJzZU1hcHBpbmcgPSBudWxsO1xuICAgIHJldHVybiBmdW5jdGlvbiBpbmRleFRvTWFwcGVkQ29uc3RhbnRVbm1hcHBlcih2YWx1ZSkge1xuICAgICAgICBpZiAocmV2ZXJzZU1hcHBpbmcgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldmVyc2VNYXBwaW5nID0gYnVpbGRSZXZlcnNlTWFwcGluZyhlbnRyaWVzKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjaG9pY2VJbmRleCA9IE9iamVjdC5pcyh2YWx1ZSwgLTApID8gcmV2ZXJzZU1hcHBpbmcubmVnYXRpdmVaZXJvSW5kZXggOiByZXZlcnNlTWFwcGluZy5tYXBwaW5nLmdldCh2YWx1ZSk7XG4gICAgICAgIGlmIChjaG9pY2VJbmRleCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gdmFsdWUgZW5jb3VudGVyZWQgY2Fubm90IGJlIGJ1aWx0IHVzaW5nIHRoaXMgbWFwVG9Db25zdGFudCcpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjaG9pY2VJbmRleDtcbiAgICB9O1xufVxuZXhwb3J0cy5pbmRleFRvTWFwcGVkQ29uc3RhbnRVbm1hcHBlckZvciA9IGluZGV4VG9NYXBwZWRDb25zdGFudFVubWFwcGVyRm9yO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmluZGV4VG9QcmludGFibGVJbmRleFVubWFwcGVyID0gZXhwb3J0cy5pbmRleFRvUHJpbnRhYmxlSW5kZXhNYXBwZXIgPSB2b2lkIDA7XG5mdW5jdGlvbiBpbmRleFRvUHJpbnRhYmxlSW5kZXhNYXBwZXIodikge1xuICAgIGlmICh2IDwgOTUpXG4gICAgICAgIHJldHVybiB2ICsgMHgyMDtcbiAgICBpZiAodiA8PSAweDdlKVxuICAgICAgICByZXR1cm4gdiAtIDk1O1xuICAgIHJldHVybiB2O1xufVxuZXhwb3J0cy5pbmRleFRvUHJpbnRhYmxlSW5kZXhNYXBwZXIgPSBpbmRleFRvUHJpbnRhYmxlSW5kZXhNYXBwZXI7XG5mdW5jdGlvbiBpbmRleFRvUHJpbnRhYmxlSW5kZXhVbm1hcHBlcih2KSB7XG4gICAgaWYgKHYgPj0gMHgyMCAmJiB2IDw9IDB4N2UpXG4gICAgICAgIHJldHVybiB2IC0gMHgyMDtcbiAgICBpZiAodiA+PSAwICYmIHYgPD0gMHgxZilcbiAgICAgICAgcmV0dXJuIHYgKyA5NTtcbiAgICByZXR1cm4gdjtcbn1cbmV4cG9ydHMuaW5kZXhUb1ByaW50YWJsZUluZGV4VW5tYXBwZXIgPSBpbmRleFRvUHJpbnRhYmxlSW5kZXhVbm1hcHBlcjtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5rZXlWYWx1ZVBhaXJzVG9PYmplY3RVbm1hcHBlciA9IGV4cG9ydHMua2V5VmFsdWVQYWlyc1RvT2JqZWN0TWFwcGVyID0gdm9pZCAwO1xuZnVuY3Rpb24ga2V5VmFsdWVQYWlyc1RvT2JqZWN0TWFwcGVyKGl0ZW1zKSB7XG4gICAgY29uc3Qgb2JqID0ge307XG4gICAgZm9yIChjb25zdCBrZXlWYWx1ZSBvZiBpdGVtcykge1xuICAgICAgICBvYmpba2V5VmFsdWVbMF1dID0ga2V5VmFsdWVbMV07XG4gICAgfVxuICAgIHJldHVybiBvYmo7XG59XG5leHBvcnRzLmtleVZhbHVlUGFpcnNUb09iamVjdE1hcHBlciA9IGtleVZhbHVlUGFpcnNUb09iamVjdE1hcHBlcjtcbmZ1bmN0aW9uIGJ1aWxkSW52YWxpZFByb3BlcnR5TmFtZUZpbHRlcihvYmopIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gaW52YWxpZFByb3BlcnR5TmFtZUZpbHRlcihrZXkpIHtcbiAgICAgICAgY29uc3QgZGVzY3JpcHRvciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqLCBrZXkpO1xuICAgICAgICByZXR1cm4gKGRlc2NyaXB0b3IgPT09IHVuZGVmaW5lZCB8fFxuICAgICAgICAgICAgIWRlc2NyaXB0b3IuY29uZmlndXJhYmxlIHx8XG4gICAgICAgICAgICAhZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8XG4gICAgICAgICAgICAhZGVzY3JpcHRvci53cml0YWJsZSB8fFxuICAgICAgICAgICAgZGVzY3JpcHRvci5nZXQgIT09IHVuZGVmaW5lZCB8fFxuICAgICAgICAgICAgZGVzY3JpcHRvci5zZXQgIT09IHVuZGVmaW5lZCk7XG4gICAgfTtcbn1cbmZ1bmN0aW9uIGtleVZhbHVlUGFpcnNUb09iamVjdFVubWFwcGVyKHZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ29iamVjdCcgfHwgdmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbmNvbXBhdGlibGUgaW5zdGFuY2UgcmVjZWl2ZWQ6IHNob3VsZCBiZSBhIG5vbi1udWxsIG9iamVjdCcpO1xuICAgIH1cbiAgICBpZiAoISgnY29uc3RydWN0b3InIGluIHZhbHVlKSB8fCB2YWx1ZS5jb25zdHJ1Y3RvciAhPT0gT2JqZWN0KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW5jb21wYXRpYmxlIGluc3RhbmNlIHJlY2VpdmVkOiBzaG91bGQgYmUgb2YgZXhhY3QgdHlwZSBPYmplY3QnKTtcbiAgICB9XG4gICAgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHModmFsdWUpLmxlbmd0aCA+IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbmNvbXBhdGlibGUgaW5zdGFuY2UgcmVjZWl2ZWQ6IHNob3VsZCBjb250YWluIHN5bWJvbHMnKTtcbiAgICB9XG4gICAgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHZhbHVlKS5maW5kKGJ1aWxkSW52YWxpZFByb3BlcnR5TmFtZUZpbHRlcih2YWx1ZSkpICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbmNvbXBhdGlibGUgaW5zdGFuY2UgcmVjZWl2ZWQ6IHNob3VsZCBjb250YWluIG9ubHkgYy9lL3cgcHJvcGVydGllcyB3aXRob3V0IGdldC9zZXQnKTtcbiAgICB9XG4gICAgcmV0dXJuIE9iamVjdC5lbnRyaWVzKHZhbHVlKTtcbn1cbmV4cG9ydHMua2V5VmFsdWVQYWlyc1RvT2JqZWN0VW5tYXBwZXIgPSBrZXlWYWx1ZVBhaXJzVG9PYmplY3RVbm1hcHBlcjtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5uYXRUb1N0cmluZ2lmaWVkTmF0VW5tYXBwZXIgPSBleHBvcnRzLnRyeVBhcnNlU3RyaW5naWZpZWROYXQgPSBleHBvcnRzLm5hdFRvU3RyaW5naWZpZWROYXRNYXBwZXIgPSB2b2lkIDA7XG5mdW5jdGlvbiBuYXRUb1N0cmluZ2lmaWVkTmF0TWFwcGVyKG9wdGlvbnMpIHtcbiAgICBjb25zdCBbc3R5bGUsIHZdID0gb3B0aW9ucztcbiAgICBzd2l0Y2ggKHN0eWxlKSB7XG4gICAgICAgIGNhc2UgJ29jdCc6XG4gICAgICAgICAgICByZXR1cm4gYDAke051bWJlcih2KS50b1N0cmluZyg4KX1gO1xuICAgICAgICBjYXNlICdoZXgnOlxuICAgICAgICAgICAgcmV0dXJuIGAweCR7TnVtYmVyKHYpLnRvU3RyaW5nKDE2KX1gO1xuICAgICAgICBjYXNlICdkZWMnOlxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIGAke3Z9YDtcbiAgICB9XG59XG5leHBvcnRzLm5hdFRvU3RyaW5naWZpZWROYXRNYXBwZXIgPSBuYXRUb1N0cmluZ2lmaWVkTmF0TWFwcGVyO1xuZnVuY3Rpb24gdHJ5UGFyc2VTdHJpbmdpZmllZE5hdChzdHJpbmdWYWx1ZSwgcmFkaXgpIHtcbiAgICBjb25zdCBwYXJzZWROYXQgPSBOdW1iZXIucGFyc2VJbnQoc3RyaW5nVmFsdWUsIHJhZGl4KTtcbiAgICBpZiAocGFyc2VkTmF0LnRvU3RyaW5nKHJhZGl4KSAhPT0gc3RyaW5nVmFsdWUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHZhbHVlJyk7XG4gICAgfVxuICAgIHJldHVybiBwYXJzZWROYXQ7XG59XG5leHBvcnRzLnRyeVBhcnNlU3RyaW5naWZpZWROYXQgPSB0cnlQYXJzZVN0cmluZ2lmaWVkTmF0O1xuZnVuY3Rpb24gbmF0VG9TdHJpbmdpZmllZE5hdFVubWFwcGVyKHZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHR5cGUnKTtcbiAgICB9XG4gICAgaWYgKHZhbHVlLmxlbmd0aCA+PSAyICYmIHZhbHVlWzBdID09PSAnMCcpIHtcbiAgICAgICAgaWYgKHZhbHVlWzFdID09PSAneCcpIHtcbiAgICAgICAgICAgIHJldHVybiBbJ2hleCcsIHRyeVBhcnNlU3RyaW5naWZpZWROYXQodmFsdWUuc3Vic3RyKDIpLCAxNildO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbJ29jdCcsIHRyeVBhcnNlU3RyaW5naWZpZWROYXQodmFsdWUuc3Vic3RyKDEpLCA4KV07XG4gICAgfVxuICAgIHJldHVybiBbJ2RlYycsIHRyeVBhcnNlU3RyaW5naWZpZWROYXQodmFsdWUsIDEwKV07XG59XG5leHBvcnRzLm5hdFRvU3RyaW5naWZpZWROYXRVbm1hcHBlciA9IG5hdFRvU3RyaW5naWZpZWROYXRVbm1hcHBlcjtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5wYXR0ZXJuc1RvU3RyaW5nVW5tYXBwZXJGb3IgPSBleHBvcnRzLnBhdHRlcm5zVG9TdHJpbmdNYXBwZXIgPSB2b2lkIDA7XG5jb25zdCBNYXhMZW5ndGhGcm9tTWluTGVuZ3RoXzEgPSByZXF1aXJlKFwiLi4vaGVscGVycy9NYXhMZW5ndGhGcm9tTWluTGVuZ3RoXCIpO1xuZnVuY3Rpb24gcGF0dGVybnNUb1N0cmluZ01hcHBlcih0YWIpIHtcbiAgICByZXR1cm4gdGFiLmpvaW4oJycpO1xufVxuZXhwb3J0cy5wYXR0ZXJuc1RvU3RyaW5nTWFwcGVyID0gcGF0dGVybnNUb1N0cmluZ01hcHBlcjtcbmZ1bmN0aW9uIHBhdHRlcm5zVG9TdHJpbmdVbm1hcHBlckZvcihwYXR0ZXJuc0FyYiwgY29uc3RyYWludHMpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gcGF0dGVybnNUb1N0cmluZ1VubWFwcGVyKHZhbHVlKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vuc3VwcG9ydGVkIHZhbHVlJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbWluTGVuZ3RoID0gY29uc3RyYWludHMubWluTGVuZ3RoICE9PSB1bmRlZmluZWQgPyBjb25zdHJhaW50cy5taW5MZW5ndGggOiAwO1xuICAgICAgICBjb25zdCBtYXhMZW5ndGggPSBjb25zdHJhaW50cy5tYXhMZW5ndGggIT09IHVuZGVmaW5lZCA/IGNvbnN0cmFpbnRzLm1heExlbmd0aCA6IE1heExlbmd0aEZyb21NaW5MZW5ndGhfMS5tYXhMZW5ndGhGcm9tTWluTGVuZ3RoKG1pbkxlbmd0aCk7XG4gICAgICAgIGlmICh2YWx1ZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIGlmIChtaW5MZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmFibGUgdG8gdW5tYXAgcmVjZWl2ZWQgc3RyaW5nJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc3RhY2sgPSBbeyBlbmRJbmRleENodW5rczogMCwgbmV4dFN0YXJ0SW5kZXg6IDEsIGNodW5rczogW10gfV07XG4gICAgICAgIHdoaWxlIChzdGFjay5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBjb25zdCBsYXN0ID0gc3RhY2sucG9wKCk7XG4gICAgICAgICAgICBmb3IgKGxldCBpbmRleCA9IGxhc3QubmV4dFN0YXJ0SW5kZXg7IGluZGV4IDw9IHZhbHVlLmxlbmd0aDsgKytpbmRleCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNodW5rID0gdmFsdWUuc3Vic3RyaW5nKGxhc3QuZW5kSW5kZXhDaHVua3MsIGluZGV4KTtcbiAgICAgICAgICAgICAgICBpZiAocGF0dGVybnNBcmIuY2FuU2hyaW5rV2l0aG91dENvbnRleHQoY2h1bmspKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG5ld0NodW5rcyA9IGxhc3QuY2h1bmtzLmNvbmNhdChbY2h1bmtdKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGluZGV4ID09PSB2YWx1ZS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuZXdDaHVua3MubGVuZ3RoIDwgbWluTGVuZ3RoIHx8IG5ld0NodW5rcy5sZW5ndGggPiBtYXhMZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXdDaHVua3M7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgc3RhY2sucHVzaCh7IGVuZEluZGV4Q2h1bmtzOiBsYXN0LmVuZEluZGV4Q2h1bmtzLCBuZXh0U3RhcnRJbmRleDogaW5kZXggKyAxLCBjaHVua3M6IGxhc3QuY2h1bmtzIH0pO1xuICAgICAgICAgICAgICAgICAgICBzdGFjay5wdXNoKHsgZW5kSW5kZXhDaHVua3M6IGluZGV4LCBuZXh0U3RhcnRJbmRleDogaW5kZXggKyAxLCBjaHVua3M6IG5ld0NodW5rcyB9KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVW5hYmxlIHRvIHVubWFwIHJlY2VpdmVkIHN0cmluZycpO1xuICAgIH07XG59XG5leHBvcnRzLnBhdHRlcm5zVG9TdHJpbmdVbm1hcHBlckZvciA9IHBhdHRlcm5zVG9TdHJpbmdVbm1hcHBlckZvcjtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5zdHJpbmdUb0Jhc2U2NFVubWFwcGVyID0gZXhwb3J0cy5zdHJpbmdUb0Jhc2U2NE1hcHBlciA9IHZvaWQgMDtcbmZ1bmN0aW9uIHN0cmluZ1RvQmFzZTY0TWFwcGVyKHMpIHtcbiAgICBzd2l0Y2ggKHMubGVuZ3RoICUgNCkge1xuICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICByZXR1cm4gcztcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgcmV0dXJuIGAke3N9PWA7XG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgIHJldHVybiBgJHtzfT09YDtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBzLnNsaWNlKDEpO1xuICAgIH1cbn1cbmV4cG9ydHMuc3RyaW5nVG9CYXNlNjRNYXBwZXIgPSBzdHJpbmdUb0Jhc2U2NE1hcHBlcjtcbmZ1bmN0aW9uIHN0cmluZ1RvQmFzZTY0VW5tYXBwZXIodmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnc3RyaW5nJyB8fCB2YWx1ZS5sZW5ndGggJSA0ICE9PSAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzdHJpbmcgcmVjZWl2ZWQnKTtcbiAgICB9XG4gICAgY29uc3QgbGFzdFRyYWlsaW5nSW5kZXggPSB2YWx1ZS5pbmRleE9mKCc9Jyk7XG4gICAgaWYgKGxhc3RUcmFpbGluZ0luZGV4ID09PSAtMSkge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIGNvbnN0IG51bVRyYWlsaW5ncyA9IHZhbHVlLmxlbmd0aCAtIGxhc3RUcmFpbGluZ0luZGV4O1xuICAgIGlmIChudW1UcmFpbGluZ3MgPiAyKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IHVubWFwIHRoZSBwYXNzZWQgdmFsdWUnKTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlLnN1YnN0cmluZygwLCBsYXN0VHJhaWxpbmdJbmRleCk7XG59XG5leHBvcnRzLnN0cmluZ1RvQmFzZTY0VW5tYXBwZXIgPSBzdHJpbmdUb0Jhc2U2NFVubWFwcGVyO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnRpbWVUb0RhdGVVbm1hcHBlciA9IGV4cG9ydHMudGltZVRvRGF0ZU1hcHBlciA9IHZvaWQgMDtcbmZ1bmN0aW9uIHRpbWVUb0RhdGVNYXBwZXIodGltZSkge1xuICAgIHJldHVybiBuZXcgRGF0ZSh0aW1lKTtcbn1cbmV4cG9ydHMudGltZVRvRGF0ZU1hcHBlciA9IHRpbWVUb0RhdGVNYXBwZXI7XG5mdW5jdGlvbiB0aW1lVG9EYXRlVW5tYXBwZXIodmFsdWUpIHtcbiAgICBpZiAoISh2YWx1ZSBpbnN0YW5jZW9mIERhdGUpIHx8IHZhbHVlLmNvbnN0cnVjdG9yICE9PSBEYXRlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTm90IGEgdmFsaWQgdmFsdWUgZm9yIGRhdGUgdW5tYXBwZXInKTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlLmdldFRpbWUoKTtcbn1cbmV4cG9ydHMudGltZVRvRGF0ZVVubWFwcGVyID0gdGltZVRvRGF0ZVVubWFwcGVyO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmJ1aWxkVmFsdWVzQW5kU2VwYXJhdGVLZXlzVG9PYmplY3RVbm1hcHBlciA9IGV4cG9ydHMuYnVpbGRWYWx1ZXNBbmRTZXBhcmF0ZUtleXNUb09iamVjdE1hcHBlciA9IHZvaWQgMDtcbmZ1bmN0aW9uIGJ1aWxkVmFsdWVzQW5kU2VwYXJhdGVLZXlzVG9PYmplY3RNYXBwZXIoa2V5cywgbm9LZXlWYWx1ZSkge1xuICAgIHJldHVybiBmdW5jdGlvbiB2YWx1ZXNBbmRTZXBhcmF0ZUtleXNUb09iamVjdE1hcHBlcihncykge1xuICAgICAgICBjb25zdCBvYmogPSB7fTtcbiAgICAgICAgZm9yIChsZXQgaWR4ID0gMDsgaWR4ICE9PSBrZXlzLmxlbmd0aDsgKytpZHgpIHtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlV3JhcHBlciA9IGdzW2lkeF07XG4gICAgICAgICAgICBpZiAodmFsdWVXcmFwcGVyICE9PSBub0tleVZhbHVlKSB7XG4gICAgICAgICAgICAgICAgb2JqW2tleXNbaWR4XV0gPSB2YWx1ZVdyYXBwZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9O1xufVxuZXhwb3J0cy5idWlsZFZhbHVlc0FuZFNlcGFyYXRlS2V5c1RvT2JqZWN0TWFwcGVyID0gYnVpbGRWYWx1ZXNBbmRTZXBhcmF0ZUtleXNUb09iamVjdE1hcHBlcjtcbmZ1bmN0aW9uIGJ1aWxkVmFsdWVzQW5kU2VwYXJhdGVLZXlzVG9PYmplY3RVbm1hcHBlcihrZXlzLCBub0tleVZhbHVlKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIHZhbHVlc0FuZFNlcGFyYXRlS2V5c1RvT2JqZWN0VW5tYXBwZXIodmFsdWUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ29iamVjdCcgfHwgdmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW5jb21wYXRpYmxlIGluc3RhbmNlIHJlY2VpdmVkOiBzaG91bGQgYmUgYSBub24tbnVsbCBvYmplY3QnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoISgnY29uc3RydWN0b3InIGluIHZhbHVlKSB8fCB2YWx1ZS5jb25zdHJ1Y3RvciAhPT0gT2JqZWN0KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0luY29tcGF0aWJsZSBpbnN0YW5jZSByZWNlaXZlZDogc2hvdWxkIGJlIG9mIGV4YWN0IHR5cGUgT2JqZWN0Jyk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGV4dHJhY3RlZFByb3BlcnRpZXNDb3VudCA9IDA7XG4gICAgICAgIGNvbnN0IGV4dHJhY3RlZFZhbHVlcyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpZHggPSAwOyBpZHggIT09IGtleXMubGVuZ3RoOyArK2lkeCkge1xuICAgICAgICAgICAgY29uc3QgZGVzY3JpcHRvciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodmFsdWUsIGtleXNbaWR4XSk7XG4gICAgICAgICAgICBpZiAoZGVzY3JpcHRvciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSB8fCAhZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8ICFkZXNjcmlwdG9yLndyaXRhYmxlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW5jb21wYXRpYmxlIGluc3RhbmNlIHJlY2VpdmVkOiBzaG91bGQgY29udGFpbiBvbmx5IGMvZS93IHByb3BlcnRpZXMnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGRlc2NyaXB0b3IuZ2V0ICE9PSB1bmRlZmluZWQgfHwgZGVzY3JpcHRvci5zZXQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0luY29tcGF0aWJsZSBpbnN0YW5jZSByZWNlaXZlZDogc2hvdWxkIGNvbnRhaW4gb25seSBubyBnZXQvc2V0IHByb3BlcnRpZXMnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgKytleHRyYWN0ZWRQcm9wZXJ0aWVzQ291bnQ7XG4gICAgICAgICAgICAgICAgZXh0cmFjdGVkVmFsdWVzLnB1c2goZGVzY3JpcHRvci52YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBleHRyYWN0ZWRWYWx1ZXMucHVzaChub0tleVZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBuYW1lUHJvcGVydGllc0NvdW50ID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModmFsdWUpLmxlbmd0aDtcbiAgICAgICAgY29uc3Qgc3ltYm9sUHJvcGVydGllc0NvdW50ID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyh2YWx1ZSkubGVuZ3RoO1xuICAgICAgICBpZiAoZXh0cmFjdGVkUHJvcGVydGllc0NvdW50ICE9PSBuYW1lUHJvcGVydGllc0NvdW50ICsgc3ltYm9sUHJvcGVydGllc0NvdW50KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0luY29tcGF0aWJsZSBpbnN0YW5jZSByZWNlaXZlZDogc2hvdWxkIG5vdCBjb250YWluIGV4dHJhIHByb3BlcnRpZXMnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZXh0cmFjdGVkVmFsdWVzO1xuICAgIH07XG59XG5leHBvcnRzLmJ1aWxkVmFsdWVzQW5kU2VwYXJhdGVLZXlzVG9PYmplY3RVbm1hcHBlciA9IGJ1aWxkVmFsdWVzQW5kU2VwYXJhdGVLZXlzVG9PYmplY3RVbm1hcHBlcjtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5zZW50ZW5jZXNUb1BhcmFncmFwaFVubWFwcGVyID0gZXhwb3J0cy5zZW50ZW5jZXNUb1BhcmFncmFwaE1hcHBlciA9IGV4cG9ydHMud29yZHNUb1NlbnRlbmNlVW5tYXBwZXJGb3IgPSBleHBvcnRzLndvcmRzVG9TZW50ZW5jZU1hcHBlciA9IGV4cG9ydHMud29yZHNUb0pvaW5lZFN0cmluZ1VubWFwcGVyRm9yID0gZXhwb3J0cy53b3Jkc1RvSm9pbmVkU3RyaW5nTWFwcGVyID0gdm9pZCAwO1xuZnVuY3Rpb24gd29yZHNUb0pvaW5lZFN0cmluZ01hcHBlcih3b3Jkcykge1xuICAgIHJldHVybiB3b3Jkcy5tYXAoKHcpID0+ICh3W3cubGVuZ3RoIC0gMV0gPT09ICcsJyA/IHcuc3Vic3RyKDAsIHcubGVuZ3RoIC0gMSkgOiB3KSkuam9pbignICcpO1xufVxuZXhwb3J0cy53b3Jkc1RvSm9pbmVkU3RyaW5nTWFwcGVyID0gd29yZHNUb0pvaW5lZFN0cmluZ01hcHBlcjtcbmZ1bmN0aW9uIHdvcmRzVG9Kb2luZWRTdHJpbmdVbm1hcHBlckZvcih3b3Jkc0FyYml0cmFyeSkge1xuICAgIHJldHVybiBmdW5jdGlvbiB3b3Jkc1RvSm9pbmVkU3RyaW5nVW5tYXBwZXIodmFsdWUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVW5zdXBwb3J0ZWQgdHlwZScpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHdvcmRzID0gW107XG4gICAgICAgIGZvciAoY29uc3QgY2FuZGlkYXRlIG9mIHZhbHVlLnNwbGl0KCcgJykpIHtcbiAgICAgICAgICAgIGlmICh3b3Jkc0FyYml0cmFyeS5jYW5TaHJpbmtXaXRob3V0Q29udGV4dChjYW5kaWRhdGUpKVxuICAgICAgICAgICAgICAgIHdvcmRzLnB1c2goY2FuZGlkYXRlKTtcbiAgICAgICAgICAgIGVsc2UgaWYgKHdvcmRzQXJiaXRyYXJ5LmNhblNocmlua1dpdGhvdXRDb250ZXh0KGNhbmRpZGF0ZSArICcsJykpXG4gICAgICAgICAgICAgICAgd29yZHMucHVzaChjYW5kaWRhdGUgKyAnLCcpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVW5zdXBwb3J0ZWQgd29yZCcpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB3b3JkcztcbiAgICB9O1xufVxuZXhwb3J0cy53b3Jkc1RvSm9pbmVkU3RyaW5nVW5tYXBwZXJGb3IgPSB3b3Jkc1RvSm9pbmVkU3RyaW5nVW5tYXBwZXJGb3I7XG5mdW5jdGlvbiB3b3Jkc1RvU2VudGVuY2VNYXBwZXIod29yZHMpIHtcbiAgICBsZXQgc2VudGVuY2UgPSB3b3Jkcy5qb2luKCcgJyk7XG4gICAgaWYgKHNlbnRlbmNlW3NlbnRlbmNlLmxlbmd0aCAtIDFdID09PSAnLCcpIHtcbiAgICAgICAgc2VudGVuY2UgPSBzZW50ZW5jZS5zdWJzdHIoMCwgc2VudGVuY2UubGVuZ3RoIC0gMSk7XG4gICAgfVxuICAgIHJldHVybiBzZW50ZW5jZVswXS50b1VwcGVyQ2FzZSgpICsgc2VudGVuY2Uuc3Vic3RyaW5nKDEpICsgJy4nO1xufVxuZXhwb3J0cy53b3Jkc1RvU2VudGVuY2VNYXBwZXIgPSB3b3Jkc1RvU2VudGVuY2VNYXBwZXI7XG5mdW5jdGlvbiB3b3Jkc1RvU2VudGVuY2VVbm1hcHBlckZvcih3b3Jkc0FyYml0cmFyeSkge1xuICAgIHJldHVybiBmdW5jdGlvbiB3b3Jkc1RvU2VudGVuY2VVbm1hcHBlcih2YWx1ZSkge1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbnN1cHBvcnRlZCB0eXBlJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZhbHVlLmxlbmd0aCA8IDIgfHxcbiAgICAgICAgICAgIHZhbHVlW3ZhbHVlLmxlbmd0aCAtIDFdICE9PSAnLicgfHxcbiAgICAgICAgICAgIHZhbHVlW3ZhbHVlLmxlbmd0aCAtIDJdID09PSAnLCcgfHxcbiAgICAgICAgICAgIHZhbHVlWzBdLnRvTG93ZXJDYXNlKCkudG9VcHBlckNhc2UoKSAhPT0gdmFsdWVbMF0pIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVW5zdXBwb3J0ZWQgdmFsdWUnKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhZGFwdGVkVmFsdWUgPSB2YWx1ZVswXS50b0xvd2VyQ2FzZSgpICsgdmFsdWUuc3Vic3RyaW5nKDEsIHZhbHVlLmxlbmd0aCAtIDEpO1xuICAgICAgICBjb25zdCB3b3JkcyA9IFtdO1xuICAgICAgICBjb25zdCBjYW5kaWRhdGVzID0gYWRhcHRlZFZhbHVlLnNwbGl0KCcgJyk7XG4gICAgICAgIGZvciAobGV0IGlkeCA9IDA7IGlkeCAhPT0gY2FuZGlkYXRlcy5sZW5ndGg7ICsraWR4KSB7XG4gICAgICAgICAgICBjb25zdCBjYW5kaWRhdGUgPSBjYW5kaWRhdGVzW2lkeF07XG4gICAgICAgICAgICBpZiAod29yZHNBcmJpdHJhcnkuY2FuU2hyaW5rV2l0aG91dENvbnRleHQoY2FuZGlkYXRlKSlcbiAgICAgICAgICAgICAgICB3b3Jkcy5wdXNoKGNhbmRpZGF0ZSk7XG4gICAgICAgICAgICBlbHNlIGlmIChpZHggPT09IGNhbmRpZGF0ZXMubGVuZ3RoIC0gMSAmJiB3b3Jkc0FyYml0cmFyeS5jYW5TaHJpbmtXaXRob3V0Q29udGV4dChjYW5kaWRhdGUgKyAnLCcpKVxuICAgICAgICAgICAgICAgIHdvcmRzLnB1c2goY2FuZGlkYXRlICsgJywnKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vuc3VwcG9ydGVkIHdvcmQnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gd29yZHM7XG4gICAgfTtcbn1cbmV4cG9ydHMud29yZHNUb1NlbnRlbmNlVW5tYXBwZXJGb3IgPSB3b3Jkc1RvU2VudGVuY2VVbm1hcHBlckZvcjtcbmZ1bmN0aW9uIHNlbnRlbmNlc1RvUGFyYWdyYXBoTWFwcGVyKHNlbnRlbmNlcykge1xuICAgIHJldHVybiBzZW50ZW5jZXMuam9pbignICcpO1xufVxuZXhwb3J0cy5zZW50ZW5jZXNUb1BhcmFncmFwaE1hcHBlciA9IHNlbnRlbmNlc1RvUGFyYWdyYXBoTWFwcGVyO1xuZnVuY3Rpb24gc2VudGVuY2VzVG9QYXJhZ3JhcGhVbm1hcHBlcih2YWx1ZSkge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVW5zdXBwb3J0ZWQgdHlwZScpO1xuICAgIH1cbiAgICBjb25zdCBzZW50ZW5jZXMgPSB2YWx1ZS5zcGxpdCgnLiAnKTtcbiAgICBmb3IgKGxldCBpZHggPSAwOyBpZHggPCBzZW50ZW5jZXMubGVuZ3RoIC0gMTsgKytpZHgpIHtcbiAgICAgICAgc2VudGVuY2VzW2lkeF0gKz0gJy4nO1xuICAgIH1cbiAgICByZXR1cm4gc2VudGVuY2VzO1xufVxuZXhwb3J0cy5zZW50ZW5jZXNUb1BhcmFncmFwaFVubWFwcGVyID0gc2VudGVuY2VzVG9QYXJhZ3JhcGhVbm1hcHBlcjtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5hcnJheSA9IHZvaWQgMDtcbmNvbnN0IENvbnZlcnRlcnNfMSA9IHJlcXVpcmUoXCIuLi9jaGVjay9hcmJpdHJhcnkvZGVmaW5pdGlvbi9Db252ZXJ0ZXJzXCIpO1xuY29uc3QgQXJyYXlBcmJpdHJhcnlfMSA9IHJlcXVpcmUoXCIuL19pbnRlcm5hbHMvQXJyYXlBcmJpdHJhcnlcIik7XG5jb25zdCBNYXhMZW5ndGhGcm9tTWluTGVuZ3RoXzEgPSByZXF1aXJlKFwiLi9faW50ZXJuYWxzL2hlbHBlcnMvTWF4TGVuZ3RoRnJvbU1pbkxlbmd0aFwiKTtcbmZ1bmN0aW9uIGFycmF5KGFyYiwgLi4uYXJncykge1xuICAgIGNvbnN0IG5leHRBcmIgPSBDb252ZXJ0ZXJzXzEuY29udmVydFRvTmV4dChhcmIpO1xuICAgIGlmIChhcmdzWzBdID09PSB1bmRlZmluZWQpXG4gICAgICAgIHJldHVybiBDb252ZXJ0ZXJzXzEuY29udmVydEZyb21OZXh0KG5ldyBBcnJheUFyYml0cmFyeV8xLkFycmF5QXJiaXRyYXJ5KG5leHRBcmIsIDAsIE1heExlbmd0aEZyb21NaW5MZW5ndGhfMS5tYXhMZW5ndGhGcm9tTWluTGVuZ3RoKDApKSk7XG4gICAgaWYgKHR5cGVvZiBhcmdzWzBdID09PSAnb2JqZWN0Jykge1xuICAgICAgICBjb25zdCBtaW5MZW5ndGggPSBhcmdzWzBdLm1pbkxlbmd0aCB8fCAwO1xuICAgICAgICBjb25zdCBzcGVjaWZpZWRNYXhMZW5ndGggPSBhcmdzWzBdLm1heExlbmd0aDtcbiAgICAgICAgY29uc3QgbWF4TGVuZ3RoID0gc3BlY2lmaWVkTWF4TGVuZ3RoICE9PSB1bmRlZmluZWQgPyBzcGVjaWZpZWRNYXhMZW5ndGggOiBNYXhMZW5ndGhGcm9tTWluTGVuZ3RoXzEubWF4TGVuZ3RoRnJvbU1pbkxlbmd0aChtaW5MZW5ndGgpO1xuICAgICAgICByZXR1cm4gQ29udmVydGVyc18xLmNvbnZlcnRGcm9tTmV4dChuZXcgQXJyYXlBcmJpdHJhcnlfMS5BcnJheUFyYml0cmFyeShuZXh0QXJiLCBtaW5MZW5ndGgsIG1heExlbmd0aCkpO1xuICAgIH1cbiAgICBpZiAoYXJnc1sxXSAhPT0gdW5kZWZpbmVkKVxuICAgICAgICByZXR1cm4gQ29udmVydGVyc18xLmNvbnZlcnRGcm9tTmV4dChuZXcgQXJyYXlBcmJpdHJhcnlfMS5BcnJheUFyYml0cmFyeShuZXh0QXJiLCBhcmdzWzBdLCBhcmdzWzFdKSk7XG4gICAgcmV0dXJuIENvbnZlcnRlcnNfMS5jb252ZXJ0RnJvbU5leHQobmV3IEFycmF5QXJiaXRyYXJ5XzEuQXJyYXlBcmJpdHJhcnkobmV4dEFyYiwgMCwgYXJnc1swXSkpO1xufVxuZXhwb3J0cy5hcnJheSA9IGFycmF5O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmFzY2lpID0gdm9pZCAwO1xuY29uc3QgQ2hhcmFjdGVyQXJiaXRyYXJ5QnVpbGRlcl8xID0gcmVxdWlyZShcIi4vX2ludGVybmFscy9idWlsZGVycy9DaGFyYWN0ZXJBcmJpdHJhcnlCdWlsZGVyXCIpO1xuY29uc3QgSW5kZXhUb1ByaW50YWJsZUluZGV4XzEgPSByZXF1aXJlKFwiLi9faW50ZXJuYWxzL21hcHBlcnMvSW5kZXhUb1ByaW50YWJsZUluZGV4XCIpO1xuZnVuY3Rpb24gYXNjaWkoKSB7XG4gICAgcmV0dXJuIENoYXJhY3RlckFyYml0cmFyeUJ1aWxkZXJfMS5idWlsZENoYXJhY3RlckFyYml0cmFyeSgweDAwLCAweDdmLCBJbmRleFRvUHJpbnRhYmxlSW5kZXhfMS5pbmRleFRvUHJpbnRhYmxlSW5kZXhNYXBwZXIsIEluZGV4VG9QcmludGFibGVJbmRleF8xLmluZGV4VG9QcmludGFibGVJbmRleFVubWFwcGVyKTtcbn1cbmV4cG9ydHMuYXNjaWkgPSBhc2NpaTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5hc2NpaVN0cmluZyA9IHZvaWQgMDtcbmNvbnN0IENvbnZlcnRlcnNfMSA9IHJlcXVpcmUoXCIuLi9jaGVjay9hcmJpdHJhcnkvZGVmaW5pdGlvbi9Db252ZXJ0ZXJzXCIpO1xuY29uc3QgYXJyYXlfMSA9IHJlcXVpcmUoXCIuL2FycmF5XCIpO1xuY29uc3QgYXNjaWlfMSA9IHJlcXVpcmUoXCIuL2FzY2lpXCIpO1xuY29uc3QgU3RyaW5nQ29uc3RyYWludHNFeHRyYWN0b3JfMSA9IHJlcXVpcmUoXCIuL19pbnRlcm5hbHMvaGVscGVycy9TdHJpbmdDb25zdHJhaW50c0V4dHJhY3RvclwiKTtcbmNvbnN0IENvZGVQb2ludHNUb1N0cmluZ18xID0gcmVxdWlyZShcIi4vX2ludGVybmFscy9tYXBwZXJzL0NvZGVQb2ludHNUb1N0cmluZ1wiKTtcbmZ1bmN0aW9uIGFzY2lpU3RyaW5nKC4uLmFyZ3MpIHtcbiAgICBjb25zdCBjb25zdHJhaW50cyA9IFN0cmluZ0NvbnN0cmFpbnRzRXh0cmFjdG9yXzEuZXh0cmFjdFN0cmluZ0NvbnN0cmFpbnRzKGFyZ3MpO1xuICAgIHJldHVybiBDb252ZXJ0ZXJzXzEuY29udmVydEZyb21OZXh0KENvbnZlcnRlcnNfMS5jb252ZXJ0VG9OZXh0KGFycmF5XzEuYXJyYXkoYXNjaWlfMS5hc2NpaSgpLCBjb25zdHJhaW50cykpLm1hcChDb2RlUG9pbnRzVG9TdHJpbmdfMS5jb2RlUG9pbnRzVG9TdHJpbmdNYXBwZXIsIENvZGVQb2ludHNUb1N0cmluZ18xLmNvZGVQb2ludHNUb1N0cmluZ1VubWFwcGVyKSk7XG59XG5leHBvcnRzLmFzY2lpU3RyaW5nID0gYXNjaWlTdHJpbmc7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuYmFzZTY0ID0gdm9pZCAwO1xuY29uc3QgQ2hhcmFjdGVyQXJiaXRyYXJ5QnVpbGRlcl8xID0gcmVxdWlyZShcIi4vX2ludGVybmFscy9idWlsZGVycy9DaGFyYWN0ZXJBcmJpdHJhcnlCdWlsZGVyXCIpO1xuZnVuY3Rpb24gYmFzZTY0TWFwcGVyKHYpIHtcbiAgICBpZiAodiA8IDI2KVxuICAgICAgICByZXR1cm4gdiArIDY1O1xuICAgIGlmICh2IDwgNTIpXG4gICAgICAgIHJldHVybiB2ICsgOTcgLSAyNjtcbiAgICBpZiAodiA8IDYyKVxuICAgICAgICByZXR1cm4gdiArIDQ4IC0gNTI7XG4gICAgcmV0dXJuIHYgPT09IDYyID8gNDMgOiA0Nztcbn1cbmZ1bmN0aW9uIGJhc2U2NFVubWFwcGVyKHYpIHtcbiAgICBpZiAodiA+PSA2NSAmJiB2IDw9IDkwKVxuICAgICAgICByZXR1cm4gdiAtIDY1O1xuICAgIGlmICh2ID49IDk3ICYmIHYgPD0gMTIyKVxuICAgICAgICByZXR1cm4gdiAtIDk3ICsgMjY7XG4gICAgaWYgKHYgPj0gNDggJiYgdiA8PSA1NylcbiAgICAgICAgcmV0dXJuIHYgLSA0OCArIDUyO1xuICAgIHJldHVybiB2ID09PSA0MyA/IDYyIDogdiA9PT0gNDcgPyA2MyA6IC0xO1xufVxuZnVuY3Rpb24gYmFzZTY0KCkge1xuICAgIHJldHVybiBDaGFyYWN0ZXJBcmJpdHJhcnlCdWlsZGVyXzEuYnVpbGRDaGFyYWN0ZXJBcmJpdHJhcnkoMCwgNjMsIGJhc2U2NE1hcHBlciwgYmFzZTY0VW5tYXBwZXIpO1xufVxuZXhwb3J0cy5iYXNlNjQgPSBiYXNlNjQ7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuYmFzZTY0U3RyaW5nID0gdm9pZCAwO1xuY29uc3QgQ29udmVydGVyc18xID0gcmVxdWlyZShcIi4uL2NoZWNrL2FyYml0cmFyeS9kZWZpbml0aW9uL0NvbnZlcnRlcnNcIik7XG5jb25zdCBhcnJheV8xID0gcmVxdWlyZShcIi4vYXJyYXlcIik7XG5jb25zdCBiYXNlNjRfMSA9IHJlcXVpcmUoXCIuL2Jhc2U2NFwiKTtcbmNvbnN0IE1heExlbmd0aEZyb21NaW5MZW5ndGhfMSA9IHJlcXVpcmUoXCIuL19pbnRlcm5hbHMvaGVscGVycy9NYXhMZW5ndGhGcm9tTWluTGVuZ3RoXCIpO1xuY29uc3QgU3RyaW5nQ29uc3RyYWludHNFeHRyYWN0b3JfMSA9IHJlcXVpcmUoXCIuL19pbnRlcm5hbHMvaGVscGVycy9TdHJpbmdDb25zdHJhaW50c0V4dHJhY3RvclwiKTtcbmNvbnN0IENvZGVQb2ludHNUb1N0cmluZ18xID0gcmVxdWlyZShcIi4vX2ludGVybmFscy9tYXBwZXJzL0NvZGVQb2ludHNUb1N0cmluZ1wiKTtcbmNvbnN0IFN0cmluZ1RvQmFzZTY0XzEgPSByZXF1aXJlKFwiLi9faW50ZXJuYWxzL21hcHBlcnMvU3RyaW5nVG9CYXNlNjRcIik7XG5mdW5jdGlvbiBleHRyYWN0TWluTWF4Q29uc3RyYWludHMoYXJncykge1xuICAgIGNvbnN0IGNvbnN0cmFpbnRzID0gU3RyaW5nQ29uc3RyYWludHNFeHRyYWN0b3JfMS5leHRyYWN0U3RyaW5nQ29uc3RyYWludHMoYXJncyk7XG4gICAgY29uc3QgbWluTGVuZ3RoID0gY29uc3RyYWludHMubWluTGVuZ3RoICE9PSB1bmRlZmluZWQgPyBjb25zdHJhaW50cy5taW5MZW5ndGggOiAwO1xuICAgIGNvbnN0IG1heExlbmd0aCA9IGNvbnN0cmFpbnRzLm1heExlbmd0aCAhPT0gdW5kZWZpbmVkID8gY29uc3RyYWludHMubWF4TGVuZ3RoIDogTWF4TGVuZ3RoRnJvbU1pbkxlbmd0aF8xLm1heExlbmd0aEZyb21NaW5MZW5ndGgobWluTGVuZ3RoKTtcbiAgICByZXR1cm4geyBtaW5MZW5ndGgsIG1heExlbmd0aCB9O1xufVxuZnVuY3Rpb24gYmFzZTY0U3RyaW5nKC4uLmFyZ3MpIHtcbiAgICBjb25zdCBjb25zdHJhaW50cyA9IGV4dHJhY3RNaW5NYXhDb25zdHJhaW50cyhhcmdzKTtcbiAgICBjb25zdCB1bnNjYWxlZE1pbkxlbmd0aCA9IGNvbnN0cmFpbnRzLm1pbkxlbmd0aDtcbiAgICBjb25zdCB1bnNjYWxlZE1heExlbmd0aCA9IGNvbnN0cmFpbnRzLm1heExlbmd0aDtcbiAgICBjb25zdCBtaW5MZW5ndGggPSB1bnNjYWxlZE1pbkxlbmd0aCArIDMgLSAoKHVuc2NhbGVkTWluTGVuZ3RoICsgMykgJSA0KTtcbiAgICBjb25zdCBtYXhMZW5ndGggPSB1bnNjYWxlZE1heExlbmd0aCAtICh1bnNjYWxlZE1heExlbmd0aCAlIDQpO1xuICAgIGlmIChtaW5MZW5ndGggPiBtYXhMZW5ndGgpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTWluaW1hbCBsZW5ndGggc2hvdWxkIGJlIGluZmVyaW9yIG9yIGVxdWFsIHRvIG1heGltYWwgbGVuZ3RoJyk7XG4gICAgaWYgKG1pbkxlbmd0aCAlIDQgIT09IDApXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTWluaW1hbCBsZW5ndGggb2YgYmFzZTY0IHN0cmluZ3MgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDQnKTtcbiAgICBpZiAobWF4TGVuZ3RoICUgNCAhPT0gMClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNYXhpbWFsIGxlbmd0aCBvZiBiYXNlNjQgc3RyaW5ncyBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgNCcpO1xuICAgIHJldHVybiBDb252ZXJ0ZXJzXzEuY29udmVydEZyb21OZXh0KENvbnZlcnRlcnNfMS5jb252ZXJ0VG9OZXh0KGFycmF5XzEuYXJyYXkoYmFzZTY0XzEuYmFzZTY0KCksIHsgbWluTGVuZ3RoLCBtYXhMZW5ndGggfSkpXG4gICAgICAgIC5tYXAoQ29kZVBvaW50c1RvU3RyaW5nXzEuY29kZVBvaW50c1RvU3RyaW5nTWFwcGVyLCBDb2RlUG9pbnRzVG9TdHJpbmdfMS5jb2RlUG9pbnRzVG9TdHJpbmdVbm1hcHBlcilcbiAgICAgICAgLm1hcChTdHJpbmdUb0Jhc2U2NF8xLnN0cmluZ1RvQmFzZTY0TWFwcGVyLCBTdHJpbmdUb0Jhc2U2NF8xLnN0cmluZ1RvQmFzZTY0VW5tYXBwZXIpKTtcbn1cbmV4cG9ydHMuYmFzZTY0U3RyaW5nID0gYmFzZTY0U3RyaW5nO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmJpZ0ludCA9IHZvaWQgMDtcbmNvbnN0IENvbnZlcnRlcnNfMSA9IHJlcXVpcmUoXCIuLi9jaGVjay9hcmJpdHJhcnkvZGVmaW5pdGlvbi9Db252ZXJ0ZXJzXCIpO1xuY29uc3QgQmlnSW50QXJiaXRyYXJ5XzEgPSByZXF1aXJlKFwiLi9faW50ZXJuYWxzL0JpZ0ludEFyYml0cmFyeVwiKTtcbmZ1bmN0aW9uIGJ1aWxkQ29tcGxldGVCaWdJbnRDb25zdHJhaW50cyhjb25zdHJhaW50cykge1xuICAgIGNvbnN0IERlZmF1bHRQb3cgPSAyNTY7XG4gICAgY29uc3QgRGVmYXVsdE1pbiA9IEJpZ0ludCgtMSkgPDwgQmlnSW50KERlZmF1bHRQb3cgLSAxKTtcbiAgICBjb25zdCBEZWZhdWx0TWF4ID0gKEJpZ0ludCgxKSA8PCBCaWdJbnQoRGVmYXVsdFBvdyAtIDEpKSAtIEJpZ0ludCgxKTtcbiAgICBjb25zdCBtaW4gPSBjb25zdHJhaW50cy5taW47XG4gICAgY29uc3QgbWF4ID0gY29uc3RyYWludHMubWF4O1xuICAgIHJldHVybiB7XG4gICAgICAgIG1pbjogbWluICE9PSB1bmRlZmluZWQgPyBtaW4gOiBEZWZhdWx0TWluIC0gKG1heCAhPT0gdW5kZWZpbmVkICYmIG1heCA8IEJpZ0ludCgwKSA/IG1heCAqIG1heCA6IEJpZ0ludCgwKSksXG4gICAgICAgIG1heDogbWF4ICE9PSB1bmRlZmluZWQgPyBtYXggOiBEZWZhdWx0TWF4ICsgKG1pbiAhPT0gdW5kZWZpbmVkICYmIG1pbiA+IEJpZ0ludCgwKSA/IG1pbiAqIG1pbiA6IEJpZ0ludCgwKSksXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGV4dHJhY3RCaWdJbnRDb25zdHJhaW50cyhhcmdzKSB7XG4gICAgaWYgKGFyZ3NbMF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4ge307XG4gICAgfVxuICAgIGlmIChhcmdzWzFdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY29uc3QgY29uc3RyYWludHMgPSBhcmdzWzBdO1xuICAgICAgICByZXR1cm4gY29uc3RyYWludHM7XG4gICAgfVxuICAgIHJldHVybiB7IG1pbjogYXJnc1swXSwgbWF4OiBhcmdzWzFdIH07XG59XG5mdW5jdGlvbiBiaWdJbnQoLi4uYXJncykge1xuICAgIGNvbnN0IGNvbnN0cmFpbnRzID0gYnVpbGRDb21wbGV0ZUJpZ0ludENvbnN0cmFpbnRzKGV4dHJhY3RCaWdJbnRDb25zdHJhaW50cyhhcmdzKSk7XG4gICAgaWYgKGNvbnN0cmFpbnRzLm1pbiA+IGNvbnN0cmFpbnRzLm1heCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ZjLmJpZ0ludCBleHBlY3RzIG1heCB0byBiZSBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gbWluJyk7XG4gICAgfVxuICAgIGNvbnN0IGFyYiA9IG5ldyBCaWdJbnRBcmJpdHJhcnlfMS5CaWdJbnRBcmJpdHJhcnkoY29uc3RyYWludHMubWluLCBjb25zdHJhaW50cy5tYXgpO1xuICAgIHJldHVybiBDb252ZXJ0ZXJzXzEuY29udmVydEZyb21OZXh0V2l0aFNocnVua09uY2UoYXJiLCBhcmIuZGVmYXVsdFRhcmdldCgpKTtcbn1cbmV4cG9ydHMuYmlnSW50ID0gYmlnSW50O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmJpZ0ludE4gPSB2b2lkIDA7XG5jb25zdCBDb252ZXJ0ZXJzXzEgPSByZXF1aXJlKFwiLi4vY2hlY2svYXJiaXRyYXJ5L2RlZmluaXRpb24vQ29udmVydGVyc1wiKTtcbmNvbnN0IEJpZ0ludEFyYml0cmFyeV8xID0gcmVxdWlyZShcIi4vX2ludGVybmFscy9CaWdJbnRBcmJpdHJhcnlcIik7XG5mdW5jdGlvbiBiaWdJbnROKG4pIHtcbiAgICBpZiAobiA8IDEpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdmYy5iaWdJbnROIGV4cGVjdHMgcmVxdWVzdGVkIG51bWJlciBvZiBiaXRzIHRvIGJlIHN1cGVyaW9yIG9yIGVxdWFsIHRvIDEnKTtcbiAgICB9XG4gICAgY29uc3QgbWluID0gQmlnSW50KC0xKSA8PCBCaWdJbnQobiAtIDEpO1xuICAgIGNvbnN0IG1heCA9IChCaWdJbnQoMSkgPDwgQmlnSW50KG4gLSAxKSkgLSBCaWdJbnQoMSk7XG4gICAgY29uc3QgYXJiID0gbmV3IEJpZ0ludEFyYml0cmFyeV8xLkJpZ0ludEFyYml0cmFyeShtaW4sIG1heCk7XG4gICAgcmV0dXJuIENvbnZlcnRlcnNfMS5jb252ZXJ0RnJvbU5leHRXaXRoU2hydW5rT25jZShhcmIsIGFyYi5kZWZhdWx0VGFyZ2V0KCkpO1xufVxuZXhwb3J0cy5iaWdJbnROID0gYmlnSW50TjtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5iaWdVaW50ID0gdm9pZCAwO1xuY29uc3QgQ29udmVydGVyc18xID0gcmVxdWlyZShcIi4uL2NoZWNrL2FyYml0cmFyeS9kZWZpbml0aW9uL0NvbnZlcnRlcnNcIik7XG5jb25zdCBCaWdJbnRBcmJpdHJhcnlfMSA9IHJlcXVpcmUoXCIuL19pbnRlcm5hbHMvQmlnSW50QXJiaXRyYXJ5XCIpO1xuZnVuY3Rpb24gY29tcHV0ZURlZmF1bHRNYXgoKSB7XG4gICAgcmV0dXJuIChCaWdJbnQoMSkgPDwgQmlnSW50KDI1NikpIC0gQmlnSW50KDEpO1xufVxuZnVuY3Rpb24gYmlnVWludChjb25zdHJhaW50cykge1xuICAgIGNvbnN0IHJlcXVlc3RlZE1heCA9IHR5cGVvZiBjb25zdHJhaW50cyA9PT0gJ29iamVjdCcgPyBjb25zdHJhaW50cy5tYXggOiBjb25zdHJhaW50cztcbiAgICBjb25zdCBtYXggPSByZXF1ZXN0ZWRNYXggIT09IHVuZGVmaW5lZCA/IHJlcXVlc3RlZE1heCA6IGNvbXB1dGVEZWZhdWx0TWF4KCk7XG4gICAgaWYgKG1heCA8IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdmYy5iaWdVaW50IGV4cGVjdHMgbWF4IHRvIGJlIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byB6ZXJvJyk7XG4gICAgfVxuICAgIGNvbnN0IGFyYiA9IG5ldyBCaWdJbnRBcmJpdHJhcnlfMS5CaWdJbnRBcmJpdHJhcnkoQmlnSW50KDApLCBtYXgpO1xuICAgIHJldHVybiBDb252ZXJ0ZXJzXzEuY29udmVydEZyb21OZXh0V2l0aFNocnVua09uY2UoYXJiLCBhcmIuZGVmYXVsdFRhcmdldCgpKTtcbn1cbmV4cG9ydHMuYmlnVWludCA9IGJpZ1VpbnQ7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuYmlnVWludE4gPSB2b2lkIDA7XG5jb25zdCBDb252ZXJ0ZXJzXzEgPSByZXF1aXJlKFwiLi4vY2hlY2svYXJiaXRyYXJ5L2RlZmluaXRpb24vQ29udmVydGVyc1wiKTtcbmNvbnN0IEJpZ0ludEFyYml0cmFyeV8xID0gcmVxdWlyZShcIi4vX2ludGVybmFscy9CaWdJbnRBcmJpdHJhcnlcIik7XG5mdW5jdGlvbiBiaWdVaW50TihuKSB7XG4gICAgaWYgKG4gPCAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignZmMuYmlnVWludE4gZXhwZWN0cyByZXF1ZXN0ZWQgbnVtYmVyIG9mIGJpdHMgdG8gYmUgc3VwZXJpb3Igb3IgZXF1YWwgdG8gMCcpO1xuICAgIH1cbiAgICBjb25zdCBtaW4gPSBCaWdJbnQoMCk7XG4gICAgY29uc3QgbWF4ID0gKEJpZ0ludCgxKSA8PCBCaWdJbnQobikpIC0gQmlnSW50KDEpO1xuICAgIGNvbnN0IGFyYiA9IG5ldyBCaWdJbnRBcmJpdHJhcnlfMS5CaWdJbnRBcmJpdHJhcnkobWluLCBtYXgpO1xuICAgIHJldHVybiBDb252ZXJ0ZXJzXzEuY29udmVydEZyb21OZXh0V2l0aFNocnVua09uY2UoYXJiLCBhcmIuZGVmYXVsdFRhcmdldCgpKTtcbn1cbmV4cG9ydHMuYmlnVWludE4gPSBiaWdVaW50TjtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5ib29sZWFuID0gdm9pZCAwO1xuY29uc3QgQ29udmVydGVyc18xID0gcmVxdWlyZShcIi4uL2NoZWNrL2FyYml0cmFyeS9kZWZpbml0aW9uL0NvbnZlcnRlcnNcIik7XG5jb25zdCBpbnRlZ2VyXzEgPSByZXF1aXJlKFwiLi9pbnRlZ2VyXCIpO1xuZnVuY3Rpb24gYm9vbGVhbk1hcHBlcih2KSB7XG4gICAgcmV0dXJuIHYgPT09IDE7XG59XG5mdW5jdGlvbiBib29sZWFuVW5tYXBwZXIodikge1xuICAgIGlmICh0eXBlb2YgdiAhPT0gJ2Jvb2xlYW4nKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vuc3VwcG9ydGVkIGlucHV0IHR5cGUnKTtcbiAgICByZXR1cm4gdiA9PT0gdHJ1ZSA/IDEgOiAwO1xufVxuZnVuY3Rpb24gYm9vbGVhbigpIHtcbiAgICByZXR1cm4gQ29udmVydGVyc18xLmNvbnZlcnRGcm9tTmV4dChDb252ZXJ0ZXJzXzEuY29udmVydFRvTmV4dChpbnRlZ2VyXzEuaW50ZWdlcih7IG1pbjogMCwgbWF4OiAxIH0pKVxuICAgICAgICAubWFwKGJvb2xlYW5NYXBwZXIsIGJvb2xlYW5Vbm1hcHBlcilcbiAgICAgICAgLm5vQmlhcygpKTtcbn1cbmV4cG9ydHMuYm9vbGVhbiA9IGJvb2xlYW47XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuY2hhciA9IHZvaWQgMDtcbmNvbnN0IENoYXJhY3RlckFyYml0cmFyeUJ1aWxkZXJfMSA9IHJlcXVpcmUoXCIuL19pbnRlcm5hbHMvYnVpbGRlcnMvQ2hhcmFjdGVyQXJiaXRyYXJ5QnVpbGRlclwiKTtcbmZ1bmN0aW9uIGlkZW50aXR5KHYpIHtcbiAgICByZXR1cm4gdjtcbn1cbmZ1bmN0aW9uIGNoYXIoKSB7XG4gICAgcmV0dXJuIENoYXJhY3RlckFyYml0cmFyeUJ1aWxkZXJfMS5idWlsZENoYXJhY3RlckFyYml0cmFyeSgweDIwLCAweDdlLCBpZGVudGl0eSwgaWRlbnRpdHkpO1xufVxuZXhwb3J0cy5jaGFyID0gY2hhcjtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5jaGFyMTZiaXRzID0gdm9pZCAwO1xuY29uc3QgQ2hhcmFjdGVyQXJiaXRyYXJ5QnVpbGRlcl8xID0gcmVxdWlyZShcIi4vX2ludGVybmFscy9idWlsZGVycy9DaGFyYWN0ZXJBcmJpdHJhcnlCdWlsZGVyXCIpO1xuY29uc3QgSW5kZXhUb1ByaW50YWJsZUluZGV4XzEgPSByZXF1aXJlKFwiLi9faW50ZXJuYWxzL21hcHBlcnMvSW5kZXhUb1ByaW50YWJsZUluZGV4XCIpO1xuZnVuY3Rpb24gY2hhcjE2Yml0cygpIHtcbiAgICByZXR1cm4gQ2hhcmFjdGVyQXJiaXRyYXJ5QnVpbGRlcl8xLmJ1aWxkQ2hhcmFjdGVyQXJiaXRyYXJ5KDB4MDAwMCwgMHhmZmZmLCBJbmRleFRvUHJpbnRhYmxlSW5kZXhfMS5pbmRleFRvUHJpbnRhYmxlSW5kZXhNYXBwZXIsIEluZGV4VG9QcmludGFibGVJbmRleF8xLmluZGV4VG9QcmludGFibGVJbmRleFVubWFwcGVyKTtcbn1cbmV4cG9ydHMuY2hhcjE2Yml0cyA9IGNoYXIxNmJpdHM7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuY2xvbmUgPSB2b2lkIDA7XG5jb25zdCBDb252ZXJ0ZXJzXzEgPSByZXF1aXJlKFwiLi4vY2hlY2svYXJiaXRyYXJ5L2RlZmluaXRpb24vQ29udmVydGVyc1wiKTtcbmNvbnN0IENsb25lQXJiaXRyYXJ5XzEgPSByZXF1aXJlKFwiLi9faW50ZXJuYWxzL0Nsb25lQXJiaXRyYXJ5XCIpO1xuZnVuY3Rpb24gY2xvbmUoYXJiLCBudW1WYWx1ZXMpIHtcbiAgICByZXR1cm4gQ29udmVydGVyc18xLmNvbnZlcnRGcm9tTmV4dChuZXcgQ2xvbmVBcmJpdHJhcnlfMS5DbG9uZUFyYml0cmFyeShDb252ZXJ0ZXJzXzEuY29udmVydFRvTmV4dChhcmIpLCBudW1WYWx1ZXMpKTtcbn1cbmV4cG9ydHMuY2xvbmUgPSBjbG9uZTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5jbG9uZWRDb25zdGFudCA9IHZvaWQgMDtcbmNvbnN0IGNvbnN0YW50XzEgPSByZXF1aXJlKFwiLi9jb25zdGFudFwiKTtcbmV4cG9ydHMuY2xvbmVkQ29uc3RhbnQgPSBjb25zdGFudF8xLmNvbnN0YW50O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmNvbXBhcmVCb29sZWFuRnVuYyA9IHZvaWQgMDtcbmNvbnN0IENvbXBhcmVGdW5jdGlvbkFyYml0cmFyeUJ1aWxkZXJfMSA9IHJlcXVpcmUoXCIuL19pbnRlcm5hbHMvYnVpbGRlcnMvQ29tcGFyZUZ1bmN0aW9uQXJiaXRyYXJ5QnVpbGRlclwiKTtcbmZ1bmN0aW9uIGNvbXBhcmVCb29sZWFuRnVuYygpIHtcbiAgICByZXR1cm4gQ29tcGFyZUZ1bmN0aW9uQXJiaXRyYXJ5QnVpbGRlcl8xLmJ1aWxkQ29tcGFyZUZ1bmN0aW9uQXJiaXRyYXJ5KE9iamVjdC5hc3NpZ24oKGhBLCBoQikgPT4gaEEgPCBoQiwge1xuICAgICAgICB0b1N0cmluZygpIHtcbiAgICAgICAgICAgIHJldHVybiAnKGhBLCBoQikgPT4gaEEgPCBoQic7XG4gICAgICAgIH0sXG4gICAgfSkpO1xufVxuZXhwb3J0cy5jb21wYXJlQm9vbGVhbkZ1bmMgPSBjb21wYXJlQm9vbGVhbkZ1bmM7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuY29tcGFyZUZ1bmMgPSB2b2lkIDA7XG5jb25zdCBDb21wYXJlRnVuY3Rpb25BcmJpdHJhcnlCdWlsZGVyXzEgPSByZXF1aXJlKFwiLi9faW50ZXJuYWxzL2J1aWxkZXJzL0NvbXBhcmVGdW5jdGlvbkFyYml0cmFyeUJ1aWxkZXJcIik7XG5mdW5jdGlvbiBjb21wYXJlRnVuYygpIHtcbiAgICByZXR1cm4gQ29tcGFyZUZ1bmN0aW9uQXJiaXRyYXJ5QnVpbGRlcl8xLmJ1aWxkQ29tcGFyZUZ1bmN0aW9uQXJiaXRyYXJ5KE9iamVjdC5hc3NpZ24oKGhBLCBoQikgPT4gaEEgLSBoQiwge1xuICAgICAgICB0b1N0cmluZygpIHtcbiAgICAgICAgICAgIHJldHVybiAnKGhBLCBoQikgPT4gaEEgLSBoQic7XG4gICAgICAgIH0sXG4gICAgfSkpO1xufVxuZXhwb3J0cy5jb21wYXJlRnVuYyA9IGNvbXBhcmVGdW5jO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmNvbnN0YW50ID0gdm9pZCAwO1xuY29uc3QgQ29udmVydGVyc18xID0gcmVxdWlyZShcIi4uL2NoZWNrL2FyYml0cmFyeS9kZWZpbml0aW9uL0NvbnZlcnRlcnNcIik7XG5jb25zdCBDb25zdGFudEFyYml0cmFyeV8xID0gcmVxdWlyZShcIi4vX2ludGVybmFscy9Db25zdGFudEFyYml0cmFyeVwiKTtcbmZ1bmN0aW9uIGNvbnN0YW50KHZhbHVlKSB7XG4gICAgcmV0dXJuIENvbnZlcnRlcnNfMS5jb252ZXJ0RnJvbU5leHQobmV3IENvbnN0YW50QXJiaXRyYXJ5XzEuQ29uc3RhbnRBcmJpdHJhcnkoW3ZhbHVlXSkpO1xufVxuZXhwb3J0cy5jb25zdGFudCA9IGNvbnN0YW50O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmNvbnN0YW50RnJvbSA9IHZvaWQgMDtcbmNvbnN0IENvbnZlcnRlcnNfMSA9IHJlcXVpcmUoXCIuLi9jaGVjay9hcmJpdHJhcnkvZGVmaW5pdGlvbi9Db252ZXJ0ZXJzXCIpO1xuY29uc3QgQ29uc3RhbnRBcmJpdHJhcnlfMSA9IHJlcXVpcmUoXCIuL19pbnRlcm5hbHMvQ29uc3RhbnRBcmJpdHJhcnlcIik7XG5mdW5jdGlvbiBjb25zdGFudEZyb20oLi4udmFsdWVzKSB7XG4gICAgaWYgKHZhbHVlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdmYy5jb25zdGFudEZyb20gZXhwZWN0cyBhdCBsZWFzdCBvbmUgcGFyYW1ldGVyJyk7XG4gICAgfVxuICAgIHJldHVybiBDb252ZXJ0ZXJzXzEuY29udmVydEZyb21OZXh0KG5ldyBDb25zdGFudEFyYml0cmFyeV8xLkNvbnN0YW50QXJiaXRyYXJ5KHZhbHVlcykpO1xufVxuZXhwb3J0cy5jb25zdGFudEZyb20gPSBjb25zdGFudEZyb207XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuY29udGV4dCA9IHZvaWQgMDtcbmNvbnN0IHN5bWJvbHNfMSA9IHJlcXVpcmUoXCIuLi9jaGVjay9zeW1ib2xzXCIpO1xuY29uc3QgY29uc3RhbnRfMSA9IHJlcXVpcmUoXCIuL2NvbnN0YW50XCIpO1xuY2xhc3MgQ29udGV4dEltcGxlbSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMucmVjZWl2ZWRMb2dzID0gW107XG4gICAgfVxuICAgIGxvZyhkYXRhKSB7XG4gICAgICAgIHRoaXMucmVjZWl2ZWRMb2dzLnB1c2goZGF0YSk7XG4gICAgfVxuICAgIHNpemUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlY2VpdmVkTG9ncy5sZW5ndGg7XG4gICAgfVxuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoeyBsb2dzOiB0aGlzLnJlY2VpdmVkTG9ncyB9KTtcbiAgICB9XG4gICAgW3N5bWJvbHNfMS5jbG9uZU1ldGhvZF0oKSB7XG4gICAgICAgIHJldHVybiBuZXcgQ29udGV4dEltcGxlbSgpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGNvbnRleHQoKSB7XG4gICAgcmV0dXJuIGNvbnN0YW50XzEuY29uc3RhbnQobmV3IENvbnRleHRJbXBsZW0oKSk7XG59XG5leHBvcnRzLmNvbnRleHQgPSBjb250ZXh0O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmRhdGUgPSB2b2lkIDA7XG5jb25zdCBDb252ZXJ0ZXJzXzEgPSByZXF1aXJlKFwiLi4vY2hlY2svYXJiaXRyYXJ5L2RlZmluaXRpb24vQ29udmVydGVyc1wiKTtcbmNvbnN0IGludGVnZXJfMSA9IHJlcXVpcmUoXCIuL2ludGVnZXJcIik7XG5jb25zdCBUaW1lVG9EYXRlXzEgPSByZXF1aXJlKFwiLi9faW50ZXJuYWxzL21hcHBlcnMvVGltZVRvRGF0ZVwiKTtcbmZ1bmN0aW9uIGRhdGUoY29uc3RyYWludHMpIHtcbiAgICBjb25zdCBpbnRNaW4gPSBjb25zdHJhaW50cyAmJiBjb25zdHJhaW50cy5taW4gIT09IHVuZGVmaW5lZCA/IGNvbnN0cmFpbnRzLm1pbi5nZXRUaW1lKCkgOiAtODY0MDAwMDAwMDAwMDAwMDtcbiAgICBjb25zdCBpbnRNYXggPSBjb25zdHJhaW50cyAmJiBjb25zdHJhaW50cy5tYXggIT09IHVuZGVmaW5lZCA/IGNvbnN0cmFpbnRzLm1heC5nZXRUaW1lKCkgOiA4NjQwMDAwMDAwMDAwMDAwO1xuICAgIGlmIChOdW1iZXIuaXNOYU4oaW50TWluKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdmYy5kYXRlIG1pbiBtdXN0IGJlIHZhbGlkIGluc3RhbmNlIG9mIERhdGUnKTtcbiAgICBpZiAoTnVtYmVyLmlzTmFOKGludE1heCkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignZmMuZGF0ZSBtYXggbXVzdCBiZSB2YWxpZCBpbnN0YW5jZSBvZiBEYXRlJyk7XG4gICAgaWYgKGludE1pbiA+IGludE1heClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdmYy5kYXRlIG1heCBtdXN0IGJlIGdyZWF0ZXIgb3IgZXF1YWwgdG8gbWluJyk7XG4gICAgcmV0dXJuIENvbnZlcnRlcnNfMS5jb252ZXJ0RnJvbU5leHQoQ29udmVydGVyc18xLmNvbnZlcnRUb05leHQoaW50ZWdlcl8xLmludGVnZXIoaW50TWluLCBpbnRNYXgpKS5tYXAoVGltZVRvRGF0ZV8xLnRpbWVUb0RhdGVNYXBwZXIsIFRpbWVUb0RhdGVfMS50aW1lVG9EYXRlVW5tYXBwZXIpKTtcbn1cbmV4cG9ydHMuZGF0ZSA9IGRhdGU7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZGVkdXAgPSB2b2lkIDA7XG5jb25zdCBjbG9uZV8xID0gcmVxdWlyZShcIi4vY2xvbmVcIik7XG5leHBvcnRzLmRlZHVwID0gY2xvbmVfMS5jbG9uZTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5kaWN0aW9uYXJ5ID0gdm9pZCAwO1xuY29uc3QgQ29udmVydGVyc18xID0gcmVxdWlyZShcIi4uL2NoZWNrL2FyYml0cmFyeS9kZWZpbml0aW9uL0NvbnZlcnRlcnNcIik7XG5jb25zdCBzZXRfMSA9IHJlcXVpcmUoXCIuL3NldFwiKTtcbmNvbnN0IHR1cGxlXzEgPSByZXF1aXJlKFwiLi90dXBsZVwiKTtcbmNvbnN0IEtleVZhbHVlUGFpcnNUb09iamVjdF8xID0gcmVxdWlyZShcIi4vX2ludGVybmFscy9tYXBwZXJzL0tleVZhbHVlUGFpcnNUb09iamVjdFwiKTtcbmZ1bmN0aW9uIGRpY3Rpb25hcnkoa2V5QXJiLCB2YWx1ZUFyYikge1xuICAgIHJldHVybiBDb252ZXJ0ZXJzXzEuY29udmVydEZyb21OZXh0KENvbnZlcnRlcnNfMS5jb252ZXJ0VG9OZXh0KHNldF8xLnNldCh0dXBsZV8xLnR1cGxlKGtleUFyYiwgdmFsdWVBcmIpLCB7IGNvbXBhcmU6ICh0MSwgdDIpID0+IHQxWzBdID09PSB0MlswXSB9KSkubWFwKEtleVZhbHVlUGFpcnNUb09iamVjdF8xLmtleVZhbHVlUGFpcnNUb09iamVjdE1hcHBlciwgS2V5VmFsdWVQYWlyc1RvT2JqZWN0XzEua2V5VmFsdWVQYWlyc1RvT2JqZWN0VW5tYXBwZXIpKTtcbn1cbmV4cG9ydHMuZGljdGlvbmFyeSA9IGRpY3Rpb25hcnk7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZmFsc3kgPSB2b2lkIDA7XG5jb25zdCBjb25zdGFudEZyb21fMSA9IHJlcXVpcmUoXCIuL2NvbnN0YW50RnJvbVwiKTtcbmZ1bmN0aW9uIGZhbHN5KGNvbnN0cmFpbnRzKSB7XG4gICAgaWYgKCFjb25zdHJhaW50cyB8fCAhY29uc3RyYWludHMud2l0aEJpZ0ludCkge1xuICAgICAgICByZXR1cm4gY29uc3RhbnRGcm9tXzEuY29uc3RhbnRGcm9tKGZhbHNlLCBudWxsLCB1bmRlZmluZWQsIDAsICcnLCBOYU4pO1xuICAgIH1cbiAgICByZXR1cm4gY29uc3RhbnRGcm9tXzEuY29uc3RhbnRGcm9tKGZhbHNlLCBudWxsLCB1bmRlZmluZWQsIDAsICcnLCBOYU4sIEJpZ0ludCgwKSk7XG59XG5leHBvcnRzLmZhbHN5ID0gZmFsc3k7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZmxvYXQzMkFycmF5ID0gdm9pZCAwO1xuY29uc3QgRmxvYXRpbmdQb2ludEFyYml0cmFyeV8xID0gcmVxdWlyZShcIi4uL2NoZWNrL2FyYml0cmFyeS9GbG9hdGluZ1BvaW50QXJiaXRyYXJ5XCIpO1xuY29uc3QgYXJyYXlfMSA9IHJlcXVpcmUoXCIuL2FycmF5XCIpO1xuZnVuY3Rpb24gZmxvYXQzMkFycmF5KGNvbnN0cmFpbnRzID0ge30pIHtcbiAgICByZXR1cm4gYXJyYXlfMS5hcnJheShGbG9hdGluZ1BvaW50QXJiaXRyYXJ5XzEuZmxvYXQoT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBjb25zdHJhaW50cyksIHsgbmV4dDogdHJ1ZSB9KSksIGNvbnN0cmFpbnRzKS5tYXAoKGRhdGEpID0+IEZsb2F0MzJBcnJheS5mcm9tKGRhdGEpKTtcbn1cbmV4cG9ydHMuZmxvYXQzMkFycmF5ID0gZmxvYXQzMkFycmF5O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmZsb2F0NjRBcnJheSA9IHZvaWQgMDtcbmNvbnN0IEZsb2F0aW5nUG9pbnRBcmJpdHJhcnlfMSA9IHJlcXVpcmUoXCIuLi9jaGVjay9hcmJpdHJhcnkvRmxvYXRpbmdQb2ludEFyYml0cmFyeVwiKTtcbmNvbnN0IGFycmF5XzEgPSByZXF1aXJlKFwiLi9hcnJheVwiKTtcbmZ1bmN0aW9uIGZsb2F0NjRBcnJheShjb25zdHJhaW50cyA9IHt9KSB7XG4gICAgcmV0dXJuIGFycmF5XzEuYXJyYXkoRmxvYXRpbmdQb2ludEFyYml0cmFyeV8xLmRvdWJsZShPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGNvbnN0cmFpbnRzKSwgeyBuZXh0OiB0cnVlIH0pKSwgY29uc3RyYWludHMpLm1hcCgoZGF0YSkgPT4gRmxvYXQ2NEFycmF5LmZyb20oZGF0YSkpO1xufVxuZXhwb3J0cy5mbG9hdDY0QXJyYXkgPSBmbG9hdDY0QXJyYXk7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZnJlcXVlbmN5ID0gdm9pZCAwO1xuY29uc3QgRnJlcXVlbmN5QXJiaXRyYXJ5XzEgPSByZXF1aXJlKFwiLi9faW50ZXJuYWxzL0ZyZXF1ZW5jeUFyYml0cmFyeVwiKTtcbmZ1bmN0aW9uIGlzRnJlcXVlbmN5Q29udHJhaW50cyhwYXJhbSkge1xuICAgIHJldHVybiBwYXJhbSAhPSBudWxsICYmIHR5cGVvZiBwYXJhbSA9PT0gJ29iamVjdCcgJiYgISgnYXJiaXRyYXJ5JyBpbiBwYXJhbSk7XG59XG5mdW5jdGlvbiBmcmVxdWVuY3koLi4uYXJncykge1xuICAgIGNvbnN0IGxhYmVsID0gJ2ZjLmZyZXF1ZW5jeSc7XG4gICAgY29uc3QgY29uc3RyYWludHMgPSBhcmdzWzBdO1xuICAgIGlmIChpc0ZyZXF1ZW5jeUNvbnRyYWludHMoY29uc3RyYWludHMpKSB7XG4gICAgICAgIHJldHVybiBGcmVxdWVuY3lBcmJpdHJhcnlfMS5GcmVxdWVuY3lBcmJpdHJhcnkuZnJvbU9sZChhcmdzLnNsaWNlKDEpLCBjb25zdHJhaW50cywgbGFiZWwpO1xuICAgIH1cbiAgICByZXR1cm4gRnJlcXVlbmN5QXJiaXRyYXJ5XzEuRnJlcXVlbmN5QXJiaXRyYXJ5LmZyb21PbGQoYXJncywge30sIGxhYmVsKTtcbn1cbmV4cG9ydHMuZnJlcXVlbmN5ID0gZnJlcXVlbmN5O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmZ1bGxVbmljb2RlID0gdm9pZCAwO1xuY29uc3QgQ2hhcmFjdGVyQXJiaXRyYXJ5QnVpbGRlcl8xID0gcmVxdWlyZShcIi4vX2ludGVybmFscy9idWlsZGVycy9DaGFyYWN0ZXJBcmJpdHJhcnlCdWlsZGVyXCIpO1xuY29uc3QgSW5kZXhUb1ByaW50YWJsZUluZGV4XzEgPSByZXF1aXJlKFwiLi9faW50ZXJuYWxzL21hcHBlcnMvSW5kZXhUb1ByaW50YWJsZUluZGV4XCIpO1xuY29uc3QgZ2FwU2l6ZSA9IDB4ZGZmZiArIDEgLSAweGQ4MDA7XG5mdW5jdGlvbiB1bmljb2RlTWFwcGVyKHYpIHtcbiAgICBpZiAodiA8IDB4ZDgwMClcbiAgICAgICAgcmV0dXJuIEluZGV4VG9QcmludGFibGVJbmRleF8xLmluZGV4VG9QcmludGFibGVJbmRleE1hcHBlcih2KTtcbiAgICByZXR1cm4gdiArIGdhcFNpemU7XG59XG5mdW5jdGlvbiB1bmljb2RlVW5tYXBwZXIodikge1xuICAgIGlmICh2IDwgMHhkODAwKVxuICAgICAgICByZXR1cm4gSW5kZXhUb1ByaW50YWJsZUluZGV4XzEuaW5kZXhUb1ByaW50YWJsZUluZGV4VW5tYXBwZXIodik7XG4gICAgaWYgKHYgPD0gMHhkZmZmKVxuICAgICAgICByZXR1cm4gLTE7XG4gICAgcmV0dXJuIHYgLSBnYXBTaXplO1xufVxuZnVuY3Rpb24gZnVsbFVuaWNvZGUoKSB7XG4gICAgcmV0dXJuIENoYXJhY3RlckFyYml0cmFyeUJ1aWxkZXJfMS5idWlsZENoYXJhY3RlckFyYml0cmFyeSgweDAwMDAsIDB4MTBmZmZmIC0gZ2FwU2l6ZSwgdW5pY29kZU1hcHBlciwgdW5pY29kZVVubWFwcGVyKTtcbn1cbmV4cG9ydHMuZnVsbFVuaWNvZGUgPSBmdWxsVW5pY29kZTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5mdWxsVW5pY29kZVN0cmluZyA9IHZvaWQgMDtcbmNvbnN0IENvbnZlcnRlcnNfMSA9IHJlcXVpcmUoXCIuLi9jaGVjay9hcmJpdHJhcnkvZGVmaW5pdGlvbi9Db252ZXJ0ZXJzXCIpO1xuY29uc3QgYXJyYXlfMSA9IHJlcXVpcmUoXCIuL2FycmF5XCIpO1xuY29uc3QgZnVsbFVuaWNvZGVfMSA9IHJlcXVpcmUoXCIuL2Z1bGxVbmljb2RlXCIpO1xuY29uc3QgU3RyaW5nQ29uc3RyYWludHNFeHRyYWN0b3JfMSA9IHJlcXVpcmUoXCIuL19pbnRlcm5hbHMvaGVscGVycy9TdHJpbmdDb25zdHJhaW50c0V4dHJhY3RvclwiKTtcbmNvbnN0IENvZGVQb2ludHNUb1N0cmluZ18xID0gcmVxdWlyZShcIi4vX2ludGVybmFscy9tYXBwZXJzL0NvZGVQb2ludHNUb1N0cmluZ1wiKTtcbmZ1bmN0aW9uIGZ1bGxVbmljb2RlU3RyaW5nKC4uLmFyZ3MpIHtcbiAgICBjb25zdCBjb25zdHJhaW50cyA9IFN0cmluZ0NvbnN0cmFpbnRzRXh0cmFjdG9yXzEuZXh0cmFjdFN0cmluZ0NvbnN0cmFpbnRzKGFyZ3MpO1xuICAgIHJldHVybiBDb252ZXJ0ZXJzXzEuY29udmVydEZyb21OZXh0KENvbnZlcnRlcnNfMS5jb252ZXJ0VG9OZXh0KGFycmF5XzEuYXJyYXkoZnVsbFVuaWNvZGVfMS5mdWxsVW5pY29kZSgpLCBjb25zdHJhaW50cykpLm1hcChDb2RlUG9pbnRzVG9TdHJpbmdfMS5jb2RlUG9pbnRzVG9TdHJpbmdNYXBwZXIsIENvZGVQb2ludHNUb1N0cmluZ18xLmNvZGVQb2ludHNUb1N0cmluZ1VubWFwcGVyKSk7XG59XG5leHBvcnRzLmZ1bGxVbmljb2RlU3RyaW5nID0gZnVsbFVuaWNvZGVTdHJpbmc7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZnVuYyA9IHZvaWQgMDtcbmNvbnN0IGhhc2hfMSA9IHJlcXVpcmUoXCIuLi91dGlscy9oYXNoXCIpO1xuY29uc3Qgc3RyaW5naWZ5XzEgPSByZXF1aXJlKFwiLi4vdXRpbHMvc3RyaW5naWZ5XCIpO1xuY29uc3Qgc3ltYm9sc18xID0gcmVxdWlyZShcIi4uL2NoZWNrL3N5bWJvbHNcIik7XG5jb25zdCBhcnJheV8xID0gcmVxdWlyZShcIi4vYXJyYXlcIik7XG5jb25zdCBpbnRlZ2VyXzEgPSByZXF1aXJlKFwiLi9pbnRlZ2VyXCIpO1xuY29uc3QgdHVwbGVfMSA9IHJlcXVpcmUoXCIuL3R1cGxlXCIpO1xuY29uc3QgVGV4dEVzY2FwZXJfMSA9IHJlcXVpcmUoXCIuLi9jaGVjay9hcmJpdHJhcnkvaGVscGVycy9UZXh0RXNjYXBlclwiKTtcbmZ1bmN0aW9uIGZ1bmMoYXJiKSB7XG4gICAgcmV0dXJuIHR1cGxlXzEudHVwbGUoYXJyYXlfMS5hcnJheShhcmIsIHsgbWluTGVuZ3RoOiAxIH0pLCBpbnRlZ2VyXzEuaW50ZWdlcigpLm5vU2hyaW5rKCkpLm1hcCgoW291dHMsIHNlZWRdKSA9PiB7XG4gICAgICAgIGNvbnN0IHByb2R1Y2VyID0gKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgcmVjb3JkZWQgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGYgPSAoLi4uYXJncykgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlcHIgPSBzdHJpbmdpZnlfMS5zdHJpbmdpZnkoYXJncyk7XG4gICAgICAgICAgICAgICAgY29uc3QgdmFsID0gb3V0c1toYXNoXzEuaGFzaChgJHtzZWVkfSR7cmVwcn1gKSAlIG91dHMubGVuZ3RoXTtcbiAgICAgICAgICAgICAgICByZWNvcmRlZFtyZXByXSA9IHZhbDtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3ltYm9sc18xLmhhc0Nsb25lTWV0aG9kKHZhbCkgPyB2YWxbc3ltYm9sc18xLmNsb25lTWV0aG9kXSgpIDogdmFsO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGZ1bmN0aW9uIHByZXR0eVByaW50KHN0cmluZ2lmaWVkT3V0cykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHNlZW5WYWx1ZXMgPSBPYmplY3Qua2V5cyhyZWNvcmRlZClcbiAgICAgICAgICAgICAgICAgICAgLnNvcnQoKVxuICAgICAgICAgICAgICAgICAgICAubWFwKChrKSA9PiBgJHtrfSA9PiAke3N0cmluZ2lmeV8xLnN0cmluZ2lmeShyZWNvcmRlZFtrXSl9YClcbiAgICAgICAgICAgICAgICAgICAgLm1hcCgobGluZSkgPT4gYC8qICR7VGV4dEVzY2FwZXJfMS5lc2NhcGVGb3JNdWx0aWxpbmVDb21tZW50cyhsaW5lKX0gKi9gKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gYGZ1bmN0aW9uKC4uLmFyZ3MpIHtcbiAgLy8gV2l0aCBoYXNoIGFuZCBzdHJpbmdpZnkgY29taW5nIGZyb20gZmFzdC1jaGVjayR7c2VlblZhbHVlcy5sZW5ndGggIT09IDAgPyBgXFxuICAke3NlZW5WYWx1ZXMuam9pbignXFxuICAnKX1gIDogJyd9XG4gIGNvbnN0IG91dHMgPSAke3N0cmluZ2lmaWVkT3V0c307XG4gIHJldHVybiBvdXRzW2hhc2goJyR7c2VlZH0nICsgc3RyaW5naWZ5KGFyZ3MpKSAlIG91dHMubGVuZ3RoXTtcbn1gO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGYsIHtcbiAgICAgICAgICAgICAgICB0b1N0cmluZzogeyB2YWx1ZTogKCkgPT4gcHJldHR5UHJpbnQoc3RyaW5naWZ5XzEuc3RyaW5naWZ5KG91dHMpKSB9LFxuICAgICAgICAgICAgICAgIFtzdHJpbmdpZnlfMS50b1N0cmluZ01ldGhvZF06IHsgdmFsdWU6ICgpID0+IHByZXR0eVByaW50KHN0cmluZ2lmeV8xLnN0cmluZ2lmeShvdXRzKSkgfSxcbiAgICAgICAgICAgICAgICBbc3RyaW5naWZ5XzEuYXN5bmNUb1N0cmluZ01ldGhvZF06IHsgdmFsdWU6IGFzeW5jICgpID0+IHByZXR0eVByaW50KGF3YWl0IHN0cmluZ2lmeV8xLmFzeW5jU3RyaW5naWZ5KG91dHMpKSB9LFxuICAgICAgICAgICAgICAgIFtzeW1ib2xzXzEuY2xvbmVNZXRob2RdOiB7IHZhbHVlOiBwcm9kdWNlciwgY29uZmlndXJhYmxlOiB0cnVlIH0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHByb2R1Y2VyKCk7XG4gICAgfSk7XG59XG5leHBvcnRzLmZ1bmMgPSBmdW5jO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmdlbmVyaWNUdXBsZSA9IHZvaWQgMDtcbmNvbnN0IENvbnZlcnRlcnNfMSA9IHJlcXVpcmUoXCIuLi9jaGVjay9hcmJpdHJhcnkvZGVmaW5pdGlvbi9Db252ZXJ0ZXJzXCIpO1xuY29uc3QgVHVwbGVBcmJpdHJhcnlfMSA9IHJlcXVpcmUoXCIuL19pbnRlcm5hbHMvVHVwbGVBcmJpdHJhcnlcIik7XG5mdW5jdGlvbiBnZW5lcmljVHVwbGUoYXJicykge1xuICAgIGNvbnN0IG5leHRBcmJzID0gYXJicy5tYXAoKGFyYikgPT4gQ29udmVydGVyc18xLmNvbnZlcnRUb05leHQoYXJiKSk7XG4gICAgcmV0dXJuIENvbnZlcnRlcnNfMS5jb252ZXJ0RnJvbU5leHQobmV3IFR1cGxlQXJiaXRyYXJ5XzEuVHVwbGVBcmJpdHJhcnkobmV4dEFyYnMpKTtcbn1cbmV4cG9ydHMuZ2VuZXJpY1R1cGxlID0gZ2VuZXJpY1R1cGxlO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmhleGEgPSB2b2lkIDA7XG5jb25zdCBDaGFyYWN0ZXJBcmJpdHJhcnlCdWlsZGVyXzEgPSByZXF1aXJlKFwiLi9faW50ZXJuYWxzL2J1aWxkZXJzL0NoYXJhY3RlckFyYml0cmFyeUJ1aWxkZXJcIik7XG5mdW5jdGlvbiBoZXhhTWFwcGVyKHYpIHtcbiAgICByZXR1cm4gdiA8IDEwXG4gICAgICAgID8gdiArIDQ4XG4gICAgICAgIDogdiArIDk3IC0gMTA7XG59XG5mdW5jdGlvbiBoZXhhVW5tYXBwZXIodikge1xuICAgIHJldHVybiB2IDwgNThcbiAgICAgICAgPyB2IC0gNDhcbiAgICAgICAgOiB2IDwgMTAzXG4gICAgICAgICAgICA/IHYgLSA5NyArIDEwXG4gICAgICAgICAgICA6IC0xO1xufVxuZnVuY3Rpb24gaGV4YSgpIHtcbiAgICByZXR1cm4gQ2hhcmFjdGVyQXJiaXRyYXJ5QnVpbGRlcl8xLmJ1aWxkQ2hhcmFjdGVyQXJiaXRyYXJ5KDAsIDE1LCBoZXhhTWFwcGVyLCBoZXhhVW5tYXBwZXIpO1xufVxuZXhwb3J0cy5oZXhhID0gaGV4YTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5oZXhhU3RyaW5nID0gdm9pZCAwO1xuY29uc3QgQ29udmVydGVyc18xID0gcmVxdWlyZShcIi4uL2NoZWNrL2FyYml0cmFyeS9kZWZpbml0aW9uL0NvbnZlcnRlcnNcIik7XG5jb25zdCBhcnJheV8xID0gcmVxdWlyZShcIi4vYXJyYXlcIik7XG5jb25zdCBoZXhhXzEgPSByZXF1aXJlKFwiLi9oZXhhXCIpO1xuY29uc3QgU3RyaW5nQ29uc3RyYWludHNFeHRyYWN0b3JfMSA9IHJlcXVpcmUoXCIuL19pbnRlcm5hbHMvaGVscGVycy9TdHJpbmdDb25zdHJhaW50c0V4dHJhY3RvclwiKTtcbmNvbnN0IENvZGVQb2ludHNUb1N0cmluZ18xID0gcmVxdWlyZShcIi4vX2ludGVybmFscy9tYXBwZXJzL0NvZGVQb2ludHNUb1N0cmluZ1wiKTtcbmZ1bmN0aW9uIGhleGFTdHJpbmcoLi4uYXJncykge1xuICAgIGNvbnN0IGNvbnN0cmFpbnRzID0gU3RyaW5nQ29uc3RyYWludHNFeHRyYWN0b3JfMS5leHRyYWN0U3RyaW5nQ29uc3RyYWludHMoYXJncyk7XG4gICAgcmV0dXJuIENvbnZlcnRlcnNfMS5jb252ZXJ0RnJvbU5leHQoQ29udmVydGVyc18xLmNvbnZlcnRUb05leHQoYXJyYXlfMS5hcnJheShoZXhhXzEuaGV4YSgpLCBjb25zdHJhaW50cykpLm1hcChDb2RlUG9pbnRzVG9TdHJpbmdfMS5jb2RlUG9pbnRzVG9TdHJpbmdNYXBwZXIsIENvZGVQb2ludHNUb1N0cmluZ18xLmNvZGVQb2ludHNUb1N0cmluZ1VubWFwcGVyKSk7XG59XG5leHBvcnRzLmhleGFTdHJpbmcgPSBoZXhhU3RyaW5nO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmluZmluaXRlU3RyZWFtID0gdm9pZCAwO1xuY29uc3QgQ29udmVydGVyc18xID0gcmVxdWlyZShcIi4uL2NoZWNrL2FyYml0cmFyeS9kZWZpbml0aW9uL0NvbnZlcnRlcnNcIik7XG5jb25zdCBTdHJlYW1BcmJpdHJhcnlfMSA9IHJlcXVpcmUoXCIuL19pbnRlcm5hbHMvU3RyZWFtQXJiaXRyYXJ5XCIpO1xuZnVuY3Rpb24gaW5maW5pdGVTdHJlYW0oYXJiKSB7XG4gICAgcmV0dXJuIENvbnZlcnRlcnNfMS5jb252ZXJ0RnJvbU5leHQobmV3IFN0cmVhbUFyYml0cmFyeV8xLlN0cmVhbUFyYml0cmFyeShDb252ZXJ0ZXJzXzEuY29udmVydFRvTmV4dChhcmIpKSk7XG59XG5leHBvcnRzLmluZmluaXRlU3RyZWFtID0gaW5maW5pdGVTdHJlYW07XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuaW50MTZBcnJheSA9IHZvaWQgMDtcbmNvbnN0IGludGVnZXJfMSA9IHJlcXVpcmUoXCIuL2ludGVnZXJcIik7XG5jb25zdCBUeXBlZEludEFycmF5QXJiaXRyYXJ5QnVpbGRlcl8xID0gcmVxdWlyZShcIi4vX2ludGVybmFscy9idWlsZGVycy9UeXBlZEludEFycmF5QXJiaXRyYXJ5QnVpbGRlclwiKTtcbmZ1bmN0aW9uIGludDE2QXJyYXkoY29uc3RyYWludHMgPSB7fSkge1xuICAgIHJldHVybiBUeXBlZEludEFycmF5QXJiaXRyYXJ5QnVpbGRlcl8xLnR5cGVkSW50QXJyYXlBcmJpdHJhcnlBcmJpdHJhcnlCdWlsZGVyKGNvbnN0cmFpbnRzLCAtMzI3NjgsIDMyNzY3LCBJbnQxNkFycmF5LCBpbnRlZ2VyXzEuaW50ZWdlcik7XG59XG5leHBvcnRzLmludDE2QXJyYXkgPSBpbnQxNkFycmF5O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmludDMyQXJyYXkgPSB2b2lkIDA7XG5jb25zdCBpbnRlZ2VyXzEgPSByZXF1aXJlKFwiLi9pbnRlZ2VyXCIpO1xuY29uc3QgVHlwZWRJbnRBcnJheUFyYml0cmFyeUJ1aWxkZXJfMSA9IHJlcXVpcmUoXCIuL19pbnRlcm5hbHMvYnVpbGRlcnMvVHlwZWRJbnRBcnJheUFyYml0cmFyeUJ1aWxkZXJcIik7XG5mdW5jdGlvbiBpbnQzMkFycmF5KGNvbnN0cmFpbnRzID0ge30pIHtcbiAgICByZXR1cm4gVHlwZWRJbnRBcnJheUFyYml0cmFyeUJ1aWxkZXJfMS50eXBlZEludEFycmF5QXJiaXRyYXJ5QXJiaXRyYXJ5QnVpbGRlcihjb25zdHJhaW50cywgLTB4ODAwMDAwMDAsIDB4N2ZmZmZmZmYsIEludDMyQXJyYXksIGludGVnZXJfMS5pbnRlZ2VyKTtcbn1cbmV4cG9ydHMuaW50MzJBcnJheSA9IGludDMyQXJyYXk7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuaW50OEFycmF5ID0gdm9pZCAwO1xuY29uc3QgaW50ZWdlcl8xID0gcmVxdWlyZShcIi4vaW50ZWdlclwiKTtcbmNvbnN0IFR5cGVkSW50QXJyYXlBcmJpdHJhcnlCdWlsZGVyXzEgPSByZXF1aXJlKFwiLi9faW50ZXJuYWxzL2J1aWxkZXJzL1R5cGVkSW50QXJyYXlBcmJpdHJhcnlCdWlsZGVyXCIpO1xuZnVuY3Rpb24gaW50OEFycmF5KGNvbnN0cmFpbnRzID0ge30pIHtcbiAgICByZXR1cm4gVHlwZWRJbnRBcnJheUFyYml0cmFyeUJ1aWxkZXJfMS50eXBlZEludEFycmF5QXJiaXRyYXJ5QXJiaXRyYXJ5QnVpbGRlcihjb25zdHJhaW50cywgLTEyOCwgMTI3LCBJbnQ4QXJyYXksIGludGVnZXJfMS5pbnRlZ2VyKTtcbn1cbmV4cG9ydHMuaW50OEFycmF5ID0gaW50OEFycmF5O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmludGVnZXIgPSB2b2lkIDA7XG5jb25zdCBDb252ZXJ0ZXJzXzEgPSByZXF1aXJlKFwiLi4vY2hlY2svYXJiaXRyYXJ5L2RlZmluaXRpb24vQ29udmVydGVyc1wiKTtcbmNvbnN0IEludGVnZXJBcmJpdHJhcnlfMSA9IHJlcXVpcmUoXCIuL19pbnRlcm5hbHMvSW50ZWdlckFyYml0cmFyeVwiKTtcbmZ1bmN0aW9uIGJ1aWxkQ29tcGxldGVJbnRlZ2VyQ29uc3RyYWludHMoY29uc3RyYWludHMpIHtcbiAgICBjb25zdCBtaW4gPSBjb25zdHJhaW50cy5taW4gIT09IHVuZGVmaW5lZCA/IGNvbnN0cmFpbnRzLm1pbiA6IC0weDgwMDAwMDAwO1xuICAgIGNvbnN0IG1heCA9IGNvbnN0cmFpbnRzLm1heCAhPT0gdW5kZWZpbmVkID8gY29uc3RyYWludHMubWF4IDogMHg3ZmZmZmZmZjtcbiAgICByZXR1cm4geyBtaW4sIG1heCB9O1xufVxuZnVuY3Rpb24gZXh0cmFjdEludGVnZXJDb25zdHJhaW50cyhhcmdzKSB7XG4gICAgaWYgKGFyZ3NbMF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4ge307XG4gICAgfVxuICAgIGlmIChhcmdzWzFdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY29uc3Qgc2FyZ3MgPSBhcmdzO1xuICAgICAgICBpZiAodHlwZW9mIHNhcmdzWzBdID09PSAnbnVtYmVyJylcbiAgICAgICAgICAgIHJldHVybiB7IG1heDogc2FyZ3NbMF0gfTtcbiAgICAgICAgcmV0dXJuIHNhcmdzWzBdO1xuICAgIH1cbiAgICBjb25zdCBzYXJncyA9IGFyZ3M7XG4gICAgcmV0dXJuIHsgbWluOiBzYXJnc1swXSwgbWF4OiBzYXJnc1sxXSB9O1xufVxuZnVuY3Rpb24gaW50ZWdlciguLi5hcmdzKSB7XG4gICAgY29uc3QgY29uc3RyYWludHMgPSBidWlsZENvbXBsZXRlSW50ZWdlckNvbnN0cmFpbnRzKGV4dHJhY3RJbnRlZ2VyQ29uc3RyYWludHMoYXJncykpO1xuICAgIGlmIChjb25zdHJhaW50cy5taW4gPiBjb25zdHJhaW50cy5tYXgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdmYy5pbnRlZ2VyIG1heGltdW0gdmFsdWUgc2hvdWxkIGJlIGVxdWFsIG9yIGdyZWF0ZXIgdGhhbiB0aGUgbWluaW11bSBvbmUnKTtcbiAgICB9XG4gICAgY29uc3QgYXJiID0gbmV3IEludGVnZXJBcmJpdHJhcnlfMS5JbnRlZ2VyQXJiaXRyYXJ5KGNvbnN0cmFpbnRzLm1pbiwgY29uc3RyYWludHMubWF4KTtcbiAgICByZXR1cm4gQ29udmVydGVyc18xLmNvbnZlcnRGcm9tTmV4dFdpdGhTaHJ1bmtPbmNlKGFyYiwgYXJiLmRlZmF1bHRUYXJnZXQoKSk7XG59XG5leHBvcnRzLmludGVnZXIgPSBpbnRlZ2VyO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmlwVjQgPSB2b2lkIDA7XG5jb25zdCBDb252ZXJ0ZXJzXzEgPSByZXF1aXJlKFwiLi4vY2hlY2svYXJiaXRyYXJ5L2RlZmluaXRpb24vQ29udmVydGVyc1wiKTtcbmNvbnN0IG5hdF8xID0gcmVxdWlyZShcIi4vbmF0XCIpO1xuY29uc3QgdHVwbGVfMSA9IHJlcXVpcmUoXCIuL3R1cGxlXCIpO1xuY29uc3QgTmF0VG9TdHJpbmdpZmllZE5hdF8xID0gcmVxdWlyZShcIi4vX2ludGVybmFscy9tYXBwZXJzL05hdFRvU3RyaW5naWZpZWROYXRcIik7XG5mdW5jdGlvbiBkb3RKb2luZXJNYXBwZXIoZGF0YSkge1xuICAgIHJldHVybiBkYXRhLmpvaW4oJy4nKTtcbn1cbmZ1bmN0aW9uIGRvdEpvaW5lclVubWFwcGVyKHZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHR5cGUnKTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlLnNwbGl0KCcuJykubWFwKCh2KSA9PiBOYXRUb1N0cmluZ2lmaWVkTmF0XzEudHJ5UGFyc2VTdHJpbmdpZmllZE5hdCh2LCAxMCkpO1xufVxuZnVuY3Rpb24gaXBWNCgpIHtcbiAgICByZXR1cm4gQ29udmVydGVyc18xLmNvbnZlcnRGcm9tTmV4dChDb252ZXJ0ZXJzXzEuY29udmVydFRvTmV4dCh0dXBsZV8xLnR1cGxlKG5hdF8xLm5hdCgyNTUpLCBuYXRfMS5uYXQoMjU1KSwgbmF0XzEubmF0KDI1NSksIG5hdF8xLm5hdCgyNTUpKSkubWFwKGRvdEpvaW5lck1hcHBlciwgZG90Sm9pbmVyVW5tYXBwZXIpKTtcbn1cbmV4cG9ydHMuaXBWNCA9IGlwVjQ7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuaXBWNEV4dGVuZGVkID0gdm9pZCAwO1xuY29uc3Qgb25lb2ZfMSA9IHJlcXVpcmUoXCIuL29uZW9mXCIpO1xuY29uc3QgdHVwbGVfMSA9IHJlcXVpcmUoXCIuL3R1cGxlXCIpO1xuY29uc3QgU3RyaW5naWZpZWROYXRBcmJpdHJhcnlCdWlsZGVyXzEgPSByZXF1aXJlKFwiLi9faW50ZXJuYWxzL2J1aWxkZXJzL1N0cmluZ2lmaWVkTmF0QXJiaXRyYXJ5QnVpbGRlclwiKTtcbmNvbnN0IENvbnZlcnRlcnNfMSA9IHJlcXVpcmUoXCIuLi9jaGVjay9hcmJpdHJhcnkvZGVmaW5pdGlvbi9Db252ZXJ0ZXJzXCIpO1xuZnVuY3Rpb24gZG90Sm9pbmVyTWFwcGVyKGRhdGEpIHtcbiAgICByZXR1cm4gZGF0YS5qb2luKCcuJyk7XG59XG5mdW5jdGlvbiBkb3RKb2luZXJVbm1hcHBlcih2YWx1ZSkge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCB0eXBlJyk7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZS5zcGxpdCgnLicpO1xufVxuZnVuY3Rpb24gaXBWNEV4dGVuZGVkKCkge1xuICAgIHJldHVybiBvbmVvZl8xLm9uZW9mKENvbnZlcnRlcnNfMS5jb252ZXJ0RnJvbU5leHQoQ29udmVydGVyc18xLmNvbnZlcnRUb05leHQodHVwbGVfMS50dXBsZShTdHJpbmdpZmllZE5hdEFyYml0cmFyeUJ1aWxkZXJfMS5idWlsZFN0cmluZ2lmaWVkTmF0QXJiaXRyYXJ5KDI1NSksIFN0cmluZ2lmaWVkTmF0QXJiaXRyYXJ5QnVpbGRlcl8xLmJ1aWxkU3RyaW5naWZpZWROYXRBcmJpdHJhcnkoMjU1KSwgU3RyaW5naWZpZWROYXRBcmJpdHJhcnlCdWlsZGVyXzEuYnVpbGRTdHJpbmdpZmllZE5hdEFyYml0cmFyeSgyNTUpLCBTdHJpbmdpZmllZE5hdEFyYml0cmFyeUJ1aWxkZXJfMS5idWlsZFN0cmluZ2lmaWVkTmF0QXJiaXRyYXJ5KDI1NSkpKS5tYXAoZG90Sm9pbmVyTWFwcGVyLCBkb3RKb2luZXJVbm1hcHBlcikpLCBDb252ZXJ0ZXJzXzEuY29udmVydEZyb21OZXh0KENvbnZlcnRlcnNfMS5jb252ZXJ0VG9OZXh0KHR1cGxlXzEudHVwbGUoU3RyaW5naWZpZWROYXRBcmJpdHJhcnlCdWlsZGVyXzEuYnVpbGRTdHJpbmdpZmllZE5hdEFyYml0cmFyeSgyNTUpLCBTdHJpbmdpZmllZE5hdEFyYml0cmFyeUJ1aWxkZXJfMS5idWlsZFN0cmluZ2lmaWVkTmF0QXJiaXRyYXJ5KDI1NSksIFN0cmluZ2lmaWVkTmF0QXJiaXRyYXJ5QnVpbGRlcl8xLmJ1aWxkU3RyaW5naWZpZWROYXRBcmJpdHJhcnkoNjU1MzUpKSkubWFwKGRvdEpvaW5lck1hcHBlciwgZG90Sm9pbmVyVW5tYXBwZXIpKSwgQ29udmVydGVyc18xLmNvbnZlcnRGcm9tTmV4dChDb252ZXJ0ZXJzXzEuY29udmVydFRvTmV4dCh0dXBsZV8xLnR1cGxlKFN0cmluZ2lmaWVkTmF0QXJiaXRyYXJ5QnVpbGRlcl8xLmJ1aWxkU3RyaW5naWZpZWROYXRBcmJpdHJhcnkoMjU1KSwgU3RyaW5naWZpZWROYXRBcmJpdHJhcnlCdWlsZGVyXzEuYnVpbGRTdHJpbmdpZmllZE5hdEFyYml0cmFyeSgxNjc3NzIxNSkpKS5tYXAoZG90Sm9pbmVyTWFwcGVyLCBkb3RKb2luZXJVbm1hcHBlcikpLCBTdHJpbmdpZmllZE5hdEFyYml0cmFyeUJ1aWxkZXJfMS5idWlsZFN0cmluZ2lmaWVkTmF0QXJiaXRyYXJ5KDQyOTQ5NjcyOTUpKTtcbn1cbmV4cG9ydHMuaXBWNEV4dGVuZGVkID0gaXBWNEV4dGVuZGVkO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmlwVjYgPSB2b2lkIDA7XG5jb25zdCBhcnJheV8xID0gcmVxdWlyZShcIi4vYXJyYXlcIik7XG5jb25zdCBDb252ZXJ0ZXJzXzEgPSByZXF1aXJlKFwiLi4vY2hlY2svYXJiaXRyYXJ5L2RlZmluaXRpb24vQ29udmVydGVyc1wiKTtcbmNvbnN0IG9uZW9mXzEgPSByZXF1aXJlKFwiLi9vbmVvZlwiKTtcbmNvbnN0IGhleGFTdHJpbmdfMSA9IHJlcXVpcmUoXCIuL2hleGFTdHJpbmdcIik7XG5jb25zdCB0dXBsZV8xID0gcmVxdWlyZShcIi4vdHVwbGVcIik7XG5jb25zdCBpcFY0XzEgPSByZXF1aXJlKFwiLi9pcFY0XCIpO1xuY29uc3QgRW50aXRpZXNUb0lQdjZfMSA9IHJlcXVpcmUoXCIuL19pbnRlcm5hbHMvbWFwcGVycy9FbnRpdGllc1RvSVB2NlwiKTtcbmZ1bmN0aW9uIGgxNnNUb2wzMk1hcHBlcihbYSwgYl0pIHtcbiAgICByZXR1cm4gYCR7YX06JHtifWA7XG59XG5mdW5jdGlvbiBoMTZzVG9sMzJVbm1hcHBlcih2YWx1ZSkge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdzdHJpbmcnKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgdHlwZScpO1xuICAgIGlmICghdmFsdWUuaW5jbHVkZXMoJzonKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHZhbHVlJyk7XG4gICAgcmV0dXJuIHZhbHVlLnNwbGl0KCc6JywgMik7XG59XG5mdW5jdGlvbiBpcFY2KCkge1xuICAgIGNvbnN0IGgxNkFyYiA9IGhleGFTdHJpbmdfMS5oZXhhU3RyaW5nKHsgbWluTGVuZ3RoOiAxLCBtYXhMZW5ndGg6IDQgfSk7XG4gICAgY29uc3QgbHMzMkFyYiA9IG9uZW9mXzEub25lb2YoQ29udmVydGVyc18xLmNvbnZlcnRGcm9tTmV4dChDb252ZXJ0ZXJzXzEuY29udmVydFRvTmV4dCh0dXBsZV8xLnR1cGxlKGgxNkFyYiwgaDE2QXJiKSkubWFwKGgxNnNUb2wzMk1hcHBlciwgaDE2c1RvbDMyVW5tYXBwZXIpKSwgaXBWNF8xLmlwVjQoKSk7XG4gICAgcmV0dXJuIG9uZW9mXzEub25lb2YoQ29udmVydGVyc18xLmNvbnZlcnRGcm9tTmV4dChDb252ZXJ0ZXJzXzEuY29udmVydFRvTmV4dCh0dXBsZV8xLnR1cGxlKGFycmF5XzEuYXJyYXkoaDE2QXJiLCB7IG1pbkxlbmd0aDogNiwgbWF4TGVuZ3RoOiA2IH0pLCBsczMyQXJiKSkubWFwKEVudGl0aWVzVG9JUHY2XzEuZnVsbHlTcGVjaWZpZWRNYXBwZXIsIEVudGl0aWVzVG9JUHY2XzEuZnVsbHlTcGVjaWZpZWRVbm1hcHBlcikpLCBDb252ZXJ0ZXJzXzEuY29udmVydEZyb21OZXh0KENvbnZlcnRlcnNfMS5jb252ZXJ0VG9OZXh0KHR1cGxlXzEudHVwbGUoYXJyYXlfMS5hcnJheShoMTZBcmIsIHsgbWluTGVuZ3RoOiA1LCBtYXhMZW5ndGg6IDUgfSksIGxzMzJBcmIpKS5tYXAoRW50aXRpZXNUb0lQdjZfMS5vbmx5VHJhaWxpbmdNYXBwZXIsIEVudGl0aWVzVG9JUHY2XzEub25seVRyYWlsaW5nVW5tYXBwZXIpKSwgQ29udmVydGVyc18xLmNvbnZlcnRGcm9tTmV4dChDb252ZXJ0ZXJzXzEuY29udmVydFRvTmV4dCh0dXBsZV8xLnR1cGxlKGFycmF5XzEuYXJyYXkoaDE2QXJiLCB7IG1pbkxlbmd0aDogMCwgbWF4TGVuZ3RoOiAxIH0pLCBhcnJheV8xLmFycmF5KGgxNkFyYiwgeyBtaW5MZW5ndGg6IDQsIG1heExlbmd0aDogNCB9KSwgbHMzMkFyYikpLm1hcChFbnRpdGllc1RvSVB2Nl8xLm11bHRpVHJhaWxpbmdNYXBwZXIsIEVudGl0aWVzVG9JUHY2XzEubXVsdGlUcmFpbGluZ1VubWFwcGVyKSksIENvbnZlcnRlcnNfMS5jb252ZXJ0RnJvbU5leHQoQ29udmVydGVyc18xLmNvbnZlcnRUb05leHQodHVwbGVfMS50dXBsZShhcnJheV8xLmFycmF5KGgxNkFyYiwgeyBtaW5MZW5ndGg6IDAsIG1heExlbmd0aDogMiB9KSwgYXJyYXlfMS5hcnJheShoMTZBcmIsIHsgbWluTGVuZ3RoOiAzLCBtYXhMZW5ndGg6IDMgfSksIGxzMzJBcmIpKS5tYXAoRW50aXRpZXNUb0lQdjZfMS5tdWx0aVRyYWlsaW5nTWFwcGVyLCBFbnRpdGllc1RvSVB2Nl8xLm11bHRpVHJhaWxpbmdVbm1hcHBlcikpLCBDb252ZXJ0ZXJzXzEuY29udmVydEZyb21OZXh0KENvbnZlcnRlcnNfMS5jb252ZXJ0VG9OZXh0KHR1cGxlXzEudHVwbGUoYXJyYXlfMS5hcnJheShoMTZBcmIsIHsgbWluTGVuZ3RoOiAwLCBtYXhMZW5ndGg6IDMgfSksIGFycmF5XzEuYXJyYXkoaDE2QXJiLCB7IG1pbkxlbmd0aDogMiwgbWF4TGVuZ3RoOiAyIH0pLCBsczMyQXJiKSkubWFwKEVudGl0aWVzVG9JUHY2XzEubXVsdGlUcmFpbGluZ01hcHBlciwgRW50aXRpZXNUb0lQdjZfMS5tdWx0aVRyYWlsaW5nVW5tYXBwZXIpKSwgQ29udmVydGVyc18xLmNvbnZlcnRGcm9tTmV4dChDb252ZXJ0ZXJzXzEuY29udmVydFRvTmV4dCh0dXBsZV8xLnR1cGxlKGFycmF5XzEuYXJyYXkoaDE2QXJiLCB7IG1pbkxlbmd0aDogMCwgbWF4TGVuZ3RoOiA0IH0pLCBoMTZBcmIsIGxzMzJBcmIpKS5tYXAoRW50aXRpZXNUb0lQdjZfMS5tdWx0aVRyYWlsaW5nTWFwcGVyT25lLCBFbnRpdGllc1RvSVB2Nl8xLm11bHRpVHJhaWxpbmdVbm1hcHBlck9uZSkpLCBDb252ZXJ0ZXJzXzEuY29udmVydEZyb21OZXh0KENvbnZlcnRlcnNfMS5jb252ZXJ0VG9OZXh0KHR1cGxlXzEudHVwbGUoYXJyYXlfMS5hcnJheShoMTZBcmIsIHsgbWluTGVuZ3RoOiAwLCBtYXhMZW5ndGg6IDUgfSksIGxzMzJBcmIpKS5tYXAoRW50aXRpZXNUb0lQdjZfMS5zaW5nbGVUcmFpbGluZ01hcHBlciwgRW50aXRpZXNUb0lQdjZfMS5zaW5nbGVUcmFpbGluZ1VubWFwcGVyKSksIENvbnZlcnRlcnNfMS5jb252ZXJ0RnJvbU5leHQoQ29udmVydGVyc18xLmNvbnZlcnRUb05leHQodHVwbGVfMS50dXBsZShhcnJheV8xLmFycmF5KGgxNkFyYiwgeyBtaW5MZW5ndGg6IDAsIG1heExlbmd0aDogNiB9KSwgaDE2QXJiKSkubWFwKEVudGl0aWVzVG9JUHY2XzEuc2luZ2xlVHJhaWxpbmdNYXBwZXIsIEVudGl0aWVzVG9JUHY2XzEuc2luZ2xlVHJhaWxpbmdVbm1hcHBlcikpLCBDb252ZXJ0ZXJzXzEuY29udmVydEZyb21OZXh0KENvbnZlcnRlcnNfMS5jb252ZXJ0VG9OZXh0KHR1cGxlXzEudHVwbGUoYXJyYXlfMS5hcnJheShoMTZBcmIsIHsgbWluTGVuZ3RoOiAwLCBtYXhMZW5ndGg6IDcgfSkpKS5tYXAoRW50aXRpZXNUb0lQdjZfMS5ub1RyYWlsaW5nTWFwcGVyLCBFbnRpdGllc1RvSVB2Nl8xLm5vVHJhaWxpbmdVbm1hcHBlcikpKTtcbn1cbmV4cG9ydHMuaXBWNiA9IGlwVjY7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMubGV0cmVjID0gdm9pZCAwO1xuY29uc3QgTGF6eUFyYml0cmFyeV8xID0gcmVxdWlyZShcIi4vX2ludGVybmFscy9MYXp5QXJiaXRyYXJ5XCIpO1xuY29uc3QgQ29udmVydGVyc18xID0gcmVxdWlyZShcIi4uL2NoZWNrL2FyYml0cmFyeS9kZWZpbml0aW9uL0NvbnZlcnRlcnNcIik7XG5mdW5jdGlvbiBsZXRyZWMoYnVpbGRlcikge1xuICAgIGNvbnN0IGxhenlBcmJzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICBjb25zdCB0aWUgPSAoa2V5KSA9PiB7XG4gICAgICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGxhenlBcmJzLCBrZXkpKSB7XG4gICAgICAgICAgICBsYXp5QXJic1trZXldID0gbmV3IExhenlBcmJpdHJhcnlfMS5MYXp5QXJiaXRyYXJ5KFN0cmluZyhrZXkpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gQ29udmVydGVyc18xLmNvbnZlcnRGcm9tTmV4dChsYXp5QXJic1trZXldKTtcbiAgICB9O1xuICAgIGNvbnN0IHN0cmljdEFyYnMgPSBidWlsZGVyKHRpZSk7XG4gICAgZm9yIChjb25zdCBrZXkgaW4gc3RyaWN0QXJicykge1xuICAgICAgICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzdHJpY3RBcmJzLCBrZXkpKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBsYXp5QXRLZXkgPSBsYXp5QXJic1trZXldO1xuICAgICAgICBjb25zdCBsYXp5QXJiID0gbGF6eUF0S2V5ICE9PSB1bmRlZmluZWQgPyBsYXp5QXRLZXkgOiBuZXcgTGF6eUFyYml0cmFyeV8xLkxhenlBcmJpdHJhcnkoa2V5KTtcbiAgICAgICAgbGF6eUFyYi51bmRlcmx5aW5nID0gQ29udmVydGVyc18xLmNvbnZlcnRUb05leHQoc3RyaWN0QXJic1trZXldKTtcbiAgICAgICAgbGF6eUFyYnNba2V5XSA9IGxhenlBcmI7XG4gICAgfVxuICAgIHJldHVybiBzdHJpY3RBcmJzO1xufVxuZXhwb3J0cy5sZXRyZWMgPSBsZXRyZWM7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMubG9yZW0gPSB2b2lkIDA7XG5jb25zdCBhcnJheV8xID0gcmVxdWlyZShcIi4vYXJyYXlcIik7XG5jb25zdCBjb25zdGFudF8xID0gcmVxdWlyZShcIi4vY29uc3RhbnRcIik7XG5jb25zdCBmcmVxdWVuY3lfMSA9IHJlcXVpcmUoXCIuL2ZyZXF1ZW5jeVwiKTtcbmNvbnN0IFdvcmRzVG9Mb3JlbV8xID0gcmVxdWlyZShcIi4vX2ludGVybmFscy9tYXBwZXJzL1dvcmRzVG9Mb3JlbVwiKTtcbmNvbnN0IENvbnZlcnRlcnNfMSA9IHJlcXVpcmUoXCIuLi9jaGVjay9hcmJpdHJhcnkvZGVmaW5pdGlvbi9Db252ZXJ0ZXJzXCIpO1xuY29uc3QgaCA9ICh2LCB3KSA9PiB7XG4gICAgcmV0dXJuIHsgYXJiaXRyYXJ5OiBjb25zdGFudF8xLmNvbnN0YW50KHYpLCB3ZWlnaHQ6IHcgfTtcbn07XG5mdW5jdGlvbiBsb3JlbVdvcmQoKSB7XG4gICAgcmV0dXJuIGZyZXF1ZW5jeV8xLmZyZXF1ZW5jeShoKCdub24nLCA2KSwgaCgnYWRpcGlzY2luZycsIDUpLCBoKCdsaWd1bGEnLCA1KSwgaCgnZW5pbScsIDUpLCBoKCdwZWxsZW50ZXNxdWUnLCA1KSwgaCgnaW4nLCA1KSwgaCgnYXVndWUnLCA1KSwgaCgnZXQnLCA1KSwgaCgnbnVsbGEnLCA1KSwgaCgnbG9yZW0nLCA0KSwgaCgnc2l0JywgNCksIGgoJ3NlZCcsIDQpLCBoKCdkaWFtJywgNCksIGgoJ2Zlcm1lbnR1bScsIDQpLCBoKCd1dCcsIDQpLCBoKCdldScsIDQpLCBoKCdhbGlxdWFtJywgNCksIGgoJ21hdXJpcycsIDQpLCBoKCd2aXRhZScsIDQpLCBoKCdmZWxpcycsIDQpLCBoKCdpcHN1bScsIDMpLCBoKCdkb2xvcicsIDMpLCBoKCdhbWV0LCcsIDMpLCBoKCdlbGl0JywgMyksIGgoJ2V1aXNtb2QnLCAzKSwgaCgnbWknLCAzKSwgaCgnb3JjaScsIDMpLCBoKCdlcmF0JywgMyksIGgoJ3ByYWVzZW50JywgMyksIGgoJ2VnZXN0YXMnLCAzKSwgaCgnbGVvJywgMyksIGgoJ3ZlbCcsIDMpLCBoKCdzYXBpZW4nLCAzKSwgaCgnaW50ZWdlcicsIDMpLCBoKCdjdXJhYml0dXInLCAzKSwgaCgnY29udmFsbGlzJywgMyksIGgoJ3B1cnVzJywgMyksIGgoJ3Jpc3VzJywgMiksIGgoJ3N1c3BlbmRpc3NlJywgMiksIGgoJ2xlY3R1cycsIDIpLCBoKCduZWMsJywgMiksIGgoJ3VsdHJpY2llcycsIDIpLCBoKCdzZWQsJywgMiksIGgoJ2NyYXMnLCAyKSwgaCgnZWxlbWVudHVtJywgMiksIGgoJ3VsdHJpY2VzJywgMiksIGgoJ21hZWNlbmFzJywgMiksIGgoJ21hc3NhLCcsIDIpLCBoKCd2YXJpdXMnLCAyKSwgaCgnYSwnLCAyKSwgaCgnc2VtcGVyJywgMiksIGgoJ3Byb2luJywgMiksIGgoJ25lYycsIDIpLCBoKCduaXNsJywgMiksIGgoJ2FtZXQnLCAyKSwgaCgnZHVpcycsIDIpLCBoKCdjb25ndWUnLCAyKSwgaCgnbGliZXJvJywgMiksIGgoJ3Zlc3RpYnVsdW0nLCAyKSwgaCgncGVkZScsIDIpLCBoKCdibGFuZGl0JywgMiksIGgoJ3NvZGFsZXMnLCAyKSwgaCgnYW50ZScsIDIpLCBoKCduaWJoJywgMiksIGgoJ2FjJywgMiksIGgoJ2FlbmVhbicsIDIpLCBoKCdtYXNzYScsIDIpLCBoKCdzdXNjaXBpdCcsIDIpLCBoKCdzb2xsaWNpdHVkaW4nLCAyKSwgaCgnZnVzY2UnLCAyKSwgaCgndGVtcHVzJywgMiksIGgoJ2FsaXF1YW0sJywgMiksIGgoJ251bmMnLCAyKSwgaCgndWxsYW1jb3JwZXInLCAyKSwgaCgncmhvbmN1cycsIDIpLCBoKCdtZXR1cycsIDIpLCBoKCdmYXVjaWJ1cywnLCAyKSwgaCgnanVzdG8nLCAyKSwgaCgnbWFnbmEnLCAyKSwgaCgnYXQnLCAyKSwgaCgndGluY2lkdW50JywgMiksIGgoJ2NvbnNlY3RldHVyJywgMSksIGgoJ3RvcnRvciwnLCAxKSwgaCgnZGlnbmlzc2ltJywgMSksIGgoJ2Nvbmd1ZSwnLCAxKSwgaCgnbm9uLCcsIDEpLCBoKCdwb3J0dGl0b3IsJywgMSksIGgoJ25vbnVtbXknLCAxKSwgaCgnbW9sZXN0aWUsJywgMSksIGgoJ2VzdCcsIDEpLCBoKCdlbGVpZmVuZCcsIDEpLCBoKCdtaSwnLCAxKSwgaCgnYXJjdScsIDEpLCBoKCdzY2VsZXJpc3F1ZScsIDEpLCBoKCd2aXRhZSwnLCAxKSwgaCgnY29uc2VxdWF0JywgMSksIGgoJ2luLCcsIDEpLCBoKCdwcmV0aXVtJywgMSksIGgoJ3ZvbHV0cGF0JywgMSksIGgoJ3BoYXJldHJhJywgMSksIGgoJ3RlbXBvcicsIDEpLCBoKCdiaWJlbmR1bScsIDEpLCBoKCdvZGlvJywgMSksIGgoJ2R1aScsIDEpLCBoKCdwcmltaXMnLCAxKSwgaCgnZmF1Y2lidXMnLCAxKSwgaCgnbHVjdHVzJywgMSksIGgoJ3Bvc3VlcmUnLCAxKSwgaCgnY3ViaWxpYScsIDEpLCBoKCdjdXJhZSwnLCAxKSwgaCgnaGVuZHJlcml0JywgMSksIGgoJ3ZlbGl0JywgMSksIGgoJ21hdXJpcywnLCAxKSwgaCgnZ3JhdmlkYScsIDEpLCBoKCdvcm5hcmUnLCAxKSwgaCgndXQsJywgMSksIGgoJ3B1bHZpbmFyJywgMSksIGgoJ3Zhcml1cywnLCAxKSwgaCgndHVycGlzJywgMSksIGgoJ25pYmgsJywgMSksIGgoJ2Vyb3MnLCAxKSwgaCgnaWQnLCAxKSwgaCgnYWxpcXVldCcsIDEpLCBoKCdxdWlzJywgMSksIGgoJ2xvYm9ydGlzJywgMSksIGgoJ2NvbnNlY3RldHVlcicsIDEpLCBoKCdtb3JiaScsIDEpLCBoKCd2ZWhpY3VsYScsIDEpLCBoKCd0b3J0b3InLCAxKSwgaCgndGVsbHVzLCcsIDEpLCBoKCdpZCwnLCAxKSwgaCgnZXUsJywgMSksIGgoJ3F1YW0nLCAxKSwgaCgnZmV1Z2lhdCwnLCAxKSwgaCgncG9zdWVyZSwnLCAxKSwgaCgnaWFjdWxpcycsIDEpLCBoKCdsZWN0dXMsJywgMSksIGgoJ3RyaXN0aXF1ZScsIDEpLCBoKCdtb2xsaXMsJywgMSksIGgoJ25pc2wsJywgMSksIGgoJ3Z1bHB1dGF0ZScsIDEpLCBoKCdzZW0nLCAxKSwgaCgndml2YW11cycsIDEpLCBoKCdwbGFjZXJhdCcsIDEpLCBoKCdpbXBlcmRpZXQnLCAxKSwgaCgnY3Vyc3VzJywgMSksIGgoJ3J1dHJ1bScsIDEpLCBoKCdpYWN1bGlzLCcsIDEpLCBoKCdhdWd1ZSwnLCAxKSwgaCgnbGFjdXMnLCAxKSk7XG59XG5mdW5jdGlvbiBsb3JlbSguLi5hcmdzKSB7XG4gICAgY29uc3QgbWF4V29yZHNDb3VudCA9IHR5cGVvZiBhcmdzWzBdID09PSAnb2JqZWN0JyA/IGFyZ3NbMF0ubWF4Q291bnQgOiBhcmdzWzBdO1xuICAgIGNvbnN0IHNlbnRlbmNlc01vZGUgPSB0eXBlb2YgYXJnc1swXSA9PT0gJ29iamVjdCcgPyBhcmdzWzBdLm1vZGUgPT09ICdzZW50ZW5jZXMnIDogYXJnc1sxXTtcbiAgICBjb25zdCBtYXhDb3VudCA9IG1heFdvcmRzQ291bnQgIT09IHVuZGVmaW5lZCA/IG1heFdvcmRzQ291bnQgOiA1O1xuICAgIGlmIChtYXhDb3VudCA8IDEpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBsb3JlbSBoYXMgdG8gcHJvZHVjZSBhdCBsZWFzdCBvbmUgd29yZC9zZW50ZW5jZWApO1xuICAgIH1cbiAgICBjb25zdCB3b3JkQXJiaXRyYXJ5ID0gbG9yZW1Xb3JkKCk7XG4gICAgY29uc3Qgd29yZEFyYml0cmFyeU5leHQgPSBDb252ZXJ0ZXJzXzEuY29udmVydFRvTmV4dCh3b3JkQXJiaXRyYXJ5KTtcbiAgICBpZiAoc2VudGVuY2VzTW9kZSkge1xuICAgICAgICBjb25zdCBzZW50ZW5jZSA9IENvbnZlcnRlcnNfMS5jb252ZXJ0VG9OZXh0KGFycmF5XzEuYXJyYXkod29yZEFyYml0cmFyeSwgeyBtaW5MZW5ndGg6IDEgfSkpLm1hcChXb3Jkc1RvTG9yZW1fMS53b3Jkc1RvU2VudGVuY2VNYXBwZXIsIFdvcmRzVG9Mb3JlbV8xLndvcmRzVG9TZW50ZW5jZVVubWFwcGVyRm9yKHdvcmRBcmJpdHJhcnlOZXh0KSk7XG4gICAgICAgIHJldHVybiBDb252ZXJ0ZXJzXzEuY29udmVydEZyb21OZXh0KENvbnZlcnRlcnNfMS5jb252ZXJ0VG9OZXh0KGFycmF5XzEuYXJyYXkoQ29udmVydGVyc18xLmNvbnZlcnRGcm9tTmV4dChzZW50ZW5jZSksIHsgbWluTGVuZ3RoOiAxLCBtYXhMZW5ndGg6IG1heENvdW50IH0pKS5tYXAoV29yZHNUb0xvcmVtXzEuc2VudGVuY2VzVG9QYXJhZ3JhcGhNYXBwZXIsIFdvcmRzVG9Mb3JlbV8xLnNlbnRlbmNlc1RvUGFyYWdyYXBoVW5tYXBwZXIpKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBDb252ZXJ0ZXJzXzEuY29udmVydEZyb21OZXh0KENvbnZlcnRlcnNfMS5jb252ZXJ0VG9OZXh0KGFycmF5XzEuYXJyYXkod29yZEFyYml0cmFyeSwgeyBtaW5MZW5ndGg6IDEsIG1heExlbmd0aDogbWF4Q291bnQgfSkpLm1hcChXb3Jkc1RvTG9yZW1fMS53b3Jkc1RvSm9pbmVkU3RyaW5nTWFwcGVyLCBXb3Jkc1RvTG9yZW1fMS53b3Jkc1RvSm9pbmVkU3RyaW5nVW5tYXBwZXJGb3Iod29yZEFyYml0cmFyeU5leHQpKSk7XG4gICAgfVxufVxuZXhwb3J0cy5sb3JlbSA9IGxvcmVtO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLm1hcFRvQ29uc3RhbnQgPSB2b2lkIDA7XG5jb25zdCBDb252ZXJ0ZXJzXzEgPSByZXF1aXJlKFwiLi4vY2hlY2svYXJiaXRyYXJ5L2RlZmluaXRpb24vQ29udmVydGVyc1wiKTtcbmNvbnN0IG5hdF8xID0gcmVxdWlyZShcIi4vbmF0XCIpO1xuY29uc3QgSW5kZXhUb01hcHBlZENvbnN0YW50XzEgPSByZXF1aXJlKFwiLi9faW50ZXJuYWxzL21hcHBlcnMvSW5kZXhUb01hcHBlZENvbnN0YW50XCIpO1xuZnVuY3Rpb24gY29tcHV0ZU51bUNob2ljZXMob3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zLmxlbmd0aCA9PT0gMClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBmYy5tYXBUb0NvbnN0YW50IGV4cGVjdHMgYXQgbGVhc3Qgb25lIG9wdGlvbmApO1xuICAgIGxldCBudW1DaG9pY2VzID0gMDtcbiAgICBmb3IgKGxldCBpZHggPSAwOyBpZHggIT09IG9wdGlvbnMubGVuZ3RoOyArK2lkeCkge1xuICAgICAgICBpZiAob3B0aW9uc1tpZHhdLm51bSA8IDApXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGZjLm1hcFRvQ29uc3RhbnQgZXhwZWN0cyBhbGwgb3B0aW9ucyB0byBoYXZlIGEgbnVtYmVyIG9mIGVudHJpZXMgZ3JlYXRlciBvciBlcXVhbCB0byB6ZXJvYCk7XG4gICAgICAgIG51bUNob2ljZXMgKz0gb3B0aW9uc1tpZHhdLm51bTtcbiAgICB9XG4gICAgaWYgKG51bUNob2ljZXMgPT09IDApXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgZmMubWFwVG9Db25zdGFudCBleHBlY3RzIGF0IGxlYXN0IG9uZSBjaG9pY2UgYW1vbmcgb3B0aW9uc2ApO1xuICAgIHJldHVybiBudW1DaG9pY2VzO1xufVxuZnVuY3Rpb24gbWFwVG9Db25zdGFudCguLi5lbnRyaWVzKSB7XG4gICAgY29uc3QgbnVtQ2hvaWNlcyA9IGNvbXB1dGVOdW1DaG9pY2VzKGVudHJpZXMpO1xuICAgIHJldHVybiBDb252ZXJ0ZXJzXzEuY29udmVydEZyb21OZXh0KENvbnZlcnRlcnNfMS5jb252ZXJ0VG9OZXh0KG5hdF8xLm5hdCh7IG1heDogbnVtQ2hvaWNlcyAtIDEgfSkpLm1hcChJbmRleFRvTWFwcGVkQ29uc3RhbnRfMS5pbmRleFRvTWFwcGVkQ29uc3RhbnRNYXBwZXJGb3IoZW50cmllcyksIEluZGV4VG9NYXBwZWRDb25zdGFudF8xLmluZGV4VG9NYXBwZWRDb25zdGFudFVubWFwcGVyRm9yKGVudHJpZXMpKSk7XG59XG5leHBvcnRzLm1hcFRvQ29uc3RhbnQgPSBtYXBUb0NvbnN0YW50O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLm1heFNhZmVJbnRlZ2VyID0gdm9pZCAwO1xuY29uc3QgQ29udmVydGVyc18xID0gcmVxdWlyZShcIi4uL2NoZWNrL2FyYml0cmFyeS9kZWZpbml0aW9uL0NvbnZlcnRlcnNcIik7XG5jb25zdCBJbnRlZ2VyQXJiaXRyYXJ5XzEgPSByZXF1aXJlKFwiLi9faW50ZXJuYWxzL0ludGVnZXJBcmJpdHJhcnlcIik7XG5mdW5jdGlvbiBtYXhTYWZlSW50ZWdlcigpIHtcbiAgICBjb25zdCBhcmIgPSBuZXcgSW50ZWdlckFyYml0cmFyeV8xLkludGVnZXJBcmJpdHJhcnkoTnVtYmVyLk1JTl9TQUZFX0lOVEVHRVIsIE51bWJlci5NQVhfU0FGRV9JTlRFR0VSKTtcbiAgICByZXR1cm4gQ29udmVydGVyc18xLmNvbnZlcnRGcm9tTmV4dFdpdGhTaHJ1bmtPbmNlKGFyYiwgYXJiLmRlZmF1bHRUYXJnZXQoKSk7XG59XG5leHBvcnRzLm1heFNhZmVJbnRlZ2VyID0gbWF4U2FmZUludGVnZXI7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMubWF4U2FmZU5hdCA9IHZvaWQgMDtcbmNvbnN0IENvbnZlcnRlcnNfMSA9IHJlcXVpcmUoXCIuLi9jaGVjay9hcmJpdHJhcnkvZGVmaW5pdGlvbi9Db252ZXJ0ZXJzXCIpO1xuY29uc3QgSW50ZWdlckFyYml0cmFyeV8xID0gcmVxdWlyZShcIi4vX2ludGVybmFscy9JbnRlZ2VyQXJiaXRyYXJ5XCIpO1xuZnVuY3Rpb24gbWF4U2FmZU5hdCgpIHtcbiAgICBjb25zdCBhcmIgPSBuZXcgSW50ZWdlckFyYml0cmFyeV8xLkludGVnZXJBcmJpdHJhcnkoMCwgTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIpO1xuICAgIHJldHVybiBDb252ZXJ0ZXJzXzEuY29udmVydEZyb21OZXh0V2l0aFNocnVua09uY2UoYXJiLCBhcmIuZGVmYXVsdFRhcmdldCgpKTtcbn1cbmV4cG9ydHMubWF4U2FmZU5hdCA9IG1heFNhZmVOYXQ7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMubWVtbyA9IHZvaWQgMDtcbmxldCBjb250ZXh0UmVtYWluaW5nRGVwdGggPSAxMDtcbmZ1bmN0aW9uIG1lbW8oYnVpbGRlcikge1xuICAgIGNvbnN0IHByZXZpb3VzID0ge307XG4gICAgcmV0dXJuICgobWF4RGVwdGgpID0+IHtcbiAgICAgICAgY29uc3QgbiA9IG1heERlcHRoICE9PSB1bmRlZmluZWQgPyBtYXhEZXB0aCA6IGNvbnRleHRSZW1haW5pbmdEZXB0aDtcbiAgICAgICAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocHJldmlvdXMsIG4pKSB7XG4gICAgICAgICAgICBjb25zdCBwcmV2ID0gY29udGV4dFJlbWFpbmluZ0RlcHRoO1xuICAgICAgICAgICAgY29udGV4dFJlbWFpbmluZ0RlcHRoID0gbiAtIDE7XG4gICAgICAgICAgICBwcmV2aW91c1tuXSA9IGJ1aWxkZXIobik7XG4gICAgICAgICAgICBjb250ZXh0UmVtYWluaW5nRGVwdGggPSBwcmV2O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwcmV2aW91c1tuXTtcbiAgICB9KTtcbn1cbmV4cG9ydHMubWVtbyA9IG1lbW87XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMubWl4ZWRDYXNlID0gdm9pZCAwO1xuY29uc3QgQ29udmVydGVyc18xID0gcmVxdWlyZShcIi4uL2NoZWNrL2FyYml0cmFyeS9kZWZpbml0aW9uL0NvbnZlcnRlcnNcIik7XG5jb25zdCBNaXhlZENhc2VBcmJpdHJhcnlfMSA9IHJlcXVpcmUoXCIuL19pbnRlcm5hbHMvTWl4ZWRDYXNlQXJiaXRyYXJ5XCIpO1xuZnVuY3Rpb24gZGVmYXVsdFRvZ2dsZUNhc2UocmF3Q2hhcikge1xuICAgIGNvbnN0IHVwcGVyID0gcmF3Q2hhci50b1VwcGVyQ2FzZSgpO1xuICAgIGlmICh1cHBlciAhPT0gcmF3Q2hhcilcbiAgICAgICAgcmV0dXJuIHVwcGVyO1xuICAgIHJldHVybiByYXdDaGFyLnRvTG93ZXJDYXNlKCk7XG59XG5mdW5jdGlvbiBtaXhlZENhc2Uoc3RyaW5nQXJiLCBjb25zdHJhaW50cykge1xuICAgIGlmICh0eXBlb2YgQmlnSW50ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYG1peGVkQ2FzZSByZXF1aXJlcyBCaWdJbnQgc3VwcG9ydGApO1xuICAgIH1cbiAgICBjb25zdCB0b2dnbGVDYXNlID0gKGNvbnN0cmFpbnRzICYmIGNvbnN0cmFpbnRzLnRvZ2dsZUNhc2UpIHx8IGRlZmF1bHRUb2dnbGVDYXNlO1xuICAgIHJldHVybiBDb252ZXJ0ZXJzXzEuY29udmVydEZyb21OZXh0KG5ldyBNaXhlZENhc2VBcmJpdHJhcnlfMS5NaXhlZENhc2VBcmJpdHJhcnkoQ29udmVydGVyc18xLmNvbnZlcnRUb05leHQoc3RyaW5nQXJiKSwgdG9nZ2xlQ2FzZSkpO1xufVxuZXhwb3J0cy5taXhlZENhc2UgPSBtaXhlZENhc2U7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMubmF0ID0gdm9pZCAwO1xuY29uc3QgQ29udmVydGVyc18xID0gcmVxdWlyZShcIi4uL2NoZWNrL2FyYml0cmFyeS9kZWZpbml0aW9uL0NvbnZlcnRlcnNcIik7XG5jb25zdCBJbnRlZ2VyQXJiaXRyYXJ5XzEgPSByZXF1aXJlKFwiLi9faW50ZXJuYWxzL0ludGVnZXJBcmJpdHJhcnlcIik7XG5mdW5jdGlvbiBuYXQoYXJnKSB7XG4gICAgY29uc3QgbWF4ID0gdHlwZW9mIGFyZyA9PT0gJ251bWJlcicgPyBhcmcgOiBhcmcgJiYgYXJnLm1heCAhPT0gdW5kZWZpbmVkID8gYXJnLm1heCA6IDB4N2ZmZmZmZmY7XG4gICAgaWYgKG1heCA8IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdmYy5uYXQgdmFsdWUgc2hvdWxkIGJlIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byAwJyk7XG4gICAgfVxuICAgIGNvbnN0IGFyYiA9IG5ldyBJbnRlZ2VyQXJiaXRyYXJ5XzEuSW50ZWdlckFyYml0cmFyeSgwLCBtYXgpO1xuICAgIHJldHVybiBDb252ZXJ0ZXJzXzEuY29udmVydEZyb21OZXh0V2l0aFNocnVua09uY2UoYXJiLCBhcmIuZGVmYXVsdFRhcmdldCgpKTtcbn1cbmV4cG9ydHMubmF0ID0gbmF0O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLm9uZW9mID0gdm9pZCAwO1xuY29uc3QgRnJlcXVlbmN5QXJiaXRyYXJ5XzEgPSByZXF1aXJlKFwiLi9faW50ZXJuYWxzL0ZyZXF1ZW5jeUFyYml0cmFyeVwiKTtcbmZ1bmN0aW9uIGlzT25lT2ZDb250cmFpbnRzKHBhcmFtKSB7XG4gICAgcmV0dXJuIHBhcmFtICE9IG51bGwgJiYgdHlwZW9mIHBhcmFtID09PSAnb2JqZWN0JyAmJiAhKCdnZW5lcmF0ZScgaW4gcGFyYW0pO1xufVxuZnVuY3Rpb24gb25lb2YoLi4uYXJncykge1xuICAgIGNvbnN0IGNvbnN0cmFpbnRzID0gYXJnc1swXTtcbiAgICBpZiAoaXNPbmVPZkNvbnRyYWludHMoY29uc3RyYWludHMpKSB7XG4gICAgICAgIGNvbnN0IHdlaWdodGVkQXJicyA9IGFyZ3Muc2xpY2UoMSkubWFwKChhcmJpdHJhcnkpID0+ICh7IGFyYml0cmFyeSwgd2VpZ2h0OiAxIH0pKTtcbiAgICAgICAgcmV0dXJuIEZyZXF1ZW5jeUFyYml0cmFyeV8xLkZyZXF1ZW5jeUFyYml0cmFyeS5mcm9tT2xkKHdlaWdodGVkQXJicywgY29uc3RyYWludHMsICdmYy5vbmVvZicpO1xuICAgIH1cbiAgICBjb25zdCB3ZWlnaHRlZEFyYnMgPSBhcmdzLm1hcCgoYXJiaXRyYXJ5KSA9PiAoeyBhcmJpdHJhcnksIHdlaWdodDogMSB9KSk7XG4gICAgcmV0dXJuIEZyZXF1ZW5jeUFyYml0cmFyeV8xLkZyZXF1ZW5jeUFyYml0cmFyeS5mcm9tT2xkKHdlaWdodGVkQXJicywge30sICdmYy5vbmVvZicpO1xufVxuZXhwb3J0cy5vbmVvZiA9IG9uZW9mO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLm9wdGlvbiA9IHZvaWQgMDtcbmNvbnN0IGNvbnN0YW50XzEgPSByZXF1aXJlKFwiLi9jb25zdGFudFwiKTtcbmNvbnN0IEZyZXF1ZW5jeUFyYml0cmFyeV8xID0gcmVxdWlyZShcIi4vX2ludGVybmFscy9GcmVxdWVuY3lBcmJpdHJhcnlcIik7XG5mdW5jdGlvbiBleHRyYWN0T3B0aW9uQ29uc3RyYWludHMoY29uc3RyYWludHMpIHtcbiAgICBpZiAodHlwZW9mIGNvbnN0cmFpbnRzID09PSAnbnVtYmVyJylcbiAgICAgICAgcmV0dXJuIHsgZnJlcTogY29uc3RyYWludHMgfTtcbiAgICBpZiAoIWNvbnN0cmFpbnRzKVxuICAgICAgICByZXR1cm4ge307XG4gICAgcmV0dXJuIGNvbnN0cmFpbnRzO1xufVxuZnVuY3Rpb24gb3B0aW9uKGFyYiwgcmF3Q29uc3RyYWludHMpIHtcbiAgICBjb25zdCBjb25zdHJhaW50cyA9IGV4dHJhY3RPcHRpb25Db25zdHJhaW50cyhyYXdDb25zdHJhaW50cyk7XG4gICAgY29uc3QgZnJlcSA9IGNvbnN0cmFpbnRzLmZyZXEgPT0gbnVsbCA/IDUgOiBjb25zdHJhaW50cy5mcmVxO1xuICAgIGNvbnN0IG5pbFZhbHVlID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbnN0cmFpbnRzLCAnbmlsJykgPyBjb25zdHJhaW50cy5uaWwgOiBudWxsO1xuICAgIGNvbnN0IG5pbEFyYiA9IGNvbnN0YW50XzEuY29uc3RhbnQobmlsVmFsdWUpO1xuICAgIGNvbnN0IHdlaWdodGVkQXJicyA9IFtcbiAgICAgICAgeyBhcmJpdHJhcnk6IG5pbEFyYiwgd2VpZ2h0OiAxLCBmYWxsYmFja1ZhbHVlOiB7IGRlZmF1bHQ6IG5pbFZhbHVlIH0gfSxcbiAgICAgICAgeyBhcmJpdHJhcnk6IGFyYiwgd2VpZ2h0OiBmcmVxIH0sXG4gICAgXTtcbiAgICBjb25zdCBmcmVxdWVuY3lDb25zdHJhaW50cyA9IHtcbiAgICAgICAgd2l0aENyb3NzU2hyaW5rOiB0cnVlLFxuICAgICAgICBkZXB0aEZhY3RvcjogY29uc3RyYWludHMuZGVwdGhGYWN0b3IsXG4gICAgICAgIG1heERlcHRoOiBjb25zdHJhaW50cy5tYXhEZXB0aCxcbiAgICAgICAgZGVwdGhJZGVudGlmaWVyOiBjb25zdHJhaW50cy5kZXB0aElkZW50aWZpZXIsXG4gICAgfTtcbiAgICByZXR1cm4gRnJlcXVlbmN5QXJiaXRyYXJ5XzEuRnJlcXVlbmN5QXJiaXRyYXJ5LmZyb21PbGQod2VpZ2h0ZWRBcmJzLCBmcmVxdWVuY3lDb25zdHJhaW50cywgJ2ZjLm9wdGlvbicpO1xufVxuZXhwb3J0cy5vcHRpb24gPSBvcHRpb247XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMucmVjb3JkID0gdm9pZCAwO1xuY29uc3QgUGFydGlhbFJlY29yZEFyYml0cmFyeUJ1aWxkZXJfMSA9IHJlcXVpcmUoXCIuL19pbnRlcm5hbHMvYnVpbGRlcnMvUGFydGlhbFJlY29yZEFyYml0cmFyeUJ1aWxkZXJcIik7XG5mdW5jdGlvbiByZWNvcmQocmVjb3JkTW9kZWwsIGNvbnN0cmFpbnRzKSB7XG4gICAgaWYgKGNvbnN0cmFpbnRzID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIFBhcnRpYWxSZWNvcmRBcmJpdHJhcnlCdWlsZGVyXzEuYnVpbGRQYXJ0aWFsUmVjb3JkQXJiaXRyYXJ5KHJlY29yZE1vZGVsLCB1bmRlZmluZWQpO1xuICAgIH1cbiAgICBpZiAoJ3dpdGhEZWxldGVkS2V5cycgaW4gY29uc3RyYWludHMgJiYgJ3JlcXVpcmVkS2V5cycgaW4gY29uc3RyYWludHMpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGByZXF1aXJlZEtleXMgYW5kIHdpdGhEZWxldGVkS2V5cyBjYW5ub3QgYmUgdXNlZCB0b2dldGhlciBpbiBmYy5yZWNvcmRgKTtcbiAgICB9XG4gICAgY29uc3QgcmVxdWlyZURlbGV0ZWRLZXlzID0gKCdyZXF1aXJlZEtleXMnIGluIGNvbnN0cmFpbnRzICYmIGNvbnN0cmFpbnRzLnJlcXVpcmVkS2V5cyAhPT0gdW5kZWZpbmVkKSB8fFxuICAgICAgICAoJ3dpdGhEZWxldGVkS2V5cycgaW4gY29uc3RyYWludHMgJiYgISFjb25zdHJhaW50cy53aXRoRGVsZXRlZEtleXMpO1xuICAgIGlmICghcmVxdWlyZURlbGV0ZWRLZXlzKSB7XG4gICAgICAgIHJldHVybiBQYXJ0aWFsUmVjb3JkQXJiaXRyYXJ5QnVpbGRlcl8xLmJ1aWxkUGFydGlhbFJlY29yZEFyYml0cmFyeShyZWNvcmRNb2RlbCwgdW5kZWZpbmVkKTtcbiAgICB9XG4gICAgY29uc3QgcmVxdWlyZWRLZXlzID0gKCdyZXF1aXJlZEtleXMnIGluIGNvbnN0cmFpbnRzID8gY29uc3RyYWludHMucmVxdWlyZWRLZXlzIDogdW5kZWZpbmVkKSB8fCBbXTtcbiAgICBmb3IgKGxldCBpZHggPSAwOyBpZHggIT09IHJlcXVpcmVkS2V5cy5sZW5ndGg7ICsraWR4KSB7XG4gICAgICAgIGNvbnN0IGRlc2NyaXB0b3IgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHJlY29yZE1vZGVsLCByZXF1aXJlZEtleXNbaWR4XSk7XG4gICAgICAgIGlmIChkZXNjcmlwdG9yID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgcmVxdWlyZWRLZXlzIGNhbm5vdCByZWZlcmVuY2Uga2V5cyB0aGF0IGhhdmUgbm90IGJlZW4gZGVmaW5lZCBpbiByZWNvcmRNb2RlbGApO1xuICAgICAgICB9XG4gICAgICAgIGlmICghZGVzY3JpcHRvci5lbnVtZXJhYmxlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHJlcXVpcmVkS2V5cyBjYW5ub3QgcmVmZXJlbmNlIGtleXMgdGhhdCBoYXZlIGFyZSBlbnVtZXJhYmxlIGluIHJlY29yZE1vZGVsYCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIFBhcnRpYWxSZWNvcmRBcmJpdHJhcnlCdWlsZGVyXzEuYnVpbGRQYXJ0aWFsUmVjb3JkQXJiaXRyYXJ5KHJlY29yZE1vZGVsLCByZXF1aXJlZEtleXMpO1xufVxuZXhwb3J0cy5yZWNvcmQgPSByZWNvcmQ7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuc2NoZWR1bGVyRm9yID0gZXhwb3J0cy5zY2hlZHVsZXIgPSB2b2lkIDA7XG5jb25zdCBDb252ZXJ0ZXJzXzEgPSByZXF1aXJlKFwiLi4vY2hlY2svYXJiaXRyYXJ5L2RlZmluaXRpb24vQ29udmVydGVyc1wiKTtcbmNvbnN0IEJ1aWxkU2NoZWR1bGVyRm9yXzEgPSByZXF1aXJlKFwiLi9faW50ZXJuYWxzL2hlbHBlcnMvQnVpbGRTY2hlZHVsZXJGb3JcIik7XG5jb25zdCBTY2hlZHVsZXJBcmJpdHJhcnlfMSA9IHJlcXVpcmUoXCIuL19pbnRlcm5hbHMvU2NoZWR1bGVyQXJiaXRyYXJ5XCIpO1xuZnVuY3Rpb24gc2NoZWR1bGVyKGNvbnN0cmFpbnRzKSB7XG4gICAgY29uc3QgeyBhY3QgPSAoZikgPT4gZigpIH0gPSBjb25zdHJhaW50cyB8fCB7fTtcbiAgICByZXR1cm4gQ29udmVydGVyc18xLmNvbnZlcnRGcm9tTmV4dChuZXcgU2NoZWR1bGVyQXJiaXRyYXJ5XzEuU2NoZWR1bGVyQXJiaXRyYXJ5KGFjdCkpO1xufVxuZXhwb3J0cy5zY2hlZHVsZXIgPSBzY2hlZHVsZXI7XG5mdW5jdGlvbiBzY2hlZHVsZXJGb3IoY3VzdG9tT3JkZXJpbmdPckNvbnN0cmFpbnRzLCBjb25zdHJhaW50c09yVW5kZWZpbmVkKSB7XG4gICAgY29uc3QgeyBhY3QgPSAoZikgPT4gZigpIH0gPSBBcnJheS5pc0FycmF5KGN1c3RvbU9yZGVyaW5nT3JDb25zdHJhaW50cylcbiAgICAgICAgPyBjb25zdHJhaW50c09yVW5kZWZpbmVkIHx8IHt9XG4gICAgICAgIDogY3VzdG9tT3JkZXJpbmdPckNvbnN0cmFpbnRzIHx8IHt9O1xuICAgIGlmIChBcnJheS5pc0FycmF5KGN1c3RvbU9yZGVyaW5nT3JDb25zdHJhaW50cykpIHtcbiAgICAgICAgcmV0dXJuIEJ1aWxkU2NoZWR1bGVyRm9yXzEuYnVpbGRTY2hlZHVsZXJGb3IoYWN0LCBjdXN0b21PcmRlcmluZ09yQ29uc3RyYWludHMpO1xuICAgIH1cbiAgICByZXR1cm4gZnVuY3Rpb24gKF9zdHJzLCAuLi5vcmRlcmluZykge1xuICAgICAgICByZXR1cm4gQnVpbGRTY2hlZHVsZXJGb3JfMS5idWlsZFNjaGVkdWxlckZvcihhY3QsIG9yZGVyaW5nKTtcbiAgICB9O1xufVxuZXhwb3J0cy5zY2hlZHVsZXJGb3IgPSBzY2hlZHVsZXJGb3I7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuc2V0ID0gdm9pZCAwO1xuY29uc3QgQXJyYXlBcmJpdHJhcnlfMSA9IHJlcXVpcmUoXCIuL19pbnRlcm5hbHMvQXJyYXlBcmJpdHJhcnlcIik7XG5jb25zdCBDb252ZXJ0ZXJzXzEgPSByZXF1aXJlKFwiLi4vY2hlY2svYXJiaXRyYXJ5L2RlZmluaXRpb24vQ29udmVydGVyc1wiKTtcbmNvbnN0IE1heExlbmd0aEZyb21NaW5MZW5ndGhfMSA9IHJlcXVpcmUoXCIuL19pbnRlcm5hbHMvaGVscGVycy9NYXhMZW5ndGhGcm9tTWluTGVuZ3RoXCIpO1xuZnVuY3Rpb24gYnVpbGRDb21wbGV0ZVNldENvbnN0cmFpbnRzKGNvbnN0cmFpbnRzKSB7XG4gICAgY29uc3QgbWluTGVuZ3RoID0gY29uc3RyYWludHMubWluTGVuZ3RoICE9PSB1bmRlZmluZWQgPyBjb25zdHJhaW50cy5taW5MZW5ndGggOiAwO1xuICAgIGNvbnN0IG1heExlbmd0aCA9IGNvbnN0cmFpbnRzLm1heExlbmd0aCAhPT0gdW5kZWZpbmVkID8gY29uc3RyYWludHMubWF4TGVuZ3RoIDogTWF4TGVuZ3RoRnJvbU1pbkxlbmd0aF8xLm1heExlbmd0aEZyb21NaW5MZW5ndGgobWluTGVuZ3RoKTtcbiAgICBjb25zdCBjb21wYXJlID0gY29uc3RyYWludHMuY29tcGFyZSAhPT0gdW5kZWZpbmVkID8gY29uc3RyYWludHMuY29tcGFyZSA6IChhLCBiKSA9PiBhID09PSBiO1xuICAgIHJldHVybiB7IG1pbkxlbmd0aCwgbWF4TGVuZ3RoLCBjb21wYXJlIH07XG59XG5mdW5jdGlvbiBleHRyYWN0U2V0Q29uc3RyYWludHMoYXJncykge1xuICAgIGlmIChhcmdzWzBdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIHt9O1xuICAgIH1cbiAgICBpZiAoYXJnc1sxXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNvbnN0IHNhcmdzID0gYXJncztcbiAgICAgICAgaWYgKHR5cGVvZiBzYXJnc1swXSA9PT0gJ251bWJlcicpXG4gICAgICAgICAgICByZXR1cm4geyBtYXhMZW5ndGg6IHNhcmdzWzBdIH07XG4gICAgICAgIGlmICh0eXBlb2Ygc2FyZ3NbMF0gPT09ICdmdW5jdGlvbicpXG4gICAgICAgICAgICByZXR1cm4geyBjb21wYXJlOiBzYXJnc1swXSB9O1xuICAgICAgICByZXR1cm4gc2FyZ3NbMF07XG4gICAgfVxuICAgIGlmIChhcmdzWzJdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY29uc3Qgc2FyZ3MgPSBhcmdzO1xuICAgICAgICBpZiAodHlwZW9mIHNhcmdzWzFdID09PSAnbnVtYmVyJylcbiAgICAgICAgICAgIHJldHVybiB7IG1pbkxlbmd0aDogc2FyZ3NbMF0sIG1heExlbmd0aDogc2FyZ3NbMV0gfTtcbiAgICAgICAgcmV0dXJuIHsgbWF4TGVuZ3RoOiBzYXJnc1swXSwgY29tcGFyZTogc2FyZ3NbMV0gfTtcbiAgICB9XG4gICAgY29uc3Qgc2FyZ3MgPSBhcmdzO1xuICAgIHJldHVybiB7IG1pbkxlbmd0aDogc2FyZ3NbMF0sIG1heExlbmd0aDogc2FyZ3NbMV0sIGNvbXBhcmU6IHNhcmdzWzJdIH07XG59XG5mdW5jdGlvbiBzZXQoYXJiLCAuLi5hcmdzKSB7XG4gICAgY29uc3QgY29uc3RyYWludHMgPSBidWlsZENvbXBsZXRlU2V0Q29uc3RyYWludHMoZXh0cmFjdFNldENvbnN0cmFpbnRzKGFyZ3MpKTtcbiAgICBjb25zdCBtaW5MZW5ndGggPSBjb25zdHJhaW50cy5taW5MZW5ndGg7XG4gICAgY29uc3QgbWF4TGVuZ3RoID0gY29uc3RyYWludHMubWF4TGVuZ3RoO1xuICAgIGNvbnN0IGNvbXBhcmUgPSBjb25zdHJhaW50cy5jb21wYXJlO1xuICAgIGNvbnN0IG5leHRBcmIgPSBDb252ZXJ0ZXJzXzEuY29udmVydFRvTmV4dChhcmIpO1xuICAgIGNvbnN0IGFycmF5QXJiID0gQ29udmVydGVyc18xLmNvbnZlcnRGcm9tTmV4dChuZXcgQXJyYXlBcmJpdHJhcnlfMS5BcnJheUFyYml0cmFyeShuZXh0QXJiLCBtaW5MZW5ndGgsIG1heExlbmd0aCwgY29tcGFyZSkpO1xuICAgIGlmIChtaW5MZW5ndGggPT09IDApXG4gICAgICAgIHJldHVybiBhcnJheUFyYjtcbiAgICByZXR1cm4gYXJyYXlBcmIuZmlsdGVyKCh0YWIpID0+IHRhYi5sZW5ndGggPj0gbWluTGVuZ3RoKTtcbn1cbmV4cG9ydHMuc2V0ID0gc2V0O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnN0cmluZyA9IHZvaWQgMDtcbmNvbnN0IENvbnZlcnRlcnNfMSA9IHJlcXVpcmUoXCIuLi9jaGVjay9hcmJpdHJhcnkvZGVmaW5pdGlvbi9Db252ZXJ0ZXJzXCIpO1xuY29uc3QgYXJyYXlfMSA9IHJlcXVpcmUoXCIuL2FycmF5XCIpO1xuY29uc3QgY2hhcl8xID0gcmVxdWlyZShcIi4vY2hhclwiKTtcbmNvbnN0IFN0cmluZ0NvbnN0cmFpbnRzRXh0cmFjdG9yXzEgPSByZXF1aXJlKFwiLi9faW50ZXJuYWxzL2hlbHBlcnMvU3RyaW5nQ29uc3RyYWludHNFeHRyYWN0b3JcIik7XG5jb25zdCBDb2RlUG9pbnRzVG9TdHJpbmdfMSA9IHJlcXVpcmUoXCIuL19pbnRlcm5hbHMvbWFwcGVycy9Db2RlUG9pbnRzVG9TdHJpbmdcIik7XG5mdW5jdGlvbiBzdHJpbmcoLi4uYXJncykge1xuICAgIGNvbnN0IGNvbnN0cmFpbnRzID0gU3RyaW5nQ29uc3RyYWludHNFeHRyYWN0b3JfMS5leHRyYWN0U3RyaW5nQ29uc3RyYWludHMoYXJncyk7XG4gICAgcmV0dXJuIENvbnZlcnRlcnNfMS5jb252ZXJ0RnJvbU5leHQoQ29udmVydGVyc18xLmNvbnZlcnRUb05leHQoYXJyYXlfMS5hcnJheShjaGFyXzEuY2hhcigpLCBjb25zdHJhaW50cykpLm1hcChDb2RlUG9pbnRzVG9TdHJpbmdfMS5jb2RlUG9pbnRzVG9TdHJpbmdNYXBwZXIsIENvZGVQb2ludHNUb1N0cmluZ18xLmNvZGVQb2ludHNUb1N0cmluZ1VubWFwcGVyKSk7XG59XG5leHBvcnRzLnN0cmluZyA9IHN0cmluZztcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5zdHJpbmcxNmJpdHMgPSB2b2lkIDA7XG5jb25zdCBDb252ZXJ0ZXJzXzEgPSByZXF1aXJlKFwiLi4vY2hlY2svYXJiaXRyYXJ5L2RlZmluaXRpb24vQ29udmVydGVyc1wiKTtcbmNvbnN0IGFycmF5XzEgPSByZXF1aXJlKFwiLi9hcnJheVwiKTtcbmNvbnN0IGNoYXIxNmJpdHNfMSA9IHJlcXVpcmUoXCIuL2NoYXIxNmJpdHNcIik7XG5jb25zdCBTdHJpbmdDb25zdHJhaW50c0V4dHJhY3Rvcl8xID0gcmVxdWlyZShcIi4vX2ludGVybmFscy9oZWxwZXJzL1N0cmluZ0NvbnN0cmFpbnRzRXh0cmFjdG9yXCIpO1xuY29uc3QgQ2hhcnNUb1N0cmluZ18xID0gcmVxdWlyZShcIi4vX2ludGVybmFscy9tYXBwZXJzL0NoYXJzVG9TdHJpbmdcIik7XG5mdW5jdGlvbiBzdHJpbmcxNmJpdHMoLi4uYXJncykge1xuICAgIGNvbnN0IGNvbnN0cmFpbnRzID0gU3RyaW5nQ29uc3RyYWludHNFeHRyYWN0b3JfMS5leHRyYWN0U3RyaW5nQ29uc3RyYWludHMoYXJncyk7XG4gICAgcmV0dXJuIENvbnZlcnRlcnNfMS5jb252ZXJ0RnJvbU5leHQoQ29udmVydGVyc18xLmNvbnZlcnRUb05leHQoYXJyYXlfMS5hcnJheShjaGFyMTZiaXRzXzEuY2hhcjE2Yml0cygpLCBjb25zdHJhaW50cykpLm1hcChDaGFyc1RvU3RyaW5nXzEuY2hhcnNUb1N0cmluZ01hcHBlciwgQ2hhcnNUb1N0cmluZ18xLmNoYXJzVG9TdHJpbmdVbm1hcHBlcikpO1xufVxuZXhwb3J0cy5zdHJpbmcxNmJpdHMgPSBzdHJpbmcxNmJpdHM7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuc3RyaW5nT2YgPSB2b2lkIDA7XG5jb25zdCBDb252ZXJ0ZXJzXzEgPSByZXF1aXJlKFwiLi4vY2hlY2svYXJiaXRyYXJ5L2RlZmluaXRpb24vQ29udmVydGVyc1wiKTtcbmNvbnN0IGFycmF5XzEgPSByZXF1aXJlKFwiLi9hcnJheVwiKTtcbmNvbnN0IFN0cmluZ0NvbnN0cmFpbnRzRXh0cmFjdG9yXzEgPSByZXF1aXJlKFwiLi9faW50ZXJuYWxzL2hlbHBlcnMvU3RyaW5nQ29uc3RyYWludHNFeHRyYWN0b3JcIik7XG5jb25zdCBQYXR0ZXJuc1RvU3RyaW5nXzEgPSByZXF1aXJlKFwiLi9faW50ZXJuYWxzL21hcHBlcnMvUGF0dGVybnNUb1N0cmluZ1wiKTtcbmZ1bmN0aW9uIHN0cmluZ09mKGNoYXJBcmIsIC4uLmFyZ3MpIHtcbiAgICBjb25zdCBjb25zdHJhaW50cyA9IFN0cmluZ0NvbnN0cmFpbnRzRXh0cmFjdG9yXzEuZXh0cmFjdFN0cmluZ0NvbnN0cmFpbnRzKGFyZ3MpO1xuICAgIHJldHVybiBDb252ZXJ0ZXJzXzEuY29udmVydEZyb21OZXh0KENvbnZlcnRlcnNfMS5jb252ZXJ0VG9OZXh0KGFycmF5XzEuYXJyYXkoY2hhckFyYiwgY29uc3RyYWludHMpKS5tYXAoUGF0dGVybnNUb1N0cmluZ18xLnBhdHRlcm5zVG9TdHJpbmdNYXBwZXIsIFBhdHRlcm5zVG9TdHJpbmdfMS5wYXR0ZXJuc1RvU3RyaW5nVW5tYXBwZXJGb3IoQ29udmVydGVyc18xLmNvbnZlcnRUb05leHQoY2hhckFyYiksIGNvbnN0cmFpbnRzKSkpO1xufVxuZXhwb3J0cy5zdHJpbmdPZiA9IHN0cmluZ09mO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnR1cGxlID0gdm9pZCAwO1xuY29uc3QgQ29udmVydGVyc18xID0gcmVxdWlyZShcIi4uL2NoZWNrL2FyYml0cmFyeS9kZWZpbml0aW9uL0NvbnZlcnRlcnNcIik7XG5jb25zdCBUdXBsZUFyYml0cmFyeV8xID0gcmVxdWlyZShcIi4vX2ludGVybmFscy9UdXBsZUFyYml0cmFyeVwiKTtcbmZ1bmN0aW9uIHR1cGxlKC4uLmFyYnMpIHtcbiAgICBjb25zdCBuZXh0QXJicyA9IGFyYnMubWFwKChhcmIpID0+IENvbnZlcnRlcnNfMS5jb252ZXJ0VG9OZXh0KGFyYikpO1xuICAgIHJldHVybiBDb252ZXJ0ZXJzXzEuY29udmVydEZyb21OZXh0KG5ldyBUdXBsZUFyYml0cmFyeV8xLlR1cGxlQXJiaXRyYXJ5KG5leHRBcmJzKSk7XG59XG5leHBvcnRzLnR1cGxlID0gdHVwbGU7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMudWludDE2QXJyYXkgPSB2b2lkIDA7XG5jb25zdCBpbnRlZ2VyXzEgPSByZXF1aXJlKFwiLi9pbnRlZ2VyXCIpO1xuY29uc3QgVHlwZWRJbnRBcnJheUFyYml0cmFyeUJ1aWxkZXJfMSA9IHJlcXVpcmUoXCIuL19pbnRlcm5hbHMvYnVpbGRlcnMvVHlwZWRJbnRBcnJheUFyYml0cmFyeUJ1aWxkZXJcIik7XG5mdW5jdGlvbiB1aW50MTZBcnJheShjb25zdHJhaW50cyA9IHt9KSB7XG4gICAgcmV0dXJuIFR5cGVkSW50QXJyYXlBcmJpdHJhcnlCdWlsZGVyXzEudHlwZWRJbnRBcnJheUFyYml0cmFyeUFyYml0cmFyeUJ1aWxkZXIoY29uc3RyYWludHMsIDAsIDY1NTM1LCBVaW50MTZBcnJheSwgaW50ZWdlcl8xLmludGVnZXIpO1xufVxuZXhwb3J0cy51aW50MTZBcnJheSA9IHVpbnQxNkFycmF5O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnVpbnQzMkFycmF5ID0gdm9pZCAwO1xuY29uc3QgaW50ZWdlcl8xID0gcmVxdWlyZShcIi4vaW50ZWdlclwiKTtcbmNvbnN0IFR5cGVkSW50QXJyYXlBcmJpdHJhcnlCdWlsZGVyXzEgPSByZXF1aXJlKFwiLi9faW50ZXJuYWxzL2J1aWxkZXJzL1R5cGVkSW50QXJyYXlBcmJpdHJhcnlCdWlsZGVyXCIpO1xuZnVuY3Rpb24gdWludDMyQXJyYXkoY29uc3RyYWludHMgPSB7fSkge1xuICAgIHJldHVybiBUeXBlZEludEFycmF5QXJiaXRyYXJ5QnVpbGRlcl8xLnR5cGVkSW50QXJyYXlBcmJpdHJhcnlBcmJpdHJhcnlCdWlsZGVyKGNvbnN0cmFpbnRzLCAwLCAweGZmZmZmZmZmLCBVaW50MzJBcnJheSwgaW50ZWdlcl8xLmludGVnZXIpO1xufVxuZXhwb3J0cy51aW50MzJBcnJheSA9IHVpbnQzMkFycmF5O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnVpbnQ4QXJyYXkgPSB2b2lkIDA7XG5jb25zdCBpbnRlZ2VyXzEgPSByZXF1aXJlKFwiLi9pbnRlZ2VyXCIpO1xuY29uc3QgVHlwZWRJbnRBcnJheUFyYml0cmFyeUJ1aWxkZXJfMSA9IHJlcXVpcmUoXCIuL19pbnRlcm5hbHMvYnVpbGRlcnMvVHlwZWRJbnRBcnJheUFyYml0cmFyeUJ1aWxkZXJcIik7XG5mdW5jdGlvbiB1aW50OEFycmF5KGNvbnN0cmFpbnRzID0ge30pIHtcbiAgICByZXR1cm4gVHlwZWRJbnRBcnJheUFyYml0cmFyeUJ1aWxkZXJfMS50eXBlZEludEFycmF5QXJiaXRyYXJ5QXJiaXRyYXJ5QnVpbGRlcihjb25zdHJhaW50cywgMCwgMjU1LCBVaW50OEFycmF5LCBpbnRlZ2VyXzEuaW50ZWdlcik7XG59XG5leHBvcnRzLnVpbnQ4QXJyYXkgPSB1aW50OEFycmF5O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnVpbnQ4Q2xhbXBlZEFycmF5ID0gdm9pZCAwO1xuY29uc3QgaW50ZWdlcl8xID0gcmVxdWlyZShcIi4vaW50ZWdlclwiKTtcbmNvbnN0IFR5cGVkSW50QXJyYXlBcmJpdHJhcnlCdWlsZGVyXzEgPSByZXF1aXJlKFwiLi9faW50ZXJuYWxzL2J1aWxkZXJzL1R5cGVkSW50QXJyYXlBcmJpdHJhcnlCdWlsZGVyXCIpO1xuZnVuY3Rpb24gdWludDhDbGFtcGVkQXJyYXkoY29uc3RyYWludHMgPSB7fSkge1xuICAgIHJldHVybiBUeXBlZEludEFycmF5QXJiaXRyYXJ5QnVpbGRlcl8xLnR5cGVkSW50QXJyYXlBcmJpdHJhcnlBcmJpdHJhcnlCdWlsZGVyKGNvbnN0cmFpbnRzLCAwLCAyNTUsIFVpbnQ4Q2xhbXBlZEFycmF5LCBpbnRlZ2VyXzEuaW50ZWdlcik7XG59XG5leHBvcnRzLnVpbnQ4Q2xhbXBlZEFycmF5ID0gdWludDhDbGFtcGVkQXJyYXk7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMudW5pY29kZSA9IHZvaWQgMDtcbmNvbnN0IENoYXJhY3RlckFyYml0cmFyeUJ1aWxkZXJfMSA9IHJlcXVpcmUoXCIuL19pbnRlcm5hbHMvYnVpbGRlcnMvQ2hhcmFjdGVyQXJiaXRyYXJ5QnVpbGRlclwiKTtcbmNvbnN0IEluZGV4VG9QcmludGFibGVJbmRleF8xID0gcmVxdWlyZShcIi4vX2ludGVybmFscy9tYXBwZXJzL0luZGV4VG9QcmludGFibGVJbmRleFwiKTtcbmNvbnN0IGdhcFNpemUgPSAweGRmZmYgKyAxIC0gMHhkODAwO1xuZnVuY3Rpb24gdW5pY29kZU1hcHBlcih2KSB7XG4gICAgaWYgKHYgPCAweGQ4MDApXG4gICAgICAgIHJldHVybiBJbmRleFRvUHJpbnRhYmxlSW5kZXhfMS5pbmRleFRvUHJpbnRhYmxlSW5kZXhNYXBwZXIodik7XG4gICAgcmV0dXJuIHYgKyBnYXBTaXplO1xufVxuZnVuY3Rpb24gdW5pY29kZVVubWFwcGVyKHYpIHtcbiAgICBpZiAodiA8IDB4ZDgwMClcbiAgICAgICAgcmV0dXJuIEluZGV4VG9QcmludGFibGVJbmRleF8xLmluZGV4VG9QcmludGFibGVJbmRleFVubWFwcGVyKHYpO1xuICAgIGlmICh2IDw9IDB4ZGZmZilcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgIHJldHVybiB2IC0gZ2FwU2l6ZTtcbn1cbmZ1bmN0aW9uIHVuaWNvZGUoKSB7XG4gICAgcmV0dXJuIENoYXJhY3RlckFyYml0cmFyeUJ1aWxkZXJfMS5idWlsZENoYXJhY3RlckFyYml0cmFyeSgweDAwMDAsIDB4ZmZmZiAtIGdhcFNpemUsIHVuaWNvZGVNYXBwZXIsIHVuaWNvZGVVbm1hcHBlcik7XG59XG5leHBvcnRzLnVuaWNvZGUgPSB1bmljb2RlO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnVuaWNvZGVTdHJpbmcgPSB2b2lkIDA7XG5jb25zdCBDb252ZXJ0ZXJzXzEgPSByZXF1aXJlKFwiLi4vY2hlY2svYXJiaXRyYXJ5L2RlZmluaXRpb24vQ29udmVydGVyc1wiKTtcbmNvbnN0IGFycmF5XzEgPSByZXF1aXJlKFwiLi9hcnJheVwiKTtcbmNvbnN0IHVuaWNvZGVfMSA9IHJlcXVpcmUoXCIuL3VuaWNvZGVcIik7XG5jb25zdCBTdHJpbmdDb25zdHJhaW50c0V4dHJhY3Rvcl8xID0gcmVxdWlyZShcIi4vX2ludGVybmFscy9oZWxwZXJzL1N0cmluZ0NvbnN0cmFpbnRzRXh0cmFjdG9yXCIpO1xuY29uc3QgQ29kZVBvaW50c1RvU3RyaW5nXzEgPSByZXF1aXJlKFwiLi9faW50ZXJuYWxzL21hcHBlcnMvQ29kZVBvaW50c1RvU3RyaW5nXCIpO1xuZnVuY3Rpb24gdW5pY29kZVN0cmluZyguLi5hcmdzKSB7XG4gICAgY29uc3QgY29uc3RyYWludHMgPSBTdHJpbmdDb25zdHJhaW50c0V4dHJhY3Rvcl8xLmV4dHJhY3RTdHJpbmdDb25zdHJhaW50cyhhcmdzKTtcbiAgICByZXR1cm4gQ29udmVydGVyc18xLmNvbnZlcnRGcm9tTmV4dChDb252ZXJ0ZXJzXzEuY29udmVydFRvTmV4dChhcnJheV8xLmFycmF5KHVuaWNvZGVfMS51bmljb2RlKCksIGNvbnN0cmFpbnRzKSkubWFwKENvZGVQb2ludHNUb1N0cmluZ18xLmNvZGVQb2ludHNUb1N0cmluZ01hcHBlciwgQ29kZVBvaW50c1RvU3RyaW5nXzEuY29kZVBvaW50c1RvU3RyaW5nVW5tYXBwZXIpKTtcbn1cbmV4cG9ydHMudW5pY29kZVN0cmluZyA9IHVuaWNvZGVTdHJpbmc7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZG91YmxlTmV4dCA9IGV4cG9ydHMuaW5kZXhUb0RvdWJsZSA9IGV4cG9ydHMuZG91YmxlVG9JbmRleCA9IGV4cG9ydHMuZGVjb21wb3NlRG91YmxlID0gdm9pZCAwO1xuY29uc3QgQXJyYXlJbnQ2NF8xID0gcmVxdWlyZShcIi4vaGVscGVycy9BcnJheUludDY0XCIpO1xuY29uc3QgQXJyYXlJbnQ2NEFyYml0cmFyeV8xID0gcmVxdWlyZShcIi4vaGVscGVycy9BcnJheUludDY0QXJiaXRyYXJ5XCIpO1xuY29uc3QgSU5ERVhfUE9TSVRJVkVfSU5GSU5JVFkgPSB7IHNpZ246IDEsIGRhdGE6IFsyMTQ2NDM1MDcyLCAwXSB9O1xuY29uc3QgSU5ERVhfTkVHQVRJVkVfSU5GSU5JVFkgPSB7IHNpZ246IC0xLCBkYXRhOiBbMjE0NjQzNTA3MiwgMV0gfTtcbmZ1bmN0aW9uIGRlY29tcG9zZURvdWJsZShkKSB7XG4gICAgY29uc3QgbWF4U2lnbmlmaWNhbmQgPSAyIC0gTnVtYmVyLkVQU0lMT047XG4gICAgZm9yIChsZXQgZXhwb25lbnQgPSAtMTAyMjsgZXhwb25lbnQgIT09IDEwMjQ7ICsrZXhwb25lbnQpIHtcbiAgICAgICAgY29uc3QgcG93RXhwb25lbnQgPSAyICoqIGV4cG9uZW50O1xuICAgICAgICBjb25zdCBtYXhGb3JFeHBvbmVudCA9IG1heFNpZ25pZmljYW5kICogcG93RXhwb25lbnQ7XG4gICAgICAgIGlmIChNYXRoLmFicyhkKSA8PSBtYXhGb3JFeHBvbmVudCkge1xuICAgICAgICAgICAgcmV0dXJuIHsgZXhwb25lbnQsIHNpZ25pZmljYW5kOiBkIC8gcG93RXhwb25lbnQgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4geyBleHBvbmVudDogTnVtYmVyLk5hTiwgc2lnbmlmaWNhbmQ6IE51bWJlci5OYU4gfTtcbn1cbmV4cG9ydHMuZGVjb21wb3NlRG91YmxlID0gZGVjb21wb3NlRG91YmxlO1xuZnVuY3Rpb24gcG9zaXRpdmVOdW1iZXJUb0ludDY0KG4pIHtcbiAgICByZXR1cm4gW35+KG4gLyAweDEwMDAwMDAwMCksIG4gPj4+IDBdO1xufVxuZnVuY3Rpb24gaW5kZXhJbkRvdWJsZUZyb21EZWNvbXAoZXhwb25lbnQsIHNpZ25pZmljYW5kKSB7XG4gICAgaWYgKGV4cG9uZW50ID09PSAtMTAyMikge1xuICAgICAgICBjb25zdCByZXNjYWxlZFNpZ25pZmljYW5kID0gc2lnbmlmaWNhbmQgKiAyICoqIDUyO1xuICAgICAgICByZXR1cm4gcG9zaXRpdmVOdW1iZXJUb0ludDY0KHJlc2NhbGVkU2lnbmlmaWNhbmQpO1xuICAgIH1cbiAgICBjb25zdCByZXNjYWxlZFNpZ25pZmljYW5kID0gKHNpZ25pZmljYW5kIC0gMSkgKiAyICoqIDUyO1xuICAgIGNvbnN0IGV4cG9uZW50T25seUhpZ2ggPSAoZXhwb25lbnQgKyAxMDIzKSAqIDIgKiogMjA7XG4gICAgY29uc3QgaW5kZXggPSBwb3NpdGl2ZU51bWJlclRvSW50NjQocmVzY2FsZWRTaWduaWZpY2FuZCk7XG4gICAgaW5kZXhbMF0gKz0gZXhwb25lbnRPbmx5SGlnaDtcbiAgICByZXR1cm4gaW5kZXg7XG59XG5mdW5jdGlvbiBkb3VibGVUb0luZGV4KGQpIHtcbiAgICBpZiAoZCA9PT0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZKSB7XG4gICAgICAgIHJldHVybiBBcnJheUludDY0XzEuY2xvbmU2NChJTkRFWF9QT1NJVElWRV9JTkZJTklUWSk7XG4gICAgfVxuICAgIGlmIChkID09PSBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFkpIHtcbiAgICAgICAgcmV0dXJuIEFycmF5SW50NjRfMS5jbG9uZTY0KElOREVYX05FR0FUSVZFX0lORklOSVRZKTtcbiAgICB9XG4gICAgY29uc3QgZGVjb21wID0gZGVjb21wb3NlRG91YmxlKGQpO1xuICAgIGNvbnN0IGV4cG9uZW50ID0gZGVjb21wLmV4cG9uZW50O1xuICAgIGNvbnN0IHNpZ25pZmljYW5kID0gZGVjb21wLnNpZ25pZmljYW5kO1xuICAgIGlmIChkID4gMCB8fCAoZCA9PT0gMCAmJiAxIC8gZCA9PT0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZKSkge1xuICAgICAgICByZXR1cm4geyBzaWduOiAxLCBkYXRhOiBpbmRleEluRG91YmxlRnJvbURlY29tcChleHBvbmVudCwgc2lnbmlmaWNhbmQpIH07XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjb25zdCBpbmRleE9wcG9zaXRlID0gaW5kZXhJbkRvdWJsZUZyb21EZWNvbXAoZXhwb25lbnQsIC1zaWduaWZpY2FuZCk7XG4gICAgICAgIGlmIChpbmRleE9wcG9zaXRlWzFdID09PSAweGZmZmZmZmZmKSB7XG4gICAgICAgICAgICBpbmRleE9wcG9zaXRlWzBdICs9IDE7XG4gICAgICAgICAgICBpbmRleE9wcG9zaXRlWzFdID0gMDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGluZGV4T3Bwb3NpdGVbMV0gKz0gMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBzaWduOiAtMSwgZGF0YTogaW5kZXhPcHBvc2l0ZSB9O1xuICAgIH1cbn1cbmV4cG9ydHMuZG91YmxlVG9JbmRleCA9IGRvdWJsZVRvSW5kZXg7XG5mdW5jdGlvbiBpbmRleFRvRG91YmxlKGluZGV4KSB7XG4gICAgaWYgKGluZGV4LnNpZ24gPT09IC0xKSB7XG4gICAgICAgIGNvbnN0IGluZGV4T3Bwb3NpdGUgPSB7IHNpZ246IDEsIGRhdGE6IFtpbmRleC5kYXRhWzBdLCBpbmRleC5kYXRhWzFdXSB9O1xuICAgICAgICBpZiAoaW5kZXhPcHBvc2l0ZS5kYXRhWzFdID09PSAwKSB7XG4gICAgICAgICAgICBpbmRleE9wcG9zaXRlLmRhdGFbMF0gLT0gMTtcbiAgICAgICAgICAgIGluZGV4T3Bwb3NpdGUuZGF0YVsxXSA9IDB4ZmZmZmZmZmY7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpbmRleE9wcG9zaXRlLmRhdGFbMV0gLT0gMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gLWluZGV4VG9Eb3VibGUoaW5kZXhPcHBvc2l0ZSk7XG4gICAgfVxuICAgIGlmIChBcnJheUludDY0XzEuaXNFcXVhbDY0KGluZGV4LCBJTkRFWF9QT1NJVElWRV9JTkZJTklUWSkpIHtcbiAgICAgICAgcmV0dXJuIE51bWJlci5QT1NJVElWRV9JTkZJTklUWTtcbiAgICB9XG4gICAgaWYgKGluZGV4LmRhdGFbMF0gPCAweDIwMDAwMCkge1xuICAgICAgICByZXR1cm4gKGluZGV4LmRhdGFbMF0gKiAweDEwMDAwMDAwMCArIGluZGV4LmRhdGFbMV0pICogMiAqKiAtMTA3NDtcbiAgICB9XG4gICAgY29uc3QgcG9zdEluZGV4SGlnaCA9IGluZGV4LmRhdGFbMF0gLSAweDIwMDAwMDtcbiAgICBjb25zdCBleHBvbmVudCA9IC0xMDIxICsgKHBvc3RJbmRleEhpZ2ggPj4gMjApO1xuICAgIGNvbnN0IHNpZ25pZmljYW5kID0gMSArICgocG9zdEluZGV4SGlnaCAmIDB4ZmZmZmYpICogMiAqKiAzMiArIGluZGV4LmRhdGFbMV0pICogTnVtYmVyLkVQU0lMT047XG4gICAgcmV0dXJuIHNpZ25pZmljYW5kICogMiAqKiBleHBvbmVudDtcbn1cbmV4cG9ydHMuaW5kZXhUb0RvdWJsZSA9IGluZGV4VG9Eb3VibGU7XG5mdW5jdGlvbiBzYWZlRG91YmxlVG9JbmRleChkLCBjb25zdHJhaW50c0xhYmVsKSB7XG4gICAgaWYgKE51bWJlci5pc05hTihkKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ZjLmRvdWJsZU5leHQgY29uc3RyYWludHMuJyArIGNvbnN0cmFpbnRzTGFiZWwgKyAnIG11c3QgYmUgYSAzMi1iaXQgZmxvYXQnKTtcbiAgICB9XG4gICAgcmV0dXJuIGRvdWJsZVRvSW5kZXgoZCk7XG59XG5mdW5jdGlvbiBkb3VibGVOZXh0KGNvbnN0cmFpbnRzID0ge30pIHtcbiAgICBjb25zdCB7IG5vRGVmYXVsdEluZmluaXR5ID0gZmFsc2UsIG5vTmFOID0gZmFsc2UsIG1pbiA9IG5vRGVmYXVsdEluZmluaXR5ID8gLU51bWJlci5NQVhfVkFMVUUgOiBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFksIG1heCA9IG5vRGVmYXVsdEluZmluaXR5ID8gTnVtYmVyLk1BWF9WQUxVRSA6IE51bWJlci5QT1NJVElWRV9JTkZJTklUWSwgfSA9IGNvbnN0cmFpbnRzO1xuICAgIGNvbnN0IG1pbkluZGV4ID0gc2FmZURvdWJsZVRvSW5kZXgobWluLCAnbWluJyk7XG4gICAgY29uc3QgbWF4SW5kZXggPSBzYWZlRG91YmxlVG9JbmRleChtYXgsICdtYXgnKTtcbiAgICBpZiAoQXJyYXlJbnQ2NF8xLmlzU3RyaWN0bHlTbWFsbGVyNjQobWF4SW5kZXgsIG1pbkluZGV4KSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ZjLmRvdWJsZU5leHQgY29uc3RyYWludHMubWluIG11c3QgYmUgc21hbGxlciBvciBlcXVhbCB0byBjb25zdHJhaW50cy5tYXgnKTtcbiAgICB9XG4gICAgaWYgKG5vTmFOKSB7XG4gICAgICAgIHJldHVybiBBcnJheUludDY0QXJiaXRyYXJ5XzEuYXJyYXlJbnQ2NChtaW5JbmRleCwgbWF4SW5kZXgpLm1hcChpbmRleFRvRG91YmxlKTtcbiAgICB9XG4gICAgY29uc3QgcG9zaXRpdmVNYXhJZHggPSBBcnJheUludDY0XzEuaXNTdHJpY3RseVBvc2l0aXZlNjQobWF4SW5kZXgpO1xuICAgIGNvbnN0IG1pbkluZGV4V2l0aE5hTiA9IHBvc2l0aXZlTWF4SWR4ID8gbWluSW5kZXggOiBBcnJheUludDY0XzEuc3Vic3RyYWN0NjQobWluSW5kZXgsIEFycmF5SW50NjRfMS5Vbml0NjQpO1xuICAgIGNvbnN0IG1heEluZGV4V2l0aE5hTiA9IHBvc2l0aXZlTWF4SWR4ID8gQXJyYXlJbnQ2NF8xLmFkZDY0KG1heEluZGV4LCBBcnJheUludDY0XzEuVW5pdDY0KSA6IG1heEluZGV4O1xuICAgIHJldHVybiBBcnJheUludDY0QXJiaXRyYXJ5XzEuYXJyYXlJbnQ2NChtaW5JbmRleFdpdGhOYU4sIG1heEluZGV4V2l0aE5hTikubWFwKChpbmRleCkgPT4ge1xuICAgICAgICBpZiAoQXJyYXlJbnQ2NF8xLmlzU3RyaWN0bHlTbWFsbGVyNjQobWF4SW5kZXgsIGluZGV4KSB8fCBBcnJheUludDY0XzEuaXNTdHJpY3RseVNtYWxsZXI2NChpbmRleCwgbWluSW5kZXgpKVxuICAgICAgICAgICAgcmV0dXJuIE51bWJlci5OYU47XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHJldHVybiBpbmRleFRvRG91YmxlKGluZGV4KTtcbiAgICB9KTtcbn1cbmV4cG9ydHMuZG91YmxlTmV4dCA9IGRvdWJsZU5leHQ7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZW1haWxBZGRyZXNzID0gdm9pZCAwO1xuY29uc3QgYXJyYXlfMSA9IHJlcXVpcmUoXCIuLi8uLi9hcmJpdHJhcnkvYXJyYXlcIik7XG5jb25zdCBTcGVjaWZpY0NoYXJhY3RlclJhbmdlXzEgPSByZXF1aXJlKFwiLi9oZWxwZXJzL1NwZWNpZmljQ2hhcmFjdGVyUmFuZ2VcIik7XG5jb25zdCBIb3N0QXJiaXRyYXJ5XzEgPSByZXF1aXJlKFwiLi9Ib3N0QXJiaXRyYXJ5XCIpO1xuY29uc3Qgc3RyaW5nT2ZfMSA9IHJlcXVpcmUoXCIuLi8uLi9hcmJpdHJhcnkvc3RyaW5nT2ZcIik7XG5jb25zdCB0dXBsZV8xID0gcmVxdWlyZShcIi4uLy4uL2FyYml0cmFyeS90dXBsZVwiKTtcbmZ1bmN0aW9uIGVtYWlsQWRkcmVzcygpIHtcbiAgICBjb25zdCBvdGhlcnMgPSBbJyEnLCAnIycsICckJywgJyUnLCAnJicsIFwiJ1wiLCAnKicsICcrJywgJy0nLCAnLycsICc9JywgJz8nLCAnXicsICdfJywgJ2AnLCAneycsICd8JywgJ30nLCAnfiddO1xuICAgIGNvbnN0IGF0ZXh0QXJiID0gU3BlY2lmaWNDaGFyYWN0ZXJSYW5nZV8xLmJ1aWxkTG93ZXJBbHBoYU51bWVyaWNBcmIob3RoZXJzKTtcbiAgICBjb25zdCBsb2NhbFBhcnRBcmIgPSBhcnJheV8xLmFycmF5KHN0cmluZ09mXzEuc3RyaW5nT2YoYXRleHRBcmIsIHsgbWluTGVuZ3RoOiAxLCBtYXhMZW5ndGg6IDEwIH0pLCB7IG1pbkxlbmd0aDogMSwgbWF4TGVuZ3RoOiA1IH0pXG4gICAgICAgIC5tYXAoKGEpID0+IGEuam9pbignLicpKVxuICAgICAgICAuZmlsdGVyKChscCkgPT4gbHAubGVuZ3RoIDw9IDY0KTtcbiAgICByZXR1cm4gdHVwbGVfMS50dXBsZShsb2NhbFBhcnRBcmIsIEhvc3RBcmJpdHJhcnlfMS5kb21haW4oKSkubWFwKChbbHAsIGRdKSA9PiBgJHtscH1AJHtkfWApO1xufVxuZXhwb3J0cy5lbWFpbEFkZHJlc3MgPSBlbWFpbEFkZHJlc3M7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZmxvYXROZXh0ID0gZXhwb3J0cy5pbmRleFRvRmxvYXQgPSBleHBvcnRzLmZsb2F0VG9JbmRleCA9IGV4cG9ydHMuZGVjb21wb3NlRmxvYXQgPSBleHBvcnRzLkVQU0lMT05fMzIgPSBleHBvcnRzLk1BWF9WQUxVRV8zMiA9IGV4cG9ydHMuTUlOX1ZBTFVFXzMyID0gdm9pZCAwO1xuY29uc3QgaW50ZWdlcl8xID0gcmVxdWlyZShcIi4uLy4uL2FyYml0cmFyeS9pbnRlZ2VyXCIpO1xuZXhwb3J0cy5NSU5fVkFMVUVfMzIgPSAyICoqIC0xMjYgKiAyICoqIC0yMztcbmV4cG9ydHMuTUFYX1ZBTFVFXzMyID0gMiAqKiAxMjcgKiAoMSArICgyICoqIDIzIC0gMSkgLyAyICoqIDIzKTtcbmV4cG9ydHMuRVBTSUxPTl8zMiA9IDIgKiogLTIzO1xuY29uc3QgSU5ERVhfUE9TSVRJVkVfSU5GSU5JVFkgPSAyMTM5MDk1MDQwO1xuY29uc3QgSU5ERVhfTkVHQVRJVkVfSU5GSU5JVFkgPSAtMjEzOTA5NTA0MTtcbmZ1bmN0aW9uIGRlY29tcG9zZUZsb2F0KGYpIHtcbiAgICBjb25zdCBtYXhTaWduaWZpY2FuZCA9IDEgKyAoMiAqKiAyMyAtIDEpIC8gMiAqKiAyMztcbiAgICBmb3IgKGxldCBleHBvbmVudCA9IC0xMjY7IGV4cG9uZW50ICE9PSAxMjg7ICsrZXhwb25lbnQpIHtcbiAgICAgICAgY29uc3QgcG93RXhwb25lbnQgPSAyICoqIGV4cG9uZW50O1xuICAgICAgICBjb25zdCBtYXhGb3JFeHBvbmVudCA9IG1heFNpZ25pZmljYW5kICogcG93RXhwb25lbnQ7XG4gICAgICAgIGlmIChNYXRoLmFicyhmKSA8PSBtYXhGb3JFeHBvbmVudCkge1xuICAgICAgICAgICAgcmV0dXJuIHsgZXhwb25lbnQsIHNpZ25pZmljYW5kOiBmIC8gcG93RXhwb25lbnQgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4geyBleHBvbmVudDogTnVtYmVyLk5hTiwgc2lnbmlmaWNhbmQ6IE51bWJlci5OYU4gfTtcbn1cbmV4cG9ydHMuZGVjb21wb3NlRmxvYXQgPSBkZWNvbXBvc2VGbG9hdDtcbmZ1bmN0aW9uIGluZGV4SW5GbG9hdEZyb21EZWNvbXAoZXhwb25lbnQsIHNpZ25pZmljYW5kKSB7XG4gICAgaWYgKGV4cG9uZW50ID09PSAtMTI2KSB7XG4gICAgICAgIHJldHVybiBzaWduaWZpY2FuZCAqIDB4ODAwMDAwO1xuICAgIH1cbiAgICByZXR1cm4gKGV4cG9uZW50ICsgMTI3KSAqIDB4ODAwMDAwICsgKHNpZ25pZmljYW5kIC0gMSkgKiAweDgwMDAwMDtcbn1cbmZ1bmN0aW9uIGZsb2F0VG9JbmRleChmKSB7XG4gICAgaWYgKGYgPT09IE51bWJlci5QT1NJVElWRV9JTkZJTklUWSkge1xuICAgICAgICByZXR1cm4gSU5ERVhfUE9TSVRJVkVfSU5GSU5JVFk7XG4gICAgfVxuICAgIGlmIChmID09PSBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFkpIHtcbiAgICAgICAgcmV0dXJuIElOREVYX05FR0FUSVZFX0lORklOSVRZO1xuICAgIH1cbiAgICBjb25zdCBkZWNvbXAgPSBkZWNvbXBvc2VGbG9hdChmKTtcbiAgICBjb25zdCBleHBvbmVudCA9IGRlY29tcC5leHBvbmVudDtcbiAgICBjb25zdCBzaWduaWZpY2FuZCA9IGRlY29tcC5zaWduaWZpY2FuZDtcbiAgICBpZiAoTnVtYmVyLmlzTmFOKGV4cG9uZW50KSB8fCBOdW1iZXIuaXNOYU4oc2lnbmlmaWNhbmQpIHx8ICFOdW1iZXIuaXNJbnRlZ2VyKHNpZ25pZmljYW5kICogMHg4MDAwMDApKSB7XG4gICAgICAgIHJldHVybiBOdW1iZXIuTmFOO1xuICAgIH1cbiAgICBpZiAoZiA+IDAgfHwgKGYgPT09IDAgJiYgMSAvIGYgPT09IE51bWJlci5QT1NJVElWRV9JTkZJTklUWSkpIHtcbiAgICAgICAgcmV0dXJuIGluZGV4SW5GbG9hdEZyb21EZWNvbXAoZXhwb25lbnQsIHNpZ25pZmljYW5kKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiAtaW5kZXhJbkZsb2F0RnJvbURlY29tcChleHBvbmVudCwgLXNpZ25pZmljYW5kKSAtIDE7XG4gICAgfVxufVxuZXhwb3J0cy5mbG9hdFRvSW5kZXggPSBmbG9hdFRvSW5kZXg7XG5mdW5jdGlvbiBpbmRleFRvRmxvYXQoaW5kZXgpIHtcbiAgICBpZiAoaW5kZXggPCAwKSB7XG4gICAgICAgIHJldHVybiAtaW5kZXhUb0Zsb2F0KC1pbmRleCAtIDEpO1xuICAgIH1cbiAgICBpZiAoaW5kZXggPT09IElOREVYX1BPU0lUSVZFX0lORklOSVRZKSB7XG4gICAgICAgIHJldHVybiBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7XG4gICAgfVxuICAgIGlmIChpbmRleCA8IDB4MTAwMDAwMCkge1xuICAgICAgICByZXR1cm4gaW5kZXggKiAyICoqIC0xNDk7XG4gICAgfVxuICAgIGNvbnN0IHBvc3RJbmRleCA9IGluZGV4IC0gMHgxMDAwMDAwO1xuICAgIGNvbnN0IGV4cG9uZW50ID0gLTEyNSArIChwb3N0SW5kZXggPj4gMjMpO1xuICAgIGNvbnN0IHNpZ25pZmljYW5kID0gMSArIChwb3N0SW5kZXggJiAweDdmZmZmZikgLyAweDgwMDAwMDtcbiAgICByZXR1cm4gc2lnbmlmaWNhbmQgKiAyICoqIGV4cG9uZW50O1xufVxuZXhwb3J0cy5pbmRleFRvRmxvYXQgPSBpbmRleFRvRmxvYXQ7XG5mdW5jdGlvbiBzYWZlRmxvYXRUb0luZGV4KGYsIGNvbnN0cmFpbnRzTGFiZWwpIHtcbiAgICBjb25zdCBjb252ZXJzaW9uVHJpY2sgPSAneW91IGNhbiBjb252ZXJ0IGFueSBkb3VibGUgdG8gYSAzMi1iaXQgZmxvYXQgYnkgdXNpbmcgYG5ldyBGbG9hdDMyQXJyYXkoW215RG91YmxlXSlbMF1gJztcbiAgICBjb25zdCBlcnJvck1lc3NhZ2UgPSAnZmMuZmxvYXROZXh0IGNvbnN0cmFpbnRzLicgKyBjb25zdHJhaW50c0xhYmVsICsgJyBtdXN0IGJlIGEgMzItYml0IGZsb2F0IC0gJyArIGNvbnZlcnNpb25UcmljaztcbiAgICBpZiAoTnVtYmVyLmlzTmFOKGYpIHx8IChOdW1iZXIuaXNGaW5pdGUoZikgJiYgKGYgPCAtZXhwb3J0cy5NQVhfVkFMVUVfMzIgfHwgZiA+IGV4cG9ydHMuTUFYX1ZBTFVFXzMyKSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yTWVzc2FnZSk7XG4gICAgfVxuICAgIGNvbnN0IGluZGV4ID0gZmxvYXRUb0luZGV4KGYpO1xuICAgIGlmICghTnVtYmVyLmlzSW50ZWdlcihpbmRleCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yTWVzc2FnZSk7XG4gICAgfVxuICAgIHJldHVybiBpbmRleDtcbn1cbmZ1bmN0aW9uIGZsb2F0TmV4dChjb25zdHJhaW50cyA9IHt9KSB7XG4gICAgY29uc3QgeyBub0RlZmF1bHRJbmZpbml0eSA9IGZhbHNlLCBub05hTiA9IGZhbHNlLCBtaW4gPSBub0RlZmF1bHRJbmZpbml0eSA/IC1leHBvcnRzLk1BWF9WQUxVRV8zMiA6IE51bWJlci5ORUdBVElWRV9JTkZJTklUWSwgbWF4ID0gbm9EZWZhdWx0SW5maW5pdHkgPyBleHBvcnRzLk1BWF9WQUxVRV8zMiA6IE51bWJlci5QT1NJVElWRV9JTkZJTklUWSwgfSA9IGNvbnN0cmFpbnRzO1xuICAgIGNvbnN0IG1pbkluZGV4ID0gc2FmZUZsb2F0VG9JbmRleChtaW4sICdtaW4nKTtcbiAgICBjb25zdCBtYXhJbmRleCA9IHNhZmVGbG9hdFRvSW5kZXgobWF4LCAnbWF4Jyk7XG4gICAgaWYgKG1pbkluZGV4ID4gbWF4SW5kZXgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdmYy5mbG9hdE5leHQgY29uc3RyYWludHMubWluIG11c3QgYmUgc21hbGxlciBvciBlcXVhbCB0byBjb25zdHJhaW50cy5tYXgnKTtcbiAgICB9XG4gICAgaWYgKG5vTmFOKSB7XG4gICAgICAgIHJldHVybiBpbnRlZ2VyXzEuaW50ZWdlcih7IG1pbjogbWluSW5kZXgsIG1heDogbWF4SW5kZXggfSkubWFwKGluZGV4VG9GbG9hdCk7XG4gICAgfVxuICAgIGNvbnN0IG1pbkluZGV4V2l0aE5hTiA9IG1heEluZGV4ID4gMCA/IG1pbkluZGV4IDogbWluSW5kZXggLSAxO1xuICAgIGNvbnN0IG1heEluZGV4V2l0aE5hTiA9IG1heEluZGV4ID4gMCA/IG1heEluZGV4ICsgMSA6IG1heEluZGV4O1xuICAgIHJldHVybiBpbnRlZ2VyXzEuaW50ZWdlcih7IG1pbjogbWluSW5kZXhXaXRoTmFOLCBtYXg6IG1heEluZGV4V2l0aE5hTiB9KS5tYXAoKGluZGV4KSA9PiB7XG4gICAgICAgIGlmIChpbmRleCA+IG1heEluZGV4IHx8IGluZGV4IDwgbWluSW5kZXgpXG4gICAgICAgICAgICByZXR1cm4gTnVtYmVyLk5hTjtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgcmV0dXJuIGluZGV4VG9GbG9hdChpbmRleCk7XG4gICAgfSk7XG59XG5leHBvcnRzLmZsb2F0TmV4dCA9IGZsb2F0TmV4dDtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5kb3VibGUgPSBleHBvcnRzLmZsb2F0ID0gdm9pZCAwO1xuY29uc3QgRG91YmxlTmV4dEFyYml0cmFyeV8xID0gcmVxdWlyZShcIi4vRG91YmxlTmV4dEFyYml0cmFyeVwiKTtcbmNvbnN0IEZsb2F0TmV4dEFyYml0cmFyeV8xID0gcmVxdWlyZShcIi4vRmxvYXROZXh0QXJiaXRyYXJ5XCIpO1xuY29uc3QgaW50ZWdlcl8xID0gcmVxdWlyZShcIi4uLy4uL2FyYml0cmFyeS9pbnRlZ2VyXCIpO1xuY29uc3QgdHVwbGVfMSA9IHJlcXVpcmUoXCIuLi8uLi9hcmJpdHJhcnkvdHVwbGVcIik7XG5mdW5jdGlvbiBuZXh0KG4pIHtcbiAgICByZXR1cm4gaW50ZWdlcl8xLmludGVnZXIoMCwgKDEgPDwgbikgLSAxKTtcbn1cbmNvbnN0IGZsb2F0SW50ZXJuYWwgPSAoKSA9PiB7XG4gICAgcmV0dXJuIG5leHQoMjQpLm1hcCgodikgPT4gdiAvICgxIDw8IDI0KSk7XG59O1xuZnVuY3Rpb24gZmxvYXQoLi4uYXJncykge1xuICAgIGlmICh0eXBlb2YgYXJnc1swXSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgaWYgKGFyZ3NbMF0ubmV4dCkge1xuICAgICAgICAgICAgcmV0dXJuIEZsb2F0TmV4dEFyYml0cmFyeV8xLmZsb2F0TmV4dChhcmdzWzBdKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtaW4gPSBhcmdzWzBdLm1pbiAhPT0gdW5kZWZpbmVkID8gYXJnc1swXS5taW4gOiAwO1xuICAgICAgICBjb25zdCBtYXggPSBhcmdzWzBdLm1heCAhPT0gdW5kZWZpbmVkID8gYXJnc1swXS5tYXggOiAxO1xuICAgICAgICByZXR1cm4gKGZsb2F0SW50ZXJuYWwoKVxuICAgICAgICAgICAgLm1hcCgodikgPT4gbWluICsgdiAqIChtYXggLSBtaW4pKVxuICAgICAgICAgICAgLmZpbHRlcigoZykgPT4gZyAhPT0gbWF4IHx8IGcgPT09IG1pbikpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgY29uc3QgYSA9IGFyZ3NbMF07XG4gICAgICAgIGNvbnN0IGIgPSBhcmdzWzFdO1xuICAgICAgICBpZiAoYSA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgcmV0dXJuIGZsb2F0SW50ZXJuYWwoKTtcbiAgICAgICAgaWYgKGIgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHJldHVybiAoZmxvYXRJbnRlcm5hbCgpXG4gICAgICAgICAgICAgICAgLm1hcCgodikgPT4gdiAqIGEpXG4gICAgICAgICAgICAgICAgLmZpbHRlcigoZykgPT4gZyAhPT0gYSB8fCBnID09PSAwKSk7XG4gICAgICAgIHJldHVybiAoZmxvYXRJbnRlcm5hbCgpXG4gICAgICAgICAgICAubWFwKCh2KSA9PiBhICsgdiAqIChiIC0gYSkpXG4gICAgICAgICAgICAuZmlsdGVyKChnKSA9PiBnICE9PSBiIHx8IGcgPT09IGEpKTtcbiAgICB9XG59XG5leHBvcnRzLmZsb2F0ID0gZmxvYXQ7XG5jb25zdCBkb3VibGVGYWN0b3IgPSBNYXRoLnBvdygyLCAyNyk7XG5jb25zdCBkb3VibGVEaXZpc29yID0gTWF0aC5wb3coMiwgLTUzKTtcbmNvbnN0IGRvdWJsZUludGVybmFsID0gKCkgPT4ge1xuICAgIHJldHVybiB0dXBsZV8xLnR1cGxlKG5leHQoMjYpLCBuZXh0KDI3KSkubWFwKCh2KSA9PiAodlswXSAqIGRvdWJsZUZhY3RvciArIHZbMV0pICogZG91YmxlRGl2aXNvcik7XG59O1xuZnVuY3Rpb24gZG91YmxlKC4uLmFyZ3MpIHtcbiAgICBpZiAodHlwZW9mIGFyZ3NbMF0gPT09ICdvYmplY3QnKSB7XG4gICAgICAgIGlmIChhcmdzWzBdLm5leHQpIHtcbiAgICAgICAgICAgIHJldHVybiBEb3VibGVOZXh0QXJiaXRyYXJ5XzEuZG91YmxlTmV4dChhcmdzWzBdKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtaW4gPSBhcmdzWzBdLm1pbiAhPT0gdW5kZWZpbmVkID8gYXJnc1swXS5taW4gOiAwO1xuICAgICAgICBjb25zdCBtYXggPSBhcmdzWzBdLm1heCAhPT0gdW5kZWZpbmVkID8gYXJnc1swXS5tYXggOiAxO1xuICAgICAgICByZXR1cm4gKGRvdWJsZUludGVybmFsKClcbiAgICAgICAgICAgIC5tYXAoKHYpID0+IG1pbiArIHYgKiAobWF4IC0gbWluKSlcbiAgICAgICAgICAgIC5maWx0ZXIoKGcpID0+IGcgIT09IG1heCB8fCBnID09PSBtaW4pKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGNvbnN0IGEgPSBhcmdzWzBdO1xuICAgICAgICBjb25zdCBiID0gYXJnc1sxXTtcbiAgICAgICAgaWYgKGEgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHJldHVybiBkb3VibGVJbnRlcm5hbCgpO1xuICAgICAgICBpZiAoYiA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgcmV0dXJuIChkb3VibGVJbnRlcm5hbCgpXG4gICAgICAgICAgICAgICAgLm1hcCgodikgPT4gdiAqIGEpXG4gICAgICAgICAgICAgICAgLmZpbHRlcigoZykgPT4gZyAhPT0gYSB8fCBnID09PSAwKSk7XG4gICAgICAgIHJldHVybiAoZG91YmxlSW50ZXJuYWwoKVxuICAgICAgICAgICAgLm1hcCgodikgPT4gYSArIHYgKiAoYiAtIGEpKVxuICAgICAgICAgICAgLmZpbHRlcigoZykgPT4gZyAhPT0gYiB8fCBnID09PSBhKSk7XG4gICAgfVxufVxuZXhwb3J0cy5kb3VibGUgPSBkb3VibGU7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuaG9zdFVzZXJJbmZvID0gZXhwb3J0cy5kb21haW4gPSBleHBvcnRzLmZpbHRlckludmFsaWRTdWJkb21haW5MYWJlbCA9IHZvaWQgMDtcbmNvbnN0IGFycmF5XzEgPSByZXF1aXJlKFwiLi4vLi4vYXJiaXRyYXJ5L2FycmF5XCIpO1xuY29uc3QgU3BlY2lmaWNDaGFyYWN0ZXJSYW5nZV8xID0gcmVxdWlyZShcIi4vaGVscGVycy9TcGVjaWZpY0NoYXJhY3RlclJhbmdlXCIpO1xuY29uc3Qgb3B0aW9uXzEgPSByZXF1aXJlKFwiLi4vLi4vYXJiaXRyYXJ5L29wdGlvblwiKTtcbmNvbnN0IHN0cmluZ09mXzEgPSByZXF1aXJlKFwiLi4vLi4vYXJiaXRyYXJ5L3N0cmluZ09mXCIpO1xuY29uc3QgdHVwbGVfMSA9IHJlcXVpcmUoXCIuLi8uLi9hcmJpdHJhcnkvdHVwbGVcIik7XG5mdW5jdGlvbiBmaWx0ZXJJbnZhbGlkU3ViZG9tYWluTGFiZWwoc3ViZG9tYWluTGFiZWwpIHtcbiAgICBpZiAoc3ViZG9tYWluTGFiZWwubGVuZ3RoID4gNjMpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gKHN1YmRvbWFpbkxhYmVsLmxlbmd0aCA8IDQgfHxcbiAgICAgICAgc3ViZG9tYWluTGFiZWxbMF0gIT09ICd4JyB8fFxuICAgICAgICBzdWJkb21haW5MYWJlbFsxXSAhPT0gJ24nIHx8XG4gICAgICAgIHN1YmRvbWFpbkxhYmVsWzJdICE9PSAnLScgfHxcbiAgICAgICAgc3ViZG9tYWluTGFiZWxbM10gIT09ICctJyk7XG59XG5leHBvcnRzLmZpbHRlckludmFsaWRTdWJkb21haW5MYWJlbCA9IGZpbHRlckludmFsaWRTdWJkb21haW5MYWJlbDtcbmZ1bmN0aW9uIHN1YmRvbWFpbkxhYmVsKCkge1xuICAgIGNvbnN0IGFscGhhTnVtZXJpY0FyYiA9IFNwZWNpZmljQ2hhcmFjdGVyUmFuZ2VfMS5idWlsZExvd2VyQWxwaGFOdW1lcmljQXJiKFtdKTtcbiAgICBjb25zdCBhbHBoYU51bWVyaWNIeXBoZW5BcmIgPSBTcGVjaWZpY0NoYXJhY3RlclJhbmdlXzEuYnVpbGRMb3dlckFscGhhTnVtZXJpY0FyYihbJy0nXSk7XG4gICAgcmV0dXJuIHR1cGxlXzEudHVwbGUoYWxwaGFOdW1lcmljQXJiLCBvcHRpb25fMS5vcHRpb24odHVwbGVfMS50dXBsZShzdHJpbmdPZl8xLnN0cmluZ09mKGFscGhhTnVtZXJpY0h5cGhlbkFyYiwgeyBtYXhMZW5ndGg6IDYxIH0pLCBhbHBoYU51bWVyaWNBcmIpKSlcbiAgICAgICAgLm1hcCgoW2YsIGRdKSA9PiAoZCA9PT0gbnVsbCA/IGYgOiBgJHtmfSR7ZFswXX0ke2RbMV19YCkpXG4gICAgICAgIC5maWx0ZXIoZmlsdGVySW52YWxpZFN1YmRvbWFpbkxhYmVsKTtcbn1cbmZ1bmN0aW9uIGRvbWFpbigpIHtcbiAgICBjb25zdCBhbHBoYU51bWVyaWNBcmIgPSBTcGVjaWZpY0NoYXJhY3RlclJhbmdlXzEuYnVpbGRMb3dlckFscGhhQXJiKFtdKTtcbiAgICBjb25zdCBwdWJsaWNTdWZmaXhBcmIgPSBzdHJpbmdPZl8xLnN0cmluZ09mKGFscGhhTnVtZXJpY0FyYiwgeyBtaW5MZW5ndGg6IDIsIG1heExlbmd0aDogMTAgfSk7XG4gICAgcmV0dXJuICh0dXBsZV8xLnR1cGxlKGFycmF5XzEuYXJyYXkoc3ViZG9tYWluTGFiZWwoKSwgeyBtaW5MZW5ndGg6IDEsIG1heExlbmd0aDogNSB9KSwgcHVibGljU3VmZml4QXJiKVxuICAgICAgICAubWFwKChbbWlkLCBleHRdKSA9PiBgJHttaWQuam9pbignLicpfS4ke2V4dH1gKVxuICAgICAgICAuZmlsdGVyKChkKSA9PiBkLmxlbmd0aCA8PSAyNTUpKTtcbn1cbmV4cG9ydHMuZG9tYWluID0gZG9tYWluO1xuZnVuY3Rpb24gaG9zdFVzZXJJbmZvKCkge1xuICAgIGNvbnN0IG90aGVycyA9IFsnLScsICcuJywgJ18nLCAnficsICchJywgJyQnLCAnJicsIFwiJ1wiLCAnKCcsICcpJywgJyonLCAnKycsICcsJywgJzsnLCAnPScsICc6J107XG4gICAgcmV0dXJuIHN0cmluZ09mXzEuc3RyaW5nT2YoU3BlY2lmaWNDaGFyYWN0ZXJSYW5nZV8xLmJ1aWxkQWxwaGFOdW1lcmljUGVyY2VudEFyYihvdGhlcnMpKTtcbn1cbmV4cG9ydHMuaG9zdFVzZXJJbmZvID0gaG9zdFVzZXJJbmZvO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnVuaWNvZGVKc29uID0gZXhwb3J0cy5qc29uID0gZXhwb3J0cy51bmljb2RlSnNvbk9iamVjdCA9IGV4cG9ydHMuanNvbk9iamVjdCA9IGV4cG9ydHMub2JqZWN0ID0gZXhwb3J0cy5hbnl0aGluZyA9IGV4cG9ydHMuYm94QXJiaXRyYXJ5ID0gdm9pZCAwO1xuY29uc3Qgc3RyaW5naWZ5XzEgPSByZXF1aXJlKFwiLi4vLi4vdXRpbHMvc3RyaW5naWZ5XCIpO1xuY29uc3QgYXJyYXlfMSA9IHJlcXVpcmUoXCIuLi8uLi9hcmJpdHJhcnkvYXJyYXlcIik7XG5jb25zdCBib29sZWFuXzEgPSByZXF1aXJlKFwiLi4vLi4vYXJiaXRyYXJ5L2Jvb2xlYW5cIik7XG5jb25zdCBjb25zdGFudF8xID0gcmVxdWlyZShcIi4uLy4uL2FyYml0cmFyeS9jb25zdGFudFwiKTtcbmNvbnN0IGRpY3Rpb25hcnlfMSA9IHJlcXVpcmUoXCIuLi8uLi9hcmJpdHJhcnkvZGljdGlvbmFyeVwiKTtcbmNvbnN0IEZsb2F0aW5nUG9pbnRBcmJpdHJhcnlfMSA9IHJlcXVpcmUoXCIuL0Zsb2F0aW5nUG9pbnRBcmJpdHJhcnlcIik7XG5jb25zdCBmcmVxdWVuY3lfMSA9IHJlcXVpcmUoXCIuLi8uLi9hcmJpdHJhcnkvZnJlcXVlbmN5XCIpO1xuY29uc3QgbWF4U2FmZUludGVnZXJfMSA9IHJlcXVpcmUoXCIuLi8uLi9hcmJpdHJhcnkvbWF4U2FmZUludGVnZXJcIik7XG5jb25zdCBtZW1vXzEgPSByZXF1aXJlKFwiLi4vLi4vYXJiaXRyYXJ5L21lbW9cIik7XG5jb25zdCBvbmVvZl8xID0gcmVxdWlyZShcIi4uLy4uL2FyYml0cmFyeS9vbmVvZlwiKTtcbmNvbnN0IHNldF8xID0gcmVxdWlyZShcIi4uLy4uL2FyYml0cmFyeS9zZXRcIik7XG5jb25zdCBzdHJpbmdfMSA9IHJlcXVpcmUoXCIuLi8uLi9hcmJpdHJhcnkvc3RyaW5nXCIpO1xuY29uc3QgdW5pY29kZVN0cmluZ18xID0gcmVxdWlyZShcIi4uLy4uL2FyYml0cmFyeS91bmljb2RlU3RyaW5nXCIpO1xuY29uc3QgdHVwbGVfMSA9IHJlcXVpcmUoXCIuLi8uLi9hcmJpdHJhcnkvdHVwbGVcIik7XG5jb25zdCBiaWdJbnRfMSA9IHJlcXVpcmUoXCIuLi8uLi9hcmJpdHJhcnkvYmlnSW50XCIpO1xuY29uc3QgZGF0ZV8xID0gcmVxdWlyZShcIi4uLy4uL2FyYml0cmFyeS9kYXRlXCIpO1xuY29uc3QgZmxvYXQzMkFycmF5XzEgPSByZXF1aXJlKFwiLi4vLi4vYXJiaXRyYXJ5L2Zsb2F0MzJBcnJheVwiKTtcbmNvbnN0IGZsb2F0NjRBcnJheV8xID0gcmVxdWlyZShcIi4uLy4uL2FyYml0cmFyeS9mbG9hdDY0QXJyYXlcIik7XG5jb25zdCBpbnQxNkFycmF5XzEgPSByZXF1aXJlKFwiLi4vLi4vYXJiaXRyYXJ5L2ludDE2QXJyYXlcIik7XG5jb25zdCBpbnQzMkFycmF5XzEgPSByZXF1aXJlKFwiLi4vLi4vYXJiaXRyYXJ5L2ludDMyQXJyYXlcIik7XG5jb25zdCBpbnQ4QXJyYXlfMSA9IHJlcXVpcmUoXCIuLi8uLi9hcmJpdHJhcnkvaW50OEFycmF5XCIpO1xuY29uc3QgdWludDE2QXJyYXlfMSA9IHJlcXVpcmUoXCIuLi8uLi9hcmJpdHJhcnkvdWludDE2QXJyYXlcIik7XG5jb25zdCB1aW50MzJBcnJheV8xID0gcmVxdWlyZShcIi4uLy4uL2FyYml0cmFyeS91aW50MzJBcnJheVwiKTtcbmNvbnN0IHVpbnQ4QXJyYXlfMSA9IHJlcXVpcmUoXCIuLi8uLi9hcmJpdHJhcnkvdWludDhBcnJheVwiKTtcbmNvbnN0IHVpbnQ4Q2xhbXBlZEFycmF5XzEgPSByZXF1aXJlKFwiLi4vLi4vYXJiaXRyYXJ5L3VpbnQ4Q2xhbXBlZEFycmF5XCIpO1xuY29uc3QgU3BhcnNlQXJyYXlBcmJpdHJhcnlfMSA9IHJlcXVpcmUoXCIuL1NwYXJzZUFycmF5QXJiaXRyYXJ5XCIpO1xuY29uc3QgS2V5VmFsdWVQYWlyc1RvT2JqZWN0XzEgPSByZXF1aXJlKFwiLi4vLi4vYXJiaXRyYXJ5L19pbnRlcm5hbHMvbWFwcGVycy9LZXlWYWx1ZVBhaXJzVG9PYmplY3RcIik7XG5mdW5jdGlvbiBib3hBcmJpdHJhcnkoYXJiKSB7XG4gICAgcmV0dXJuIGFyYi5tYXAoKHYpID0+IHtcbiAgICAgICAgc3dpdGNoICh0eXBlb2Ygdikge1xuICAgICAgICAgICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBCb29sZWFuKHYpO1xuICAgICAgICAgICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IE51bWJlcih2KTtcbiAgICAgICAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBTdHJpbmcodik7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJldHVybiB2O1xuICAgICAgICB9XG4gICAgfSk7XG59XG5leHBvcnRzLmJveEFyYml0cmFyeSA9IGJveEFyYml0cmFyeTtcbmNsYXNzIFF1YWxpZmllZE9iamVjdENvbnN0cmFpbnRzIHtcbiAgICBjb25zdHJ1Y3RvcihrZXksIHZhbHVlcywgbWF4RGVwdGgsIG1heEtleXMsIHdpdGhTZXQsIHdpdGhNYXAsIHdpdGhPYmplY3RTdHJpbmcsIHdpdGhOdWxsUHJvdG90eXBlLCB3aXRoQmlnSW50LCB3aXRoRGF0ZSwgd2l0aFR5cGVkQXJyYXksIHdpdGhTcGFyc2VBcnJheSkge1xuICAgICAgICB0aGlzLmtleSA9IGtleTtcbiAgICAgICAgdGhpcy52YWx1ZXMgPSB2YWx1ZXM7XG4gICAgICAgIHRoaXMubWF4RGVwdGggPSBtYXhEZXB0aDtcbiAgICAgICAgdGhpcy5tYXhLZXlzID0gbWF4S2V5cztcbiAgICAgICAgdGhpcy53aXRoU2V0ID0gd2l0aFNldDtcbiAgICAgICAgdGhpcy53aXRoTWFwID0gd2l0aE1hcDtcbiAgICAgICAgdGhpcy53aXRoT2JqZWN0U3RyaW5nID0gd2l0aE9iamVjdFN0cmluZztcbiAgICAgICAgdGhpcy53aXRoTnVsbFByb3RvdHlwZSA9IHdpdGhOdWxsUHJvdG90eXBlO1xuICAgICAgICB0aGlzLndpdGhCaWdJbnQgPSB3aXRoQmlnSW50O1xuICAgICAgICB0aGlzLndpdGhEYXRlID0gd2l0aERhdGU7XG4gICAgICAgIHRoaXMud2l0aFR5cGVkQXJyYXkgPSB3aXRoVHlwZWRBcnJheTtcbiAgICAgICAgdGhpcy53aXRoU3BhcnNlQXJyYXkgPSB3aXRoU3BhcnNlQXJyYXk7XG4gICAgfVxuICAgIHN0YXRpYyBkZWZhdWx0VmFsdWVzKCkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgYm9vbGVhbl8xLmJvb2xlYW4oKSxcbiAgICAgICAgICAgIG1heFNhZmVJbnRlZ2VyXzEubWF4U2FmZUludGVnZXIoKSxcbiAgICAgICAgICAgIEZsb2F0aW5nUG9pbnRBcmJpdHJhcnlfMS5kb3VibGUoeyBuZXh0OiB0cnVlIH0pLFxuICAgICAgICAgICAgc3RyaW5nXzEuc3RyaW5nKCksXG4gICAgICAgICAgICBvbmVvZl8xLm9uZW9mKHN0cmluZ18xLnN0cmluZygpLCBjb25zdGFudF8xLmNvbnN0YW50KG51bGwpLCBjb25zdGFudF8xLmNvbnN0YW50KHVuZGVmaW5lZCkpLFxuICAgICAgICBdO1xuICAgIH1cbiAgICBzdGF0aWMgYm94QXJiaXRyYXJpZXMoYXJicykge1xuICAgICAgICByZXR1cm4gYXJicy5tYXAoKGFyYikgPT4gYm94QXJiaXRyYXJ5KGFyYikpO1xuICAgIH1cbiAgICBzdGF0aWMgYm94QXJiaXRyYXJpZXNJZk5lZWRlZChhcmJzLCBib3hFbmFibGVkKSB7XG4gICAgICAgIHJldHVybiBib3hFbmFibGVkID8gUXVhbGlmaWVkT2JqZWN0Q29uc3RyYWludHMuYm94QXJiaXRyYXJpZXMoYXJicykuY29uY2F0KGFyYnMpIDogYXJicztcbiAgICB9XG4gICAgc3RhdGljIGZyb20oc2V0dGluZ3MgPSB7fSkge1xuICAgICAgICBmdW5jdGlvbiBvckRlZmF1bHQob3B0aW9uYWxWYWx1ZSwgZGVmYXVsdFZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gb3B0aW9uYWxWYWx1ZSAhPT0gdW5kZWZpbmVkID8gb3B0aW9uYWxWYWx1ZSA6IGRlZmF1bHRWYWx1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFF1YWxpZmllZE9iamVjdENvbnN0cmFpbnRzKG9yRGVmYXVsdChzZXR0aW5ncy5rZXksIHN0cmluZ18xLnN0cmluZygpKSwgUXVhbGlmaWVkT2JqZWN0Q29uc3RyYWludHMuYm94QXJiaXRyYXJpZXNJZk5lZWRlZChvckRlZmF1bHQoc2V0dGluZ3MudmFsdWVzLCBRdWFsaWZpZWRPYmplY3RDb25zdHJhaW50cy5kZWZhdWx0VmFsdWVzKCkpLCBvckRlZmF1bHQoc2V0dGluZ3Mud2l0aEJveGVkVmFsdWVzLCBmYWxzZSkpLCBvckRlZmF1bHQoc2V0dGluZ3MubWF4RGVwdGgsIDIpLCBvckRlZmF1bHQoc2V0dGluZ3MubWF4S2V5cywgNSksIG9yRGVmYXVsdChzZXR0aW5ncy53aXRoU2V0LCBmYWxzZSksIG9yRGVmYXVsdChzZXR0aW5ncy53aXRoTWFwLCBmYWxzZSksIG9yRGVmYXVsdChzZXR0aW5ncy53aXRoT2JqZWN0U3RyaW5nLCBmYWxzZSksIG9yRGVmYXVsdChzZXR0aW5ncy53aXRoTnVsbFByb3RvdHlwZSwgZmFsc2UpLCBvckRlZmF1bHQoc2V0dGluZ3Mud2l0aEJpZ0ludCwgZmFsc2UpLCBvckRlZmF1bHQoc2V0dGluZ3Mud2l0aERhdGUsIGZhbHNlKSwgb3JEZWZhdWx0KHNldHRpbmdzLndpdGhUeXBlZEFycmF5LCBmYWxzZSksIG9yRGVmYXVsdChzZXR0aW5ncy53aXRoU3BhcnNlQXJyYXksIGZhbHNlKSk7XG4gICAgfVxufVxuY29uc3QgYW55dGhpbmdJbnRlcm5hbCA9IChjb25zdHJhaW50cykgPT4ge1xuICAgIGNvbnN0IGFyYktleXMgPSBjb25zdHJhaW50cy53aXRoT2JqZWN0U3RyaW5nXG4gICAgICAgID8gbWVtb18xLm1lbW8oKG4pID0+IGZyZXF1ZW5jeV8xLmZyZXF1ZW5jeSh7IGFyYml0cmFyeTogY29uc3RyYWludHMua2V5LCB3ZWlnaHQ6IDEwIH0sIHsgYXJiaXRyYXJ5OiBhbnl0aGluZ0FyYihuKS5tYXAoKG8pID0+IHN0cmluZ2lmeV8xLnN0cmluZ2lmeShvKSksIHdlaWdodDogMSB9KSlcbiAgICAgICAgOiBtZW1vXzEubWVtbygoKSA9PiBjb25zdHJhaW50cy5rZXkpO1xuICAgIGNvbnN0IGFyYml0cmFyaWVzRm9yQmFzZSA9IGNvbnN0cmFpbnRzLnZhbHVlcztcbiAgICBjb25zdCBtYXhEZXB0aCA9IGNvbnN0cmFpbnRzLm1heERlcHRoO1xuICAgIGNvbnN0IG1heEtleXMgPSBjb25zdHJhaW50cy5tYXhLZXlzO1xuICAgIGNvbnN0IGVudHJpZXNPZiA9IChrZXlBcmIsIHZhbHVlQXJiKSA9PiBzZXRfMS5zZXQodHVwbGVfMS50dXBsZShrZXlBcmIsIHZhbHVlQXJiKSwgeyBtYXhMZW5ndGg6IG1heEtleXMsIGNvbXBhcmU6ICh0MSwgdDIpID0+IHQxWzBdID09PSB0MlswXSB9KTtcbiAgICBjb25zdCBtYXBPZiA9IChrYSwgdmEpID0+IGVudHJpZXNPZihrYSwgdmEpLm1hcCgodikgPT4gbmV3IE1hcCh2KSk7XG4gICAgY29uc3QgZGljdE9mID0gKGthLCB2YSkgPT4gZW50cmllc09mKGthLCB2YSkubWFwKCh2KSA9PiBLZXlWYWx1ZVBhaXJzVG9PYmplY3RfMS5rZXlWYWx1ZVBhaXJzVG9PYmplY3RNYXBwZXIodikpO1xuICAgIGNvbnN0IGJhc2VBcmIgPSBvbmVvZl8xLm9uZW9mKC4uLmFyYml0cmFyaWVzRm9yQmFzZSk7XG4gICAgY29uc3QgYXJyYXlCYXNlQXJiID0gb25lb2ZfMS5vbmVvZiguLi5hcmJpdHJhcmllc0ZvckJhc2UubWFwKChhcmIpID0+IGFycmF5XzEuYXJyYXkoYXJiLCB7IG1heExlbmd0aDogbWF4S2V5cyB9KSkpO1xuICAgIGNvbnN0IG9iamVjdEJhc2VBcmIgPSAobikgPT4gb25lb2ZfMS5vbmVvZiguLi5hcmJpdHJhcmllc0ZvckJhc2UubWFwKChhcmIpID0+IGRpY3RPZihhcmJLZXlzKG4pLCBhcmIpKSk7XG4gICAgY29uc3Qgc2V0QmFzZUFyYiA9ICgpID0+IG9uZW9mXzEub25lb2YoLi4uYXJiaXRyYXJpZXNGb3JCYXNlLm1hcCgoYXJiKSA9PiBzZXRfMS5zZXQoYXJiLCB7IG1heExlbmd0aDogbWF4S2V5cyB9KS5tYXAoKHYpID0+IG5ldyBTZXQodikpKSk7XG4gICAgY29uc3QgbWFwQmFzZUFyYiA9IChuKSA9PiBvbmVvZl8xLm9uZW9mKC4uLmFyYml0cmFyaWVzRm9yQmFzZS5tYXAoKGFyYikgPT4gbWFwT2YoYXJiS2V5cyhuKSwgYXJiKSkpO1xuICAgIGNvbnN0IGFycmF5QXJiID0gbWVtb18xLm1lbW8oKG4pID0+IG9uZW9mXzEub25lb2YoYXJyYXlCYXNlQXJiLCBhcnJheV8xLmFycmF5KGFueXRoaW5nQXJiKG4pLCB7IG1heExlbmd0aDogbWF4S2V5cyB9KSkpO1xuICAgIGNvbnN0IHNldEFyYiA9IG1lbW9fMS5tZW1vKChuKSA9PiBvbmVvZl8xLm9uZW9mKHNldEJhc2VBcmIoKSwgc2V0XzEuc2V0KGFueXRoaW5nQXJiKG4pLCB7IG1heExlbmd0aDogbWF4S2V5cyB9KS5tYXAoKHYpID0+IG5ldyBTZXQodikpKSk7XG4gICAgY29uc3QgbWFwQXJiID0gbWVtb18xLm1lbW8oKG4pID0+IG9uZW9mXzEub25lb2YobWFwQmFzZUFyYihuKSwgb25lb2ZfMS5vbmVvZihtYXBPZihhcmJLZXlzKG4pLCBhbnl0aGluZ0FyYihuKSksIG1hcE9mKGFueXRoaW5nQXJiKG4pLCBhbnl0aGluZ0FyYihuKSkpKSk7XG4gICAgY29uc3Qgb2JqZWN0QXJiID0gbWVtb18xLm1lbW8oKG4pID0+IG9uZW9mXzEub25lb2Yob2JqZWN0QmFzZUFyYihuKSwgZGljdE9mKGFyYktleXMobiksIGFueXRoaW5nQXJiKG4pKSkpO1xuICAgIGNvbnN0IGFueXRoaW5nQXJiID0gbWVtb18xLm1lbW8oKG4pID0+IHtcbiAgICAgICAgaWYgKG4gPD0gMClcbiAgICAgICAgICAgIHJldHVybiBvbmVvZl8xLm9uZW9mKGJhc2VBcmIpO1xuICAgICAgICByZXR1cm4gb25lb2ZfMS5vbmVvZihiYXNlQXJiLCBhcnJheUFyYigpLCBvYmplY3RBcmIoKSwgLi4uKGNvbnN0cmFpbnRzLndpdGhNYXAgPyBbbWFwQXJiKCldIDogW10pLCAuLi4oY29uc3RyYWludHMud2l0aFNldCA/IFtzZXRBcmIoKV0gOiBbXSksIC4uLihjb25zdHJhaW50cy53aXRoT2JqZWN0U3RyaW5nID8gW2FueXRoaW5nQXJiKCkubWFwKChvKSA9PiBzdHJpbmdpZnlfMS5zdHJpbmdpZnkobykpXSA6IFtdKSwgLi4uKGNvbnN0cmFpbnRzLndpdGhOdWxsUHJvdG90eXBlID8gW29iamVjdEFyYigpLm1hcCgobykgPT4gT2JqZWN0LmFzc2lnbihPYmplY3QuY3JlYXRlKG51bGwpLCBvKSldIDogW10pLCAuLi4oY29uc3RyYWludHMud2l0aEJpZ0ludCA/IFtiaWdJbnRfMS5iaWdJbnQoKV0gOiBbXSksIC4uLihjb25zdHJhaW50cy53aXRoRGF0ZSA/IFtkYXRlXzEuZGF0ZSgpXSA6IFtdKSwgLi4uKGNvbnN0cmFpbnRzLndpdGhUeXBlZEFycmF5XG4gICAgICAgICAgICA/IFtcbiAgICAgICAgICAgICAgICBvbmVvZl8xLm9uZW9mKGludDhBcnJheV8xLmludDhBcnJheSgpLCB1aW50OEFycmF5XzEudWludDhBcnJheSgpLCB1aW50OENsYW1wZWRBcnJheV8xLnVpbnQ4Q2xhbXBlZEFycmF5KCksIGludDE2QXJyYXlfMS5pbnQxNkFycmF5KCksIHVpbnQxNkFycmF5XzEudWludDE2QXJyYXkoKSwgaW50MzJBcnJheV8xLmludDMyQXJyYXkoKSwgdWludDMyQXJyYXlfMS51aW50MzJBcnJheSgpLCBmbG9hdDMyQXJyYXlfMS5mbG9hdDMyQXJyYXkoKSwgZmxvYXQ2NEFycmF5XzEuZmxvYXQ2NEFycmF5KCkpLFxuICAgICAgICAgICAgXVxuICAgICAgICAgICAgOiBbXSksIC4uLihjb25zdHJhaW50cy53aXRoU3BhcnNlQXJyYXkgPyBbU3BhcnNlQXJyYXlBcmJpdHJhcnlfMS5zcGFyc2VBcnJheShhbnl0aGluZ0FyYigpKV0gOiBbXSkpO1xuICAgIH0pO1xuICAgIHJldHVybiBhbnl0aGluZ0FyYihtYXhEZXB0aCk7XG59O1xuY29uc3Qgb2JqZWN0SW50ZXJuYWwgPSAoY29uc3RyYWludHMpID0+IHtcbiAgICByZXR1cm4gZGljdGlvbmFyeV8xLmRpY3Rpb25hcnkoY29uc3RyYWludHMua2V5LCBhbnl0aGluZ0ludGVybmFsKGNvbnN0cmFpbnRzKSk7XG59O1xuZnVuY3Rpb24gYW55dGhpbmcoY29uc3RyYWludHMpIHtcbiAgICByZXR1cm4gYW55dGhpbmdJbnRlcm5hbChRdWFsaWZpZWRPYmplY3RDb25zdHJhaW50cy5mcm9tKGNvbnN0cmFpbnRzKSk7XG59XG5leHBvcnRzLmFueXRoaW5nID0gYW55dGhpbmc7XG5mdW5jdGlvbiBvYmplY3QoY29uc3RyYWludHMpIHtcbiAgICByZXR1cm4gb2JqZWN0SW50ZXJuYWwoUXVhbGlmaWVkT2JqZWN0Q29uc3RyYWludHMuZnJvbShjb25zdHJhaW50cykpO1xufVxuZXhwb3J0cy5vYmplY3QgPSBvYmplY3Q7XG5mdW5jdGlvbiBqc29uU2V0dGluZ3Moc3RyaW5nQXJiaXRyYXJ5LCBjb25zdHJhaW50cykge1xuICAgIGNvbnN0IGtleSA9IHN0cmluZ0FyYml0cmFyeTtcbiAgICBjb25zdCB2YWx1ZXMgPSBbXG4gICAgICAgIGJvb2xlYW5fMS5ib29sZWFuKCksXG4gICAgICAgIG1heFNhZmVJbnRlZ2VyXzEubWF4U2FmZUludGVnZXIoKSxcbiAgICAgICAgRmxvYXRpbmdQb2ludEFyYml0cmFyeV8xLmRvdWJsZSh7IG5leHQ6IHRydWUsIG5vRGVmYXVsdEluZmluaXR5OiB0cnVlLCBub05hTjogdHJ1ZSB9KSxcbiAgICAgICAgc3RyaW5nQXJiaXRyYXJ5LFxuICAgICAgICBjb25zdGFudF8xLmNvbnN0YW50KG51bGwpLFxuICAgIF07XG4gICAgcmV0dXJuIGNvbnN0cmFpbnRzICE9IG51bGxcbiAgICAgICAgPyB0eXBlb2YgY29uc3RyYWludHMgPT09ICdudW1iZXInXG4gICAgICAgICAgICA/IHsga2V5LCB2YWx1ZXMsIG1heERlcHRoOiBjb25zdHJhaW50cyB9XG4gICAgICAgICAgICA6IHsga2V5LCB2YWx1ZXMsIG1heERlcHRoOiBjb25zdHJhaW50cy5tYXhEZXB0aCB9XG4gICAgICAgIDogeyBrZXksIHZhbHVlcyB9O1xufVxuZnVuY3Rpb24ganNvbk9iamVjdChjb25zdHJhaW50cykge1xuICAgIHJldHVybiBhbnl0aGluZyhqc29uU2V0dGluZ3Moc3RyaW5nXzEuc3RyaW5nKCksIGNvbnN0cmFpbnRzKSk7XG59XG5leHBvcnRzLmpzb25PYmplY3QgPSBqc29uT2JqZWN0O1xuZnVuY3Rpb24gdW5pY29kZUpzb25PYmplY3QoY29uc3RyYWludHMpIHtcbiAgICByZXR1cm4gYW55dGhpbmcoanNvblNldHRpbmdzKHVuaWNvZGVTdHJpbmdfMS51bmljb2RlU3RyaW5nKCksIGNvbnN0cmFpbnRzKSk7XG59XG5leHBvcnRzLnVuaWNvZGVKc29uT2JqZWN0ID0gdW5pY29kZUpzb25PYmplY3Q7XG5mdW5jdGlvbiBqc29uKGNvbnN0cmFpbnRzKSB7XG4gICAgY29uc3QgYXJiID0gY29uc3RyYWludHMgIT0gbnVsbCA/IGpzb25PYmplY3QoY29uc3RyYWludHMpIDoganNvbk9iamVjdCgpO1xuICAgIHJldHVybiBhcmIubWFwKEpTT04uc3RyaW5naWZ5KTtcbn1cbmV4cG9ydHMuanNvbiA9IGpzb247XG5mdW5jdGlvbiB1bmljb2RlSnNvbihjb25zdHJhaW50cykge1xuICAgIGNvbnN0IGFyYiA9IGNvbnN0cmFpbnRzICE9IG51bGwgPyB1bmljb2RlSnNvbk9iamVjdChjb25zdHJhaW50cykgOiB1bmljb2RlSnNvbk9iamVjdCgpO1xuICAgIHJldHVybiBhcmIubWFwKEpTT04uc3RyaW5naWZ5KTtcbn1cbmV4cG9ydHMudW5pY29kZUpzb24gPSB1bmljb2RlSnNvbjtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5zcGFyc2VBcnJheSA9IHZvaWQgMDtcbmNvbnN0IG5hdF8xID0gcmVxdWlyZShcIi4uLy4uL2FyYml0cmFyeS9uYXRcIik7XG5jb25zdCBzZXRfMSA9IHJlcXVpcmUoXCIuLi8uLi9hcmJpdHJhcnkvc2V0XCIpO1xuY29uc3QgdHVwbGVfMSA9IHJlcXVpcmUoXCIuLi8uLi9hcmJpdHJhcnkvdHVwbGVcIik7XG5jb25zdCBNYXhMZW5ndGhGcm9tTWluTGVuZ3RoXzEgPSByZXF1aXJlKFwiLi4vLi4vYXJiaXRyYXJ5L19pbnRlcm5hbHMvaGVscGVycy9NYXhMZW5ndGhGcm9tTWluTGVuZ3RoXCIpO1xuZnVuY3Rpb24gZXh0cmFjdE1heEluZGV4KGluZGV4ZXNBbmRWYWx1ZXMpIHtcbiAgICBsZXQgbWF4SW5kZXggPSAtMTtcbiAgICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4ICE9PSBpbmRleGVzQW5kVmFsdWVzLmxlbmd0aDsgKytpbmRleCkge1xuICAgICAgICBtYXhJbmRleCA9IE1hdGgubWF4KG1heEluZGV4LCBpbmRleGVzQW5kVmFsdWVzW2luZGV4XVswXSk7XG4gICAgfVxuICAgIHJldHVybiBtYXhJbmRleDtcbn1cbmZ1bmN0aW9uIGFycmF5RnJvbUl0ZW1zKGxlbmd0aCwgaW5kZXhlc0FuZFZhbHVlcykge1xuICAgIGNvbnN0IGFycmF5ID0gQXJyYXkobGVuZ3RoKTtcbiAgICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4ICE9PSBpbmRleGVzQW5kVmFsdWVzLmxlbmd0aDsgKytpbmRleCkge1xuICAgICAgICBjb25zdCBpdCA9IGluZGV4ZXNBbmRWYWx1ZXNbaW5kZXhdO1xuICAgICAgICBpZiAoaXRbMF0gPCBsZW5ndGgpXG4gICAgICAgICAgICBhcnJheVtpdFswXV0gPSBpdFsxXTtcbiAgICB9XG4gICAgcmV0dXJuIGFycmF5O1xufVxuZnVuY3Rpb24gc3BhcnNlQXJyYXkoYXJiLCBjb25zdHJhaW50cyA9IHt9KSB7XG4gICAgY29uc3QgeyBtaW5OdW1FbGVtZW50cyA9IDAsIG1heE51bUVsZW1lbnRzID0gTWF4TGVuZ3RoRnJvbU1pbkxlbmd0aF8xLm1heExlbmd0aEZyb21NaW5MZW5ndGgobWluTnVtRWxlbWVudHMpLCBtYXhMZW5ndGggPSBNYXRoLm1pbihNYXhMZW5ndGhGcm9tTWluTGVuZ3RoXzEubWF4TGVuZ3RoRnJvbU1pbkxlbmd0aChtYXhOdW1FbGVtZW50cyksIDQyOTQ5NjcyOTUpLCBub1RyYWlsaW5nSG9sZSwgfSA9IGNvbnN0cmFpbnRzO1xuICAgIGlmIChtaW5OdW1FbGVtZW50cyA+IG1heExlbmd0aCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFRoZSBtaW5pbWFsIG51bWJlciBvZiBub24taG9sZSBlbGVtZW50cyBjYW5ub3QgYmUgaGlnaGVyIHRoYW4gdGhlIG1heGltYWwgbGVuZ3RoIG9mIHRoZSBhcnJheWApO1xuICAgIH1cbiAgICBpZiAobWluTnVtRWxlbWVudHMgPiBtYXhOdW1FbGVtZW50cykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFRoZSBtaW5pbWFsIG51bWJlciBvZiBub24taG9sZSBlbGVtZW50cyBjYW5ub3QgYmUgaGlnaGVyIHRoYW4gdGhlIG1heGltYWwgbnVtYmVyIG9mIG5vbi1ob2xlc2ApO1xuICAgIH1cbiAgICBjb25zdCByZXN1bHRlZE1heE51bUVsZW1lbnRzID0gTWF0aC5taW4obWF4TnVtRWxlbWVudHMsIG1heExlbmd0aCk7XG4gICAgaWYgKG5vVHJhaWxpbmdIb2xlKSB7XG4gICAgICAgIGNvbnN0IG1heEluZGV4QXV0aG9yaXplZCA9IE1hdGgubWF4KG1heExlbmd0aCAtIDEsIDApO1xuICAgICAgICByZXR1cm4gc2V0XzEuc2V0KHR1cGxlXzEudHVwbGUobmF0XzEubmF0KG1heEluZGV4QXV0aG9yaXplZCksIGFyYiksIHtcbiAgICAgICAgICAgIG1pbkxlbmd0aDogbWluTnVtRWxlbWVudHMsXG4gICAgICAgICAgICBtYXhMZW5ndGg6IHJlc3VsdGVkTWF4TnVtRWxlbWVudHMsXG4gICAgICAgICAgICBjb21wYXJlOiAoaXRlbUEsIGl0ZW1CKSA9PiBpdGVtQVswXSA9PT0gaXRlbUJbMF0sXG4gICAgICAgIH0pLm1hcCgoaXRlbXMpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGxhc3RJbmRleCA9IGV4dHJhY3RNYXhJbmRleChpdGVtcyk7XG4gICAgICAgICAgICByZXR1cm4gYXJyYXlGcm9tSXRlbXMobGFzdEluZGV4ICsgMSwgaXRlbXMpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHNldF8xLnNldCh0dXBsZV8xLnR1cGxlKG5hdF8xLm5hdChtYXhMZW5ndGgpLCBhcmIpLCB7XG4gICAgICAgIG1pbkxlbmd0aDogbWluTnVtRWxlbWVudHMgKyAxLFxuICAgICAgICBtYXhMZW5ndGg6IHJlc3VsdGVkTWF4TnVtRWxlbWVudHMgKyAxLFxuICAgICAgICBjb21wYXJlOiAoaXRlbUEsIGl0ZW1CKSA9PiBpdGVtQVswXSA9PT0gaXRlbUJbMF0sXG4gICAgfSkubWFwKChpdGVtcykgPT4ge1xuICAgICAgICBjb25zdCBsZW5ndGggPSBleHRyYWN0TWF4SW5kZXgoaXRlbXMpO1xuICAgICAgICByZXR1cm4gYXJyYXlGcm9tSXRlbXMobGVuZ3RoLCBpdGVtcyk7XG4gICAgfSk7XG59XG5leHBvcnRzLnNwYXJzZUFycmF5ID0gc3BhcnNlQXJyYXk7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuc2h1ZmZsZWRTdWJhcnJheSA9IGV4cG9ydHMuc3ViYXJyYXkgPSB2b2lkIDA7XG5jb25zdCBTdHJlYW1fMSA9IHJlcXVpcmUoXCIuLi8uLi9zdHJlYW0vU3RyZWFtXCIpO1xuY29uc3QgQXJiaXRyYXJ5XzEgPSByZXF1aXJlKFwiLi9kZWZpbml0aW9uL0FyYml0cmFyeVwiKTtcbmNvbnN0IEJpYXNlZEFyYml0cmFyeVdyYXBwZXJfMSA9IHJlcXVpcmUoXCIuL2RlZmluaXRpb24vQmlhc2VkQXJiaXRyYXJ5V3JhcHBlclwiKTtcbmNvbnN0IFNocmlua2FibGVfMSA9IHJlcXVpcmUoXCIuL2RlZmluaXRpb24vU2hyaW5rYWJsZVwiKTtcbmNvbnN0IGludGVnZXJfMSA9IHJlcXVpcmUoXCIuLi8uLi9hcmJpdHJhcnkvaW50ZWdlclwiKTtcbmNvbnN0IExhenlJdGVyYWJsZUl0ZXJhdG9yXzEgPSByZXF1aXJlKFwiLi4vLi4vc3RyZWFtL0xhenlJdGVyYWJsZUl0ZXJhdG9yXCIpO1xuY2xhc3MgU3ViYXJyYXlBcmJpdHJhcnkgZXh0ZW5kcyBBcmJpdHJhcnlfMS5BcmJpdHJhcnkge1xuICAgIGNvbnN0cnVjdG9yKG9yaWdpbmFsQXJyYXksIGlzT3JkZXJlZCwgbWluTGVuZ3RoLCBtYXhMZW5ndGgpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5vcmlnaW5hbEFycmF5ID0gb3JpZ2luYWxBcnJheTtcbiAgICAgICAgdGhpcy5pc09yZGVyZWQgPSBpc09yZGVyZWQ7XG4gICAgICAgIHRoaXMubWluTGVuZ3RoID0gbWluTGVuZ3RoO1xuICAgICAgICB0aGlzLm1heExlbmd0aCA9IG1heExlbmd0aDtcbiAgICAgICAgaWYgKG1pbkxlbmd0aCA8IDAgfHwgbWluTGVuZ3RoID4gb3JpZ2luYWxBcnJheS5sZW5ndGgpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ZjLip7c3xTfXViYXJyYXlPZiBleHBlY3RzIHRoZSBtaW5pbWFsIGxlbmd0aCB0byBiZSBiZXR3ZWVuIDAgYW5kIHRoZSBzaXplIG9mIHRoZSBvcmlnaW5hbCBhcnJheScpO1xuICAgICAgICBpZiAobWF4TGVuZ3RoIDwgMCB8fCBtYXhMZW5ndGggPiBvcmlnaW5hbEFycmF5Lmxlbmd0aClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignZmMuKntzfFN9dWJhcnJheU9mIGV4cGVjdHMgdGhlIG1heGltYWwgbGVuZ3RoIHRvIGJlIGJldHdlZW4gMCBhbmQgdGhlIHNpemUgb2YgdGhlIG9yaWdpbmFsIGFycmF5Jyk7XG4gICAgICAgIGlmIChtaW5MZW5ndGggPiBtYXhMZW5ndGgpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ZjLip7c3xTfXViYXJyYXlPZiBleHBlY3RzIHRoZSBtaW5pbWFsIGxlbmd0aCB0byBiZSBpbmZlcmlvciBvciBlcXVhbCB0byB0aGUgbWF4aW1hbCBsZW5ndGgnKTtcbiAgICAgICAgdGhpcy5sZW5ndGhBcmIgPSBpbnRlZ2VyXzEuaW50ZWdlcihtaW5MZW5ndGgsIG1heExlbmd0aCk7XG4gICAgfVxuICAgIHdyYXBwZXIoaXRlbXMsIGl0ZW1zTGVuZ3RoQ29udGV4dCkge1xuICAgICAgICByZXR1cm4gbmV3IFNocmlua2FibGVfMS5TaHJpbmthYmxlKGl0ZW1zLCAoKSA9PiB0aGlzLnNocmlua0ltcGwoaXRlbXMsIGl0ZW1zTGVuZ3RoQ29udGV4dCkubWFwKChjb250ZXh0dWFsVmFsdWUpID0+IHRoaXMud3JhcHBlcihjb250ZXh0dWFsVmFsdWVbMF0sIGNvbnRleHR1YWxWYWx1ZVsxXSkpKTtcbiAgICB9XG4gICAgZ2VuZXJhdGUobXJuZykge1xuICAgICAgICBjb25zdCByZW1haW5pbmdFbGVtZW50cyA9IHRoaXMub3JpZ2luYWxBcnJheS5tYXAoKF92LCBpZHgpID0+IGlkeCk7XG4gICAgICAgIGNvbnN0IHNpemUgPSB0aGlzLmxlbmd0aEFyYi5nZW5lcmF0ZShtcm5nKS52YWx1ZTtcbiAgICAgICAgY29uc3QgaWRzID0gW107XG4gICAgICAgIGZvciAobGV0IGlkeCA9IDA7IGlkeCAhPT0gc2l6ZTsgKytpZHgpIHtcbiAgICAgICAgICAgIGNvbnN0IHNlbGVjdGVkSWRJbmRleCA9IG1ybmcubmV4dEludCgwLCByZW1haW5pbmdFbGVtZW50cy5sZW5ndGggLSAxKTtcbiAgICAgICAgICAgIGlkcy5wdXNoKHJlbWFpbmluZ0VsZW1lbnRzW3NlbGVjdGVkSWRJbmRleF0pO1xuICAgICAgICAgICAgcmVtYWluaW5nRWxlbWVudHMuc3BsaWNlKHNlbGVjdGVkSWRJbmRleCwgMSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuaXNPcmRlcmVkKVxuICAgICAgICAgICAgaWRzLnNvcnQoKGEsIGIpID0+IGEgLSBiKTtcbiAgICAgICAgcmV0dXJuIHRoaXMud3JhcHBlcihpZHMubWFwKChpKSA9PiB0aGlzLm9yaWdpbmFsQXJyYXlbaV0pLCB1bmRlZmluZWQpO1xuICAgIH1cbiAgICBzaHJpbmtJbXBsKGl0ZW1zLCBpdGVtc0xlbmd0aENvbnRleHQpIHtcbiAgICAgICAgaWYgKGl0ZW1zLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIFN0cmVhbV8xLlN0cmVhbS5uaWwoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5sZW5ndGhBcmJcbiAgICAgICAgICAgIC5jb250ZXh0dWFsU2hyaW5rKGl0ZW1zLmxlbmd0aCwgaXRlbXNMZW5ndGhDb250ZXh0KVxuICAgICAgICAgICAgLm1hcCgoY29udGV4dHVhbFZhbHVlKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgIGl0ZW1zLnNsaWNlKGl0ZW1zLmxlbmd0aCAtIGNvbnRleHR1YWxWYWx1ZVswXSksXG4gICAgICAgICAgICAgICAgY29udGV4dHVhbFZhbHVlWzFdLFxuICAgICAgICAgICAgXTtcbiAgICAgICAgfSlcbiAgICAgICAgICAgIC5qb2luKGl0ZW1zLmxlbmd0aCA+IHRoaXMubWluTGVuZ3RoXG4gICAgICAgICAgICA/IExhenlJdGVyYWJsZUl0ZXJhdG9yXzEubWFrZUxhenkoKCkgPT4gdGhpcy5zaHJpbmtJbXBsKGl0ZW1zLnNsaWNlKDEpLCB1bmRlZmluZWQpXG4gICAgICAgICAgICAgICAgLmZpbHRlcigoY29udGV4dHVhbFZhbHVlKSA9PiB0aGlzLm1pbkxlbmd0aCA8PSBjb250ZXh0dWFsVmFsdWVbMF0ubGVuZ3RoICsgMSlcbiAgICAgICAgICAgICAgICAubWFwKChjb250ZXh0dWFsVmFsdWUpID0+IFtbaXRlbXNbMF1dLmNvbmNhdChjb250ZXh0dWFsVmFsdWVbMF0pLCB1bmRlZmluZWRdKSlcbiAgICAgICAgICAgIDogU3RyZWFtXzEuU3RyZWFtLm5pbCgpKTtcbiAgICB9XG4gICAgd2l0aEJpYXMoZnJlcSkge1xuICAgICAgICByZXR1cm4gdGhpcy5taW5MZW5ndGggIT09IHRoaXMubWF4TGVuZ3RoXG4gICAgICAgICAgICA/IEJpYXNlZEFyYml0cmFyeVdyYXBwZXJfMS5iaWFzV3JhcHBlcihmcmVxLCB0aGlzLCAob3JpZ2luYWxBcmJpdHJhcnkpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFN1YmFycmF5QXJiaXRyYXJ5KG9yaWdpbmFsQXJiaXRyYXJ5Lm9yaWdpbmFsQXJyYXksIG9yaWdpbmFsQXJiaXRyYXJ5LmlzT3JkZXJlZCwgb3JpZ2luYWxBcmJpdHJhcnkubWluTGVuZ3RoLCBvcmlnaW5hbEFyYml0cmFyeS5taW5MZW5ndGggK1xuICAgICAgICAgICAgICAgICAgICBNYXRoLmZsb29yKE1hdGgubG9nKG9yaWdpbmFsQXJiaXRyYXJ5Lm1heExlbmd0aCAtIG9yaWdpbmFsQXJiaXRyYXJ5Lm1pbkxlbmd0aCkgLyBNYXRoLmxvZygyKSkpO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIDogdGhpcztcbiAgICB9XG59XG5mdW5jdGlvbiBzdWJhcnJheShvcmlnaW5hbEFycmF5LCAuLi5hcmdzKSB7XG4gICAgaWYgKHR5cGVvZiBhcmdzWzBdID09PSAnbnVtYmVyJyAmJiB0eXBlb2YgYXJnc1sxXSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTdWJhcnJheUFyYml0cmFyeShvcmlnaW5hbEFycmF5LCB0cnVlLCBhcmdzWzBdLCBhcmdzWzFdKTtcbiAgICB9XG4gICAgY29uc3QgY3QgPSBhcmdzWzBdO1xuICAgIGNvbnN0IG1pbkxlbmd0aCA9IGN0ICE9PSB1bmRlZmluZWQgJiYgY3QubWluTGVuZ3RoICE9PSB1bmRlZmluZWQgPyBjdC5taW5MZW5ndGggOiAwO1xuICAgIGNvbnN0IG1heExlbmd0aCA9IGN0ICE9PSB1bmRlZmluZWQgJiYgY3QubWF4TGVuZ3RoICE9PSB1bmRlZmluZWQgPyBjdC5tYXhMZW5ndGggOiBvcmlnaW5hbEFycmF5Lmxlbmd0aDtcbiAgICByZXR1cm4gbmV3IFN1YmFycmF5QXJiaXRyYXJ5KG9yaWdpbmFsQXJyYXksIHRydWUsIG1pbkxlbmd0aCwgbWF4TGVuZ3RoKTtcbn1cbmV4cG9ydHMuc3ViYXJyYXkgPSBzdWJhcnJheTtcbmZ1bmN0aW9uIHNodWZmbGVkU3ViYXJyYXkob3JpZ2luYWxBcnJheSwgLi4uYXJncykge1xuICAgIGlmICh0eXBlb2YgYXJnc1swXSA9PT0gJ251bWJlcicgJiYgdHlwZW9mIGFyZ3NbMV0gPT09ICdudW1iZXInKSB7XG4gICAgICAgIHJldHVybiBuZXcgU3ViYXJyYXlBcmJpdHJhcnkob3JpZ2luYWxBcnJheSwgZmFsc2UsIGFyZ3NbMF0sIGFyZ3NbMV0pO1xuICAgIH1cbiAgICBjb25zdCBjdCA9IGFyZ3NbMF07XG4gICAgY29uc3QgbWluTGVuZ3RoID0gY3QgIT09IHVuZGVmaW5lZCAmJiBjdC5taW5MZW5ndGggIT09IHVuZGVmaW5lZCA/IGN0Lm1pbkxlbmd0aCA6IDA7XG4gICAgY29uc3QgbWF4TGVuZ3RoID0gY3QgIT09IHVuZGVmaW5lZCAmJiBjdC5tYXhMZW5ndGggIT09IHVuZGVmaW5lZCA/IGN0Lm1heExlbmd0aCA6IG9yaWdpbmFsQXJyYXkubGVuZ3RoO1xuICAgIHJldHVybiBuZXcgU3ViYXJyYXlBcmJpdHJhcnkob3JpZ2luYWxBcnJheSwgZmFsc2UsIG1pbkxlbmd0aCwgbWF4TGVuZ3RoKTtcbn1cbmV4cG9ydHMuc2h1ZmZsZWRTdWJhcnJheSA9IHNodWZmbGVkU3ViYXJyYXk7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMudXVpZFYgPSBleHBvcnRzLnV1aWQgPSB2b2lkIDA7XG5jb25zdCBpbnRlZ2VyXzEgPSByZXF1aXJlKFwiLi4vLi4vYXJiaXRyYXJ5L2ludGVnZXJcIik7XG5jb25zdCBuYXRfMSA9IHJlcXVpcmUoXCIuLi8uLi9hcmJpdHJhcnkvbmF0XCIpO1xuY29uc3QgdHVwbGVfMSA9IHJlcXVpcmUoXCIuLi8uLi9hcmJpdHJhcnkvdHVwbGVcIik7XG5jb25zdCBwYWRFaWdodCA9IChhcmIpID0+IGFyYi5tYXAoKG4pID0+IG4udG9TdHJpbmcoMTYpLnBhZFN0YXJ0KDgsICcwJykpO1xuZnVuY3Rpb24gdXVpZCgpIHtcbiAgICBjb25zdCBwYWRkZWQgPSBwYWRFaWdodChuYXRfMS5uYXQoMHhmZmZmZmZmZikpO1xuICAgIGNvbnN0IHNlY29uZFBhZGRlZCA9IHBhZEVpZ2h0KGludGVnZXJfMS5pbnRlZ2VyKDB4MTAwMDAwMDAsIDB4NWZmZmZmZmYpKTtcbiAgICBjb25zdCB0aGlyZFBhZGRlZCA9IHBhZEVpZ2h0KGludGVnZXJfMS5pbnRlZ2VyKDB4ODAwMDAwMDAsIDB4YmZmZmZmZmYpKTtcbiAgICByZXR1cm4gdHVwbGVfMS50dXBsZShwYWRkZWQsIHNlY29uZFBhZGRlZCwgdGhpcmRQYWRkZWQsIHBhZGRlZCkubWFwKCh0KSA9PiB7XG4gICAgICAgIHJldHVybiBgJHt0WzBdfS0ke3RbMV0uc3Vic3RyaW5nKDQpfS0ke3RbMV0uc3Vic3RyaW5nKDAsIDQpfS0ke3RbMl0uc3Vic3RyaW5nKDAsIDQpfS0ke3RbMl0uc3Vic3RyaW5nKDQpfSR7dFszXX1gO1xuICAgIH0pO1xufVxuZXhwb3J0cy51dWlkID0gdXVpZDtcbmZ1bmN0aW9uIHV1aWRWKHZlcnNpb25OdW1iZXIpIHtcbiAgICBjb25zdCBwYWRkZWQgPSBwYWRFaWdodChuYXRfMS5uYXQoMHhmZmZmZmZmZikpO1xuICAgIGNvbnN0IHNlY29uZFBhZGRlZCA9IHBhZEVpZ2h0KG5hdF8xLm5hdCgweDBmZmZmZmZmKSk7XG4gICAgY29uc3QgdGhpcmRQYWRkZWQgPSBwYWRFaWdodChpbnRlZ2VyXzEuaW50ZWdlcigweDgwMDAwMDAwLCAweGJmZmZmZmZmKSk7XG4gICAgcmV0dXJuIHR1cGxlXzEudHVwbGUocGFkZGVkLCBzZWNvbmRQYWRkZWQsIHRoaXJkUGFkZGVkLCBwYWRkZWQpLm1hcCgodCkgPT4ge1xuICAgICAgICByZXR1cm4gYCR7dFswXX0tJHt0WzFdLnN1YnN0cmluZyg0KX0tJHt2ZXJzaW9uTnVtYmVyfSR7dFsxXS5zdWJzdHJpbmcoMSwgNCl9LSR7dFsyXS5zdWJzdHJpbmcoMCwgNCl9LSR7dFsyXS5zdWJzdHJpbmcoNCl9JHt0WzNdfWA7XG4gICAgfSk7XG59XG5leHBvcnRzLnV1aWRWID0gdXVpZFY7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMud2ViVXJsID0gZXhwb3J0cy53ZWJGcmFnbWVudHMgPSBleHBvcnRzLndlYlF1ZXJ5UGFyYW1ldGVycyA9IGV4cG9ydHMud2ViU2VnbWVudCA9IGV4cG9ydHMud2ViQXV0aG9yaXR5ID0gdm9pZCAwO1xuY29uc3QgYXJyYXlfMSA9IHJlcXVpcmUoXCIuLi8uLi9hcmJpdHJhcnkvYXJyYXlcIik7XG5jb25zdCBjb25zdGFudEZyb21fMSA9IHJlcXVpcmUoXCIuLi8uLi9hcmJpdHJhcnkvY29uc3RhbnRGcm9tXCIpO1xuY29uc3QgY29uc3RhbnRfMSA9IHJlcXVpcmUoXCIuLi8uLi9hcmJpdHJhcnkvY29uc3RhbnRcIik7XG5jb25zdCBTcGVjaWZpY0NoYXJhY3RlclJhbmdlXzEgPSByZXF1aXJlKFwiLi9oZWxwZXJzL1NwZWNpZmljQ2hhcmFjdGVyUmFuZ2VcIik7XG5jb25zdCBIb3N0QXJiaXRyYXJ5XzEgPSByZXF1aXJlKFwiLi9Ib3N0QXJiaXRyYXJ5XCIpO1xuY29uc3QgbmF0XzEgPSByZXF1aXJlKFwiLi4vLi4vYXJiaXRyYXJ5L25hdFwiKTtcbmNvbnN0IGlwVjRfMSA9IHJlcXVpcmUoXCIuLi8uLi9hcmJpdHJhcnkvaXBWNFwiKTtcbmNvbnN0IGlwVjRFeHRlbmRlZF8xID0gcmVxdWlyZShcIi4uLy4uL2FyYml0cmFyeS9pcFY0RXh0ZW5kZWRcIik7XG5jb25zdCBpcFY2XzEgPSByZXF1aXJlKFwiLi4vLi4vYXJiaXRyYXJ5L2lwVjZcIik7XG5jb25zdCBvbmVvZl8xID0gcmVxdWlyZShcIi4uLy4uL2FyYml0cmFyeS9vbmVvZlwiKTtcbmNvbnN0IG9wdGlvbl8xID0gcmVxdWlyZShcIi4uLy4uL2FyYml0cmFyeS9vcHRpb25cIik7XG5jb25zdCBzdHJpbmdPZl8xID0gcmVxdWlyZShcIi4uLy4uL2FyYml0cmFyeS9zdHJpbmdPZlwiKTtcbmNvbnN0IHR1cGxlXzEgPSByZXF1aXJlKFwiLi4vLi4vYXJiaXRyYXJ5L3R1cGxlXCIpO1xuZnVuY3Rpb24gd2ViQXV0aG9yaXR5KGNvbnN0cmFpbnRzKSB7XG4gICAgY29uc3QgYyA9IGNvbnN0cmFpbnRzIHx8IHt9O1xuICAgIGNvbnN0IGhvc3RuYW1lQXJicyA9IFtIb3N0QXJiaXRyYXJ5XzEuZG9tYWluKCldXG4gICAgICAgIC5jb25jYXQoYy53aXRoSVB2NCA9PT0gdHJ1ZSA/IFtpcFY0XzEuaXBWNCgpXSA6IFtdKVxuICAgICAgICAuY29uY2F0KGMud2l0aElQdjYgPT09IHRydWUgPyBbaXBWNl8xLmlwVjYoKS5tYXAoKGlwKSA9PiBgWyR7aXB9XWApXSA6IFtdKVxuICAgICAgICAuY29uY2F0KGMud2l0aElQdjRFeHRlbmRlZCA9PT0gdHJ1ZSA/IFtpcFY0RXh0ZW5kZWRfMS5pcFY0RXh0ZW5kZWQoKV0gOiBbXSk7XG4gICAgcmV0dXJuIHR1cGxlXzEudHVwbGUoYy53aXRoVXNlckluZm8gPT09IHRydWUgPyBvcHRpb25fMS5vcHRpb24oSG9zdEFyYml0cmFyeV8xLmhvc3RVc2VySW5mbygpKSA6IGNvbnN0YW50XzEuY29uc3RhbnQobnVsbCksIG9uZW9mXzEub25lb2YoLi4uaG9zdG5hbWVBcmJzKSwgYy53aXRoUG9ydCA9PT0gdHJ1ZSA/IG9wdGlvbl8xLm9wdGlvbihuYXRfMS5uYXQoNjU1MzUpKSA6IGNvbnN0YW50XzEuY29uc3RhbnQobnVsbCkpLm1hcCgoW3UsIGgsIHBdKSA9PiAodSA9PT0gbnVsbCA/ICcnIDogYCR7dX1AYCkgKyBoICsgKHAgPT09IG51bGwgPyAnJyA6IGA6JHtwfWApKTtcbn1cbmV4cG9ydHMud2ViQXV0aG9yaXR5ID0gd2ViQXV0aG9yaXR5O1xuZnVuY3Rpb24gd2ViU2VnbWVudCgpIHtcbiAgICBjb25zdCBvdGhlcnMgPSBbJy0nLCAnLicsICdfJywgJ34nLCAnIScsICckJywgJyYnLCBcIidcIiwgJygnLCAnKScsICcqJywgJysnLCAnLCcsICc7JywgJz0nLCAnOicsICdAJ107XG4gICAgcmV0dXJuIHN0cmluZ09mXzEuc3RyaW5nT2YoU3BlY2lmaWNDaGFyYWN0ZXJSYW5nZV8xLmJ1aWxkQWxwaGFOdW1lcmljUGVyY2VudEFyYihvdGhlcnMpKTtcbn1cbmV4cG9ydHMud2ViU2VnbWVudCA9IHdlYlNlZ21lbnQ7XG5mdW5jdGlvbiB1cmlRdWVyeU9yRnJhZ21lbnQoKSB7XG4gICAgY29uc3Qgb3RoZXJzID0gWyctJywgJy4nLCAnXycsICd+JywgJyEnLCAnJCcsICcmJywgXCInXCIsICcoJywgJyknLCAnKicsICcrJywgJywnLCAnOycsICc9JywgJzonLCAnQCcsICcvJywgJz8nXTtcbiAgICByZXR1cm4gc3RyaW5nT2ZfMS5zdHJpbmdPZihTcGVjaWZpY0NoYXJhY3RlclJhbmdlXzEuYnVpbGRBbHBoYU51bWVyaWNQZXJjZW50QXJiKG90aGVycykpO1xufVxuZnVuY3Rpb24gd2ViUXVlcnlQYXJhbWV0ZXJzKCkge1xuICAgIHJldHVybiB1cmlRdWVyeU9yRnJhZ21lbnQoKTtcbn1cbmV4cG9ydHMud2ViUXVlcnlQYXJhbWV0ZXJzID0gd2ViUXVlcnlQYXJhbWV0ZXJzO1xuZnVuY3Rpb24gd2ViRnJhZ21lbnRzKCkge1xuICAgIHJldHVybiB1cmlRdWVyeU9yRnJhZ21lbnQoKTtcbn1cbmV4cG9ydHMud2ViRnJhZ21lbnRzID0gd2ViRnJhZ21lbnRzO1xuZnVuY3Rpb24gd2ViVXJsKGNvbnN0cmFpbnRzKSB7XG4gICAgY29uc3QgYyA9IGNvbnN0cmFpbnRzIHx8IHt9O1xuICAgIGNvbnN0IHZhbGlkU2NoZW1lcyA9IGMudmFsaWRTY2hlbWVzIHx8IFsnaHR0cCcsICdodHRwcyddO1xuICAgIGNvbnN0IHNjaGVtZUFyYiA9IGNvbnN0YW50RnJvbV8xLmNvbnN0YW50RnJvbSguLi52YWxpZFNjaGVtZXMpO1xuICAgIGNvbnN0IGF1dGhvcml0eUFyYiA9IHdlYkF1dGhvcml0eShjLmF1dGhvcml0eVNldHRpbmdzKTtcbiAgICBjb25zdCBwYXRoQXJiID0gYXJyYXlfMS5hcnJheSh3ZWJTZWdtZW50KCkpLm1hcCgocCkgPT4gcC5tYXAoKHYpID0+IGAvJHt2fWApLmpvaW4oJycpKTtcbiAgICByZXR1cm4gdHVwbGVfMS50dXBsZShzY2hlbWVBcmIsIGF1dGhvcml0eUFyYiwgcGF0aEFyYiwgYy53aXRoUXVlcnlQYXJhbWV0ZXJzID09PSB0cnVlID8gb3B0aW9uXzEub3B0aW9uKHdlYlF1ZXJ5UGFyYW1ldGVycygpKSA6IGNvbnN0YW50XzEuY29uc3RhbnQobnVsbCksIGMud2l0aEZyYWdtZW50cyA9PT0gdHJ1ZSA/IG9wdGlvbl8xLm9wdGlvbih3ZWJGcmFnbWVudHMoKSkgOiBjb25zdGFudF8xLmNvbnN0YW50KG51bGwpKS5tYXAoKFtzLCBhLCBwLCBxLCBmXSkgPT4gYCR7c306Ly8ke2F9JHtwfSR7cSA9PT0gbnVsbCA/ICcnIDogYD8ke3F9YH0ke2YgPT09IG51bGwgPyAnJyA6IGAjJHtmfWB9YCk7XG59XG5leHBvcnRzLndlYlVybCA9IHdlYlVybDtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5hc3NlcnRJc0FyYml0cmFyeSA9IGV4cG9ydHMuQXJiaXRyYXJ5ID0gdm9pZCAwO1xuY29uc3QgU2hyaW5rYWJsZV8xID0gcmVxdWlyZShcIi4vU2hyaW5rYWJsZVwiKTtcbmNsYXNzIEFyYml0cmFyeSB7XG4gICAgZmlsdGVyKHJlZmluZW1lbnQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBGaWx0ZXJBcmJpdHJhcnkodGhpcywgcmVmaW5lbWVudCk7XG4gICAgfVxuICAgIG1hcChtYXBwZXIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBNYXBBcmJpdHJhcnkodGhpcywgbWFwcGVyKTtcbiAgICB9XG4gICAgY2hhaW4oZm1hcHBlcikge1xuICAgICAgICByZXR1cm4gbmV3IENoYWluQXJiaXRyYXJ5KHRoaXMsIGZtYXBwZXIpO1xuICAgIH1cbiAgICBub1NocmluaygpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBOb1Nocmlua0FyYml0cmFyeSh0aGlzKTtcbiAgICB9XG4gICAgd2l0aEJpYXMoX2ZyZXEpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIG5vQmlhcygpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBOb0JpYXNBcmJpdHJhcnkodGhpcyk7XG4gICAgfVxufVxuZXhwb3J0cy5BcmJpdHJhcnkgPSBBcmJpdHJhcnk7XG5jbGFzcyBDaGFpbkFyYml0cmFyeSBleHRlbmRzIEFyYml0cmFyeSB7XG4gICAgY29uc3RydWN0b3IoYXJiLCBmbWFwcGVyKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuYXJiID0gYXJiO1xuICAgICAgICB0aGlzLmZtYXBwZXIgPSBmbWFwcGVyO1xuICAgIH1cbiAgICBnZW5lcmF0ZShtcm5nKSB7XG4gICAgICAgIGNvbnN0IGNsb25lZE1ybmcgPSBtcm5nLmNsb25lKCk7XG4gICAgICAgIGNvbnN0IHNyYyA9IHRoaXMuYXJiLmdlbmVyYXRlKG1ybmcpO1xuICAgICAgICBjb25zdCBkc3QgPSB0aGlzLmZtYXBwZXIoc3JjLnZhbHVlKS5nZW5lcmF0ZShtcm5nKTtcbiAgICAgICAgcmV0dXJuIENoYWluQXJiaXRyYXJ5LnNocmlua0NoYWluKGNsb25lZE1ybmcsIHNyYywgZHN0LCB0aGlzLmZtYXBwZXIpO1xuICAgIH1cbiAgICB3aXRoQmlhcyhmcmVxKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFyYi53aXRoQmlhcyhmcmVxKS5jaGFpbigodCkgPT4gdGhpcy5mbWFwcGVyKHQpLndpdGhCaWFzKGZyZXEpKTtcbiAgICB9XG4gICAgc3RhdGljIHNocmlua0NoYWluKG1ybmcsIHNyYywgZHN0LCBmbWFwcGVyKSB7XG4gICAgICAgIHJldHVybiBuZXcgU2hyaW5rYWJsZV8xLlNocmlua2FibGUoZHN0LnZhbHVlLCAoKSA9PiBzcmNcbiAgICAgICAgICAgIC5zaHJpbmsoKVxuICAgICAgICAgICAgLm1hcCgodikgPT4gQ2hhaW5BcmJpdHJhcnkuc2hyaW5rQ2hhaW4obXJuZy5jbG9uZSgpLCB2LCBmbWFwcGVyKHYudmFsdWUpLmdlbmVyYXRlKG1ybmcuY2xvbmUoKSksIGZtYXBwZXIpKVxuICAgICAgICAgICAgLmpvaW4oZHN0LnNocmluaygpKSk7XG4gICAgfVxufVxuY2xhc3MgTWFwQXJiaXRyYXJ5IGV4dGVuZHMgQXJiaXRyYXJ5IHtcbiAgICBjb25zdHJ1Y3RvcihhcmIsIG1hcHBlcikge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmFyYiA9IGFyYjtcbiAgICAgICAgdGhpcy5tYXBwZXIgPSBtYXBwZXI7XG4gICAgfVxuICAgIGdlbmVyYXRlKG1ybmcpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXJiLmdlbmVyYXRlKG1ybmcpLm1hcCh0aGlzLm1hcHBlcik7XG4gICAgfVxuICAgIHdpdGhCaWFzKGZyZXEpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXJiLndpdGhCaWFzKGZyZXEpLm1hcCh0aGlzLm1hcHBlcik7XG4gICAgfVxufVxuY2xhc3MgRmlsdGVyQXJiaXRyYXJ5IGV4dGVuZHMgQXJiaXRyYXJ5IHtcbiAgICBjb25zdHJ1Y3RvcihhcmIsIHJlZmluZW1lbnQpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5hcmIgPSBhcmI7XG4gICAgICAgIHRoaXMucmVmaW5lbWVudCA9IHJlZmluZW1lbnQ7XG4gICAgfVxuICAgIGdlbmVyYXRlKG1ybmcpIHtcbiAgICAgICAgbGV0IGcgPSB0aGlzLmFyYi5nZW5lcmF0ZShtcm5nKTtcbiAgICAgICAgd2hpbGUgKCF0aGlzLnJlZmluZW1lbnRPblNocmlua2FibGUoZykpIHtcbiAgICAgICAgICAgIGcgPSB0aGlzLmFyYi5nZW5lcmF0ZShtcm5nKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZy5maWx0ZXIodGhpcy5yZWZpbmVtZW50KTtcbiAgICB9XG4gICAgd2l0aEJpYXMoZnJlcSkge1xuICAgICAgICByZXR1cm4gdGhpcy5hcmIud2l0aEJpYXMoZnJlcSkuZmlsdGVyKHRoaXMucmVmaW5lbWVudCk7XG4gICAgfVxuICAgIHJlZmluZW1lbnRPblNocmlua2FibGUocykge1xuICAgICAgICByZXR1cm4gdGhpcy5yZWZpbmVtZW50KHMudmFsdWUpO1xuICAgIH1cbn1cbmNsYXNzIE5vU2hyaW5rQXJiaXRyYXJ5IGV4dGVuZHMgQXJiaXRyYXJ5IHtcbiAgICBjb25zdHJ1Y3RvcihhcmIpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5hcmIgPSBhcmI7XG4gICAgfVxuICAgIGdlbmVyYXRlKG1ybmcpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTaHJpbmthYmxlXzEuU2hyaW5rYWJsZSh0aGlzLmFyYi5nZW5lcmF0ZShtcm5nKS52YWx1ZSk7XG4gICAgfVxuICAgIHdpdGhCaWFzKGZyZXEpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXJiLndpdGhCaWFzKGZyZXEpLm5vU2hyaW5rKCk7XG4gICAgfVxufVxuY2xhc3MgTm9CaWFzQXJiaXRyYXJ5IGV4dGVuZHMgQXJiaXRyYXJ5IHtcbiAgICBjb25zdHJ1Y3RvcihhcmIpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5hcmIgPSBhcmI7XG4gICAgfVxuICAgIGdlbmVyYXRlKG1ybmcpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXJiLmdlbmVyYXRlKG1ybmcpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGFzc2VydElzQXJiaXRyYXJ5KGluc3RhbmNlKSB7XG4gICAgaWYgKHR5cGVvZiBpbnN0YW5jZSAhPT0gJ29iamVjdCcgfHwgaW5zdGFuY2UgPT09IG51bGwgfHwgISgnZ2VuZXJhdGUnIGluIGluc3RhbmNlKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuZXhwZWN0ZWQgdmFsdWUgcmVjZWl2ZWQ6IG5vdCBhbiBpbnN0YW5jZSBvZiBBcmJpdHJhcnknKTtcbiAgICB9XG59XG5leHBvcnRzLmFzc2VydElzQXJiaXRyYXJ5ID0gYXNzZXJ0SXNBcmJpdHJhcnk7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQXJiaXRyYXJ5V2l0aENvbnRleHR1YWxTaHJpbmsgPSB2b2lkIDA7XG5jb25zdCBBcmJpdHJhcnlfMSA9IHJlcXVpcmUoXCIuL0FyYml0cmFyeVwiKTtcbmNvbnN0IFNocmlua2FibGVfMSA9IHJlcXVpcmUoXCIuL1Nocmlua2FibGVcIik7XG5mdW5jdGlvbiByZW1vdmVDb250ZXh0RnJvbUNvbnRleHR1YWxWYWx1ZShjb250ZXh0dWFsVmFsdWUpIHtcbiAgICByZXR1cm4gY29udGV4dHVhbFZhbHVlWzBdO1xufVxuY2xhc3MgQXJiaXRyYXJ5V2l0aENvbnRleHR1YWxTaHJpbmsgZXh0ZW5kcyBBcmJpdHJhcnlfMS5BcmJpdHJhcnkge1xuICAgIGNvbnRleHR1YWxTaHJpbmthYmxlRm9yKHZhbHVlLCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiBuZXcgU2hyaW5rYWJsZV8xLlNocmlua2FibGUodmFsdWUsICgpID0+IHRoaXMuY29udGV4dHVhbFNocmluayh2YWx1ZSwgY29udGV4dCkubWFwKChjb250ZXh0dWFsVmFsdWUpID0+IHRoaXMuY29udGV4dHVhbFNocmlua2FibGVGb3IoY29udGV4dHVhbFZhbHVlWzBdLCBjb250ZXh0dWFsVmFsdWVbMV0pKSk7XG4gICAgfVxuICAgIHNocmluayh2YWx1ZSwgc2hydW5rT25jZSkge1xuICAgICAgICBjb25zdCBjb250ZXh0ID0gc2hydW5rT25jZSA9PT0gdHJ1ZSA/IHRoaXMuc2hydW5rT25jZUNvbnRleHQoKSA6IHVuZGVmaW5lZDtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29udGV4dHVhbFNocmluayh2YWx1ZSwgY29udGV4dCkubWFwKHJlbW92ZUNvbnRleHRGcm9tQ29udGV4dHVhbFZhbHVlKTtcbiAgICB9XG4gICAgc2hyaW5rYWJsZUZvcih2YWx1ZSwgc2hydW5rT25jZSkge1xuICAgICAgICByZXR1cm4gbmV3IFNocmlua2FibGVfMS5TaHJpbmthYmxlKHZhbHVlLCAoKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zaHJpbmsodmFsdWUsIHNocnVua09uY2UpLm1hcCgodmFsdWUpID0+IHRoaXMuc2hyaW5rYWJsZUZvcih2YWx1ZSwgdHJ1ZSkpO1xuICAgICAgICB9KTtcbiAgICB9XG59XG5leHBvcnRzLkFyYml0cmFyeVdpdGhDb250ZXh0dWFsU2hyaW5rID0gQXJiaXRyYXJ5V2l0aENvbnRleHR1YWxTaHJpbms7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQXJiaXRyYXJ5V2l0aFNocmluayA9IHZvaWQgMDtcbmNvbnN0IEFyYml0cmFyeV8xID0gcmVxdWlyZShcIi4vQXJiaXRyYXJ5XCIpO1xuY29uc3QgU2hyaW5rYWJsZV8xID0gcmVxdWlyZShcIi4vU2hyaW5rYWJsZVwiKTtcbmNsYXNzIEFyYml0cmFyeVdpdGhTaHJpbmsgZXh0ZW5kcyBBcmJpdHJhcnlfMS5BcmJpdHJhcnkge1xuICAgIHNocmlua2FibGVGb3IodmFsdWUsIHNocnVua09uY2UpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTaHJpbmthYmxlXzEuU2hyaW5rYWJsZSh2YWx1ZSwgKCkgPT4gdGhpcy5zaHJpbmsodmFsdWUsIHNocnVua09uY2UgPT09IHRydWUpLm1hcCgodikgPT4gdGhpcy5zaHJpbmthYmxlRm9yKHYsIHRydWUpKSk7XG4gICAgfVxufVxuZXhwb3J0cy5BcmJpdHJhcnlXaXRoU2hyaW5rID0gQXJiaXRyYXJ5V2l0aFNocmluaztcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5iaWFzV3JhcHBlciA9IHZvaWQgMDtcbmNvbnN0IEFyYml0cmFyeV8xID0gcmVxdWlyZShcIi4vQXJiaXRyYXJ5XCIpO1xuY2xhc3MgQmlhc2VkQXJiaXRyYXJ5V3JhcHBlciBleHRlbmRzIEFyYml0cmFyeV8xLkFyYml0cmFyeSB7XG4gICAgY29uc3RydWN0b3IoZnJlcSwgYXJiLCBiaWFzZWRBcmJCdWlsZGVyKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuZnJlcSA9IGZyZXE7XG4gICAgICAgIHRoaXMuYXJiID0gYXJiO1xuICAgICAgICB0aGlzLmJpYXNlZEFyYkJ1aWxkZXIgPSBiaWFzZWRBcmJCdWlsZGVyO1xuICAgIH1cbiAgICBnZW5lcmF0ZShtcm5nKSB7XG4gICAgICAgIHJldHVybiBtcm5nLm5leHRJbnQoMSwgdGhpcy5mcmVxKSA9PT0gMSA/IHRoaXMuYmlhc2VkQXJiQnVpbGRlcih0aGlzLmFyYikuZ2VuZXJhdGUobXJuZykgOiB0aGlzLmFyYi5nZW5lcmF0ZShtcm5nKTtcbiAgICB9XG59XG5mdW5jdGlvbiBiaWFzV3JhcHBlcihmcmVxLCBhcmIsIGJpYXNlZEFyYkJ1aWxkZXIpIHtcbiAgICByZXR1cm4gbmV3IEJpYXNlZEFyYml0cmFyeVdyYXBwZXIoZnJlcSwgYXJiLCBiaWFzZWRBcmJCdWlsZGVyKTtcbn1cbmV4cG9ydHMuYmlhc1dyYXBwZXIgPSBiaWFzV3JhcHBlcjtcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9hO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Db252ZXJ0ZXJGcm9tTmV4dCA9IHZvaWQgMDtcbmNvbnN0IEFyYml0cmFyeVdpdGhDb250ZXh0dWFsU2hyaW5rXzEgPSByZXF1aXJlKFwiLi9BcmJpdHJhcnlXaXRoQ29udGV4dHVhbFNocmlua1wiKTtcbmNvbnN0IENvbnZlcnRlclRvTmV4dF8xID0gcmVxdWlyZShcIi4vQ29udmVydGVyVG9OZXh0XCIpO1xuY29uc3QgU2hyaW5rYWJsZV8xID0gcmVxdWlyZShcIi4vU2hyaW5rYWJsZVwiKTtcbmNvbnN0IGlkZW50aWZpZXIgPSAnX19Db252ZXJ0ZXJGcm9tTmV4dF9fJztcbmZ1bmN0aW9uIGZyb21OZXh0VmFsdWVUb1Nocmlua2FibGVGb3IoYXJiKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIGZyb21OZXh0VmFsdWVUb1Nocmlua2FibGUodikge1xuICAgICAgICBjb25zdCB2YWx1ZV8gPSB2LnZhbHVlXztcbiAgICAgICAgY29uc3Qgc2hyaW5rZXIgPSAoKSA9PiBhcmIuc2hyaW5rKHZhbHVlXywgdi5jb250ZXh0KS5tYXAoZnJvbU5leHRWYWx1ZVRvU2hyaW5rYWJsZSk7XG4gICAgICAgIGlmICghdi5oYXNUb0JlQ2xvbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFNocmlua2FibGVfMS5TaHJpbmthYmxlKHZhbHVlXywgc2hyaW5rZXIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgU2hyaW5rYWJsZV8xLlNocmlua2FibGUodmFsdWVfLCBzaHJpbmtlciwgKCkgPT4gdi52YWx1ZSk7XG4gICAgfTtcbn1cbmNsYXNzIENvbnZlcnRlckZyb21OZXh0IGV4dGVuZHMgQXJiaXRyYXJ5V2l0aENvbnRleHR1YWxTaHJpbmtfMS5BcmJpdHJhcnlXaXRoQ29udGV4dHVhbFNocmluayB7XG4gICAgY29uc3RydWN0b3IoYXJiLCBsZWdhY3lTaHJ1bmtPbmNlQ29udGV4dCwgYmlhc0ZhY3RvciA9IHVuZGVmaW5lZCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmFyYiA9IGFyYjtcbiAgICAgICAgdGhpcy5sZWdhY3lTaHJ1bmtPbmNlQ29udGV4dCA9IGxlZ2FjeVNocnVua09uY2VDb250ZXh0O1xuICAgICAgICB0aGlzLmJpYXNGYWN0b3IgPSBiaWFzRmFjdG9yO1xuICAgICAgICB0aGlzW19hXSA9IHRydWU7XG4gICAgICAgIHRoaXMudG9TaHJpbmthYmxlID0gZnJvbU5leHRWYWx1ZVRvU2hyaW5rYWJsZUZvcihhcmIpO1xuICAgIH1cbiAgICBzdGF0aWMgaXNDb252ZXJ0ZXJGcm9tTmV4dChhcmIpIHtcbiAgICAgICAgcmV0dXJuIGlkZW50aWZpZXIgaW4gYXJiO1xuICAgIH1cbiAgICBzdGF0aWMgY29udmVydElmTmVlZGVkKGFyYikge1xuICAgICAgICBpZiAoQ29udmVydGVyVG9OZXh0XzEuQ29udmVydGVyVG9OZXh0LmlzQ29udmVydGVyVG9OZXh0KGFyYikpXG4gICAgICAgICAgICByZXR1cm4gYXJiLmFyYjtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBDb252ZXJ0ZXJGcm9tTmV4dChhcmIpO1xuICAgIH1cbiAgICBnZW5lcmF0ZShtcm5nKSB7XG4gICAgICAgIGNvbnN0IGcgPSB0aGlzLmFyYi5nZW5lcmF0ZShtcm5nLCB0aGlzLmJpYXNGYWN0b3IpO1xuICAgICAgICByZXR1cm4gdGhpcy50b1Nocmlua2FibGUoZyk7XG4gICAgfVxuICAgIGNvbnRleHR1YWxTaHJpbmsodmFsdWUsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXJiLnNocmluayh2YWx1ZSwgY29udGV4dCkubWFwKCh2KSA9PiBbdi52YWx1ZV8sIHYuY29udGV4dF0pO1xuICAgIH1cbiAgICBzaHJ1bmtPbmNlQ29udGV4dCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubGVnYWN5U2hydW5rT25jZUNvbnRleHQ7XG4gICAgfVxuICAgIGZpbHRlcihyZWZpbmVtZW50KSB7XG4gICAgICAgIHJldHVybiBDb252ZXJ0ZXJGcm9tTmV4dC5jb252ZXJ0SWZOZWVkZWQodGhpcy5hcmIuZmlsdGVyKHJlZmluZW1lbnQpKTtcbiAgICB9XG4gICAgbWFwKG1hcHBlcikge1xuICAgICAgICByZXR1cm4gQ29udmVydGVyRnJvbU5leHQuY29udmVydElmTmVlZGVkKHRoaXMuYXJiLm1hcChtYXBwZXIpKTtcbiAgICB9XG4gICAgY2hhaW4oZm1hcHBlcikge1xuICAgICAgICByZXR1cm4gQ29udmVydGVyRnJvbU5leHQuY29udmVydElmTmVlZGVkKHRoaXMuYXJiLmNoYWluKCh0KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBmbWFwcGVkID0gZm1hcHBlcih0KTtcbiAgICAgICAgICAgIGlmIChDb252ZXJ0ZXJGcm9tTmV4dC5pc0NvbnZlcnRlckZyb21OZXh0KGZtYXBwZWQpKVxuICAgICAgICAgICAgICAgIHJldHVybiBmbWFwcGVkLmFyYjtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IENvbnZlcnRlclRvTmV4dF8xLkNvbnZlcnRlclRvTmV4dChmbWFwcGVkKTtcbiAgICAgICAgfSkpO1xuICAgIH1cbiAgICBub1NocmluaygpIHtcbiAgICAgICAgcmV0dXJuIENvbnZlcnRlckZyb21OZXh0LmNvbnZlcnRJZk5lZWRlZCh0aGlzLmFyYi5ub1NocmluaygpKTtcbiAgICB9XG4gICAgd2l0aEJpYXMoZnJlcSkge1xuICAgICAgICByZXR1cm4gbmV3IENvbnZlcnRlckZyb21OZXh0KHRoaXMuYXJiLCB0aGlzLmxlZ2FjeVNocnVua09uY2VDb250ZXh0LCBmcmVxKTtcbiAgICB9XG4gICAgbm9CaWFzKCkge1xuICAgICAgICByZXR1cm4gQ29udmVydGVyRnJvbU5leHQuY29udmVydElmTmVlZGVkKHRoaXMuYXJiLm5vQmlhcygpKTtcbiAgICB9XG59XG5leHBvcnRzLkNvbnZlcnRlckZyb21OZXh0ID0gQ29udmVydGVyRnJvbU5leHQ7XG5fYSA9IGlkZW50aWZpZXI7XG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfYTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQ29udmVydGVyVG9OZXh0ID0gdm9pZCAwO1xuY29uc3QgU3RyZWFtXzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vc3RyZWFtL1N0cmVhbVwiKTtcbmNvbnN0IENvbnZlcnRlckZyb21OZXh0XzEgPSByZXF1aXJlKFwiLi9Db252ZXJ0ZXJGcm9tTmV4dFwiKTtcbmNvbnN0IE5leHRBcmJpdHJhcnlfMSA9IHJlcXVpcmUoXCIuL05leHRBcmJpdHJhcnlcIik7XG5jb25zdCBOZXh0VmFsdWVfMSA9IHJlcXVpcmUoXCIuL05leHRWYWx1ZVwiKTtcbmNvbnN0IGlkZW50aWZpZXIgPSAnX19Db252ZXJ0ZXJUb05leHRfXyc7XG5mdW5jdGlvbiBmcm9tU2hyaW5rYWJsZVRvTmV4dFZhbHVlKGcpIHtcbiAgICBpZiAoIWcuaGFzVG9CZUNsb25lZCkge1xuICAgICAgICByZXR1cm4gbmV3IE5leHRWYWx1ZV8xLk5leHRWYWx1ZShnLnZhbHVlXywgZyk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgTmV4dFZhbHVlXzEuTmV4dFZhbHVlKGcudmFsdWVfLCBnLCAoKSA9PiBnLnZhbHVlKTtcbn1cbmNsYXNzIENvbnZlcnRlclRvTmV4dCBleHRlbmRzIE5leHRBcmJpdHJhcnlfMS5OZXh0QXJiaXRyYXJ5IHtcbiAgICBjb25zdHJ1Y3RvcihhcmIpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5hcmIgPSBhcmI7XG4gICAgICAgIHRoaXNbX2FdID0gdHJ1ZTtcbiAgICB9XG4gICAgc3RhdGljIGlzQ29udmVydGVyVG9OZXh0KGFyYikge1xuICAgICAgICByZXR1cm4gaWRlbnRpZmllciBpbiBhcmI7XG4gICAgfVxuICAgIHN0YXRpYyBjb252ZXJ0SWZOZWVkZWQoYXJiKSB7XG4gICAgICAgIGlmIChDb252ZXJ0ZXJGcm9tTmV4dF8xLkNvbnZlcnRlckZyb21OZXh0LmlzQ29udmVydGVyRnJvbU5leHQoYXJiKSlcbiAgICAgICAgICAgIHJldHVybiBhcmIuYXJiO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICByZXR1cm4gbmV3IENvbnZlcnRlclRvTmV4dChhcmIpO1xuICAgIH1cbiAgICBnZW5lcmF0ZShtcm5nLCBiaWFzRmFjdG9yKSB7XG4gICAgICAgIGNvbnN0IGcgPSBiaWFzRmFjdG9yICE9PSB1bmRlZmluZWQgPyB0aGlzLmFyYi53aXRoQmlhcyhiaWFzRmFjdG9yKS5nZW5lcmF0ZShtcm5nKSA6IHRoaXMuYXJiLmdlbmVyYXRlKG1ybmcpO1xuICAgICAgICByZXR1cm4gZnJvbVNocmlua2FibGVUb05leHRWYWx1ZShnKTtcbiAgICB9XG4gICAgY2FuU2hyaW5rV2l0aG91dENvbnRleHQoX3ZhbHVlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgc2hyaW5rKF92YWx1ZSwgY29udGV4dCkge1xuICAgICAgICBpZiAodGhpcy5pc1NhZmVDb250ZXh0KGNvbnRleHQpKSB7XG4gICAgICAgICAgICByZXR1cm4gY29udGV4dC5zaHJpbmsoKS5tYXAoZnJvbVNocmlua2FibGVUb05leHRWYWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFN0cmVhbV8xLlN0cmVhbS5uaWwoKTtcbiAgICB9XG4gICAgaXNTYWZlQ29udGV4dChjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiAoY29udGV4dCAhPSBudWxsICYmIHR5cGVvZiBjb250ZXh0ID09PSAnb2JqZWN0JyAmJiAndmFsdWUnIGluIGNvbnRleHQgJiYgJ3NocmluaycgaW4gY29udGV4dCk7XG4gICAgfVxuICAgIGZpbHRlcihyZWZpbmVtZW50KSB7XG4gICAgICAgIHJldHVybiBDb252ZXJ0ZXJUb05leHQuY29udmVydElmTmVlZGVkKHRoaXMuYXJiLmZpbHRlcihyZWZpbmVtZW50KSk7XG4gICAgfVxuICAgIG1hcChtYXBwZXIpIHtcbiAgICAgICAgcmV0dXJuIENvbnZlcnRlclRvTmV4dC5jb252ZXJ0SWZOZWVkZWQodGhpcy5hcmIubWFwKG1hcHBlcikpO1xuICAgIH1cbiAgICBjaGFpbihmbWFwcGVyKSB7XG4gICAgICAgIHJldHVybiBDb252ZXJ0ZXJUb05leHQuY29udmVydElmTmVlZGVkKHRoaXMuYXJiLmNoYWluKCh0KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBmbWFwcGVkID0gZm1hcHBlcih0KTtcbiAgICAgICAgICAgIGlmIChDb252ZXJ0ZXJUb05leHQuaXNDb252ZXJ0ZXJUb05leHQoZm1hcHBlZCkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZtYXBwZWQuYXJiO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQ29udmVydGVyRnJvbU5leHRfMS5Db252ZXJ0ZXJGcm9tTmV4dChmbWFwcGVkKTtcbiAgICAgICAgfSkpO1xuICAgIH1cbiAgICBub1NocmluaygpIHtcbiAgICAgICAgcmV0dXJuIENvbnZlcnRlclRvTmV4dC5jb252ZXJ0SWZOZWVkZWQodGhpcy5hcmIubm9TaHJpbmsoKSk7XG4gICAgfVxuICAgIG5vQmlhcygpIHtcbiAgICAgICAgcmV0dXJuIENvbnZlcnRlclRvTmV4dC5jb252ZXJ0SWZOZWVkZWQodGhpcy5hcmIubm9CaWFzKCkpO1xuICAgIH1cbn1cbmV4cG9ydHMuQ29udmVydGVyVG9OZXh0ID0gQ29udmVydGVyVG9OZXh0O1xuX2EgPSBpZGVudGlmaWVyO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmNvbnZlcnRUb05leHQgPSBleHBvcnRzLmNvbnZlcnRGcm9tTmV4dFdpdGhTaHJ1bmtPbmNlID0gZXhwb3J0cy5jb252ZXJ0RnJvbU5leHQgPSB2b2lkIDA7XG5jb25zdCBBcmJpdHJhcnlfMSA9IHJlcXVpcmUoXCIuL0FyYml0cmFyeVwiKTtcbmNvbnN0IENvbnZlcnRlckZyb21OZXh0XzEgPSByZXF1aXJlKFwiLi9Db252ZXJ0ZXJGcm9tTmV4dFwiKTtcbmNvbnN0IENvbnZlcnRlclRvTmV4dF8xID0gcmVxdWlyZShcIi4vQ29udmVydGVyVG9OZXh0XCIpO1xuY29uc3QgTmV4dEFyYml0cmFyeV8xID0gcmVxdWlyZShcIi4vTmV4dEFyYml0cmFyeVwiKTtcbmZ1bmN0aW9uIGNvbnZlcnRGcm9tTmV4dChhcmIpIHtcbiAgICBpZiAoQ29udmVydGVyVG9OZXh0XzEuQ29udmVydGVyVG9OZXh0LmlzQ29udmVydGVyVG9OZXh0KGFyYikpIHtcbiAgICAgICAgcmV0dXJuIGFyYi5hcmI7XG4gICAgfVxuICAgIE5leHRBcmJpdHJhcnlfMS5hc3NlcnRJc05leHRBcmJpdHJhcnkoYXJiKTtcbiAgICByZXR1cm4gbmV3IENvbnZlcnRlckZyb21OZXh0XzEuQ29udmVydGVyRnJvbU5leHQoYXJiKTtcbn1cbmV4cG9ydHMuY29udmVydEZyb21OZXh0ID0gY29udmVydEZyb21OZXh0O1xuZnVuY3Rpb24gY29udmVydEZyb21OZXh0V2l0aFNocnVua09uY2UoYXJiLCBsZWdhY3lTaHJ1bmtPbmNlQ29udGV4dCkge1xuICAgIGlmIChDb252ZXJ0ZXJUb05leHRfMS5Db252ZXJ0ZXJUb05leHQuaXNDb252ZXJ0ZXJUb05leHQoYXJiKSkge1xuICAgICAgICBpZiAoISgnY29udGV4dHVhbFNocmluaycgaW4gYXJiLmFyYikgfHxcbiAgICAgICAgICAgICEoJ2NvbnRleHR1YWxTaHJpbmthYmxlRm9yJyBpbiBhcmIuYXJiKSB8fFxuICAgICAgICAgICAgISgnc2hydW5rT25jZUNvbnRleHQnIGluIGFyYi5hcmIpIHx8XG4gICAgICAgICAgICAhKCdzaHJpbmsnIGluIGFyYi5hcmIpIHx8XG4gICAgICAgICAgICAhKCdzaHJpbmthYmxlRm9yJyBpbiBhcmIuYXJiKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDb252ZXJzaW9uIHJlamVjdGVkOiBVbmRlcmx5aW5nIGFyYml0cmFyeSBpcyBub3QgY29tcGF0aWJsZSB3aXRoIEFyYml0cmFyeVdpdGhDb250ZXh0dWFsU2hyaW5rJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFyYi5hcmI7XG4gICAgfVxuICAgIE5leHRBcmJpdHJhcnlfMS5hc3NlcnRJc05leHRBcmJpdHJhcnkoYXJiKTtcbiAgICByZXR1cm4gbmV3IENvbnZlcnRlckZyb21OZXh0XzEuQ29udmVydGVyRnJvbU5leHQoYXJiLCBsZWdhY3lTaHJ1bmtPbmNlQ29udGV4dCk7XG59XG5leHBvcnRzLmNvbnZlcnRGcm9tTmV4dFdpdGhTaHJ1bmtPbmNlID0gY29udmVydEZyb21OZXh0V2l0aFNocnVua09uY2U7XG5mdW5jdGlvbiBjb252ZXJ0VG9OZXh0KGFyYikge1xuICAgIGlmIChDb252ZXJ0ZXJGcm9tTmV4dF8xLkNvbnZlcnRlckZyb21OZXh0LmlzQ29udmVydGVyRnJvbU5leHQoYXJiKSkge1xuICAgICAgICByZXR1cm4gYXJiLmFyYjtcbiAgICB9XG4gICAgQXJiaXRyYXJ5XzEuYXNzZXJ0SXNBcmJpdHJhcnkoYXJiKTtcbiAgICByZXR1cm4gbmV3IENvbnZlcnRlclRvTmV4dF8xLkNvbnZlcnRlclRvTmV4dChhcmIpO1xufVxuZXhwb3J0cy5jb252ZXJ0VG9OZXh0ID0gY29udmVydFRvTmV4dDtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5hc3NlcnRJc05leHRBcmJpdHJhcnkgPSBleHBvcnRzLk5leHRBcmJpdHJhcnkgPSB2b2lkIDA7XG5jb25zdCBTdHJlYW1fMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi9zdHJlYW0vU3RyZWFtXCIpO1xuY29uc3Qgc3ltYm9sc18xID0gcmVxdWlyZShcIi4uLy4uL3N5bWJvbHNcIik7XG5jb25zdCBOZXh0VmFsdWVfMSA9IHJlcXVpcmUoXCIuL05leHRWYWx1ZVwiKTtcbmNsYXNzIE5leHRBcmJpdHJhcnkge1xuICAgIGZpbHRlcihyZWZpbmVtZW50KSB7XG4gICAgICAgIHJldHVybiBuZXcgRmlsdGVyQXJiaXRyYXJ5KHRoaXMsIHJlZmluZW1lbnQpO1xuICAgIH1cbiAgICBtYXAobWFwcGVyLCB1bm1hcHBlcikge1xuICAgICAgICByZXR1cm4gbmV3IE1hcEFyYml0cmFyeSh0aGlzLCBtYXBwZXIsIHVubWFwcGVyKTtcbiAgICB9XG4gICAgY2hhaW4oY2hhaW5lcikge1xuICAgICAgICByZXR1cm4gbmV3IENoYWluQXJiaXRyYXJ5KHRoaXMsIGNoYWluZXIpO1xuICAgIH1cbiAgICBub1NocmluaygpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBOb1Nocmlua0FyYml0cmFyeSh0aGlzKTtcbiAgICB9XG4gICAgbm9CaWFzKCkge1xuICAgICAgICByZXR1cm4gbmV3IE5vQmlhc0FyYml0cmFyeSh0aGlzKTtcbiAgICB9XG59XG5leHBvcnRzLk5leHRBcmJpdHJhcnkgPSBOZXh0QXJiaXRyYXJ5O1xuY2xhc3MgQ2hhaW5BcmJpdHJhcnkgZXh0ZW5kcyBOZXh0QXJiaXRyYXJ5IHtcbiAgICBjb25zdHJ1Y3RvcihhcmIsIGNoYWluZXIpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5hcmIgPSBhcmI7XG4gICAgICAgIHRoaXMuY2hhaW5lciA9IGNoYWluZXI7XG4gICAgfVxuICAgIGdlbmVyYXRlKG1ybmcsIGJpYXNGYWN0b3IpIHtcbiAgICAgICAgY29uc3QgY2xvbmVkTXJuZyA9IG1ybmcuY2xvbmUoKTtcbiAgICAgICAgY29uc3Qgc3JjID0gdGhpcy5hcmIuZ2VuZXJhdGUobXJuZywgYmlhc0ZhY3Rvcik7XG4gICAgICAgIHJldHVybiB0aGlzLnZhbHVlQ2hhaW5lcihzcmMsIG1ybmcsIGNsb25lZE1ybmcsIGJpYXNGYWN0b3IpO1xuICAgIH1cbiAgICBjYW5TaHJpbmtXaXRob3V0Q29udGV4dCh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHNocmluayh2YWx1ZSwgY29udGV4dCkge1xuICAgICAgICBpZiAodGhpcy5pc1NhZmVDb250ZXh0KGNvbnRleHQpKSB7XG4gICAgICAgICAgICByZXR1cm4gKCFjb250ZXh0LnN0b3BwZWRGb3JPcmlnaW5hbFxuICAgICAgICAgICAgICAgID8gdGhpcy5hcmJcbiAgICAgICAgICAgICAgICAgICAgLnNocmluayhjb250ZXh0Lm9yaWdpbmFsVmFsdWUsIGNvbnRleHQub3JpZ2luYWxDb250ZXh0KVxuICAgICAgICAgICAgICAgICAgICAubWFwKCh2KSA9PiB0aGlzLnZhbHVlQ2hhaW5lcih2LCBjb250ZXh0LmNsb25lZE1ybmcuY2xvbmUoKSwgY29udGV4dC5jbG9uZWRNcm5nLCBjb250ZXh0Lm9yaWdpbmFsQmlhcykpXG4gICAgICAgICAgICAgICAgOiBTdHJlYW1fMS5TdHJlYW0ubmlsKCkpLmpvaW4oY29udGV4dC5jaGFpbmVkQXJiaXRyYXJ5LnNocmluayh2YWx1ZSwgY29udGV4dC5jaGFpbmVkQ29udGV4dCkubWFwKChkc3QpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBuZXdDb250ZXh0ID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBjb250ZXh0KSwgeyBjaGFpbmVkQ29udGV4dDogZHN0LmNvbnRleHQsIHN0b3BwZWRGb3JPcmlnaW5hbDogdHJ1ZSB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IE5leHRWYWx1ZV8xLk5leHRWYWx1ZShkc3QudmFsdWVfLCBuZXdDb250ZXh0KTtcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gU3RyZWFtXzEuU3RyZWFtLm5pbCgpO1xuICAgIH1cbiAgICB2YWx1ZUNoYWluZXIodiwgZ2VuZXJhdGVNcm5nLCBjbG9uZWRNcm5nLCBiaWFzRmFjdG9yKSB7XG4gICAgICAgIGNvbnN0IGNoYWluZWRBcmJpdHJhcnkgPSB0aGlzLmNoYWluZXIodi52YWx1ZV8pO1xuICAgICAgICBjb25zdCBkc3QgPSBjaGFpbmVkQXJiaXRyYXJ5LmdlbmVyYXRlKGdlbmVyYXRlTXJuZywgYmlhc0ZhY3Rvcik7XG4gICAgICAgIGNvbnN0IGNvbnRleHQgPSB7XG4gICAgICAgICAgICBvcmlnaW5hbEJpYXM6IGJpYXNGYWN0b3IsXG4gICAgICAgICAgICBvcmlnaW5hbFZhbHVlOiB2LnZhbHVlXyxcbiAgICAgICAgICAgIG9yaWdpbmFsQ29udGV4dDogdi5jb250ZXh0LFxuICAgICAgICAgICAgc3RvcHBlZEZvck9yaWdpbmFsOiBmYWxzZSxcbiAgICAgICAgICAgIGNoYWluZWRBcmJpdHJhcnksXG4gICAgICAgICAgICBjaGFpbmVkQ29udGV4dDogZHN0LmNvbnRleHQsXG4gICAgICAgICAgICBjbG9uZWRNcm5nLFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gbmV3IE5leHRWYWx1ZV8xLk5leHRWYWx1ZShkc3QudmFsdWVfLCBjb250ZXh0KTtcbiAgICB9XG4gICAgaXNTYWZlQ29udGV4dChjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiAoY29udGV4dCAhPSBudWxsICYmXG4gICAgICAgICAgICB0eXBlb2YgY29udGV4dCA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgICAgICdvcmlnaW5hbEJpYXMnIGluIGNvbnRleHQgJiZcbiAgICAgICAgICAgICdvcmlnaW5hbFZhbHVlJyBpbiBjb250ZXh0ICYmXG4gICAgICAgICAgICAnb3JpZ2luYWxDb250ZXh0JyBpbiBjb250ZXh0ICYmXG4gICAgICAgICAgICAnc3RvcHBlZEZvck9yaWdpbmFsJyBpbiBjb250ZXh0ICYmXG4gICAgICAgICAgICAnY2hhaW5lZEFyYml0cmFyeScgaW4gY29udGV4dCAmJlxuICAgICAgICAgICAgJ2NoYWluZWRDb250ZXh0JyBpbiBjb250ZXh0ICYmXG4gICAgICAgICAgICAnY2xvbmVkTXJuZycgaW4gY29udGV4dCk7XG4gICAgfVxufVxuY2xhc3MgTWFwQXJiaXRyYXJ5IGV4dGVuZHMgTmV4dEFyYml0cmFyeSB7XG4gICAgY29uc3RydWN0b3IoYXJiLCBtYXBwZXIsIHVubWFwcGVyKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuYXJiID0gYXJiO1xuICAgICAgICB0aGlzLm1hcHBlciA9IG1hcHBlcjtcbiAgICAgICAgdGhpcy51bm1hcHBlciA9IHVubWFwcGVyO1xuICAgICAgICB0aGlzLmJpbmRWYWx1ZU1hcHBlciA9IHRoaXMudmFsdWVNYXBwZXIuYmluZCh0aGlzKTtcbiAgICB9XG4gICAgZ2VuZXJhdGUobXJuZywgYmlhc0ZhY3Rvcikge1xuICAgICAgICBjb25zdCBnID0gdGhpcy5hcmIuZ2VuZXJhdGUobXJuZywgYmlhc0ZhY3Rvcik7XG4gICAgICAgIHJldHVybiB0aGlzLnZhbHVlTWFwcGVyKGcpO1xuICAgIH1cbiAgICBjYW5TaHJpbmtXaXRob3V0Q29udGV4dCh2YWx1ZSkge1xuICAgICAgICBpZiAodGhpcy51bm1hcHBlciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHVubWFwcGVkID0gdGhpcy51bm1hcHBlcih2YWx1ZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuYXJiLmNhblNocmlua1dpdGhvdXRDb250ZXh0KHVubWFwcGVkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChfZXJyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgc2hyaW5rKHZhbHVlLCBjb250ZXh0KSB7XG4gICAgICAgIGlmICh0aGlzLmlzU2FmZUNvbnRleHQoY29udGV4dCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmFyYi5zaHJpbmsoY29udGV4dC5vcmlnaW5hbFZhbHVlLCBjb250ZXh0Lm9yaWdpbmFsQ29udGV4dCkubWFwKHRoaXMuYmluZFZhbHVlTWFwcGVyKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy51bm1hcHBlciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb25zdCB1bm1hcHBlZCA9IHRoaXMudW5tYXBwZXIodmFsdWUpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYXJiLnNocmluayh1bm1hcHBlZCwgdW5kZWZpbmVkKS5tYXAodGhpcy5iaW5kVmFsdWVNYXBwZXIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBTdHJlYW1fMS5TdHJlYW0ubmlsKCk7XG4gICAgfVxuICAgIG1hcHBlcldpdGhDbG9uZUlmTmVlZGVkKHYpIHtcbiAgICAgICAgY29uc3Qgc291cmNlVmFsdWUgPSB2LnZhbHVlO1xuICAgICAgICBjb25zdCBtYXBwZWRWYWx1ZSA9IHRoaXMubWFwcGVyKHNvdXJjZVZhbHVlKTtcbiAgICAgICAgaWYgKHYuaGFzVG9CZUNsb25lZCAmJlxuICAgICAgICAgICAgKCh0eXBlb2YgbWFwcGVkVmFsdWUgPT09ICdvYmplY3QnICYmIG1hcHBlZFZhbHVlICE9PSBudWxsKSB8fCB0eXBlb2YgbWFwcGVkVmFsdWUgPT09ICdmdW5jdGlvbicpICYmXG4gICAgICAgICAgICBPYmplY3QuaXNFeHRlbnNpYmxlKG1hcHBlZFZhbHVlKSkge1xuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG1hcHBlZFZhbHVlLCBzeW1ib2xzXzEuY2xvbmVNZXRob2QsIHsgZ2V0OiAoKSA9PiAoKSA9PiB0aGlzLm1hcHBlcldpdGhDbG9uZUlmTmVlZGVkKHYpWzBdIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbbWFwcGVkVmFsdWUsIHNvdXJjZVZhbHVlXTtcbiAgICB9XG4gICAgdmFsdWVNYXBwZXIodikge1xuICAgICAgICBjb25zdCBbbWFwcGVkVmFsdWUsIHNvdXJjZVZhbHVlXSA9IHRoaXMubWFwcGVyV2l0aENsb25lSWZOZWVkZWQodik7XG4gICAgICAgIGNvbnN0IGNvbnRleHQgPSB7IG9yaWdpbmFsVmFsdWU6IHNvdXJjZVZhbHVlLCBvcmlnaW5hbENvbnRleHQ6IHYuY29udGV4dCB9O1xuICAgICAgICByZXR1cm4gbmV3IE5leHRWYWx1ZV8xLk5leHRWYWx1ZShtYXBwZWRWYWx1ZSwgY29udGV4dCk7XG4gICAgfVxuICAgIGlzU2FmZUNvbnRleHQoY29udGV4dCkge1xuICAgICAgICByZXR1cm4gKGNvbnRleHQgIT0gbnVsbCAmJlxuICAgICAgICAgICAgdHlwZW9mIGNvbnRleHQgPT09ICdvYmplY3QnICYmXG4gICAgICAgICAgICAnb3JpZ2luYWxWYWx1ZScgaW4gY29udGV4dCAmJlxuICAgICAgICAgICAgJ29yaWdpbmFsQ29udGV4dCcgaW4gY29udGV4dCk7XG4gICAgfVxufVxuY2xhc3MgRmlsdGVyQXJiaXRyYXJ5IGV4dGVuZHMgTmV4dEFyYml0cmFyeSB7XG4gICAgY29uc3RydWN0b3IoYXJiLCByZWZpbmVtZW50KSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuYXJiID0gYXJiO1xuICAgICAgICB0aGlzLnJlZmluZW1lbnQgPSByZWZpbmVtZW50O1xuICAgICAgICB0aGlzLmJpbmRSZWZpbmVtZW50T25WYWx1ZSA9IHRoaXMucmVmaW5lbWVudE9uVmFsdWUuYmluZCh0aGlzKTtcbiAgICB9XG4gICAgZ2VuZXJhdGUobXJuZywgYmlhc0ZhY3Rvcikge1xuICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgY29uc3QgZyA9IHRoaXMuYXJiLmdlbmVyYXRlKG1ybmcsIGJpYXNGYWN0b3IpO1xuICAgICAgICAgICAgaWYgKHRoaXMucmVmaW5lbWVudE9uVmFsdWUoZykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBjYW5TaHJpbmtXaXRob3V0Q29udGV4dCh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5hcmIuY2FuU2hyaW5rV2l0aG91dENvbnRleHQodmFsdWUpICYmIHRoaXMucmVmaW5lbWVudCh2YWx1ZSk7XG4gICAgfVxuICAgIHNocmluayh2YWx1ZSwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gdGhpcy5hcmIuc2hyaW5rKHZhbHVlLCBjb250ZXh0KS5maWx0ZXIodGhpcy5iaW5kUmVmaW5lbWVudE9uVmFsdWUpO1xuICAgIH1cbiAgICByZWZpbmVtZW50T25WYWx1ZSh2KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlZmluZW1lbnQodi52YWx1ZSk7XG4gICAgfVxufVxuY2xhc3MgTm9TaHJpbmtBcmJpdHJhcnkgZXh0ZW5kcyBOZXh0QXJiaXRyYXJ5IHtcbiAgICBjb25zdHJ1Y3RvcihhcmIpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5hcmIgPSBhcmI7XG4gICAgfVxuICAgIGdlbmVyYXRlKG1ybmcsIGJpYXNGYWN0b3IpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXJiLmdlbmVyYXRlKG1ybmcsIGJpYXNGYWN0b3IpO1xuICAgIH1cbiAgICBjYW5TaHJpbmtXaXRob3V0Q29udGV4dCh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5hcmIuY2FuU2hyaW5rV2l0aG91dENvbnRleHQodmFsdWUpO1xuICAgIH1cbiAgICBzaHJpbmsoX3ZhbHVlLCBfY29udGV4dCkge1xuICAgICAgICByZXR1cm4gU3RyZWFtXzEuU3RyZWFtLm5pbCgpO1xuICAgIH1cbiAgICBub1NocmluaygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxufVxuY2xhc3MgTm9CaWFzQXJiaXRyYXJ5IGV4dGVuZHMgTmV4dEFyYml0cmFyeSB7XG4gICAgY29uc3RydWN0b3IoYXJiKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuYXJiID0gYXJiO1xuICAgIH1cbiAgICBnZW5lcmF0ZShtcm5nLCBfYmlhc0ZhY3Rvcikge1xuICAgICAgICByZXR1cm4gdGhpcy5hcmIuZ2VuZXJhdGUobXJuZywgdW5kZWZpbmVkKTtcbiAgICB9XG4gICAgY2FuU2hyaW5rV2l0aG91dENvbnRleHQodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXJiLmNhblNocmlua1dpdGhvdXRDb250ZXh0KHZhbHVlKTtcbiAgICB9XG4gICAgc2hyaW5rKHZhbHVlLCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFyYi5zaHJpbmsodmFsdWUsIGNvbnRleHQpO1xuICAgIH1cbiAgICBub0JpYXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGFzc2VydElzTmV4dEFyYml0cmFyeShpbnN0YW5jZSkge1xuICAgIGlmICh0eXBlb2YgaW5zdGFuY2UgIT09ICdvYmplY3QnIHx8XG4gICAgICAgIGluc3RhbmNlID09PSBudWxsIHx8XG4gICAgICAgICEoJ2dlbmVyYXRlJyBpbiBpbnN0YW5jZSkgfHxcbiAgICAgICAgISgnc2hyaW5rJyBpbiBpbnN0YW5jZSkgfHxcbiAgICAgICAgJ3Nocmlua2FibGVGb3InIGluIGluc3RhbmNlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVW5leHBlY3RlZCB2YWx1ZSByZWNlaXZlZDogbm90IGFuIGluc3RhbmNlIG9mIE5leHRBcmJpdHJhcnknKTtcbiAgICB9XG59XG5leHBvcnRzLmFzc2VydElzTmV4dEFyYml0cmFyeSA9IGFzc2VydElzTmV4dEFyYml0cmFyeTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5OZXh0VmFsdWUgPSB2b2lkIDA7XG5jb25zdCBzeW1ib2xzXzEgPSByZXF1aXJlKFwiLi4vLi4vc3ltYm9sc1wiKTtcbmNsYXNzIE5leHRWYWx1ZSB7XG4gICAgY29uc3RydWN0b3IodmFsdWVfLCBjb250ZXh0LCBjdXN0b21HZXRWYWx1ZSA9IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLnZhbHVlXyA9IHZhbHVlXztcbiAgICAgICAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgICAgICAgdGhpcy5oYXNUb0JlQ2xvbmVkID0gY3VzdG9tR2V0VmFsdWUgIT09IHVuZGVmaW5lZCB8fCBzeW1ib2xzXzEuaGFzQ2xvbmVNZXRob2QodmFsdWVfKTtcbiAgICAgICAgdGhpcy5yZWFkT25jZSA9IGZhbHNlO1xuICAgICAgICBpZiAodGhpcy5oYXNUb0JlQ2xvbmVkKSB7XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ3ZhbHVlJywgeyBnZXQ6IGN1c3RvbUdldFZhbHVlICE9PSB1bmRlZmluZWQgPyBjdXN0b21HZXRWYWx1ZSA6IHRoaXMuZ2V0VmFsdWUgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWVfO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldFZhbHVlKCkge1xuICAgICAgICBpZiAodGhpcy5oYXNUb0JlQ2xvbmVkKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMucmVhZE9uY2UpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlYWRPbmNlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy52YWx1ZV87XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy52YWx1ZV9bc3ltYm9sc18xLmNsb25lTWV0aG9kXSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnZhbHVlXztcbiAgICB9XG59XG5leHBvcnRzLk5leHRWYWx1ZSA9IE5leHRWYWx1ZTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5TaHJpbmthYmxlID0gdm9pZCAwO1xuY29uc3QgU3RyZWFtXzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vc3RyZWFtL1N0cmVhbVwiKTtcbmNvbnN0IHN5bWJvbHNfMSA9IHJlcXVpcmUoXCIuLi8uLi9zeW1ib2xzXCIpO1xuY2xhc3MgU2hyaW5rYWJsZSB7XG4gICAgY29uc3RydWN0b3IodmFsdWVfLCBzaHJpbmsgPSAoKSA9PiBTdHJlYW1fMS5TdHJlYW0ubmlsKCksIGN1c3RvbUdldFZhbHVlID0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRoaXMudmFsdWVfID0gdmFsdWVfO1xuICAgICAgICB0aGlzLnNocmluayA9IHNocmluaztcbiAgICAgICAgdGhpcy5oYXNUb0JlQ2xvbmVkID0gY3VzdG9tR2V0VmFsdWUgIT09IHVuZGVmaW5lZCB8fCBzeW1ib2xzXzEuaGFzQ2xvbmVNZXRob2QodmFsdWVfKTtcbiAgICAgICAgdGhpcy5yZWFkT25jZSA9IGZhbHNlO1xuICAgICAgICBpZiAodGhpcy5oYXNUb0JlQ2xvbmVkKSB7XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ3ZhbHVlJywgeyBnZXQ6IGN1c3RvbUdldFZhbHVlICE9PSB1bmRlZmluZWQgPyBjdXN0b21HZXRWYWx1ZSA6IHRoaXMuZ2V0VmFsdWUgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWVfO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldFZhbHVlKCkge1xuICAgICAgICBpZiAoIXRoaXMucmVhZE9uY2UpIHtcbiAgICAgICAgICAgIHRoaXMucmVhZE9uY2UgPSB0cnVlO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudmFsdWVfO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnZhbHVlX1tzeW1ib2xzXzEuY2xvbmVNZXRob2RdKCk7XG4gICAgfVxuICAgIGFwcGx5TWFwcGVyKG1hcHBlcikge1xuICAgICAgICBpZiAodGhpcy5oYXNUb0JlQ2xvbmVkKSB7XG4gICAgICAgICAgICBjb25zdCBvdXQgPSBtYXBwZXIodGhpcy52YWx1ZSk7XG4gICAgICAgICAgICBpZiAob3V0IGluc3RhbmNlb2YgT2JqZWN0KSB7XG4gICAgICAgICAgICAgICAgb3V0W3N5bWJvbHNfMS5jbG9uZU1ldGhvZF0gPSAoKSA9PiB0aGlzLmFwcGx5TWFwcGVyKG1hcHBlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gb3V0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtYXBwZXIodGhpcy52YWx1ZSk7XG4gICAgfVxuICAgIG1hcChtYXBwZXIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTaHJpbmthYmxlKHRoaXMuYXBwbHlNYXBwZXIobWFwcGVyKSwgKCkgPT4gdGhpcy5zaHJpbmsoKS5tYXAoKHYpID0+IHYubWFwKG1hcHBlcikpKTtcbiAgICB9XG4gICAgZmlsdGVyKHJlZmluZW1lbnQpIHtcbiAgICAgICAgY29uc3QgcmVmaW5lbWVudE9uU2hyaW5rYWJsZSA9IChzKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gcmVmaW5lbWVudChzLnZhbHVlXyk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBuZXcgU2hyaW5rYWJsZSh0aGlzLnZhbHVlLCAoKSA9PiB0aGlzLnNocmluaygpXG4gICAgICAgICAgICAuZmlsdGVyKHJlZmluZW1lbnRPblNocmlua2FibGUpXG4gICAgICAgICAgICAubWFwKCh2KSA9PiB2LmZpbHRlcihyZWZpbmVtZW50KSkpO1xuICAgIH1cbn1cbmV4cG9ydHMuU2hyaW5rYWJsZSA9IFNocmlua2FibGU7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMubG9nTGlrZTY0ID0gZXhwb3J0cy5oYWx2ZTY0ID0gZXhwb3J0cy5hZGQ2NCA9IGV4cG9ydHMubmVnYXRpdmU2NCA9IGV4cG9ydHMuc3Vic3RyYWN0NjQgPSBleHBvcnRzLmNsb25lNjQgPSBleHBvcnRzLmlzU3RyaWN0bHlTbWFsbGVyNjQgPSBleHBvcnRzLmlzRXF1YWw2NCA9IGV4cG9ydHMuaXNTdHJpY3RseVBvc2l0aXZlNjQgPSBleHBvcnRzLmlzU3RyaWN0bHlOZWdhdGl2ZTY0ID0gZXhwb3J0cy5pc1plcm82NCA9IGV4cG9ydHMuVW5pdDY0ID0gZXhwb3J0cy5aZXJvNjQgPSB2b2lkIDA7XG5leHBvcnRzLlplcm82NCA9IHsgc2lnbjogMSwgZGF0YTogWzAsIDBdIH07XG5leHBvcnRzLlVuaXQ2NCA9IHsgc2lnbjogMSwgZGF0YTogWzAsIDFdIH07XG5mdW5jdGlvbiBpc1plcm82NChhKSB7XG4gICAgcmV0dXJuIGEuZGF0YVswXSA9PT0gMCAmJiBhLmRhdGFbMV0gPT09IDA7XG59XG5leHBvcnRzLmlzWmVybzY0ID0gaXNaZXJvNjQ7XG5mdW5jdGlvbiBpc1N0cmljdGx5TmVnYXRpdmU2NChhKSB7XG4gICAgcmV0dXJuIGEuc2lnbiA9PT0gLTEgJiYgIWlzWmVybzY0KGEpO1xufVxuZXhwb3J0cy5pc1N0cmljdGx5TmVnYXRpdmU2NCA9IGlzU3RyaWN0bHlOZWdhdGl2ZTY0O1xuZnVuY3Rpb24gaXNTdHJpY3RseVBvc2l0aXZlNjQoYSkge1xuICAgIHJldHVybiBhLnNpZ24gPT09IDEgJiYgIWlzWmVybzY0KGEpO1xufVxuZXhwb3J0cy5pc1N0cmljdGx5UG9zaXRpdmU2NCA9IGlzU3RyaWN0bHlQb3NpdGl2ZTY0O1xuZnVuY3Rpb24gaXNFcXVhbDY0KGEsIGIpIHtcbiAgICBpZiAoYS5kYXRhWzBdID09PSBiLmRhdGFbMF0gJiYgYS5kYXRhWzFdID09PSBiLmRhdGFbMV0pIHtcbiAgICAgICAgcmV0dXJuIGEuc2lnbiA9PT0gYi5zaWduIHx8IChhLmRhdGFbMF0gPT09IDAgJiYgYS5kYXRhWzFdID09PSAwKTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZXhwb3J0cy5pc0VxdWFsNjQgPSBpc0VxdWFsNjQ7XG5mdW5jdGlvbiBpc1N0cmljdGx5U21hbGxlcjY0SW50ZXJuYWwoYSwgYikge1xuICAgIHJldHVybiBhWzBdIDwgYlswXSB8fCAoYVswXSA9PT0gYlswXSAmJiBhWzFdIDwgYlsxXSk7XG59XG5mdW5jdGlvbiBpc1N0cmljdGx5U21hbGxlcjY0KGEsIGIpIHtcbiAgICBpZiAoYS5zaWduID09PSBiLnNpZ24pIHtcbiAgICAgICAgcmV0dXJuIGEuc2lnbiA9PT0gMVxuICAgICAgICAgICAgPyBpc1N0cmljdGx5U21hbGxlcjY0SW50ZXJuYWwoYS5kYXRhLCBiLmRhdGEpXG4gICAgICAgICAgICA6IGlzU3RyaWN0bHlTbWFsbGVyNjRJbnRlcm5hbChiLmRhdGEsIGEuZGF0YSk7XG4gICAgfVxuICAgIHJldHVybiBhLnNpZ24gPT09IC0xICYmICghaXNaZXJvNjQoYSkgfHwgIWlzWmVybzY0KGIpKTtcbn1cbmV4cG9ydHMuaXNTdHJpY3RseVNtYWxsZXI2NCA9IGlzU3RyaWN0bHlTbWFsbGVyNjQ7XG5mdW5jdGlvbiBjbG9uZTY0KGEpIHtcbiAgICByZXR1cm4geyBzaWduOiBhLnNpZ24sIGRhdGE6IFthLmRhdGFbMF0sIGEuZGF0YVsxXV0gfTtcbn1cbmV4cG9ydHMuY2xvbmU2NCA9IGNsb25lNjQ7XG5mdW5jdGlvbiBzdWJzdHJhY3Q2NERhdGFJbnRlcm5hbChhLCBiKSB7XG4gICAgbGV0IHJlbWluZGVyTG93ID0gMDtcbiAgICBsZXQgbG93ID0gYVsxXSAtIGJbMV07XG4gICAgaWYgKGxvdyA8IDApIHtcbiAgICAgICAgcmVtaW5kZXJMb3cgPSAxO1xuICAgICAgICBsb3cgPSBsb3cgPj4+IDA7XG4gICAgfVxuICAgIHJldHVybiBbYVswXSAtIGJbMF0gLSByZW1pbmRlckxvdywgbG93XTtcbn1cbmZ1bmN0aW9uIHN1YnN0cmFjdDY0SW50ZXJuYWwoYSwgYikge1xuICAgIGlmIChhLnNpZ24gPT09IDEgJiYgYi5zaWduID09PSAtMSkge1xuICAgICAgICBjb25zdCBsb3cgPSBhLmRhdGFbMV0gKyBiLmRhdGFbMV07XG4gICAgICAgIGNvbnN0IGhpZ2ggPSBhLmRhdGFbMF0gKyBiLmRhdGFbMF0gKyAobG93ID4gMHhmZmZmZmZmZiA/IDEgOiAwKTtcbiAgICAgICAgcmV0dXJuIHsgc2lnbjogMSwgZGF0YTogW2hpZ2ggPj4+IDAsIGxvdyA+Pj4gMF0gfTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgc2lnbjogMSxcbiAgICAgICAgZGF0YTogYS5zaWduID09PSAxID8gc3Vic3RyYWN0NjREYXRhSW50ZXJuYWwoYS5kYXRhLCBiLmRhdGEpIDogc3Vic3RyYWN0NjREYXRhSW50ZXJuYWwoYi5kYXRhLCBhLmRhdGEpLFxuICAgIH07XG59XG5mdW5jdGlvbiBzdWJzdHJhY3Q2NChhcnJheUludEEsIGFycmF5SW50Qikge1xuICAgIGlmIChpc1N0cmljdGx5U21hbGxlcjY0KGFycmF5SW50QSwgYXJyYXlJbnRCKSkge1xuICAgICAgICBjb25zdCBvdXQgPSBzdWJzdHJhY3Q2NEludGVybmFsKGFycmF5SW50QiwgYXJyYXlJbnRBKTtcbiAgICAgICAgb3V0LnNpZ24gPSAtMTtcbiAgICAgICAgcmV0dXJuIG91dDtcbiAgICB9XG4gICAgcmV0dXJuIHN1YnN0cmFjdDY0SW50ZXJuYWwoYXJyYXlJbnRBLCBhcnJheUludEIpO1xufVxuZXhwb3J0cy5zdWJzdHJhY3Q2NCA9IHN1YnN0cmFjdDY0O1xuZnVuY3Rpb24gbmVnYXRpdmU2NChhcnJheUludEEpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBzaWduOiAtYXJyYXlJbnRBLnNpZ24sXG4gICAgICAgIGRhdGE6IFthcnJheUludEEuZGF0YVswXSwgYXJyYXlJbnRBLmRhdGFbMV1dLFxuICAgIH07XG59XG5leHBvcnRzLm5lZ2F0aXZlNjQgPSBuZWdhdGl2ZTY0O1xuZnVuY3Rpb24gYWRkNjQoYXJyYXlJbnRBLCBhcnJheUludEIpIHtcbiAgICBpZiAoaXNaZXJvNjQoYXJyYXlJbnRCKSkge1xuICAgICAgICBpZiAoaXNaZXJvNjQoYXJyYXlJbnRBKSkge1xuICAgICAgICAgICAgcmV0dXJuIGNsb25lNjQoZXhwb3J0cy5aZXJvNjQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjbG9uZTY0KGFycmF5SW50QSk7XG4gICAgfVxuICAgIHJldHVybiBzdWJzdHJhY3Q2NChhcnJheUludEEsIG5lZ2F0aXZlNjQoYXJyYXlJbnRCKSk7XG59XG5leHBvcnRzLmFkZDY0ID0gYWRkNjQ7XG5mdW5jdGlvbiBoYWx2ZTY0KGEpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBzaWduOiBhLnNpZ24sXG4gICAgICAgIGRhdGE6IFtNYXRoLmZsb29yKGEuZGF0YVswXSAvIDIpLCAoYS5kYXRhWzBdICUgMiA9PT0gMSA/IDB4ODAwMDAwMDAgOiAwKSArIE1hdGguZmxvb3IoYS5kYXRhWzFdIC8gMildLFxuICAgIH07XG59XG5leHBvcnRzLmhhbHZlNjQgPSBoYWx2ZTY0O1xuZnVuY3Rpb24gbG9nTGlrZTY0KGEpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBzaWduOiBhLnNpZ24sXG4gICAgICAgIGRhdGE6IFswLCBNYXRoLmZsb29yKE1hdGgubG9nKGEuZGF0YVswXSAqIDB4MTAwMDAwMDAwICsgYS5kYXRhWzFdKSAvIE1hdGgubG9nKDIpKV0sXG4gICAgfTtcbn1cbmV4cG9ydHMubG9nTGlrZTY0ID0gbG9nTGlrZTY0O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmFycmF5SW50NjQgPSB2b2lkIDA7XG5jb25zdCBTdHJlYW1fMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi9zdHJlYW0vU3RyZWFtXCIpO1xuY29uc3QgQ29udmVydGVyc18xID0gcmVxdWlyZShcIi4uL2RlZmluaXRpb24vQ29udmVydGVyc1wiKTtcbmNvbnN0IE5leHRBcmJpdHJhcnlfMSA9IHJlcXVpcmUoXCIuLi9kZWZpbml0aW9uL05leHRBcmJpdHJhcnlcIik7XG5jb25zdCBOZXh0VmFsdWVfMSA9IHJlcXVpcmUoXCIuLi9kZWZpbml0aW9uL05leHRWYWx1ZVwiKTtcbmNvbnN0IEFycmF5SW50NjRfMSA9IHJlcXVpcmUoXCIuL0FycmF5SW50NjRcIik7XG5jbGFzcyBBcnJheUludDY0QXJiaXRyYXJ5IGV4dGVuZHMgTmV4dEFyYml0cmFyeV8xLk5leHRBcmJpdHJhcnkge1xuICAgIGNvbnN0cnVjdG9yKG1pbiwgbWF4KSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMubWluID0gbWluO1xuICAgICAgICB0aGlzLm1heCA9IG1heDtcbiAgICAgICAgdGhpcy5iaWFzZWRSYW5nZXMgPSBudWxsO1xuICAgIH1cbiAgICBnZW5lcmF0ZShtcm5nLCBiaWFzRmFjdG9yKSB7XG4gICAgICAgIGNvbnN0IHJhbmdlID0gdGhpcy5jb21wdXRlR2VuZXJhdGVSYW5nZShtcm5nLCBiaWFzRmFjdG9yKTtcbiAgICAgICAgY29uc3QgdW5jaGVja2VkVmFsdWUgPSBtcm5nLm5leHRBcnJheUludChyYW5nZS5taW4sIHJhbmdlLm1heCk7XG4gICAgICAgIGlmICh1bmNoZWNrZWRWYWx1ZS5kYXRhLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgdW5jaGVja2VkVmFsdWUuZGF0YS51bnNoaWZ0KDApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgTmV4dFZhbHVlXzEuTmV4dFZhbHVlKHVuY2hlY2tlZFZhbHVlLCB1bmRlZmluZWQpO1xuICAgIH1cbiAgICBjb21wdXRlR2VuZXJhdGVSYW5nZShtcm5nLCBiaWFzRmFjdG9yKSB7XG4gICAgICAgIGlmIChiaWFzRmFjdG9yID09PSB1bmRlZmluZWQgfHwgbXJuZy5uZXh0SW50KDEsIGJpYXNGYWN0b3IpICE9PSAxKSB7XG4gICAgICAgICAgICByZXR1cm4geyBtaW46IHRoaXMubWluLCBtYXg6IHRoaXMubWF4IH07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmFuZ2VzID0gdGhpcy5yZXRyaWV2ZUJpYXNlZFJhbmdlcygpO1xuICAgICAgICBpZiAocmFuZ2VzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgcmV0dXJuIHJhbmdlc1swXTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBpZCA9IG1ybmcubmV4dEludCgtMiAqIChyYW5nZXMubGVuZ3RoIC0gMSksIHJhbmdlcy5sZW5ndGggLSAyKTtcbiAgICAgICAgcmV0dXJuIGlkIDwgMCA/IHJhbmdlc1swXSA6IHJhbmdlc1tpZCArIDFdO1xuICAgIH1cbiAgICBjYW5TaHJpbmtXaXRob3V0Q29udGV4dCh2YWx1ZSkge1xuICAgICAgICBjb25zdCB1bnNhZmVWYWx1ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gKHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgICAgIHZhbHVlICE9PSBudWxsICYmXG4gICAgICAgICAgICAodW5zYWZlVmFsdWUuc2lnbiA9PT0gLTEgfHwgdW5zYWZlVmFsdWUuc2lnbiA9PT0gMSkgJiZcbiAgICAgICAgICAgIEFycmF5LmlzQXJyYXkodW5zYWZlVmFsdWUuZGF0YSkgJiZcbiAgICAgICAgICAgIHVuc2FmZVZhbHVlLmRhdGEubGVuZ3RoID09PSAyICYmXG4gICAgICAgICAgICAoKEFycmF5SW50NjRfMS5pc1N0cmljdGx5U21hbGxlcjY0KHRoaXMubWluLCB1bnNhZmVWYWx1ZSkgJiYgQXJyYXlJbnQ2NF8xLmlzU3RyaWN0bHlTbWFsbGVyNjQodW5zYWZlVmFsdWUsIHRoaXMubWF4KSkgfHxcbiAgICAgICAgICAgICAgICBBcnJheUludDY0XzEuaXNFcXVhbDY0KHRoaXMubWluLCB1bnNhZmVWYWx1ZSkgfHxcbiAgICAgICAgICAgICAgICBBcnJheUludDY0XzEuaXNFcXVhbDY0KHRoaXMubWF4LCB1bnNhZmVWYWx1ZSkpKTtcbiAgICB9XG4gICAgc2hyaW5rQXJyYXlJbnQ2NCh2YWx1ZSwgdGFyZ2V0LCB0cnlUYXJnZXRBc2FwKSB7XG4gICAgICAgIGNvbnN0IHJlYWxHYXAgPSBBcnJheUludDY0XzEuc3Vic3RyYWN0NjQodmFsdWUsIHRhcmdldCk7XG4gICAgICAgIGZ1bmN0aW9uKiBzaHJpbmtHZW4oKSB7XG4gICAgICAgICAgICBsZXQgcHJldmlvdXMgPSB0cnlUYXJnZXRBc2FwID8gdW5kZWZpbmVkIDogdGFyZ2V0O1xuICAgICAgICAgICAgY29uc3QgZ2FwID0gdHJ5VGFyZ2V0QXNhcCA/IHJlYWxHYXAgOiBBcnJheUludDY0XzEuaGFsdmU2NChyZWFsR2FwKTtcbiAgICAgICAgICAgIGZvciAobGV0IHRvcmVtb3ZlID0gZ2FwOyAhQXJyYXlJbnQ2NF8xLmlzWmVybzY0KHRvcmVtb3ZlKTsgdG9yZW1vdmUgPSBBcnJheUludDY0XzEuaGFsdmU2NCh0b3JlbW92ZSkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBuZXh0ID0gQXJyYXlJbnQ2NF8xLnN1YnN0cmFjdDY0KHZhbHVlLCB0b3JlbW92ZSk7XG4gICAgICAgICAgICAgICAgeWllbGQgbmV3IE5leHRWYWx1ZV8xLk5leHRWYWx1ZShuZXh0LCBwcmV2aW91cyk7XG4gICAgICAgICAgICAgICAgcHJldmlvdXMgPSBuZXh0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBTdHJlYW1fMS5zdHJlYW0oc2hyaW5rR2VuKCkpO1xuICAgIH1cbiAgICBzaHJpbmsoY3VycmVudCwgY29udGV4dCkge1xuICAgICAgICBpZiAoIUFycmF5SW50NjRBcmJpdHJhcnkuaXNWYWxpZENvbnRleHQoY3VycmVudCwgY29udGV4dCkpIHtcbiAgICAgICAgICAgIGNvbnN0IHRhcmdldCA9IHRoaXMuZGVmYXVsdFRhcmdldCgpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2hyaW5rQXJyYXlJbnQ2NChjdXJyZW50LCB0YXJnZXQsIHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmlzTGFzdENoYW5jZVRyeShjdXJyZW50LCBjb250ZXh0KSkge1xuICAgICAgICAgICAgcmV0dXJuIFN0cmVhbV8xLlN0cmVhbS5vZihuZXcgTmV4dFZhbHVlXzEuTmV4dFZhbHVlKGNvbnRleHQsIHVuZGVmaW5lZCkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnNocmlua0FycmF5SW50NjQoY3VycmVudCwgY29udGV4dCwgZmFsc2UpO1xuICAgIH1cbiAgICBkZWZhdWx0VGFyZ2V0KCkge1xuICAgICAgICBpZiAoIUFycmF5SW50NjRfMS5pc1N0cmljdGx5UG9zaXRpdmU2NCh0aGlzLm1pbikgJiYgIUFycmF5SW50NjRfMS5pc1N0cmljdGx5TmVnYXRpdmU2NCh0aGlzLm1heCkpIHtcbiAgICAgICAgICAgIHJldHVybiBBcnJheUludDY0XzEuWmVybzY0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBBcnJheUludDY0XzEuaXNTdHJpY3RseU5lZ2F0aXZlNjQodGhpcy5taW4pID8gdGhpcy5tYXggOiB0aGlzLm1pbjtcbiAgICB9XG4gICAgaXNMYXN0Q2hhbmNlVHJ5KGN1cnJlbnQsIGNvbnRleHQpIHtcbiAgICAgICAgaWYgKEFycmF5SW50NjRfMS5pc1plcm82NChjdXJyZW50KSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjdXJyZW50LnNpZ24gPT09IDEpIHtcbiAgICAgICAgICAgIHJldHVybiBBcnJheUludDY0XzEuaXNFcXVhbDY0KGN1cnJlbnQsIEFycmF5SW50NjRfMS5hZGQ2NChjb250ZXh0LCBBcnJheUludDY0XzEuVW5pdDY0KSkgJiYgQXJyYXlJbnQ2NF8xLmlzU3RyaWN0bHlQb3NpdGl2ZTY0KEFycmF5SW50NjRfMS5zdWJzdHJhY3Q2NChjdXJyZW50LCB0aGlzLm1pbikpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIEFycmF5SW50NjRfMS5pc0VxdWFsNjQoY3VycmVudCwgQXJyYXlJbnQ2NF8xLnN1YnN0cmFjdDY0KGNvbnRleHQsIEFycmF5SW50NjRfMS5Vbml0NjQpKSAmJiBBcnJheUludDY0XzEuaXNTdHJpY3RseU5lZ2F0aXZlNjQoQXJyYXlJbnQ2NF8xLnN1YnN0cmFjdDY0KGN1cnJlbnQsIHRoaXMubWF4KSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3RhdGljIGlzVmFsaWRDb250ZXh0KF9jdXJyZW50LCBjb250ZXh0KSB7XG4gICAgICAgIGlmIChjb250ZXh0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGNvbnRleHQgIT09ICdvYmplY3QnIHx8IGNvbnRleHQgPT09IG51bGwgfHwgISgnc2lnbicgaW4gY29udGV4dCkgfHwgISgnZGF0YScgaW4gY29udGV4dCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBjb250ZXh0IHR5cGUgcGFzc2VkIHRvIEFycmF5SW50NjRBcmJpdHJhcnkgKCMxKWApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXRyaWV2ZUJpYXNlZFJhbmdlcygpIHtcbiAgICAgICAgaWYgKHRoaXMuYmlhc2VkUmFuZ2VzICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmJpYXNlZFJhbmdlcztcbiAgICAgICAgfVxuICAgICAgICBpZiAoQXJyYXlJbnQ2NF8xLmlzRXF1YWw2NCh0aGlzLm1pbiwgdGhpcy5tYXgpKSB7XG4gICAgICAgICAgICB0aGlzLmJpYXNlZFJhbmdlcyA9IFt7IG1pbjogdGhpcy5taW4sIG1heDogdGhpcy5tYXggfV07XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5iaWFzZWRSYW5nZXM7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbWluU3RyaWN0bHlTbWFsbGVyWmVybyA9IEFycmF5SW50NjRfMS5pc1N0cmljdGx5TmVnYXRpdmU2NCh0aGlzLm1pbik7XG4gICAgICAgIGNvbnN0IG1heFN0cmljdGx5R3JlYXRlclplcm8gPSBBcnJheUludDY0XzEuaXNTdHJpY3RseVBvc2l0aXZlNjQodGhpcy5tYXgpO1xuICAgICAgICBpZiAobWluU3RyaWN0bHlTbWFsbGVyWmVybyAmJiBtYXhTdHJpY3RseUdyZWF0ZXJaZXJvKSB7XG4gICAgICAgICAgICBjb25zdCBsb2dNaW4gPSBBcnJheUludDY0XzEubG9nTGlrZTY0KHRoaXMubWluKTtcbiAgICAgICAgICAgIGNvbnN0IGxvZ01heCA9IEFycmF5SW50NjRfMS5sb2dMaWtlNjQodGhpcy5tYXgpO1xuICAgICAgICAgICAgdGhpcy5iaWFzZWRSYW5nZXMgPSBbXG4gICAgICAgICAgICAgICAgeyBtaW46IGxvZ01pbiwgbWF4OiBsb2dNYXggfSxcbiAgICAgICAgICAgICAgICB7IG1pbjogQXJyYXlJbnQ2NF8xLnN1YnN0cmFjdDY0KHRoaXMubWF4LCBsb2dNYXgpLCBtYXg6IHRoaXMubWF4IH0sXG4gICAgICAgICAgICAgICAgeyBtaW46IHRoaXMubWluLCBtYXg6IEFycmF5SW50NjRfMS5zdWJzdHJhY3Q2NCh0aGlzLm1pbiwgbG9nTWluKSB9LFxuICAgICAgICAgICAgXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGxvZ0dhcCA9IEFycmF5SW50NjRfMS5sb2dMaWtlNjQoQXJyYXlJbnQ2NF8xLnN1YnN0cmFjdDY0KHRoaXMubWF4LCB0aGlzLm1pbikpO1xuICAgICAgICAgICAgY29uc3QgYXJiQ2xvc2VUb01pbiA9IHsgbWluOiB0aGlzLm1pbiwgbWF4OiBBcnJheUludDY0XzEuYWRkNjQodGhpcy5taW4sIGxvZ0dhcCkgfTtcbiAgICAgICAgICAgIGNvbnN0IGFyYkNsb3NlVG9NYXggPSB7IG1pbjogQXJyYXlJbnQ2NF8xLnN1YnN0cmFjdDY0KHRoaXMubWF4LCBsb2dHYXApLCBtYXg6IHRoaXMubWF4IH07XG4gICAgICAgICAgICB0aGlzLmJpYXNlZFJhbmdlcyA9IG1pblN0cmljdGx5U21hbGxlclplcm9cbiAgICAgICAgICAgICAgICA/IFthcmJDbG9zZVRvTWF4LCBhcmJDbG9zZVRvTWluXVxuICAgICAgICAgICAgICAgIDogW2FyYkNsb3NlVG9NaW4sIGFyYkNsb3NlVG9NYXhdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmJpYXNlZFJhbmdlcztcbiAgICB9XG59XG5mdW5jdGlvbiBhcnJheUludDY0KG1pbiwgbWF4KSB7XG4gICAgY29uc3QgYXJiID0gbmV3IEFycmF5SW50NjRBcmJpdHJhcnkobWluLCBtYXgpO1xuICAgIHJldHVybiBDb252ZXJ0ZXJzXzEuY29udmVydEZyb21OZXh0V2l0aFNocnVua09uY2UoYXJiLCBhcmIuZGVmYXVsdFRhcmdldCgpKTtcbn1cbmV4cG9ydHMuYXJyYXlJbnQ2NCA9IGFycmF5SW50NjQ7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuYnVpbGRBbHBoYU51bWVyaWNQZXJjZW50QXJiID0gZXhwb3J0cy5idWlsZEFscGhhTnVtZXJpY0FyYiA9IGV4cG9ydHMuYnVpbGRMb3dlckFscGhhTnVtZXJpY0FyYiA9IGV4cG9ydHMuYnVpbGRMb3dlckFscGhhQXJiID0gdm9pZCAwO1xuY29uc3QgZnVsbFVuaWNvZGVfMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi9hcmJpdHJhcnkvZnVsbFVuaWNvZGVcIik7XG5jb25zdCBmcmVxdWVuY3lfMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi9hcmJpdHJhcnkvZnJlcXVlbmN5XCIpO1xuY29uc3QgbWFwVG9Db25zdGFudF8xID0gcmVxdWlyZShcIi4uLy4uLy4uL2FyYml0cmFyeS9tYXBUb0NvbnN0YW50XCIpO1xuY29uc3QgbG93ZXJDYXNlTWFwcGVyID0geyBudW06IDI2LCBidWlsZDogKHYpID0+IFN0cmluZy5mcm9tQ2hhckNvZGUodiArIDB4NjEpIH07XG5jb25zdCB1cHBlckNhc2VNYXBwZXIgPSB7IG51bTogMjYsIGJ1aWxkOiAodikgPT4gU3RyaW5nLmZyb21DaGFyQ29kZSh2ICsgMHg0MSkgfTtcbmNvbnN0IG51bWVyaWNNYXBwZXIgPSB7IG51bTogMTAsIGJ1aWxkOiAodikgPT4gU3RyaW5nLmZyb21DaGFyQ29kZSh2ICsgMHgzMCkgfTtcbmNvbnN0IHBlcmNlbnRDaGFyQXJiID0gZnVsbFVuaWNvZGVfMS5mdWxsVW5pY29kZSgpLm1hcCgoYykgPT4ge1xuICAgIGNvbnN0IGVuY29kZWQgPSBlbmNvZGVVUklDb21wb25lbnQoYyk7XG4gICAgcmV0dXJuIGMgIT09IGVuY29kZWQgPyBlbmNvZGVkIDogYCUke2MuY2hhckNvZGVBdCgwKS50b1N0cmluZygxNil9YDtcbn0pO1xuY29uc3QgYnVpbGRMb3dlckFscGhhQXJiID0gKG90aGVycykgPT4gbWFwVG9Db25zdGFudF8xLm1hcFRvQ29uc3RhbnQobG93ZXJDYXNlTWFwcGVyLCB7IG51bTogb3RoZXJzLmxlbmd0aCwgYnVpbGQ6ICh2KSA9PiBvdGhlcnNbdl0gfSk7XG5leHBvcnRzLmJ1aWxkTG93ZXJBbHBoYUFyYiA9IGJ1aWxkTG93ZXJBbHBoYUFyYjtcbmNvbnN0IGJ1aWxkTG93ZXJBbHBoYU51bWVyaWNBcmIgPSAob3RoZXJzKSA9PiBtYXBUb0NvbnN0YW50XzEubWFwVG9Db25zdGFudChsb3dlckNhc2VNYXBwZXIsIG51bWVyaWNNYXBwZXIsIHsgbnVtOiBvdGhlcnMubGVuZ3RoLCBidWlsZDogKHYpID0+IG90aGVyc1t2XSB9KTtcbmV4cG9ydHMuYnVpbGRMb3dlckFscGhhTnVtZXJpY0FyYiA9IGJ1aWxkTG93ZXJBbHBoYU51bWVyaWNBcmI7XG5jb25zdCBidWlsZEFscGhhTnVtZXJpY0FyYiA9IChvdGhlcnMpID0+IG1hcFRvQ29uc3RhbnRfMS5tYXBUb0NvbnN0YW50KGxvd2VyQ2FzZU1hcHBlciwgdXBwZXJDYXNlTWFwcGVyLCBudW1lcmljTWFwcGVyLCB7IG51bTogb3RoZXJzLmxlbmd0aCwgYnVpbGQ6ICh2KSA9PiBvdGhlcnNbdl0gfSk7XG5leHBvcnRzLmJ1aWxkQWxwaGFOdW1lcmljQXJiID0gYnVpbGRBbHBoYU51bWVyaWNBcmI7XG5jb25zdCBidWlsZEFscGhhTnVtZXJpY1BlcmNlbnRBcmIgPSAob3RoZXJzKSA9PiBmcmVxdWVuY3lfMS5mcmVxdWVuY3koe1xuICAgIHdlaWdodDogMTAsXG4gICAgYXJiaXRyYXJ5OiBleHBvcnRzLmJ1aWxkQWxwaGFOdW1lcmljQXJiKG90aGVycyksXG59LCB7XG4gICAgd2VpZ2h0OiAxLFxuICAgIGFyYml0cmFyeTogcGVyY2VudENoYXJBcmIsXG59KTtcbmV4cG9ydHMuYnVpbGRBbHBoYU51bWVyaWNQZXJjZW50QXJiID0gYnVpbGRBbHBoYU51bWVyaWNQZXJjZW50QXJiO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmVzY2FwZUZvck11bHRpbGluZUNvbW1lbnRzID0gZXhwb3J0cy5lc2NhcGVGb3JUZW1wbGF0ZVN0cmluZyA9IHZvaWQgMDtcbmZ1bmN0aW9uIGVzY2FwZUZvclRlbXBsYXRlU3RyaW5nKG9yaWdpbmFsVGV4dCkge1xuICAgIHJldHVybiBvcmlnaW5hbFRleHQucmVwbGFjZSgvKFskYFxcXFxdKS9nLCAnXFxcXCQxJykucmVwbGFjZSgvXFxyL2csICdcXFxccicpO1xufVxuZXhwb3J0cy5lc2NhcGVGb3JUZW1wbGF0ZVN0cmluZyA9IGVzY2FwZUZvclRlbXBsYXRlU3RyaW5nO1xuZnVuY3Rpb24gZXNjYXBlRm9yTXVsdGlsaW5lQ29tbWVudHMob3JpZ2luYWxUZXh0KSB7XG4gICAgcmV0dXJuIG9yaWdpbmFsVGV4dC5yZXBsYWNlKC9cXCpcXC8vZywgJypcXFxcLycpO1xufVxuZXhwb3J0cy5lc2NhcGVGb3JNdWx0aWxpbmVDb21tZW50cyA9IGVzY2FwZUZvck11bHRpbGluZUNvbW1lbnRzO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnNjaGVkdWxlZE1vZGVsUnVuID0gZXhwb3J0cy5hc3luY01vZGVsUnVuID0gZXhwb3J0cy5tb2RlbFJ1biA9IHZvaWQgMDtcbmNvbnN0IFNjaGVkdWxlZENvbW1hbmRfMSA9IHJlcXVpcmUoXCIuL2NvbW1hbmRzL1NjaGVkdWxlZENvbW1hbmRcIik7XG5jb25zdCBnZW5lcmljTW9kZWxSdW4gPSAocywgY21kcywgaW5pdGlhbFZhbHVlLCBydW5DbWQsIHRoZW4pID0+IHtcbiAgICByZXR1cm4gcy50aGVuKChvKSA9PiB7XG4gICAgICAgIGNvbnN0IHsgbW9kZWwsIHJlYWwgfSA9IG87XG4gICAgICAgIGxldCBzdGF0ZSA9IGluaXRpYWxWYWx1ZTtcbiAgICAgICAgZm9yIChjb25zdCBjIG9mIGNtZHMpIHtcbiAgICAgICAgICAgIHN0YXRlID0gdGhlbihzdGF0ZSwgKCkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBydW5DbWQoYywgbW9kZWwsIHJlYWwpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN0YXRlO1xuICAgIH0pO1xufTtcbmNvbnN0IGludGVybmFsTW9kZWxSdW4gPSAocywgY21kcykgPT4ge1xuICAgIGNvbnN0IHRoZW4gPSAoX3AsIGMpID0+IGMoKTtcbiAgICBjb25zdCBzZXR1cFByb2R1Y2VyID0ge1xuICAgICAgICB0aGVuOiAoZnVuKSA9PiB7XG4gICAgICAgICAgICBmdW4ocygpKTtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH0sXG4gICAgfTtcbiAgICBjb25zdCBydW5TeW5jID0gKGNtZCwgbSwgcikgPT4ge1xuICAgICAgICBpZiAoY21kLmNoZWNrKG0pKVxuICAgICAgICAgICAgY21kLnJ1bihtLCByKTtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9O1xuICAgIHJldHVybiBnZW5lcmljTW9kZWxSdW4oc2V0dXBQcm9kdWNlciwgY21kcywgdW5kZWZpbmVkLCBydW5TeW5jLCB0aGVuKTtcbn07XG5jb25zdCBpc0FzeW5jU2V0dXAgPSAocykgPT4ge1xuICAgIHJldHVybiB0eXBlb2Ygcy50aGVuID09PSAnZnVuY3Rpb24nO1xufTtcbmNvbnN0IGludGVybmFsQXN5bmNNb2RlbFJ1biA9IGFzeW5jIChzLCBjbWRzLCBkZWZhdWx0UHJvbWlzZSA9IFByb21pc2UucmVzb2x2ZSgpKSA9PiB7XG4gICAgY29uc3QgdGhlbiA9IChwLCBjKSA9PiBwLnRoZW4oYyk7XG4gICAgY29uc3Qgc2V0dXBQcm9kdWNlciA9IHtcbiAgICAgICAgdGhlbjogKGZ1bikgPT4ge1xuICAgICAgICAgICAgY29uc3Qgb3V0ID0gcygpO1xuICAgICAgICAgICAgaWYgKGlzQXN5bmNTZXR1cChvdXQpKVxuICAgICAgICAgICAgICAgIHJldHVybiBvdXQudGhlbihmdW4pO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHJldHVybiBmdW4ob3V0KTtcbiAgICAgICAgfSxcbiAgICB9O1xuICAgIGNvbnN0IHJ1bkFzeW5jID0gYXN5bmMgKGNtZCwgbSwgcikgPT4ge1xuICAgICAgICBpZiAoYXdhaXQgY21kLmNoZWNrKG0pKVxuICAgICAgICAgICAgYXdhaXQgY21kLnJ1bihtLCByKTtcbiAgICB9O1xuICAgIHJldHVybiBhd2FpdCBnZW5lcmljTW9kZWxSdW4oc2V0dXBQcm9kdWNlciwgY21kcywgZGVmYXVsdFByb21pc2UsIHJ1bkFzeW5jLCB0aGVuKTtcbn07XG5mdW5jdGlvbiBtb2RlbFJ1bihzLCBjbWRzKSB7XG4gICAgaW50ZXJuYWxNb2RlbFJ1bihzLCBjbWRzKTtcbn1cbmV4cG9ydHMubW9kZWxSdW4gPSBtb2RlbFJ1bjtcbmFzeW5jIGZ1bmN0aW9uIGFzeW5jTW9kZWxSdW4ocywgY21kcykge1xuICAgIGF3YWl0IGludGVybmFsQXN5bmNNb2RlbFJ1bihzLCBjbWRzKTtcbn1cbmV4cG9ydHMuYXN5bmNNb2RlbFJ1biA9IGFzeW5jTW9kZWxSdW47XG5hc3luYyBmdW5jdGlvbiBzY2hlZHVsZWRNb2RlbFJ1bihzY2hlZHVsZXIsIHMsIGNtZHMpIHtcbiAgICBjb25zdCBzY2hlZHVsZWRDb21tYW5kcyA9IFNjaGVkdWxlZENvbW1hbmRfMS5zY2hlZHVsZUNvbW1hbmRzKHNjaGVkdWxlciwgY21kcyk7XG4gICAgY29uc3Qgb3V0ID0gaW50ZXJuYWxBc3luY01vZGVsUnVuKHMsIHNjaGVkdWxlZENvbW1hbmRzLCBzY2hlZHVsZXIuc2NoZWR1bGUoUHJvbWlzZS5yZXNvbHZlKCksICdzdGFydE1vZGVsJykpO1xuICAgIGF3YWl0IHNjaGVkdWxlci53YWl0QWxsKCk7XG4gICAgYXdhaXQgb3V0O1xufVxuZXhwb3J0cy5zY2hlZHVsZWRNb2RlbFJ1biA9IHNjaGVkdWxlZE1vZGVsUnVuO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlJlcGxheVBhdGggPSB2b2lkIDA7XG5jbGFzcyBSZXBsYXlQYXRoIHtcbiAgICBzdGF0aWMgcGFyc2UocmVwbGF5UGF0aFN0cikge1xuICAgICAgICBjb25zdCBbc2VyaWFsaXplZENvdW50LCBzZXJpYWxpemVkQ2hhbmdlc10gPSByZXBsYXlQYXRoU3RyLnNwbGl0KCc6Jyk7XG4gICAgICAgIGNvbnN0IGNvdW50cyA9IHRoaXMucGFyc2VDb3VudHMoc2VyaWFsaXplZENvdW50KTtcbiAgICAgICAgY29uc3QgY2hhbmdlcyA9IHRoaXMucGFyc2VDaGFuZ2VzKHNlcmlhbGl6ZWRDaGFuZ2VzKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VPY2N1cmVuY2VzKGNvdW50cywgY2hhbmdlcyk7XG4gICAgfVxuICAgIHN0YXRpYyBzdHJpbmdpZnkocmVwbGF5UGF0aCkge1xuICAgICAgICBjb25zdCBvY2N1cmVuY2VzID0gdGhpcy5jb3VudE9jY3VyZW5jZXMocmVwbGF5UGF0aCk7XG4gICAgICAgIGNvbnN0IHNlcmlhbGl6ZWRDb3VudCA9IHRoaXMuc3RyaW5naWZ5Q291bnRzKG9jY3VyZW5jZXMpO1xuICAgICAgICBjb25zdCBzZXJpYWxpemVkQ2hhbmdlcyA9IHRoaXMuc3RyaW5naWZ5Q2hhbmdlcyhvY2N1cmVuY2VzKTtcbiAgICAgICAgcmV0dXJuIGAke3NlcmlhbGl6ZWRDb3VudH06JHtzZXJpYWxpemVkQ2hhbmdlc31gO1xuICAgIH1cbiAgICBzdGF0aWMgaW50VG9CNjQobikge1xuICAgICAgICBpZiAobiA8IDI2KVxuICAgICAgICAgICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUobiArIDY1KTtcbiAgICAgICAgaWYgKG4gPCA1MilcbiAgICAgICAgICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKG4gKyA5NyAtIDI2KTtcbiAgICAgICAgaWYgKG4gPCA2MilcbiAgICAgICAgICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKG4gKyA0OCAtIDUyKTtcbiAgICAgICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUobiA9PT0gNjIgPyA0MyA6IDQ3KTtcbiAgICB9XG4gICAgc3RhdGljIGI2NFRvSW50KGMpIHtcbiAgICAgICAgaWYgKGMgPj0gJ2EnKVxuICAgICAgICAgICAgcmV0dXJuIGMuY2hhckNvZGVBdCgwKSAtIDk3ICsgMjY7XG4gICAgICAgIGlmIChjID49ICdBJylcbiAgICAgICAgICAgIHJldHVybiBjLmNoYXJDb2RlQXQoMCkgLSA2NTtcbiAgICAgICAgaWYgKGMgPj0gJzAnKVxuICAgICAgICAgICAgcmV0dXJuIGMuY2hhckNvZGVBdCgwKSAtIDQ4ICsgNTI7XG4gICAgICAgIHJldHVybiBjID09PSAnKycgPyA2MiA6IDYzO1xuICAgIH1cbiAgICBzdGF0aWMgY291bnRPY2N1cmVuY2VzKHJlcGxheVBhdGgpIHtcbiAgICAgICAgcmV0dXJuIHJlcGxheVBhdGgucmVkdWNlKChjb3VudHMsIGN1cikgPT4ge1xuICAgICAgICAgICAgaWYgKGNvdW50cy5sZW5ndGggPT09IDAgfHwgY291bnRzW2NvdW50cy5sZW5ndGggLSAxXS5jb3VudCA9PT0gNjQgfHwgY291bnRzW2NvdW50cy5sZW5ndGggLSAxXS52YWx1ZSAhPT0gY3VyKVxuICAgICAgICAgICAgICAgIGNvdW50cy5wdXNoKHsgdmFsdWU6IGN1ciwgY291bnQ6IDEgfSk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgY291bnRzW2NvdW50cy5sZW5ndGggLSAxXS5jb3VudCArPSAxO1xuICAgICAgICAgICAgcmV0dXJuIGNvdW50cztcbiAgICAgICAgfSwgW10pO1xuICAgIH1cbiAgICBzdGF0aWMgcGFyc2VPY2N1cmVuY2VzKGNvdW50cywgY2hhbmdlcykge1xuICAgICAgICBjb25zdCByZXBsYXlQYXRoID0gW107XG4gICAgICAgIGZvciAobGV0IGlkeCA9IDA7IGlkeCAhPT0gY291bnRzLmxlbmd0aDsgKytpZHgpIHtcbiAgICAgICAgICAgIGNvbnN0IGNvdW50ID0gY291bnRzW2lkeF07XG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IGNoYW5nZXNbaWR4XTtcbiAgICAgICAgICAgIGZvciAobGV0IG51bSA9IDA7IG51bSAhPT0gY291bnQ7ICsrbnVtKVxuICAgICAgICAgICAgICAgIHJlcGxheVBhdGgucHVzaCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlcGxheVBhdGg7XG4gICAgfVxuICAgIHN0YXRpYyBzdHJpbmdpZnlDaGFuZ2VzKG9jY3VyZW5jZXMpIHtcbiAgICAgICAgbGV0IHNlcmlhbGl6ZWRDaGFuZ2VzID0gJyc7XG4gICAgICAgIGZvciAobGV0IGlkeCA9IDA7IGlkeCA8IG9jY3VyZW5jZXMubGVuZ3RoOyBpZHggKz0gNikge1xuICAgICAgICAgICAgY29uc3QgY2hhbmdlc0ludCA9IG9jY3VyZW5jZXNcbiAgICAgICAgICAgICAgICAuc2xpY2UoaWR4LCBpZHggKyA2KVxuICAgICAgICAgICAgICAgIC5yZWR1Y2VSaWdodCgocHJldiwgY3VyKSA9PiBwcmV2ICogMiArIChjdXIudmFsdWUgPyAxIDogMCksIDApO1xuICAgICAgICAgICAgc2VyaWFsaXplZENoYW5nZXMgKz0gdGhpcy5pbnRUb0I2NChjaGFuZ2VzSW50KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2VyaWFsaXplZENoYW5nZXM7XG4gICAgfVxuICAgIHN0YXRpYyBwYXJzZUNoYW5nZXMoc2VyaWFsaXplZENoYW5nZXMpIHtcbiAgICAgICAgY29uc3QgY2hhbmdlc0ludCA9IHNlcmlhbGl6ZWRDaGFuZ2VzLnNwbGl0KCcnKS5tYXAoKGMpID0+IHRoaXMuYjY0VG9JbnQoYykpO1xuICAgICAgICBjb25zdCBjaGFuZ2VzID0gW107XG4gICAgICAgIGZvciAobGV0IGlkeCA9IDA7IGlkeCAhPT0gY2hhbmdlc0ludC5sZW5ndGg7ICsraWR4KSB7XG4gICAgICAgICAgICBsZXQgY3VycmVudCA9IGNoYW5nZXNJbnRbaWR4XTtcbiAgICAgICAgICAgIGZvciAobGV0IG4gPSAwOyBuICE9PSA2OyArK24sIGN1cnJlbnQgPj49IDEpIHtcbiAgICAgICAgICAgICAgICBjaGFuZ2VzLnB1c2goY3VycmVudCAlIDIgPT09IDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjaGFuZ2VzO1xuICAgIH1cbiAgICBzdGF0aWMgc3RyaW5naWZ5Q291bnRzKG9jY3VyZW5jZXMpIHtcbiAgICAgICAgcmV0dXJuIG9jY3VyZW5jZXMubWFwKCh7IGNvdW50IH0pID0+IHRoaXMuaW50VG9CNjQoY291bnQgLSAxKSkuam9pbignJyk7XG4gICAgfVxuICAgIHN0YXRpYyBwYXJzZUNvdW50cyhzZXJpYWxpemVkQ291bnQpIHtcbiAgICAgICAgcmV0dXJuIHNlcmlhbGl6ZWRDb3VudC5zcGxpdCgnJykubWFwKChjKSA9PiB0aGlzLmI2NFRvSW50KGMpICsgMSk7XG4gICAgfVxufVxuZXhwb3J0cy5SZXBsYXlQYXRoID0gUmVwbGF5UGF0aDtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Db21tYW5kV3JhcHBlciA9IHZvaWQgMDtcbmNvbnN0IHN0cmluZ2lmeV8xID0gcmVxdWlyZShcIi4uLy4uLy4uL3V0aWxzL3N0cmluZ2lmeVwiKTtcbmNvbnN0IHN5bWJvbHNfMSA9IHJlcXVpcmUoXCIuLi8uLi9zeW1ib2xzXCIpO1xuY2xhc3MgQ29tbWFuZFdyYXBwZXIge1xuICAgIGNvbnN0cnVjdG9yKGNtZCkge1xuICAgICAgICB0aGlzLmNtZCA9IGNtZDtcbiAgICAgICAgdGhpcy5oYXNSYW4gPSBmYWxzZTtcbiAgICAgICAgaWYgKHN0cmluZ2lmeV8xLmhhc1RvU3RyaW5nTWV0aG9kKGNtZCkpIHtcbiAgICAgICAgICAgIGNvbnN0IG1ldGhvZCA9IGNtZFtzdHJpbmdpZnlfMS50b1N0cmluZ01ldGhvZF07XG4gICAgICAgICAgICB0aGlzW3N0cmluZ2lmeV8xLnRvU3RyaW5nTWV0aG9kXSA9IGZ1bmN0aW9uIHRvU3RyaW5nTWV0aG9kKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBtZXRob2QuY2FsbChjbWQpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RyaW5naWZ5XzEuaGFzQXN5bmNUb1N0cmluZ01ldGhvZChjbWQpKSB7XG4gICAgICAgICAgICBjb25zdCBtZXRob2QgPSBjbWRbc3RyaW5naWZ5XzEuYXN5bmNUb1N0cmluZ01ldGhvZF07XG4gICAgICAgICAgICB0aGlzW3N0cmluZ2lmeV8xLmFzeW5jVG9TdHJpbmdNZXRob2RdID0gZnVuY3Rpb24gYXN5bmNUb1N0cmluZ01ldGhvZCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbWV0aG9kLmNhbGwoY21kKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2hlY2sobSkge1xuICAgICAgICByZXR1cm4gdGhpcy5jbWQuY2hlY2sobSk7XG4gICAgfVxuICAgIHJ1bihtLCByKSB7XG4gICAgICAgIHRoaXMuaGFzUmFuID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY21kLnJ1bihtLCByKTtcbiAgICB9XG4gICAgY2xvbmUoKSB7XG4gICAgICAgIGlmIChzeW1ib2xzXzEuaGFzQ2xvbmVNZXRob2QodGhpcy5jbWQpKVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBDb21tYW5kV3JhcHBlcih0aGlzLmNtZFtzeW1ib2xzXzEuY2xvbmVNZXRob2RdKCkpO1xuICAgICAgICByZXR1cm4gbmV3IENvbW1hbmRXcmFwcGVyKHRoaXMuY21kKTtcbiAgICB9XG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNtZC50b1N0cmluZygpO1xuICAgIH1cbn1cbmV4cG9ydHMuQ29tbWFuZFdyYXBwZXIgPSBDb21tYW5kV3JhcHBlcjtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5jb21tYW5kcyA9IHZvaWQgMDtcbmNvbnN0IFN0cmVhbV8xID0gcmVxdWlyZShcIi4uLy4uLy4uL3N0cmVhbS9TdHJlYW1cIik7XG5jb25zdCBBcmJpdHJhcnlfMSA9IHJlcXVpcmUoXCIuLi8uLi9hcmJpdHJhcnkvZGVmaW5pdGlvbi9BcmJpdHJhcnlcIik7XG5jb25zdCBTaHJpbmthYmxlXzEgPSByZXF1aXJlKFwiLi4vLi4vYXJiaXRyYXJ5L2RlZmluaXRpb24vU2hyaW5rYWJsZVwiKTtcbmNvbnN0IG5hdF8xID0gcmVxdWlyZShcIi4uLy4uLy4uL2FyYml0cmFyeS9uYXRcIik7XG5jb25zdCBvbmVvZl8xID0gcmVxdWlyZShcIi4uLy4uLy4uL2FyYml0cmFyeS9vbmVvZlwiKTtcbmNvbnN0IFJlcGxheVBhdGhfMSA9IHJlcXVpcmUoXCIuLi9SZXBsYXlQYXRoXCIpO1xuY29uc3QgQ29tbWFuZHNJdGVyYWJsZV8xID0gcmVxdWlyZShcIi4vQ29tbWFuZHNJdGVyYWJsZVwiKTtcbmNvbnN0IENvbW1hbmRXcmFwcGVyXzEgPSByZXF1aXJlKFwiLi9Db21tYW5kV3JhcHBlclwiKTtcbmNvbnN0IExhenlJdGVyYWJsZUl0ZXJhdG9yXzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vc3RyZWFtL0xhenlJdGVyYWJsZUl0ZXJhdG9yXCIpO1xuY2xhc3MgQ29tbWFuZHNBcmJpdHJhcnkgZXh0ZW5kcyBBcmJpdHJhcnlfMS5BcmJpdHJhcnkge1xuICAgIGNvbnN0cnVjdG9yKGNvbW1hbmRBcmJzLCBtYXhDb21tYW5kcywgc291cmNlUmVwbGF5UGF0aCwgZGlzYWJsZVJlcGxheUxvZykge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLnNvdXJjZVJlcGxheVBhdGggPSBzb3VyY2VSZXBsYXlQYXRoO1xuICAgICAgICB0aGlzLmRpc2FibGVSZXBsYXlMb2cgPSBkaXNhYmxlUmVwbGF5TG9nO1xuICAgICAgICB0aGlzLm9uZUNvbW1hbmRBcmIgPSBvbmVvZl8xLm9uZW9mKC4uLmNvbW1hbmRBcmJzKS5tYXAoKGMpID0+IG5ldyBDb21tYW5kV3JhcHBlcl8xLkNvbW1hbmRXcmFwcGVyKGMpKTtcbiAgICAgICAgdGhpcy5sZW5ndGhBcmIgPSBuYXRfMS5uYXQobWF4Q29tbWFuZHMpO1xuICAgICAgICB0aGlzLnJlcGxheVBhdGggPSBbXTtcbiAgICAgICAgdGhpcy5yZXBsYXlQYXRoUG9zaXRpb24gPSAwO1xuICAgIH1cbiAgICBtZXRhZGF0YUZvclJlcGxheSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGlzYWJsZVJlcGxheUxvZyA/ICcnIDogYHJlcGxheVBhdGg9JHtKU09OLnN0cmluZ2lmeShSZXBsYXlQYXRoXzEuUmVwbGF5UGF0aC5zdHJpbmdpZnkodGhpcy5yZXBsYXlQYXRoKSl9YDtcbiAgICB9XG4gICAgd3JhcHBlcihpdGVtcywgc2hydW5rT25jZSkge1xuICAgICAgICByZXR1cm4gbmV3IFNocmlua2FibGVfMS5TaHJpbmthYmxlKG5ldyBDb21tYW5kc0l0ZXJhYmxlXzEuQ29tbWFuZHNJdGVyYWJsZShpdGVtcy5tYXAoKHMpID0+IHMudmFsdWVfKSwgKCkgPT4gdGhpcy5tZXRhZGF0YUZvclJlcGxheSgpKSwgKCkgPT4gdGhpcy5zaHJpbmtJbXBsKGl0ZW1zLCBzaHJ1bmtPbmNlKS5tYXAoKHYpID0+IHRoaXMud3JhcHBlcih2LCB0cnVlKSkpO1xuICAgIH1cbiAgICBnZW5lcmF0ZShtcm5nKSB7XG4gICAgICAgIGNvbnN0IHNpemUgPSB0aGlzLmxlbmd0aEFyYi5nZW5lcmF0ZShtcm5nKTtcbiAgICAgICAgY29uc3QgaXRlbXMgPSBBcnJheShzaXplLnZhbHVlXyk7XG4gICAgICAgIGZvciAobGV0IGlkeCA9IDA7IGlkeCAhPT0gc2l6ZS52YWx1ZV87ICsraWR4KSB7XG4gICAgICAgICAgICBjb25zdCBpdGVtID0gdGhpcy5vbmVDb21tYW5kQXJiLmdlbmVyYXRlKG1ybmcpO1xuICAgICAgICAgICAgaXRlbXNbaWR4XSA9IGl0ZW07XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yZXBsYXlQYXRoUG9zaXRpb24gPSAwO1xuICAgICAgICByZXR1cm4gdGhpcy53cmFwcGVyKGl0ZW1zLCBmYWxzZSk7XG4gICAgfVxuICAgIGZpbHRlck9uRXhlY3V0aW9uKGl0ZW1zUmF3KSB7XG4gICAgICAgIGNvbnN0IGl0ZW1zID0gW107XG4gICAgICAgIGZvciAoY29uc3QgYyBvZiBpdGVtc1Jhdykge1xuICAgICAgICAgICAgaWYgKGMudmFsdWVfLmhhc1Jhbikge1xuICAgICAgICAgICAgICAgIHRoaXMucmVwbGF5UGF0aC5wdXNoKHRydWUpO1xuICAgICAgICAgICAgICAgIGl0ZW1zLnB1c2goYyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgdGhpcy5yZXBsYXlQYXRoLnB1c2goZmFsc2UpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpdGVtcztcbiAgICB9XG4gICAgZmlsdGVyT25SZXBsYXkoaXRlbXNSYXcpIHtcbiAgICAgICAgcmV0dXJuIGl0ZW1zUmF3LmZpbHRlcigoYywgaWR4KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBzdGF0ZSA9IHRoaXMucmVwbGF5UGF0aFt0aGlzLnJlcGxheVBhdGhQb3NpdGlvbiArIGlkeF07XG4gICAgICAgICAgICBpZiAoc3RhdGUgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFRvbyBzaG9ydCByZXBsYXlQYXRoYCk7XG4gICAgICAgICAgICBpZiAoIXN0YXRlICYmIGMudmFsdWVfLmhhc1JhbilcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE1pc21hdGNoIGJldHdlZW4gcmVwbGF5UGF0aCBhbmQgcmVhbCBleGVjdXRpb25gKTtcbiAgICAgICAgICAgIHJldHVybiBzdGF0ZTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGZpbHRlckZvclNocmlua0ltcGwoaXRlbXNSYXcpIHtcbiAgICAgICAgaWYgKHRoaXMucmVwbGF5UGF0aFBvc2l0aW9uID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLnJlcGxheVBhdGggPSB0aGlzLnNvdXJjZVJlcGxheVBhdGggIT09IG51bGwgPyBSZXBsYXlQYXRoXzEuUmVwbGF5UGF0aC5wYXJzZSh0aGlzLnNvdXJjZVJlcGxheVBhdGgpIDogW107XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaXRlbXMgPSB0aGlzLnJlcGxheVBhdGhQb3NpdGlvbiA8IHRoaXMucmVwbGF5UGF0aC5sZW5ndGhcbiAgICAgICAgICAgID8gdGhpcy5maWx0ZXJPblJlcGxheShpdGVtc1JhdylcbiAgICAgICAgICAgIDogdGhpcy5maWx0ZXJPbkV4ZWN1dGlvbihpdGVtc1Jhdyk7XG4gICAgICAgIHRoaXMucmVwbGF5UGF0aFBvc2l0aW9uICs9IGl0ZW1zUmF3Lmxlbmd0aDtcbiAgICAgICAgcmV0dXJuIGl0ZW1zO1xuICAgIH1cbiAgICBzaHJpbmtJbXBsKGl0ZW1zUmF3LCBzaHJ1bmtPbmNlKSB7XG4gICAgICAgIGNvbnN0IGl0ZW1zID0gdGhpcy5maWx0ZXJGb3JTaHJpbmtJbXBsKGl0ZW1zUmF3KTtcbiAgICAgICAgaWYgKGl0ZW1zLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIFN0cmVhbV8xLlN0cmVhbS5uaWwoKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByb290U2hyaW5rID0gc2hydW5rT25jZVxuICAgICAgICAgICAgPyBTdHJlYW1fMS5TdHJlYW0ubmlsKClcbiAgICAgICAgICAgIDogbmV3IFN0cmVhbV8xLlN0cmVhbShbW11dW1N5bWJvbC5pdGVyYXRvcl0oKSk7XG4gICAgICAgIGNvbnN0IG5leHRTaHJpbmtzID0gW107XG4gICAgICAgIGZvciAobGV0IG51bVRvS2VlcCA9IDA7IG51bVRvS2VlcCAhPT0gaXRlbXMubGVuZ3RoOyArK251bVRvS2VlcCkge1xuICAgICAgICAgICAgbmV4dFNocmlua3MucHVzaChMYXp5SXRlcmFibGVJdGVyYXRvcl8xLm1ha2VMYXp5KCgpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBzaXplID0gdGhpcy5sZW5ndGhBcmIuY29udGV4dHVhbFNocmlua2FibGVGb3IoaXRlbXMubGVuZ3RoIC0gMSAtIG51bVRvS2VlcCk7XG4gICAgICAgICAgICAgICAgY29uc3QgZml4ZWRTdGFydCA9IGl0ZW1zLnNsaWNlKDAsIG51bVRvS2VlcCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNpemUuc2hyaW5rKCkubWFwKChsKSA9PiBmaXhlZFN0YXJ0LmNvbmNhdChpdGVtcy5zbGljZShpdGVtcy5sZW5ndGggLSAobC52YWx1ZSArIDEpKSkpO1xuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGl0ZW1BdCA9IDA7IGl0ZW1BdCAhPT0gaXRlbXMubGVuZ3RoOyArK2l0ZW1BdCkge1xuICAgICAgICAgICAgbmV4dFNocmlua3MucHVzaChMYXp5SXRlcmFibGVJdGVyYXRvcl8xLm1ha2VMYXp5KCgpID0+IGl0ZW1zW2l0ZW1BdF0uc2hyaW5rKCkubWFwKCh2KSA9PiBpdGVtcy5zbGljZSgwLCBpdGVtQXQpLmNvbmNhdChbdl0sIGl0ZW1zLnNsaWNlKGl0ZW1BdCArIDEpKSkpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcm9vdFNocmluay5qb2luKC4uLm5leHRTaHJpbmtzKS5tYXAoKHNocmlua2FibGVzKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gc2hyaW5rYWJsZXMubWFwKChjKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBTaHJpbmthYmxlXzEuU2hyaW5rYWJsZShjLnZhbHVlXy5jbG9uZSgpLCBjLnNocmluayk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuZnVuY3Rpb24gY29tbWFuZHMoY29tbWFuZEFyYnMsIGNvbnN0cmFpbnRzKSB7XG4gICAgY29uc3QgY29uZmlnID0gY29uc3RyYWludHMgPT0gbnVsbCA/IHt9IDogdHlwZW9mIGNvbnN0cmFpbnRzID09PSAnbnVtYmVyJyA/IHsgbWF4Q29tbWFuZHM6IGNvbnN0cmFpbnRzIH0gOiBjb25zdHJhaW50cztcbiAgICByZXR1cm4gbmV3IENvbW1hbmRzQXJiaXRyYXJ5KGNvbW1hbmRBcmJzLCBjb25maWcubWF4Q29tbWFuZHMgIT0gbnVsbCA/IGNvbmZpZy5tYXhDb21tYW5kcyA6IDEwLCBjb25maWcucmVwbGF5UGF0aCAhPSBudWxsID8gY29uZmlnLnJlcGxheVBhdGggOiBudWxsLCAhIWNvbmZpZy5kaXNhYmxlUmVwbGF5TG9nKTtcbn1cbmV4cG9ydHMuY29tbWFuZHMgPSBjb21tYW5kcztcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Db21tYW5kc0l0ZXJhYmxlID0gdm9pZCAwO1xuY29uc3Qgc3ltYm9sc18xID0gcmVxdWlyZShcIi4uLy4uL3N5bWJvbHNcIik7XG5jbGFzcyBDb21tYW5kc0l0ZXJhYmxlIHtcbiAgICBjb25zdHJ1Y3Rvcihjb21tYW5kcywgbWV0YWRhdGFGb3JSZXBsYXkpIHtcbiAgICAgICAgdGhpcy5jb21tYW5kcyA9IGNvbW1hbmRzO1xuICAgICAgICB0aGlzLm1ldGFkYXRhRm9yUmVwbGF5ID0gbWV0YWRhdGFGb3JSZXBsYXk7XG4gICAgfVxuICAgIFtTeW1ib2wuaXRlcmF0b3JdKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb21tYW5kc1tTeW1ib2wuaXRlcmF0b3JdKCk7XG4gICAgfVxuICAgIFtzeW1ib2xzXzEuY2xvbmVNZXRob2RdKCkge1xuICAgICAgICByZXR1cm4gbmV3IENvbW1hbmRzSXRlcmFibGUodGhpcy5jb21tYW5kcy5tYXAoKGMpID0+IGMuY2xvbmUoKSksIHRoaXMubWV0YWRhdGFGb3JSZXBsYXkpO1xuICAgIH1cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgY29uc3Qgc2VyaWFsaXplZENvbW1hbmRzID0gdGhpcy5jb21tYW5kc1xuICAgICAgICAgICAgLmZpbHRlcigoYykgPT4gYy5oYXNSYW4pXG4gICAgICAgICAgICAubWFwKChjKSA9PiBjLnRvU3RyaW5nKCkpXG4gICAgICAgICAgICAuam9pbignLCcpO1xuICAgICAgICBjb25zdCBtZXRhZGF0YSA9IHRoaXMubWV0YWRhdGFGb3JSZXBsYXkoKTtcbiAgICAgICAgcmV0dXJuIG1ldGFkYXRhLmxlbmd0aCAhPT0gMCA/IGAke3NlcmlhbGl6ZWRDb21tYW5kc30gLyoke21ldGFkYXRhfSovYCA6IHNlcmlhbGl6ZWRDb21tYW5kcztcbiAgICB9XG59XG5leHBvcnRzLkNvbW1hbmRzSXRlcmFibGUgPSBDb21tYW5kc0l0ZXJhYmxlO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnNjaGVkdWxlQ29tbWFuZHMgPSBleHBvcnRzLlNjaGVkdWxlZENvbW1hbmQgPSB2b2lkIDA7XG5jbGFzcyBTY2hlZHVsZWRDb21tYW5kIHtcbiAgICBjb25zdHJ1Y3RvcihzLCBjbWQpIHtcbiAgICAgICAgdGhpcy5zID0gcztcbiAgICAgICAgdGhpcy5jbWQgPSBjbWQ7XG4gICAgfVxuICAgIGFzeW5jIGNoZWNrKG0pIHtcbiAgICAgICAgbGV0IGVycm9yID0gbnVsbDtcbiAgICAgICAgbGV0IGNoZWNrUGFzc2VkID0gZmFsc2U7XG4gICAgICAgIGNvbnN0IHN0YXR1cyA9IGF3YWl0IHRoaXMucy5zY2hlZHVsZVNlcXVlbmNlKFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBsYWJlbDogYGNoZWNrQCR7dGhpcy5jbWQudG9TdHJpbmcoKX1gLFxuICAgICAgICAgICAgICAgIGJ1aWxkZXI6IGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoZWNrUGFzc2VkID0gYXdhaXQgUHJvbWlzZS5yZXNvbHZlKHRoaXMuY21kLmNoZWNrKG0pKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvciA9IGVycjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICBdKS50YXNrO1xuICAgICAgICBpZiAoc3RhdHVzLmZhdWx0eSkge1xuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNoZWNrUGFzc2VkO1xuICAgIH1cbiAgICBhc3luYyBydW4obSwgcikge1xuICAgICAgICBsZXQgZXJyb3IgPSBudWxsO1xuICAgICAgICBjb25zdCBzdGF0dXMgPSBhd2FpdCB0aGlzLnMuc2NoZWR1bGVTZXF1ZW5jZShbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbGFiZWw6IGBydW5AJHt0aGlzLmNtZC50b1N0cmluZygpfWAsXG4gICAgICAgICAgICAgICAgYnVpbGRlcjogYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5jbWQucnVuKG0sIHIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yID0gZXJyO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIF0pLnRhc2s7XG4gICAgICAgIGlmIChzdGF0dXMuZmF1bHR5KSB7XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuU2NoZWR1bGVkQ29tbWFuZCA9IFNjaGVkdWxlZENvbW1hbmQ7XG5jb25zdCBzY2hlZHVsZUNvbW1hbmRzID0gZnVuY3Rpb24qIChzLCBjbWRzKSB7XG4gICAgZm9yIChjb25zdCBjbWQgb2YgY21kcykge1xuICAgICAgICB5aWVsZCBuZXcgU2NoZWR1bGVkQ29tbWFuZChzLCBjbWQpO1xuICAgIH1cbn07XG5leHBvcnRzLnNjaGVkdWxlQ29tbWFuZHMgPSBzY2hlZHVsZUNvbW1hbmRzO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnByZSA9IHZvaWQgMDtcbmNvbnN0IFByZWNvbmRpdGlvbkZhaWx1cmVfMSA9IHJlcXVpcmUoXCIuL1ByZWNvbmRpdGlvbkZhaWx1cmVcIik7XG5mdW5jdGlvbiBwcmUoZXhwZWN0VHJ1dGh5KSB7XG4gICAgaWYgKCFleHBlY3RUcnV0aHkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFByZWNvbmRpdGlvbkZhaWx1cmVfMS5QcmVjb25kaXRpb25GYWlsdXJlKCk7XG4gICAgfVxufVxuZXhwb3J0cy5wcmUgPSBwcmU7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuUHJlY29uZGl0aW9uRmFpbHVyZSA9IHZvaWQgMDtcbmNsYXNzIFByZWNvbmRpdGlvbkZhaWx1cmUgZXh0ZW5kcyBFcnJvciB7XG4gICAgY29uc3RydWN0b3IoaW50ZXJydXB0RXhlY3V0aW9uID0gZmFsc2UpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5pbnRlcnJ1cHRFeGVjdXRpb24gPSBpbnRlcnJ1cHRFeGVjdXRpb247XG4gICAgICAgIHRoaXMuZm9vdHByaW50ID0gUHJlY29uZGl0aW9uRmFpbHVyZS5TaGFyZWRGb290UHJpbnQ7XG4gICAgfVxuICAgIHN0YXRpYyBpc0ZhaWx1cmUoZXJyKSB7XG4gICAgICAgIHJldHVybiBlcnIgIT0gbnVsbCAmJiBlcnIuZm9vdHByaW50ID09PSBQcmVjb25kaXRpb25GYWlsdXJlLlNoYXJlZEZvb3RQcmludDtcbiAgICB9XG59XG5leHBvcnRzLlByZWNvbmRpdGlvbkZhaWx1cmUgPSBQcmVjb25kaXRpb25GYWlsdXJlO1xuUHJlY29uZGl0aW9uRmFpbHVyZS5TaGFyZWRGb290UHJpbnQgPSBTeW1ib2woJ2Zhc3QtY2hlY2svUHJlY29uZGl0aW9uRmFpbHVyZScpO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmFzeW5jUHJvcGVydHkgPSB2b2lkIDA7XG5jb25zdCBnZW5lcmljVHVwbGVfMSA9IHJlcXVpcmUoXCIuLi8uLi9hcmJpdHJhcnkvZ2VuZXJpY1R1cGxlXCIpO1xuY29uc3QgQXN5bmNQcm9wZXJ0eV9nZW5lcmljXzEgPSByZXF1aXJlKFwiLi9Bc3luY1Byb3BlcnR5LmdlbmVyaWNcIik7XG5mdW5jdGlvbiBhc3luY1Byb3BlcnR5KC4uLmFyZ3MpIHtcbiAgICBpZiAoYXJncy5sZW5ndGggPCAyKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2FzeW5jUHJvcGVydHkgZXhwZWN0cyBhdCBsZWFzdCB0d28gcGFyYW1ldGVycycpO1xuICAgIGNvbnN0IGFyYnMgPSBhcmdzLnNsaWNlKDAsIGFyZ3MubGVuZ3RoIC0gMSk7XG4gICAgY29uc3QgcCA9IGFyZ3NbYXJncy5sZW5ndGggLSAxXTtcbiAgICByZXR1cm4gbmV3IEFzeW5jUHJvcGVydHlfZ2VuZXJpY18xLkFzeW5jUHJvcGVydHkoZ2VuZXJpY1R1cGxlXzEuZ2VuZXJpY1R1cGxlKGFyYnMpLCB0ID0+IHAoLi4udCkpO1xufVxuZXhwb3J0cy5hc3luY1Byb3BlcnR5ID0gYXN5bmNQcm9wZXJ0eTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Bc3luY1Byb3BlcnR5ID0gdm9pZCAwO1xuY29uc3QgUHJlY29uZGl0aW9uRmFpbHVyZV8xID0gcmVxdWlyZShcIi4uL3ByZWNvbmRpdGlvbi9QcmVjb25kaXRpb25GYWlsdXJlXCIpO1xuY29uc3QgSVJhd1Byb3BlcnR5XzEgPSByZXF1aXJlKFwiLi9JUmF3UHJvcGVydHlcIik7XG5jb25zdCBHbG9iYWxQYXJhbWV0ZXJzXzEgPSByZXF1aXJlKFwiLi4vcnVubmVyL2NvbmZpZ3VyYXRpb24vR2xvYmFsUGFyYW1ldGVyc1wiKTtcbmNvbnN0IENvbnZlcnRlckZyb21OZXh0XzEgPSByZXF1aXJlKFwiLi4vYXJiaXRyYXJ5L2RlZmluaXRpb24vQ29udmVydGVyRnJvbU5leHRcIik7XG5jbGFzcyBBc3luY1Byb3BlcnR5IHtcbiAgICBjb25zdHJ1Y3RvcihhcmIsIHByZWRpY2F0ZSkge1xuICAgICAgICB0aGlzLmFyYiA9IGFyYjtcbiAgICAgICAgdGhpcy5wcmVkaWNhdGUgPSBwcmVkaWNhdGU7XG4gICAgICAgIHRoaXMuaXNBc3luYyA9ICgpID0+IHRydWU7XG4gICAgICAgIGNvbnN0IHsgYXN5bmNCZWZvcmVFYWNoLCBhc3luY0FmdGVyRWFjaCwgYmVmb3JlRWFjaCwgYWZ0ZXJFYWNoIH0gPSBHbG9iYWxQYXJhbWV0ZXJzXzEucmVhZENvbmZpZ3VyZUdsb2JhbCgpIHx8IHt9O1xuICAgICAgICBpZiAoYXN5bmNCZWZvcmVFYWNoICE9PSB1bmRlZmluZWQgJiYgYmVmb3JlRWFjaCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcignR2xvYmFsIFwiYXN5bmNCZWZvcmVFYWNoXCIgYW5kIFwiYmVmb3JlRWFjaFwiIHBhcmFtZXRlcnMgY2FuXFwndCBiZSBzZXQgYXQgdGhlIHNhbWUgdGltZSB3aGVuIHJ1bm5pbmcgYXN5bmMgcHJvcGVydGllcycpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhc3luY0FmdGVyRWFjaCAhPT0gdW5kZWZpbmVkICYmIGFmdGVyRWFjaCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcignR2xvYmFsIFwiYXN5bmNBZnRlckVhY2hcIiBhbmQgXCJhZnRlckVhY2hcIiBwYXJhbWV0ZXJzIGNhblxcJ3QgYmUgc2V0IGF0IHRoZSBzYW1lIHRpbWUgd2hlbiBydW5uaW5nIGFzeW5jIHByb3BlcnRpZXMnKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmJlZm9yZUVhY2hIb29rID0gYXN5bmNCZWZvcmVFYWNoIHx8IGJlZm9yZUVhY2ggfHwgQXN5bmNQcm9wZXJ0eS5kdW1teUhvb2s7XG4gICAgICAgIHRoaXMuYWZ0ZXJFYWNoSG9vayA9IGFzeW5jQWZ0ZXJFYWNoIHx8IGFmdGVyRWFjaCB8fCBBc3luY1Byb3BlcnR5LmR1bW15SG9vaztcbiAgICB9XG4gICAgZ2VuZXJhdGUobXJuZywgcnVuSWQpIHtcbiAgICAgICAgaWYgKENvbnZlcnRlckZyb21OZXh0XzEuQ29udmVydGVyRnJvbU5leHQuaXNDb252ZXJ0ZXJGcm9tTmV4dCh0aGlzLmFyYikpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmFyYi50b1Nocmlua2FibGUodGhpcy5hcmIuYXJiLmdlbmVyYXRlKG1ybmcsIHJ1bklkICE9IG51bGwgPyBJUmF3UHJvcGVydHlfMS5ydW5JZFRvRnJlcXVlbmN5KHJ1bklkKSA6IHVuZGVmaW5lZCkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBydW5JZCAhPSBudWxsID8gdGhpcy5hcmIud2l0aEJpYXMoSVJhd1Byb3BlcnR5XzEucnVuSWRUb0ZyZXF1ZW5jeShydW5JZCkpLmdlbmVyYXRlKG1ybmcpIDogdGhpcy5hcmIuZ2VuZXJhdGUobXJuZyk7XG4gICAgfVxuICAgIGFzeW5jIHJ1bih2KSB7XG4gICAgICAgIGF3YWl0IHRoaXMuYmVmb3JlRWFjaEhvb2soKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IG91dHB1dCA9IGF3YWl0IHRoaXMucHJlZGljYXRlKHYpO1xuICAgICAgICAgICAgcmV0dXJuIG91dHB1dCA9PSBudWxsIHx8IG91dHB1dCA9PT0gdHJ1ZSA/IG51bGwgOiAnUHJvcGVydHkgZmFpbGVkIGJ5IHJldHVybmluZyBmYWxzZSc7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgaWYgKFByZWNvbmRpdGlvbkZhaWx1cmVfMS5QcmVjb25kaXRpb25GYWlsdXJlLmlzRmFpbHVyZShlcnIpKVxuICAgICAgICAgICAgICAgIHJldHVybiBlcnI7XG4gICAgICAgICAgICBpZiAoZXJyIGluc3RhbmNlb2YgRXJyb3IgJiYgZXJyLnN0YWNrKVxuICAgICAgICAgICAgICAgIHJldHVybiBgJHtlcnJ9XFxuXFxuU3RhY2sgdHJhY2U6ICR7ZXJyLnN0YWNrfWA7XG4gICAgICAgICAgICByZXR1cm4gYCR7ZXJyfWA7XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLmFmdGVyRWFjaEhvb2soKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBiZWZvcmVFYWNoKGhvb2tGdW5jdGlvbikge1xuICAgICAgICBjb25zdCBwcmV2aW91c0JlZm9yZUVhY2hIb29rID0gdGhpcy5iZWZvcmVFYWNoSG9vaztcbiAgICAgICAgdGhpcy5iZWZvcmVFYWNoSG9vayA9ICgpID0+IGhvb2tGdW5jdGlvbihwcmV2aW91c0JlZm9yZUVhY2hIb29rKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGFmdGVyRWFjaChob29rRnVuY3Rpb24pIHtcbiAgICAgICAgY29uc3QgcHJldmlvdXNBZnRlckVhY2hIb29rID0gdGhpcy5hZnRlckVhY2hIb29rO1xuICAgICAgICB0aGlzLmFmdGVyRWFjaEhvb2sgPSAoKSA9PiBob29rRnVuY3Rpb24ocHJldmlvdXNBZnRlckVhY2hIb29rKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxufVxuZXhwb3J0cy5Bc3luY1Byb3BlcnR5ID0gQXN5bmNQcm9wZXJ0eTtcbkFzeW5jUHJvcGVydHkuZHVtbXlIb29rID0gKCkgPT4geyB9O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmFzeW5jUHJvcGVydHkgPSB2b2lkIDA7XG5jb25zdCBBc3luY1Byb3BlcnR5X2dlbmVyYXRlZF8xID0gcmVxdWlyZShcIi4vQXN5bmNQcm9wZXJ0eS5nZW5lcmF0ZWRcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJhc3luY1Byb3BlcnR5XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBBc3luY1Byb3BlcnR5X2dlbmVyYXRlZF8xLmFzeW5jUHJvcGVydHk7IH0gfSk7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMucnVuSWRUb0ZyZXF1ZW5jeSA9IHZvaWQgMDtcbmNvbnN0IHJ1bklkVG9GcmVxdWVuY3kgPSAocnVuSWQpID0+IDIgKyBNYXRoLmZsb29yKE1hdGgubG9nKHJ1bklkICsgMSkgLyBNYXRoLmxvZygxMCkpO1xuZXhwb3J0cy5ydW5JZFRvRnJlcXVlbmN5ID0gcnVuSWRUb0ZyZXF1ZW5jeTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5JZ25vcmVFcXVhbFZhbHVlc1Byb3BlcnR5ID0gdm9pZCAwO1xuY29uc3Qgc3RyaW5naWZ5XzEgPSByZXF1aXJlKFwiLi4vLi4vdXRpbHMvc3RyaW5naWZ5XCIpO1xuY29uc3QgUHJlY29uZGl0aW9uRmFpbHVyZV8xID0gcmVxdWlyZShcIi4uL3ByZWNvbmRpdGlvbi9QcmVjb25kaXRpb25GYWlsdXJlXCIpO1xuZnVuY3Rpb24gZnJvbVN5bmNDYWNoZWQoY2FjaGVkVmFsdWUpIHtcbiAgICByZXR1cm4gY2FjaGVkVmFsdWUgPT09IG51bGwgPyBuZXcgUHJlY29uZGl0aW9uRmFpbHVyZV8xLlByZWNvbmRpdGlvbkZhaWx1cmUoKSA6IGNhY2hlZFZhbHVlO1xufVxuZnVuY3Rpb24gZnJvbUNhY2hlZCguLi5kYXRhKSB7XG4gICAgaWYgKGRhdGFbMV0pXG4gICAgICAgIHJldHVybiBkYXRhWzBdLnRoZW4oZnJvbVN5bmNDYWNoZWQpO1xuICAgIHJldHVybiBmcm9tU3luY0NhY2hlZChkYXRhWzBdKTtcbn1cbmZ1bmN0aW9uIGZyb21DYWNoZWRVbnNhZmUoY2FjaGVkVmFsdWUsIGlzQXN5bmMpIHtcbiAgICByZXR1cm4gZnJvbUNhY2hlZChjYWNoZWRWYWx1ZSwgaXNBc3luYyk7XG59XG5jbGFzcyBJZ25vcmVFcXVhbFZhbHVlc1Byb3BlcnR5IHtcbiAgICBjb25zdHJ1Y3Rvcihwcm9wZXJ0eSwgc2tpcFJ1bnMpIHtcbiAgICAgICAgdGhpcy5wcm9wZXJ0eSA9IHByb3BlcnR5O1xuICAgICAgICB0aGlzLnNraXBSdW5zID0gc2tpcFJ1bnM7XG4gICAgICAgIHRoaXMuY292ZXJlZENhc2VzID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLmlzQXN5bmMgPSAoKSA9PiB0aGlzLnByb3BlcnR5LmlzQXN5bmMoKTtcbiAgICAgICAgdGhpcy5nZW5lcmF0ZSA9IChtcm5nLCBydW5JZCkgPT4gdGhpcy5wcm9wZXJ0eS5nZW5lcmF0ZShtcm5nLCBydW5JZCk7XG4gICAgICAgIHRoaXMucnVuID0gKHYpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHN0cmluZ2lmaWVkVmFsdWUgPSBzdHJpbmdpZnlfMS5zdHJpbmdpZnkodik7XG4gICAgICAgICAgICBpZiAodGhpcy5jb3ZlcmVkQ2FzZXMuaGFzKHN0cmluZ2lmaWVkVmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbGFzdE91dHB1dCA9IHRoaXMuY292ZXJlZENhc2VzLmdldChzdHJpbmdpZmllZFZhbHVlKTtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuc2tpcFJ1bnMpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGxhc3RPdXRwdXQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBmcm9tQ2FjaGVkVW5zYWZlKGxhc3RPdXRwdXQsIHRoaXMucHJvcGVydHkuaXNBc3luYygpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IG91dCA9IHRoaXMucHJvcGVydHkucnVuKHYpO1xuICAgICAgICAgICAgdGhpcy5jb3ZlcmVkQ2FzZXMuc2V0KHN0cmluZ2lmaWVkVmFsdWUsIG91dCk7XG4gICAgICAgICAgICByZXR1cm4gb3V0O1xuICAgICAgICB9O1xuICAgIH1cbn1cbmV4cG9ydHMuSWdub3JlRXF1YWxWYWx1ZXNQcm9wZXJ0eSA9IElnbm9yZUVxdWFsVmFsdWVzUHJvcGVydHk7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMucHJvcGVydHkgPSB2b2lkIDA7XG5jb25zdCBnZW5lcmljVHVwbGVfMSA9IHJlcXVpcmUoXCIuLi8uLi9hcmJpdHJhcnkvZ2VuZXJpY1R1cGxlXCIpO1xuY29uc3QgUHJvcGVydHlfZ2VuZXJpY18xID0gcmVxdWlyZShcIi4vUHJvcGVydHkuZ2VuZXJpY1wiKTtcbmZ1bmN0aW9uIHByb3BlcnR5KC4uLmFyZ3MpIHtcbiAgICBpZiAoYXJncy5sZW5ndGggPCAyKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb3BlcnR5IGV4cGVjdHMgYXQgbGVhc3QgdHdvIHBhcmFtZXRlcnMnKTtcbiAgICBjb25zdCBhcmJzID0gYXJncy5zbGljZSgwLCBhcmdzLmxlbmd0aCAtIDEpO1xuICAgIGNvbnN0IHAgPSBhcmdzW2FyZ3MubGVuZ3RoIC0gMV07XG4gICAgcmV0dXJuIG5ldyBQcm9wZXJ0eV9nZW5lcmljXzEuUHJvcGVydHkoZ2VuZXJpY1R1cGxlXzEuZ2VuZXJpY1R1cGxlKGFyYnMpLCB0ID0+IHAoLi4udCkpO1xufVxuZXhwb3J0cy5wcm9wZXJ0eSA9IHByb3BlcnR5O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlByb3BlcnR5ID0gdm9pZCAwO1xuY29uc3QgUHJlY29uZGl0aW9uRmFpbHVyZV8xID0gcmVxdWlyZShcIi4uL3ByZWNvbmRpdGlvbi9QcmVjb25kaXRpb25GYWlsdXJlXCIpO1xuY29uc3QgSVJhd1Byb3BlcnR5XzEgPSByZXF1aXJlKFwiLi9JUmF3UHJvcGVydHlcIik7XG5jb25zdCBHbG9iYWxQYXJhbWV0ZXJzXzEgPSByZXF1aXJlKFwiLi4vcnVubmVyL2NvbmZpZ3VyYXRpb24vR2xvYmFsUGFyYW1ldGVyc1wiKTtcbmNvbnN0IENvbnZlcnRlckZyb21OZXh0XzEgPSByZXF1aXJlKFwiLi4vYXJiaXRyYXJ5L2RlZmluaXRpb24vQ29udmVydGVyRnJvbU5leHRcIik7XG5jbGFzcyBQcm9wZXJ0eSB7XG4gICAgY29uc3RydWN0b3IoYXJiLCBwcmVkaWNhdGUpIHtcbiAgICAgICAgdGhpcy5hcmIgPSBhcmI7XG4gICAgICAgIHRoaXMucHJlZGljYXRlID0gcHJlZGljYXRlO1xuICAgICAgICB0aGlzLmlzQXN5bmMgPSAoKSA9PiBmYWxzZTtcbiAgICAgICAgY29uc3QgeyBiZWZvcmVFYWNoID0gUHJvcGVydHkuZHVtbXlIb29rLCBhZnRlckVhY2ggPSBQcm9wZXJ0eS5kdW1teUhvb2ssIGFzeW5jQmVmb3JlRWFjaCwgYXN5bmNBZnRlckVhY2gsIH0gPSBHbG9iYWxQYXJhbWV0ZXJzXzEucmVhZENvbmZpZ3VyZUdsb2JhbCgpIHx8IHt9O1xuICAgICAgICBpZiAoYXN5bmNCZWZvcmVFYWNoICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKCdcImFzeW5jQmVmb3JlRWFjaFwiIGNhblxcJ3QgYmUgc2V0IHdoZW4gcnVubmluZyBzeW5jaHJvbm91cyBwcm9wZXJ0aWVzJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFzeW5jQWZ0ZXJFYWNoICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKCdcImFzeW5jQWZ0ZXJFYWNoXCIgY2FuXFwndCBiZSBzZXQgd2hlbiBydW5uaW5nIHN5bmNocm9ub3VzIHByb3BlcnRpZXMnKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmJlZm9yZUVhY2hIb29rID0gYmVmb3JlRWFjaDtcbiAgICAgICAgdGhpcy5hZnRlckVhY2hIb29rID0gYWZ0ZXJFYWNoO1xuICAgIH1cbiAgICBnZW5lcmF0ZShtcm5nLCBydW5JZCkge1xuICAgICAgICBpZiAoQ29udmVydGVyRnJvbU5leHRfMS5Db252ZXJ0ZXJGcm9tTmV4dC5pc0NvbnZlcnRlckZyb21OZXh0KHRoaXMuYXJiKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYXJiLnRvU2hyaW5rYWJsZSh0aGlzLmFyYi5hcmIuZ2VuZXJhdGUobXJuZywgcnVuSWQgIT0gbnVsbCA/IElSYXdQcm9wZXJ0eV8xLnJ1bklkVG9GcmVxdWVuY3kocnVuSWQpIDogdW5kZWZpbmVkKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJ1bklkICE9IG51bGwgPyB0aGlzLmFyYi53aXRoQmlhcyhJUmF3UHJvcGVydHlfMS5ydW5JZFRvRnJlcXVlbmN5KHJ1bklkKSkuZ2VuZXJhdGUobXJuZykgOiB0aGlzLmFyYi5nZW5lcmF0ZShtcm5nKTtcbiAgICB9XG4gICAgcnVuKHYpIHtcbiAgICAgICAgdGhpcy5iZWZvcmVFYWNoSG9vaygpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3Qgb3V0cHV0ID0gdGhpcy5wcmVkaWNhdGUodik7XG4gICAgICAgICAgICByZXR1cm4gb3V0cHV0ID09IG51bGwgfHwgb3V0cHV0ID09PSB0cnVlID8gbnVsbCA6ICdQcm9wZXJ0eSBmYWlsZWQgYnkgcmV0dXJuaW5nIGZhbHNlJztcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBpZiAoUHJlY29uZGl0aW9uRmFpbHVyZV8xLlByZWNvbmRpdGlvbkZhaWx1cmUuaXNGYWlsdXJlKGVycikpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGVycjtcbiAgICAgICAgICAgIGlmIChlcnIgaW5zdGFuY2VvZiBFcnJvciAmJiBlcnIuc3RhY2spXG4gICAgICAgICAgICAgICAgcmV0dXJuIGAke2Vycn1cXG5cXG5TdGFjayB0cmFjZTogJHtlcnIuc3RhY2t9YDtcbiAgICAgICAgICAgIHJldHVybiBgJHtlcnJ9YDtcbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgIHRoaXMuYWZ0ZXJFYWNoSG9vaygpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGJlZm9yZUVhY2goaG9va0Z1bmN0aW9uKSB7XG4gICAgICAgIGNvbnN0IHByZXZpb3VzQmVmb3JlRWFjaEhvb2sgPSB0aGlzLmJlZm9yZUVhY2hIb29rO1xuICAgICAgICB0aGlzLmJlZm9yZUVhY2hIb29rID0gKCkgPT4gaG9va0Z1bmN0aW9uKHByZXZpb3VzQmVmb3JlRWFjaEhvb2spO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgYWZ0ZXJFYWNoKGhvb2tGdW5jdGlvbikge1xuICAgICAgICBjb25zdCBwcmV2aW91c0FmdGVyRWFjaEhvb2sgPSB0aGlzLmFmdGVyRWFjaEhvb2s7XG4gICAgICAgIHRoaXMuYWZ0ZXJFYWNoSG9vayA9ICgpID0+IGhvb2tGdW5jdGlvbihwcmV2aW91c0FmdGVyRWFjaEhvb2spO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG59XG5leHBvcnRzLlByb3BlcnR5ID0gUHJvcGVydHk7XG5Qcm9wZXJ0eS5kdW1teUhvb2sgPSAoKSA9PiB7IH07XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMucHJvcGVydHkgPSB2b2lkIDA7XG5jb25zdCBQcm9wZXJ0eV9nZW5lcmF0ZWRfMSA9IHJlcXVpcmUoXCIuL1Byb3BlcnR5LmdlbmVyYXRlZFwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInByb3BlcnR5XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBQcm9wZXJ0eV9nZW5lcmF0ZWRfMS5wcm9wZXJ0eTsgfSB9KTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Ta2lwQWZ0ZXJQcm9wZXJ0eSA9IHZvaWQgMDtcbmNvbnN0IFByZWNvbmRpdGlvbkZhaWx1cmVfMSA9IHJlcXVpcmUoXCIuLi9wcmVjb25kaXRpb24vUHJlY29uZGl0aW9uRmFpbHVyZVwiKTtcbmNsYXNzIFNraXBBZnRlclByb3BlcnR5IHtcbiAgICBjb25zdHJ1Y3Rvcihwcm9wZXJ0eSwgZ2V0VGltZSwgdGltZUxpbWl0LCBpbnRlcnJ1cHRFeGVjdXRpb24pIHtcbiAgICAgICAgdGhpcy5wcm9wZXJ0eSA9IHByb3BlcnR5O1xuICAgICAgICB0aGlzLmdldFRpbWUgPSBnZXRUaW1lO1xuICAgICAgICB0aGlzLmludGVycnVwdEV4ZWN1dGlvbiA9IGludGVycnVwdEV4ZWN1dGlvbjtcbiAgICAgICAgdGhpcy5pc0FzeW5jID0gKCkgPT4gdGhpcy5wcm9wZXJ0eS5pc0FzeW5jKCk7XG4gICAgICAgIHRoaXMuZ2VuZXJhdGUgPSAobXJuZywgcnVuSWQpID0+IHRoaXMucHJvcGVydHkuZ2VuZXJhdGUobXJuZywgcnVuSWQpO1xuICAgICAgICB0aGlzLnJ1biA9ICh2KSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5nZXRUaW1lKCkgPj0gdGhpcy5za2lwQWZ0ZXJUaW1lKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcHJlY29uZGl0aW9uRmFpbHVyZSA9IG5ldyBQcmVjb25kaXRpb25GYWlsdXJlXzEuUHJlY29uZGl0aW9uRmFpbHVyZSh0aGlzLmludGVycnVwdEV4ZWN1dGlvbik7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaXNBc3luYygpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUocHJlY29uZGl0aW9uRmFpbHVyZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcHJlY29uZGl0aW9uRmFpbHVyZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wcm9wZXJ0eS5ydW4odik7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuc2tpcEFmdGVyVGltZSA9IHRoaXMuZ2V0VGltZSgpICsgdGltZUxpbWl0O1xuICAgIH1cbn1cbmV4cG9ydHMuU2tpcEFmdGVyUHJvcGVydHkgPSBTa2lwQWZ0ZXJQcm9wZXJ0eTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5UaW1lb3V0UHJvcGVydHkgPSB2b2lkIDA7XG5jb25zdCB0aW1lb3V0QWZ0ZXIgPSAodGltZU1zKSA9PiB7XG4gICAgbGV0IHRpbWVvdXRIYW5kbGUgPSBudWxsO1xuICAgIGNvbnN0IHByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgICB0aW1lb3V0SGFuZGxlID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICByZXNvbHZlKGBQcm9wZXJ0eSB0aW1lb3V0OiBleGNlZWRlZCBsaW1pdCBvZiAke3RpbWVNc30gbWlsbGlzZWNvbmRzYCk7XG4gICAgICAgIH0sIHRpbWVNcyk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgY2xlYXI6ICgpID0+IGNsZWFyVGltZW91dCh0aW1lb3V0SGFuZGxlKSxcbiAgICAgICAgcHJvbWlzZSxcbiAgICB9O1xufTtcbmNsYXNzIFRpbWVvdXRQcm9wZXJ0eSB7XG4gICAgY29uc3RydWN0b3IocHJvcGVydHksIHRpbWVNcykge1xuICAgICAgICB0aGlzLnByb3BlcnR5ID0gcHJvcGVydHk7XG4gICAgICAgIHRoaXMudGltZU1zID0gdGltZU1zO1xuICAgICAgICB0aGlzLmlzQXN5bmMgPSAoKSA9PiB0cnVlO1xuICAgIH1cbiAgICBnZW5lcmF0ZShtcm5nLCBydW5JZCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wcm9wZXJ0eS5nZW5lcmF0ZShtcm5nLCBydW5JZCk7XG4gICAgfVxuICAgIGFzeW5jIHJ1bih2KSB7XG4gICAgICAgIGNvbnN0IHQgPSB0aW1lb3V0QWZ0ZXIodGhpcy50aW1lTXMpO1xuICAgICAgICBjb25zdCBwcm9wUnVuID0gUHJvbWlzZS5yYWNlKFt0aGlzLnByb3BlcnR5LnJ1bih2KSwgdC5wcm9taXNlXSk7XG4gICAgICAgIHByb3BSdW4udGhlbih0LmNsZWFyLCB0LmNsZWFyKTtcbiAgICAgICAgcmV0dXJuIHByb3BSdW47XG4gICAgfVxufVxuZXhwb3J0cy5UaW1lb3V0UHJvcGVydHkgPSBUaW1lb3V0UHJvcGVydHk7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuVW5iaWFzZWRQcm9wZXJ0eSA9IHZvaWQgMDtcbmNsYXNzIFVuYmlhc2VkUHJvcGVydHkge1xuICAgIGNvbnN0cnVjdG9yKHByb3BlcnR5KSB7XG4gICAgICAgIHRoaXMucHJvcGVydHkgPSBwcm9wZXJ0eTtcbiAgICAgICAgdGhpcy5pc0FzeW5jID0gKCkgPT4gdGhpcy5wcm9wZXJ0eS5pc0FzeW5jKCk7XG4gICAgICAgIHRoaXMuZ2VuZXJhdGUgPSAobXJuZywgX3J1bklkKSA9PiB0aGlzLnByb3BlcnR5LmdlbmVyYXRlKG1ybmcpO1xuICAgICAgICB0aGlzLnJ1biA9ICh2KSA9PiB0aGlzLnByb3BlcnR5LnJ1bih2KTtcbiAgICB9XG59XG5leHBvcnRzLlVuYmlhc2VkUHJvcGVydHkgPSBVbmJpYXNlZFByb3BlcnR5O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmRlY29yYXRlUHJvcGVydHkgPSB2b2lkIDA7XG5jb25zdCBTa2lwQWZ0ZXJQcm9wZXJ0eV8xID0gcmVxdWlyZShcIi4uL3Byb3BlcnR5L1NraXBBZnRlclByb3BlcnR5XCIpO1xuY29uc3QgVGltZW91dFByb3BlcnR5XzEgPSByZXF1aXJlKFwiLi4vcHJvcGVydHkvVGltZW91dFByb3BlcnR5XCIpO1xuY29uc3QgVW5iaWFzZWRQcm9wZXJ0eV8xID0gcmVxdWlyZShcIi4uL3Byb3BlcnR5L1VuYmlhc2VkUHJvcGVydHlcIik7XG5jb25zdCBJZ25vcmVFcXVhbFZhbHVlc1Byb3BlcnR5XzEgPSByZXF1aXJlKFwiLi4vcHJvcGVydHkvSWdub3JlRXF1YWxWYWx1ZXNQcm9wZXJ0eVwiKTtcbmZ1bmN0aW9uIGRlY29yYXRlUHJvcGVydHkocmF3UHJvcGVydHksIHFQYXJhbXMpIHtcbiAgICBsZXQgcHJvcCA9IHJhd1Byb3BlcnR5O1xuICAgIGlmIChyYXdQcm9wZXJ0eS5pc0FzeW5jKCkgJiYgcVBhcmFtcy50aW1lb3V0ICE9IG51bGwpIHtcbiAgICAgICAgcHJvcCA9IG5ldyBUaW1lb3V0UHJvcGVydHlfMS5UaW1lb3V0UHJvcGVydHkocHJvcCwgcVBhcmFtcy50aW1lb3V0KTtcbiAgICB9XG4gICAgaWYgKHFQYXJhbXMudW5iaWFzZWQpIHtcbiAgICAgICAgcHJvcCA9IG5ldyBVbmJpYXNlZFByb3BlcnR5XzEuVW5iaWFzZWRQcm9wZXJ0eShwcm9wKTtcbiAgICB9XG4gICAgaWYgKHFQYXJhbXMuc2tpcEFsbEFmdGVyVGltZUxpbWl0ICE9IG51bGwpIHtcbiAgICAgICAgcHJvcCA9IG5ldyBTa2lwQWZ0ZXJQcm9wZXJ0eV8xLlNraXBBZnRlclByb3BlcnR5KHByb3AsIERhdGUubm93LCBxUGFyYW1zLnNraXBBbGxBZnRlclRpbWVMaW1pdCwgZmFsc2UpO1xuICAgIH1cbiAgICBpZiAocVBhcmFtcy5pbnRlcnJ1cHRBZnRlclRpbWVMaW1pdCAhPSBudWxsKSB7XG4gICAgICAgIHByb3AgPSBuZXcgU2tpcEFmdGVyUHJvcGVydHlfMS5Ta2lwQWZ0ZXJQcm9wZXJ0eShwcm9wLCBEYXRlLm5vdywgcVBhcmFtcy5pbnRlcnJ1cHRBZnRlclRpbWVMaW1pdCwgdHJ1ZSk7XG4gICAgfVxuICAgIGlmIChxUGFyYW1zLnNraXBFcXVhbFZhbHVlcykge1xuICAgICAgICBwcm9wID0gbmV3IElnbm9yZUVxdWFsVmFsdWVzUHJvcGVydHlfMS5JZ25vcmVFcXVhbFZhbHVlc1Byb3BlcnR5KHByb3AsIHRydWUpO1xuICAgIH1cbiAgICBpZiAocVBhcmFtcy5pZ25vcmVFcXVhbFZhbHVlcykge1xuICAgICAgICBwcm9wID0gbmV3IElnbm9yZUVxdWFsVmFsdWVzUHJvcGVydHlfMS5JZ25vcmVFcXVhbFZhbHVlc1Byb3BlcnR5KHByb3AsIGZhbHNlKTtcbiAgICB9XG4gICAgcmV0dXJuIHByb3A7XG59XG5leHBvcnRzLmRlY29yYXRlUHJvcGVydHkgPSBkZWNvcmF0ZVByb3BlcnR5O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmFzc2VydCA9IGV4cG9ydHMuY2hlY2sgPSB2b2lkIDA7XG5jb25zdCBTdHJlYW1fMSA9IHJlcXVpcmUoXCIuLi8uLi9zdHJlYW0vU3RyZWFtXCIpO1xuY29uc3QgU2hyaW5rYWJsZV8xID0gcmVxdWlyZShcIi4uL2FyYml0cmFyeS9kZWZpbml0aW9uL1Nocmlua2FibGVcIik7XG5jb25zdCBHbG9iYWxQYXJhbWV0ZXJzXzEgPSByZXF1aXJlKFwiLi9jb25maWd1cmF0aW9uL0dsb2JhbFBhcmFtZXRlcnNcIik7XG5jb25zdCBRdWFsaWZpZWRQYXJhbWV0ZXJzXzEgPSByZXF1aXJlKFwiLi9jb25maWd1cmF0aW9uL1F1YWxpZmllZFBhcmFtZXRlcnNcIik7XG5jb25zdCBEZWNvcmF0ZVByb3BlcnR5XzEgPSByZXF1aXJlKFwiLi9EZWNvcmF0ZVByb3BlcnR5XCIpO1xuY29uc3QgUnVubmVySXRlcmF0b3JfMSA9IHJlcXVpcmUoXCIuL1J1bm5lckl0ZXJhdG9yXCIpO1xuY29uc3QgU291cmNlVmFsdWVzSXRlcmF0b3JfMSA9IHJlcXVpcmUoXCIuL1NvdXJjZVZhbHVlc0l0ZXJhdG9yXCIpO1xuY29uc3QgVG9zc2VyXzEgPSByZXF1aXJlKFwiLi9Ub3NzZXJcIik7XG5jb25zdCBQYXRoV2Fsa2VyXzEgPSByZXF1aXJlKFwiLi91dGlscy9QYXRoV2Fsa2VyXCIpO1xuY29uc3QgUnVuRGV0YWlsc0Zvcm1hdHRlcl8xID0gcmVxdWlyZShcIi4vdXRpbHMvUnVuRGV0YWlsc0Zvcm1hdHRlclwiKTtcbmZ1bmN0aW9uIHJ1bkl0KHByb3BlcnR5LCBzb3VyY2VWYWx1ZXMsIHZlcmJvc2UsIGludGVycnVwdGVkQXNGYWlsdXJlKSB7XG4gICAgY29uc3QgcnVubmVyID0gbmV3IFJ1bm5lckl0ZXJhdG9yXzEuUnVubmVySXRlcmF0b3Ioc291cmNlVmFsdWVzLCB2ZXJib3NlLCBpbnRlcnJ1cHRlZEFzRmFpbHVyZSk7XG4gICAgZm9yIChjb25zdCB2IG9mIHJ1bm5lcikge1xuICAgICAgICBjb25zdCBvdXQgPSBwcm9wZXJ0eS5ydW4odik7XG4gICAgICAgIHJ1bm5lci5oYW5kbGVSZXN1bHQob3V0KTtcbiAgICB9XG4gICAgcmV0dXJuIHJ1bm5lci5ydW5FeGVjdXRpb247XG59XG5hc3luYyBmdW5jdGlvbiBhc3luY1J1bkl0KHByb3BlcnR5LCBzb3VyY2VWYWx1ZXMsIHZlcmJvc2UsIGludGVycnVwdGVkQXNGYWlsdXJlKSB7XG4gICAgY29uc3QgcnVubmVyID0gbmV3IFJ1bm5lckl0ZXJhdG9yXzEuUnVubmVySXRlcmF0b3Ioc291cmNlVmFsdWVzLCB2ZXJib3NlLCBpbnRlcnJ1cHRlZEFzRmFpbHVyZSk7XG4gICAgZm9yIChjb25zdCB2IG9mIHJ1bm5lcikge1xuICAgICAgICBjb25zdCBvdXQgPSBhd2FpdCBwcm9wZXJ0eS5ydW4odik7XG4gICAgICAgIHJ1bm5lci5oYW5kbGVSZXN1bHQob3V0KTtcbiAgICB9XG4gICAgcmV0dXJuIHJ1bm5lci5ydW5FeGVjdXRpb247XG59XG5mdW5jdGlvbiBydW5uZXJQYXRoV2Fsa2VyKHZhbHVlUHJvZHVjZXJzLCBwYXRoKSB7XG4gICAgY29uc3QgcGF0aFBvaW50cyA9IHBhdGguc3BsaXQoJzonKTtcbiAgICBjb25zdCBwYXRoU3RyZWFtID0gU3RyZWFtXzEuc3RyZWFtKHZhbHVlUHJvZHVjZXJzKVxuICAgICAgICAuZHJvcChwYXRoUG9pbnRzLmxlbmd0aCA+IDAgPyArcGF0aFBvaW50c1swXSA6IDApXG4gICAgICAgIC5tYXAoKHByb2R1Y2VyKSA9PiBwcm9kdWNlcigpKTtcbiAgICBjb25zdCBhZGFwdGVkUGF0aCA9IFsnMCcsIC4uLnBhdGhQb2ludHMuc2xpY2UoMSldLmpvaW4oJzonKTtcbiAgICByZXR1cm4gU3RyZWFtXzEuc3RyZWFtKFBhdGhXYWxrZXJfMS5wYXRoV2FsayhhZGFwdGVkUGF0aCwgcGF0aFN0cmVhbSkpLm1hcCgodikgPT4gKCkgPT4gdik7XG59XG5mdW5jdGlvbiBidWlsZEluaXRpYWxWYWx1ZXModmFsdWVQcm9kdWNlcnMsIHFQYXJhbXMpIHtcbiAgICBjb25zdCByYXdWYWx1ZXMgPSBxUGFyYW1zLnBhdGgubGVuZ3RoID09PSAwID8gU3RyZWFtXzEuc3RyZWFtKHZhbHVlUHJvZHVjZXJzKSA6IHJ1bm5lclBhdGhXYWxrZXIodmFsdWVQcm9kdWNlcnMsIHFQYXJhbXMucGF0aCk7XG4gICAgaWYgKCFxUGFyYW1zLmVuZE9uRmFpbHVyZSlcbiAgICAgICAgcmV0dXJuIHJhd1ZhbHVlcztcbiAgICByZXR1cm4gcmF3VmFsdWVzLm1hcCgoc2hyaW5rYWJsZUdlbikgPT4ge1xuICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgcyA9IHNocmlua2FibGVHZW4oKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgU2hyaW5rYWJsZV8xLlNocmlua2FibGUocy52YWx1ZV8pO1xuICAgICAgICB9O1xuICAgIH0pO1xufVxuZnVuY3Rpb24gY2hlY2socmF3UHJvcGVydHksIHBhcmFtcykge1xuICAgIGlmIChyYXdQcm9wZXJ0eSA9PSBudWxsIHx8IHJhd1Byb3BlcnR5LmdlbmVyYXRlID09IG51bGwpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBwcm9wZXJ0eSBlbmNvdW50ZXJlZCwgcGxlYXNlIHVzZSBhIHZhbGlkIHByb3BlcnR5Jyk7XG4gICAgaWYgKHJhd1Byb3BlcnR5LnJ1biA9PSBudWxsKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgcHJvcGVydHkgZW5jb3VudGVyZWQsIHBsZWFzZSB1c2UgYSB2YWxpZCBwcm9wZXJ0eSBub3QgYW4gYXJiaXRyYXJ5Jyk7XG4gICAgY29uc3QgcVBhcmFtcyA9IFF1YWxpZmllZFBhcmFtZXRlcnNfMS5RdWFsaWZpZWRQYXJhbWV0ZXJzLnJlYWQoT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBHbG9iYWxQYXJhbWV0ZXJzXzEucmVhZENvbmZpZ3VyZUdsb2JhbCgpKSwgcGFyYW1zKSk7XG4gICAgaWYgKHFQYXJhbXMucmVwb3J0ZXIgIT09IG51bGwgJiYgcVBhcmFtcy5hc3luY1JlcG9ydGVyICE9PSBudWxsKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgcGFyYW1ldGVycyBlbmNvdW50ZXJlZCwgcmVwb3J0ZXIgYW5kIGFzeW5jUmVwb3J0ZXIgY2Fubm90IGJlIHNwZWNpZmllZCB0b2dldGhlcicpO1xuICAgIGlmIChxUGFyYW1zLmFzeW5jUmVwb3J0ZXIgIT09IG51bGwgJiYgIXJhd1Byb3BlcnR5LmlzQXN5bmMoKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHBhcmFtZXRlcnMgZW5jb3VudGVyZWQsIG9ubHkgYXN5bmNQcm9wZXJ0eSBjYW4gYmUgdXNlZCB3aGVuIGFzeW5jUmVwb3J0ZXIgc3BlY2lmaWVkJyk7XG4gICAgY29uc3QgcHJvcGVydHkgPSBEZWNvcmF0ZVByb3BlcnR5XzEuZGVjb3JhdGVQcm9wZXJ0eShyYXdQcm9wZXJ0eSwgcVBhcmFtcyk7XG4gICAgY29uc3QgZ2VuZXJhdG9yID0gVG9zc2VyXzEudG9zcyhwcm9wZXJ0eSwgcVBhcmFtcy5zZWVkLCBxUGFyYW1zLnJhbmRvbVR5cGUsIHFQYXJhbXMuZXhhbXBsZXMpO1xuICAgIGNvbnN0IG1heEluaXRpYWxJdGVyYXRpb25zID0gcVBhcmFtcy5wYXRoLmluZGV4T2YoJzonKSA9PT0gLTEgPyBxUGFyYW1zLm51bVJ1bnMgOiAtMTtcbiAgICBjb25zdCBtYXhTa2lwcyA9IHFQYXJhbXMubnVtUnVucyAqIHFQYXJhbXMubWF4U2tpcHNQZXJSdW47XG4gICAgY29uc3QgaW5pdGlhbFZhbHVlcyA9IGJ1aWxkSW5pdGlhbFZhbHVlcyhnZW5lcmF0b3IsIHFQYXJhbXMpO1xuICAgIGNvbnN0IHNvdXJjZVZhbHVlcyA9IG5ldyBTb3VyY2VWYWx1ZXNJdGVyYXRvcl8xLlNvdXJjZVZhbHVlc0l0ZXJhdG9yKGluaXRpYWxWYWx1ZXMsIG1heEluaXRpYWxJdGVyYXRpb25zLCBtYXhTa2lwcyk7XG4gICAgcmV0dXJuIHByb3BlcnR5LmlzQXN5bmMoKVxuICAgICAgICA/IGFzeW5jUnVuSXQocHJvcGVydHksIHNvdXJjZVZhbHVlcywgcVBhcmFtcy52ZXJib3NlLCBxUGFyYW1zLm1hcmtJbnRlcnJ1cHRBc0ZhaWx1cmUpLnRoZW4oKGUpID0+IGUudG9SdW5EZXRhaWxzKHFQYXJhbXMuc2VlZCwgcVBhcmFtcy5wYXRoLCBtYXhTa2lwcywgcVBhcmFtcykpXG4gICAgICAgIDogcnVuSXQocHJvcGVydHksIHNvdXJjZVZhbHVlcywgcVBhcmFtcy52ZXJib3NlLCBxUGFyYW1zLm1hcmtJbnRlcnJ1cHRBc0ZhaWx1cmUpLnRvUnVuRGV0YWlscyhxUGFyYW1zLnNlZWQsIHFQYXJhbXMucGF0aCwgbWF4U2tpcHMsIHFQYXJhbXMpO1xufVxuZXhwb3J0cy5jaGVjayA9IGNoZWNrO1xuZnVuY3Rpb24gYXNzZXJ0KHByb3BlcnR5LCBwYXJhbXMpIHtcbiAgICBjb25zdCBvdXQgPSBjaGVjayhwcm9wZXJ0eSwgcGFyYW1zKTtcbiAgICBpZiAocHJvcGVydHkuaXNBc3luYygpKVxuICAgICAgICByZXR1cm4gb3V0LnRoZW4oUnVuRGV0YWlsc0Zvcm1hdHRlcl8xLmFzeW5jUmVwb3J0UnVuRGV0YWlscyk7XG4gICAgZWxzZVxuICAgICAgICBSdW5EZXRhaWxzRm9ybWF0dGVyXzEucmVwb3J0UnVuRGV0YWlscyhvdXQpO1xufVxuZXhwb3J0cy5hc3NlcnQgPSBhc3NlcnQ7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuUnVubmVySXRlcmF0b3IgPSB2b2lkIDA7XG5jb25zdCBSdW5FeGVjdXRpb25fMSA9IHJlcXVpcmUoXCIuL3JlcG9ydGVyL1J1bkV4ZWN1dGlvblwiKTtcbmNsYXNzIFJ1bm5lckl0ZXJhdG9yIHtcbiAgICBjb25zdHJ1Y3Rvcihzb3VyY2VWYWx1ZXMsIHZlcmJvc2UsIGludGVycnVwdGVkQXNGYWlsdXJlKSB7XG4gICAgICAgIHRoaXMuc291cmNlVmFsdWVzID0gc291cmNlVmFsdWVzO1xuICAgICAgICB0aGlzLnJ1bkV4ZWN1dGlvbiA9IG5ldyBSdW5FeGVjdXRpb25fMS5SdW5FeGVjdXRpb24odmVyYm9zZSwgaW50ZXJydXB0ZWRBc0ZhaWx1cmUpO1xuICAgICAgICB0aGlzLmN1cnJlbnRJZHggPSAtMTtcbiAgICAgICAgdGhpcy5uZXh0VmFsdWVzID0gc291cmNlVmFsdWVzO1xuICAgIH1cbiAgICBbU3ltYm9sLml0ZXJhdG9yXSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIG5leHQoKSB7XG4gICAgICAgIGNvbnN0IG5leHRWYWx1ZSA9IHRoaXMubmV4dFZhbHVlcy5uZXh0KCk7XG4gICAgICAgIGlmIChuZXh0VmFsdWUuZG9uZSB8fCB0aGlzLnJ1bkV4ZWN1dGlvbi5pbnRlcnJ1cHRlZCkge1xuICAgICAgICAgICAgcmV0dXJuIHsgZG9uZTogdHJ1ZSwgdmFsdWU6IHVuZGVmaW5lZCB9O1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY3VycmVudFNocmlua2FibGUgPSBuZXh0VmFsdWUudmFsdWU7XG4gICAgICAgICsrdGhpcy5jdXJyZW50SWR4O1xuICAgICAgICByZXR1cm4geyBkb25lOiBmYWxzZSwgdmFsdWU6IG5leHRWYWx1ZS52YWx1ZS52YWx1ZV8gfTtcbiAgICB9XG4gICAgaGFuZGxlUmVzdWx0KHJlc3VsdCkge1xuICAgICAgICBpZiAocmVzdWx0ICE9IG51bGwgJiYgdHlwZW9mIHJlc3VsdCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHRoaXMucnVuRXhlY3V0aW9uLmZhaWwodGhpcy5jdXJyZW50U2hyaW5rYWJsZS52YWx1ZV8sIHRoaXMuY3VycmVudElkeCwgcmVzdWx0KTtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudElkeCA9IC0xO1xuICAgICAgICAgICAgdGhpcy5uZXh0VmFsdWVzID0gdGhpcy5jdXJyZW50U2hyaW5rYWJsZS5zaHJpbmsoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChyZXN1bHQgIT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKCFyZXN1bHQuaW50ZXJydXB0RXhlY3V0aW9uKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5ydW5FeGVjdXRpb24uc2tpcCh0aGlzLmN1cnJlbnRTaHJpbmthYmxlLnZhbHVlXyk7XG4gICAgICAgICAgICAgICAgdGhpcy5zb3VyY2VWYWx1ZXMuc2tpcHBlZE9uZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5ydW5FeGVjdXRpb24uaW50ZXJydXB0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnJ1bkV4ZWN1dGlvbi5zdWNjZXNzKHRoaXMuY3VycmVudFNocmlua2FibGUudmFsdWVfKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuUnVubmVySXRlcmF0b3IgPSBSdW5uZXJJdGVyYXRvcjtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5zdGF0aXN0aWNzID0gZXhwb3J0cy5zYW1wbGUgPSB2b2lkIDA7XG5jb25zdCBTdHJlYW1fMSA9IHJlcXVpcmUoXCIuLi8uLi9zdHJlYW0vU3RyZWFtXCIpO1xuY29uc3QgUHJvcGVydHlfZ2VuZXJpY18xID0gcmVxdWlyZShcIi4uL3Byb3BlcnR5L1Byb3BlcnR5LmdlbmVyaWNcIik7XG5jb25zdCBVbmJpYXNlZFByb3BlcnR5XzEgPSByZXF1aXJlKFwiLi4vcHJvcGVydHkvVW5iaWFzZWRQcm9wZXJ0eVwiKTtcbmNvbnN0IEdsb2JhbFBhcmFtZXRlcnNfMSA9IHJlcXVpcmUoXCIuL2NvbmZpZ3VyYXRpb24vR2xvYmFsUGFyYW1ldGVyc1wiKTtcbmNvbnN0IFF1YWxpZmllZFBhcmFtZXRlcnNfMSA9IHJlcXVpcmUoXCIuL2NvbmZpZ3VyYXRpb24vUXVhbGlmaWVkUGFyYW1ldGVyc1wiKTtcbmNvbnN0IFRvc3Nlcl8xID0gcmVxdWlyZShcIi4vVG9zc2VyXCIpO1xuY29uc3QgUGF0aFdhbGtlcl8xID0gcmVxdWlyZShcIi4vdXRpbHMvUGF0aFdhbGtlclwiKTtcbmZ1bmN0aW9uIHRvUHJvcGVydHkoZ2VuZXJhdG9yLCBxUGFyYW1zKSB7XG4gICAgY29uc3QgcHJvcCA9ICFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZ2VuZXJhdG9yLCAnaXNBc3luYycpXG4gICAgICAgID8gbmV3IFByb3BlcnR5X2dlbmVyaWNfMS5Qcm9wZXJ0eShnZW5lcmF0b3IsICgpID0+IHRydWUpXG4gICAgICAgIDogZ2VuZXJhdG9yO1xuICAgIHJldHVybiBxUGFyYW1zLnVuYmlhc2VkID09PSB0cnVlID8gbmV3IFVuYmlhc2VkUHJvcGVydHlfMS5VbmJpYXNlZFByb3BlcnR5KHByb3ApIDogcHJvcDtcbn1cbmZ1bmN0aW9uIHN0cmVhbVNhbXBsZShnZW5lcmF0b3IsIHBhcmFtcykge1xuICAgIGNvbnN0IGV4dGVuZGVkUGFyYW1zID0gdHlwZW9mIHBhcmFtcyA9PT0gJ251bWJlcidcbiAgICAgICAgPyBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIEdsb2JhbFBhcmFtZXRlcnNfMS5yZWFkQ29uZmlndXJlR2xvYmFsKCkpLCB7IG51bVJ1bnM6IHBhcmFtcyB9KSA6IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgR2xvYmFsUGFyYW1ldGVyc18xLnJlYWRDb25maWd1cmVHbG9iYWwoKSksIHBhcmFtcyk7XG4gICAgY29uc3QgcVBhcmFtcyA9IFF1YWxpZmllZFBhcmFtZXRlcnNfMS5RdWFsaWZpZWRQYXJhbWV0ZXJzLnJlYWQoZXh0ZW5kZWRQYXJhbXMpO1xuICAgIGNvbnN0IHRvc3NlZFZhbHVlcyA9IFN0cmVhbV8xLnN0cmVhbShUb3NzZXJfMS50b3NzKHRvUHJvcGVydHkoZ2VuZXJhdG9yLCBxUGFyYW1zKSwgcVBhcmFtcy5zZWVkLCBxUGFyYW1zLnJhbmRvbVR5cGUsIHFQYXJhbXMuZXhhbXBsZXMpKTtcbiAgICBpZiAocVBhcmFtcy5wYXRoLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gdG9zc2VkVmFsdWVzLnRha2UocVBhcmFtcy5udW1SdW5zKS5tYXAoKHMpID0+IHMoKS52YWx1ZV8pO1xuICAgIH1cbiAgICByZXR1cm4gU3RyZWFtXzEuc3RyZWFtKFBhdGhXYWxrZXJfMS5wYXRoV2FsayhxUGFyYW1zLnBhdGgsIHRvc3NlZFZhbHVlcy5tYXAoKHMpID0+IHMoKSkpKVxuICAgICAgICAudGFrZShxUGFyYW1zLm51bVJ1bnMpXG4gICAgICAgIC5tYXAoKHMpID0+IHMudmFsdWVfKTtcbn1cbmZ1bmN0aW9uIHNhbXBsZShnZW5lcmF0b3IsIHBhcmFtcykge1xuICAgIHJldHVybiBbLi4uc3RyZWFtU2FtcGxlKGdlbmVyYXRvciwgcGFyYW1zKV07XG59XG5leHBvcnRzLnNhbXBsZSA9IHNhbXBsZTtcbmZ1bmN0aW9uIHN0YXRpc3RpY3MoZ2VuZXJhdG9yLCBjbGFzc2lmeSwgcGFyYW1zKSB7XG4gICAgY29uc3QgZXh0ZW5kZWRQYXJhbXMgPSB0eXBlb2YgcGFyYW1zID09PSAnbnVtYmVyJ1xuICAgICAgICA/IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgR2xvYmFsUGFyYW1ldGVyc18xLnJlYWRDb25maWd1cmVHbG9iYWwoKSksIHsgbnVtUnVuczogcGFyYW1zIH0pIDogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBHbG9iYWxQYXJhbWV0ZXJzXzEucmVhZENvbmZpZ3VyZUdsb2JhbCgpKSwgcGFyYW1zKTtcbiAgICBjb25zdCBxUGFyYW1zID0gUXVhbGlmaWVkUGFyYW1ldGVyc18xLlF1YWxpZmllZFBhcmFtZXRlcnMucmVhZChleHRlbmRlZFBhcmFtcyk7XG4gICAgY29uc3QgcmVjb3JkZWQgPSB7fTtcbiAgICBmb3IgKGNvbnN0IGcgb2Ygc3RyZWFtU2FtcGxlKGdlbmVyYXRvciwgcGFyYW1zKSkge1xuICAgICAgICBjb25zdCBvdXQgPSBjbGFzc2lmeShnKTtcbiAgICAgICAgY29uc3QgY2F0ZWdvcmllcyA9IEFycmF5LmlzQXJyYXkob3V0KSA/IG91dCA6IFtvdXRdO1xuICAgICAgICBmb3IgKGNvbnN0IGMgb2YgY2F0ZWdvcmllcykge1xuICAgICAgICAgICAgcmVjb3JkZWRbY10gPSAocmVjb3JkZWRbY10gfHwgMCkgKyAxO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGRhdGEgPSBPYmplY3QuZW50cmllcyhyZWNvcmRlZClcbiAgICAgICAgLnNvcnQoKGEsIGIpID0+IGJbMV0gLSBhWzFdKVxuICAgICAgICAubWFwKChpKSA9PiBbaVswXSwgYCR7KChpWzFdICogMTAwLjApIC8gcVBhcmFtcy5udW1SdW5zKS50b0ZpeGVkKDIpfSVgXSk7XG4gICAgY29uc3QgbG9uZ2VzdE5hbWUgPSBkYXRhLm1hcCgoaSkgPT4gaVswXS5sZW5ndGgpLnJlZHVjZSgocCwgYykgPT4gTWF0aC5tYXgocCwgYyksIDApO1xuICAgIGNvbnN0IGxvbmdlc3RQZXJjZW50ID0gZGF0YS5tYXAoKGkpID0+IGlbMV0ubGVuZ3RoKS5yZWR1Y2UoKHAsIGMpID0+IE1hdGgubWF4KHAsIGMpLCAwKTtcbiAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgZGF0YSkge1xuICAgICAgICBxUGFyYW1zLmxvZ2dlcihgJHtpdGVtWzBdLnBhZEVuZChsb25nZXN0TmFtZSwgJy4nKX0uLiR7aXRlbVsxXS5wYWRTdGFydChsb25nZXN0UGVyY2VudCwgJy4nKX1gKTtcbiAgICB9XG59XG5leHBvcnRzLnN0YXRpc3RpY3MgPSBzdGF0aXN0aWNzO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlNvdXJjZVZhbHVlc0l0ZXJhdG9yID0gdm9pZCAwO1xuY2xhc3MgU291cmNlVmFsdWVzSXRlcmF0b3Ige1xuICAgIGNvbnN0cnVjdG9yKGluaXRpYWxWYWx1ZXMsIG1heEluaXRpYWxJdGVyYXRpb25zLCByZW1haW5pbmdTa2lwcykge1xuICAgICAgICB0aGlzLmluaXRpYWxWYWx1ZXMgPSBpbml0aWFsVmFsdWVzO1xuICAgICAgICB0aGlzLm1heEluaXRpYWxJdGVyYXRpb25zID0gbWF4SW5pdGlhbEl0ZXJhdGlvbnM7XG4gICAgICAgIHRoaXMucmVtYWluaW5nU2tpcHMgPSByZW1haW5pbmdTa2lwcztcbiAgICB9XG4gICAgW1N5bWJvbC5pdGVyYXRvcl0oKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBuZXh0KCkge1xuICAgICAgICBpZiAoLS10aGlzLm1heEluaXRpYWxJdGVyYXRpb25zICE9PSAtMSAmJiB0aGlzLnJlbWFpbmluZ1NraXBzID49IDApIHtcbiAgICAgICAgICAgIGNvbnN0IG4gPSB0aGlzLmluaXRpYWxWYWx1ZXMubmV4dCgpO1xuICAgICAgICAgICAgaWYgKCFuLmRvbmUpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IG4udmFsdWUoKSwgZG9uZTogZmFsc2UgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyB2YWx1ZTogdW5kZWZpbmVkLCBkb25lOiB0cnVlIH07XG4gICAgfVxuICAgIHNraXBwZWRPbmUoKSB7XG4gICAgICAgIC0tdGhpcy5yZW1haW5pbmdTa2lwcztcbiAgICAgICAgKyt0aGlzLm1heEluaXRpYWxJdGVyYXRpb25zO1xuICAgIH1cbn1cbmV4cG9ydHMuU291cmNlVmFsdWVzSXRlcmF0b3IgPSBTb3VyY2VWYWx1ZXNJdGVyYXRvcjtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy50b3NzID0gdm9pZCAwO1xuY29uc3QgcHVyZV9yYW5kXzEgPSByZXF1aXJlKFwicHVyZS1yYW5kXCIpO1xuY29uc3QgUmFuZG9tXzEgPSByZXF1aXJlKFwiLi4vLi4vcmFuZG9tL2dlbmVyYXRvci9SYW5kb21cIik7XG5jb25zdCBTaHJpbmthYmxlXzEgPSByZXF1aXJlKFwiLi4vYXJiaXRyYXJ5L2RlZmluaXRpb24vU2hyaW5rYWJsZVwiKTtcbmNvbnN0IFB1cmVSYW5kb21fMSA9IHJlcXVpcmUoXCIuLi8uLi9yYW5kb20vZ2VuZXJhdG9yL1B1cmVSYW5kb21cIik7XG5mdW5jdGlvbiBsYXp5R2VuZXJhdGUoZ2VuZXJhdG9yLCBybmcsIGlkeCkge1xuICAgIHJldHVybiAoKSA9PiBnZW5lcmF0b3IuZ2VuZXJhdGUobmV3IFJhbmRvbV8xLlJhbmRvbShybmcpLCBpZHgpO1xufVxuZnVuY3Rpb24qIHRvc3MoZ2VuZXJhdG9yLCBzZWVkLCByYW5kb20sIGV4YW1wbGVzKSB7XG4gICAgeWllbGQqIGV4YW1wbGVzLm1hcCgoZSkgPT4gKCkgPT4gbmV3IFNocmlua2FibGVfMS5TaHJpbmthYmxlKGUpKTtcbiAgICBsZXQgaWR4ID0gMDtcbiAgICBsZXQgcm5nID0gUHVyZVJhbmRvbV8xLmNvbnZlcnRUb1JhbmRvbUdlbmVyYXRvcihyYW5kb20oc2VlZCkpO1xuICAgIGZvciAoOzspIHtcbiAgICAgICAgcm5nID0gcm5nLmp1bXAgPyBybmcuanVtcCgpIDogcHVyZV9yYW5kXzEuc2tpcE4ocm5nLCA0Mik7XG4gICAgICAgIHlpZWxkIGxhenlHZW5lcmF0ZShnZW5lcmF0b3IsIHJuZywgaWR4KyspO1xuICAgIH1cbn1cbmV4cG9ydHMudG9zcyA9IHRvc3M7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMucmVzZXRDb25maWd1cmVHbG9iYWwgPSBleHBvcnRzLnJlYWRDb25maWd1cmVHbG9iYWwgPSBleHBvcnRzLmNvbmZpZ3VyZUdsb2JhbCA9IHZvaWQgMDtcbmxldCBnbG9iYWxQYXJhbWV0ZXJzID0ge307XG5mdW5jdGlvbiBjb25maWd1cmVHbG9iYWwocGFyYW1ldGVycykge1xuICAgIGdsb2JhbFBhcmFtZXRlcnMgPSBwYXJhbWV0ZXJzO1xufVxuZXhwb3J0cy5jb25maWd1cmVHbG9iYWwgPSBjb25maWd1cmVHbG9iYWw7XG5mdW5jdGlvbiByZWFkQ29uZmlndXJlR2xvYmFsKCkge1xuICAgIHJldHVybiBnbG9iYWxQYXJhbWV0ZXJzO1xufVxuZXhwb3J0cy5yZWFkQ29uZmlndXJlR2xvYmFsID0gcmVhZENvbmZpZ3VyZUdsb2JhbDtcbmZ1bmN0aW9uIHJlc2V0Q29uZmlndXJlR2xvYmFsKCkge1xuICAgIGdsb2JhbFBhcmFtZXRlcnMgPSB7fTtcbn1cbmV4cG9ydHMucmVzZXRDb25maWd1cmVHbG9iYWwgPSByZXNldENvbmZpZ3VyZUdsb2JhbDtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5RdWFsaWZpZWRQYXJhbWV0ZXJzID0gdm9pZCAwO1xuY29uc3QgcHVyZV9yYW5kXzEgPSByZXF1aXJlKFwicHVyZS1yYW5kXCIpO1xuY29uc3QgVmVyYm9zaXR5TGV2ZWxfMSA9IHJlcXVpcmUoXCIuL1ZlcmJvc2l0eUxldmVsXCIpO1xuY2xhc3MgUXVhbGlmaWVkUGFyYW1ldGVycyB7XG4gICAgY29uc3RydWN0b3Iob3ApIHtcbiAgICAgICAgY29uc3QgcCA9IG9wIHx8IHt9O1xuICAgICAgICB0aGlzLnNlZWQgPSBRdWFsaWZpZWRQYXJhbWV0ZXJzLnJlYWRTZWVkKHApO1xuICAgICAgICB0aGlzLnJhbmRvbVR5cGUgPSBRdWFsaWZpZWRQYXJhbWV0ZXJzLnJlYWRSYW5kb21UeXBlKHApO1xuICAgICAgICB0aGlzLm51bVJ1bnMgPSBRdWFsaWZpZWRQYXJhbWV0ZXJzLnJlYWROdW1SdW5zKHApO1xuICAgICAgICB0aGlzLnZlcmJvc2UgPSBRdWFsaWZpZWRQYXJhbWV0ZXJzLnJlYWRWZXJib3NlKHApO1xuICAgICAgICB0aGlzLm1heFNraXBzUGVyUnVuID0gUXVhbGlmaWVkUGFyYW1ldGVycy5yZWFkT3JEZWZhdWx0KHAsICdtYXhTa2lwc1BlclJ1bicsIDEwMCk7XG4gICAgICAgIHRoaXMudGltZW91dCA9IFF1YWxpZmllZFBhcmFtZXRlcnMucmVhZE9yRGVmYXVsdChwLCAndGltZW91dCcsIG51bGwpO1xuICAgICAgICB0aGlzLnNraXBBbGxBZnRlclRpbWVMaW1pdCA9IFF1YWxpZmllZFBhcmFtZXRlcnMucmVhZE9yRGVmYXVsdChwLCAnc2tpcEFsbEFmdGVyVGltZUxpbWl0JywgbnVsbCk7XG4gICAgICAgIHRoaXMuaW50ZXJydXB0QWZ0ZXJUaW1lTGltaXQgPSBRdWFsaWZpZWRQYXJhbWV0ZXJzLnJlYWRPckRlZmF1bHQocCwgJ2ludGVycnVwdEFmdGVyVGltZUxpbWl0JywgbnVsbCk7XG4gICAgICAgIHRoaXMubWFya0ludGVycnVwdEFzRmFpbHVyZSA9IFF1YWxpZmllZFBhcmFtZXRlcnMucmVhZEJvb2xlYW4ocCwgJ21hcmtJbnRlcnJ1cHRBc0ZhaWx1cmUnKTtcbiAgICAgICAgdGhpcy5za2lwRXF1YWxWYWx1ZXMgPSBRdWFsaWZpZWRQYXJhbWV0ZXJzLnJlYWRCb29sZWFuKHAsICdza2lwRXF1YWxWYWx1ZXMnKTtcbiAgICAgICAgdGhpcy5pZ25vcmVFcXVhbFZhbHVlcyA9IFF1YWxpZmllZFBhcmFtZXRlcnMucmVhZEJvb2xlYW4ocCwgJ2lnbm9yZUVxdWFsVmFsdWVzJyk7XG4gICAgICAgIHRoaXMubG9nZ2VyID0gUXVhbGlmaWVkUGFyYW1ldGVycy5yZWFkT3JEZWZhdWx0KHAsICdsb2dnZXInLCAodikgPT4ge1xuICAgICAgICAgICAgY29uc29sZS5sb2codik7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnBhdGggPSBRdWFsaWZpZWRQYXJhbWV0ZXJzLnJlYWRPckRlZmF1bHQocCwgJ3BhdGgnLCAnJyk7XG4gICAgICAgIHRoaXMudW5iaWFzZWQgPSBRdWFsaWZpZWRQYXJhbWV0ZXJzLnJlYWRCb29sZWFuKHAsICd1bmJpYXNlZCcpO1xuICAgICAgICB0aGlzLmV4YW1wbGVzID0gUXVhbGlmaWVkUGFyYW1ldGVycy5yZWFkT3JEZWZhdWx0KHAsICdleGFtcGxlcycsIFtdKTtcbiAgICAgICAgdGhpcy5lbmRPbkZhaWx1cmUgPSBRdWFsaWZpZWRQYXJhbWV0ZXJzLnJlYWRCb29sZWFuKHAsICdlbmRPbkZhaWx1cmUnKTtcbiAgICAgICAgdGhpcy5yZXBvcnRlciA9IFF1YWxpZmllZFBhcmFtZXRlcnMucmVhZE9yRGVmYXVsdChwLCAncmVwb3J0ZXInLCBudWxsKTtcbiAgICAgICAgdGhpcy5hc3luY1JlcG9ydGVyID0gUXVhbGlmaWVkUGFyYW1ldGVycy5yZWFkT3JEZWZhdWx0KHAsICdhc3luY1JlcG9ydGVyJywgbnVsbCk7XG4gICAgfVxuICAgIHRvUGFyYW1ldGVycygpIHtcbiAgICAgICAgY29uc3Qgb3JVbmRlZmluZWQgPSAodmFsdWUpID0+ICh2YWx1ZSAhPT0gbnVsbCA/IHZhbHVlIDogdW5kZWZpbmVkKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHNlZWQ6IHRoaXMuc2VlZCxcbiAgICAgICAgICAgIHJhbmRvbVR5cGU6IHRoaXMucmFuZG9tVHlwZSxcbiAgICAgICAgICAgIG51bVJ1bnM6IHRoaXMubnVtUnVucyxcbiAgICAgICAgICAgIG1heFNraXBzUGVyUnVuOiB0aGlzLm1heFNraXBzUGVyUnVuLFxuICAgICAgICAgICAgdGltZW91dDogb3JVbmRlZmluZWQodGhpcy50aW1lb3V0KSxcbiAgICAgICAgICAgIHNraXBBbGxBZnRlclRpbWVMaW1pdDogb3JVbmRlZmluZWQodGhpcy5za2lwQWxsQWZ0ZXJUaW1lTGltaXQpLFxuICAgICAgICAgICAgaW50ZXJydXB0QWZ0ZXJUaW1lTGltaXQ6IG9yVW5kZWZpbmVkKHRoaXMuaW50ZXJydXB0QWZ0ZXJUaW1lTGltaXQpLFxuICAgICAgICAgICAgbWFya0ludGVycnVwdEFzRmFpbHVyZTogdGhpcy5tYXJrSW50ZXJydXB0QXNGYWlsdXJlLFxuICAgICAgICAgICAgc2tpcEVxdWFsVmFsdWVzOiB0aGlzLnNraXBFcXVhbFZhbHVlcyxcbiAgICAgICAgICAgIGlnbm9yZUVxdWFsVmFsdWVzOiB0aGlzLmlnbm9yZUVxdWFsVmFsdWVzLFxuICAgICAgICAgICAgcGF0aDogdGhpcy5wYXRoLFxuICAgICAgICAgICAgbG9nZ2VyOiB0aGlzLmxvZ2dlcixcbiAgICAgICAgICAgIHVuYmlhc2VkOiB0aGlzLnVuYmlhc2VkLFxuICAgICAgICAgICAgdmVyYm9zZTogdGhpcy52ZXJib3NlLFxuICAgICAgICAgICAgZXhhbXBsZXM6IHRoaXMuZXhhbXBsZXMsXG4gICAgICAgICAgICBlbmRPbkZhaWx1cmU6IHRoaXMuZW5kT25GYWlsdXJlLFxuICAgICAgICAgICAgcmVwb3J0ZXI6IG9yVW5kZWZpbmVkKHRoaXMucmVwb3J0ZXIpLFxuICAgICAgICAgICAgYXN5bmNSZXBvcnRlcjogb3JVbmRlZmluZWQodGhpcy5hc3luY1JlcG9ydGVyKSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgc3RhdGljIHJlYWQob3ApIHtcbiAgICAgICAgcmV0dXJuIG5ldyBRdWFsaWZpZWRQYXJhbWV0ZXJzKG9wKTtcbiAgICB9XG59XG5leHBvcnRzLlF1YWxpZmllZFBhcmFtZXRlcnMgPSBRdWFsaWZpZWRQYXJhbWV0ZXJzO1xuUXVhbGlmaWVkUGFyYW1ldGVycy5yZWFkU2VlZCA9IChwKSA9PiB7XG4gICAgaWYgKHAuc2VlZCA9PSBudWxsKVxuICAgICAgICByZXR1cm4gRGF0ZS5ub3coKSBeIChNYXRoLnJhbmRvbSgpICogMHgxMDAwMDAwMDApO1xuICAgIGNvbnN0IHNlZWQzMiA9IHAuc2VlZCB8IDA7XG4gICAgaWYgKHAuc2VlZCA9PT0gc2VlZDMyKVxuICAgICAgICByZXR1cm4gc2VlZDMyO1xuICAgIGNvbnN0IGdhcCA9IHAuc2VlZCAtIHNlZWQzMjtcbiAgICByZXR1cm4gc2VlZDMyIF4gKGdhcCAqIDB4MTAwMDAwMDAwKTtcbn07XG5RdWFsaWZpZWRQYXJhbWV0ZXJzLnJlYWRSYW5kb21UeXBlID0gKHApID0+IHtcbiAgICBpZiAocC5yYW5kb21UeXBlID09IG51bGwpXG4gICAgICAgIHJldHVybiBwdXJlX3JhbmRfMS5kZWZhdWx0LnhvcnNoaWZ0MTI4cGx1cztcbiAgICBpZiAodHlwZW9mIHAucmFuZG9tVHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgc3dpdGNoIChwLnJhbmRvbVR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgJ21lcnNlbm5lJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gcHVyZV9yYW5kXzEuZGVmYXVsdC5tZXJzZW5uZTtcbiAgICAgICAgICAgIGNhc2UgJ2NvbmdydWVudGlhbCc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHB1cmVfcmFuZF8xLmRlZmF1bHQuY29uZ3J1ZW50aWFsO1xuICAgICAgICAgICAgY2FzZSAnY29uZ3J1ZW50aWFsMzInOlxuICAgICAgICAgICAgICAgIHJldHVybiBwdXJlX3JhbmRfMS5kZWZhdWx0LmNvbmdydWVudGlhbDMyO1xuICAgICAgICAgICAgY2FzZSAneG9yc2hpZnQxMjhwbHVzJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gcHVyZV9yYW5kXzEuZGVmYXVsdC54b3JzaGlmdDEyOHBsdXM7XG4gICAgICAgICAgICBjYXNlICd4b3Jvc2hpcm8xMjhwbHVzJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gcHVyZV9yYW5kXzEuZGVmYXVsdC54b3Jvc2hpcm8xMjhwbHVzO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgcmFuZG9tIHNwZWNpZmllZDogJyR7cC5yYW5kb21UeXBlfSdgKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcC5yYW5kb21UeXBlO1xufTtcblF1YWxpZmllZFBhcmFtZXRlcnMucmVhZE51bVJ1bnMgPSAocCkgPT4ge1xuICAgIGNvbnN0IGRlZmF1bHRWYWx1ZSA9IDEwMDtcbiAgICBpZiAocC5udW1SdW5zICE9IG51bGwpXG4gICAgICAgIHJldHVybiBwLm51bVJ1bnM7XG4gICAgaWYgKHAubnVtX3J1bnMgIT0gbnVsbClcbiAgICAgICAgcmV0dXJuIHAubnVtX3J1bnM7XG4gICAgcmV0dXJuIGRlZmF1bHRWYWx1ZTtcbn07XG5RdWFsaWZpZWRQYXJhbWV0ZXJzLnJlYWRWZXJib3NlID0gKHApID0+IHtcbiAgICBpZiAocC52ZXJib3NlID09IG51bGwpXG4gICAgICAgIHJldHVybiBWZXJib3NpdHlMZXZlbF8xLlZlcmJvc2l0eUxldmVsLk5vbmU7XG4gICAgaWYgKHR5cGVvZiBwLnZlcmJvc2UgPT09ICdib29sZWFuJykge1xuICAgICAgICByZXR1cm4gcC52ZXJib3NlID09PSB0cnVlID8gVmVyYm9zaXR5TGV2ZWxfMS5WZXJib3NpdHlMZXZlbC5WZXJib3NlIDogVmVyYm9zaXR5TGV2ZWxfMS5WZXJib3NpdHlMZXZlbC5Ob25lO1xuICAgIH1cbiAgICBpZiAocC52ZXJib3NlIDw9IFZlcmJvc2l0eUxldmVsXzEuVmVyYm9zaXR5TGV2ZWwuTm9uZSkge1xuICAgICAgICByZXR1cm4gVmVyYm9zaXR5TGV2ZWxfMS5WZXJib3NpdHlMZXZlbC5Ob25lO1xuICAgIH1cbiAgICBpZiAocC52ZXJib3NlID49IFZlcmJvc2l0eUxldmVsXzEuVmVyYm9zaXR5TGV2ZWwuVmVyeVZlcmJvc2UpIHtcbiAgICAgICAgcmV0dXJuIFZlcmJvc2l0eUxldmVsXzEuVmVyYm9zaXR5TGV2ZWwuVmVyeVZlcmJvc2U7XG4gICAgfVxuICAgIHJldHVybiBwLnZlcmJvc2UgfCAwO1xufTtcblF1YWxpZmllZFBhcmFtZXRlcnMucmVhZEJvb2xlYW4gPSAocCwga2V5KSA9PiBwW2tleV0gPT09IHRydWU7XG5RdWFsaWZpZWRQYXJhbWV0ZXJzLnJlYWRPckRlZmF1bHQgPSAocCwga2V5LCBkZWZhdWx0VmFsdWUpID0+IHtcbiAgICBjb25zdCB2YWx1ZSA9IHBba2V5XTtcbiAgICByZXR1cm4gdmFsdWUgIT0gbnVsbCA/IHZhbHVlIDogZGVmYXVsdFZhbHVlO1xufTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5WZXJib3NpdHlMZXZlbCA9IHZvaWQgMDtcbnZhciBWZXJib3NpdHlMZXZlbDtcbihmdW5jdGlvbiAoVmVyYm9zaXR5TGV2ZWwpIHtcbiAgICBWZXJib3NpdHlMZXZlbFtWZXJib3NpdHlMZXZlbFtcIk5vbmVcIl0gPSAwXSA9IFwiTm9uZVwiO1xuICAgIFZlcmJvc2l0eUxldmVsW1ZlcmJvc2l0eUxldmVsW1wiVmVyYm9zZVwiXSA9IDFdID0gXCJWZXJib3NlXCI7XG4gICAgVmVyYm9zaXR5TGV2ZWxbVmVyYm9zaXR5TGV2ZWxbXCJWZXJ5VmVyYm9zZVwiXSA9IDJdID0gXCJWZXJ5VmVyYm9zZVwiO1xufSkoVmVyYm9zaXR5TGV2ZWwgPSBleHBvcnRzLlZlcmJvc2l0eUxldmVsIHx8IChleHBvcnRzLlZlcmJvc2l0eUxldmVsID0ge30pKTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5FeGVjdXRpb25TdGF0dXMgPSB2b2lkIDA7XG52YXIgRXhlY3V0aW9uU3RhdHVzO1xuKGZ1bmN0aW9uIChFeGVjdXRpb25TdGF0dXMpIHtcbiAgICBFeGVjdXRpb25TdGF0dXNbRXhlY3V0aW9uU3RhdHVzW1wiU3VjY2Vzc1wiXSA9IDBdID0gXCJTdWNjZXNzXCI7XG4gICAgRXhlY3V0aW9uU3RhdHVzW0V4ZWN1dGlvblN0YXR1c1tcIlNraXBwZWRcIl0gPSAtMV0gPSBcIlNraXBwZWRcIjtcbiAgICBFeGVjdXRpb25TdGF0dXNbRXhlY3V0aW9uU3RhdHVzW1wiRmFpbHVyZVwiXSA9IDFdID0gXCJGYWlsdXJlXCI7XG59KShFeGVjdXRpb25TdGF0dXMgPSBleHBvcnRzLkV4ZWN1dGlvblN0YXR1cyB8fCAoZXhwb3J0cy5FeGVjdXRpb25TdGF0dXMgPSB7fSkpO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlJ1bkV4ZWN1dGlvbiA9IHZvaWQgMDtcbmNvbnN0IFZlcmJvc2l0eUxldmVsXzEgPSByZXF1aXJlKFwiLi4vY29uZmlndXJhdGlvbi9WZXJib3NpdHlMZXZlbFwiKTtcbmNvbnN0IEV4ZWN1dGlvblN0YXR1c18xID0gcmVxdWlyZShcIi4vRXhlY3V0aW9uU3RhdHVzXCIpO1xuY2xhc3MgUnVuRXhlY3V0aW9uIHtcbiAgICBjb25zdHJ1Y3Rvcih2ZXJib3NpdHksIGludGVycnVwdGVkQXNGYWlsdXJlKSB7XG4gICAgICAgIHRoaXMudmVyYm9zaXR5ID0gdmVyYm9zaXR5O1xuICAgICAgICB0aGlzLmludGVycnVwdGVkQXNGYWlsdXJlID0gaW50ZXJydXB0ZWRBc0ZhaWx1cmU7XG4gICAgICAgIHRoaXMuaXNTdWNjZXNzID0gKCkgPT4gdGhpcy5wYXRoVG9GYWlsdXJlID09IG51bGw7XG4gICAgICAgIHRoaXMuZmlyc3RGYWlsdXJlID0gKCkgPT4gKHRoaXMucGF0aFRvRmFpbHVyZSA/ICt0aGlzLnBhdGhUb0ZhaWx1cmUuc3BsaXQoJzonKVswXSA6IC0xKTtcbiAgICAgICAgdGhpcy5udW1TaHJpbmtzID0gKCkgPT4gKHRoaXMucGF0aFRvRmFpbHVyZSA/IHRoaXMucGF0aFRvRmFpbHVyZS5zcGxpdCgnOicpLmxlbmd0aCAtIDEgOiAwKTtcbiAgICAgICAgdGhpcy5yb290RXhlY3V0aW9uVHJlZXMgPSBbXTtcbiAgICAgICAgdGhpcy5jdXJyZW50TGV2ZWxFeGVjdXRpb25UcmVlcyA9IHRoaXMucm9vdEV4ZWN1dGlvblRyZWVzO1xuICAgICAgICB0aGlzLmZhaWx1cmUgPSBudWxsO1xuICAgICAgICB0aGlzLm51bVNraXBzID0gMDtcbiAgICAgICAgdGhpcy5udW1TdWNjZXNzZXMgPSAwO1xuICAgICAgICB0aGlzLmludGVycnVwdGVkID0gZmFsc2U7XG4gICAgfVxuICAgIGFwcGVuZEV4ZWN1dGlvblRyZWUoc3RhdHVzLCB2YWx1ZSkge1xuICAgICAgICBjb25zdCBjdXJyZW50VHJlZSA9IHsgc3RhdHVzLCB2YWx1ZSwgY2hpbGRyZW46IFtdIH07XG4gICAgICAgIHRoaXMuY3VycmVudExldmVsRXhlY3V0aW9uVHJlZXMucHVzaChjdXJyZW50VHJlZSk7XG4gICAgICAgIHJldHVybiBjdXJyZW50VHJlZTtcbiAgICB9XG4gICAgZmFpbCh2YWx1ZSwgaWQsIG1lc3NhZ2UpIHtcbiAgICAgICAgaWYgKHRoaXMudmVyYm9zaXR5ID49IFZlcmJvc2l0eUxldmVsXzEuVmVyYm9zaXR5TGV2ZWwuVmVyYm9zZSkge1xuICAgICAgICAgICAgY29uc3QgY3VycmVudFRyZWUgPSB0aGlzLmFwcGVuZEV4ZWN1dGlvblRyZWUoRXhlY3V0aW9uU3RhdHVzXzEuRXhlY3V0aW9uU3RhdHVzLkZhaWx1cmUsIHZhbHVlKTtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudExldmVsRXhlY3V0aW9uVHJlZXMgPSBjdXJyZW50VHJlZS5jaGlsZHJlbjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5wYXRoVG9GYWlsdXJlID09IG51bGwpXG4gICAgICAgICAgICB0aGlzLnBhdGhUb0ZhaWx1cmUgPSBgJHtpZH1gO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICB0aGlzLnBhdGhUb0ZhaWx1cmUgKz0gYDoke2lkfWA7XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5mYWlsdXJlID0gbWVzc2FnZTtcbiAgICB9XG4gICAgc2tpcCh2YWx1ZSkge1xuICAgICAgICBpZiAodGhpcy52ZXJib3NpdHkgPj0gVmVyYm9zaXR5TGV2ZWxfMS5WZXJib3NpdHlMZXZlbC5WZXJ5VmVyYm9zZSkge1xuICAgICAgICAgICAgdGhpcy5hcHBlbmRFeGVjdXRpb25UcmVlKEV4ZWN1dGlvblN0YXR1c18xLkV4ZWN1dGlvblN0YXR1cy5Ta2lwcGVkLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMucGF0aFRvRmFpbHVyZSA9PSBudWxsKSB7XG4gICAgICAgICAgICArK3RoaXMubnVtU2tpcHM7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3VjY2Vzcyh2YWx1ZSkge1xuICAgICAgICBpZiAodGhpcy52ZXJib3NpdHkgPj0gVmVyYm9zaXR5TGV2ZWxfMS5WZXJib3NpdHlMZXZlbC5WZXJ5VmVyYm9zZSkge1xuICAgICAgICAgICAgdGhpcy5hcHBlbmRFeGVjdXRpb25UcmVlKEV4ZWN1dGlvblN0YXR1c18xLkV4ZWN1dGlvblN0YXR1cy5TdWNjZXNzLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMucGF0aFRvRmFpbHVyZSA9PSBudWxsKSB7XG4gICAgICAgICAgICArK3RoaXMubnVtU3VjY2Vzc2VzO1xuICAgICAgICB9XG4gICAgfVxuICAgIGludGVycnVwdCgpIHtcbiAgICAgICAgdGhpcy5pbnRlcnJ1cHRlZCA9IHRydWU7XG4gICAgfVxuICAgIGV4dHJhY3RGYWlsdXJlcygpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNTdWNjZXNzKCkpIHtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBmYWlsdXJlcyA9IFtdO1xuICAgICAgICBsZXQgY3Vyc29yID0gdGhpcy5yb290RXhlY3V0aW9uVHJlZXM7XG4gICAgICAgIHdoaWxlIChjdXJzb3IubGVuZ3RoID4gMCAmJiBjdXJzb3JbY3Vyc29yLmxlbmd0aCAtIDFdLnN0YXR1cyA9PT0gRXhlY3V0aW9uU3RhdHVzXzEuRXhlY3V0aW9uU3RhdHVzLkZhaWx1cmUpIHtcbiAgICAgICAgICAgIGNvbnN0IGZhaWx1cmVUcmVlID0gY3Vyc29yW2N1cnNvci5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgIGZhaWx1cmVzLnB1c2goZmFpbHVyZVRyZWUudmFsdWUpO1xuICAgICAgICAgICAgY3Vyc29yID0gZmFpbHVyZVRyZWUuY2hpbGRyZW47XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhaWx1cmVzO1xuICAgIH1cbiAgICB0b1J1bkRldGFpbHMoc2VlZCwgYmFzZVBhdGgsIG1heFNraXBzLCBxUGFyYW1zKSB7XG4gICAgICAgIGlmICghdGhpcy5pc1N1Y2Nlc3MoKSkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBmYWlsZWQ6IHRydWUsXG4gICAgICAgICAgICAgICAgaW50ZXJydXB0ZWQ6IHRoaXMuaW50ZXJydXB0ZWQsXG4gICAgICAgICAgICAgICAgbnVtUnVuczogdGhpcy5maXJzdEZhaWx1cmUoKSArIDEgLSB0aGlzLm51bVNraXBzLFxuICAgICAgICAgICAgICAgIG51bVNraXBzOiB0aGlzLm51bVNraXBzLFxuICAgICAgICAgICAgICAgIG51bVNocmlua3M6IHRoaXMubnVtU2hyaW5rcygpLFxuICAgICAgICAgICAgICAgIHNlZWQsXG4gICAgICAgICAgICAgICAgY291bnRlcmV4YW1wbGU6IHRoaXMudmFsdWUsXG4gICAgICAgICAgICAgICAgY291bnRlcmV4YW1wbGVQYXRoOiBSdW5FeGVjdXRpb24ubWVyZ2VQYXRocyhiYXNlUGF0aCwgdGhpcy5wYXRoVG9GYWlsdXJlKSxcbiAgICAgICAgICAgICAgICBlcnJvcjogdGhpcy5mYWlsdXJlLFxuICAgICAgICAgICAgICAgIGZhaWx1cmVzOiB0aGlzLmV4dHJhY3RGYWlsdXJlcygpLFxuICAgICAgICAgICAgICAgIGV4ZWN1dGlvblN1bW1hcnk6IHRoaXMucm9vdEV4ZWN1dGlvblRyZWVzLFxuICAgICAgICAgICAgICAgIHZlcmJvc2U6IHRoaXMudmVyYm9zaXR5LFxuICAgICAgICAgICAgICAgIHJ1bkNvbmZpZ3VyYXRpb246IHFQYXJhbXMudG9QYXJhbWV0ZXJzKCksXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGZhaWxlZCA9IHRoaXMubnVtU2tpcHMgPiBtYXhTa2lwcyB8fCAodGhpcy5pbnRlcnJ1cHRlZCAmJiB0aGlzLmludGVycnVwdGVkQXNGYWlsdXJlKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGZhaWxlZCxcbiAgICAgICAgICAgIGludGVycnVwdGVkOiB0aGlzLmludGVycnVwdGVkLFxuICAgICAgICAgICAgbnVtUnVuczogdGhpcy5udW1TdWNjZXNzZXMsXG4gICAgICAgICAgICBudW1Ta2lwczogdGhpcy5udW1Ta2lwcyxcbiAgICAgICAgICAgIG51bVNocmlua3M6IDAsXG4gICAgICAgICAgICBzZWVkLFxuICAgICAgICAgICAgY291bnRlcmV4YW1wbGU6IG51bGwsXG4gICAgICAgICAgICBjb3VudGVyZXhhbXBsZVBhdGg6IG51bGwsXG4gICAgICAgICAgICBlcnJvcjogbnVsbCxcbiAgICAgICAgICAgIGZhaWx1cmVzOiBbXSxcbiAgICAgICAgICAgIGV4ZWN1dGlvblN1bW1hcnk6IHRoaXMucm9vdEV4ZWN1dGlvblRyZWVzLFxuICAgICAgICAgICAgdmVyYm9zZTogdGhpcy52ZXJib3NpdHksXG4gICAgICAgICAgICBydW5Db25maWd1cmF0aW9uOiBxUGFyYW1zLnRvUGFyYW1ldGVycygpLFxuICAgICAgICB9O1xuICAgIH1cbn1cbmV4cG9ydHMuUnVuRXhlY3V0aW9uID0gUnVuRXhlY3V0aW9uO1xuUnVuRXhlY3V0aW9uLm1lcmdlUGF0aHMgPSAob2Zmc2V0UGF0aCwgcGF0aCkgPT4ge1xuICAgIGlmIChvZmZzZXRQYXRoLmxlbmd0aCA9PT0gMClcbiAgICAgICAgcmV0dXJuIHBhdGg7XG4gICAgY29uc3Qgb2Zmc2V0SXRlbXMgPSBvZmZzZXRQYXRoLnNwbGl0KCc6Jyk7XG4gICAgY29uc3QgcmVtYWluaW5nSXRlbXMgPSBwYXRoLnNwbGl0KCc6Jyk7XG4gICAgY29uc3QgbWlkZGxlID0gK29mZnNldEl0ZW1zW29mZnNldEl0ZW1zLmxlbmd0aCAtIDFdICsgK3JlbWFpbmluZ0l0ZW1zWzBdO1xuICAgIHJldHVybiBbLi4ub2Zmc2V0SXRlbXMuc2xpY2UoMCwgb2Zmc2V0SXRlbXMubGVuZ3RoIC0gMSksIGAke21pZGRsZX1gLCAuLi5yZW1haW5pbmdJdGVtcy5zbGljZSgxKV0uam9pbignOicpO1xufTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5wYXRoV2FsayA9IHZvaWQgMDtcbmNvbnN0IFN0cmVhbV8xID0gcmVxdWlyZShcIi4uLy4uLy4uL3N0cmVhbS9TdHJlYW1cIik7XG5mdW5jdGlvbiBwYXRoV2FsayhwYXRoLCBpbml0aWFsVmFsdWVzKSB7XG4gICAgbGV0IHZhbHVlcyA9IFN0cmVhbV8xLnN0cmVhbShpbml0aWFsVmFsdWVzKTtcbiAgICBjb25zdCBzZWdtZW50cyA9IHBhdGguc3BsaXQoJzonKS5tYXAoKHRleHQpID0+ICt0ZXh0KTtcbiAgICBpZiAoc2VnbWVudHMubGVuZ3RoID09PSAwKVxuICAgICAgICByZXR1cm4gdmFsdWVzO1xuICAgIGlmICghc2VnbWVudHMuZXZlcnkoKHYpID0+ICFOdW1iZXIuaXNOYU4odikpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5hYmxlIHRvIHJlcGxheSwgZ290IGludmFsaWQgcGF0aD0ke3BhdGh9YCk7XG4gICAgfVxuICAgIHZhbHVlcyA9IHZhbHVlcy5kcm9wKHNlZ21lbnRzWzBdKTtcbiAgICBmb3IgKGNvbnN0IHMgb2Ygc2VnbWVudHMuc2xpY2UoMSkpIHtcbiAgICAgICAgY29uc3QgdmFsdWVUb1NocmluayA9IHZhbHVlcy5nZXROdGhPckxhc3QoMCk7XG4gICAgICAgIGlmICh2YWx1ZVRvU2hyaW5rID09IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5hYmxlIHRvIHJlcGxheSwgZ290IHdyb25nIHBhdGg9JHtwYXRofWApO1xuICAgICAgICB9XG4gICAgICAgIHZhbHVlcyA9IHZhbHVlVG9TaHJpbmsuc2hyaW5rKCkuZHJvcChzKTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlcztcbn1cbmV4cG9ydHMucGF0aFdhbGsgPSBwYXRoV2FsaztcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5hc3luY0RlZmF1bHRSZXBvcnRNZXNzYWdlID0gZXhwb3J0cy5kZWZhdWx0UmVwb3J0TWVzc2FnZSA9IGV4cG9ydHMuYXN5bmNSZXBvcnRSdW5EZXRhaWxzID0gZXhwb3J0cy5yZXBvcnRSdW5EZXRhaWxzID0gdm9pZCAwO1xuY29uc3Qgc3RyaW5naWZ5XzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vdXRpbHMvc3RyaW5naWZ5XCIpO1xuY29uc3QgVmVyYm9zaXR5TGV2ZWxfMSA9IHJlcXVpcmUoXCIuLi9jb25maWd1cmF0aW9uL1ZlcmJvc2l0eUxldmVsXCIpO1xuY29uc3QgRXhlY3V0aW9uU3RhdHVzXzEgPSByZXF1aXJlKFwiLi4vcmVwb3J0ZXIvRXhlY3V0aW9uU3RhdHVzXCIpO1xuZnVuY3Rpb24gZm9ybWF0SGludHMoaGludHMpIHtcbiAgICBpZiAoaGludHMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIHJldHVybiBgSGludDogJHtoaW50c1swXX1gO1xuICAgIH1cbiAgICByZXR1cm4gaGludHMubWFwKChoLCBpZHgpID0+IGBIaW50ICgke2lkeCArIDF9KTogJHtofWApLmpvaW4oJ1xcbicpO1xufVxuZnVuY3Rpb24gZm9ybWF0RmFpbHVyZXMoZmFpbHVyZXMsIHN0cmluZ2lmeU9uZSkge1xuICAgIHJldHVybiBgRW5jb3VudGVyZWQgZmFpbHVyZXMgd2VyZTpcXG4tICR7ZmFpbHVyZXMubWFwKHN0cmluZ2lmeU9uZSkuam9pbignXFxuLSAnKX1gO1xufVxuZnVuY3Rpb24gZm9ybWF0RXhlY3V0aW9uU3VtbWFyeShleGVjdXRpb25UcmVlcywgc3RyaW5naWZ5T25lKSB7XG4gICAgY29uc3Qgc3VtbWFyeUxpbmVzID0gW107XG4gICAgY29uc3QgcmVtYWluaW5nVHJlZXNBbmREZXB0aCA9IFtdO1xuICAgIGZvciAoY29uc3QgdHJlZSBvZiBleGVjdXRpb25UcmVlcy5zbGljZSgpLnJldmVyc2UoKSkge1xuICAgICAgICByZW1haW5pbmdUcmVlc0FuZERlcHRoLnB1c2goeyBkZXB0aDogMSwgdHJlZSB9KTtcbiAgICB9XG4gICAgd2hpbGUgKHJlbWFpbmluZ1RyZWVzQW5kRGVwdGgubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRUcmVlQW5kRGVwdGggPSByZW1haW5pbmdUcmVlc0FuZERlcHRoLnBvcCgpO1xuICAgICAgICBjb25zdCBjdXJyZW50VHJlZSA9IGN1cnJlbnRUcmVlQW5kRGVwdGgudHJlZTtcbiAgICAgICAgY29uc3QgY3VycmVudERlcHRoID0gY3VycmVudFRyZWVBbmREZXB0aC5kZXB0aDtcbiAgICAgICAgY29uc3Qgc3RhdHVzSWNvbiA9IGN1cnJlbnRUcmVlLnN0YXR1cyA9PT0gRXhlY3V0aW9uU3RhdHVzXzEuRXhlY3V0aW9uU3RhdHVzLlN1Y2Nlc3NcbiAgICAgICAgICAgID8gJ1xceDFiWzMybVxcdTIyMUFcXHgxYlswbSdcbiAgICAgICAgICAgIDogY3VycmVudFRyZWUuc3RhdHVzID09PSBFeGVjdXRpb25TdGF0dXNfMS5FeGVjdXRpb25TdGF0dXMuRmFpbHVyZVxuICAgICAgICAgICAgICAgID8gJ1xceDFiWzMxbVxceEQ3XFx4MWJbMG0nXG4gICAgICAgICAgICAgICAgOiAnXFx4MWJbMzNtIVxceDFiWzBtJztcbiAgICAgICAgY29uc3QgbGVmdFBhZGRpbmcgPSBBcnJheShjdXJyZW50RGVwdGgpLmpvaW4oJy4gJyk7XG4gICAgICAgIHN1bW1hcnlMaW5lcy5wdXNoKGAke2xlZnRQYWRkaW5nfSR7c3RhdHVzSWNvbn0gJHtzdHJpbmdpZnlPbmUoY3VycmVudFRyZWUudmFsdWUpfWApO1xuICAgICAgICBmb3IgKGNvbnN0IHRyZWUgb2YgY3VycmVudFRyZWUuY2hpbGRyZW4uc2xpY2UoKS5yZXZlcnNlKCkpIHtcbiAgICAgICAgICAgIHJlbWFpbmluZ1RyZWVzQW5kRGVwdGgucHVzaCh7IGRlcHRoOiBjdXJyZW50RGVwdGggKyAxLCB0cmVlIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBgRXhlY3V0aW9uIHN1bW1hcnk6XFxuJHtzdW1tYXJ5TGluZXMuam9pbignXFxuJyl9YDtcbn1cbmZ1bmN0aW9uIHByZUZvcm1hdFRvb01hbnlTa2lwcGVkKG91dCwgc3RyaW5naWZ5T25lKSB7XG4gICAgY29uc3QgbWVzc2FnZSA9IGBGYWlsZWQgdG8gcnVuIHByb3BlcnR5LCB0b28gbWFueSBwcmUtY29uZGl0aW9uIGZhaWx1cmVzIGVuY291bnRlcmVkXFxueyBzZWVkOiAke291dC5zZWVkfSB9XFxuXFxuUmFuICR7b3V0Lm51bVJ1bnN9IHRpbWUocylcXG5Ta2lwcGVkICR7b3V0Lm51bVNraXBzfSB0aW1lKHMpYDtcbiAgICBsZXQgZGV0YWlscyA9IG51bGw7XG4gICAgY29uc3QgaGludHMgPSBbXG4gICAgICAgICdUcnkgdG8gcmVkdWNlIHRoZSBudW1iZXIgb2YgcmVqZWN0ZWQgdmFsdWVzIGJ5IGNvbWJpbmluZyBtYXAsIGZsYXRNYXAgYW5kIGJ1aWx0LWluIGFyYml0cmFyaWVzJyxcbiAgICAgICAgJ0luY3JlYXNlIGZhaWx1cmUgdG9sZXJhbmNlIGJ5IHNldHRpbmcgbWF4U2tpcHNQZXJSdW4gdG8gYW4gaGlnaGVyIHZhbHVlJyxcbiAgICBdO1xuICAgIGlmIChvdXQudmVyYm9zZSA+PSBWZXJib3NpdHlMZXZlbF8xLlZlcmJvc2l0eUxldmVsLlZlcnlWZXJib3NlKSB7XG4gICAgICAgIGRldGFpbHMgPSBmb3JtYXRFeGVjdXRpb25TdW1tYXJ5KG91dC5leGVjdXRpb25TdW1tYXJ5LCBzdHJpbmdpZnlPbmUpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgaGludHMucHVzaCgnRW5hYmxlIHZlcmJvc2UgbW9kZSBhdCBsZXZlbCBWZXJ5VmVyYm9zZSBpbiBvcmRlciB0byBjaGVjayBhbGwgZ2VuZXJhdGVkIHZhbHVlcyBhbmQgdGhlaXIgYXNzb2NpYXRlZCBzdGF0dXMnKTtcbiAgICB9XG4gICAgcmV0dXJuIHsgbWVzc2FnZSwgZGV0YWlscywgaGludHMgfTtcbn1cbmZ1bmN0aW9uIHByZUZvcm1hdEZhaWx1cmUob3V0LCBzdHJpbmdpZnlPbmUpIHtcbiAgICBjb25zdCBtZXNzYWdlID0gYFByb3BlcnR5IGZhaWxlZCBhZnRlciAke291dC5udW1SdW5zfSB0ZXN0c1xcbnsgc2VlZDogJHtvdXQuc2VlZH0sIHBhdGg6IFwiJHtvdXQuY291bnRlcmV4YW1wbGVQYXRofVwiLCBlbmRPbkZhaWx1cmU6IHRydWUgfVxcbkNvdW50ZXJleGFtcGxlOiAke3N0cmluZ2lmeU9uZShvdXQuY291bnRlcmV4YW1wbGUpfVxcblNocnVuayAke291dC5udW1TaHJpbmtzfSB0aW1lKHMpXFxuR290IGVycm9yOiAke291dC5lcnJvcn1gO1xuICAgIGxldCBkZXRhaWxzID0gbnVsbDtcbiAgICBjb25zdCBoaW50cyA9IFtdO1xuICAgIGlmIChvdXQudmVyYm9zZSA+PSBWZXJib3NpdHlMZXZlbF8xLlZlcmJvc2l0eUxldmVsLlZlcnlWZXJib3NlKSB7XG4gICAgICAgIGRldGFpbHMgPSBmb3JtYXRFeGVjdXRpb25TdW1tYXJ5KG91dC5leGVjdXRpb25TdW1tYXJ5LCBzdHJpbmdpZnlPbmUpO1xuICAgIH1cbiAgICBlbHNlIGlmIChvdXQudmVyYm9zZSA9PT0gVmVyYm9zaXR5TGV2ZWxfMS5WZXJib3NpdHlMZXZlbC5WZXJib3NlKSB7XG4gICAgICAgIGRldGFpbHMgPSBmb3JtYXRGYWlsdXJlcyhvdXQuZmFpbHVyZXMsIHN0cmluZ2lmeU9uZSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBoaW50cy5wdXNoKCdFbmFibGUgdmVyYm9zZSBtb2RlIGluIG9yZGVyIHRvIGhhdmUgdGhlIGxpc3Qgb2YgYWxsIGZhaWxpbmcgdmFsdWVzIGVuY291bnRlcmVkIGR1cmluZyB0aGUgcnVuJyk7XG4gICAgfVxuICAgIHJldHVybiB7IG1lc3NhZ2UsIGRldGFpbHMsIGhpbnRzIH07XG59XG5mdW5jdGlvbiBwcmVGb3JtYXRFYXJseUludGVycnVwdGVkKG91dCwgc3RyaW5naWZ5T25lKSB7XG4gICAgY29uc3QgbWVzc2FnZSA9IGBQcm9wZXJ0eSBpbnRlcnJ1cHRlZCBhZnRlciAke291dC5udW1SdW5zfSB0ZXN0c1xcbnsgc2VlZDogJHtvdXQuc2VlZH0gfWA7XG4gICAgbGV0IGRldGFpbHMgPSBudWxsO1xuICAgIGNvbnN0IGhpbnRzID0gW107XG4gICAgaWYgKG91dC52ZXJib3NlID49IFZlcmJvc2l0eUxldmVsXzEuVmVyYm9zaXR5TGV2ZWwuVmVyeVZlcmJvc2UpIHtcbiAgICAgICAgZGV0YWlscyA9IGZvcm1hdEV4ZWN1dGlvblN1bW1hcnkob3V0LmV4ZWN1dGlvblN1bW1hcnksIHN0cmluZ2lmeU9uZSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBoaW50cy5wdXNoKCdFbmFibGUgdmVyYm9zZSBtb2RlIGF0IGxldmVsIFZlcnlWZXJib3NlIGluIG9yZGVyIHRvIGNoZWNrIGFsbCBnZW5lcmF0ZWQgdmFsdWVzIGFuZCB0aGVpciBhc3NvY2lhdGVkIHN0YXR1cycpO1xuICAgIH1cbiAgICByZXR1cm4geyBtZXNzYWdlLCBkZXRhaWxzLCBoaW50cyB9O1xufVxuZnVuY3Rpb24gZGVmYXVsdFJlcG9ydE1lc3NhZ2VJbnRlcm5hbChvdXQsIHN0cmluZ2lmeU9uZSkge1xuICAgIGlmICghb3V0LmZhaWxlZClcbiAgICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IHsgbWVzc2FnZSwgZGV0YWlscywgaGludHMgfSA9IG91dC5jb3VudGVyZXhhbXBsZVBhdGggPT09IG51bGxcbiAgICAgICAgPyBvdXQuaW50ZXJydXB0ZWRcbiAgICAgICAgICAgID8gcHJlRm9ybWF0RWFybHlJbnRlcnJ1cHRlZChvdXQsIHN0cmluZ2lmeU9uZSlcbiAgICAgICAgICAgIDogcHJlRm9ybWF0VG9vTWFueVNraXBwZWQob3V0LCBzdHJpbmdpZnlPbmUpXG4gICAgICAgIDogcHJlRm9ybWF0RmFpbHVyZShvdXQsIHN0cmluZ2lmeU9uZSk7XG4gICAgbGV0IGVycm9yTWVzc2FnZSA9IG1lc3NhZ2U7XG4gICAgaWYgKGRldGFpbHMgIT0gbnVsbClcbiAgICAgICAgZXJyb3JNZXNzYWdlICs9IGBcXG5cXG4ke2RldGFpbHN9YDtcbiAgICBpZiAoaGludHMubGVuZ3RoID4gMClcbiAgICAgICAgZXJyb3JNZXNzYWdlICs9IGBcXG5cXG4ke2Zvcm1hdEhpbnRzKGhpbnRzKX1gO1xuICAgIHJldHVybiBlcnJvck1lc3NhZ2U7XG59XG5mdW5jdGlvbiBkZWZhdWx0UmVwb3J0TWVzc2FnZShvdXQpIHtcbiAgICByZXR1cm4gZGVmYXVsdFJlcG9ydE1lc3NhZ2VJbnRlcm5hbChvdXQsIHN0cmluZ2lmeV8xLnN0cmluZ2lmeSk7XG59XG5leHBvcnRzLmRlZmF1bHRSZXBvcnRNZXNzYWdlID0gZGVmYXVsdFJlcG9ydE1lc3NhZ2U7XG5hc3luYyBmdW5jdGlvbiBhc3luY0RlZmF1bHRSZXBvcnRNZXNzYWdlKG91dCkge1xuICAgIGNvbnN0IHBlbmRpbmdTdHJpbmdpZmllZHMgPSBbXTtcbiAgICBmdW5jdGlvbiBzdHJpbmdpZnlPbmUodmFsdWUpIHtcbiAgICAgICAgY29uc3Qgc3RyaW5naWZpZWQgPSBzdHJpbmdpZnlfMS5wb3NzaWJseUFzeW5jU3RyaW5naWZ5KHZhbHVlKTtcbiAgICAgICAgaWYgKHR5cGVvZiBzdHJpbmdpZmllZCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHJldHVybiBzdHJpbmdpZmllZDtcbiAgICAgICAgfVxuICAgICAgICBwZW5kaW5nU3RyaW5naWZpZWRzLnB1c2goUHJvbWlzZS5hbGwoW3ZhbHVlLCBzdHJpbmdpZmllZF0pKTtcbiAgICAgICAgcmV0dXJuICdcXHUyMDI2JztcbiAgICB9XG4gICAgY29uc3QgZmlyc3RUcnlNZXNzYWdlID0gZGVmYXVsdFJlcG9ydE1lc3NhZ2VJbnRlcm5hbChvdXQsIHN0cmluZ2lmeU9uZSk7XG4gICAgaWYgKHBlbmRpbmdTdHJpbmdpZmllZHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiBmaXJzdFRyeU1lc3NhZ2U7XG4gICAgfVxuICAgIGNvbnN0IHJlZ2lzdGVyZWRWYWx1ZXMgPSBuZXcgTWFwKGF3YWl0IFByb21pc2UuYWxsKHBlbmRpbmdTdHJpbmdpZmllZHMpKTtcbiAgICBmdW5jdGlvbiBzdHJpbmdpZnlTZWNvbmQodmFsdWUpIHtcbiAgICAgICAgY29uc3QgYXN5bmNTdHJpbmdpZmllZElmUmVnaXN0ZXJlZCA9IHJlZ2lzdGVyZWRWYWx1ZXMuZ2V0KHZhbHVlKTtcbiAgICAgICAgaWYgKGFzeW5jU3RyaW5naWZpZWRJZlJlZ2lzdGVyZWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIGFzeW5jU3RyaW5naWZpZWRJZlJlZ2lzdGVyZWQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN0cmluZ2lmeV8xLnN0cmluZ2lmeSh2YWx1ZSk7XG4gICAgfVxuICAgIHJldHVybiBkZWZhdWx0UmVwb3J0TWVzc2FnZUludGVybmFsKG91dCwgc3RyaW5naWZ5U2Vjb25kKTtcbn1cbmV4cG9ydHMuYXN5bmNEZWZhdWx0UmVwb3J0TWVzc2FnZSA9IGFzeW5jRGVmYXVsdFJlcG9ydE1lc3NhZ2U7XG5mdW5jdGlvbiB0aHJvd0lmRmFpbGVkKG91dCkge1xuICAgIGlmICghb3V0LmZhaWxlZClcbiAgICAgICAgcmV0dXJuO1xuICAgIHRocm93IG5ldyBFcnJvcihkZWZhdWx0UmVwb3J0TWVzc2FnZShvdXQpKTtcbn1cbmFzeW5jIGZ1bmN0aW9uIGFzeW5jVGhyb3dJZkZhaWxlZChvdXQpIHtcbiAgICBpZiAoIW91dC5mYWlsZWQpXG4gICAgICAgIHJldHVybjtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYXdhaXQgYXN5bmNEZWZhdWx0UmVwb3J0TWVzc2FnZShvdXQpKTtcbn1cbmZ1bmN0aW9uIHJlcG9ydFJ1bkRldGFpbHMob3V0KSB7XG4gICAgaWYgKG91dC5ydW5Db25maWd1cmF0aW9uLmFzeW5jUmVwb3J0ZXIpXG4gICAgICAgIHJldHVybiBvdXQucnVuQ29uZmlndXJhdGlvbi5hc3luY1JlcG9ydGVyKG91dCk7XG4gICAgZWxzZSBpZiAob3V0LnJ1bkNvbmZpZ3VyYXRpb24ucmVwb3J0ZXIpXG4gICAgICAgIHJldHVybiBvdXQucnVuQ29uZmlndXJhdGlvbi5yZXBvcnRlcihvdXQpO1xuICAgIGVsc2VcbiAgICAgICAgcmV0dXJuIHRocm93SWZGYWlsZWQob3V0KTtcbn1cbmV4cG9ydHMucmVwb3J0UnVuRGV0YWlscyA9IHJlcG9ydFJ1bkRldGFpbHM7XG5hc3luYyBmdW5jdGlvbiBhc3luY1JlcG9ydFJ1bkRldGFpbHMob3V0KSB7XG4gICAgaWYgKG91dC5ydW5Db25maWd1cmF0aW9uLmFzeW5jUmVwb3J0ZXIpXG4gICAgICAgIHJldHVybiBvdXQucnVuQ29uZmlndXJhdGlvbi5hc3luY1JlcG9ydGVyKG91dCk7XG4gICAgZWxzZSBpZiAob3V0LnJ1bkNvbmZpZ3VyYXRpb24ucmVwb3J0ZXIpXG4gICAgICAgIHJldHVybiBvdXQucnVuQ29uZmlndXJhdGlvbi5yZXBvcnRlcihvdXQpO1xuICAgIGVsc2VcbiAgICAgICAgcmV0dXJuIGFzeW5jVGhyb3dJZkZhaWxlZChvdXQpO1xufVxuZXhwb3J0cy5hc3luY1JlcG9ydFJ1bkRldGFpbHMgPSBhc3luY1JlcG9ydFJ1bkRldGFpbHM7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuY2xvbmVJZk5lZWRlZCA9IGV4cG9ydHMuaGFzQ2xvbmVNZXRob2QgPSBleHBvcnRzLmNsb25lTWV0aG9kID0gdm9pZCAwO1xuZXhwb3J0cy5jbG9uZU1ldGhvZCA9IFN5bWJvbCgnZmFzdC1jaGVjay9jbG9uZU1ldGhvZCcpO1xuZnVuY3Rpb24gaGFzQ2xvbmVNZXRob2QoaW5zdGFuY2UpIHtcbiAgICByZXR1cm4gKGluc3RhbmNlICE9PSBudWxsICYmXG4gICAgICAgICh0eXBlb2YgaW5zdGFuY2UgPT09ICdvYmplY3QnIHx8IHR5cGVvZiBpbnN0YW5jZSA9PT0gJ2Z1bmN0aW9uJykgJiZcbiAgICAgICAgZXhwb3J0cy5jbG9uZU1ldGhvZCBpbiBpbnN0YW5jZSAmJlxuICAgICAgICB0eXBlb2YgaW5zdGFuY2VbZXhwb3J0cy5jbG9uZU1ldGhvZF0gPT09ICdmdW5jdGlvbicpO1xufVxuZXhwb3J0cy5oYXNDbG9uZU1ldGhvZCA9IGhhc0Nsb25lTWV0aG9kO1xuZnVuY3Rpb24gY2xvbmVJZk5lZWRlZChpbnN0YW5jZSkge1xuICAgIHJldHVybiBoYXNDbG9uZU1ldGhvZChpbnN0YW5jZSkgPyBpbnN0YW5jZVtleHBvcnRzLmNsb25lTWV0aG9kXSgpIDogaW5zdGFuY2U7XG59XG5leHBvcnRzLmNsb25lSWZOZWVkZWQgPSBjbG9uZUlmTmVlZGVkO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnNodWZmbGVkU3ViYXJyYXkgPSBleHBvcnRzLmRlZHVwID0gZXhwb3J0cy5jbG9uZSA9IGV4cG9ydHMuZnJlcXVlbmN5ID0gZXhwb3J0cy5vbmVvZiA9IGV4cG9ydHMub3B0aW9uID0gZXhwb3J0cy5tYXBUb0NvbnN0YW50ID0gZXhwb3J0cy5jbG9uZWRDb25zdGFudCA9IGV4cG9ydHMuY29uc3RhbnRGcm9tID0gZXhwb3J0cy5jb25zdGFudCA9IGV4cG9ydHMubG9yZW0gPSBleHBvcnRzLmJhc2U2NFN0cmluZyA9IGV4cG9ydHMuaGV4YVN0cmluZyA9IGV4cG9ydHMuZnVsbFVuaWNvZGVTdHJpbmcgPSBleHBvcnRzLnVuaWNvZGVTdHJpbmcgPSBleHBvcnRzLnN0cmluZ09mID0gZXhwb3J0cy5zdHJpbmcxNmJpdHMgPSBleHBvcnRzLmFzY2lpU3RyaW5nID0gZXhwb3J0cy5zdHJpbmcgPSBleHBvcnRzLm1peGVkQ2FzZSA9IGV4cG9ydHMuYmFzZTY0ID0gZXhwb3J0cy5oZXhhID0gZXhwb3J0cy5mdWxsVW5pY29kZSA9IGV4cG9ydHMudW5pY29kZSA9IGV4cG9ydHMuY2hhcjE2Yml0cyA9IGV4cG9ydHMuYXNjaWkgPSBleHBvcnRzLmNoYXIgPSBleHBvcnRzLmJpZ1VpbnQgPSBleHBvcnRzLmJpZ0ludCA9IGV4cG9ydHMuYmlnVWludE4gPSBleHBvcnRzLmJpZ0ludE4gPSBleHBvcnRzLm1heFNhZmVOYXQgPSBleHBvcnRzLm1heFNhZmVJbnRlZ2VyID0gZXhwb3J0cy5uYXQgPSBleHBvcnRzLmludGVnZXIgPSBleHBvcnRzLmRvdWJsZSA9IGV4cG9ydHMuZmxvYXQgPSBleHBvcnRzLmZhbHN5ID0gZXhwb3J0cy5ib29sZWFuID0gZXhwb3J0cy5hc3luY1Byb3BlcnR5ID0gZXhwb3J0cy5wcm9wZXJ0eSA9IGV4cG9ydHMuUHJlY29uZGl0aW9uRmFpbHVyZSA9IGV4cG9ydHMucHJlID0gZXhwb3J0cy5hc3NlcnQgPSBleHBvcnRzLmNoZWNrID0gZXhwb3J0cy5zdGF0aXN0aWNzID0gZXhwb3J0cy5zYW1wbGUgPSBleHBvcnRzLl9fY29tbWl0SGFzaCA9IGV4cG9ydHMuX192ZXJzaW9uID0gZXhwb3J0cy5fX3R5cGUgPSB2b2lkIDA7XG5leHBvcnRzLkFyYml0cmFyeSA9IGV4cG9ydHMuc2NoZWR1bGVyRm9yID0gZXhwb3J0cy5zY2hlZHVsZXIgPSBleHBvcnRzLmNvbW1hbmRzID0gZXhwb3J0cy5zY2hlZHVsZWRNb2RlbFJ1biA9IGV4cG9ydHMubW9kZWxSdW4gPSBleHBvcnRzLmFzeW5jTW9kZWxSdW4gPSBleHBvcnRzLmZsb2F0NjRBcnJheSA9IGV4cG9ydHMuZmxvYXQzMkFycmF5ID0gZXhwb3J0cy51aW50MzJBcnJheSA9IGV4cG9ydHMuaW50MzJBcnJheSA9IGV4cG9ydHMudWludDE2QXJyYXkgPSBleHBvcnRzLmludDE2QXJyYXkgPSBleHBvcnRzLnVpbnQ4Q2xhbXBlZEFycmF5ID0gZXhwb3J0cy51aW50OEFycmF5ID0gZXhwb3J0cy5pbnQ4QXJyYXkgPSBleHBvcnRzLnV1aWRWID0gZXhwb3J0cy51dWlkID0gZXhwb3J0cy5lbWFpbEFkZHJlc3MgPSBleHBvcnRzLndlYlVybCA9IGV4cG9ydHMud2ViUXVlcnlQYXJhbWV0ZXJzID0gZXhwb3J0cy53ZWJGcmFnbWVudHMgPSBleHBvcnRzLndlYlNlZ21lbnQgPSBleHBvcnRzLndlYkF1dGhvcml0eSA9IGV4cG9ydHMuZG9tYWluID0gZXhwb3J0cy5pcFY2ID0gZXhwb3J0cy5pcFY0RXh0ZW5kZWQgPSBleHBvcnRzLmlwVjQgPSBleHBvcnRzLmRhdGUgPSBleHBvcnRzLmNvbnRleHQgPSBleHBvcnRzLmZ1bmMgPSBleHBvcnRzLmNvbXBhcmVGdW5jID0gZXhwb3J0cy5jb21wYXJlQm9vbGVhbkZ1bmMgPSBleHBvcnRzLm1lbW8gPSBleHBvcnRzLmxldHJlYyA9IGV4cG9ydHMudW5pY29kZUpzb25PYmplY3QgPSBleHBvcnRzLnVuaWNvZGVKc29uID0gZXhwb3J0cy5qc29uT2JqZWN0ID0gZXhwb3J0cy5qc29uID0gZXhwb3J0cy5vYmplY3QgPSBleHBvcnRzLmFueXRoaW5nID0gZXhwb3J0cy5kaWN0aW9uYXJ5ID0gZXhwb3J0cy5yZWNvcmQgPSBleHBvcnRzLmdlbmVyaWNUdXBsZSA9IGV4cG9ydHMudHVwbGUgPSBleHBvcnRzLnNldCA9IGV4cG9ydHMuaW5maW5pdGVTdHJlYW0gPSBleHBvcnRzLnNwYXJzZUFycmF5ID0gZXhwb3J0cy5hcnJheSA9IGV4cG9ydHMuc3ViYXJyYXkgPSB2b2lkIDA7XG5leHBvcnRzLnN0cmVhbSA9IGV4cG9ydHMuU3RyZWFtID0gZXhwb3J0cy5SYW5kb20gPSBleHBvcnRzLkV4ZWN1dGlvblN0YXR1cyA9IGV4cG9ydHMucmVzZXRDb25maWd1cmVHbG9iYWwgPSBleHBvcnRzLnJlYWRDb25maWd1cmVHbG9iYWwgPSBleHBvcnRzLmNvbmZpZ3VyZUdsb2JhbCA9IGV4cG9ydHMuVmVyYm9zaXR5TGV2ZWwgPSBleHBvcnRzLmhhc2ggPSBleHBvcnRzLmFzeW5jRGVmYXVsdFJlcG9ydE1lc3NhZ2UgPSBleHBvcnRzLmRlZmF1bHRSZXBvcnRNZXNzYWdlID0gZXhwb3J0cy5hc3luY1N0cmluZ2lmeSA9IGV4cG9ydHMuc3RyaW5naWZ5ID0gZXhwb3J0cy5oYXNBc3luY1RvU3RyaW5nTWV0aG9kID0gZXhwb3J0cy5hc3luY1RvU3RyaW5nTWV0aG9kID0gZXhwb3J0cy5oYXNUb1N0cmluZ01ldGhvZCA9IGV4cG9ydHMudG9TdHJpbmdNZXRob2QgPSBleHBvcnRzLmNvbnZlcnRUb05leHQgPSBleHBvcnRzLmNvbnZlcnRGcm9tTmV4dFdpdGhTaHJ1bmtPbmNlID0gZXhwb3J0cy5jb252ZXJ0RnJvbU5leHQgPSBleHBvcnRzLmhhc0Nsb25lTWV0aG9kID0gZXhwb3J0cy5jbG9uZUlmTmVlZGVkID0gZXhwb3J0cy5jbG9uZU1ldGhvZCA9IGV4cG9ydHMuTmV4dFZhbHVlID0gZXhwb3J0cy5TaHJpbmthYmxlID0gZXhwb3J0cy5BcmJpdHJhcnlXaXRoQ29udGV4dHVhbFNocmluayA9IGV4cG9ydHMuQXJiaXRyYXJ5V2l0aFNocmluayA9IGV4cG9ydHMuTmV4dEFyYml0cmFyeSA9IHZvaWQgMDtcbmNvbnN0IFByZV8xID0gcmVxdWlyZShcIi4vY2hlY2svcHJlY29uZGl0aW9uL1ByZVwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInByZVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gUHJlXzEucHJlOyB9IH0pO1xuY29uc3QgQXN5bmNQcm9wZXJ0eV8xID0gcmVxdWlyZShcIi4vY2hlY2svcHJvcGVydHkvQXN5bmNQcm9wZXJ0eVwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImFzeW5jUHJvcGVydHlcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIEFzeW5jUHJvcGVydHlfMS5hc3luY1Byb3BlcnR5OyB9IH0pO1xuY29uc3QgUHJvcGVydHlfMSA9IHJlcXVpcmUoXCIuL2NoZWNrL3Byb3BlcnR5L1Byb3BlcnR5XCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwicHJvcGVydHlcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFByb3BlcnR5XzEucHJvcGVydHk7IH0gfSk7XG5jb25zdCBSdW5uZXJfMSA9IHJlcXVpcmUoXCIuL2NoZWNrL3J1bm5lci9SdW5uZXJcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJhc3NlcnRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFJ1bm5lcl8xLmFzc2VydDsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImNoZWNrXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBSdW5uZXJfMS5jaGVjazsgfSB9KTtcbmNvbnN0IFNhbXBsZXJfMSA9IHJlcXVpcmUoXCIuL2NoZWNrL3J1bm5lci9TYW1wbGVyXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwic2FtcGxlXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBTYW1wbGVyXzEuc2FtcGxlOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwic3RhdGlzdGljc1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gU2FtcGxlcl8xLnN0YXRpc3RpY3M7IH0gfSk7XG5jb25zdCBhcnJheV8xID0gcmVxdWlyZShcIi4vYXJiaXRyYXJ5L2FycmF5XCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiYXJyYXlcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGFycmF5XzEuYXJyYXk7IH0gfSk7XG5jb25zdCBiaWdJbnRfMSA9IHJlcXVpcmUoXCIuL2FyYml0cmFyeS9iaWdJbnRcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJiaWdJbnRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGJpZ0ludF8xLmJpZ0ludDsgfSB9KTtcbmNvbnN0IGJpZ0ludE5fMSA9IHJlcXVpcmUoXCIuL2FyYml0cmFyeS9iaWdJbnROXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiYmlnSW50TlwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gYmlnSW50Tl8xLmJpZ0ludE47IH0gfSk7XG5jb25zdCBiaWdVaW50XzEgPSByZXF1aXJlKFwiLi9hcmJpdHJhcnkvYmlnVWludFwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImJpZ1VpbnRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGJpZ1VpbnRfMS5iaWdVaW50OyB9IH0pO1xuY29uc3QgYmlnVWludE5fMSA9IHJlcXVpcmUoXCIuL2FyYml0cmFyeS9iaWdVaW50TlwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImJpZ1VpbnROXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBiaWdVaW50Tl8xLmJpZ1VpbnROOyB9IH0pO1xuY29uc3QgYm9vbGVhbl8xID0gcmVxdWlyZShcIi4vYXJiaXRyYXJ5L2Jvb2xlYW5cIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJib29sZWFuXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBib29sZWFuXzEuYm9vbGVhbjsgfSB9KTtcbmNvbnN0IGZhbHN5XzEgPSByZXF1aXJlKFwiLi9hcmJpdHJhcnkvZmFsc3lcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJmYWxzeVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZmFsc3lfMS5mYWxzeTsgfSB9KTtcbmNvbnN0IGFzY2lpXzEgPSByZXF1aXJlKFwiLi9hcmJpdHJhcnkvYXNjaWlcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJhc2NpaVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gYXNjaWlfMS5hc2NpaTsgfSB9KTtcbmNvbnN0IGJhc2U2NF8xID0gcmVxdWlyZShcIi4vYXJiaXRyYXJ5L2Jhc2U2NFwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImJhc2U2NFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gYmFzZTY0XzEuYmFzZTY0OyB9IH0pO1xuY29uc3QgY2hhcl8xID0gcmVxdWlyZShcIi4vYXJiaXRyYXJ5L2NoYXJcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJjaGFyXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjaGFyXzEuY2hhcjsgfSB9KTtcbmNvbnN0IGNoYXIxNmJpdHNfMSA9IHJlcXVpcmUoXCIuL2FyYml0cmFyeS9jaGFyMTZiaXRzXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiY2hhcjE2Yml0c1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY2hhcjE2Yml0c18xLmNoYXIxNmJpdHM7IH0gfSk7XG5jb25zdCBmdWxsVW5pY29kZV8xID0gcmVxdWlyZShcIi4vYXJiaXRyYXJ5L2Z1bGxVbmljb2RlXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZnVsbFVuaWNvZGVcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGZ1bGxVbmljb2RlXzEuZnVsbFVuaWNvZGU7IH0gfSk7XG5jb25zdCBoZXhhXzEgPSByZXF1aXJlKFwiLi9hcmJpdHJhcnkvaGV4YVwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImhleGFcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGhleGFfMS5oZXhhOyB9IH0pO1xuY29uc3QgdW5pY29kZV8xID0gcmVxdWlyZShcIi4vYXJiaXRyYXJ5L3VuaWNvZGVcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJ1bmljb2RlXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB1bmljb2RlXzEudW5pY29kZTsgfSB9KTtcbmNvbnN0IGNsb25lZENvbnN0YW50XzEgPSByZXF1aXJlKFwiLi9hcmJpdHJhcnkvY2xvbmVkQ29uc3RhbnRcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJjbG9uZWRDb25zdGFudFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY2xvbmVkQ29uc3RhbnRfMS5jbG9uZWRDb25zdGFudDsgfSB9KTtcbmNvbnN0IGNvbnN0YW50XzEgPSByZXF1aXJlKFwiLi9hcmJpdHJhcnkvY29uc3RhbnRcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJjb25zdGFudFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY29uc3RhbnRfMS5jb25zdGFudDsgfSB9KTtcbmNvbnN0IGNvbnN0YW50RnJvbV8xID0gcmVxdWlyZShcIi4vYXJiaXRyYXJ5L2NvbnN0YW50RnJvbVwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImNvbnN0YW50RnJvbVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY29uc3RhbnRGcm9tXzEuY29uc3RhbnRGcm9tOyB9IH0pO1xuY29uc3QgY29udGV4dF8xID0gcmVxdWlyZShcIi4vYXJiaXRyYXJ5L2NvbnRleHRcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJjb250ZXh0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjb250ZXh0XzEuY29udGV4dDsgfSB9KTtcbmNvbnN0IGRhdGVfMSA9IHJlcXVpcmUoXCIuL2FyYml0cmFyeS9kYXRlXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZGF0ZVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZGF0ZV8xLmRhdGU7IH0gfSk7XG5jb25zdCBjbG9uZV8xID0gcmVxdWlyZShcIi4vYXJiaXRyYXJ5L2Nsb25lXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiY2xvbmVcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNsb25lXzEuY2xvbmU7IH0gfSk7XG5jb25zdCBkZWR1cF8xID0gcmVxdWlyZShcIi4vYXJiaXRyYXJ5L2RlZHVwXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZGVkdXBcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGRlZHVwXzEuZGVkdXA7IH0gfSk7XG5jb25zdCBBcmJpdHJhcnlfMSA9IHJlcXVpcmUoXCIuL2NoZWNrL2FyYml0cmFyeS9kZWZpbml0aW9uL0FyYml0cmFyeVwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkFyYml0cmFyeVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gQXJiaXRyYXJ5XzEuQXJiaXRyYXJ5OyB9IH0pO1xuY29uc3QgU2hyaW5rYWJsZV8xID0gcmVxdWlyZShcIi4vY2hlY2svYXJiaXRyYXJ5L2RlZmluaXRpb24vU2hyaW5rYWJsZVwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlNocmlua2FibGVcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFNocmlua2FibGVfMS5TaHJpbmthYmxlOyB9IH0pO1xuY29uc3QgZGljdGlvbmFyeV8xID0gcmVxdWlyZShcIi4vYXJiaXRyYXJ5L2RpY3Rpb25hcnlcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJkaWN0aW9uYXJ5XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBkaWN0aW9uYXJ5XzEuZGljdGlvbmFyeTsgfSB9KTtcbmNvbnN0IEVtYWlsQXJiaXRyYXJ5XzEgPSByZXF1aXJlKFwiLi9jaGVjay9hcmJpdHJhcnkvRW1haWxBcmJpdHJhcnlcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJlbWFpbEFkZHJlc3NcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIEVtYWlsQXJiaXRyYXJ5XzEuZW1haWxBZGRyZXNzOyB9IH0pO1xuY29uc3QgRmxvYXRpbmdQb2ludEFyYml0cmFyeV8xID0gcmVxdWlyZShcIi4vY2hlY2svYXJiaXRyYXJ5L0Zsb2F0aW5nUG9pbnRBcmJpdHJhcnlcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJkb3VibGVcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIEZsb2F0aW5nUG9pbnRBcmJpdHJhcnlfMS5kb3VibGU7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJmbG9hdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gRmxvYXRpbmdQb2ludEFyYml0cmFyeV8xLmZsb2F0OyB9IH0pO1xuY29uc3QgZnJlcXVlbmN5XzEgPSByZXF1aXJlKFwiLi9hcmJpdHJhcnkvZnJlcXVlbmN5XCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZnJlcXVlbmN5XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBmcmVxdWVuY3lfMS5mcmVxdWVuY3k7IH0gfSk7XG5jb25zdCBjb21wYXJlQm9vbGVhbkZ1bmNfMSA9IHJlcXVpcmUoXCIuL2FyYml0cmFyeS9jb21wYXJlQm9vbGVhbkZ1bmNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJjb21wYXJlQm9vbGVhbkZ1bmNcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvbXBhcmVCb29sZWFuRnVuY18xLmNvbXBhcmVCb29sZWFuRnVuYzsgfSB9KTtcbmNvbnN0IGNvbXBhcmVGdW5jXzEgPSByZXF1aXJlKFwiLi9hcmJpdHJhcnkvY29tcGFyZUZ1bmNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJjb21wYXJlRnVuY1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY29tcGFyZUZ1bmNfMS5jb21wYXJlRnVuYzsgfSB9KTtcbmNvbnN0IGZ1bmNfMSA9IHJlcXVpcmUoXCIuL2FyYml0cmFyeS9mdW5jXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZnVuY1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZnVuY18xLmZ1bmM7IH0gfSk7XG5jb25zdCBIb3N0QXJiaXRyYXJ5XzEgPSByZXF1aXJlKFwiLi9jaGVjay9hcmJpdHJhcnkvSG9zdEFyYml0cmFyeVwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImRvbWFpblwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gSG9zdEFyYml0cmFyeV8xLmRvbWFpbjsgfSB9KTtcbmNvbnN0IGludGVnZXJfMSA9IHJlcXVpcmUoXCIuL2FyYml0cmFyeS9pbnRlZ2VyXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiaW50ZWdlclwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaW50ZWdlcl8xLmludGVnZXI7IH0gfSk7XG5jb25zdCBtYXhTYWZlSW50ZWdlcl8xID0gcmVxdWlyZShcIi4vYXJiaXRyYXJ5L21heFNhZmVJbnRlZ2VyXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwibWF4U2FmZUludGVnZXJcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG1heFNhZmVJbnRlZ2VyXzEubWF4U2FmZUludGVnZXI7IH0gfSk7XG5jb25zdCBtYXhTYWZlTmF0XzEgPSByZXF1aXJlKFwiLi9hcmJpdHJhcnkvbWF4U2FmZU5hdFwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIm1heFNhZmVOYXRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG1heFNhZmVOYXRfMS5tYXhTYWZlTmF0OyB9IH0pO1xuY29uc3QgbmF0XzEgPSByZXF1aXJlKFwiLi9hcmJpdHJhcnkvbmF0XCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwibmF0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBuYXRfMS5uYXQ7IH0gfSk7XG5jb25zdCBpcFY0XzEgPSByZXF1aXJlKFwiLi9hcmJpdHJhcnkvaXBWNFwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImlwVjRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGlwVjRfMS5pcFY0OyB9IH0pO1xuY29uc3QgaXBWNEV4dGVuZGVkXzEgPSByZXF1aXJlKFwiLi9hcmJpdHJhcnkvaXBWNEV4dGVuZGVkXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiaXBWNEV4dGVuZGVkXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBpcFY0RXh0ZW5kZWRfMS5pcFY0RXh0ZW5kZWQ7IH0gfSk7XG5jb25zdCBpcFY2XzEgPSByZXF1aXJlKFwiLi9hcmJpdHJhcnkvaXBWNlwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImlwVjZcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGlwVjZfMS5pcFY2OyB9IH0pO1xuY29uc3QgbGV0cmVjXzEgPSByZXF1aXJlKFwiLi9hcmJpdHJhcnkvbGV0cmVjXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwibGV0cmVjXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBsZXRyZWNfMS5sZXRyZWM7IH0gfSk7XG5jb25zdCBsb3JlbV8xID0gcmVxdWlyZShcIi4vYXJiaXRyYXJ5L2xvcmVtXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwibG9yZW1cIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGxvcmVtXzEubG9yZW07IH0gfSk7XG5jb25zdCBtYXBUb0NvbnN0YW50XzEgPSByZXF1aXJlKFwiLi9hcmJpdHJhcnkvbWFwVG9Db25zdGFudFwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIm1hcFRvQ29uc3RhbnRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG1hcFRvQ29uc3RhbnRfMS5tYXBUb0NvbnN0YW50OyB9IH0pO1xuY29uc3QgbWVtb18xID0gcmVxdWlyZShcIi4vYXJiaXRyYXJ5L21lbW9cIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJtZW1vXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBtZW1vXzEubWVtbzsgfSB9KTtcbmNvbnN0IG1peGVkQ2FzZV8xID0gcmVxdWlyZShcIi4vYXJiaXRyYXJ5L21peGVkQ2FzZVwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIm1peGVkQ2FzZVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbWl4ZWRDYXNlXzEubWl4ZWRDYXNlOyB9IH0pO1xuY29uc3QgT2JqZWN0QXJiaXRyYXJ5XzEgPSByZXF1aXJlKFwiLi9jaGVjay9hcmJpdHJhcnkvT2JqZWN0QXJiaXRyYXJ5XCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiYW55dGhpbmdcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIE9iamVjdEFyYml0cmFyeV8xLmFueXRoaW5nOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwianNvblwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gT2JqZWN0QXJiaXRyYXJ5XzEuanNvbjsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImpzb25PYmplY3RcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIE9iamVjdEFyYml0cmFyeV8xLmpzb25PYmplY3Q7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJvYmplY3RcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIE9iamVjdEFyYml0cmFyeV8xLm9iamVjdDsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInVuaWNvZGVKc29uXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBPYmplY3RBcmJpdHJhcnlfMS51bmljb2RlSnNvbjsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInVuaWNvZGVKc29uT2JqZWN0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBPYmplY3RBcmJpdHJhcnlfMS51bmljb2RlSnNvbk9iamVjdDsgfSB9KTtcbmNvbnN0IG9uZW9mXzEgPSByZXF1aXJlKFwiLi9hcmJpdHJhcnkvb25lb2ZcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJvbmVvZlwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gb25lb2ZfMS5vbmVvZjsgfSB9KTtcbmNvbnN0IG9wdGlvbl8xID0gcmVxdWlyZShcIi4vYXJiaXRyYXJ5L29wdGlvblwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIm9wdGlvblwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gb3B0aW9uXzEub3B0aW9uOyB9IH0pO1xuY29uc3QgcmVjb3JkXzEgPSByZXF1aXJlKFwiLi9hcmJpdHJhcnkvcmVjb3JkXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwicmVjb3JkXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiByZWNvcmRfMS5yZWNvcmQ7IH0gfSk7XG5jb25zdCBzZXRfMSA9IHJlcXVpcmUoXCIuL2FyYml0cmFyeS9zZXRcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJzZXRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHNldF8xLnNldDsgfSB9KTtcbmNvbnN0IGluZmluaXRlU3RyZWFtXzEgPSByZXF1aXJlKFwiLi9hcmJpdHJhcnkvaW5maW5pdGVTdHJlYW1cIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJpbmZpbml0ZVN0cmVhbVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaW5maW5pdGVTdHJlYW1fMS5pbmZpbml0ZVN0cmVhbTsgfSB9KTtcbmNvbnN0IGFzY2lpU3RyaW5nXzEgPSByZXF1aXJlKFwiLi9hcmJpdHJhcnkvYXNjaWlTdHJpbmdcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJhc2NpaVN0cmluZ1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gYXNjaWlTdHJpbmdfMS5hc2NpaVN0cmluZzsgfSB9KTtcbmNvbnN0IGJhc2U2NFN0cmluZ18xID0gcmVxdWlyZShcIi4vYXJiaXRyYXJ5L2Jhc2U2NFN0cmluZ1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImJhc2U2NFN0cmluZ1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gYmFzZTY0U3RyaW5nXzEuYmFzZTY0U3RyaW5nOyB9IH0pO1xuY29uc3QgZnVsbFVuaWNvZGVTdHJpbmdfMSA9IHJlcXVpcmUoXCIuL2FyYml0cmFyeS9mdWxsVW5pY29kZVN0cmluZ1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImZ1bGxVbmljb2RlU3RyaW5nXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBmdWxsVW5pY29kZVN0cmluZ18xLmZ1bGxVbmljb2RlU3RyaW5nOyB9IH0pO1xuY29uc3QgaGV4YVN0cmluZ18xID0gcmVxdWlyZShcIi4vYXJiaXRyYXJ5L2hleGFTdHJpbmdcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJoZXhhU3RyaW5nXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBoZXhhU3RyaW5nXzEuaGV4YVN0cmluZzsgfSB9KTtcbmNvbnN0IHN0cmluZ18xID0gcmVxdWlyZShcIi4vYXJiaXRyYXJ5L3N0cmluZ1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInN0cmluZ1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gc3RyaW5nXzEuc3RyaW5nOyB9IH0pO1xuY29uc3Qgc3RyaW5nMTZiaXRzXzEgPSByZXF1aXJlKFwiLi9hcmJpdHJhcnkvc3RyaW5nMTZiaXRzXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwic3RyaW5nMTZiaXRzXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBzdHJpbmcxNmJpdHNfMS5zdHJpbmcxNmJpdHM7IH0gfSk7XG5jb25zdCBzdHJpbmdPZl8xID0gcmVxdWlyZShcIi4vYXJiaXRyYXJ5L3N0cmluZ09mXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwic3RyaW5nT2ZcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHN0cmluZ09mXzEuc3RyaW5nT2Y7IH0gfSk7XG5jb25zdCB1bmljb2RlU3RyaW5nXzEgPSByZXF1aXJlKFwiLi9hcmJpdHJhcnkvdW5pY29kZVN0cmluZ1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInVuaWNvZGVTdHJpbmdcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHVuaWNvZGVTdHJpbmdfMS51bmljb2RlU3RyaW5nOyB9IH0pO1xuY29uc3QgU3ViYXJyYXlBcmJpdHJhcnlfMSA9IHJlcXVpcmUoXCIuL2NoZWNrL2FyYml0cmFyeS9TdWJhcnJheUFyYml0cmFyeVwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInNodWZmbGVkU3ViYXJyYXlcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFN1YmFycmF5QXJiaXRyYXJ5XzEuc2h1ZmZsZWRTdWJhcnJheTsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInN1YmFycmF5XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBTdWJhcnJheUFyYml0cmFyeV8xLnN1YmFycmF5OyB9IH0pO1xuY29uc3QgZ2VuZXJpY1R1cGxlXzEgPSByZXF1aXJlKFwiLi9hcmJpdHJhcnkvZ2VuZXJpY1R1cGxlXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZ2VuZXJpY1R1cGxlXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBnZW5lcmljVHVwbGVfMS5nZW5lcmljVHVwbGU7IH0gfSk7XG5jb25zdCB0dXBsZV8xID0gcmVxdWlyZShcIi4vYXJiaXRyYXJ5L3R1cGxlXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwidHVwbGVcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHR1cGxlXzEudHVwbGU7IH0gfSk7XG5jb25zdCBVdWlkQXJiaXRyYXJ5XzEgPSByZXF1aXJlKFwiLi9jaGVjay9hcmJpdHJhcnkvVXVpZEFyYml0cmFyeVwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInV1aWRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFV1aWRBcmJpdHJhcnlfMS51dWlkOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwidXVpZFZcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFV1aWRBcmJpdHJhcnlfMS51dWlkVjsgfSB9KTtcbmNvbnN0IFdlYkFyYml0cmFyeV8xID0gcmVxdWlyZShcIi4vY2hlY2svYXJiaXRyYXJ5L1dlYkFyYml0cmFyeVwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIndlYkF1dGhvcml0eVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gV2ViQXJiaXRyYXJ5XzEud2ViQXV0aG9yaXR5OyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwid2ViRnJhZ21lbnRzXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBXZWJBcmJpdHJhcnlfMS53ZWJGcmFnbWVudHM7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJ3ZWJRdWVyeVBhcmFtZXRlcnNcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFdlYkFyYml0cmFyeV8xLndlYlF1ZXJ5UGFyYW1ldGVyczsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIndlYlNlZ21lbnRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFdlYkFyYml0cmFyeV8xLndlYlNlZ21lbnQ7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJ3ZWJVcmxcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFdlYkFyYml0cmFyeV8xLndlYlVybDsgfSB9KTtcbmNvbnN0IENvbW1hbmRzQXJiaXRyYXJ5XzEgPSByZXF1aXJlKFwiLi9jaGVjay9tb2RlbC9jb21tYW5kcy9Db21tYW5kc0FyYml0cmFyeVwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImNvbW1hbmRzXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBDb21tYW5kc0FyYml0cmFyeV8xLmNvbW1hbmRzOyB9IH0pO1xuY29uc3QgTW9kZWxSdW5uZXJfMSA9IHJlcXVpcmUoXCIuL2NoZWNrL21vZGVsL01vZGVsUnVubmVyXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiYXN5bmNNb2RlbFJ1blwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gTW9kZWxSdW5uZXJfMS5hc3luY01vZGVsUnVuOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwibW9kZWxSdW5cIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIE1vZGVsUnVubmVyXzEubW9kZWxSdW47IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJzY2hlZHVsZWRNb2RlbFJ1blwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gTW9kZWxSdW5uZXJfMS5zY2hlZHVsZWRNb2RlbFJ1bjsgfSB9KTtcbmNvbnN0IFJhbmRvbV8xID0gcmVxdWlyZShcIi4vcmFuZG9tL2dlbmVyYXRvci9SYW5kb21cIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJSYW5kb21cIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFJhbmRvbV8xLlJhbmRvbTsgfSB9KTtcbmNvbnN0IEdsb2JhbFBhcmFtZXRlcnNfMSA9IHJlcXVpcmUoXCIuL2NoZWNrL3J1bm5lci9jb25maWd1cmF0aW9uL0dsb2JhbFBhcmFtZXRlcnNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJjb25maWd1cmVHbG9iYWxcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIEdsb2JhbFBhcmFtZXRlcnNfMS5jb25maWd1cmVHbG9iYWw7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJyZWFkQ29uZmlndXJlR2xvYmFsXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBHbG9iYWxQYXJhbWV0ZXJzXzEucmVhZENvbmZpZ3VyZUdsb2JhbDsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInJlc2V0Q29uZmlndXJlR2xvYmFsXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBHbG9iYWxQYXJhbWV0ZXJzXzEucmVzZXRDb25maWd1cmVHbG9iYWw7IH0gfSk7XG5jb25zdCBWZXJib3NpdHlMZXZlbF8xID0gcmVxdWlyZShcIi4vY2hlY2svcnVubmVyL2NvbmZpZ3VyYXRpb24vVmVyYm9zaXR5TGV2ZWxcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJWZXJib3NpdHlMZXZlbFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gVmVyYm9zaXR5TGV2ZWxfMS5WZXJib3NpdHlMZXZlbDsgfSB9KTtcbmNvbnN0IEV4ZWN1dGlvblN0YXR1c18xID0gcmVxdWlyZShcIi4vY2hlY2svcnVubmVyL3JlcG9ydGVyL0V4ZWN1dGlvblN0YXR1c1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkV4ZWN1dGlvblN0YXR1c1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gRXhlY3V0aW9uU3RhdHVzXzEuRXhlY3V0aW9uU3RhdHVzOyB9IH0pO1xuY29uc3Qgc3ltYm9sc18xID0gcmVxdWlyZShcIi4vY2hlY2svc3ltYm9sc1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImNsb25lTWV0aG9kXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBzeW1ib2xzXzEuY2xvbmVNZXRob2Q7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJjbG9uZUlmTmVlZGVkXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBzeW1ib2xzXzEuY2xvbmVJZk5lZWRlZDsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImhhc0Nsb25lTWV0aG9kXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBzeW1ib2xzXzEuaGFzQ2xvbmVNZXRob2Q7IH0gfSk7XG5jb25zdCBTdHJlYW1fMSA9IHJlcXVpcmUoXCIuL3N0cmVhbS9TdHJlYW1cIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJTdHJlYW1cIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFN0cmVhbV8xLlN0cmVhbTsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInN0cmVhbVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gU3RyZWFtXzEuc3RyZWFtOyB9IH0pO1xuY29uc3QgaGFzaF8xID0gcmVxdWlyZShcIi4vdXRpbHMvaGFzaFwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImhhc2hcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGhhc2hfMS5oYXNoOyB9IH0pO1xuY29uc3Qgc3RyaW5naWZ5XzEgPSByZXF1aXJlKFwiLi91dGlscy9zdHJpbmdpZnlcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJzdHJpbmdpZnlcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHN0cmluZ2lmeV8xLnN0cmluZ2lmeTsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImFzeW5jU3RyaW5naWZ5XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBzdHJpbmdpZnlfMS5hc3luY1N0cmluZ2lmeTsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInRvU3RyaW5nTWV0aG9kXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBzdHJpbmdpZnlfMS50b1N0cmluZ01ldGhvZDsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImhhc1RvU3RyaW5nTWV0aG9kXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBzdHJpbmdpZnlfMS5oYXNUb1N0cmluZ01ldGhvZDsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImFzeW5jVG9TdHJpbmdNZXRob2RcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHN0cmluZ2lmeV8xLmFzeW5jVG9TdHJpbmdNZXRob2Q7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJoYXNBc3luY1RvU3RyaW5nTWV0aG9kXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBzdHJpbmdpZnlfMS5oYXNBc3luY1RvU3RyaW5nTWV0aG9kOyB9IH0pO1xuY29uc3Qgc2NoZWR1bGVyXzEgPSByZXF1aXJlKFwiLi9hcmJpdHJhcnkvc2NoZWR1bGVyXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwic2NoZWR1bGVyXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBzY2hlZHVsZXJfMS5zY2hlZHVsZXI7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJzY2hlZHVsZXJGb3JcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHNjaGVkdWxlcl8xLnNjaGVkdWxlckZvcjsgfSB9KTtcbmNvbnN0IFJ1bkRldGFpbHNGb3JtYXR0ZXJfMSA9IHJlcXVpcmUoXCIuL2NoZWNrL3J1bm5lci91dGlscy9SdW5EZXRhaWxzRm9ybWF0dGVyXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZGVmYXVsdFJlcG9ydE1lc3NhZ2VcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFJ1bkRldGFpbHNGb3JtYXR0ZXJfMS5kZWZhdWx0UmVwb3J0TWVzc2FnZTsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImFzeW5jRGVmYXVsdFJlcG9ydE1lc3NhZ2VcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFJ1bkRldGFpbHNGb3JtYXR0ZXJfMS5hc3luY0RlZmF1bHRSZXBvcnRNZXNzYWdlOyB9IH0pO1xuY29uc3QgQXJiaXRyYXJ5V2l0aFNocmlua18xID0gcmVxdWlyZShcIi4vY2hlY2svYXJiaXRyYXJ5L2RlZmluaXRpb24vQXJiaXRyYXJ5V2l0aFNocmlua1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkFyYml0cmFyeVdpdGhTaHJpbmtcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIEFyYml0cmFyeVdpdGhTaHJpbmtfMS5BcmJpdHJhcnlXaXRoU2hyaW5rOyB9IH0pO1xuY29uc3QgQXJiaXRyYXJ5V2l0aENvbnRleHR1YWxTaHJpbmtfMSA9IHJlcXVpcmUoXCIuL2NoZWNrL2FyYml0cmFyeS9kZWZpbml0aW9uL0FyYml0cmFyeVdpdGhDb250ZXh0dWFsU2hyaW5rXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQXJiaXRyYXJ5V2l0aENvbnRleHR1YWxTaHJpbmtcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIEFyYml0cmFyeVdpdGhDb250ZXh0dWFsU2hyaW5rXzEuQXJiaXRyYXJ5V2l0aENvbnRleHR1YWxTaHJpbms7IH0gfSk7XG5jb25zdCBQcmVjb25kaXRpb25GYWlsdXJlXzEgPSByZXF1aXJlKFwiLi9jaGVjay9wcmVjb25kaXRpb24vUHJlY29uZGl0aW9uRmFpbHVyZVwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlByZWNvbmRpdGlvbkZhaWx1cmVcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFByZWNvbmRpdGlvbkZhaWx1cmVfMS5QcmVjb25kaXRpb25GYWlsdXJlOyB9IH0pO1xuY29uc3QgaW50OEFycmF5XzEgPSByZXF1aXJlKFwiLi9hcmJpdHJhcnkvaW50OEFycmF5XCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiaW50OEFycmF5XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBpbnQ4QXJyYXlfMS5pbnQ4QXJyYXk7IH0gfSk7XG5jb25zdCBpbnQxNkFycmF5XzEgPSByZXF1aXJlKFwiLi9hcmJpdHJhcnkvaW50MTZBcnJheVwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImludDE2QXJyYXlcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGludDE2QXJyYXlfMS5pbnQxNkFycmF5OyB9IH0pO1xuY29uc3QgaW50MzJBcnJheV8xID0gcmVxdWlyZShcIi4vYXJiaXRyYXJ5L2ludDMyQXJyYXlcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJpbnQzMkFycmF5XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBpbnQzMkFycmF5XzEuaW50MzJBcnJheTsgfSB9KTtcbmNvbnN0IHVpbnQ4QXJyYXlfMSA9IHJlcXVpcmUoXCIuL2FyYml0cmFyeS91aW50OEFycmF5XCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwidWludDhBcnJheVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdWludDhBcnJheV8xLnVpbnQ4QXJyYXk7IH0gfSk7XG5jb25zdCB1aW50OENsYW1wZWRBcnJheV8xID0gcmVxdWlyZShcIi4vYXJiaXRyYXJ5L3VpbnQ4Q2xhbXBlZEFycmF5XCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwidWludDhDbGFtcGVkQXJyYXlcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHVpbnQ4Q2xhbXBlZEFycmF5XzEudWludDhDbGFtcGVkQXJyYXk7IH0gfSk7XG5jb25zdCB1aW50MTZBcnJheV8xID0gcmVxdWlyZShcIi4vYXJiaXRyYXJ5L3VpbnQxNkFycmF5XCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwidWludDE2QXJyYXlcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHVpbnQxNkFycmF5XzEudWludDE2QXJyYXk7IH0gfSk7XG5jb25zdCB1aW50MzJBcnJheV8xID0gcmVxdWlyZShcIi4vYXJiaXRyYXJ5L3VpbnQzMkFycmF5XCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwidWludDMyQXJyYXlcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHVpbnQzMkFycmF5XzEudWludDMyQXJyYXk7IH0gfSk7XG5jb25zdCBmbG9hdDMyQXJyYXlfMSA9IHJlcXVpcmUoXCIuL2FyYml0cmFyeS9mbG9hdDMyQXJyYXlcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJmbG9hdDMyQXJyYXlcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGZsb2F0MzJBcnJheV8xLmZsb2F0MzJBcnJheTsgfSB9KTtcbmNvbnN0IGZsb2F0NjRBcnJheV8xID0gcmVxdWlyZShcIi4vYXJiaXRyYXJ5L2Zsb2F0NjRBcnJheVwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImZsb2F0NjRBcnJheVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZmxvYXQ2NEFycmF5XzEuZmxvYXQ2NEFycmF5OyB9IH0pO1xuY29uc3QgU3BhcnNlQXJyYXlBcmJpdHJhcnlfMSA9IHJlcXVpcmUoXCIuL2NoZWNrL2FyYml0cmFyeS9TcGFyc2VBcnJheUFyYml0cmFyeVwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInNwYXJzZUFycmF5XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBTcGFyc2VBcnJheUFyYml0cmFyeV8xLnNwYXJzZUFycmF5OyB9IH0pO1xuY29uc3QgTmV4dEFyYml0cmFyeV8xID0gcmVxdWlyZShcIi4vY2hlY2svYXJiaXRyYXJ5L2RlZmluaXRpb24vTmV4dEFyYml0cmFyeVwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIk5leHRBcmJpdHJhcnlcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIE5leHRBcmJpdHJhcnlfMS5OZXh0QXJiaXRyYXJ5OyB9IH0pO1xuY29uc3QgTmV4dFZhbHVlXzEgPSByZXF1aXJlKFwiLi9jaGVjay9hcmJpdHJhcnkvZGVmaW5pdGlvbi9OZXh0VmFsdWVcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJOZXh0VmFsdWVcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIE5leHRWYWx1ZV8xLk5leHRWYWx1ZTsgfSB9KTtcbmNvbnN0IENvbnZlcnRlcnNfMSA9IHJlcXVpcmUoXCIuL2NoZWNrL2FyYml0cmFyeS9kZWZpbml0aW9uL0NvbnZlcnRlcnNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJjb252ZXJ0RnJvbU5leHRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIENvbnZlcnRlcnNfMS5jb252ZXJ0RnJvbU5leHQ7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJjb252ZXJ0RnJvbU5leHRXaXRoU2hydW5rT25jZVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gQ29udmVydGVyc18xLmNvbnZlcnRGcm9tTmV4dFdpdGhTaHJ1bmtPbmNlOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiY29udmVydFRvTmV4dFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gQ29udmVydGVyc18xLmNvbnZlcnRUb05leHQ7IH0gfSk7XG5jb25zdCBfX3R5cGUgPSAnY29tbW9uanMnO1xuZXhwb3J0cy5fX3R5cGUgPSBfX3R5cGU7XG5jb25zdCBfX3ZlcnNpb24gPSAnMi4xNy4wJztcbmV4cG9ydHMuX192ZXJzaW9uID0gX192ZXJzaW9uO1xuY29uc3QgX19jb21taXRIYXNoID0gJ2I3MDY0YTIxNDEyZWI5ZTY4ZWRiM2FlY2U3NGQ0NTUyMmM4MGJjNzcnO1xuZXhwb3J0cy5fX2NvbW1pdEhhc2ggPSBfX2NvbW1pdEhhc2g7XG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9KTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19leHBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2V4cG9ydFN0YXIpIHx8IGZ1bmN0aW9uKG0sIGV4cG9ydHMpIHtcbiAgICBmb3IgKHZhciBwIGluIG0pIGlmIChwICE9PSBcImRlZmF1bHRcIiAmJiAhT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGV4cG9ydHMsIHApKSBfX2NyZWF0ZUJpbmRpbmcoZXhwb3J0cywgbSwgcCk7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgZmMgPSByZXF1aXJlKFwiLi9mYXN0LWNoZWNrLWRlZmF1bHRcIik7XG5leHBvcnRzLmRlZmF1bHQgPSBmYztcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9mYXN0LWNoZWNrLWRlZmF1bHRcIiksIGV4cG9ydHMpO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmNvbnZlcnRUb1JhbmRvbUdlbmVyYXRvciA9IHZvaWQgMDtcbmNsYXNzIENvbnZlcnRlZFJhbmRvbUdlbmVyYXRvciB7XG4gICAgY29uc3RydWN0b3Iocm5nKSB7XG4gICAgICAgIHRoaXMucm5nID0gcm5nO1xuICAgICAgICBpZiAodHlwZW9mIHRoaXMucm5nLmp1bXAgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHRoaXMuanVtcCA9IGZ1bmN0aW9uIGp1bXAoKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgb3V0ID0gdGhpcy5qdW1wKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBDb252ZXJ0ZWRSYW5kb21HZW5lcmF0b3Iob3V0KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB0aGlzLnVuc2FmZUp1bXAgPSBmdW5jdGlvbiB1bnNhZmVKdW1wKCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG91dCA9IHRoaXMuanVtcCgpO1xuICAgICAgICAgICAgICAgIHRoaXMucm5nID0gb3V0O1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBtaW4oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJuZy5taW4oKTtcbiAgICB9XG4gICAgbWF4KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5ybmcubWF4KCk7XG4gICAgfVxuICAgIGNsb25lKCkge1xuICAgICAgICByZXR1cm4gbmV3IENvbnZlcnRlZFJhbmRvbUdlbmVyYXRvcih0aGlzLnJuZyk7XG4gICAgfVxuICAgIG5leHQoKSB7XG4gICAgICAgIGNvbnN0IG91dCA9IHRoaXMucm5nLm5leHQoKTtcbiAgICAgICAgcmV0dXJuIFtvdXRbMF0sIG5ldyBDb252ZXJ0ZWRSYW5kb21HZW5lcmF0b3Iob3V0WzFdKV07XG4gICAgfVxuICAgIHVuc2FmZU5leHQoKSB7XG4gICAgICAgIGNvbnN0IG91dCA9IHRoaXMucm5nLm5leHQoKTtcbiAgICAgICAgdGhpcy5ybmcgPSBvdXRbMV07XG4gICAgICAgIHJldHVybiBvdXRbMF07XG4gICAgfVxufVxuZnVuY3Rpb24gY29udmVydFRvUmFuZG9tR2VuZXJhdG9yKHJuZykge1xuICAgIGlmICgnY2xvbmUnIGluIHJuZyAmJiAndW5zYWZlTmV4dCcgaW4gcm5nKSB7XG4gICAgICAgIHJldHVybiBybmc7XG4gICAgfVxuICAgIHJldHVybiBuZXcgQ29udmVydGVkUmFuZG9tR2VuZXJhdG9yKHJuZyk7XG59XG5leHBvcnRzLmNvbnZlcnRUb1JhbmRvbUdlbmVyYXRvciA9IGNvbnZlcnRUb1JhbmRvbUdlbmVyYXRvcjtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5SYW5kb20gPSB2b2lkIDA7XG5jb25zdCBwdXJlX3JhbmRfMSA9IHJlcXVpcmUoXCJwdXJlLXJhbmRcIik7XG5jb25zdCBQdXJlUmFuZG9tXzEgPSByZXF1aXJlKFwiLi9QdXJlUmFuZG9tXCIpO1xuY2xhc3MgUmFuZG9tIHtcbiAgICBjb25zdHJ1Y3Rvcihzb3VyY2VSbmcpIHtcbiAgICAgICAgdGhpcy5pbnRlcm5hbFJuZyA9IFB1cmVSYW5kb21fMS5jb252ZXJ0VG9SYW5kb21HZW5lcmF0b3Ioc291cmNlUm5nKS5jbG9uZSgpO1xuICAgIH1cbiAgICBjbG9uZSgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBSYW5kb20odGhpcy5pbnRlcm5hbFJuZyk7XG4gICAgfVxuICAgIG5leHQoYml0cykge1xuICAgICAgICByZXR1cm4gcHVyZV9yYW5kXzEudW5zYWZlVW5pZm9ybUludERpc3RyaWJ1dGlvbigwLCAoMSA8PCBiaXRzKSAtIDEsIHRoaXMuaW50ZXJuYWxSbmcpO1xuICAgIH1cbiAgICBuZXh0Qm9vbGVhbigpIHtcbiAgICAgICAgcmV0dXJuIHB1cmVfcmFuZF8xLnVuc2FmZVVuaWZvcm1JbnREaXN0cmlidXRpb24oMCwgMSwgdGhpcy5pbnRlcm5hbFJuZykgPT0gMTtcbiAgICB9XG4gICAgbmV4dEludChtaW4sIG1heCkge1xuICAgICAgICByZXR1cm4gcHVyZV9yYW5kXzEudW5zYWZlVW5pZm9ybUludERpc3RyaWJ1dGlvbihtaW4gPT0gbnVsbCA/IFJhbmRvbS5NSU5fSU5UIDogbWluLCBtYXggPT0gbnVsbCA/IFJhbmRvbS5NQVhfSU5UIDogbWF4LCB0aGlzLmludGVybmFsUm5nKTtcbiAgICB9XG4gICAgbmV4dEJpZ0ludChtaW4sIG1heCkge1xuICAgICAgICByZXR1cm4gcHVyZV9yYW5kXzEudW5zYWZlVW5pZm9ybUJpZ0ludERpc3RyaWJ1dGlvbihtaW4sIG1heCwgdGhpcy5pbnRlcm5hbFJuZyk7XG4gICAgfVxuICAgIG5leHRBcnJheUludChtaW4sIG1heCkge1xuICAgICAgICByZXR1cm4gcHVyZV9yYW5kXzEudW5zYWZlVW5pZm9ybUFycmF5SW50RGlzdHJpYnV0aW9uKG1pbiwgbWF4LCB0aGlzLmludGVybmFsUm5nKTtcbiAgICB9XG4gICAgbmV4dERvdWJsZSgpIHtcbiAgICAgICAgY29uc3QgYSA9IHRoaXMubmV4dCgyNik7XG4gICAgICAgIGNvbnN0IGIgPSB0aGlzLm5leHQoMjcpO1xuICAgICAgICByZXR1cm4gKGEgKiBSYW5kb20uREJMX0ZBQ1RPUiArIGIpICogUmFuZG9tLkRCTF9ESVZJU09SO1xuICAgIH1cbn1cbmV4cG9ydHMuUmFuZG9tID0gUmFuZG9tO1xuUmFuZG9tLk1JTl9JTlQgPSAweDgwMDAwMDAwIHwgMDtcblJhbmRvbS5NQVhfSU5UID0gMHg3ZmZmZmZmZiB8IDA7XG5SYW5kb20uREJMX0ZBQ1RPUiA9IE1hdGgucG93KDIsIDI3KTtcblJhbmRvbS5EQkxfRElWSVNPUiA9IE1hdGgucG93KDIsIC01Myk7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMubWFrZUxhenkgPSB2b2lkIDA7XG5jbGFzcyBMYXp5SXRlcmFibGVJdGVyYXRvciB7XG4gICAgY29uc3RydWN0b3IocHJvZHVjZXIpIHtcbiAgICAgICAgdGhpcy5wcm9kdWNlciA9IHByb2R1Y2VyO1xuICAgIH1cbiAgICBbU3ltYm9sLml0ZXJhdG9yXSgpIHtcbiAgICAgICAgaWYgKHRoaXMuaXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5pdCA9IHRoaXMucHJvZHVjZXIoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5pdDtcbiAgICB9XG4gICAgbmV4dCgpIHtcbiAgICAgICAgaWYgKHRoaXMuaXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5pdCA9IHRoaXMucHJvZHVjZXIoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5pdC5uZXh0KCk7XG4gICAgfVxufVxuZnVuY3Rpb24gbWFrZUxhenkocHJvZHVjZXIpIHtcbiAgICByZXR1cm4gbmV3IExhenlJdGVyYWJsZUl0ZXJhdG9yKHByb2R1Y2VyKTtcbn1cbmV4cG9ydHMubWFrZUxhenkgPSBtYWtlTGF6eTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5zdHJlYW0gPSBleHBvcnRzLlN0cmVhbSA9IHZvaWQgMDtcbmNvbnN0IFN0cmVhbUhlbHBlcnNfMSA9IHJlcXVpcmUoXCIuL1N0cmVhbUhlbHBlcnNcIik7XG5jbGFzcyBTdHJlYW0ge1xuICAgIGNvbnN0cnVjdG9yKGcpIHtcbiAgICAgICAgdGhpcy5nID0gZztcbiAgICB9XG4gICAgc3RhdGljIG5pbCgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTdHJlYW0oU3RyZWFtSGVscGVyc18xLm5pbEhlbHBlcigpKTtcbiAgICB9XG4gICAgc3RhdGljIG9mKC4uLmVsZW1lbnRzKSB7XG4gICAgICAgIHJldHVybiBuZXcgU3RyZWFtKGVsZW1lbnRzW1N5bWJvbC5pdGVyYXRvcl0oKSk7XG4gICAgfVxuICAgIG5leHQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmcubmV4dCgpO1xuICAgIH1cbiAgICBbU3ltYm9sLml0ZXJhdG9yXSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZztcbiAgICB9XG4gICAgbWFwKGYpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTdHJlYW0oU3RyZWFtSGVscGVyc18xLm1hcEhlbHBlcih0aGlzLmcsIGYpKTtcbiAgICB9XG4gICAgZmxhdE1hcChmKSB7XG4gICAgICAgIHJldHVybiBuZXcgU3RyZWFtKFN0cmVhbUhlbHBlcnNfMS5mbGF0TWFwSGVscGVyKHRoaXMuZywgZikpO1xuICAgIH1cbiAgICBkcm9wV2hpbGUoZikge1xuICAgICAgICBsZXQgZm91bmRFbGlnaWJsZSA9IGZhbHNlO1xuICAgICAgICBmdW5jdGlvbiogaGVscGVyKHYpIHtcbiAgICAgICAgICAgIGlmIChmb3VuZEVsaWdpYmxlIHx8ICFmKHYpKSB7XG4gICAgICAgICAgICAgICAgZm91bmRFbGlnaWJsZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgeWllbGQgdjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5mbGF0TWFwKGhlbHBlcik7XG4gICAgfVxuICAgIGRyb3Aobikge1xuICAgICAgICBsZXQgaWR4ID0gMDtcbiAgICAgICAgZnVuY3Rpb24gaGVscGVyKCkge1xuICAgICAgICAgICAgcmV0dXJuIGlkeCsrIDwgbjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5kcm9wV2hpbGUoaGVscGVyKTtcbiAgICB9XG4gICAgdGFrZVdoaWxlKGYpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTdHJlYW0oU3RyZWFtSGVscGVyc18xLnRha2VXaGlsZUhlbHBlcih0aGlzLmcsIGYpKTtcbiAgICB9XG4gICAgdGFrZShuKSB7XG4gICAgICAgIHJldHVybiBuZXcgU3RyZWFtKFN0cmVhbUhlbHBlcnNfMS50YWtlTkhlbHBlcih0aGlzLmcsIG4pKTtcbiAgICB9XG4gICAgZmlsdGVyKGYpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTdHJlYW0oU3RyZWFtSGVscGVyc18xLmZpbHRlckhlbHBlcih0aGlzLmcsIGYpKTtcbiAgICB9XG4gICAgZXZlcnkoZikge1xuICAgICAgICBmb3IgKGNvbnN0IHYgb2YgdGhpcy5nKSB7XG4gICAgICAgICAgICBpZiAoIWYodikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGhhcyhmKSB7XG4gICAgICAgIGZvciAoY29uc3QgdiBvZiB0aGlzLmcpIHtcbiAgICAgICAgICAgIGlmIChmKHYpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFt0cnVlLCB2XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW2ZhbHNlLCBudWxsXTtcbiAgICB9XG4gICAgam9pbiguLi5vdGhlcnMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTdHJlYW0oU3RyZWFtSGVscGVyc18xLmpvaW5IZWxwZXIodGhpcy5nLCBvdGhlcnMpKTtcbiAgICB9XG4gICAgZ2V0TnRoT3JMYXN0KG50aCkge1xuICAgICAgICBsZXQgcmVtYWluaW5nID0gbnRoO1xuICAgICAgICBsZXQgbGFzdCA9IG51bGw7XG4gICAgICAgIGZvciAoY29uc3QgdiBvZiB0aGlzLmcpIHtcbiAgICAgICAgICAgIGlmIChyZW1haW5pbmctLSA9PT0gMClcbiAgICAgICAgICAgICAgICByZXR1cm4gdjtcbiAgICAgICAgICAgIGxhc3QgPSB2O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsYXN0O1xuICAgIH1cbn1cbmV4cG9ydHMuU3RyZWFtID0gU3RyZWFtO1xuZnVuY3Rpb24gc3RyZWFtKGcpIHtcbiAgICByZXR1cm4gbmV3IFN0cmVhbShnKTtcbn1cbmV4cG9ydHMuc3RyZWFtID0gc3RyZWFtO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmpvaW5IZWxwZXIgPSBleHBvcnRzLnRha2VXaGlsZUhlbHBlciA9IGV4cG9ydHMudGFrZU5IZWxwZXIgPSBleHBvcnRzLmZpbHRlckhlbHBlciA9IGV4cG9ydHMuZmxhdE1hcEhlbHBlciA9IGV4cG9ydHMubWFwSGVscGVyID0gZXhwb3J0cy5uaWxIZWxwZXIgPSB2b2lkIDA7XG5jbGFzcyBOaWwge1xuICAgIFtTeW1ib2wuaXRlcmF0b3JdKCkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgbmV4dCh2YWx1ZSkge1xuICAgICAgICByZXR1cm4geyB2YWx1ZSwgZG9uZTogdHJ1ZSB9O1xuICAgIH1cbn1cbk5pbC5uaWwgPSBuZXcgTmlsKCk7XG5mdW5jdGlvbiBuaWxIZWxwZXIoKSB7XG4gICAgcmV0dXJuIE5pbC5uaWw7XG59XG5leHBvcnRzLm5pbEhlbHBlciA9IG5pbEhlbHBlcjtcbmZ1bmN0aW9uKiBtYXBIZWxwZXIoZywgZikge1xuICAgIGZvciAoY29uc3QgdiBvZiBnKSB7XG4gICAgICAgIHlpZWxkIGYodik7XG4gICAgfVxufVxuZXhwb3J0cy5tYXBIZWxwZXIgPSBtYXBIZWxwZXI7XG5mdW5jdGlvbiogZmxhdE1hcEhlbHBlcihnLCBmKSB7XG4gICAgZm9yIChjb25zdCB2IG9mIGcpIHtcbiAgICAgICAgeWllbGQqIGYodik7XG4gICAgfVxufVxuZXhwb3J0cy5mbGF0TWFwSGVscGVyID0gZmxhdE1hcEhlbHBlcjtcbmZ1bmN0aW9uKiBmaWx0ZXJIZWxwZXIoZywgZikge1xuICAgIGZvciAoY29uc3QgdiBvZiBnKSB7XG4gICAgICAgIGlmIChmKHYpKSB7XG4gICAgICAgICAgICB5aWVsZCB2O1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5maWx0ZXJIZWxwZXIgPSBmaWx0ZXJIZWxwZXI7XG5mdW5jdGlvbiogdGFrZU5IZWxwZXIoZywgbikge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgICAgIGNvbnN0IGN1ciA9IGcubmV4dCgpO1xuICAgICAgICBpZiAoY3VyLmRvbmUpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHlpZWxkIGN1ci52YWx1ZTtcbiAgICB9XG59XG5leHBvcnRzLnRha2VOSGVscGVyID0gdGFrZU5IZWxwZXI7XG5mdW5jdGlvbiogdGFrZVdoaWxlSGVscGVyKGcsIGYpIHtcbiAgICBsZXQgY3VyID0gZy5uZXh0KCk7XG4gICAgd2hpbGUgKCFjdXIuZG9uZSAmJiBmKGN1ci52YWx1ZSkpIHtcbiAgICAgICAgeWllbGQgY3VyLnZhbHVlO1xuICAgICAgICBjdXIgPSBnLm5leHQoKTtcbiAgICB9XG59XG5leHBvcnRzLnRha2VXaGlsZUhlbHBlciA9IHRha2VXaGlsZUhlbHBlcjtcbmZ1bmN0aW9uKiBqb2luSGVscGVyKGcsIG90aGVycykge1xuICAgIGZvciAobGV0IGN1ciA9IGcubmV4dCgpOyAhY3VyLmRvbmU7IGN1ciA9IGcubmV4dCgpKSB7XG4gICAgICAgIHlpZWxkIGN1ci52YWx1ZTtcbiAgICB9XG4gICAgZm9yIChjb25zdCBzIG9mIG90aGVycykge1xuICAgICAgICBmb3IgKGxldCBjdXIgPSBzLm5leHQoKTsgIWN1ci5kb25lOyBjdXIgPSBzLm5leHQoKSkge1xuICAgICAgICAgICAgeWllbGQgY3VyLnZhbHVlO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5qb2luSGVscGVyID0gam9pbkhlbHBlcjtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5oYXNoID0gdm9pZCAwO1xuY29uc3QgY3JjMzJUYWJsZSA9IFtcbiAgICAweDAwMDAwMDAwLCAweDc3MDczMDk2LCAweGVlMGU2MTJjLCAweDk5MDk1MWJhLCAweDA3NmRjNDE5LCAweDcwNmFmNDhmLCAweGU5NjNhNTM1LCAweDllNjQ5NWEzLCAweDBlZGI4ODMyLFxuICAgIDB4NzlkY2I4YTQsIDB4ZTBkNWU5MWUsIDB4OTdkMmQ5ODgsIDB4MDliNjRjMmIsIDB4N2ViMTdjYmQsIDB4ZTdiODJkMDcsIDB4OTBiZjFkOTEsIDB4MWRiNzEwNjQsIDB4NmFiMDIwZjIsXG4gICAgMHhmM2I5NzE0OCwgMHg4NGJlNDFkZSwgMHgxYWRhZDQ3ZCwgMHg2ZGRkZTRlYiwgMHhmNGQ0YjU1MSwgMHg4M2QzODVjNywgMHgxMzZjOTg1NiwgMHg2NDZiYThjMCwgMHhmZDYyZjk3YSxcbiAgICAweDhhNjVjOWVjLCAweDE0MDE1YzRmLCAweDYzMDY2Y2Q5LCAweGZhMGYzZDYzLCAweDhkMDgwZGY1LCAweDNiNmUyMGM4LCAweDRjNjkxMDVlLCAweGQ1NjA0MWU0LCAweGEyNjc3MTcyLFxuICAgIDB4M2MwM2U0ZDEsIDB4NGIwNGQ0NDcsIDB4ZDIwZDg1ZmQsIDB4YTUwYWI1NmIsIDB4MzViNWE4ZmEsIDB4NDJiMjk4NmMsIDB4ZGJiYmM5ZDYsIDB4YWNiY2Y5NDAsIDB4MzJkODZjZTMsXG4gICAgMHg0NWRmNWM3NSwgMHhkY2Q2MGRjZiwgMHhhYmQxM2Q1OSwgMHgyNmQ5MzBhYywgMHg1MWRlMDAzYSwgMHhjOGQ3NTE4MCwgMHhiZmQwNjExNiwgMHgyMWI0ZjRiNSwgMHg1NmIzYzQyMyxcbiAgICAweGNmYmE5NTk5LCAweGI4YmRhNTBmLCAweDI4MDJiODllLCAweDVmMDU4ODA4LCAweGM2MGNkOWIyLCAweGIxMGJlOTI0LCAweDJmNmY3Yzg3LCAweDU4Njg0YzExLCAweGMxNjExZGFiLFxuICAgIDB4YjY2NjJkM2QsIDB4NzZkYzQxOTAsIDB4MDFkYjcxMDYsIDB4OThkMjIwYmMsIDB4ZWZkNTEwMmEsIDB4NzFiMTg1ODksIDB4MDZiNmI1MWYsIDB4OWZiZmU0YTUsIDB4ZThiOGQ0MzMsXG4gICAgMHg3ODA3YzlhMiwgMHgwZjAwZjkzNCwgMHg5NjA5YTg4ZSwgMHhlMTBlOTgxOCwgMHg3ZjZhMGRiYiwgMHgwODZkM2QyZCwgMHg5MTY0NmM5NywgMHhlNjYzNWMwMSwgMHg2YjZiNTFmNCxcbiAgICAweDFjNmM2MTYyLCAweDg1NjUzMGQ4LCAweGYyNjIwMDRlLCAweDZjMDY5NWVkLCAweDFiMDFhNTdiLCAweDgyMDhmNGMxLCAweGY1MGZjNDU3LCAweDY1YjBkOWM2LCAweDEyYjdlOTUwLFxuICAgIDB4OGJiZWI4ZWEsIDB4ZmNiOTg4N2MsIDB4NjJkZDFkZGYsIDB4MTVkYTJkNDksIDB4OGNkMzdjZjMsIDB4ZmJkNDRjNjUsIDB4NGRiMjYxNTgsIDB4M2FiNTUxY2UsIDB4YTNiYzAwNzQsXG4gICAgMHhkNGJiMzBlMiwgMHg0YWRmYTU0MSwgMHgzZGQ4OTVkNywgMHhhNGQxYzQ2ZCwgMHhkM2Q2ZjRmYiwgMHg0MzY5ZTk2YSwgMHgzNDZlZDlmYywgMHhhZDY3ODg0NiwgMHhkYTYwYjhkMCxcbiAgICAweDQ0MDQyZDczLCAweDMzMDMxZGU1LCAweGFhMGE0YzVmLCAweGRkMGQ3Y2M5LCAweDUwMDU3MTNjLCAweDI3MDI0MWFhLCAweGJlMGIxMDEwLCAweGM5MGMyMDg2LCAweDU3NjhiNTI1LFxuICAgIDB4MjA2Zjg1YjMsIDB4Yjk2NmQ0MDksIDB4Y2U2MWU0OWYsIDB4NWVkZWY5MGUsIDB4MjlkOWM5OTgsIDB4YjBkMDk4MjIsIDB4YzdkN2E4YjQsIDB4NTliMzNkMTcsIDB4MmViNDBkODEsXG4gICAgMHhiN2JkNWMzYiwgMHhjMGJhNmNhZCwgMHhlZGI4ODMyMCwgMHg5YWJmYjNiNiwgMHgwM2I2ZTIwYywgMHg3NGIxZDI5YSwgMHhlYWQ1NDczOSwgMHg5ZGQyNzdhZiwgMHgwNGRiMjYxNSxcbiAgICAweDczZGMxNjgzLCAweGUzNjMwYjEyLCAweDk0NjQzYjg0LCAweDBkNmQ2YTNlLCAweDdhNmE1YWE4LCAweGU0MGVjZjBiLCAweDkzMDlmZjlkLCAweDBhMDBhZTI3LCAweDdkMDc5ZWIxLFxuICAgIDB4ZjAwZjkzNDQsIDB4ODcwOGEzZDIsIDB4MWUwMWYyNjgsIDB4NjkwNmMyZmUsIDB4Zjc2MjU3NWQsIDB4ODA2NTY3Y2IsIDB4MTk2YzM2NzEsIDB4NmU2YjA2ZTcsIDB4ZmVkNDFiNzYsXG4gICAgMHg4OWQzMmJlMCwgMHgxMGRhN2E1YSwgMHg2N2RkNGFjYywgMHhmOWI5ZGY2ZiwgMHg4ZWJlZWZmOSwgMHgxN2I3YmU0MywgMHg2MGIwOGVkNSwgMHhkNmQ2YTNlOCwgMHhhMWQxOTM3ZSxcbiAgICAweDM4ZDhjMmM0LCAweDRmZGZmMjUyLCAweGQxYmI2N2YxLCAweGE2YmM1NzY3LCAweDNmYjUwNmRkLCAweDQ4YjIzNjRiLCAweGQ4MGQyYmRhLCAweGFmMGExYjRjLCAweDM2MDM0YWY2LFxuICAgIDB4NDEwNDdhNjAsIDB4ZGY2MGVmYzMsIDB4YTg2N2RmNTUsIDB4MzE2ZThlZWYsIDB4NDY2OWJlNzksIDB4Y2I2MWIzOGMsIDB4YmM2NjgzMWEsIDB4MjU2ZmQyYTAsIDB4NTI2OGUyMzYsXG4gICAgMHhjYzBjNzc5NSwgMHhiYjBiNDcwMywgMHgyMjAyMTZiOSwgMHg1NTA1MjYyZiwgMHhjNWJhM2JiZSwgMHhiMmJkMGIyOCwgMHgyYmI0NWE5MiwgMHg1Y2IzNmEwNCwgMHhjMmQ3ZmZhNyxcbiAgICAweGI1ZDBjZjMxLCAweDJjZDk5ZThiLCAweDViZGVhZTFkLCAweDliNjRjMmIwLCAweGVjNjNmMjI2LCAweDc1NmFhMzljLCAweDAyNmQ5MzBhLCAweDljMDkwNmE5LCAweGViMGUzNjNmLFxuICAgIDB4NzIwNzY3ODUsIDB4MDUwMDU3MTMsIDB4OTViZjRhODIsIDB4ZTJiODdhMTQsIDB4N2JiMTJiYWUsIDB4MGNiNjFiMzgsIDB4OTJkMjhlOWIsIDB4ZTVkNWJlMGQsIDB4N2NkY2VmYjcsXG4gICAgMHgwYmRiZGYyMSwgMHg4NmQzZDJkNCwgMHhmMWQ0ZTI0MiwgMHg2OGRkYjNmOCwgMHgxZmRhODM2ZSwgMHg4MWJlMTZjZCwgMHhmNmI5MjY1YiwgMHg2ZmIwNzdlMSwgMHgxOGI3NDc3NyxcbiAgICAweDg4MDg1YWU2LCAweGZmMGY2YTcwLCAweDY2MDYzYmNhLCAweDExMDEwYjVjLCAweDhmNjU5ZWZmLCAweGY4NjJhZTY5LCAweDYxNmJmZmQzLCAweDE2NmNjZjQ1LCAweGEwMGFlMjc4LFxuICAgIDB4ZDcwZGQyZWUsIDB4NGUwNDgzNTQsIDB4MzkwM2IzYzIsIDB4YTc2NzI2NjEsIDB4ZDA2MDE2ZjcsIDB4NDk2OTQ3NGQsIDB4M2U2ZTc3ZGIsIDB4YWVkMTZhNGEsIDB4ZDlkNjVhZGMsXG4gICAgMHg0MGRmMGI2NiwgMHgzN2Q4M2JmMCwgMHhhOWJjYWU1MywgMHhkZWJiOWVjNSwgMHg0N2IyY2Y3ZiwgMHgzMGI1ZmZlOSwgMHhiZGJkZjIxYywgMHhjYWJhYzI4YSwgMHg1M2IzOTMzMCxcbiAgICAweDI0YjRhM2E2LCAweGJhZDAzNjA1LCAweGNkZDcwNjkzLCAweDU0ZGU1NzI5LCAweDIzZDk2N2JmLCAweGIzNjY3YTJlLCAweGM0NjE0YWI4LCAweDVkNjgxYjAyLCAweDJhNmYyYjk0LFxuICAgIDB4YjQwYmJlMzcsIDB4YzMwYzhlYTEsIDB4NWEwNWRmMWIsIDB4MmQwMmVmOGQsXG5dO1xuZnVuY3Rpb24gaGFzaChyZXByKSB7XG4gICAgbGV0IGNyYyA9IDB4ZmZmZmZmZmY7XG4gICAgZm9yIChsZXQgaWR4ID0gMDsgaWR4IDwgcmVwci5sZW5ndGg7ICsraWR4KSB7XG4gICAgICAgIGNvbnN0IGMgPSByZXByLmNoYXJDb2RlQXQoaWR4KTtcbiAgICAgICAgaWYgKGMgPCAweDgwKSB7XG4gICAgICAgICAgICBjcmMgPSBjcmMzMlRhYmxlWyhjcmMgJiAweGZmKSBeIGNdIF4gKGNyYyA+PiA4KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjIDwgMHg4MDApIHtcbiAgICAgICAgICAgIGNyYyA9IGNyYzMyVGFibGVbKGNyYyAmIDB4ZmYpIF4gKDE5MiB8ICgoYyA+PiA2KSAmIDMxKSldIF4gKGNyYyA+PiA4KTtcbiAgICAgICAgICAgIGNyYyA9IGNyYzMyVGFibGVbKGNyYyAmIDB4ZmYpIF4gKDEyOCB8IChjICYgNjMpKV0gXiAoY3JjID4+IDgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGMgPj0gMHhkODAwICYmIGMgPCAweGUwMDApIHtcbiAgICAgICAgICAgIGNvbnN0IGNOZXh0ID0gcmVwci5jaGFyQ29kZUF0KCsraWR4KTtcbiAgICAgICAgICAgIGlmIChjID49IDB4ZGMwMCB8fCBjTmV4dCA8IDB4ZGMwMCB8fCBjTmV4dCA+IDB4ZGZmZiB8fCBOdW1iZXIuaXNOYU4oY05leHQpKSB7XG4gICAgICAgICAgICAgICAgaWR4IC09IDE7XG4gICAgICAgICAgICAgICAgY3JjID0gY3JjMzJUYWJsZVsoY3JjICYgMHhmZikgXiAweGVmXSBeIChjcmMgPj4gOCk7XG4gICAgICAgICAgICAgICAgY3JjID0gY3JjMzJUYWJsZVsoY3JjICYgMHhmZikgXiAweGJmXSBeIChjcmMgPj4gOCk7XG4gICAgICAgICAgICAgICAgY3JjID0gY3JjMzJUYWJsZVsoY3JjICYgMHhmZikgXiAweGJkXSBeIChjcmMgPj4gOCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjMSA9IChjICYgMTAyMykgKyA2NDtcbiAgICAgICAgICAgICAgICBjb25zdCBjMiA9IGNOZXh0ICYgMTAyMztcbiAgICAgICAgICAgICAgICBjcmMgPSBjcmMzMlRhYmxlWyhjcmMgJiAweGZmKSBeICgyNDAgfCAoKGMxID4+IDgpICYgNykpXSBeIChjcmMgPj4gOCk7XG4gICAgICAgICAgICAgICAgY3JjID0gY3JjMzJUYWJsZVsoY3JjICYgMHhmZikgXiAoMTI4IHwgKChjMSA+PiAyKSAmIDYzKSldIF4gKGNyYyA+PiA4KTtcbiAgICAgICAgICAgICAgICBjcmMgPSBjcmMzMlRhYmxlWyhjcmMgJiAweGZmKSBeICgxMjggfCAoKGMyID4+IDYpICYgMTUpIHwgKChjMSAmIDMpIDw8IDQpKV0gXiAoY3JjID4+IDgpO1xuICAgICAgICAgICAgICAgIGNyYyA9IGNyYzMyVGFibGVbKGNyYyAmIDB4ZmYpIF4gKDEyOCB8IChjMiAmIDYzKSldIF4gKGNyYyA+PiA4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNyYyA9IGNyYzMyVGFibGVbKGNyYyAmIDB4ZmYpIF4gKDIyNCB8ICgoYyA+PiAxMikgJiAxNSkpXSBeIChjcmMgPj4gOCk7XG4gICAgICAgICAgICBjcmMgPSBjcmMzMlRhYmxlWyhjcmMgJiAweGZmKSBeICgxMjggfCAoKGMgPj4gNikgJiA2MykpXSBeIChjcmMgPj4gOCk7XG4gICAgICAgICAgICBjcmMgPSBjcmMzMlRhYmxlWyhjcmMgJiAweGZmKSBeICgxMjggfCAoYyAmIDYzKSldIF4gKGNyYyA+PiA4KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gKGNyYyB8IDApICsgMHg4MDAwMDAwMDtcbn1cbmV4cG9ydHMuaGFzaCA9IGhhc2g7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuYXN5bmNTdHJpbmdpZnkgPSBleHBvcnRzLnBvc3NpYmx5QXN5bmNTdHJpbmdpZnkgPSBleHBvcnRzLnN0cmluZ2lmeSA9IGV4cG9ydHMuc3RyaW5naWZ5SW50ZXJuYWwgPSBleHBvcnRzLmhhc0FzeW5jVG9TdHJpbmdNZXRob2QgPSBleHBvcnRzLmFzeW5jVG9TdHJpbmdNZXRob2QgPSBleHBvcnRzLmhhc1RvU3RyaW5nTWV0aG9kID0gZXhwb3J0cy50b1N0cmluZ01ldGhvZCA9IHZvaWQgMDtcbmV4cG9ydHMudG9TdHJpbmdNZXRob2QgPSBTeW1ib2woJ2Zhc3QtY2hlY2svdG9TdHJpbmdNZXRob2QnKTtcbmZ1bmN0aW9uIGhhc1RvU3RyaW5nTWV0aG9kKGluc3RhbmNlKSB7XG4gICAgcmV0dXJuIChpbnN0YW5jZSAhPT0gbnVsbCAmJlxuICAgICAgICAodHlwZW9mIGluc3RhbmNlID09PSAnb2JqZWN0JyB8fCB0eXBlb2YgaW5zdGFuY2UgPT09ICdmdW5jdGlvbicpICYmXG4gICAgICAgIGV4cG9ydHMudG9TdHJpbmdNZXRob2QgaW4gaW5zdGFuY2UgJiZcbiAgICAgICAgdHlwZW9mIGluc3RhbmNlW2V4cG9ydHMudG9TdHJpbmdNZXRob2RdID09PSAnZnVuY3Rpb24nKTtcbn1cbmV4cG9ydHMuaGFzVG9TdHJpbmdNZXRob2QgPSBoYXNUb1N0cmluZ01ldGhvZDtcbmV4cG9ydHMuYXN5bmNUb1N0cmluZ01ldGhvZCA9IFN5bWJvbCgnZmFzdC1jaGVjay9hc3luY1RvU3RyaW5nTWV0aG9kJyk7XG5mdW5jdGlvbiBoYXNBc3luY1RvU3RyaW5nTWV0aG9kKGluc3RhbmNlKSB7XG4gICAgcmV0dXJuIChpbnN0YW5jZSAhPT0gbnVsbCAmJlxuICAgICAgICAodHlwZW9mIGluc3RhbmNlID09PSAnb2JqZWN0JyB8fCB0eXBlb2YgaW5zdGFuY2UgPT09ICdmdW5jdGlvbicpICYmXG4gICAgICAgIGV4cG9ydHMuYXN5bmNUb1N0cmluZ01ldGhvZCBpbiBpbnN0YW5jZSAmJlxuICAgICAgICB0eXBlb2YgaW5zdGFuY2VbZXhwb3J0cy5hc3luY1RvU3RyaW5nTWV0aG9kXSA9PT0gJ2Z1bmN0aW9uJyk7XG59XG5leHBvcnRzLmhhc0FzeW5jVG9TdHJpbmdNZXRob2QgPSBoYXNBc3luY1RvU3RyaW5nTWV0aG9kO1xuY29uc3QgZmluZFN5bWJvbE5hbWVSZWdleCA9IC9eU3ltYm9sXFwoKC4qKVxcKSQvO1xuZnVuY3Rpb24gZ2V0U3ltYm9sRGVzY3JpcHRpb24ocykge1xuICAgIGlmIChzLmRlc2NyaXB0aW9uICE9PSB1bmRlZmluZWQpXG4gICAgICAgIHJldHVybiBzLmRlc2NyaXB0aW9uO1xuICAgIGNvbnN0IG0gPSBmaW5kU3ltYm9sTmFtZVJlZ2V4LmV4ZWMoU3RyaW5nKHMpKTtcbiAgICByZXR1cm4gbSAmJiBtWzFdLmxlbmd0aCA/IG1bMV0gOiBudWxsO1xufVxuZnVuY3Rpb24gc3RyaW5naWZ5TnVtYmVyKG51bVZhbHVlKSB7XG4gICAgc3dpdGNoIChudW1WYWx1ZSkge1xuICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICByZXR1cm4gMSAvIG51bVZhbHVlID09PSBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFkgPyAnLTAnIDogJzAnO1xuICAgICAgICBjYXNlIE51bWJlci5ORUdBVElWRV9JTkZJTklUWTpcbiAgICAgICAgICAgIHJldHVybiAnTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZJztcbiAgICAgICAgY2FzZSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk6XG4gICAgICAgICAgICByZXR1cm4gJ051bWJlci5QT1NJVElWRV9JTkZJTklUWSc7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gbnVtVmFsdWUgPT09IG51bVZhbHVlID8gU3RyaW5nKG51bVZhbHVlKSA6ICdOdW1iZXIuTmFOJztcbiAgICB9XG59XG5mdW5jdGlvbiBpc1NwYXJzZUFycmF5KGFycikge1xuICAgIGxldCBwcmV2aW91c051bWJlcmVkSW5kZXggPSAtMTtcbiAgICBmb3IgKGNvbnN0IGluZGV4IGluIGFycikge1xuICAgICAgICBjb25zdCBudW1iZXJlZEluZGV4ID0gTnVtYmVyKGluZGV4KTtcbiAgICAgICAgaWYgKG51bWJlcmVkSW5kZXggIT09IHByZXZpb3VzTnVtYmVyZWRJbmRleCArIDEpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgcHJldmlvdXNOdW1iZXJlZEluZGV4ID0gbnVtYmVyZWRJbmRleDtcbiAgICB9XG4gICAgcmV0dXJuIHByZXZpb3VzTnVtYmVyZWRJbmRleCArIDEgIT09IGFyci5sZW5ndGg7XG59XG5mdW5jdGlvbiBzdHJpbmdpZnlJbnRlcm5hbCh2YWx1ZSwgcHJldmlvdXNWYWx1ZXMsIGdldEFzeW5jQ29udGVudCkge1xuICAgIGNvbnN0IGN1cnJlbnRWYWx1ZXMgPSBwcmV2aW91c1ZhbHVlcy5jb25jYXQoW3ZhbHVlXSk7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgaWYgKHByZXZpb3VzVmFsdWVzLmluZGV4T2YodmFsdWUpICE9PSAtMSkge1xuICAgICAgICAgICAgcmV0dXJuICdbY3ljbGljXSc7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGhhc0FzeW5jVG9TdHJpbmdNZXRob2QodmFsdWUpKSB7XG4gICAgICAgIGNvbnN0IGNvbnRlbnQgPSBnZXRBc3luY0NvbnRlbnQodmFsdWUpO1xuICAgICAgICBpZiAoY29udGVudC5zdGF0ZSA9PT0gJ2Z1bGZpbGxlZCcpIHtcbiAgICAgICAgICAgIHJldHVybiBjb250ZW50LnZhbHVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChoYXNUb1N0cmluZ01ldGhvZCh2YWx1ZSkpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZVtleHBvcnRzLnRvU3RyaW5nTWV0aG9kXSgpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzd2l0Y2ggKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSkpIHtcbiAgICAgICAgY2FzZSAnW29iamVjdCBBcnJheV0nOiB7XG4gICAgICAgICAgICBjb25zdCBhcnIgPSB2YWx1ZTtcbiAgICAgICAgICAgIGlmIChhcnIubGVuZ3RoID49IDUwICYmIGlzU3BhcnNlQXJyYXkoYXJyKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGFzc2lnbm1lbnRzID0gW107XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBpbmRleCBpbiBhcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFOdW1iZXIuaXNOYU4oTnVtYmVyKGluZGV4KSkpXG4gICAgICAgICAgICAgICAgICAgICAgICBhc3NpZ25tZW50cy5wdXNoKGAke2luZGV4fToke3N0cmluZ2lmeUludGVybmFsKGFycltpbmRleF0sIGN1cnJlbnRWYWx1ZXMsIGdldEFzeW5jQ29udGVudCl9YCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBhc3NpZ25tZW50cy5sZW5ndGggIT09IDBcbiAgICAgICAgICAgICAgICAgICAgPyBgT2JqZWN0LmFzc2lnbihBcnJheSgke2Fyci5sZW5ndGh9KSx7JHthc3NpZ25tZW50cy5qb2luKCcsJyl9fSlgXG4gICAgICAgICAgICAgICAgICAgIDogYEFycmF5KCR7YXJyLmxlbmd0aH0pYDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHN0cmluZ2lmaWVkQXJyYXkgPSBhcnIubWFwKCh2KSA9PiBzdHJpbmdpZnlJbnRlcm5hbCh2LCBjdXJyZW50VmFsdWVzLCBnZXRBc3luY0NvbnRlbnQpKS5qb2luKCcsJyk7XG4gICAgICAgICAgICByZXR1cm4gYXJyLmxlbmd0aCA9PT0gMCB8fCBhcnIubGVuZ3RoIC0gMSBpbiBhcnIgPyBgWyR7c3RyaW5naWZpZWRBcnJheX1dYCA6IGBbJHtzdHJpbmdpZmllZEFycmF5fSxdYDtcbiAgICAgICAgfVxuICAgICAgICBjYXNlICdbb2JqZWN0IEJpZ0ludF0nOlxuICAgICAgICAgICAgcmV0dXJuIGAke3ZhbHVlfW5gO1xuICAgICAgICBjYXNlICdbb2JqZWN0IEJvb2xlYW5dJzpcbiAgICAgICAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJyA/IEpTT04uc3RyaW5naWZ5KHZhbHVlKSA6IGBuZXcgQm9vbGVhbigke0pTT04uc3RyaW5naWZ5KHZhbHVlKX0pYDtcbiAgICAgICAgY2FzZSAnW29iamVjdCBEYXRlXSc6IHtcbiAgICAgICAgICAgIGNvbnN0IGQgPSB2YWx1ZTtcbiAgICAgICAgICAgIHJldHVybiBOdW1iZXIuaXNOYU4oZC5nZXRUaW1lKCkpID8gYG5ldyBEYXRlKE5hTilgIDogYG5ldyBEYXRlKCR7SlNPTi5zdHJpbmdpZnkoZC50b0lTT1N0cmluZygpKX0pYDtcbiAgICAgICAgfVxuICAgICAgICBjYXNlICdbb2JqZWN0IE1hcF0nOlxuICAgICAgICAgICAgcmV0dXJuIGBuZXcgTWFwKCR7c3RyaW5naWZ5SW50ZXJuYWwoQXJyYXkuZnJvbSh2YWx1ZSksIGN1cnJlbnRWYWx1ZXMsIGdldEFzeW5jQ29udGVudCl9KWA7XG4gICAgICAgIGNhc2UgJ1tvYmplY3QgTnVsbF0nOlxuICAgICAgICAgICAgcmV0dXJuIGBudWxsYDtcbiAgICAgICAgY2FzZSAnW29iamVjdCBOdW1iZXJdJzpcbiAgICAgICAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInID8gc3RyaW5naWZ5TnVtYmVyKHZhbHVlKSA6IGBuZXcgTnVtYmVyKCR7c3RyaW5naWZ5TnVtYmVyKE51bWJlcih2YWx1ZSkpfSlgO1xuICAgICAgICBjYXNlICdbb2JqZWN0IE9iamVjdF0nOiB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHRvU3RyaW5nQWNjZXNzb3IgPSB2YWx1ZS50b1N0cmluZztcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHRvU3RyaW5nQWNjZXNzb3IgPT09ICdmdW5jdGlvbicgJiYgdG9TdHJpbmdBY2Nlc3NvciAhPT0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWUudG9TdHJpbmcoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICdbb2JqZWN0IE9iamVjdF0nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbWFwcGVyID0gKGspID0+IGAke2sgPT09ICdfX3Byb3RvX18nXG4gICAgICAgICAgICAgICAgPyAnW1wiX19wcm90b19fXCJdJ1xuICAgICAgICAgICAgICAgIDogdHlwZW9mIGsgPT09ICdzeW1ib2wnXG4gICAgICAgICAgICAgICAgICAgID8gYFske3N0cmluZ2lmeUludGVybmFsKGssIGN1cnJlbnRWYWx1ZXMsIGdldEFzeW5jQ29udGVudCl9XWBcbiAgICAgICAgICAgICAgICAgICAgOiBKU09OLnN0cmluZ2lmeShrKX06JHtzdHJpbmdpZnlJbnRlcm5hbCh2YWx1ZVtrXSwgY3VycmVudFZhbHVlcywgZ2V0QXN5bmNDb250ZW50KX1gO1xuICAgICAgICAgICAgY29uc3Qgc3RyaW5naWZpZWRQcm9wZXJ0aWVzID0gW1xuICAgICAgICAgICAgICAgIC4uLk9iamVjdC5rZXlzKHZhbHVlKS5tYXAobWFwcGVyKSxcbiAgICAgICAgICAgICAgICAuLi5PYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHZhbHVlKVxuICAgICAgICAgICAgICAgICAgICAuZmlsdGVyKChzKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGRlc2NyaXB0b3IgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHZhbHVlLCBzKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRlc2NyaXB0b3IgJiYgZGVzY3JpcHRvci5lbnVtZXJhYmxlO1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgIC5tYXAobWFwcGVyKSxcbiAgICAgICAgICAgIF07XG4gICAgICAgICAgICBjb25zdCByYXdSZXByID0gJ3snICsgc3RyaW5naWZpZWRQcm9wZXJ0aWVzLmpvaW4oJywnKSArICd9JztcbiAgICAgICAgICAgIGlmIChPYmplY3QuZ2V0UHJvdG90eXBlT2YodmFsdWUpID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJhd1JlcHIgPT09ICd7fScgPyAnT2JqZWN0LmNyZWF0ZShudWxsKScgOiBgT2JqZWN0LmFzc2lnbihPYmplY3QuY3JlYXRlKG51bGwpLCR7cmF3UmVwcn0pYDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByYXdSZXByO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgJ1tvYmplY3QgU2V0XSc6XG4gICAgICAgICAgICByZXR1cm4gYG5ldyBTZXQoJHtzdHJpbmdpZnlJbnRlcm5hbChBcnJheS5mcm9tKHZhbHVlKSwgY3VycmVudFZhbHVlcywgZ2V0QXN5bmNDb250ZW50KX0pYDtcbiAgICAgICAgY2FzZSAnW29iamVjdCBTdHJpbmddJzpcbiAgICAgICAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnID8gSlNPTi5zdHJpbmdpZnkodmFsdWUpIDogYG5ldyBTdHJpbmcoJHtKU09OLnN0cmluZ2lmeSh2YWx1ZSl9KWA7XG4gICAgICAgIGNhc2UgJ1tvYmplY3QgU3ltYm9sXSc6IHtcbiAgICAgICAgICAgIGNvbnN0IHMgPSB2YWx1ZTtcbiAgICAgICAgICAgIGlmIChTeW1ib2wua2V5Rm9yKHMpICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYFN5bWJvbC5mb3IoJHtKU09OLnN0cmluZ2lmeShTeW1ib2wua2V5Rm9yKHMpKX0pYDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGRlc2MgPSBnZXRTeW1ib2xEZXNjcmlwdGlvbihzKTtcbiAgICAgICAgICAgIGlmIChkZXNjID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICdTeW1ib2woKSc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBrbm93blN5bWJvbCA9IGRlc2Muc3RhcnRzV2l0aCgnU3ltYm9sLicpICYmIFN5bWJvbFtkZXNjLnN1YnN0cmluZyg3KV07XG4gICAgICAgICAgICByZXR1cm4gcyA9PT0ga25vd25TeW1ib2wgPyBkZXNjIDogYFN5bWJvbCgke0pTT04uc3RyaW5naWZ5KGRlc2MpfSlgO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgJ1tvYmplY3QgUHJvbWlzZV0nOiB7XG4gICAgICAgICAgICBjb25zdCBwcm9taXNlQ29udGVudCA9IGdldEFzeW5jQ29udGVudCh2YWx1ZSk7XG4gICAgICAgICAgICBzd2l0Y2ggKHByb21pc2VDb250ZW50LnN0YXRlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnZnVsZmlsbGVkJzpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGBQcm9taXNlLnJlc29sdmUoJHtzdHJpbmdpZnlJbnRlcm5hbChwcm9taXNlQ29udGVudC52YWx1ZSwgY3VycmVudFZhbHVlcywgZ2V0QXN5bmNDb250ZW50KX0pYDtcbiAgICAgICAgICAgICAgICBjYXNlICdyZWplY3RlZCc6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBgUHJvbWlzZS5yZWplY3QoJHtzdHJpbmdpZnlJbnRlcm5hbChwcm9taXNlQ29udGVudC52YWx1ZSwgY3VycmVudFZhbHVlcywgZ2V0QXN5bmNDb250ZW50KX0pYDtcbiAgICAgICAgICAgICAgICBjYXNlICdwZW5kaW5nJzpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGBuZXcgUHJvbWlzZSgoKSA9PiB7LypwZW5kaW5nKi99KWA7XG4gICAgICAgICAgICAgICAgY2FzZSAndW5rbm93bic6XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGBuZXcgUHJvbWlzZSgoKSA9PiB7Lyp1bmtub3duKi99KWA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAnW29iamVjdCBFcnJvcl0nOlxuICAgICAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYG5ldyBFcnJvcigke3N0cmluZ2lmeUludGVybmFsKHZhbHVlLm1lc3NhZ2UsIGN1cnJlbnRWYWx1ZXMsIGdldEFzeW5jQ29udGVudCl9KWA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnW29iamVjdCBVbmRlZmluZWRdJzpcbiAgICAgICAgICAgIHJldHVybiBgdW5kZWZpbmVkYDtcbiAgICAgICAgY2FzZSAnW29iamVjdCBJbnQ4QXJyYXldJzpcbiAgICAgICAgY2FzZSAnW29iamVjdCBVaW50OEFycmF5XSc6XG4gICAgICAgIGNhc2UgJ1tvYmplY3QgVWludDhDbGFtcGVkQXJyYXldJzpcbiAgICAgICAgY2FzZSAnW29iamVjdCBJbnQxNkFycmF5XSc6XG4gICAgICAgIGNhc2UgJ1tvYmplY3QgVWludDE2QXJyYXldJzpcbiAgICAgICAgY2FzZSAnW29iamVjdCBJbnQzMkFycmF5XSc6XG4gICAgICAgIGNhc2UgJ1tvYmplY3QgVWludDMyQXJyYXldJzpcbiAgICAgICAgY2FzZSAnW29iamVjdCBGbG9hdDMyQXJyYXldJzpcbiAgICAgICAgY2FzZSAnW29iamVjdCBGbG9hdDY0QXJyYXldJzpcbiAgICAgICAgY2FzZSAnW29iamVjdCBCaWdJbnQ2NEFycmF5XSc6XG4gICAgICAgIGNhc2UgJ1tvYmplY3QgQmlnVWludDY0QXJyYXldJzoge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBCdWZmZXIgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBCdWZmZXIuaXNCdWZmZXIgPT09ICdmdW5jdGlvbicgJiYgQnVmZmVyLmlzQnVmZmVyKHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBgQnVmZmVyLmZyb20oJHtzdHJpbmdpZnlJbnRlcm5hbChBcnJheS5mcm9tKHZhbHVlLnZhbHVlcygpKSwgY3VycmVudFZhbHVlcywgZ2V0QXN5bmNDb250ZW50KX0pYDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHZhbHVlUHJvdG90eXBlID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHZhbHVlKTtcbiAgICAgICAgICAgIGNvbnN0IGNsYXNzTmFtZSA9IHZhbHVlUHJvdG90eXBlICYmIHZhbHVlUHJvdG90eXBlLmNvbnN0cnVjdG9yICYmIHZhbHVlUHJvdG90eXBlLmNvbnN0cnVjdG9yLm5hbWU7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGNsYXNzTmFtZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB0eXBlZEFycmF5ID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgY29uc3QgdmFsdWVzRnJvbVR5cGVkQXJyID0gdHlwZWRBcnJheS52YWx1ZXMoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gYCR7Y2xhc3NOYW1lfS5mcm9tKCR7c3RyaW5naWZ5SW50ZXJuYWwoQXJyYXkuZnJvbSh2YWx1ZXNGcm9tVHlwZWRBcnIpLCBjdXJyZW50VmFsdWVzLCBnZXRBc3luY0NvbnRlbnQpfSlgO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIHZhbHVlLnRvU3RyaW5nKCk7XG4gICAgfVxuICAgIGNhdGNoIChfYSkge1xuICAgICAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKTtcbiAgICB9XG59XG5leHBvcnRzLnN0cmluZ2lmeUludGVybmFsID0gc3RyaW5naWZ5SW50ZXJuYWw7XG5mdW5jdGlvbiBzdHJpbmdpZnkodmFsdWUpIHtcbiAgICByZXR1cm4gc3RyaW5naWZ5SW50ZXJuYWwodmFsdWUsIFtdLCAoKSA9PiAoeyBzdGF0ZTogJ3Vua25vd24nLCB2YWx1ZTogdW5kZWZpbmVkIH0pKTtcbn1cbmV4cG9ydHMuc3RyaW5naWZ5ID0gc3RyaW5naWZ5O1xuZnVuY3Rpb24gcG9zc2libHlBc3luY1N0cmluZ2lmeSh2YWx1ZSkge1xuICAgIGNvbnN0IHN0aWxsUGVuZGluZ01hcmtlciA9IFN5bWJvbCgpO1xuICAgIGNvbnN0IHBlbmRpbmdQcm9taXNlc0ZvckNhY2hlID0gW107XG4gICAgY29uc3QgY2FjaGUgPSBuZXcgTWFwKCk7XG4gICAgZnVuY3Rpb24gY3JlYXRlRGVsYXkwKCkge1xuICAgICAgICBsZXQgaGFuZGxlSWQgPSBudWxsO1xuICAgICAgICBjb25zdCBjYW5jZWwgPSAoKSA9PiB7XG4gICAgICAgICAgICBpZiAoaGFuZGxlSWQgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQoaGFuZGxlSWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBkZWxheSA9IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICAgICAgICBoYW5kbGVJZCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgIGhhbmRsZUlkID0gbnVsbDtcbiAgICAgICAgICAgICAgICByZXNvbHZlKHN0aWxsUGVuZGluZ01hcmtlcik7XG4gICAgICAgICAgICB9LCAwKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB7IGRlbGF5LCBjYW5jZWwgfTtcbiAgICB9XG4gICAgY29uc3QgdW5rbm93blN0YXRlID0geyBzdGF0ZTogJ3Vua25vd24nLCB2YWx1ZTogdW5kZWZpbmVkIH07XG4gICAgY29uc3QgZ2V0QXN5bmNDb250ZW50ID0gZnVuY3Rpb24gZ2V0QXN5bmNDb250ZW50KGRhdGEpIHtcbiAgICAgICAgY29uc3QgY2FjaGVLZXkgPSBkYXRhO1xuICAgICAgICBpZiAoY2FjaGUuaGFzKGNhY2hlS2V5KSkge1xuICAgICAgICAgICAgcmV0dXJuIGNhY2hlLmdldChjYWNoZUtleSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZGVsYXkwID0gY3JlYXRlRGVsYXkwKCk7XG4gICAgICAgIGNvbnN0IHAgPSBleHBvcnRzLmFzeW5jVG9TdHJpbmdNZXRob2QgaW4gZGF0YVxuICAgICAgICAgICAgPyBQcm9taXNlLnJlc29sdmUoKS50aGVuKCgpID0+IGRhdGFbZXhwb3J0cy5hc3luY1RvU3RyaW5nTWV0aG9kXSgpKVxuICAgICAgICAgICAgOiBkYXRhO1xuICAgICAgICBwLmNhdGNoKCgpID0+IHsgfSk7XG4gICAgICAgIHBlbmRpbmdQcm9taXNlc0ZvckNhY2hlLnB1c2goUHJvbWlzZS5yYWNlKFtwLCBkZWxheTAuZGVsYXldKS50aGVuKChzdWNjZXNzVmFsdWUpID0+IHtcbiAgICAgICAgICAgIGlmIChzdWNjZXNzVmFsdWUgPT09IHN0aWxsUGVuZGluZ01hcmtlcilcbiAgICAgICAgICAgICAgICBjYWNoZS5zZXQoY2FjaGVLZXksIHsgc3RhdGU6ICdwZW5kaW5nJywgdmFsdWU6IHVuZGVmaW5lZCB9KTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBjYWNoZS5zZXQoY2FjaGVLZXksIHsgc3RhdGU6ICdmdWxmaWxsZWQnLCB2YWx1ZTogc3VjY2Vzc1ZhbHVlIH0pO1xuICAgICAgICAgICAgZGVsYXkwLmNhbmNlbCgpO1xuICAgICAgICB9LCAoZXJyb3JWYWx1ZSkgPT4ge1xuICAgICAgICAgICAgY2FjaGUuc2V0KGNhY2hlS2V5LCB7IHN0YXRlOiAncmVqZWN0ZWQnLCB2YWx1ZTogZXJyb3JWYWx1ZSB9KTtcbiAgICAgICAgICAgIGRlbGF5MC5jYW5jZWwoKTtcbiAgICAgICAgfSkpO1xuICAgICAgICBjYWNoZS5zZXQoY2FjaGVLZXksIHVua25vd25TdGF0ZSk7XG4gICAgICAgIHJldHVybiB1bmtub3duU3RhdGU7XG4gICAgfTtcbiAgICBmdW5jdGlvbiBsb29wKCkge1xuICAgICAgICBjb25zdCBzdHJpbmdpZmllZFZhbHVlID0gc3RyaW5naWZ5SW50ZXJuYWwodmFsdWUsIFtdLCBnZXRBc3luY0NvbnRlbnQpO1xuICAgICAgICBpZiAocGVuZGluZ1Byb21pc2VzRm9yQ2FjaGUubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gc3RyaW5naWZpZWRWYWx1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwocGVuZGluZ1Byb21pc2VzRm9yQ2FjaGUuc3BsaWNlKDApKS50aGVuKGxvb3ApO1xuICAgIH1cbiAgICByZXR1cm4gbG9vcCgpO1xufVxuZXhwb3J0cy5wb3NzaWJseUFzeW5jU3RyaW5naWZ5ID0gcG9zc2libHlBc3luY1N0cmluZ2lmeTtcbmFzeW5jIGZ1bmN0aW9uIGFzeW5jU3RyaW5naWZ5KHZhbHVlKSB7XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShwb3NzaWJseUFzeW5jU3RyaW5naWZ5KHZhbHVlKSk7XG59XG5leHBvcnRzLmFzeW5jU3RyaW5naWZ5ID0gYXN5bmNTdHJpbmdpZnk7XG4iLCJcInVzZSBzdHJpY3RcIjtcbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5leHBvcnRzLnVuaWZvcm1BcnJheUludERpc3RyaWJ1dGlvbiA9IHZvaWQgMDtcbnZhciBVbnNhZmVVbmlmb3JtQXJyYXlJbnREaXN0cmlidXRpb25fMSA9IHJlcXVpcmUoXCIuL1Vuc2FmZVVuaWZvcm1BcnJheUludERpc3RyaWJ1dGlvblwiKTtcbmZ1bmN0aW9uIHVuaWZvcm1BcnJheUludERpc3RyaWJ1dGlvbihmcm9tLCB0bywgcm5nKSB7XG4gICAgaWYgKHJuZyAhPSBudWxsKSB7XG4gICAgICAgIHZhciBuZXh0Um5nID0gcm5nLmNsb25lKCk7XG4gICAgICAgIHJldHVybiBbVW5zYWZlVW5pZm9ybUFycmF5SW50RGlzdHJpYnV0aW9uXzEudW5zYWZlVW5pZm9ybUFycmF5SW50RGlzdHJpYnV0aW9uKGZyb20sIHRvLCBuZXh0Um5nKSwgbmV4dFJuZ107XG4gICAgfVxuICAgIHJldHVybiBmdW5jdGlvbiAocm5nKSB7XG4gICAgICAgIHZhciBuZXh0Um5nID0gcm5nLmNsb25lKCk7XG4gICAgICAgIHJldHVybiBbVW5zYWZlVW5pZm9ybUFycmF5SW50RGlzdHJpYnV0aW9uXzEudW5zYWZlVW5pZm9ybUFycmF5SW50RGlzdHJpYnV0aW9uKGZyb20sIHRvLCBuZXh0Um5nKSwgbmV4dFJuZ107XG4gICAgfTtcbn1cbmV4cG9ydHMudW5pZm9ybUFycmF5SW50RGlzdHJpYnV0aW9uID0gdW5pZm9ybUFycmF5SW50RGlzdHJpYnV0aW9uO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuZXhwb3J0cy51bmlmb3JtQmlnSW50RGlzdHJpYnV0aW9uID0gdm9pZCAwO1xudmFyIFVuc2FmZVVuaWZvcm1CaWdJbnREaXN0cmlidXRpb25fMSA9IHJlcXVpcmUoXCIuL1Vuc2FmZVVuaWZvcm1CaWdJbnREaXN0cmlidXRpb25cIik7XG5mdW5jdGlvbiB1bmlmb3JtQmlnSW50RGlzdHJpYnV0aW9uKGZyb20sIHRvLCBybmcpIHtcbiAgICBpZiAocm5nICE9IG51bGwpIHtcbiAgICAgICAgdmFyIG5leHRSbmcgPSBybmcuY2xvbmUoKTtcbiAgICAgICAgcmV0dXJuIFtVbnNhZmVVbmlmb3JtQmlnSW50RGlzdHJpYnV0aW9uXzEudW5zYWZlVW5pZm9ybUJpZ0ludERpc3RyaWJ1dGlvbihmcm9tLCB0bywgbmV4dFJuZyksIG5leHRSbmddO1xuICAgIH1cbiAgICByZXR1cm4gZnVuY3Rpb24gKHJuZykge1xuICAgICAgICB2YXIgbmV4dFJuZyA9IHJuZy5jbG9uZSgpO1xuICAgICAgICByZXR1cm4gW1Vuc2FmZVVuaWZvcm1CaWdJbnREaXN0cmlidXRpb25fMS51bnNhZmVVbmlmb3JtQmlnSW50RGlzdHJpYnV0aW9uKGZyb20sIHRvLCBuZXh0Um5nKSwgbmV4dFJuZ107XG4gICAgfTtcbn1cbmV4cG9ydHMudW5pZm9ybUJpZ0ludERpc3RyaWJ1dGlvbiA9IHVuaWZvcm1CaWdJbnREaXN0cmlidXRpb247XG4iLCJcInVzZSBzdHJpY3RcIjtcbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5leHBvcnRzLnVuaWZvcm1JbnREaXN0cmlidXRpb24gPSB2b2lkIDA7XG52YXIgVW5zYWZlVW5pZm9ybUludERpc3RyaWJ1dGlvbl8xID0gcmVxdWlyZShcIi4vVW5zYWZlVW5pZm9ybUludERpc3RyaWJ1dGlvblwiKTtcbmZ1bmN0aW9uIHVuaWZvcm1JbnREaXN0cmlidXRpb24oZnJvbSwgdG8sIHJuZykge1xuICAgIGlmIChybmcgIT0gbnVsbCkge1xuICAgICAgICB2YXIgbmV4dFJuZyA9IHJuZy5jbG9uZSgpO1xuICAgICAgICByZXR1cm4gW1Vuc2FmZVVuaWZvcm1JbnREaXN0cmlidXRpb25fMS51bnNhZmVVbmlmb3JtSW50RGlzdHJpYnV0aW9uKGZyb20sIHRvLCBuZXh0Um5nKSwgbmV4dFJuZ107XG4gICAgfVxuICAgIHJldHVybiBmdW5jdGlvbiAocm5nKSB7XG4gICAgICAgIHZhciBuZXh0Um5nID0gcm5nLmNsb25lKCk7XG4gICAgICAgIHJldHVybiBbVW5zYWZlVW5pZm9ybUludERpc3RyaWJ1dGlvbl8xLnVuc2FmZVVuaWZvcm1JbnREaXN0cmlidXRpb24oZnJvbSwgdG8sIG5leHRSbmcpLCBuZXh0Um5nXTtcbiAgICB9O1xufVxuZXhwb3J0cy51bmlmb3JtSW50RGlzdHJpYnV0aW9uID0gdW5pZm9ybUludERpc3RyaWJ1dGlvbjtcbiIsIlwidXNlIHN0cmljdFwiO1xuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbmV4cG9ydHMudW5zYWZlVW5pZm9ybUFycmF5SW50RGlzdHJpYnV0aW9uID0gdm9pZCAwO1xudmFyIEFycmF5SW50XzEgPSByZXF1aXJlKFwiLi9pbnRlcm5hbHMvQXJyYXlJbnRcIik7XG52YXIgVW5zYWZlVW5pZm9ybUFycmF5SW50RGlzdHJpYnV0aW9uSW50ZXJuYWxfMSA9IHJlcXVpcmUoXCIuL2ludGVybmFscy9VbnNhZmVVbmlmb3JtQXJyYXlJbnREaXN0cmlidXRpb25JbnRlcm5hbFwiKTtcbmZ1bmN0aW9uIHVuc2FmZVVuaWZvcm1BcnJheUludERpc3RyaWJ1dGlvbihmcm9tLCB0bywgcm5nKSB7XG4gICAgdmFyIHJhbmdlU2l6ZSA9IEFycmF5SW50XzEudHJpbUFycmF5SW50SW5wbGFjZShBcnJheUludF8xLmFkZE9uZVRvUG9zaXRpdmVBcnJheUludChBcnJheUludF8xLnN1YnN0cmFjdEFycmF5SW50VG9OZXcodG8sIGZyb20pKSk7XG4gICAgdmFyIGVtcHR5QXJyYXlJbnREYXRhID0gcmFuZ2VTaXplLmRhdGEuc2xpY2UoMCk7XG4gICAgdmFyIGcgPSBVbnNhZmVVbmlmb3JtQXJyYXlJbnREaXN0cmlidXRpb25JbnRlcm5hbF8xLnVuc2FmZVVuaWZvcm1BcnJheUludERpc3RyaWJ1dGlvbkludGVybmFsKGVtcHR5QXJyYXlJbnREYXRhLCByYW5nZVNpemUuZGF0YSwgcm5nKTtcbiAgICByZXR1cm4gQXJyYXlJbnRfMS50cmltQXJyYXlJbnRJbnBsYWNlKEFycmF5SW50XzEuYWRkQXJyYXlJbnRUb05ldyh7IHNpZ246IDEsIGRhdGE6IGcgfSwgZnJvbSkpO1xufVxuZXhwb3J0cy51bnNhZmVVbmlmb3JtQXJyYXlJbnREaXN0cmlidXRpb24gPSB1bnNhZmVVbmlmb3JtQXJyYXlJbnREaXN0cmlidXRpb247XG4iLCJcInVzZSBzdHJpY3RcIjtcbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5leHBvcnRzLnVuc2FmZVVuaWZvcm1CaWdJbnREaXN0cmlidXRpb24gPSB2b2lkIDA7XG5mdW5jdGlvbiB1bnNhZmVVbmlmb3JtQmlnSW50RGlzdHJpYnV0aW9uKGZyb20sIHRvLCBybmcpIHtcbiAgICB2YXIgZGlmZiA9IHRvIC0gZnJvbSArIEJpZ0ludCgxKTtcbiAgICB2YXIgTWluUm5nID0gQmlnSW50KHJuZy5taW4oKSk7XG4gICAgdmFyIE51bVZhbHVlcyA9IEJpZ0ludChybmcubWF4KCkgLSBybmcubWluKCkgKyAxKTtcbiAgICB2YXIgRmluYWxOdW1WYWx1ZXMgPSBOdW1WYWx1ZXM7XG4gICAgdmFyIE51bUl0ZXJhdGlvbnMgPSBCaWdJbnQoMSk7XG4gICAgd2hpbGUgKEZpbmFsTnVtVmFsdWVzIDwgZGlmZikge1xuICAgICAgICBGaW5hbE51bVZhbHVlcyAqPSBOdW1WYWx1ZXM7XG4gICAgICAgICsrTnVtSXRlcmF0aW9ucztcbiAgICB9XG4gICAgdmFyIE1heEFjY2VwdGVkUmFuZG9tID0gRmluYWxOdW1WYWx1ZXMgLSAoRmluYWxOdW1WYWx1ZXMgJSBkaWZmKTtcbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICB2YXIgdmFsdWUgPSBCaWdJbnQoMCk7XG4gICAgICAgIGZvciAodmFyIG51bSA9IEJpZ0ludCgwKTsgbnVtICE9PSBOdW1JdGVyYXRpb25zOyArK251bSkge1xuICAgICAgICAgICAgdmFyIG91dCA9IHJuZy51bnNhZmVOZXh0KCk7XG4gICAgICAgICAgICB2YWx1ZSA9IE51bVZhbHVlcyAqIHZhbHVlICsgKEJpZ0ludChvdXQpIC0gTWluUm5nKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodmFsdWUgPCBNYXhBY2NlcHRlZFJhbmRvbSkge1xuICAgICAgICAgICAgdmFyIGluRGlmZiA9IHZhbHVlICUgZGlmZjtcbiAgICAgICAgICAgIHJldHVybiBpbkRpZmYgKyBmcm9tO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy51bnNhZmVVbmlmb3JtQmlnSW50RGlzdHJpYnV0aW9uID0gdW5zYWZlVW5pZm9ybUJpZ0ludERpc3RyaWJ1dGlvbjtcbiIsIlwidXNlIHN0cmljdFwiO1xuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbmV4cG9ydHMudW5zYWZlVW5pZm9ybUludERpc3RyaWJ1dGlvbiA9IHZvaWQgMDtcbnZhciBVbnNhZmVVbmlmb3JtSW50RGlzdHJpYnV0aW9uSW50ZXJuYWxfMSA9IHJlcXVpcmUoXCIuL2ludGVybmFscy9VbnNhZmVVbmlmb3JtSW50RGlzdHJpYnV0aW9uSW50ZXJuYWxcIik7XG52YXIgQXJyYXlJbnRfMSA9IHJlcXVpcmUoXCIuL2ludGVybmFscy9BcnJheUludFwiKTtcbnZhciBVbnNhZmVVbmlmb3JtQXJyYXlJbnREaXN0cmlidXRpb25JbnRlcm5hbF8xID0gcmVxdWlyZShcIi4vaW50ZXJuYWxzL1Vuc2FmZVVuaWZvcm1BcnJheUludERpc3RyaWJ1dGlvbkludGVybmFsXCIpO1xudmFyIHNoYXJlZEEgPSB7IHNpZ246IDEsIGRhdGE6IFswLCAwXSB9O1xudmFyIHNoYXJlZEIgPSB7IHNpZ246IDEsIGRhdGE6IFswLCAwXSB9O1xudmFyIHNoYXJlZEMgPSB7IHNpZ246IDEsIGRhdGE6IFswLCAwXSB9O1xudmFyIHNoYXJlZERhdGEgPSBbMCwgMF07XG5mdW5jdGlvbiB1bmlmb3JtTGFyZ2VJbnRJbnRlcm5hbChmcm9tLCB0bywgcmFuZ2VTaXplLCBybmcpIHtcbiAgICB2YXIgcmFuZ2VTaXplQXJyYXlJbnRWYWx1ZSA9IHJhbmdlU2l6ZSA8PSBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUlxuICAgICAgICA/IEFycmF5SW50XzEuZnJvbU51bWJlclRvQXJyYXlJbnQ2NChzaGFyZWRDLCByYW5nZVNpemUpXG4gICAgICAgIDogQXJyYXlJbnRfMS5zdWJzdHJhY3RBcnJheUludDY0KHNoYXJlZEMsIEFycmF5SW50XzEuZnJvbU51bWJlclRvQXJyYXlJbnQ2NChzaGFyZWRBLCB0byksIEFycmF5SW50XzEuZnJvbU51bWJlclRvQXJyYXlJbnQ2NChzaGFyZWRCLCBmcm9tKSk7XG4gICAgaWYgKHJhbmdlU2l6ZUFycmF5SW50VmFsdWUuZGF0YVsxXSA9PT0gMHhmZmZmZmZmZikge1xuICAgICAgICByYW5nZVNpemVBcnJheUludFZhbHVlLmRhdGFbMF0gKz0gMTtcbiAgICAgICAgcmFuZ2VTaXplQXJyYXlJbnRWYWx1ZS5kYXRhWzFdID0gMDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJhbmdlU2l6ZUFycmF5SW50VmFsdWUuZGF0YVsxXSArPSAxO1xuICAgIH1cbiAgICBVbnNhZmVVbmlmb3JtQXJyYXlJbnREaXN0cmlidXRpb25JbnRlcm5hbF8xLnVuc2FmZVVuaWZvcm1BcnJheUludERpc3RyaWJ1dGlvbkludGVybmFsKHNoYXJlZERhdGEsIHJhbmdlU2l6ZUFycmF5SW50VmFsdWUuZGF0YSwgcm5nKTtcbiAgICByZXR1cm4gc2hhcmVkRGF0YVswXSAqIDB4MTAwMDAwMDAwICsgc2hhcmVkRGF0YVsxXSArIGZyb207XG59XG5mdW5jdGlvbiB1bnNhZmVVbmlmb3JtSW50RGlzdHJpYnV0aW9uKGZyb20sIHRvLCBybmcpIHtcbiAgICB2YXIgcmFuZ2VTaXplID0gdG8gLSBmcm9tO1xuICAgIGlmIChyYW5nZVNpemUgPD0gMHhmZmZmZmZmZikge1xuICAgICAgICB2YXIgZyA9IFVuc2FmZVVuaWZvcm1JbnREaXN0cmlidXRpb25JbnRlcm5hbF8xLnVuc2FmZVVuaWZvcm1JbnREaXN0cmlidXRpb25JbnRlcm5hbChyYW5nZVNpemUgKyAxLCBybmcpO1xuICAgICAgICByZXR1cm4gZyArIGZyb207XG4gICAgfVxuICAgIHJldHVybiB1bmlmb3JtTGFyZ2VJbnRJbnRlcm5hbChmcm9tLCB0bywgcmFuZ2VTaXplLCBybmcpO1xufVxuZXhwb3J0cy51bnNhZmVVbmlmb3JtSW50RGlzdHJpYnV0aW9uID0gdW5zYWZlVW5pZm9ybUludERpc3RyaWJ1dGlvbjtcbiIsIlwidXNlIHN0cmljdFwiO1xuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbmV4cG9ydHMuc3Vic3RyYWN0QXJyYXlJbnQ2NCA9IGV4cG9ydHMuZnJvbU51bWJlclRvQXJyYXlJbnQ2NCA9IGV4cG9ydHMudHJpbUFycmF5SW50SW5wbGFjZSA9IGV4cG9ydHMuc3Vic3RyYWN0QXJyYXlJbnRUb05ldyA9IGV4cG9ydHMuYWRkT25lVG9Qb3NpdGl2ZUFycmF5SW50ID0gZXhwb3J0cy5hZGRBcnJheUludFRvTmV3ID0gdm9pZCAwO1xuZnVuY3Rpb24gYWRkQXJyYXlJbnRUb05ldyhhcnJheUludEEsIGFycmF5SW50Qikge1xuICAgIGlmIChhcnJheUludEEuc2lnbiAhPT0gYXJyYXlJbnRCLnNpZ24pIHtcbiAgICAgICAgcmV0dXJuIHN1YnN0cmFjdEFycmF5SW50VG9OZXcoYXJyYXlJbnRBLCB7IHNpZ246IC1hcnJheUludEIuc2lnbiwgZGF0YTogYXJyYXlJbnRCLmRhdGEgfSk7XG4gICAgfVxuICAgIHZhciBkYXRhID0gW107XG4gICAgdmFyIHJlbWluZGVyID0gMDtcbiAgICB2YXIgZGF0YUEgPSBhcnJheUludEEuZGF0YTtcbiAgICB2YXIgZGF0YUIgPSBhcnJheUludEIuZGF0YTtcbiAgICBmb3IgKHZhciBpbmRleEEgPSBkYXRhQS5sZW5ndGggLSAxLCBpbmRleEIgPSBkYXRhQi5sZW5ndGggLSAxOyBpbmRleEEgPj0gMCB8fCBpbmRleEIgPj0gMDsgLS1pbmRleEEsIC0taW5kZXhCKSB7XG4gICAgICAgIHZhciB2QSA9IGluZGV4QSA+PSAwID8gZGF0YUFbaW5kZXhBXSA6IDA7XG4gICAgICAgIHZhciB2QiA9IGluZGV4QiA+PSAwID8gZGF0YUJbaW5kZXhCXSA6IDA7XG4gICAgICAgIHZhciBjdXJyZW50ID0gdkEgKyB2QiArIHJlbWluZGVyO1xuICAgICAgICBkYXRhLnB1c2goY3VycmVudCA+Pj4gMCk7XG4gICAgICAgIHJlbWluZGVyID0gfn4oY3VycmVudCAvIDB4MTAwMDAwMDAwKTtcbiAgICB9XG4gICAgaWYgKHJlbWluZGVyICE9PSAwKSB7XG4gICAgICAgIGRhdGEucHVzaChyZW1pbmRlcik7XG4gICAgfVxuICAgIHJldHVybiB7IHNpZ246IGFycmF5SW50QS5zaWduLCBkYXRhOiBkYXRhLnJldmVyc2UoKSB9O1xufVxuZXhwb3J0cy5hZGRBcnJheUludFRvTmV3ID0gYWRkQXJyYXlJbnRUb05ldztcbmZ1bmN0aW9uIGFkZE9uZVRvUG9zaXRpdmVBcnJheUludChhcnJheUludCkge1xuICAgIGFycmF5SW50LnNpZ24gPSAxO1xuICAgIHZhciBkYXRhID0gYXJyYXlJbnQuZGF0YTtcbiAgICBmb3IgKHZhciBpbmRleCA9IGRhdGEubGVuZ3RoIC0gMTsgaW5kZXggPj0gMDsgLS1pbmRleCkge1xuICAgICAgICBpZiAoZGF0YVtpbmRleF0gPT09IDB4ZmZmZmZmZmYpIHtcbiAgICAgICAgICAgIGRhdGFbaW5kZXhdID0gMDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGRhdGFbaW5kZXhdICs9IDE7XG4gICAgICAgICAgICByZXR1cm4gYXJyYXlJbnQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZGF0YS51bnNoaWZ0KDEpO1xuICAgIHJldHVybiBhcnJheUludDtcbn1cbmV4cG9ydHMuYWRkT25lVG9Qb3NpdGl2ZUFycmF5SW50ID0gYWRkT25lVG9Qb3NpdGl2ZUFycmF5SW50O1xuZnVuY3Rpb24gaXNTdHJpY3RseVNtYWxsZXIoZGF0YUEsIGRhdGFCKSB7XG4gICAgdmFyIG1heExlbmd0aCA9IE1hdGgubWF4KGRhdGFBLmxlbmd0aCwgZGF0YUIubGVuZ3RoKTtcbiAgICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgbWF4TGVuZ3RoOyArK2luZGV4KSB7XG4gICAgICAgIHZhciBpbmRleEEgPSBpbmRleCArIGRhdGFBLmxlbmd0aCAtIG1heExlbmd0aDtcbiAgICAgICAgdmFyIGluZGV4QiA9IGluZGV4ICsgZGF0YUIubGVuZ3RoIC0gbWF4TGVuZ3RoO1xuICAgICAgICB2YXIgdkEgPSBpbmRleEEgPj0gMCA/IGRhdGFBW2luZGV4QV0gOiAwO1xuICAgICAgICB2YXIgdkIgPSBpbmRleEIgPj0gMCA/IGRhdGFCW2luZGV4Ql0gOiAwO1xuICAgICAgICBpZiAodkEgPCB2QilcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICBpZiAodkEgPiB2QilcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gc3Vic3RyYWN0QXJyYXlJbnRUb05ldyhhcnJheUludEEsIGFycmF5SW50Qikge1xuICAgIGlmIChhcnJheUludEEuc2lnbiAhPT0gYXJyYXlJbnRCLnNpZ24pIHtcbiAgICAgICAgcmV0dXJuIGFkZEFycmF5SW50VG9OZXcoYXJyYXlJbnRBLCB7IHNpZ246IC1hcnJheUludEIuc2lnbiwgZGF0YTogYXJyYXlJbnRCLmRhdGEgfSk7XG4gICAgfVxuICAgIHZhciBkYXRhQSA9IGFycmF5SW50QS5kYXRhO1xuICAgIHZhciBkYXRhQiA9IGFycmF5SW50Qi5kYXRhO1xuICAgIGlmIChpc1N0cmljdGx5U21hbGxlcihkYXRhQSwgZGF0YUIpKSB7XG4gICAgICAgIHZhciBvdXQgPSBzdWJzdHJhY3RBcnJheUludFRvTmV3KGFycmF5SW50QiwgYXJyYXlJbnRBKTtcbiAgICAgICAgb3V0LnNpZ24gPSAtb3V0LnNpZ247XG4gICAgICAgIHJldHVybiBvdXQ7XG4gICAgfVxuICAgIHZhciBkYXRhID0gW107XG4gICAgdmFyIHJlbWluZGVyID0gMDtcbiAgICBmb3IgKHZhciBpbmRleEEgPSBkYXRhQS5sZW5ndGggLSAxLCBpbmRleEIgPSBkYXRhQi5sZW5ndGggLSAxOyBpbmRleEEgPj0gMCB8fCBpbmRleEIgPj0gMDsgLS1pbmRleEEsIC0taW5kZXhCKSB7XG4gICAgICAgIHZhciB2QSA9IGluZGV4QSA+PSAwID8gZGF0YUFbaW5kZXhBXSA6IDA7XG4gICAgICAgIHZhciB2QiA9IGluZGV4QiA+PSAwID8gZGF0YUJbaW5kZXhCXSA6IDA7XG4gICAgICAgIHZhciBjdXJyZW50ID0gdkEgLSB2QiAtIHJlbWluZGVyO1xuICAgICAgICBkYXRhLnB1c2goY3VycmVudCA+Pj4gMCk7XG4gICAgICAgIHJlbWluZGVyID0gY3VycmVudCA8IDAgPyAxIDogMDtcbiAgICB9XG4gICAgcmV0dXJuIHsgc2lnbjogYXJyYXlJbnRBLnNpZ24sIGRhdGE6IGRhdGEucmV2ZXJzZSgpIH07XG59XG5leHBvcnRzLnN1YnN0cmFjdEFycmF5SW50VG9OZXcgPSBzdWJzdHJhY3RBcnJheUludFRvTmV3O1xuZnVuY3Rpb24gdHJpbUFycmF5SW50SW5wbGFjZShhcnJheUludCkge1xuICAgIHZhciBkYXRhID0gYXJyYXlJbnQuZGF0YTtcbiAgICB2YXIgZmlyc3ROb25aZXJvID0gMDtcbiAgICBmb3IgKDsgZmlyc3ROb25aZXJvICE9PSBkYXRhLmxlbmd0aCAmJiBkYXRhW2ZpcnN0Tm9uWmVyb10gPT09IDA7ICsrZmlyc3ROb25aZXJvKSB7IH1cbiAgICBpZiAoZmlyc3ROb25aZXJvID09PSBkYXRhLmxlbmd0aCkge1xuICAgICAgICBhcnJheUludC5zaWduID0gMTtcbiAgICAgICAgYXJyYXlJbnQuZGF0YSA9IFswXTtcbiAgICAgICAgcmV0dXJuIGFycmF5SW50O1xuICAgIH1cbiAgICBkYXRhLnNwbGljZSgwLCBmaXJzdE5vblplcm8pO1xuICAgIHJldHVybiBhcnJheUludDtcbn1cbmV4cG9ydHMudHJpbUFycmF5SW50SW5wbGFjZSA9IHRyaW1BcnJheUludElucGxhY2U7XG5mdW5jdGlvbiBmcm9tTnVtYmVyVG9BcnJheUludDY0KG91dCwgbikge1xuICAgIGlmIChuIDwgMCkge1xuICAgICAgICB2YXIgcG9zTiA9IC1uO1xuICAgICAgICBvdXQuc2lnbiA9IC0xO1xuICAgICAgICBvdXQuZGF0YVswXSA9IH5+KHBvc04gLyAweDEwMDAwMDAwMCk7XG4gICAgICAgIG91dC5kYXRhWzFdID0gcG9zTiA+Pj4gMDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIG91dC5zaWduID0gMTtcbiAgICAgICAgb3V0LmRhdGFbMF0gPSB+fihuIC8gMHgxMDAwMDAwMDApO1xuICAgICAgICBvdXQuZGF0YVsxXSA9IG4gPj4+IDA7XG4gICAgfVxuICAgIHJldHVybiBvdXQ7XG59XG5leHBvcnRzLmZyb21OdW1iZXJUb0FycmF5SW50NjQgPSBmcm9tTnVtYmVyVG9BcnJheUludDY0O1xuZnVuY3Rpb24gc3Vic3RyYWN0QXJyYXlJbnQ2NChvdXQsIGFycmF5SW50QSwgYXJyYXlJbnRCKSB7XG4gICAgdmFyIGxvd0EgPSBhcnJheUludEEuZGF0YVsxXTtcbiAgICB2YXIgaGlnaEEgPSBhcnJheUludEEuZGF0YVswXTtcbiAgICB2YXIgc2lnbkEgPSBhcnJheUludEEuc2lnbjtcbiAgICB2YXIgbG93QiA9IGFycmF5SW50Qi5kYXRhWzFdO1xuICAgIHZhciBoaWdoQiA9IGFycmF5SW50Qi5kYXRhWzBdO1xuICAgIHZhciBzaWduQiA9IGFycmF5SW50Qi5zaWduO1xuICAgIG91dC5zaWduID0gMTtcbiAgICBpZiAoc2lnbkEgPT09IDEgJiYgc2lnbkIgPT09IC0xKSB7XG4gICAgICAgIHZhciBsb3dfMSA9IGxvd0EgKyBsb3dCO1xuICAgICAgICB2YXIgaGlnaCA9IGhpZ2hBICsgaGlnaEIgKyAobG93XzEgPiAweGZmZmZmZmZmID8gMSA6IDApO1xuICAgICAgICBvdXQuZGF0YVswXSA9IGhpZ2ggPj4+IDA7XG4gICAgICAgIG91dC5kYXRhWzFdID0gbG93XzEgPj4+IDA7XG4gICAgICAgIHJldHVybiBvdXQ7XG4gICAgfVxuICAgIHZhciBsb3dGaXJzdCA9IGxvd0E7XG4gICAgdmFyIGhpZ2hGaXJzdCA9IGhpZ2hBO1xuICAgIHZhciBsb3dTZWNvbmQgPSBsb3dCO1xuICAgIHZhciBoaWdoU2Vjb25kID0gaGlnaEI7XG4gICAgaWYgKHNpZ25BID09PSAtMSkge1xuICAgICAgICBsb3dGaXJzdCA9IGxvd0I7XG4gICAgICAgIGhpZ2hGaXJzdCA9IGhpZ2hCO1xuICAgICAgICBsb3dTZWNvbmQgPSBsb3dBO1xuICAgICAgICBoaWdoU2Vjb25kID0gaGlnaEE7XG4gICAgfVxuICAgIHZhciByZW1pbmRlckxvdyA9IDA7XG4gICAgdmFyIGxvdyA9IGxvd0ZpcnN0IC0gbG93U2Vjb25kO1xuICAgIGlmIChsb3cgPCAwKSB7XG4gICAgICAgIHJlbWluZGVyTG93ID0gMTtcbiAgICAgICAgbG93ID0gbG93ID4+PiAwO1xuICAgIH1cbiAgICBvdXQuZGF0YVswXSA9IGhpZ2hGaXJzdCAtIGhpZ2hTZWNvbmQgLSByZW1pbmRlckxvdztcbiAgICBvdXQuZGF0YVsxXSA9IGxvdztcbiAgICByZXR1cm4gb3V0O1xufVxuZXhwb3J0cy5zdWJzdHJhY3RBcnJheUludDY0ID0gc3Vic3RyYWN0QXJyYXlJbnQ2NDtcbiIsIlwidXNlIHN0cmljdFwiO1xuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbmV4cG9ydHMudW5zYWZlVW5pZm9ybUFycmF5SW50RGlzdHJpYnV0aW9uSW50ZXJuYWwgPSB2b2lkIDA7XG52YXIgVW5zYWZlVW5pZm9ybUludERpc3RyaWJ1dGlvbkludGVybmFsXzEgPSByZXF1aXJlKFwiLi9VbnNhZmVVbmlmb3JtSW50RGlzdHJpYnV0aW9uSW50ZXJuYWxcIik7XG5mdW5jdGlvbiB1bnNhZmVVbmlmb3JtQXJyYXlJbnREaXN0cmlidXRpb25JbnRlcm5hbChvdXQsIHJhbmdlU2l6ZSwgcm5nKSB7XG4gICAgdmFyIHJhbmdlTGVuZ3RoID0gcmFuZ2VTaXplLmxlbmd0aDtcbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4ICE9PSByYW5nZUxlbmd0aDsgKytpbmRleCkge1xuICAgICAgICAgICAgdmFyIGluZGV4UmFuZ2VTaXplID0gaW5kZXggPT09IDAgPyByYW5nZVNpemVbMF0gKyAxIDogMHgxMDAwMDAwMDA7XG4gICAgICAgICAgICB2YXIgZyA9IFVuc2FmZVVuaWZvcm1JbnREaXN0cmlidXRpb25JbnRlcm5hbF8xLnVuc2FmZVVuaWZvcm1JbnREaXN0cmlidXRpb25JbnRlcm5hbChpbmRleFJhbmdlU2l6ZSwgcm5nKTtcbiAgICAgICAgICAgIG91dFtpbmRleF0gPSBnO1xuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIGluZGV4ID0gMDsgaW5kZXggIT09IHJhbmdlTGVuZ3RoOyArK2luZGV4KSB7XG4gICAgICAgICAgICB2YXIgY3VycmVudCA9IG91dFtpbmRleF07XG4gICAgICAgICAgICB2YXIgY3VycmVudEluUmFuZ2UgPSByYW5nZVNpemVbaW5kZXhdO1xuICAgICAgICAgICAgaWYgKGN1cnJlbnQgPCBjdXJyZW50SW5SYW5nZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBvdXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjdXJyZW50ID4gY3VycmVudEluUmFuZ2UpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMudW5zYWZlVW5pZm9ybUFycmF5SW50RGlzdHJpYnV0aW9uSW50ZXJuYWwgPSB1bnNhZmVVbmlmb3JtQXJyYXlJbnREaXN0cmlidXRpb25JbnRlcm5hbDtcbiIsIlwidXNlIHN0cmljdFwiO1xuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbmV4cG9ydHMudW5zYWZlVW5pZm9ybUludERpc3RyaWJ1dGlvbkludGVybmFsID0gdm9pZCAwO1xuZnVuY3Rpb24gdW5zYWZlVW5pZm9ybUludERpc3RyaWJ1dGlvbkludGVybmFsKHJhbmdlU2l6ZSwgcm5nKSB7XG4gICAgdmFyIE1pblJuZyA9IHJuZy5taW4oKTtcbiAgICB2YXIgTnVtVmFsdWVzID0gcm5nLm1heCgpIC0gcm5nLm1pbigpICsgMTtcbiAgICBpZiAocmFuZ2VTaXplIDw9IE51bVZhbHVlcykge1xuICAgICAgICB2YXIgbnJuZ18xID0gcm5nO1xuICAgICAgICB2YXIgTWF4QWxsb3dlZCA9IE51bVZhbHVlcyAtIChOdW1WYWx1ZXMgJSByYW5nZVNpemUpO1xuICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgdmFyIG91dCA9IG5ybmdfMS51bnNhZmVOZXh0KCk7XG4gICAgICAgICAgICB2YXIgZGVsdGFWID0gb3V0IC0gTWluUm5nO1xuICAgICAgICAgICAgaWYgKGRlbHRhViA8IE1heEFsbG93ZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZGVsdGFWICUgcmFuZ2VTaXplO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHZhciBGaW5hbE51bVZhbHVlcyA9IE51bVZhbHVlcyAqIE51bVZhbHVlcztcbiAgICB2YXIgTnVtSXRlcmF0aW9ucyA9IDI7XG4gICAgd2hpbGUgKEZpbmFsTnVtVmFsdWVzIDwgcmFuZ2VTaXplKSB7XG4gICAgICAgIEZpbmFsTnVtVmFsdWVzICo9IE51bVZhbHVlcztcbiAgICAgICAgKytOdW1JdGVyYXRpb25zO1xuICAgIH1cbiAgICB2YXIgTWF4QWNjZXB0ZWRSYW5kb20gPSByYW5nZVNpemUgKiBNYXRoLmZsb29yKCgxICogRmluYWxOdW1WYWx1ZXMpIC8gcmFuZ2VTaXplKTtcbiAgICB2YXIgbnJuZyA9IHJuZztcbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICB2YXIgdmFsdWUgPSAwO1xuICAgICAgICBmb3IgKHZhciBudW0gPSAwOyBudW0gIT09IE51bUl0ZXJhdGlvbnM7ICsrbnVtKSB7XG4gICAgICAgICAgICB2YXIgb3V0ID0gbnJuZy51bnNhZmVOZXh0KCk7XG4gICAgICAgICAgICB2YWx1ZSA9IE51bVZhbHVlcyAqIHZhbHVlICsgKG91dCAtIE1pblJuZyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZhbHVlIDwgTWF4QWNjZXB0ZWRSYW5kb20pIHtcbiAgICAgICAgICAgIHZhciBpbkRpZmYgPSB2YWx1ZSAtIHJhbmdlU2l6ZSAqIE1hdGguZmxvb3IoKDEgKiB2YWx1ZSkgLyByYW5nZVNpemUpO1xuICAgICAgICAgICAgcmV0dXJuIGluRGlmZjtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMudW5zYWZlVW5pZm9ybUludERpc3RyaWJ1dGlvbkludGVybmFsID0gdW5zYWZlVW5pZm9ybUludERpc3RyaWJ1dGlvbkludGVybmFsO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuZXhwb3J0cy5jb25ncnVlbnRpYWwzMiA9IGV4cG9ydHMuY29uZ3J1ZW50aWFsID0gdm9pZCAwO1xudmFyIE1VTFRJUExJRVIgPSAweDAwMDM0M2ZkO1xudmFyIElOQ1JFTUVOVCA9IDB4MDAyNjllYzM7XG52YXIgTUFTSyA9IDB4ZmZmZmZmZmY7XG52YXIgTUFTS18yID0gKDEgPDwgMzEpIC0gMTtcbnZhciBjb21wdXRlTmV4dFNlZWQgPSBmdW5jdGlvbiAoc2VlZCkge1xuICAgIHJldHVybiAoc2VlZCAqIE1VTFRJUExJRVIgKyBJTkNSRU1FTlQpICYgTUFTSztcbn07XG52YXIgY29tcHV0ZVZhbHVlRnJvbU5leHRTZWVkID0gZnVuY3Rpb24gKG5leHRzZWVkKSB7XG4gICAgcmV0dXJuIChuZXh0c2VlZCAmIE1BU0tfMikgPj4gMTY7XG59O1xudmFyIExpbmVhckNvbmdydWVudGlhbCA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTGluZWFyQ29uZ3J1ZW50aWFsKHNlZWQpIHtcbiAgICAgICAgdGhpcy5zZWVkID0gc2VlZDtcbiAgICB9XG4gICAgTGluZWFyQ29uZ3J1ZW50aWFsLnByb3RvdHlwZS5taW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBMaW5lYXJDb25ncnVlbnRpYWwubWluO1xuICAgIH07XG4gICAgTGluZWFyQ29uZ3J1ZW50aWFsLnByb3RvdHlwZS5tYXggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBMaW5lYXJDb25ncnVlbnRpYWwubWF4O1xuICAgIH07XG4gICAgTGluZWFyQ29uZ3J1ZW50aWFsLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBMaW5lYXJDb25ncnVlbnRpYWwodGhpcy5zZWVkKTtcbiAgICB9O1xuICAgIExpbmVhckNvbmdydWVudGlhbC5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG5leHRSbmcgPSBuZXcgTGluZWFyQ29uZ3J1ZW50aWFsKHRoaXMuc2VlZCk7XG4gICAgICAgIHZhciBvdXQgPSBuZXh0Um5nLnVuc2FmZU5leHQoKTtcbiAgICAgICAgcmV0dXJuIFtvdXQsIG5leHRSbmddO1xuICAgIH07XG4gICAgTGluZWFyQ29uZ3J1ZW50aWFsLnByb3RvdHlwZS51bnNhZmVOZXh0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnNlZWQgPSBjb21wdXRlTmV4dFNlZWQodGhpcy5zZWVkKTtcbiAgICAgICAgcmV0dXJuIGNvbXB1dGVWYWx1ZUZyb21OZXh0U2VlZCh0aGlzLnNlZWQpO1xuICAgIH07XG4gICAgTGluZWFyQ29uZ3J1ZW50aWFsLm1pbiA9IDA7XG4gICAgTGluZWFyQ29uZ3J1ZW50aWFsLm1heCA9IE1hdGgucG93KDIsIDE1KSAtIDE7XG4gICAgcmV0dXJuIExpbmVhckNvbmdydWVudGlhbDtcbn0oKSk7XG52YXIgTGluZWFyQ29uZ3J1ZW50aWFsMzIgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIExpbmVhckNvbmdydWVudGlhbDMyKHNlZWQpIHtcbiAgICAgICAgdGhpcy5zZWVkID0gc2VlZDtcbiAgICB9XG4gICAgTGluZWFyQ29uZ3J1ZW50aWFsMzIucHJvdG90eXBlLm1pbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIExpbmVhckNvbmdydWVudGlhbDMyLm1pbjtcbiAgICB9O1xuICAgIExpbmVhckNvbmdydWVudGlhbDMyLnByb3RvdHlwZS5tYXggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBMaW5lYXJDb25ncnVlbnRpYWwzMi5tYXg7XG4gICAgfTtcbiAgICBMaW5lYXJDb25ncnVlbnRpYWwzMi5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBuZXcgTGluZWFyQ29uZ3J1ZW50aWFsMzIodGhpcy5zZWVkKTtcbiAgICB9O1xuICAgIExpbmVhckNvbmdydWVudGlhbDMyLnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgbmV4dFJuZyA9IG5ldyBMaW5lYXJDb25ncnVlbnRpYWwzMih0aGlzLnNlZWQpO1xuICAgICAgICB2YXIgb3V0ID0gbmV4dFJuZy51bnNhZmVOZXh0KCk7XG4gICAgICAgIHJldHVybiBbb3V0LCBuZXh0Um5nXTtcbiAgICB9O1xuICAgIExpbmVhckNvbmdydWVudGlhbDMyLnByb3RvdHlwZS51bnNhZmVOZXh0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgczEgPSBjb21wdXRlTmV4dFNlZWQodGhpcy5zZWVkKTtcbiAgICAgICAgdmFyIHYxID0gY29tcHV0ZVZhbHVlRnJvbU5leHRTZWVkKHMxKTtcbiAgICAgICAgdmFyIHMyID0gY29tcHV0ZU5leHRTZWVkKHMxKTtcbiAgICAgICAgdmFyIHYyID0gY29tcHV0ZVZhbHVlRnJvbU5leHRTZWVkKHMyKTtcbiAgICAgICAgdGhpcy5zZWVkID0gY29tcHV0ZU5leHRTZWVkKHMyKTtcbiAgICAgICAgdmFyIHYzID0gY29tcHV0ZVZhbHVlRnJvbU5leHRTZWVkKHRoaXMuc2VlZCk7XG4gICAgICAgIHZhciB2bmV4dCA9IHYzICsgKCh2MiArICh2MSA8PCAxNSkpIDw8IDE1KTtcbiAgICAgICAgcmV0dXJuICgodm5leHQgKyAweDgwMDAwMDAwKSB8IDApICsgMHg4MDAwMDAwMDtcbiAgICB9O1xuICAgIExpbmVhckNvbmdydWVudGlhbDMyLm1pbiA9IDA7XG4gICAgTGluZWFyQ29uZ3J1ZW50aWFsMzIubWF4ID0gMHhmZmZmZmZmZjtcbiAgICByZXR1cm4gTGluZWFyQ29uZ3J1ZW50aWFsMzI7XG59KCkpO1xudmFyIGNvbmdydWVudGlhbCA9IGZ1bmN0aW9uIChzZWVkKSB7XG4gICAgcmV0dXJuIG5ldyBMaW5lYXJDb25ncnVlbnRpYWwoc2VlZCk7XG59O1xuZXhwb3J0cy5jb25ncnVlbnRpYWwgPSBjb25ncnVlbnRpYWw7XG52YXIgY29uZ3J1ZW50aWFsMzIgPSBmdW5jdGlvbiAoc2VlZCkge1xuICAgIHJldHVybiBuZXcgTGluZWFyQ29uZ3J1ZW50aWFsMzIoc2VlZCk7XG59O1xuZXhwb3J0cy5jb25ncnVlbnRpYWwzMiA9IGNvbmdydWVudGlhbDMyO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xudmFyIE1lcnNlbm5lVHdpc3RlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTWVyc2VubmVUd2lzdGVyKHN0YXRlcywgaW5kZXgpIHtcbiAgICAgICAgdGhpcy5zdGF0ZXMgPSBzdGF0ZXM7XG4gICAgICAgIHRoaXMuaW5kZXggPSBpbmRleDtcbiAgICB9XG4gICAgTWVyc2VubmVUd2lzdGVyLnR3aXN0ID0gZnVuY3Rpb24gKHByZXYpIHtcbiAgICAgICAgdmFyIG10ID0gcHJldi5zbGljZSgpO1xuICAgICAgICBmb3IgKHZhciBpZHggPSAwOyBpZHggIT09IE1lcnNlbm5lVHdpc3Rlci5OIC0gTWVyc2VubmVUd2lzdGVyLk07ICsraWR4KSB7XG4gICAgICAgICAgICB2YXIgeV8xID0gKG10W2lkeF0gJiBNZXJzZW5uZVR3aXN0ZXIuTUFTS19VUFBFUikgKyAobXRbaWR4ICsgMV0gJiBNZXJzZW5uZVR3aXN0ZXIuTUFTS19MT1dFUik7XG4gICAgICAgICAgICBtdFtpZHhdID0gbXRbaWR4ICsgTWVyc2VubmVUd2lzdGVyLk1dIF4gKHlfMSA+Pj4gMSkgXiAoLSh5XzEgJiAxKSAmIE1lcnNlbm5lVHdpc3Rlci5BKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBpZHggPSBNZXJzZW5uZVR3aXN0ZXIuTiAtIE1lcnNlbm5lVHdpc3Rlci5NOyBpZHggIT09IE1lcnNlbm5lVHdpc3Rlci5OIC0gMTsgKytpZHgpIHtcbiAgICAgICAgICAgIHZhciB5XzIgPSAobXRbaWR4XSAmIE1lcnNlbm5lVHdpc3Rlci5NQVNLX1VQUEVSKSArIChtdFtpZHggKyAxXSAmIE1lcnNlbm5lVHdpc3Rlci5NQVNLX0xPV0VSKTtcbiAgICAgICAgICAgIG10W2lkeF0gPSBtdFtpZHggKyBNZXJzZW5uZVR3aXN0ZXIuTSAtIE1lcnNlbm5lVHdpc3Rlci5OXSBeICh5XzIgPj4+IDEpIF4gKC0oeV8yICYgMSkgJiBNZXJzZW5uZVR3aXN0ZXIuQSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHkgPSAobXRbTWVyc2VubmVUd2lzdGVyLk4gLSAxXSAmIE1lcnNlbm5lVHdpc3Rlci5NQVNLX1VQUEVSKSArIChtdFswXSAmIE1lcnNlbm5lVHdpc3Rlci5NQVNLX0xPV0VSKTtcbiAgICAgICAgbXRbTWVyc2VubmVUd2lzdGVyLk4gLSAxXSA9IG10W01lcnNlbm5lVHdpc3Rlci5NIC0gMV0gXiAoeSA+Pj4gMSkgXiAoLSh5ICYgMSkgJiBNZXJzZW5uZVR3aXN0ZXIuQSk7XG4gICAgICAgIHJldHVybiBtdDtcbiAgICB9O1xuICAgIE1lcnNlbm5lVHdpc3Rlci5zZWVkZWQgPSBmdW5jdGlvbiAoc2VlZCkge1xuICAgICAgICB2YXIgb3V0ID0gQXJyYXkoTWVyc2VubmVUd2lzdGVyLk4pO1xuICAgICAgICBvdXRbMF0gPSBzZWVkO1xuICAgICAgICBmb3IgKHZhciBpZHggPSAxOyBpZHggIT09IE1lcnNlbm5lVHdpc3Rlci5OOyArK2lkeCkge1xuICAgICAgICAgICAgdmFyIHhvcmVkID0gb3V0W2lkeCAtIDFdIF4gKG91dFtpZHggLSAxXSA+Pj4gMzApO1xuICAgICAgICAgICAgb3V0W2lkeF0gPSAoTWF0aC5pbXVsKE1lcnNlbm5lVHdpc3Rlci5GLCB4b3JlZCkgKyBpZHgpIHwgMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3V0O1xuICAgIH07XG4gICAgTWVyc2VubmVUd2lzdGVyLmZyb20gPSBmdW5jdGlvbiAoc2VlZCkge1xuICAgICAgICByZXR1cm4gbmV3IE1lcnNlbm5lVHdpc3RlcihNZXJzZW5uZVR3aXN0ZXIudHdpc3QoTWVyc2VubmVUd2lzdGVyLnNlZWRlZChzZWVkKSksIDApO1xuICAgIH07XG4gICAgTWVyc2VubmVUd2lzdGVyLnByb3RvdHlwZS5taW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBNZXJzZW5uZVR3aXN0ZXIubWluO1xuICAgIH07XG4gICAgTWVyc2VubmVUd2lzdGVyLnByb3RvdHlwZS5tYXggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBNZXJzZW5uZVR3aXN0ZXIubWF4O1xuICAgIH07XG4gICAgTWVyc2VubmVUd2lzdGVyLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBNZXJzZW5uZVR3aXN0ZXIodGhpcy5zdGF0ZXMsIHRoaXMuaW5kZXgpO1xuICAgIH07XG4gICAgTWVyc2VubmVUd2lzdGVyLnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgbmV4dFJuZyA9IG5ldyBNZXJzZW5uZVR3aXN0ZXIodGhpcy5zdGF0ZXMsIHRoaXMuaW5kZXgpO1xuICAgICAgICB2YXIgb3V0ID0gbmV4dFJuZy51bnNhZmVOZXh0KCk7XG4gICAgICAgIHJldHVybiBbb3V0LCBuZXh0Um5nXTtcbiAgICB9O1xuICAgIE1lcnNlbm5lVHdpc3Rlci5wcm90b3R5cGUudW5zYWZlTmV4dCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHkgPSB0aGlzLnN0YXRlc1t0aGlzLmluZGV4XTtcbiAgICAgICAgeSBePSB0aGlzLnN0YXRlc1t0aGlzLmluZGV4XSA+Pj4gTWVyc2VubmVUd2lzdGVyLlU7XG4gICAgICAgIHkgXj0gKHkgPDwgTWVyc2VubmVUd2lzdGVyLlMpICYgTWVyc2VubmVUd2lzdGVyLkI7XG4gICAgICAgIHkgXj0gKHkgPDwgTWVyc2VubmVUd2lzdGVyLlQpICYgTWVyc2VubmVUd2lzdGVyLkM7XG4gICAgICAgIHkgXj0geSA+Pj4gTWVyc2VubmVUd2lzdGVyLkw7XG4gICAgICAgIGlmICgrK3RoaXMuaW5kZXggPj0gTWVyc2VubmVUd2lzdGVyLk4pIHtcbiAgICAgICAgICAgIHRoaXMuc3RhdGVzID0gTWVyc2VubmVUd2lzdGVyLnR3aXN0KHRoaXMuc3RhdGVzKTtcbiAgICAgICAgICAgIHRoaXMuaW5kZXggPSAwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB5ID4+PiAwO1xuICAgIH07XG4gICAgTWVyc2VubmVUd2lzdGVyLm1pbiA9IDA7XG4gICAgTWVyc2VubmVUd2lzdGVyLm1heCA9IDB4ZmZmZmZmZmY7XG4gICAgTWVyc2VubmVUd2lzdGVyLk4gPSA2MjQ7XG4gICAgTWVyc2VubmVUd2lzdGVyLk0gPSAzOTc7XG4gICAgTWVyc2VubmVUd2lzdGVyLlIgPSAzMTtcbiAgICBNZXJzZW5uZVR3aXN0ZXIuQSA9IDB4OTkwOGIwZGY7XG4gICAgTWVyc2VubmVUd2lzdGVyLkYgPSAxODEyNDMzMjUzO1xuICAgIE1lcnNlbm5lVHdpc3Rlci5VID0gMTE7XG4gICAgTWVyc2VubmVUd2lzdGVyLlMgPSA3O1xuICAgIE1lcnNlbm5lVHdpc3Rlci5CID0gMHg5ZDJjNTY4MDtcbiAgICBNZXJzZW5uZVR3aXN0ZXIuVCA9IDE1O1xuICAgIE1lcnNlbm5lVHdpc3Rlci5DID0gMHhlZmM2MDAwMDtcbiAgICBNZXJzZW5uZVR3aXN0ZXIuTCA9IDE4O1xuICAgIE1lcnNlbm5lVHdpc3Rlci5NQVNLX0xPV0VSID0gTWF0aC5wb3coMiwgTWVyc2VubmVUd2lzdGVyLlIpIC0gMTtcbiAgICBNZXJzZW5uZVR3aXN0ZXIuTUFTS19VUFBFUiA9IE1hdGgucG93KDIsIE1lcnNlbm5lVHdpc3Rlci5SKTtcbiAgICByZXR1cm4gTWVyc2VubmVUd2lzdGVyO1xufSgpKTtcbmZ1bmN0aW9uIGRlZmF1bHRfMShzZWVkKSB7XG4gICAgcmV0dXJuIE1lcnNlbm5lVHdpc3Rlci5mcm9tKHNlZWQpO1xufVxuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBkZWZhdWx0XzE7XG4iLCJcInVzZSBzdHJpY3RcIjtcbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5leHBvcnRzLnNraXBOID0gZXhwb3J0cy51bnNhZmVTa2lwTiA9IGV4cG9ydHMuZ2VuZXJhdGVOID0gZXhwb3J0cy51bnNhZmVHZW5lcmF0ZU4gPSB2b2lkIDA7XG5mdW5jdGlvbiB1bnNhZmVHZW5lcmF0ZU4ocm5nLCBudW0pIHtcbiAgICB2YXIgb3V0ID0gW107XG4gICAgZm9yICh2YXIgaWR4ID0gMDsgaWR4ICE9IG51bTsgKytpZHgpIHtcbiAgICAgICAgb3V0LnB1c2gocm5nLnVuc2FmZU5leHQoKSk7XG4gICAgfVxuICAgIHJldHVybiBvdXQ7XG59XG5leHBvcnRzLnVuc2FmZUdlbmVyYXRlTiA9IHVuc2FmZUdlbmVyYXRlTjtcbmZ1bmN0aW9uIGdlbmVyYXRlTihybmcsIG51bSkge1xuICAgIHZhciBuZXh0Um5nID0gcm5nLmNsb25lKCk7XG4gICAgdmFyIG91dCA9IHVuc2FmZUdlbmVyYXRlTihuZXh0Um5nLCBudW0pO1xuICAgIHJldHVybiBbb3V0LCBuZXh0Um5nXTtcbn1cbmV4cG9ydHMuZ2VuZXJhdGVOID0gZ2VuZXJhdGVOO1xuZnVuY3Rpb24gdW5zYWZlU2tpcE4ocm5nLCBudW0pIHtcbiAgICBmb3IgKHZhciBpZHggPSAwOyBpZHggIT0gbnVtOyArK2lkeCkge1xuICAgICAgICBybmcudW5zYWZlTmV4dCgpO1xuICAgIH1cbn1cbmV4cG9ydHMudW5zYWZlU2tpcE4gPSB1bnNhZmVTa2lwTjtcbmZ1bmN0aW9uIHNraXBOKHJuZywgbnVtKSB7XG4gICAgdmFyIG5leHRSbmcgPSBybmcuY2xvbmUoKTtcbiAgICB1bnNhZmVTa2lwTihuZXh0Um5nLCBudW0pO1xuICAgIHJldHVybiBuZXh0Um5nO1xufVxuZXhwb3J0cy5za2lwTiA9IHNraXBOO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuZXhwb3J0cy54b3JzaGlmdDEyOHBsdXMgPSB2b2lkIDA7XG52YXIgWG9yU2hpZnQxMjhQbHVzID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBYb3JTaGlmdDEyOFBsdXMoczAxLCBzMDAsIHMxMSwgczEwKSB7XG4gICAgICAgIHRoaXMuczAxID0gczAxO1xuICAgICAgICB0aGlzLnMwMCA9IHMwMDtcbiAgICAgICAgdGhpcy5zMTEgPSBzMTE7XG4gICAgICAgIHRoaXMuczEwID0gczEwO1xuICAgIH1cbiAgICBYb3JTaGlmdDEyOFBsdXMucHJvdG90eXBlLm1pbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIC0weDgwMDAwMDAwO1xuICAgIH07XG4gICAgWG9yU2hpZnQxMjhQbHVzLnByb3RvdHlwZS5tYXggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAweDdmZmZmZmZmO1xuICAgIH07XG4gICAgWG9yU2hpZnQxMjhQbHVzLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBYb3JTaGlmdDEyOFBsdXModGhpcy5zMDEsIHRoaXMuczAwLCB0aGlzLnMxMSwgdGhpcy5zMTApO1xuICAgIH07XG4gICAgWG9yU2hpZnQxMjhQbHVzLnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgbmV4dFJuZyA9IG5ldyBYb3JTaGlmdDEyOFBsdXModGhpcy5zMDEsIHRoaXMuczAwLCB0aGlzLnMxMSwgdGhpcy5zMTApO1xuICAgICAgICB2YXIgb3V0ID0gbmV4dFJuZy51bnNhZmVOZXh0KCk7XG4gICAgICAgIHJldHVybiBbb3V0LCBuZXh0Um5nXTtcbiAgICB9O1xuICAgIFhvclNoaWZ0MTI4UGx1cy5wcm90b3R5cGUudW5zYWZlTmV4dCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGEwID0gdGhpcy5zMDAgXiAodGhpcy5zMDAgPDwgMjMpO1xuICAgICAgICB2YXIgYTEgPSB0aGlzLnMwMSBeICgodGhpcy5zMDEgPDwgMjMpIHwgKHRoaXMuczAwID4+PiA5KSk7XG4gICAgICAgIHZhciBiMCA9IGEwIF4gdGhpcy5zMTAgXiAoKGEwID4+PiAxOCkgfCAoYTEgPDwgMTQpKSBeICgodGhpcy5zMTAgPj4+IDUpIHwgKHRoaXMuczExIDw8IDI3KSk7XG4gICAgICAgIHZhciBiMSA9IGExIF4gdGhpcy5zMTEgXiAoYTEgPj4+IDE4KSBeICh0aGlzLnMxMSA+Pj4gNSk7XG4gICAgICAgIHZhciBvdXQgPSAodGhpcy5zMDAgKyB0aGlzLnMxMCkgfCAwO1xuICAgICAgICB0aGlzLnMwMSA9IHRoaXMuczExO1xuICAgICAgICB0aGlzLnMwMCA9IHRoaXMuczEwO1xuICAgICAgICB0aGlzLnMxMSA9IGIxO1xuICAgICAgICB0aGlzLnMxMCA9IGIwO1xuICAgICAgICByZXR1cm4gb3V0O1xuICAgIH07XG4gICAgWG9yU2hpZnQxMjhQbHVzLnByb3RvdHlwZS5qdW1wID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgbmV4dFJuZyA9IG5ldyBYb3JTaGlmdDEyOFBsdXModGhpcy5zMDEsIHRoaXMuczAwLCB0aGlzLnMxMSwgdGhpcy5zMTApO1xuICAgICAgICBuZXh0Um5nLnVuc2FmZUp1bXAoKTtcbiAgICAgICAgcmV0dXJuIG5leHRSbmc7XG4gICAgfTtcbiAgICBYb3JTaGlmdDEyOFBsdXMucHJvdG90eXBlLnVuc2FmZUp1bXAgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBuczAxID0gMDtcbiAgICAgICAgdmFyIG5zMDAgPSAwO1xuICAgICAgICB2YXIgbnMxMSA9IDA7XG4gICAgICAgIHZhciBuczEwID0gMDtcbiAgICAgICAgdmFyIGp1bXAgPSBbMHg2MzVkMmRmZiwgMHg4YTVjZDc4OSwgMHg1YzQ3MmY5NiwgMHgxMjFmZDIxNV07XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpICE9PSA0OyArK2kpIHtcbiAgICAgICAgICAgIGZvciAodmFyIG1hc2sgPSAxOyBtYXNrOyBtYXNrIDw8PSAxKSB7XG4gICAgICAgICAgICAgICAgaWYgKGp1bXBbaV0gJiBtYXNrKSB7XG4gICAgICAgICAgICAgICAgICAgIG5zMDEgXj0gdGhpcy5zMDE7XG4gICAgICAgICAgICAgICAgICAgIG5zMDAgXj0gdGhpcy5zMDA7XG4gICAgICAgICAgICAgICAgICAgIG5zMTEgXj0gdGhpcy5zMTE7XG4gICAgICAgICAgICAgICAgICAgIG5zMTAgXj0gdGhpcy5zMTA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMudW5zYWZlTmV4dCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuczAxID0gbnMwMTtcbiAgICAgICAgdGhpcy5zMDAgPSBuczAwO1xuICAgICAgICB0aGlzLnMxMSA9IG5zMTE7XG4gICAgICAgIHRoaXMuczEwID0gbnMxMDtcbiAgICB9O1xuICAgIHJldHVybiBYb3JTaGlmdDEyOFBsdXM7XG59KCkpO1xudmFyIHhvcnNoaWZ0MTI4cGx1cyA9IGZ1bmN0aW9uIChzZWVkKSB7XG4gICAgcmV0dXJuIG5ldyBYb3JTaGlmdDEyOFBsdXMoLTEsIH5zZWVkLCBzZWVkIHwgMCwgMCk7XG59O1xuZXhwb3J0cy54b3JzaGlmdDEyOHBsdXMgPSB4b3JzaGlmdDEyOHBsdXM7XG4iLCJcInVzZSBzdHJpY3RcIjtcbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5leHBvcnRzLnhvcm9zaGlybzEyOHBsdXMgPSB2b2lkIDA7XG52YXIgWG9yb1NoaXJvMTI4UGx1cyA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gWG9yb1NoaXJvMTI4UGx1cyhzMDEsIHMwMCwgczExLCBzMTApIHtcbiAgICAgICAgdGhpcy5zMDEgPSBzMDE7XG4gICAgICAgIHRoaXMuczAwID0gczAwO1xuICAgICAgICB0aGlzLnMxMSA9IHMxMTtcbiAgICAgICAgdGhpcy5zMTAgPSBzMTA7XG4gICAgfVxuICAgIFhvcm9TaGlybzEyOFBsdXMucHJvdG90eXBlLm1pbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIC0weDgwMDAwMDAwO1xuICAgIH07XG4gICAgWG9yb1NoaXJvMTI4UGx1cy5wcm90b3R5cGUubWF4ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gMHg3ZmZmZmZmZjtcbiAgICB9O1xuICAgIFhvcm9TaGlybzEyOFBsdXMucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gbmV3IFhvcm9TaGlybzEyOFBsdXModGhpcy5zMDEsIHRoaXMuczAwLCB0aGlzLnMxMSwgdGhpcy5zMTApO1xuICAgIH07XG4gICAgWG9yb1NoaXJvMTI4UGx1cy5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG5leHRSbmcgPSBuZXcgWG9yb1NoaXJvMTI4UGx1cyh0aGlzLnMwMSwgdGhpcy5zMDAsIHRoaXMuczExLCB0aGlzLnMxMCk7XG4gICAgICAgIHZhciBvdXQgPSBuZXh0Um5nLnVuc2FmZU5leHQoKTtcbiAgICAgICAgcmV0dXJuIFtvdXQsIG5leHRSbmddO1xuICAgIH07XG4gICAgWG9yb1NoaXJvMTI4UGx1cy5wcm90b3R5cGUudW5zYWZlTmV4dCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG91dCA9ICh0aGlzLnMwMCArIHRoaXMuczEwKSB8IDA7XG4gICAgICAgIHZhciBhMCA9IHRoaXMuczEwIF4gdGhpcy5zMDA7XG4gICAgICAgIHZhciBhMSA9IHRoaXMuczExIF4gdGhpcy5zMDE7XG4gICAgICAgIHZhciBzMDAgPSB0aGlzLnMwMDtcbiAgICAgICAgdmFyIHMwMSA9IHRoaXMuczAxO1xuICAgICAgICB0aGlzLnMwMCA9IChzMDAgPDwgMjQpIF4gKHMwMSA+Pj4gOCkgXiBhMCBeIChhMCA8PCAxNik7XG4gICAgICAgIHRoaXMuczAxID0gKHMwMSA8PCAyNCkgXiAoczAwID4+PiA4KSBeIGExIF4gKChhMSA8PCAxNikgfCAoYTAgPj4+IDE2KSk7XG4gICAgICAgIHRoaXMuczEwID0gKGExIDw8IDUpIF4gKGEwID4+PiAyNyk7XG4gICAgICAgIHRoaXMuczExID0gKGEwIDw8IDUpIF4gKGExID4+PiAyNyk7XG4gICAgICAgIHJldHVybiBvdXQ7XG4gICAgfTtcbiAgICBYb3JvU2hpcm8xMjhQbHVzLnByb3RvdHlwZS5qdW1wID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgbmV4dFJuZyA9IG5ldyBYb3JvU2hpcm8xMjhQbHVzKHRoaXMuczAxLCB0aGlzLnMwMCwgdGhpcy5zMTEsIHRoaXMuczEwKTtcbiAgICAgICAgbmV4dFJuZy51bnNhZmVKdW1wKCk7XG4gICAgICAgIHJldHVybiBuZXh0Um5nO1xuICAgIH07XG4gICAgWG9yb1NoaXJvMTI4UGx1cy5wcm90b3R5cGUudW5zYWZlSnVtcCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG5zMDEgPSAwO1xuICAgICAgICB2YXIgbnMwMCA9IDA7XG4gICAgICAgIHZhciBuczExID0gMDtcbiAgICAgICAgdmFyIG5zMTAgPSAwO1xuICAgICAgICB2YXIganVtcCA9IFsweGQ4ZjU1NGE1LCAweGRmOTAwMjk0LCAweDRiMzIwMWZjLCAweDE3MDg2NWRmXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgIT09IDQ7ICsraSkge1xuICAgICAgICAgICAgZm9yICh2YXIgbWFzayA9IDE7IG1hc2s7IG1hc2sgPDw9IDEpIHtcbiAgICAgICAgICAgICAgICBpZiAoanVtcFtpXSAmIG1hc2spIHtcbiAgICAgICAgICAgICAgICAgICAgbnMwMSBePSB0aGlzLnMwMTtcbiAgICAgICAgICAgICAgICAgICAgbnMwMCBePSB0aGlzLnMwMDtcbiAgICAgICAgICAgICAgICAgICAgbnMxMSBePSB0aGlzLnMxMTtcbiAgICAgICAgICAgICAgICAgICAgbnMxMCBePSB0aGlzLnMxMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy51bnNhZmVOZXh0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zMDEgPSBuczAxO1xuICAgICAgICB0aGlzLnMwMCA9IG5zMDA7XG4gICAgICAgIHRoaXMuczExID0gbnMxMTtcbiAgICAgICAgdGhpcy5zMTAgPSBuczEwO1xuICAgIH07XG4gICAgcmV0dXJuIFhvcm9TaGlybzEyOFBsdXM7XG59KCkpO1xudmFyIHhvcm9zaGlybzEyOHBsdXMgPSBmdW5jdGlvbiAoc2VlZCkge1xuICAgIHJldHVybiBuZXcgWG9yb1NoaXJvMTI4UGx1cygtMSwgfnNlZWQsIHNlZWQgfCAwLCAwKTtcbn07XG5leHBvcnRzLnhvcm9zaGlybzEyOHBsdXMgPSB4b3Jvc2hpcm8xMjhwbHVzO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuZXhwb3J0cy51bnNhZmVVbmlmb3JtSW50RGlzdHJpYnV0aW9uID0gZXhwb3J0cy51bnNhZmVVbmlmb3JtQmlnSW50RGlzdHJpYnV0aW9uID0gZXhwb3J0cy51bnNhZmVVbmlmb3JtQXJyYXlJbnREaXN0cmlidXRpb24gPSBleHBvcnRzLnVuaWZvcm1JbnREaXN0cmlidXRpb24gPSBleHBvcnRzLnVuaWZvcm1CaWdJbnREaXN0cmlidXRpb24gPSBleHBvcnRzLnVuaWZvcm1BcnJheUludERpc3RyaWJ1dGlvbiA9IGV4cG9ydHMueG9yb3NoaXJvMTI4cGx1cyA9IGV4cG9ydHMueG9yc2hpZnQxMjhwbHVzID0gZXhwb3J0cy5tZXJzZW5uZSA9IGV4cG9ydHMuY29uZ3J1ZW50aWFsMzIgPSBleHBvcnRzLmNvbmdydWVudGlhbCA9IGV4cG9ydHMudW5zYWZlU2tpcE4gPSBleHBvcnRzLnVuc2FmZUdlbmVyYXRlTiA9IGV4cG9ydHMuc2tpcE4gPSBleHBvcnRzLmdlbmVyYXRlTiA9IGV4cG9ydHMuX19jb21taXRIYXNoID0gZXhwb3J0cy5fX3ZlcnNpb24gPSBleHBvcnRzLl9fdHlwZSA9IHZvaWQgMDtcbnZhciBSYW5kb21HZW5lcmF0b3JfMSA9IHJlcXVpcmUoXCIuL2dlbmVyYXRvci9SYW5kb21HZW5lcmF0b3JcIik7XG5leHBvcnRzLmdlbmVyYXRlTiA9IFJhbmRvbUdlbmVyYXRvcl8xLmdlbmVyYXRlTjtcbmV4cG9ydHMuc2tpcE4gPSBSYW5kb21HZW5lcmF0b3JfMS5za2lwTjtcbmV4cG9ydHMudW5zYWZlR2VuZXJhdGVOID0gUmFuZG9tR2VuZXJhdG9yXzEudW5zYWZlR2VuZXJhdGVOO1xuZXhwb3J0cy51bnNhZmVTa2lwTiA9IFJhbmRvbUdlbmVyYXRvcl8xLnVuc2FmZVNraXBOO1xudmFyIExpbmVhckNvbmdydWVudGlhbF8xID0gcmVxdWlyZShcIi4vZ2VuZXJhdG9yL0xpbmVhckNvbmdydWVudGlhbFwiKTtcbmV4cG9ydHMuY29uZ3J1ZW50aWFsID0gTGluZWFyQ29uZ3J1ZW50aWFsXzEuY29uZ3J1ZW50aWFsO1xuZXhwb3J0cy5jb25ncnVlbnRpYWwzMiA9IExpbmVhckNvbmdydWVudGlhbF8xLmNvbmdydWVudGlhbDMyO1xudmFyIE1lcnNlbm5lVHdpc3Rlcl8xID0gcmVxdWlyZShcIi4vZ2VuZXJhdG9yL01lcnNlbm5lVHdpc3RlclwiKTtcbmV4cG9ydHMubWVyc2VubmUgPSBNZXJzZW5uZVR3aXN0ZXJfMVtcImRlZmF1bHRcIl07XG52YXIgWG9yU2hpZnRfMSA9IHJlcXVpcmUoXCIuL2dlbmVyYXRvci9Yb3JTaGlmdFwiKTtcbmV4cG9ydHMueG9yc2hpZnQxMjhwbHVzID0gWG9yU2hpZnRfMS54b3JzaGlmdDEyOHBsdXM7XG52YXIgWG9yb1NoaXJvXzEgPSByZXF1aXJlKFwiLi9nZW5lcmF0b3IvWG9yb1NoaXJvXCIpO1xuZXhwb3J0cy54b3Jvc2hpcm8xMjhwbHVzID0gWG9yb1NoaXJvXzEueG9yb3NoaXJvMTI4cGx1cztcbnZhciBVbmlmb3JtQXJyYXlJbnREaXN0cmlidXRpb25fMSA9IHJlcXVpcmUoXCIuL2Rpc3RyaWJ1dGlvbi9Vbmlmb3JtQXJyYXlJbnREaXN0cmlidXRpb25cIik7XG5leHBvcnRzLnVuaWZvcm1BcnJheUludERpc3RyaWJ1dGlvbiA9IFVuaWZvcm1BcnJheUludERpc3RyaWJ1dGlvbl8xLnVuaWZvcm1BcnJheUludERpc3RyaWJ1dGlvbjtcbnZhciBVbmlmb3JtQmlnSW50RGlzdHJpYnV0aW9uXzEgPSByZXF1aXJlKFwiLi9kaXN0cmlidXRpb24vVW5pZm9ybUJpZ0ludERpc3RyaWJ1dGlvblwiKTtcbmV4cG9ydHMudW5pZm9ybUJpZ0ludERpc3RyaWJ1dGlvbiA9IFVuaWZvcm1CaWdJbnREaXN0cmlidXRpb25fMS51bmlmb3JtQmlnSW50RGlzdHJpYnV0aW9uO1xudmFyIFVuaWZvcm1JbnREaXN0cmlidXRpb25fMSA9IHJlcXVpcmUoXCIuL2Rpc3RyaWJ1dGlvbi9Vbmlmb3JtSW50RGlzdHJpYnV0aW9uXCIpO1xuZXhwb3J0cy51bmlmb3JtSW50RGlzdHJpYnV0aW9uID0gVW5pZm9ybUludERpc3RyaWJ1dGlvbl8xLnVuaWZvcm1JbnREaXN0cmlidXRpb247XG52YXIgVW5zYWZlVW5pZm9ybUFycmF5SW50RGlzdHJpYnV0aW9uXzEgPSByZXF1aXJlKFwiLi9kaXN0cmlidXRpb24vVW5zYWZlVW5pZm9ybUFycmF5SW50RGlzdHJpYnV0aW9uXCIpO1xuZXhwb3J0cy51bnNhZmVVbmlmb3JtQXJyYXlJbnREaXN0cmlidXRpb24gPSBVbnNhZmVVbmlmb3JtQXJyYXlJbnREaXN0cmlidXRpb25fMS51bnNhZmVVbmlmb3JtQXJyYXlJbnREaXN0cmlidXRpb247XG52YXIgVW5zYWZlVW5pZm9ybUJpZ0ludERpc3RyaWJ1dGlvbl8xID0gcmVxdWlyZShcIi4vZGlzdHJpYnV0aW9uL1Vuc2FmZVVuaWZvcm1CaWdJbnREaXN0cmlidXRpb25cIik7XG5leHBvcnRzLnVuc2FmZVVuaWZvcm1CaWdJbnREaXN0cmlidXRpb24gPSBVbnNhZmVVbmlmb3JtQmlnSW50RGlzdHJpYnV0aW9uXzEudW5zYWZlVW5pZm9ybUJpZ0ludERpc3RyaWJ1dGlvbjtcbnZhciBVbnNhZmVVbmlmb3JtSW50RGlzdHJpYnV0aW9uXzEgPSByZXF1aXJlKFwiLi9kaXN0cmlidXRpb24vVW5zYWZlVW5pZm9ybUludERpc3RyaWJ1dGlvblwiKTtcbmV4cG9ydHMudW5zYWZlVW5pZm9ybUludERpc3RyaWJ1dGlvbiA9IFVuc2FmZVVuaWZvcm1JbnREaXN0cmlidXRpb25fMS51bnNhZmVVbmlmb3JtSW50RGlzdHJpYnV0aW9uO1xudmFyIF9fdHlwZSA9ICdjb21tb25qcyc7XG5leHBvcnRzLl9fdHlwZSA9IF9fdHlwZTtcbnZhciBfX3ZlcnNpb24gPSAnNS4wLjAnO1xuZXhwb3J0cy5fX3ZlcnNpb24gPSBfX3ZlcnNpb247XG52YXIgX19jb21taXRIYXNoID0gJzc0NDU1NTg1NWEwMWUxNTUxYWIxY2Y2N2E2ZWE5NzNkMTQ5NjQ2NjEnO1xuZXhwb3J0cy5fX2NvbW1pdEhhc2ggPSBfX2NvbW1pdEhhc2g7XG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9KTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19leHBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2V4cG9ydFN0YXIpIHx8IGZ1bmN0aW9uKG0sIGV4cG9ydHMpIHtcbiAgICBmb3IgKHZhciBwIGluIG0pIGlmIChwICE9PSBcImRlZmF1bHRcIiAmJiAhT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGV4cG9ydHMsIHApKSBfX2NyZWF0ZUJpbmRpbmcoZXhwb3J0cywgbSwgcCk7XG59O1xuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbnZhciBwcmFuZCA9IHJlcXVpcmUoXCIuL3B1cmUtcmFuZC1kZWZhdWx0XCIpO1xuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBwcmFuZDtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9wdXJlLXJhbmQtZGVmYXVsdFwiKSwgZXhwb3J0cyk7XG4iLCIvLyBUaGUgbW9kdWxlIGNhY2hlXG52YXIgX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fID0ge307XG5cbi8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG5mdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuXHR2YXIgY2FjaGVkTW9kdWxlID0gX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fW21vZHVsZUlkXTtcblx0aWYgKGNhY2hlZE1vZHVsZSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0cmV0dXJuIGNhY2hlZE1vZHVsZS5leHBvcnRzO1xuXHR9XG5cdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG5cdHZhciBtb2R1bGUgPSBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX19bbW9kdWxlSWRdID0ge1xuXHRcdGlkOiBtb2R1bGVJZCxcblx0XHRsb2FkZWQ6IGZhbHNlLFxuXHRcdGV4cG9ydHM6IHt9XG5cdH07XG5cblx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG5cdF9fd2VicGFja19tb2R1bGVzX19bbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuXG5cdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcblx0bW9kdWxlLmxvYWRlZCA9IHRydWU7XG5cblx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcblx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xufVxuXG4iLCJfX3dlYnBhY2tfcmVxdWlyZV9fLmcgPSAoZnVuY3Rpb24oKSB7XG5cdGlmICh0eXBlb2YgZ2xvYmFsVGhpcyA9PT0gJ29iamVjdCcpIHJldHVybiBnbG9iYWxUaGlzO1xuXHR0cnkge1xuXHRcdHJldHVybiB0aGlzIHx8IG5ldyBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpO1xuXHR9IGNhdGNoIChlKSB7XG5cdFx0aWYgKHR5cGVvZiB3aW5kb3cgPT09ICdvYmplY3QnKSByZXR1cm4gd2luZG93O1xuXHR9XG59KSgpOyIsIi8vIGRlZmluZSBfX2VzTW9kdWxlIG9uIGV4cG9ydHNcbl9fd2VicGFja19yZXF1aXJlX18uciA9IChleHBvcnRzKSA9PiB7XG5cdGlmKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC50b1N0cmluZ1RhZykge1xuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBTeW1ib2wudG9TdHJpbmdUYWcsIHsgdmFsdWU6ICdNb2R1bGUnIH0pO1xuXHR9XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG59OyIsIl9fd2VicGFja19yZXF1aXJlX18ubm1kID0gKG1vZHVsZSkgPT4ge1xuXHRtb2R1bGUucGF0aHMgPSBbXTtcblx0aWYgKCFtb2R1bGUuY2hpbGRyZW4pIG1vZHVsZS5jaGlsZHJlbiA9IFtdO1xuXHRyZXR1cm4gbW9kdWxlO1xufTsiLCJcInVzZSBzdHJpY3RcIjtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5jb25zdCB2aXMgPSByZXF1aXJlKFwibGl0c2NyaXB0L2xpYi92aXN1YWxpemVyXCIpO1xyXG5jb25zdCBsZSA9IHJlcXVpcmUoXCJsaXRzLWV4dHJhc1wiKTtcclxuY29uc3QgcHogPSByZXF1aXJlKFwiLi5cIik7XHJcbmNvbnN0IGVwID0gcmVxdWlyZShcIi4uL3Rlc3QvZXhwcnBhcnNlclwiKTtcclxucmVxdWlyZShcIi4uL3Rlc3QvZXhwcnRlc3RzXCIpO1xyXG5yZXF1aXJlKFwiLi9ydW4tZXhwci10ZXN0cy5sZXNzXCIpO1xyXG52aXMucmVnaXN0ZXJWaXN1YWxpemVyKFwicnVuLWV4cHItdGVzdHNcIiwgbGUucnVuVGVzdHMpO1xyXG52aXMucmVnaXN0ZXJWaXN1YWxpemVyKFwiY2FsY3VsYXRvclwiLCBjYWxjdWxhdG9yKTtcclxuZnVuY3Rpb24gY2FsY3VsYXRvcihwYXJhbXMsIHBhcmVudCkge1xyXG4gICAgcGFyZW50LmNsYXNzTGlzdC5hZGQoXCJjYWxjdWxhdG9yXCIpO1xyXG4gICAgbGV0IHRhID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW5wdXQnKTtcclxuICAgIGxldCByZXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcclxuICAgIHJlcy5jbGFzc0xpc3QuYWRkKFwicmVzdWx0XCIpO1xyXG4gICAgcGFyZW50LmFwcGVuZCh0YSwgcmVzKTtcclxuICAgIHRhLmFkZEV2ZW50TGlzdGVuZXIoXCJjaGFuZ2VcIiwgXyA9PiB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgcmVzLmlubmVyVGV4dCA9IGVwLmV2YWx1YXRlRXhwcmVzc2lvbih0YS52YWx1ZSkudG9TdHJpbmcoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgaWYgKGUgaW5zdGFuY2VvZiBwei5QYXJzZUVycm9yKVxyXG4gICAgICAgICAgICAgICAgcmVzLmlubmVyVGV4dCA9IGUubWVzc2FnZTtcclxuICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgdGhyb3cgZTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxufVxyXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=