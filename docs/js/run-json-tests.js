/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/dagre/index.js":
/*!*************************************!*\
  !*** ./node_modules/dagre/index.js ***!
  \*************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/*
Copyright (c) 2012-2014 Chris Pettitt

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
*/

module.exports = {
  graphlib: __webpack_require__(/*! ./lib/graphlib */ "./node_modules/dagre/lib/graphlib.js"),

  layout: __webpack_require__(/*! ./lib/layout */ "./node_modules/dagre/lib/layout.js"),
  debug: __webpack_require__(/*! ./lib/debug */ "./node_modules/dagre/lib/debug.js"),
  util: {
    time: __webpack_require__(/*! ./lib/util */ "./node_modules/dagre/lib/util.js").time,
    notime: __webpack_require__(/*! ./lib/util */ "./node_modules/dagre/lib/util.js").notime
  },
  version: __webpack_require__(/*! ./lib/version */ "./node_modules/dagre/lib/version.js")
};


/***/ }),

/***/ "./node_modules/dagre/lib/acyclic.js":
/*!*******************************************!*\
  !*** ./node_modules/dagre/lib/acyclic.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var _ = __webpack_require__(/*! ./lodash */ "./node_modules/dagre/lib/lodash.js");
var greedyFAS = __webpack_require__(/*! ./greedy-fas */ "./node_modules/dagre/lib/greedy-fas.js");

module.exports = {
  run: run,
  undo: undo
};

function run(g) {
  var fas = (g.graph().acyclicer === "greedy"
    ? greedyFAS(g, weightFn(g))
    : dfsFAS(g));
  _.forEach(fas, function(e) {
    var label = g.edge(e);
    g.removeEdge(e);
    label.forwardName = e.name;
    label.reversed = true;
    g.setEdge(e.w, e.v, label, _.uniqueId("rev"));
  });

  function weightFn(g) {
    return function(e) {
      return g.edge(e).weight;
    };
  }
}

function dfsFAS(g) {
  var fas = [];
  var stack = {};
  var visited = {};

  function dfs(v) {
    if (_.has(visited, v)) {
      return;
    }
    visited[v] = true;
    stack[v] = true;
    _.forEach(g.outEdges(v), function(e) {
      if (_.has(stack, e.w)) {
        fas.push(e);
      } else {
        dfs(e.w);
      }
    });
    delete stack[v];
  }

  _.forEach(g.nodes(), dfs);
  return fas;
}

function undo(g) {
  _.forEach(g.edges(), function(e) {
    var label = g.edge(e);
    if (label.reversed) {
      g.removeEdge(e);

      var forwardName = label.forwardName;
      delete label.reversed;
      delete label.forwardName;
      g.setEdge(e.w, e.v, label, forwardName);
    }
  });
}


/***/ }),

/***/ "./node_modules/dagre/lib/add-border-segments.js":
/*!*******************************************************!*\
  !*** ./node_modules/dagre/lib/add-border-segments.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var _ = __webpack_require__(/*! ./lodash */ "./node_modules/dagre/lib/lodash.js");
var util = __webpack_require__(/*! ./util */ "./node_modules/dagre/lib/util.js");

module.exports = addBorderSegments;

function addBorderSegments(g) {
  function dfs(v) {
    var children = g.children(v);
    var node = g.node(v);
    if (children.length) {
      _.forEach(children, dfs);
    }

    if (_.has(node, "minRank")) {
      node.borderLeft = [];
      node.borderRight = [];
      for (var rank = node.minRank, maxRank = node.maxRank + 1;
        rank < maxRank;
        ++rank) {
        addBorderNode(g, "borderLeft", "_bl", v, node, rank);
        addBorderNode(g, "borderRight", "_br", v, node, rank);
      }
    }
  }

  _.forEach(g.children(), dfs);
}

function addBorderNode(g, prop, prefix, sg, sgNode, rank) {
  var label = { width: 0, height: 0, rank: rank, borderType: prop };
  var prev = sgNode[prop][rank - 1];
  var curr = util.addDummyNode(g, "border", label, prefix);
  sgNode[prop][rank] = curr;
  g.setParent(curr, sg);
  if (prev) {
    g.setEdge(prev, curr, { weight: 1 });
  }
}


/***/ }),

/***/ "./node_modules/dagre/lib/coordinate-system.js":
/*!*****************************************************!*\
  !*** ./node_modules/dagre/lib/coordinate-system.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var _ = __webpack_require__(/*! ./lodash */ "./node_modules/dagre/lib/lodash.js");

module.exports = {
  adjust: adjust,
  undo: undo
};

function adjust(g) {
  var rankDir = g.graph().rankdir.toLowerCase();
  if (rankDir === "lr" || rankDir === "rl") {
    swapWidthHeight(g);
  }
}

function undo(g) {
  var rankDir = g.graph().rankdir.toLowerCase();
  if (rankDir === "bt" || rankDir === "rl") {
    reverseY(g);
  }

  if (rankDir === "lr" || rankDir === "rl") {
    swapXY(g);
    swapWidthHeight(g);
  }
}

function swapWidthHeight(g) {
  _.forEach(g.nodes(), function(v) { swapWidthHeightOne(g.node(v)); });
  _.forEach(g.edges(), function(e) { swapWidthHeightOne(g.edge(e)); });
}

function swapWidthHeightOne(attrs) {
  var w = attrs.width;
  attrs.width = attrs.height;
  attrs.height = w;
}

function reverseY(g) {
  _.forEach(g.nodes(), function(v) { reverseYOne(g.node(v)); });

  _.forEach(g.edges(), function(e) {
    var edge = g.edge(e);
    _.forEach(edge.points, reverseYOne);
    if (_.has(edge, "y")) {
      reverseYOne(edge);
    }
  });
}

function reverseYOne(attrs) {
  attrs.y = -attrs.y;
}

function swapXY(g) {
  _.forEach(g.nodes(), function(v) { swapXYOne(g.node(v)); });

  _.forEach(g.edges(), function(e) {
    var edge = g.edge(e);
    _.forEach(edge.points, swapXYOne);
    if (_.has(edge, "x")) {
      swapXYOne(edge);
    }
  });
}

function swapXYOne(attrs) {
  var x = attrs.x;
  attrs.x = attrs.y;
  attrs.y = x;
}


/***/ }),

/***/ "./node_modules/dagre/lib/data/list.js":
/*!*********************************************!*\
  !*** ./node_modules/dagre/lib/data/list.js ***!
  \*********************************************/
/***/ ((module) => {

/*
 * Simple doubly linked list implementation derived from Cormen, et al.,
 * "Introduction to Algorithms".
 */

module.exports = List;

function List() {
  var sentinel = {};
  sentinel._next = sentinel._prev = sentinel;
  this._sentinel = sentinel;
}

List.prototype.dequeue = function() {
  var sentinel = this._sentinel;
  var entry = sentinel._prev;
  if (entry !== sentinel) {
    unlink(entry);
    return entry;
  }
};

List.prototype.enqueue = function(entry) {
  var sentinel = this._sentinel;
  if (entry._prev && entry._next) {
    unlink(entry);
  }
  entry._next = sentinel._next;
  sentinel._next._prev = entry;
  sentinel._next = entry;
  entry._prev = sentinel;
};

List.prototype.toString = function() {
  var strs = [];
  var sentinel = this._sentinel;
  var curr = sentinel._prev;
  while (curr !== sentinel) {
    strs.push(JSON.stringify(curr, filterOutLinks));
    curr = curr._prev;
  }
  return "[" + strs.join(", ") + "]";
};

function unlink(entry) {
  entry._prev._next = entry._next;
  entry._next._prev = entry._prev;
  delete entry._next;
  delete entry._prev;
}

function filterOutLinks(k, v) {
  if (k !== "_next" && k !== "_prev") {
    return v;
  }
}


/***/ }),

/***/ "./node_modules/dagre/lib/debug.js":
/*!*****************************************!*\
  !*** ./node_modules/dagre/lib/debug.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var _ = __webpack_require__(/*! ./lodash */ "./node_modules/dagre/lib/lodash.js");
var util = __webpack_require__(/*! ./util */ "./node_modules/dagre/lib/util.js");
var Graph = __webpack_require__(/*! ./graphlib */ "./node_modules/dagre/lib/graphlib.js").Graph;

module.exports = {
  debugOrdering: debugOrdering
};

/* istanbul ignore next */
function debugOrdering(g) {
  var layerMatrix = util.buildLayerMatrix(g);

  var h = new Graph({ compound: true, multigraph: true }).setGraph({});

  _.forEach(g.nodes(), function(v) {
    h.setNode(v, { label: v });
    h.setParent(v, "layer" + g.node(v).rank);
  });

  _.forEach(g.edges(), function(e) {
    h.setEdge(e.v, e.w, {}, e.name);
  });

  _.forEach(layerMatrix, function(layer, i) {
    var layerV = "layer" + i;
    h.setNode(layerV, { rank: "same" });
    _.reduce(layer, function(u, v) {
      h.setEdge(u, v, { style: "invis" });
      return v;
    });
  });

  return h;
}


/***/ }),

/***/ "./node_modules/dagre/lib/graphlib.js":
/*!********************************************!*\
  !*** ./node_modules/dagre/lib/graphlib.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/* global window */

var graphlib;

if (true) {
  try {
    graphlib = __webpack_require__(/*! graphlib */ "./node_modules/graphlib/index.js");
  } catch (e) {
    // continue regardless of error
  }
}

if (!graphlib) {
  graphlib = window.graphlib;
}

module.exports = graphlib;


/***/ }),

/***/ "./node_modules/dagre/lib/greedy-fas.js":
/*!**********************************************!*\
  !*** ./node_modules/dagre/lib/greedy-fas.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var _ = __webpack_require__(/*! ./lodash */ "./node_modules/dagre/lib/lodash.js");
var Graph = __webpack_require__(/*! ./graphlib */ "./node_modules/dagre/lib/graphlib.js").Graph;
var List = __webpack_require__(/*! ./data/list */ "./node_modules/dagre/lib/data/list.js");

/*
 * A greedy heuristic for finding a feedback arc set for a graph. A feedback
 * arc set is a set of edges that can be removed to make a graph acyclic.
 * The algorithm comes from: P. Eades, X. Lin, and W. F. Smyth, "A fast and
 * effective heuristic for the feedback arc set problem." This implementation
 * adjusts that from the paper to allow for weighted edges.
 */
module.exports = greedyFAS;

var DEFAULT_WEIGHT_FN = _.constant(1);

function greedyFAS(g, weightFn) {
  if (g.nodeCount() <= 1) {
    return [];
  }
  var state = buildState(g, weightFn || DEFAULT_WEIGHT_FN);
  var results = doGreedyFAS(state.graph, state.buckets, state.zeroIdx);

  // Expand multi-edges
  return _.flatten(_.map(results, function(e) {
    return g.outEdges(e.v, e.w);
  }), true);
}

function doGreedyFAS(g, buckets, zeroIdx) {
  var results = [];
  var sources = buckets[buckets.length - 1];
  var sinks = buckets[0];

  var entry;
  while (g.nodeCount()) {
    while ((entry = sinks.dequeue()))   { removeNode(g, buckets, zeroIdx, entry); }
    while ((entry = sources.dequeue())) { removeNode(g, buckets, zeroIdx, entry); }
    if (g.nodeCount()) {
      for (var i = buckets.length - 2; i > 0; --i) {
        entry = buckets[i].dequeue();
        if (entry) {
          results = results.concat(removeNode(g, buckets, zeroIdx, entry, true));
          break;
        }
      }
    }
  }

  return results;
}

function removeNode(g, buckets, zeroIdx, entry, collectPredecessors) {
  var results = collectPredecessors ? [] : undefined;

  _.forEach(g.inEdges(entry.v), function(edge) {
    var weight = g.edge(edge);
    var uEntry = g.node(edge.v);

    if (collectPredecessors) {
      results.push({ v: edge.v, w: edge.w });
    }

    uEntry.out -= weight;
    assignBucket(buckets, zeroIdx, uEntry);
  });

  _.forEach(g.outEdges(entry.v), function(edge) {
    var weight = g.edge(edge);
    var w = edge.w;
    var wEntry = g.node(w);
    wEntry["in"] -= weight;
    assignBucket(buckets, zeroIdx, wEntry);
  });

  g.removeNode(entry.v);

  return results;
}

function buildState(g, weightFn) {
  var fasGraph = new Graph();
  var maxIn = 0;
  var maxOut = 0;

  _.forEach(g.nodes(), function(v) {
    fasGraph.setNode(v, { v: v, "in": 0, out: 0 });
  });

  // Aggregate weights on nodes, but also sum the weights across multi-edges
  // into a single edge for the fasGraph.
  _.forEach(g.edges(), function(e) {
    var prevWeight = fasGraph.edge(e.v, e.w) || 0;
    var weight = weightFn(e);
    var edgeWeight = prevWeight + weight;
    fasGraph.setEdge(e.v, e.w, edgeWeight);
    maxOut = Math.max(maxOut, fasGraph.node(e.v).out += weight);
    maxIn  = Math.max(maxIn,  fasGraph.node(e.w)["in"]  += weight);
  });

  var buckets = _.range(maxOut + maxIn + 3).map(function() { return new List(); });
  var zeroIdx = maxIn + 1;

  _.forEach(fasGraph.nodes(), function(v) {
    assignBucket(buckets, zeroIdx, fasGraph.node(v));
  });

  return { graph: fasGraph, buckets: buckets, zeroIdx: zeroIdx };
}

function assignBucket(buckets, zeroIdx, entry) {
  if (!entry.out) {
    buckets[0].enqueue(entry);
  } else if (!entry["in"]) {
    buckets[buckets.length - 1].enqueue(entry);
  } else {
    buckets[entry.out - entry["in"] + zeroIdx].enqueue(entry);
  }
}


/***/ }),

/***/ "./node_modules/dagre/lib/layout.js":
/*!******************************************!*\
  !*** ./node_modules/dagre/lib/layout.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var _ = __webpack_require__(/*! ./lodash */ "./node_modules/dagre/lib/lodash.js");
var acyclic = __webpack_require__(/*! ./acyclic */ "./node_modules/dagre/lib/acyclic.js");
var normalize = __webpack_require__(/*! ./normalize */ "./node_modules/dagre/lib/normalize.js");
var rank = __webpack_require__(/*! ./rank */ "./node_modules/dagre/lib/rank/index.js");
var normalizeRanks = __webpack_require__(/*! ./util */ "./node_modules/dagre/lib/util.js").normalizeRanks;
var parentDummyChains = __webpack_require__(/*! ./parent-dummy-chains */ "./node_modules/dagre/lib/parent-dummy-chains.js");
var removeEmptyRanks = __webpack_require__(/*! ./util */ "./node_modules/dagre/lib/util.js").removeEmptyRanks;
var nestingGraph = __webpack_require__(/*! ./nesting-graph */ "./node_modules/dagre/lib/nesting-graph.js");
var addBorderSegments = __webpack_require__(/*! ./add-border-segments */ "./node_modules/dagre/lib/add-border-segments.js");
var coordinateSystem = __webpack_require__(/*! ./coordinate-system */ "./node_modules/dagre/lib/coordinate-system.js");
var order = __webpack_require__(/*! ./order */ "./node_modules/dagre/lib/order/index.js");
var position = __webpack_require__(/*! ./position */ "./node_modules/dagre/lib/position/index.js");
var util = __webpack_require__(/*! ./util */ "./node_modules/dagre/lib/util.js");
var Graph = __webpack_require__(/*! ./graphlib */ "./node_modules/dagre/lib/graphlib.js").Graph;

module.exports = layout;

function layout(g, opts) {
  var time = opts && opts.debugTiming ? util.time : util.notime;
  time("layout", function() {
    var layoutGraph = 
      time("  buildLayoutGraph", function() { return buildLayoutGraph(g); });
    time("  runLayout",        function() { runLayout(layoutGraph, time); });
    time("  updateInputGraph", function() { updateInputGraph(g, layoutGraph); });
  });
}

function runLayout(g, time) {
  time("    makeSpaceForEdgeLabels", function() { makeSpaceForEdgeLabels(g); });
  time("    removeSelfEdges",        function() { removeSelfEdges(g); });
  time("    acyclic",                function() { acyclic.run(g); });
  time("    nestingGraph.run",       function() { nestingGraph.run(g); });
  time("    rank",                   function() { rank(util.asNonCompoundGraph(g)); });
  time("    injectEdgeLabelProxies", function() { injectEdgeLabelProxies(g); });
  time("    removeEmptyRanks",       function() { removeEmptyRanks(g); });
  time("    nestingGraph.cleanup",   function() { nestingGraph.cleanup(g); });
  time("    normalizeRanks",         function() { normalizeRanks(g); });
  time("    assignRankMinMax",       function() { assignRankMinMax(g); });
  time("    removeEdgeLabelProxies", function() { removeEdgeLabelProxies(g); });
  time("    normalize.run",          function() { normalize.run(g); });
  time("    parentDummyChains",      function() { parentDummyChains(g); });
  time("    addBorderSegments",      function() { addBorderSegments(g); });
  time("    order",                  function() { order(g); });
  time("    insertSelfEdges",        function() { insertSelfEdges(g); });
  time("    adjustCoordinateSystem", function() { coordinateSystem.adjust(g); });
  time("    position",               function() { position(g); });
  time("    positionSelfEdges",      function() { positionSelfEdges(g); });
  time("    removeBorderNodes",      function() { removeBorderNodes(g); });
  time("    normalize.undo",         function() { normalize.undo(g); });
  time("    fixupEdgeLabelCoords",   function() { fixupEdgeLabelCoords(g); });
  time("    undoCoordinateSystem",   function() { coordinateSystem.undo(g); });
  time("    translateGraph",         function() { translateGraph(g); });
  time("    assignNodeIntersects",   function() { assignNodeIntersects(g); });
  time("    reversePoints",          function() { reversePointsForReversedEdges(g); });
  time("    acyclic.undo",           function() { acyclic.undo(g); });
}

/*
 * Copies final layout information from the layout graph back to the input
 * graph. This process only copies whitelisted attributes from the layout graph
 * to the input graph, so it serves as a good place to determine what
 * attributes can influence layout.
 */
function updateInputGraph(inputGraph, layoutGraph) {
  _.forEach(inputGraph.nodes(), function(v) {
    var inputLabel = inputGraph.node(v);
    var layoutLabel = layoutGraph.node(v);

    if (inputLabel) {
      inputLabel.x = layoutLabel.x;
      inputLabel.y = layoutLabel.y;

      if (layoutGraph.children(v).length) {
        inputLabel.width = layoutLabel.width;
        inputLabel.height = layoutLabel.height;
      }
    }
  });

  _.forEach(inputGraph.edges(), function(e) {
    var inputLabel = inputGraph.edge(e);
    var layoutLabel = layoutGraph.edge(e);

    inputLabel.points = layoutLabel.points;
    if (_.has(layoutLabel, "x")) {
      inputLabel.x = layoutLabel.x;
      inputLabel.y = layoutLabel.y;
    }
  });

  inputGraph.graph().width = layoutGraph.graph().width;
  inputGraph.graph().height = layoutGraph.graph().height;
}

var graphNumAttrs = ["nodesep", "edgesep", "ranksep", "marginx", "marginy"];
var graphDefaults = { ranksep: 50, edgesep: 20, nodesep: 50, rankdir: "tb" };
var graphAttrs = ["acyclicer", "ranker", "rankdir", "align"];
var nodeNumAttrs = ["width", "height"];
var nodeDefaults = { width: 0, height: 0 };
var edgeNumAttrs = ["minlen", "weight", "width", "height", "labeloffset"];
var edgeDefaults = {
  minlen: 1, weight: 1, width: 0, height: 0,
  labeloffset: 10, labelpos: "r"
};
var edgeAttrs = ["labelpos"];

/*
 * Constructs a new graph from the input graph, which can be used for layout.
 * This process copies only whitelisted attributes from the input graph to the
 * layout graph. Thus this function serves as a good place to determine what
 * attributes can influence layout.
 */
function buildLayoutGraph(inputGraph) {
  var g = new Graph({ multigraph: true, compound: true });
  var graph = canonicalize(inputGraph.graph());

  g.setGraph(_.merge({},
    graphDefaults,
    selectNumberAttrs(graph, graphNumAttrs),
    _.pick(graph, graphAttrs)));

  _.forEach(inputGraph.nodes(), function(v) {
    var node = canonicalize(inputGraph.node(v));
    g.setNode(v, _.defaults(selectNumberAttrs(node, nodeNumAttrs), nodeDefaults));
    g.setParent(v, inputGraph.parent(v));
  });

  _.forEach(inputGraph.edges(), function(e) {
    var edge = canonicalize(inputGraph.edge(e));
    g.setEdge(e, _.merge({},
      edgeDefaults,
      selectNumberAttrs(edge, edgeNumAttrs),
      _.pick(edge, edgeAttrs)));
  });

  return g;
}

/*
 * This idea comes from the Gansner paper: to account for edge labels in our
 * layout we split each rank in half by doubling minlen and halving ranksep.
 * Then we can place labels at these mid-points between nodes.
 *
 * We also add some minimal padding to the width to push the label for the edge
 * away from the edge itself a bit.
 */
function makeSpaceForEdgeLabels(g) {
  var graph = g.graph();
  graph.ranksep /= 2;
  _.forEach(g.edges(), function(e) {
    var edge = g.edge(e);
    edge.minlen *= 2;
    if (edge.labelpos.toLowerCase() !== "c") {
      if (graph.rankdir === "TB" || graph.rankdir === "BT") {
        edge.width += edge.labeloffset;
      } else {
        edge.height += edge.labeloffset;
      }
    }
  });
}

/*
 * Creates temporary dummy nodes that capture the rank in which each edge's
 * label is going to, if it has one of non-zero width and height. We do this
 * so that we can safely remove empty ranks while preserving balance for the
 * label's position.
 */
function injectEdgeLabelProxies(g) {
  _.forEach(g.edges(), function(e) {
    var edge = g.edge(e);
    if (edge.width && edge.height) {
      var v = g.node(e.v);
      var w = g.node(e.w);
      var label = { rank: (w.rank - v.rank) / 2 + v.rank, e: e };
      util.addDummyNode(g, "edge-proxy", label, "_ep");
    }
  });
}

function assignRankMinMax(g) {
  var maxRank = 0;
  _.forEach(g.nodes(), function(v) {
    var node = g.node(v);
    if (node.borderTop) {
      node.minRank = g.node(node.borderTop).rank;
      node.maxRank = g.node(node.borderBottom).rank;
      maxRank = _.max(maxRank, node.maxRank);
    }
  });
  g.graph().maxRank = maxRank;
}

function removeEdgeLabelProxies(g) {
  _.forEach(g.nodes(), function(v) {
    var node = g.node(v);
    if (node.dummy === "edge-proxy") {
      g.edge(node.e).labelRank = node.rank;
      g.removeNode(v);
    }
  });
}

function translateGraph(g) {
  var minX = Number.POSITIVE_INFINITY;
  var maxX = 0;
  var minY = Number.POSITIVE_INFINITY;
  var maxY = 0;
  var graphLabel = g.graph();
  var marginX = graphLabel.marginx || 0;
  var marginY = graphLabel.marginy || 0;

  function getExtremes(attrs) {
    var x = attrs.x;
    var y = attrs.y;
    var w = attrs.width;
    var h = attrs.height;
    minX = Math.min(minX, x - w / 2);
    maxX = Math.max(maxX, x + w / 2);
    minY = Math.min(minY, y - h / 2);
    maxY = Math.max(maxY, y + h / 2);
  }

  _.forEach(g.nodes(), function(v) { getExtremes(g.node(v)); });
  _.forEach(g.edges(), function(e) {
    var edge = g.edge(e);
    if (_.has(edge, "x")) {
      getExtremes(edge);
    }
  });

  minX -= marginX;
  minY -= marginY;

  _.forEach(g.nodes(), function(v) {
    var node = g.node(v);
    node.x -= minX;
    node.y -= minY;
  });

  _.forEach(g.edges(), function(e) {
    var edge = g.edge(e);
    _.forEach(edge.points, function(p) {
      p.x -= minX;
      p.y -= minY;
    });
    if (_.has(edge, "x")) { edge.x -= minX; }
    if (_.has(edge, "y")) { edge.y -= minY; }
  });

  graphLabel.width = maxX - minX + marginX;
  graphLabel.height = maxY - minY + marginY;
}

function assignNodeIntersects(g) {
  _.forEach(g.edges(), function(e) {
    var edge = g.edge(e);
    var nodeV = g.node(e.v);
    var nodeW = g.node(e.w);
    var p1, p2;
    if (!edge.points) {
      edge.points = [];
      p1 = nodeW;
      p2 = nodeV;
    } else {
      p1 = edge.points[0];
      p2 = edge.points[edge.points.length - 1];
    }
    edge.points.unshift(util.intersectRect(nodeV, p1));
    edge.points.push(util.intersectRect(nodeW, p2));
  });
}

function fixupEdgeLabelCoords(g) {
  _.forEach(g.edges(), function(e) {
    var edge = g.edge(e);
    if (_.has(edge, "x")) {
      if (edge.labelpos === "l" || edge.labelpos === "r") {
        edge.width -= edge.labeloffset;
      }
      switch (edge.labelpos) {
      case "l": edge.x -= edge.width / 2 + edge.labeloffset; break;
      case "r": edge.x += edge.width / 2 + edge.labeloffset; break;
      }
    }
  });
}

function reversePointsForReversedEdges(g) {
  _.forEach(g.edges(), function(e) {
    var edge = g.edge(e);
    if (edge.reversed) {
      edge.points.reverse();
    }
  });
}

function removeBorderNodes(g) {
  _.forEach(g.nodes(), function(v) {
    if (g.children(v).length) {
      var node = g.node(v);
      var t = g.node(node.borderTop);
      var b = g.node(node.borderBottom);
      var l = g.node(_.last(node.borderLeft));
      var r = g.node(_.last(node.borderRight));

      node.width = Math.abs(r.x - l.x);
      node.height = Math.abs(b.y - t.y);
      node.x = l.x + node.width / 2;
      node.y = t.y + node.height / 2;
    }
  });

  _.forEach(g.nodes(), function(v) {
    if (g.node(v).dummy === "border") {
      g.removeNode(v);
    }
  });
}

function removeSelfEdges(g) {
  _.forEach(g.edges(), function(e) {
    if (e.v === e.w) {
      var node = g.node(e.v);
      if (!node.selfEdges) {
        node.selfEdges = [];
      }
      node.selfEdges.push({ e: e, label: g.edge(e) });
      g.removeEdge(e);
    }
  });
}

function insertSelfEdges(g) {
  var layers = util.buildLayerMatrix(g);
  _.forEach(layers, function(layer) {
    var orderShift = 0;
    _.forEach(layer, function(v, i) {
      var node = g.node(v);
      node.order = i + orderShift;
      _.forEach(node.selfEdges, function(selfEdge) {
        util.addDummyNode(g, "selfedge", {
          width: selfEdge.label.width,
          height: selfEdge.label.height,
          rank: node.rank,
          order: i + (++orderShift),
          e: selfEdge.e,
          label: selfEdge.label
        }, "_se");
      });
      delete node.selfEdges;
    });
  });
}

function positionSelfEdges(g) {
  _.forEach(g.nodes(), function(v) {
    var node = g.node(v);
    if (node.dummy === "selfedge") {
      var selfNode = g.node(node.e.v);
      var x = selfNode.x + selfNode.width / 2;
      var y = selfNode.y;
      var dx = node.x - x;
      var dy = selfNode.height / 2;
      g.setEdge(node.e, node.label);
      g.removeNode(v);
      node.label.points = [
        { x: x + 2 * dx / 3, y: y - dy },
        { x: x + 5 * dx / 6, y: y - dy },
        { x: x +     dx    , y: y },
        { x: x + 5 * dx / 6, y: y + dy },
        { x: x + 2 * dx / 3, y: y + dy }
      ];
      node.label.x = node.x;
      node.label.y = node.y;
    }
  });
}

function selectNumberAttrs(obj, attrs) {
  return _.mapValues(_.pick(obj, attrs), Number);
}

function canonicalize(attrs) {
  var newAttrs = {};
  _.forEach(attrs, function(v, k) {
    newAttrs[k.toLowerCase()] = v;
  });
  return newAttrs;
}


/***/ }),

/***/ "./node_modules/dagre/lib/lodash.js":
/*!******************************************!*\
  !*** ./node_modules/dagre/lib/lodash.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/* global window */

var lodash;

if (true) {
  try {
    lodash = {
      cloneDeep: __webpack_require__(/*! lodash/cloneDeep */ "./node_modules/lodash/cloneDeep.js"),
      constant: __webpack_require__(/*! lodash/constant */ "./node_modules/lodash/constant.js"),
      defaults: __webpack_require__(/*! lodash/defaults */ "./node_modules/lodash/defaults.js"),
      each: __webpack_require__(/*! lodash/each */ "./node_modules/lodash/each.js"),
      filter: __webpack_require__(/*! lodash/filter */ "./node_modules/lodash/filter.js"),
      find: __webpack_require__(/*! lodash/find */ "./node_modules/lodash/find.js"),
      flatten: __webpack_require__(/*! lodash/flatten */ "./node_modules/lodash/flatten.js"),
      forEach: __webpack_require__(/*! lodash/forEach */ "./node_modules/lodash/forEach.js"),
      forIn: __webpack_require__(/*! lodash/forIn */ "./node_modules/lodash/forIn.js"),
      has:  __webpack_require__(/*! lodash/has */ "./node_modules/lodash/has.js"),
      isUndefined: __webpack_require__(/*! lodash/isUndefined */ "./node_modules/lodash/isUndefined.js"),
      last: __webpack_require__(/*! lodash/last */ "./node_modules/lodash/last.js"),
      map: __webpack_require__(/*! lodash/map */ "./node_modules/lodash/map.js"),
      mapValues: __webpack_require__(/*! lodash/mapValues */ "./node_modules/lodash/mapValues.js"),
      max: __webpack_require__(/*! lodash/max */ "./node_modules/lodash/max.js"),
      merge: __webpack_require__(/*! lodash/merge */ "./node_modules/lodash/merge.js"),
      min: __webpack_require__(/*! lodash/min */ "./node_modules/lodash/min.js"),
      minBy: __webpack_require__(/*! lodash/minBy */ "./node_modules/lodash/minBy.js"),
      now: __webpack_require__(/*! lodash/now */ "./node_modules/lodash/now.js"),
      pick: __webpack_require__(/*! lodash/pick */ "./node_modules/lodash/pick.js"),
      range: __webpack_require__(/*! lodash/range */ "./node_modules/lodash/range.js"),
      reduce: __webpack_require__(/*! lodash/reduce */ "./node_modules/lodash/reduce.js"),
      sortBy: __webpack_require__(/*! lodash/sortBy */ "./node_modules/lodash/sortBy.js"),
      uniqueId: __webpack_require__(/*! lodash/uniqueId */ "./node_modules/lodash/uniqueId.js"),
      values: __webpack_require__(/*! lodash/values */ "./node_modules/lodash/values.js"),
      zipObject: __webpack_require__(/*! lodash/zipObject */ "./node_modules/lodash/zipObject.js"),
    };
  } catch (e) {
    // continue regardless of error
  }
}

if (!lodash) {
  lodash = window._;
}

module.exports = lodash;


/***/ }),

/***/ "./node_modules/dagre/lib/nesting-graph.js":
/*!*************************************************!*\
  !*** ./node_modules/dagre/lib/nesting-graph.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var _ = __webpack_require__(/*! ./lodash */ "./node_modules/dagre/lib/lodash.js");
var util = __webpack_require__(/*! ./util */ "./node_modules/dagre/lib/util.js");

module.exports = {
  run: run,
  cleanup: cleanup
};

/*
 * A nesting graph creates dummy nodes for the tops and bottoms of subgraphs,
 * adds appropriate edges to ensure that all cluster nodes are placed between
 * these boundries, and ensures that the graph is connected.
 *
 * In addition we ensure, through the use of the minlen property, that nodes
 * and subgraph border nodes to not end up on the same rank.
 *
 * Preconditions:
 *
 *    1. Input graph is a DAG
 *    2. Nodes in the input graph has a minlen attribute
 *
 * Postconditions:
 *
 *    1. Input graph is connected.
 *    2. Dummy nodes are added for the tops and bottoms of subgraphs.
 *    3. The minlen attribute for nodes is adjusted to ensure nodes do not
 *       get placed on the same rank as subgraph border nodes.
 *
 * The nesting graph idea comes from Sander, "Layout of Compound Directed
 * Graphs."
 */
function run(g) {
  var root = util.addDummyNode(g, "root", {}, "_root");
  var depths = treeDepths(g);
  var height = _.max(_.values(depths)) - 1; // Note: depths is an Object not an array
  var nodeSep = 2 * height + 1;

  g.graph().nestingRoot = root;

  // Multiply minlen by nodeSep to align nodes on non-border ranks.
  _.forEach(g.edges(), function(e) { g.edge(e).minlen *= nodeSep; });

  // Calculate a weight that is sufficient to keep subgraphs vertically compact
  var weight = sumWeights(g) + 1;

  // Create border nodes and link them up
  _.forEach(g.children(), function(child) {
    dfs(g, root, nodeSep, weight, height, depths, child);
  });

  // Save the multiplier for node layers for later removal of empty border
  // layers.
  g.graph().nodeRankFactor = nodeSep;
}

function dfs(g, root, nodeSep, weight, height, depths, v) {
  var children = g.children(v);
  if (!children.length) {
    if (v !== root) {
      g.setEdge(root, v, { weight: 0, minlen: nodeSep });
    }
    return;
  }

  var top = util.addBorderNode(g, "_bt");
  var bottom = util.addBorderNode(g, "_bb");
  var label = g.node(v);

  g.setParent(top, v);
  label.borderTop = top;
  g.setParent(bottom, v);
  label.borderBottom = bottom;

  _.forEach(children, function(child) {
    dfs(g, root, nodeSep, weight, height, depths, child);

    var childNode = g.node(child);
    var childTop = childNode.borderTop ? childNode.borderTop : child;
    var childBottom = childNode.borderBottom ? childNode.borderBottom : child;
    var thisWeight = childNode.borderTop ? weight : 2 * weight;
    var minlen = childTop !== childBottom ? 1 : height - depths[v] + 1;

    g.setEdge(top, childTop, {
      weight: thisWeight,
      minlen: minlen,
      nestingEdge: true
    });

    g.setEdge(childBottom, bottom, {
      weight: thisWeight,
      minlen: minlen,
      nestingEdge: true
    });
  });

  if (!g.parent(v)) {
    g.setEdge(root, top, { weight: 0, minlen: height + depths[v] });
  }
}

function treeDepths(g) {
  var depths = {};
  function dfs(v, depth) {
    var children = g.children(v);
    if (children && children.length) {
      _.forEach(children, function(child) {
        dfs(child, depth + 1);
      });
    }
    depths[v] = depth;
  }
  _.forEach(g.children(), function(v) { dfs(v, 1); });
  return depths;
}

function sumWeights(g) {
  return _.reduce(g.edges(), function(acc, e) {
    return acc + g.edge(e).weight;
  }, 0);
}

function cleanup(g) {
  var graphLabel = g.graph();
  g.removeNode(graphLabel.nestingRoot);
  delete graphLabel.nestingRoot;
  _.forEach(g.edges(), function(e) {
    var edge = g.edge(e);
    if (edge.nestingEdge) {
      g.removeEdge(e);
    }
  });
}


/***/ }),

/***/ "./node_modules/dagre/lib/normalize.js":
/*!*********************************************!*\
  !*** ./node_modules/dagre/lib/normalize.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var _ = __webpack_require__(/*! ./lodash */ "./node_modules/dagre/lib/lodash.js");
var util = __webpack_require__(/*! ./util */ "./node_modules/dagre/lib/util.js");

module.exports = {
  run: run,
  undo: undo
};

/*
 * Breaks any long edges in the graph into short segments that span 1 layer
 * each. This operation is undoable with the denormalize function.
 *
 * Pre-conditions:
 *
 *    1. The input graph is a DAG.
 *    2. Each node in the graph has a "rank" property.
 *
 * Post-condition:
 *
 *    1. All edges in the graph have a length of 1.
 *    2. Dummy nodes are added where edges have been split into segments.
 *    3. The graph is augmented with a "dummyChains" attribute which contains
 *       the first dummy in each chain of dummy nodes produced.
 */
function run(g) {
  g.graph().dummyChains = [];
  _.forEach(g.edges(), function(edge) { normalizeEdge(g, edge); });
}

function normalizeEdge(g, e) {
  var v = e.v;
  var vRank = g.node(v).rank;
  var w = e.w;
  var wRank = g.node(w).rank;
  var name = e.name;
  var edgeLabel = g.edge(e);
  var labelRank = edgeLabel.labelRank;

  if (wRank === vRank + 1) return;

  g.removeEdge(e);

  var dummy, attrs, i;
  for (i = 0, ++vRank; vRank < wRank; ++i, ++vRank) {
    edgeLabel.points = [];
    attrs = {
      width: 0, height: 0,
      edgeLabel: edgeLabel, edgeObj: e,
      rank: vRank
    };
    dummy = util.addDummyNode(g, "edge", attrs, "_d");
    if (vRank === labelRank) {
      attrs.width = edgeLabel.width;
      attrs.height = edgeLabel.height;
      attrs.dummy = "edge-label";
      attrs.labelpos = edgeLabel.labelpos;
    }
    g.setEdge(v, dummy, { weight: edgeLabel.weight }, name);
    if (i === 0) {
      g.graph().dummyChains.push(dummy);
    }
    v = dummy;
  }

  g.setEdge(v, w, { weight: edgeLabel.weight }, name);
}

function undo(g) {
  _.forEach(g.graph().dummyChains, function(v) {
    var node = g.node(v);
    var origLabel = node.edgeLabel;
    var w;
    g.setEdge(node.edgeObj, origLabel);
    while (node.dummy) {
      w = g.successors(v)[0];
      g.removeNode(v);
      origLabel.points.push({ x: node.x, y: node.y });
      if (node.dummy === "edge-label") {
        origLabel.x = node.x;
        origLabel.y = node.y;
        origLabel.width = node.width;
        origLabel.height = node.height;
      }
      v = w;
      node = g.node(v);
    }
  });
}


/***/ }),

/***/ "./node_modules/dagre/lib/order/add-subgraph-constraints.js":
/*!******************************************************************!*\
  !*** ./node_modules/dagre/lib/order/add-subgraph-constraints.js ***!
  \******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var _ = __webpack_require__(/*! ../lodash */ "./node_modules/dagre/lib/lodash.js");

module.exports = addSubgraphConstraints;

function addSubgraphConstraints(g, cg, vs) {
  var prev = {},
    rootPrev;

  _.forEach(vs, function(v) {
    var child = g.parent(v),
      parent,
      prevChild;
    while (child) {
      parent = g.parent(child);
      if (parent) {
        prevChild = prev[parent];
        prev[parent] = child;
      } else {
        prevChild = rootPrev;
        rootPrev = child;
      }
      if (prevChild && prevChild !== child) {
        cg.setEdge(prevChild, child);
        return;
      }
      child = parent;
    }
  });

  /*
  function dfs(v) {
    var children = v ? g.children(v) : g.children();
    if (children.length) {
      var min = Number.POSITIVE_INFINITY,
          subgraphs = [];
      _.each(children, function(child) {
        var childMin = dfs(child);
        if (g.children(child).length) {
          subgraphs.push({ v: child, order: childMin });
        }
        min = Math.min(min, childMin);
      });
      _.reduce(_.sortBy(subgraphs, "order"), function(prev, curr) {
        cg.setEdge(prev.v, curr.v);
        return curr;
      });
      return min;
    }
    return g.node(v).order;
  }
  dfs(undefined);
  */
}


/***/ }),

/***/ "./node_modules/dagre/lib/order/barycenter.js":
/*!****************************************************!*\
  !*** ./node_modules/dagre/lib/order/barycenter.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var _ = __webpack_require__(/*! ../lodash */ "./node_modules/dagre/lib/lodash.js");

module.exports = barycenter;

function barycenter(g, movable) {
  return _.map(movable, function(v) {
    var inV = g.inEdges(v);
    if (!inV.length) {
      return { v: v };
    } else {
      var result = _.reduce(inV, function(acc, e) {
        var edge = g.edge(e),
          nodeU = g.node(e.v);
        return {
          sum: acc.sum + (edge.weight * nodeU.order),
          weight: acc.weight + edge.weight
        };
      }, { sum: 0, weight: 0 });

      return {
        v: v,
        barycenter: result.sum / result.weight,
        weight: result.weight
      };
    }
  });
}



/***/ }),

/***/ "./node_modules/dagre/lib/order/build-layer-graph.js":
/*!***********************************************************!*\
  !*** ./node_modules/dagre/lib/order/build-layer-graph.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var _ = __webpack_require__(/*! ../lodash */ "./node_modules/dagre/lib/lodash.js");
var Graph = __webpack_require__(/*! ../graphlib */ "./node_modules/dagre/lib/graphlib.js").Graph;

module.exports = buildLayerGraph;

/*
 * Constructs a graph that can be used to sort a layer of nodes. The graph will
 * contain all base and subgraph nodes from the request layer in their original
 * hierarchy and any edges that are incident on these nodes and are of the type
 * requested by the "relationship" parameter.
 *
 * Nodes from the requested rank that do not have parents are assigned a root
 * node in the output graph, which is set in the root graph attribute. This
 * makes it easy to walk the hierarchy of movable nodes during ordering.
 *
 * Pre-conditions:
 *
 *    1. Input graph is a DAG
 *    2. Base nodes in the input graph have a rank attribute
 *    3. Subgraph nodes in the input graph has minRank and maxRank attributes
 *    4. Edges have an assigned weight
 *
 * Post-conditions:
 *
 *    1. Output graph has all nodes in the movable rank with preserved
 *       hierarchy.
 *    2. Root nodes in the movable layer are made children of the node
 *       indicated by the root attribute of the graph.
 *    3. Non-movable nodes incident on movable nodes, selected by the
 *       relationship parameter, are included in the graph (without hierarchy).
 *    4. Edges incident on movable nodes, selected by the relationship
 *       parameter, are added to the output graph.
 *    5. The weights for copied edges are aggregated as need, since the output
 *       graph is not a multi-graph.
 */
function buildLayerGraph(g, rank, relationship) {
  var root = createRootNode(g),
    result = new Graph({ compound: true }).setGraph({ root: root })
      .setDefaultNodeLabel(function(v) { return g.node(v); });

  _.forEach(g.nodes(), function(v) {
    var node = g.node(v),
      parent = g.parent(v);

    if (node.rank === rank || node.minRank <= rank && rank <= node.maxRank) {
      result.setNode(v);
      result.setParent(v, parent || root);

      // This assumes we have only short edges!
      _.forEach(g[relationship](v), function(e) {
        var u = e.v === v ? e.w : e.v,
          edge = result.edge(u, v),
          weight = !_.isUndefined(edge) ? edge.weight : 0;
        result.setEdge(u, v, { weight: g.edge(e).weight + weight });
      });

      if (_.has(node, "minRank")) {
        result.setNode(v, {
          borderLeft: node.borderLeft[rank],
          borderRight: node.borderRight[rank]
        });
      }
    }
  });

  return result;
}

function createRootNode(g) {
  var v;
  while (g.hasNode((v = _.uniqueId("_root"))));
  return v;
}


/***/ }),

/***/ "./node_modules/dagre/lib/order/cross-count.js":
/*!*****************************************************!*\
  !*** ./node_modules/dagre/lib/order/cross-count.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var _ = __webpack_require__(/*! ../lodash */ "./node_modules/dagre/lib/lodash.js");

module.exports = crossCount;

/*
 * A function that takes a layering (an array of layers, each with an array of
 * ordererd nodes) and a graph and returns a weighted crossing count.
 *
 * Pre-conditions:
 *
 *    1. Input graph must be simple (not a multigraph), directed, and include
 *       only simple edges.
 *    2. Edges in the input graph must have assigned weights.
 *
 * Post-conditions:
 *
 *    1. The graph and layering matrix are left unchanged.
 *
 * This algorithm is derived from Barth, et al., "Bilayer Cross Counting."
 */
function crossCount(g, layering) {
  var cc = 0;
  for (var i = 1; i < layering.length; ++i) {
    cc += twoLayerCrossCount(g, layering[i-1], layering[i]);
  }
  return cc;
}

function twoLayerCrossCount(g, northLayer, southLayer) {
  // Sort all of the edges between the north and south layers by their position
  // in the north layer and then the south. Map these edges to the position of
  // their head in the south layer.
  var southPos = _.zipObject(southLayer,
    _.map(southLayer, function (v, i) { return i; }));
  var southEntries = _.flatten(_.map(northLayer, function(v) {
    return _.sortBy(_.map(g.outEdges(v), function(e) {
      return { pos: southPos[e.w], weight: g.edge(e).weight };
    }), "pos");
  }), true);

  // Build the accumulator tree
  var firstIndex = 1;
  while (firstIndex < southLayer.length) firstIndex <<= 1;
  var treeSize = 2 * firstIndex - 1;
  firstIndex -= 1;
  var tree = _.map(new Array(treeSize), function() { return 0; });

  // Calculate the weighted crossings
  var cc = 0;
  _.forEach(southEntries.forEach(function(entry) {
    var index = entry.pos + firstIndex;
    tree[index] += entry.weight;
    var weightSum = 0;
    while (index > 0) {
      if (index % 2) {
        weightSum += tree[index + 1];
      }
      index = (index - 1) >> 1;
      tree[index] += entry.weight;
    }
    cc += entry.weight * weightSum;
  }));

  return cc;
}


/***/ }),

/***/ "./node_modules/dagre/lib/order/index.js":
/*!***********************************************!*\
  !*** ./node_modules/dagre/lib/order/index.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var _ = __webpack_require__(/*! ../lodash */ "./node_modules/dagre/lib/lodash.js");
var initOrder = __webpack_require__(/*! ./init-order */ "./node_modules/dagre/lib/order/init-order.js");
var crossCount = __webpack_require__(/*! ./cross-count */ "./node_modules/dagre/lib/order/cross-count.js");
var sortSubgraph = __webpack_require__(/*! ./sort-subgraph */ "./node_modules/dagre/lib/order/sort-subgraph.js");
var buildLayerGraph = __webpack_require__(/*! ./build-layer-graph */ "./node_modules/dagre/lib/order/build-layer-graph.js");
var addSubgraphConstraints = __webpack_require__(/*! ./add-subgraph-constraints */ "./node_modules/dagre/lib/order/add-subgraph-constraints.js");
var Graph = __webpack_require__(/*! ../graphlib */ "./node_modules/dagre/lib/graphlib.js").Graph;
var util = __webpack_require__(/*! ../util */ "./node_modules/dagre/lib/util.js");

module.exports = order;

/*
 * Applies heuristics to minimize edge crossings in the graph and sets the best
 * order solution as an order attribute on each node.
 *
 * Pre-conditions:
 *
 *    1. Graph must be DAG
 *    2. Graph nodes must be objects with a "rank" attribute
 *    3. Graph edges must have the "weight" attribute
 *
 * Post-conditions:
 *
 *    1. Graph nodes will have an "order" attribute based on the results of the
 *       algorithm.
 */
function order(g) {
  var maxRank = util.maxRank(g),
    downLayerGraphs = buildLayerGraphs(g, _.range(1, maxRank + 1), "inEdges"),
    upLayerGraphs = buildLayerGraphs(g, _.range(maxRank - 1, -1, -1), "outEdges");

  var layering = initOrder(g);
  assignOrder(g, layering);

  var bestCC = Number.POSITIVE_INFINITY,
    best;

  for (var i = 0, lastBest = 0; lastBest < 4; ++i, ++lastBest) {
    sweepLayerGraphs(i % 2 ? downLayerGraphs : upLayerGraphs, i % 4 >= 2);

    layering = util.buildLayerMatrix(g);
    var cc = crossCount(g, layering);
    if (cc < bestCC) {
      lastBest = 0;
      best = _.cloneDeep(layering);
      bestCC = cc;
    }
  }

  assignOrder(g, best);
}

function buildLayerGraphs(g, ranks, relationship) {
  return _.map(ranks, function(rank) {
    return buildLayerGraph(g, rank, relationship);
  });
}

function sweepLayerGraphs(layerGraphs, biasRight) {
  var cg = new Graph();
  _.forEach(layerGraphs, function(lg) {
    var root = lg.graph().root;
    var sorted = sortSubgraph(lg, root, cg, biasRight);
    _.forEach(sorted.vs, function(v, i) {
      lg.node(v).order = i;
    });
    addSubgraphConstraints(lg, cg, sorted.vs);
  });
}

function assignOrder(g, layering) {
  _.forEach(layering, function(layer) {
    _.forEach(layer, function(v, i) {
      g.node(v).order = i;
    });
  });
}


/***/ }),

/***/ "./node_modules/dagre/lib/order/init-order.js":
/*!****************************************************!*\
  !*** ./node_modules/dagre/lib/order/init-order.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var _ = __webpack_require__(/*! ../lodash */ "./node_modules/dagre/lib/lodash.js");

module.exports = initOrder;

/*
 * Assigns an initial order value for each node by performing a DFS search
 * starting from nodes in the first rank. Nodes are assigned an order in their
 * rank as they are first visited.
 *
 * This approach comes from Gansner, et al., "A Technique for Drawing Directed
 * Graphs."
 *
 * Returns a layering matrix with an array per layer and each layer sorted by
 * the order of its nodes.
 */
function initOrder(g) {
  var visited = {};
  var simpleNodes = _.filter(g.nodes(), function(v) {
    return !g.children(v).length;
  });
  var maxRank = _.max(_.map(simpleNodes, function(v) { return g.node(v).rank; }));
  var layers = _.map(_.range(maxRank + 1), function() { return []; });

  function dfs(v) {
    if (_.has(visited, v)) return;
    visited[v] = true;
    var node = g.node(v);
    layers[node.rank].push(v);
    _.forEach(g.successors(v), dfs);
  }

  var orderedVs = _.sortBy(simpleNodes, function(v) { return g.node(v).rank; });
  _.forEach(orderedVs, dfs);

  return layers;
}


/***/ }),

/***/ "./node_modules/dagre/lib/order/resolve-conflicts.js":
/*!***********************************************************!*\
  !*** ./node_modules/dagre/lib/order/resolve-conflicts.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var _ = __webpack_require__(/*! ../lodash */ "./node_modules/dagre/lib/lodash.js");

module.exports = resolveConflicts;

/*
 * Given a list of entries of the form {v, barycenter, weight} and a
 * constraint graph this function will resolve any conflicts between the
 * constraint graph and the barycenters for the entries. If the barycenters for
 * an entry would violate a constraint in the constraint graph then we coalesce
 * the nodes in the conflict into a new node that respects the contraint and
 * aggregates barycenter and weight information.
 *
 * This implementation is based on the description in Forster, "A Fast and
 * Simple Hueristic for Constrained Two-Level Crossing Reduction," thought it
 * differs in some specific details.
 *
 * Pre-conditions:
 *
 *    1. Each entry has the form {v, barycenter, weight}, or if the node has
 *       no barycenter, then {v}.
 *
 * Returns:
 *
 *    A new list of entries of the form {vs, i, barycenter, weight}. The list
 *    `vs` may either be a singleton or it may be an aggregation of nodes
 *    ordered such that they do not violate constraints from the constraint
 *    graph. The property `i` is the lowest original index of any of the
 *    elements in `vs`.
 */
function resolveConflicts(entries, cg) {
  var mappedEntries = {};
  _.forEach(entries, function(entry, i) {
    var tmp = mappedEntries[entry.v] = {
      indegree: 0,
      "in": [],
      out: [],
      vs: [entry.v],
      i: i
    };
    if (!_.isUndefined(entry.barycenter)) {
      tmp.barycenter = entry.barycenter;
      tmp.weight = entry.weight;
    }
  });

  _.forEach(cg.edges(), function(e) {
    var entryV = mappedEntries[e.v];
    var entryW = mappedEntries[e.w];
    if (!_.isUndefined(entryV) && !_.isUndefined(entryW)) {
      entryW.indegree++;
      entryV.out.push(mappedEntries[e.w]);
    }
  });

  var sourceSet = _.filter(mappedEntries, function(entry) {
    return !entry.indegree;
  });

  return doResolveConflicts(sourceSet);
}

function doResolveConflicts(sourceSet) {
  var entries = [];

  function handleIn(vEntry) {
    return function(uEntry) {
      if (uEntry.merged) {
        return;
      }
      if (_.isUndefined(uEntry.barycenter) ||
          _.isUndefined(vEntry.barycenter) ||
          uEntry.barycenter >= vEntry.barycenter) {
        mergeEntries(vEntry, uEntry);
      }
    };
  }

  function handleOut(vEntry) {
    return function(wEntry) {
      wEntry["in"].push(vEntry);
      if (--wEntry.indegree === 0) {
        sourceSet.push(wEntry);
      }
    };
  }

  while (sourceSet.length) {
    var entry = sourceSet.pop();
    entries.push(entry);
    _.forEach(entry["in"].reverse(), handleIn(entry));
    _.forEach(entry.out, handleOut(entry));
  }

  return _.map(_.filter(entries, function(entry) { return !entry.merged; }),
    function(entry) {
      return _.pick(entry, ["vs", "i", "barycenter", "weight"]);
    });

}

function mergeEntries(target, source) {
  var sum = 0;
  var weight = 0;

  if (target.weight) {
    sum += target.barycenter * target.weight;
    weight += target.weight;
  }

  if (source.weight) {
    sum += source.barycenter * source.weight;
    weight += source.weight;
  }

  target.vs = source.vs.concat(target.vs);
  target.barycenter = sum / weight;
  target.weight = weight;
  target.i = Math.min(source.i, target.i);
  source.merged = true;
}


/***/ }),

/***/ "./node_modules/dagre/lib/order/sort-subgraph.js":
/*!*******************************************************!*\
  !*** ./node_modules/dagre/lib/order/sort-subgraph.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var _ = __webpack_require__(/*! ../lodash */ "./node_modules/dagre/lib/lodash.js");
var barycenter = __webpack_require__(/*! ./barycenter */ "./node_modules/dagre/lib/order/barycenter.js");
var resolveConflicts = __webpack_require__(/*! ./resolve-conflicts */ "./node_modules/dagre/lib/order/resolve-conflicts.js");
var sort = __webpack_require__(/*! ./sort */ "./node_modules/dagre/lib/order/sort.js");

module.exports = sortSubgraph;

function sortSubgraph(g, v, cg, biasRight) {
  var movable = g.children(v);
  var node = g.node(v);
  var bl = node ? node.borderLeft : undefined;
  var br = node ? node.borderRight: undefined;
  var subgraphs = {};

  if (bl) {
    movable = _.filter(movable, function(w) {
      return w !== bl && w !== br;
    });
  }

  var barycenters = barycenter(g, movable);
  _.forEach(barycenters, function(entry) {
    if (g.children(entry.v).length) {
      var subgraphResult = sortSubgraph(g, entry.v, cg, biasRight);
      subgraphs[entry.v] = subgraphResult;
      if (_.has(subgraphResult, "barycenter")) {
        mergeBarycenters(entry, subgraphResult);
      }
    }
  });

  var entries = resolveConflicts(barycenters, cg);
  expandSubgraphs(entries, subgraphs);

  var result = sort(entries, biasRight);

  if (bl) {
    result.vs = _.flatten([bl, result.vs, br], true);
    if (g.predecessors(bl).length) {
      var blPred = g.node(g.predecessors(bl)[0]),
        brPred = g.node(g.predecessors(br)[0]);
      if (!_.has(result, "barycenter")) {
        result.barycenter = 0;
        result.weight = 0;
      }
      result.barycenter = (result.barycenter * result.weight +
                           blPred.order + brPred.order) / (result.weight + 2);
      result.weight += 2;
    }
  }

  return result;
}

function expandSubgraphs(entries, subgraphs) {
  _.forEach(entries, function(entry) {
    entry.vs = _.flatten(entry.vs.map(function(v) {
      if (subgraphs[v]) {
        return subgraphs[v].vs;
      }
      return v;
    }), true);
  });
}

function mergeBarycenters(target, other) {
  if (!_.isUndefined(target.barycenter)) {
    target.barycenter = (target.barycenter * target.weight +
                         other.barycenter * other.weight) /
                        (target.weight + other.weight);
    target.weight += other.weight;
  } else {
    target.barycenter = other.barycenter;
    target.weight = other.weight;
  }
}


/***/ }),

/***/ "./node_modules/dagre/lib/order/sort.js":
/*!**********************************************!*\
  !*** ./node_modules/dagre/lib/order/sort.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var _ = __webpack_require__(/*! ../lodash */ "./node_modules/dagre/lib/lodash.js");
var util = __webpack_require__(/*! ../util */ "./node_modules/dagre/lib/util.js");

module.exports = sort;

function sort(entries, biasRight) {
  var parts = util.partition(entries, function(entry) {
    return _.has(entry, "barycenter");
  });
  var sortable = parts.lhs,
    unsortable = _.sortBy(parts.rhs, function(entry) { return -entry.i; }),
    vs = [],
    sum = 0,
    weight = 0,
    vsIndex = 0;

  sortable.sort(compareWithBias(!!biasRight));

  vsIndex = consumeUnsortable(vs, unsortable, vsIndex);

  _.forEach(sortable, function (entry) {
    vsIndex += entry.vs.length;
    vs.push(entry.vs);
    sum += entry.barycenter * entry.weight;
    weight += entry.weight;
    vsIndex = consumeUnsortable(vs, unsortable, vsIndex);
  });

  var result = { vs: _.flatten(vs, true) };
  if (weight) {
    result.barycenter = sum / weight;
    result.weight = weight;
  }
  return result;
}

function consumeUnsortable(vs, unsortable, index) {
  var last;
  while (unsortable.length && (last = _.last(unsortable)).i <= index) {
    unsortable.pop();
    vs.push(last.vs);
    index++;
  }
  return index;
}

function compareWithBias(bias) {
  return function(entryV, entryW) {
    if (entryV.barycenter < entryW.barycenter) {
      return -1;
    } else if (entryV.barycenter > entryW.barycenter) {
      return 1;
    }

    return !bias ? entryV.i - entryW.i : entryW.i - entryV.i;
  };
}


/***/ }),

/***/ "./node_modules/dagre/lib/parent-dummy-chains.js":
/*!*******************************************************!*\
  !*** ./node_modules/dagre/lib/parent-dummy-chains.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var _ = __webpack_require__(/*! ./lodash */ "./node_modules/dagre/lib/lodash.js");

module.exports = parentDummyChains;

function parentDummyChains(g) {
  var postorderNums = postorder(g);

  _.forEach(g.graph().dummyChains, function(v) {
    var node = g.node(v);
    var edgeObj = node.edgeObj;
    var pathData = findPath(g, postorderNums, edgeObj.v, edgeObj.w);
    var path = pathData.path;
    var lca = pathData.lca;
    var pathIdx = 0;
    var pathV = path[pathIdx];
    var ascending = true;

    while (v !== edgeObj.w) {
      node = g.node(v);

      if (ascending) {
        while ((pathV = path[pathIdx]) !== lca &&
               g.node(pathV).maxRank < node.rank) {
          pathIdx++;
        }

        if (pathV === lca) {
          ascending = false;
        }
      }

      if (!ascending) {
        while (pathIdx < path.length - 1 &&
               g.node(pathV = path[pathIdx + 1]).minRank <= node.rank) {
          pathIdx++;
        }
        pathV = path[pathIdx];
      }

      g.setParent(v, pathV);
      v = g.successors(v)[0];
    }
  });
}

// Find a path from v to w through the lowest common ancestor (LCA). Return the
// full path and the LCA.
function findPath(g, postorderNums, v, w) {
  var vPath = [];
  var wPath = [];
  var low = Math.min(postorderNums[v].low, postorderNums[w].low);
  var lim = Math.max(postorderNums[v].lim, postorderNums[w].lim);
  var parent;
  var lca;

  // Traverse up from v to find the LCA
  parent = v;
  do {
    parent = g.parent(parent);
    vPath.push(parent);
  } while (parent &&
           (postorderNums[parent].low > low || lim > postorderNums[parent].lim));
  lca = parent;

  // Traverse from w to LCA
  parent = w;
  while ((parent = g.parent(parent)) !== lca) {
    wPath.push(parent);
  }

  return { path: vPath.concat(wPath.reverse()), lca: lca };
}

function postorder(g) {
  var result = {};
  var lim = 0;

  function dfs(v) {
    var low = lim;
    _.forEach(g.children(v), dfs);
    result[v] = { low: low, lim: lim++ };
  }
  _.forEach(g.children(), dfs);

  return result;
}


/***/ }),

/***/ "./node_modules/dagre/lib/position/bk.js":
/*!***********************************************!*\
  !*** ./node_modules/dagre/lib/position/bk.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var _ = __webpack_require__(/*! ../lodash */ "./node_modules/dagre/lib/lodash.js");
var Graph = __webpack_require__(/*! ../graphlib */ "./node_modules/dagre/lib/graphlib.js").Graph;
var util = __webpack_require__(/*! ../util */ "./node_modules/dagre/lib/util.js");

/*
 * This module provides coordinate assignment based on Brandes and Kpf, "Fast
 * and Simple Horizontal Coordinate Assignment."
 */

module.exports = {
  positionX: positionX,
  findType1Conflicts: findType1Conflicts,
  findType2Conflicts: findType2Conflicts,
  addConflict: addConflict,
  hasConflict: hasConflict,
  verticalAlignment: verticalAlignment,
  horizontalCompaction: horizontalCompaction,
  alignCoordinates: alignCoordinates,
  findSmallestWidthAlignment: findSmallestWidthAlignment,
  balance: balance
};

/*
 * Marks all edges in the graph with a type-1 conflict with the "type1Conflict"
 * property. A type-1 conflict is one where a non-inner segment crosses an
 * inner segment. An inner segment is an edge with both incident nodes marked
 * with the "dummy" property.
 *
 * This algorithm scans layer by layer, starting with the second, for type-1
 * conflicts between the current layer and the previous layer. For each layer
 * it scans the nodes from left to right until it reaches one that is incident
 * on an inner segment. It then scans predecessors to determine if they have
 * edges that cross that inner segment. At the end a final scan is done for all
 * nodes on the current rank to see if they cross the last visited inner
 * segment.
 *
 * This algorithm (safely) assumes that a dummy node will only be incident on a
 * single node in the layers being scanned.
 */
function findType1Conflicts(g, layering) {
  var conflicts = {};

  function visitLayer(prevLayer, layer) {
    var
      // last visited node in the previous layer that is incident on an inner
      // segment.
      k0 = 0,
      // Tracks the last node in this layer scanned for crossings with a type-1
      // segment.
      scanPos = 0,
      prevLayerLength = prevLayer.length,
      lastNode = _.last(layer);

    _.forEach(layer, function(v, i) {
      var w = findOtherInnerSegmentNode(g, v),
        k1 = w ? g.node(w).order : prevLayerLength;

      if (w || v === lastNode) {
        _.forEach(layer.slice(scanPos, i +1), function(scanNode) {
          _.forEach(g.predecessors(scanNode), function(u) {
            var uLabel = g.node(u),
              uPos = uLabel.order;
            if ((uPos < k0 || k1 < uPos) &&
                !(uLabel.dummy && g.node(scanNode).dummy)) {
              addConflict(conflicts, u, scanNode);
            }
          });
        });
        scanPos = i + 1;
        k0 = k1;
      }
    });

    return layer;
  }

  _.reduce(layering, visitLayer);
  return conflicts;
}

function findType2Conflicts(g, layering) {
  var conflicts = {};

  function scan(south, southPos, southEnd, prevNorthBorder, nextNorthBorder) {
    var v;
    _.forEach(_.range(southPos, southEnd), function(i) {
      v = south[i];
      if (g.node(v).dummy) {
        _.forEach(g.predecessors(v), function(u) {
          var uNode = g.node(u);
          if (uNode.dummy &&
              (uNode.order < prevNorthBorder || uNode.order > nextNorthBorder)) {
            addConflict(conflicts, u, v);
          }
        });
      }
    });
  }


  function visitLayer(north, south) {
    var prevNorthPos = -1,
      nextNorthPos,
      southPos = 0;

    _.forEach(south, function(v, southLookahead) {
      if (g.node(v).dummy === "border") {
        var predecessors = g.predecessors(v);
        if (predecessors.length) {
          nextNorthPos = g.node(predecessors[0]).order;
          scan(south, southPos, southLookahead, prevNorthPos, nextNorthPos);
          southPos = southLookahead;
          prevNorthPos = nextNorthPos;
        }
      }
      scan(south, southPos, south.length, nextNorthPos, north.length);
    });

    return south;
  }

  _.reduce(layering, visitLayer);
  return conflicts;
}

function findOtherInnerSegmentNode(g, v) {
  if (g.node(v).dummy) {
    return _.find(g.predecessors(v), function(u) {
      return g.node(u).dummy;
    });
  }
}

function addConflict(conflicts, v, w) {
  if (v > w) {
    var tmp = v;
    v = w;
    w = tmp;
  }

  var conflictsV = conflicts[v];
  if (!conflictsV) {
    conflicts[v] = conflictsV = {};
  }
  conflictsV[w] = true;
}

function hasConflict(conflicts, v, w) {
  if (v > w) {
    var tmp = v;
    v = w;
    w = tmp;
  }
  return _.has(conflicts[v], w);
}

/*
 * Try to align nodes into vertical "blocks" where possible. This algorithm
 * attempts to align a node with one of its median neighbors. If the edge
 * connecting a neighbor is a type-1 conflict then we ignore that possibility.
 * If a previous node has already formed a block with a node after the node
 * we're trying to form a block with, we also ignore that possibility - our
 * blocks would be split in that scenario.
 */
function verticalAlignment(g, layering, conflicts, neighborFn) {
  var root = {},
    align = {},
    pos = {};

  // We cache the position here based on the layering because the graph and
  // layering may be out of sync. The layering matrix is manipulated to
  // generate different extreme alignments.
  _.forEach(layering, function(layer) {
    _.forEach(layer, function(v, order) {
      root[v] = v;
      align[v] = v;
      pos[v] = order;
    });
  });

  _.forEach(layering, function(layer) {
    var prevIdx = -1;
    _.forEach(layer, function(v) {
      var ws = neighborFn(v);
      if (ws.length) {
        ws = _.sortBy(ws, function(w) { return pos[w]; });
        var mp = (ws.length - 1) / 2;
        for (var i = Math.floor(mp), il = Math.ceil(mp); i <= il; ++i) {
          var w = ws[i];
          if (align[v] === v &&
              prevIdx < pos[w] &&
              !hasConflict(conflicts, v, w)) {
            align[w] = v;
            align[v] = root[v] = root[w];
            prevIdx = pos[w];
          }
        }
      }
    });
  });

  return { root: root, align: align };
}

function horizontalCompaction(g, layering, root, align, reverseSep) {
  // This portion of the algorithm differs from BK due to a number of problems.
  // Instead of their algorithm we construct a new block graph and do two
  // sweeps. The first sweep places blocks with the smallest possible
  // coordinates. The second sweep removes unused space by moving blocks to the
  // greatest coordinates without violating separation.
  var xs = {},
    blockG = buildBlockGraph(g, layering, root, reverseSep),
    borderType = reverseSep ? "borderLeft" : "borderRight";

  function iterate(setXsFunc, nextNodesFunc) {
    var stack = blockG.nodes();
    var elem = stack.pop();
    var visited = {};
    while (elem) {
      if (visited[elem]) {
        setXsFunc(elem);
      } else {
        visited[elem] = true;
        stack.push(elem);
        stack = stack.concat(nextNodesFunc(elem));
      }

      elem = stack.pop();
    }
  }

  // First pass, assign smallest coordinates
  function pass1(elem) {
    xs[elem] = blockG.inEdges(elem).reduce(function(acc, e) {
      return Math.max(acc, xs[e.v] + blockG.edge(e));
    }, 0);
  }

  // Second pass, assign greatest coordinates
  function pass2(elem) {
    var min = blockG.outEdges(elem).reduce(function(acc, e) {
      return Math.min(acc, xs[e.w] - blockG.edge(e));
    }, Number.POSITIVE_INFINITY);

    var node = g.node(elem);
    if (min !== Number.POSITIVE_INFINITY && node.borderType !== borderType) {
      xs[elem] = Math.max(xs[elem], min);
    }
  }

  iterate(pass1, blockG.predecessors.bind(blockG));
  iterate(pass2, blockG.successors.bind(blockG));

  // Assign x coordinates to all nodes
  _.forEach(align, function(v) {
    xs[v] = xs[root[v]];
  });

  return xs;
}


function buildBlockGraph(g, layering, root, reverseSep) {
  var blockGraph = new Graph(),
    graphLabel = g.graph(),
    sepFn = sep(graphLabel.nodesep, graphLabel.edgesep, reverseSep);

  _.forEach(layering, function(layer) {
    var u;
    _.forEach(layer, function(v) {
      var vRoot = root[v];
      blockGraph.setNode(vRoot);
      if (u) {
        var uRoot = root[u],
          prevMax = blockGraph.edge(uRoot, vRoot);
        blockGraph.setEdge(uRoot, vRoot, Math.max(sepFn(g, v, u), prevMax || 0));
      }
      u = v;
    });
  });

  return blockGraph;
}

/*
 * Returns the alignment that has the smallest width of the given alignments.
 */
function findSmallestWidthAlignment(g, xss) {
  return _.minBy(_.values(xss), function (xs) {
    var max = Number.NEGATIVE_INFINITY;
    var min = Number.POSITIVE_INFINITY;

    _.forIn(xs, function (x, v) {
      var halfWidth = width(g, v) / 2;

      max = Math.max(x + halfWidth, max);
      min = Math.min(x - halfWidth, min);
    });

    return max - min;
  });
}

/*
 * Align the coordinates of each of the layout alignments such that
 * left-biased alignments have their minimum coordinate at the same point as
 * the minimum coordinate of the smallest width alignment and right-biased
 * alignments have their maximum coordinate at the same point as the maximum
 * coordinate of the smallest width alignment.
 */
function alignCoordinates(xss, alignTo) {
  var alignToVals = _.values(alignTo),
    alignToMin = _.min(alignToVals),
    alignToMax = _.max(alignToVals);

  _.forEach(["u", "d"], function(vert) {
    _.forEach(["l", "r"], function(horiz) {
      var alignment = vert + horiz,
        xs = xss[alignment],
        delta;
      if (xs === alignTo) return;

      var xsVals = _.values(xs);
      delta = horiz === "l" ? alignToMin - _.min(xsVals) : alignToMax - _.max(xsVals);

      if (delta) {
        xss[alignment] = _.mapValues(xs, function(x) { return x + delta; });
      }
    });
  });
}

function balance(xss, align) {
  return _.mapValues(xss.ul, function(ignore, v) {
    if (align) {
      return xss[align.toLowerCase()][v];
    } else {
      var xs = _.sortBy(_.map(xss, v));
      return (xs[1] + xs[2]) / 2;
    }
  });
}

function positionX(g) {
  var layering = util.buildLayerMatrix(g);
  var conflicts = _.merge(
    findType1Conflicts(g, layering),
    findType2Conflicts(g, layering));

  var xss = {};
  var adjustedLayering;
  _.forEach(["u", "d"], function(vert) {
    adjustedLayering = vert === "u" ? layering : _.values(layering).reverse();
    _.forEach(["l", "r"], function(horiz) {
      if (horiz === "r") {
        adjustedLayering = _.map(adjustedLayering, function(inner) {
          return _.values(inner).reverse();
        });
      }

      var neighborFn = (vert === "u" ? g.predecessors : g.successors).bind(g);
      var align = verticalAlignment(g, adjustedLayering, conflicts, neighborFn);
      var xs = horizontalCompaction(g, adjustedLayering,
        align.root, align.align, horiz === "r");
      if (horiz === "r") {
        xs = _.mapValues(xs, function(x) { return -x; });
      }
      xss[vert + horiz] = xs;
    });
  });

  var smallestWidth = findSmallestWidthAlignment(g, xss);
  alignCoordinates(xss, smallestWidth);
  return balance(xss, g.graph().align);
}

function sep(nodeSep, edgeSep, reverseSep) {
  return function(g, v, w) {
    var vLabel = g.node(v);
    var wLabel = g.node(w);
    var sum = 0;
    var delta;

    sum += vLabel.width / 2;
    if (_.has(vLabel, "labelpos")) {
      switch (vLabel.labelpos.toLowerCase()) {
      case "l": delta = -vLabel.width / 2; break;
      case "r": delta = vLabel.width / 2; break;
      }
    }
    if (delta) {
      sum += reverseSep ? delta : -delta;
    }
    delta = 0;

    sum += (vLabel.dummy ? edgeSep : nodeSep) / 2;
    sum += (wLabel.dummy ? edgeSep : nodeSep) / 2;

    sum += wLabel.width / 2;
    if (_.has(wLabel, "labelpos")) {
      switch (wLabel.labelpos.toLowerCase()) {
      case "l": delta = wLabel.width / 2; break;
      case "r": delta = -wLabel.width / 2; break;
      }
    }
    if (delta) {
      sum += reverseSep ? delta : -delta;
    }
    delta = 0;

    return sum;
  };
}

function width(g, v) {
  return g.node(v).width;
}


/***/ }),

/***/ "./node_modules/dagre/lib/position/index.js":
/*!**************************************************!*\
  !*** ./node_modules/dagre/lib/position/index.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var _ = __webpack_require__(/*! ../lodash */ "./node_modules/dagre/lib/lodash.js");
var util = __webpack_require__(/*! ../util */ "./node_modules/dagre/lib/util.js");
var positionX = __webpack_require__(/*! ./bk */ "./node_modules/dagre/lib/position/bk.js").positionX;

module.exports = position;

function position(g) {
  g = util.asNonCompoundGraph(g);

  positionY(g);
  _.forEach(positionX(g), function(x, v) {
    g.node(v).x = x;
  });
}

function positionY(g) {
  var layering = util.buildLayerMatrix(g);
  var rankSep = g.graph().ranksep;
  var prevY = 0;
  _.forEach(layering, function(layer) {
    var maxHeight = _.max(_.map(layer, function(v) { return g.node(v).height; }));
    _.forEach(layer, function(v) {
      g.node(v).y = prevY + maxHeight / 2;
    });
    prevY += maxHeight + rankSep;
  });
}



/***/ }),

/***/ "./node_modules/dagre/lib/rank/feasible-tree.js":
/*!******************************************************!*\
  !*** ./node_modules/dagre/lib/rank/feasible-tree.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var _ = __webpack_require__(/*! ../lodash */ "./node_modules/dagre/lib/lodash.js");
var Graph = __webpack_require__(/*! ../graphlib */ "./node_modules/dagre/lib/graphlib.js").Graph;
var slack = __webpack_require__(/*! ./util */ "./node_modules/dagre/lib/rank/util.js").slack;

module.exports = feasibleTree;

/*
 * Constructs a spanning tree with tight edges and adjusted the input node's
 * ranks to achieve this. A tight edge is one that is has a length that matches
 * its "minlen" attribute.
 *
 * The basic structure for this function is derived from Gansner, et al., "A
 * Technique for Drawing Directed Graphs."
 *
 * Pre-conditions:
 *
 *    1. Graph must be a DAG.
 *    2. Graph must be connected.
 *    3. Graph must have at least one node.
 *    5. Graph nodes must have been previously assigned a "rank" property that
 *       respects the "minlen" property of incident edges.
 *    6. Graph edges must have a "minlen" property.
 *
 * Post-conditions:
 *
 *    - Graph nodes will have their rank adjusted to ensure that all edges are
 *      tight.
 *
 * Returns a tree (undirected graph) that is constructed using only "tight"
 * edges.
 */
function feasibleTree(g) {
  var t = new Graph({ directed: false });

  // Choose arbitrary node from which to start our tree
  var start = g.nodes()[0];
  var size = g.nodeCount();
  t.setNode(start, {});

  var edge, delta;
  while (tightTree(t, g) < size) {
    edge = findMinSlackEdge(t, g);
    delta = t.hasNode(edge.v) ? slack(g, edge) : -slack(g, edge);
    shiftRanks(t, g, delta);
  }

  return t;
}

/*
 * Finds a maximal tree of tight edges and returns the number of nodes in the
 * tree.
 */
function tightTree(t, g) {
  function dfs(v) {
    _.forEach(g.nodeEdges(v), function(e) {
      var edgeV = e.v,
        w = (v === edgeV) ? e.w : edgeV;
      if (!t.hasNode(w) && !slack(g, e)) {
        t.setNode(w, {});
        t.setEdge(v, w, {});
        dfs(w);
      }
    });
  }

  _.forEach(t.nodes(), dfs);
  return t.nodeCount();
}

/*
 * Finds the edge with the smallest slack that is incident on tree and returns
 * it.
 */
function findMinSlackEdge(t, g) {
  return _.minBy(g.edges(), function(e) {
    if (t.hasNode(e.v) !== t.hasNode(e.w)) {
      return slack(g, e);
    }
  });
}

function shiftRanks(t, g, delta) {
  _.forEach(t.nodes(), function(v) {
    g.node(v).rank += delta;
  });
}


/***/ }),

/***/ "./node_modules/dagre/lib/rank/index.js":
/*!**********************************************!*\
  !*** ./node_modules/dagre/lib/rank/index.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var rankUtil = __webpack_require__(/*! ./util */ "./node_modules/dagre/lib/rank/util.js");
var longestPath = rankUtil.longestPath;
var feasibleTree = __webpack_require__(/*! ./feasible-tree */ "./node_modules/dagre/lib/rank/feasible-tree.js");
var networkSimplex = __webpack_require__(/*! ./network-simplex */ "./node_modules/dagre/lib/rank/network-simplex.js");

module.exports = rank;

/*
 * Assigns a rank to each node in the input graph that respects the "minlen"
 * constraint specified on edges between nodes.
 *
 * This basic structure is derived from Gansner, et al., "A Technique for
 * Drawing Directed Graphs."
 *
 * Pre-conditions:
 *
 *    1. Graph must be a connected DAG
 *    2. Graph nodes must be objects
 *    3. Graph edges must have "weight" and "minlen" attributes
 *
 * Post-conditions:
 *
 *    1. Graph nodes will have a "rank" attribute based on the results of the
 *       algorithm. Ranks can start at any index (including negative), we'll
 *       fix them up later.
 */
function rank(g) {
  switch(g.graph().ranker) {
  case "network-simplex": networkSimplexRanker(g); break;
  case "tight-tree": tightTreeRanker(g); break;
  case "longest-path": longestPathRanker(g); break;
  default: networkSimplexRanker(g);
  }
}

// A fast and simple ranker, but results are far from optimal.
var longestPathRanker = longestPath;

function tightTreeRanker(g) {
  longestPath(g);
  feasibleTree(g);
}

function networkSimplexRanker(g) {
  networkSimplex(g);
}


/***/ }),

/***/ "./node_modules/dagre/lib/rank/network-simplex.js":
/*!********************************************************!*\
  !*** ./node_modules/dagre/lib/rank/network-simplex.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var _ = __webpack_require__(/*! ../lodash */ "./node_modules/dagre/lib/lodash.js");
var feasibleTree = __webpack_require__(/*! ./feasible-tree */ "./node_modules/dagre/lib/rank/feasible-tree.js");
var slack = __webpack_require__(/*! ./util */ "./node_modules/dagre/lib/rank/util.js").slack;
var initRank = __webpack_require__(/*! ./util */ "./node_modules/dagre/lib/rank/util.js").longestPath;
var preorder = __webpack_require__(/*! ../graphlib */ "./node_modules/dagre/lib/graphlib.js").alg.preorder;
var postorder = __webpack_require__(/*! ../graphlib */ "./node_modules/dagre/lib/graphlib.js").alg.postorder;
var simplify = __webpack_require__(/*! ../util */ "./node_modules/dagre/lib/util.js").simplify;

module.exports = networkSimplex;

// Expose some internals for testing purposes
networkSimplex.initLowLimValues = initLowLimValues;
networkSimplex.initCutValues = initCutValues;
networkSimplex.calcCutValue = calcCutValue;
networkSimplex.leaveEdge = leaveEdge;
networkSimplex.enterEdge = enterEdge;
networkSimplex.exchangeEdges = exchangeEdges;

/*
 * The network simplex algorithm assigns ranks to each node in the input graph
 * and iteratively improves the ranking to reduce the length of edges.
 *
 * Preconditions:
 *
 *    1. The input graph must be a DAG.
 *    2. All nodes in the graph must have an object value.
 *    3. All edges in the graph must have "minlen" and "weight" attributes.
 *
 * Postconditions:
 *
 *    1. All nodes in the graph will have an assigned "rank" attribute that has
 *       been optimized by the network simplex algorithm. Ranks start at 0.
 *
 *
 * A rough sketch of the algorithm is as follows:
 *
 *    1. Assign initial ranks to each node. We use the longest path algorithm,
 *       which assigns ranks to the lowest position possible. In general this
 *       leads to very wide bottom ranks and unnecessarily long edges.
 *    2. Construct a feasible tight tree. A tight tree is one such that all
 *       edges in the tree have no slack (difference between length of edge
 *       and minlen for the edge). This by itself greatly improves the assigned
 *       rankings by shorting edges.
 *    3. Iteratively find edges that have negative cut values. Generally a
 *       negative cut value indicates that the edge could be removed and a new
 *       tree edge could be added to produce a more compact graph.
 *
 * Much of the algorithms here are derived from Gansner, et al., "A Technique
 * for Drawing Directed Graphs." The structure of the file roughly follows the
 * structure of the overall algorithm.
 */
function networkSimplex(g) {
  g = simplify(g);
  initRank(g);
  var t = feasibleTree(g);
  initLowLimValues(t);
  initCutValues(t, g);

  var e, f;
  while ((e = leaveEdge(t))) {
    f = enterEdge(t, g, e);
    exchangeEdges(t, g, e, f);
  }
}

/*
 * Initializes cut values for all edges in the tree.
 */
function initCutValues(t, g) {
  var vs = postorder(t, t.nodes());
  vs = vs.slice(0, vs.length - 1);
  _.forEach(vs, function(v) {
    assignCutValue(t, g, v);
  });
}

function assignCutValue(t, g, child) {
  var childLab = t.node(child);
  var parent = childLab.parent;
  t.edge(child, parent).cutvalue = calcCutValue(t, g, child);
}

/*
 * Given the tight tree, its graph, and a child in the graph calculate and
 * return the cut value for the edge between the child and its parent.
 */
function calcCutValue(t, g, child) {
  var childLab = t.node(child);
  var parent = childLab.parent;
  // True if the child is on the tail end of the edge in the directed graph
  var childIsTail = true;
  // The graph's view of the tree edge we're inspecting
  var graphEdge = g.edge(child, parent);
  // The accumulated cut value for the edge between this node and its parent
  var cutValue = 0;

  if (!graphEdge) {
    childIsTail = false;
    graphEdge = g.edge(parent, child);
  }

  cutValue = graphEdge.weight;

  _.forEach(g.nodeEdges(child), function(e) {
    var isOutEdge = e.v === child,
      other = isOutEdge ? e.w : e.v;

    if (other !== parent) {
      var pointsToHead = isOutEdge === childIsTail,
        otherWeight = g.edge(e).weight;

      cutValue += pointsToHead ? otherWeight : -otherWeight;
      if (isTreeEdge(t, child, other)) {
        var otherCutValue = t.edge(child, other).cutvalue;
        cutValue += pointsToHead ? -otherCutValue : otherCutValue;
      }
    }
  });

  return cutValue;
}

function initLowLimValues(tree, root) {
  if (arguments.length < 2) {
    root = tree.nodes()[0];
  }
  dfsAssignLowLim(tree, {}, 1, root);
}

function dfsAssignLowLim(tree, visited, nextLim, v, parent) {
  var low = nextLim;
  var label = tree.node(v);

  visited[v] = true;
  _.forEach(tree.neighbors(v), function(w) {
    if (!_.has(visited, w)) {
      nextLim = dfsAssignLowLim(tree, visited, nextLim, w, v);
    }
  });

  label.low = low;
  label.lim = nextLim++;
  if (parent) {
    label.parent = parent;
  } else {
    // TODO should be able to remove this when we incrementally update low lim
    delete label.parent;
  }

  return nextLim;
}

function leaveEdge(tree) {
  return _.find(tree.edges(), function(e) {
    return tree.edge(e).cutvalue < 0;
  });
}

function enterEdge(t, g, edge) {
  var v = edge.v;
  var w = edge.w;

  // For the rest of this function we assume that v is the tail and w is the
  // head, so if we don't have this edge in the graph we should flip it to
  // match the correct orientation.
  if (!g.hasEdge(v, w)) {
    v = edge.w;
    w = edge.v;
  }

  var vLabel = t.node(v);
  var wLabel = t.node(w);
  var tailLabel = vLabel;
  var flip = false;

  // If the root is in the tail of the edge then we need to flip the logic that
  // checks for the head and tail nodes in the candidates function below.
  if (vLabel.lim > wLabel.lim) {
    tailLabel = wLabel;
    flip = true;
  }

  var candidates = _.filter(g.edges(), function(edge) {
    return flip === isDescendant(t, t.node(edge.v), tailLabel) &&
           flip !== isDescendant(t, t.node(edge.w), tailLabel);
  });

  return _.minBy(candidates, function(edge) { return slack(g, edge); });
}

function exchangeEdges(t, g, e, f) {
  var v = e.v;
  var w = e.w;
  t.removeEdge(v, w);
  t.setEdge(f.v, f.w, {});
  initLowLimValues(t);
  initCutValues(t, g);
  updateRanks(t, g);
}

function updateRanks(t, g) {
  var root = _.find(t.nodes(), function(v) { return !g.node(v).parent; });
  var vs = preorder(t, root);
  vs = vs.slice(1);
  _.forEach(vs, function(v) {
    var parent = t.node(v).parent,
      edge = g.edge(v, parent),
      flipped = false;

    if (!edge) {
      edge = g.edge(parent, v);
      flipped = true;
    }

    g.node(v).rank = g.node(parent).rank + (flipped ? edge.minlen : -edge.minlen);
  });
}

/*
 * Returns true if the edge is in the tree.
 */
function isTreeEdge(tree, u, v) {
  return tree.hasEdge(u, v);
}

/*
 * Returns true if the specified node is descendant of the root node per the
 * assigned low and lim attributes in the tree.
 */
function isDescendant(tree, vLabel, rootLabel) {
  return rootLabel.low <= vLabel.lim && vLabel.lim <= rootLabel.lim;
}


/***/ }),

/***/ "./node_modules/dagre/lib/rank/util.js":
/*!*********************************************!*\
  !*** ./node_modules/dagre/lib/rank/util.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var _ = __webpack_require__(/*! ../lodash */ "./node_modules/dagre/lib/lodash.js");

module.exports = {
  longestPath: longestPath,
  slack: slack
};

/*
 * Initializes ranks for the input graph using the longest path algorithm. This
 * algorithm scales well and is fast in practice, it yields rather poor
 * solutions. Nodes are pushed to the lowest layer possible, leaving the bottom
 * ranks wide and leaving edges longer than necessary. However, due to its
 * speed, this algorithm is good for getting an initial ranking that can be fed
 * into other algorithms.
 *
 * This algorithm does not normalize layers because it will be used by other
 * algorithms in most cases. If using this algorithm directly, be sure to
 * run normalize at the end.
 *
 * Pre-conditions:
 *
 *    1. Input graph is a DAG.
 *    2. Input graph node labels can be assigned properties.
 *
 * Post-conditions:
 *
 *    1. Each node will be assign an (unnormalized) "rank" property.
 */
function longestPath(g) {
  var visited = {};

  function dfs(v) {
    var label = g.node(v);
    if (_.has(visited, v)) {
      return label.rank;
    }
    visited[v] = true;

    var rank = _.min(_.map(g.outEdges(v), function(e) {
      return dfs(e.w) - g.edge(e).minlen;
    }));

    if (rank === Number.POSITIVE_INFINITY || // return value of _.map([]) for Lodash 3
        rank === undefined || // return value of _.map([]) for Lodash 4
        rank === null) { // return value of _.map([null])
      rank = 0;
    }

    return (label.rank = rank);
  }

  _.forEach(g.sources(), dfs);
}

/*
 * Returns the amount of slack for the given edge. The slack is defined as the
 * difference between the length of the edge and its minimum length.
 */
function slack(g, e) {
  return g.node(e.w).rank - g.node(e.v).rank - g.edge(e).minlen;
}


/***/ }),

/***/ "./node_modules/dagre/lib/util.js":
/*!****************************************!*\
  !*** ./node_modules/dagre/lib/util.js ***!
  \****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/* eslint "no-console": off */



var _ = __webpack_require__(/*! ./lodash */ "./node_modules/dagre/lib/lodash.js");
var Graph = __webpack_require__(/*! ./graphlib */ "./node_modules/dagre/lib/graphlib.js").Graph;

module.exports = {
  addDummyNode: addDummyNode,
  simplify: simplify,
  asNonCompoundGraph: asNonCompoundGraph,
  successorWeights: successorWeights,
  predecessorWeights: predecessorWeights,
  intersectRect: intersectRect,
  buildLayerMatrix: buildLayerMatrix,
  normalizeRanks: normalizeRanks,
  removeEmptyRanks: removeEmptyRanks,
  addBorderNode: addBorderNode,
  maxRank: maxRank,
  partition: partition,
  time: time,
  notime: notime
};

/*
 * Adds a dummy node to the graph and return v.
 */
function addDummyNode(g, type, attrs, name) {
  var v;
  do {
    v = _.uniqueId(name);
  } while (g.hasNode(v));

  attrs.dummy = type;
  g.setNode(v, attrs);
  return v;
}

/*
 * Returns a new graph with only simple edges. Handles aggregation of data
 * associated with multi-edges.
 */
function simplify(g) {
  var simplified = new Graph().setGraph(g.graph());
  _.forEach(g.nodes(), function(v) { simplified.setNode(v, g.node(v)); });
  _.forEach(g.edges(), function(e) {
    var simpleLabel = simplified.edge(e.v, e.w) || { weight: 0, minlen: 1 };
    var label = g.edge(e);
    simplified.setEdge(e.v, e.w, {
      weight: simpleLabel.weight + label.weight,
      minlen: Math.max(simpleLabel.minlen, label.minlen)
    });
  });
  return simplified;
}

function asNonCompoundGraph(g) {
  var simplified = new Graph({ multigraph: g.isMultigraph() }).setGraph(g.graph());
  _.forEach(g.nodes(), function(v) {
    if (!g.children(v).length) {
      simplified.setNode(v, g.node(v));
    }
  });
  _.forEach(g.edges(), function(e) {
    simplified.setEdge(e, g.edge(e));
  });
  return simplified;
}

function successorWeights(g) {
  var weightMap = _.map(g.nodes(), function(v) {
    var sucs = {};
    _.forEach(g.outEdges(v), function(e) {
      sucs[e.w] = (sucs[e.w] || 0) + g.edge(e).weight;
    });
    return sucs;
  });
  return _.zipObject(g.nodes(), weightMap);
}

function predecessorWeights(g) {
  var weightMap = _.map(g.nodes(), function(v) {
    var preds = {};
    _.forEach(g.inEdges(v), function(e) {
      preds[e.v] = (preds[e.v] || 0) + g.edge(e).weight;
    });
    return preds;
  });
  return _.zipObject(g.nodes(), weightMap);
}

/*
 * Finds where a line starting at point ({x, y}) would intersect a rectangle
 * ({x, y, width, height}) if it were pointing at the rectangle's center.
 */
function intersectRect(rect, point) {
  var x = rect.x;
  var y = rect.y;

  // Rectangle intersection algorithm from:
  // http://math.stackexchange.com/questions/108113/find-edge-between-two-boxes
  var dx = point.x - x;
  var dy = point.y - y;
  var w = rect.width / 2;
  var h = rect.height / 2;

  if (!dx && !dy) {
    throw new Error("Not possible to find intersection inside of the rectangle");
  }

  var sx, sy;
  if (Math.abs(dy) * w > Math.abs(dx) * h) {
    // Intersection is top or bottom of rect.
    if (dy < 0) {
      h = -h;
    }
    sx = h * dx / dy;
    sy = h;
  } else {
    // Intersection is left or right of rect.
    if (dx < 0) {
      w = -w;
    }
    sx = w;
    sy = w * dy / dx;
  }

  return { x: x + sx, y: y + sy };
}

/*
 * Given a DAG with each node assigned "rank" and "order" properties, this
 * function will produce a matrix with the ids of each node.
 */
function buildLayerMatrix(g) {
  var layering = _.map(_.range(maxRank(g) + 1), function() { return []; });
  _.forEach(g.nodes(), function(v) {
    var node = g.node(v);
    var rank = node.rank;
    if (!_.isUndefined(rank)) {
      layering[rank][node.order] = v;
    }
  });
  return layering;
}

/*
 * Adjusts the ranks for all nodes in the graph such that all nodes v have
 * rank(v) >= 0 and at least one node w has rank(w) = 0.
 */
function normalizeRanks(g) {
  var min = _.min(_.map(g.nodes(), function(v) { return g.node(v).rank; }));
  _.forEach(g.nodes(), function(v) {
    var node = g.node(v);
    if (_.has(node, "rank")) {
      node.rank -= min;
    }
  });
}

function removeEmptyRanks(g) {
  // Ranks may not start at 0, so we need to offset them
  var offset = _.min(_.map(g.nodes(), function(v) { return g.node(v).rank; }));

  var layers = [];
  _.forEach(g.nodes(), function(v) {
    var rank = g.node(v).rank - offset;
    if (!layers[rank]) {
      layers[rank] = [];
    }
    layers[rank].push(v);
  });

  var delta = 0;
  var nodeRankFactor = g.graph().nodeRankFactor;
  _.forEach(layers, function(vs, i) {
    if (_.isUndefined(vs) && i % nodeRankFactor !== 0) {
      --delta;
    } else if (delta) {
      _.forEach(vs, function(v) { g.node(v).rank += delta; });
    }
  });
}

function addBorderNode(g, prefix, rank, order) {
  var node = {
    width: 0,
    height: 0
  };
  if (arguments.length >= 4) {
    node.rank = rank;
    node.order = order;
  }
  return addDummyNode(g, "border", node, prefix);
}

function maxRank(g) {
  return _.max(_.map(g.nodes(), function(v) {
    var rank = g.node(v).rank;
    if (!_.isUndefined(rank)) {
      return rank;
    }
  }));
}

/*
 * Partition a collection into two groups: `lhs` and `rhs`. If the supplied
 * function returns true for an entry it goes into `lhs`. Otherwise it goes
 * into `rhs.
 */
function partition(collection, fn) {
  var result = { lhs: [], rhs: [] };
  _.forEach(collection, function(value) {
    if (fn(value)) {
      result.lhs.push(value);
    } else {
      result.rhs.push(value);
    }
  });
  return result;
}

/*
 * Returns a new function that wraps `fn` with a timer. The wrapper logs the
 * time it takes to execute the function.
 */
function time(name, fn) {
  var start = _.now();
  try {
    return fn();
  } finally {
    console.log(name + " time: " + (_.now() - start) + "ms");
  }
}

function notime(name, fn) {
  return fn();
}


/***/ }),

/***/ "./node_modules/dagre/lib/version.js":
/*!*******************************************!*\
  !*** ./node_modules/dagre/lib/version.js ***!
  \*******************************************/
/***/ ((module) => {

module.exports = "0.8.5";


/***/ }),

/***/ "./node_modules/graphlib/index.js":
/*!****************************************!*\
  !*** ./node_modules/graphlib/index.js ***!
  \****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/**
 * Copyright (c) 2014, Chris Pettitt
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 * list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 * this list of conditions and the following disclaimer in the documentation
 * and/or other materials provided with the distribution.
 *
 * 3. Neither the name of the copyright holder nor the names of its contributors
 * may be used to endorse or promote products derived from this software without
 * specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

var lib = __webpack_require__(/*! ./lib */ "./node_modules/graphlib/lib/index.js");

module.exports = {
  Graph: lib.Graph,
  json: __webpack_require__(/*! ./lib/json */ "./node_modules/graphlib/lib/json.js"),
  alg: __webpack_require__(/*! ./lib/alg */ "./node_modules/graphlib/lib/alg/index.js"),
  version: lib.version
};


/***/ }),

/***/ "./node_modules/graphlib/lib/alg/components.js":
/*!*****************************************************!*\
  !*** ./node_modules/graphlib/lib/alg/components.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var _ = __webpack_require__(/*! ../lodash */ "./node_modules/graphlib/lib/lodash.js");

module.exports = components;

function components(g) {
  var visited = {};
  var cmpts = [];
  var cmpt;

  function dfs(v) {
    if (_.has(visited, v)) return;
    visited[v] = true;
    cmpt.push(v);
    _.each(g.successors(v), dfs);
    _.each(g.predecessors(v), dfs);
  }

  _.each(g.nodes(), function(v) {
    cmpt = [];
    dfs(v);
    if (cmpt.length) {
      cmpts.push(cmpt);
    }
  });

  return cmpts;
}


/***/ }),

/***/ "./node_modules/graphlib/lib/alg/dfs.js":
/*!**********************************************!*\
  !*** ./node_modules/graphlib/lib/alg/dfs.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var _ = __webpack_require__(/*! ../lodash */ "./node_modules/graphlib/lib/lodash.js");

module.exports = dfs;

/*
 * A helper that preforms a pre- or post-order traversal on the input graph
 * and returns the nodes in the order they were visited. If the graph is
 * undirected then this algorithm will navigate using neighbors. If the graph
 * is directed then this algorithm will navigate using successors.
 *
 * Order must be one of "pre" or "post".
 */
function dfs(g, vs, order) {
  if (!_.isArray(vs)) {
    vs = [vs];
  }

  var navigation = (g.isDirected() ? g.successors : g.neighbors).bind(g);

  var acc = [];
  var visited = {};
  _.each(vs, function(v) {
    if (!g.hasNode(v)) {
      throw new Error("Graph does not have node: " + v);
    }

    doDfs(g, v, order === "post", visited, navigation, acc);
  });
  return acc;
}

function doDfs(g, v, postorder, visited, navigation, acc) {
  if (!_.has(visited, v)) {
    visited[v] = true;

    if (!postorder) { acc.push(v); }
    _.each(navigation(v), function(w) {
      doDfs(g, w, postorder, visited, navigation, acc);
    });
    if (postorder) { acc.push(v); }
  }
}


/***/ }),

/***/ "./node_modules/graphlib/lib/alg/dijkstra-all.js":
/*!*******************************************************!*\
  !*** ./node_modules/graphlib/lib/alg/dijkstra-all.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var dijkstra = __webpack_require__(/*! ./dijkstra */ "./node_modules/graphlib/lib/alg/dijkstra.js");
var _ = __webpack_require__(/*! ../lodash */ "./node_modules/graphlib/lib/lodash.js");

module.exports = dijkstraAll;

function dijkstraAll(g, weightFunc, edgeFunc) {
  return _.transform(g.nodes(), function(acc, v) {
    acc[v] = dijkstra(g, v, weightFunc, edgeFunc);
  }, {});
}


/***/ }),

/***/ "./node_modules/graphlib/lib/alg/dijkstra.js":
/*!***************************************************!*\
  !*** ./node_modules/graphlib/lib/alg/dijkstra.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var _ = __webpack_require__(/*! ../lodash */ "./node_modules/graphlib/lib/lodash.js");
var PriorityQueue = __webpack_require__(/*! ../data/priority-queue */ "./node_modules/graphlib/lib/data/priority-queue.js");

module.exports = dijkstra;

var DEFAULT_WEIGHT_FUNC = _.constant(1);

function dijkstra(g, source, weightFn, edgeFn) {
  return runDijkstra(g, String(source),
    weightFn || DEFAULT_WEIGHT_FUNC,
    edgeFn || function(v) { return g.outEdges(v); });
}

function runDijkstra(g, source, weightFn, edgeFn) {
  var results = {};
  var pq = new PriorityQueue();
  var v, vEntry;

  var updateNeighbors = function(edge) {
    var w = edge.v !== v ? edge.v : edge.w;
    var wEntry = results[w];
    var weight = weightFn(edge);
    var distance = vEntry.distance + weight;

    if (weight < 0) {
      throw new Error("dijkstra does not allow negative edge weights. " +
                      "Bad edge: " + edge + " Weight: " + weight);
    }

    if (distance < wEntry.distance) {
      wEntry.distance = distance;
      wEntry.predecessor = v;
      pq.decrease(w, distance);
    }
  };

  g.nodes().forEach(function(v) {
    var distance = v === source ? 0 : Number.POSITIVE_INFINITY;
    results[v] = { distance: distance };
    pq.add(v, distance);
  });

  while (pq.size() > 0) {
    v = pq.removeMin();
    vEntry = results[v];
    if (vEntry.distance === Number.POSITIVE_INFINITY) {
      break;
    }

    edgeFn(v).forEach(updateNeighbors);
  }

  return results;
}


/***/ }),

/***/ "./node_modules/graphlib/lib/alg/find-cycles.js":
/*!******************************************************!*\
  !*** ./node_modules/graphlib/lib/alg/find-cycles.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var _ = __webpack_require__(/*! ../lodash */ "./node_modules/graphlib/lib/lodash.js");
var tarjan = __webpack_require__(/*! ./tarjan */ "./node_modules/graphlib/lib/alg/tarjan.js");

module.exports = findCycles;

function findCycles(g) {
  return _.filter(tarjan(g), function(cmpt) {
    return cmpt.length > 1 || (cmpt.length === 1 && g.hasEdge(cmpt[0], cmpt[0]));
  });
}


/***/ }),

/***/ "./node_modules/graphlib/lib/alg/floyd-warshall.js":
/*!*********************************************************!*\
  !*** ./node_modules/graphlib/lib/alg/floyd-warshall.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var _ = __webpack_require__(/*! ../lodash */ "./node_modules/graphlib/lib/lodash.js");

module.exports = floydWarshall;

var DEFAULT_WEIGHT_FUNC = _.constant(1);

function floydWarshall(g, weightFn, edgeFn) {
  return runFloydWarshall(g,
    weightFn || DEFAULT_WEIGHT_FUNC,
    edgeFn || function(v) { return g.outEdges(v); });
}

function runFloydWarshall(g, weightFn, edgeFn) {
  var results = {};
  var nodes = g.nodes();

  nodes.forEach(function(v) {
    results[v] = {};
    results[v][v] = { distance: 0 };
    nodes.forEach(function(w) {
      if (v !== w) {
        results[v][w] = { distance: Number.POSITIVE_INFINITY };
      }
    });
    edgeFn(v).forEach(function(edge) {
      var w = edge.v === v ? edge.w : edge.v;
      var d = weightFn(edge);
      results[v][w] = { distance: d, predecessor: v };
    });
  });

  nodes.forEach(function(k) {
    var rowK = results[k];
    nodes.forEach(function(i) {
      var rowI = results[i];
      nodes.forEach(function(j) {
        var ik = rowI[k];
        var kj = rowK[j];
        var ij = rowI[j];
        var altDistance = ik.distance + kj.distance;
        if (altDistance < ij.distance) {
          ij.distance = altDistance;
          ij.predecessor = kj.predecessor;
        }
      });
    });
  });

  return results;
}


/***/ }),

/***/ "./node_modules/graphlib/lib/alg/index.js":
/*!************************************************!*\
  !*** ./node_modules/graphlib/lib/alg/index.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = {
  components: __webpack_require__(/*! ./components */ "./node_modules/graphlib/lib/alg/components.js"),
  dijkstra: __webpack_require__(/*! ./dijkstra */ "./node_modules/graphlib/lib/alg/dijkstra.js"),
  dijkstraAll: __webpack_require__(/*! ./dijkstra-all */ "./node_modules/graphlib/lib/alg/dijkstra-all.js"),
  findCycles: __webpack_require__(/*! ./find-cycles */ "./node_modules/graphlib/lib/alg/find-cycles.js"),
  floydWarshall: __webpack_require__(/*! ./floyd-warshall */ "./node_modules/graphlib/lib/alg/floyd-warshall.js"),
  isAcyclic: __webpack_require__(/*! ./is-acyclic */ "./node_modules/graphlib/lib/alg/is-acyclic.js"),
  postorder: __webpack_require__(/*! ./postorder */ "./node_modules/graphlib/lib/alg/postorder.js"),
  preorder: __webpack_require__(/*! ./preorder */ "./node_modules/graphlib/lib/alg/preorder.js"),
  prim: __webpack_require__(/*! ./prim */ "./node_modules/graphlib/lib/alg/prim.js"),
  tarjan: __webpack_require__(/*! ./tarjan */ "./node_modules/graphlib/lib/alg/tarjan.js"),
  topsort: __webpack_require__(/*! ./topsort */ "./node_modules/graphlib/lib/alg/topsort.js")
};


/***/ }),

/***/ "./node_modules/graphlib/lib/alg/is-acyclic.js":
/*!*****************************************************!*\
  !*** ./node_modules/graphlib/lib/alg/is-acyclic.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var topsort = __webpack_require__(/*! ./topsort */ "./node_modules/graphlib/lib/alg/topsort.js");

module.exports = isAcyclic;

function isAcyclic(g) {
  try {
    topsort(g);
  } catch (e) {
    if (e instanceof topsort.CycleException) {
      return false;
    }
    throw e;
  }
  return true;
}


/***/ }),

/***/ "./node_modules/graphlib/lib/alg/postorder.js":
/*!****************************************************!*\
  !*** ./node_modules/graphlib/lib/alg/postorder.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var dfs = __webpack_require__(/*! ./dfs */ "./node_modules/graphlib/lib/alg/dfs.js");

module.exports = postorder;

function postorder(g, vs) {
  return dfs(g, vs, "post");
}


/***/ }),

/***/ "./node_modules/graphlib/lib/alg/preorder.js":
/*!***************************************************!*\
  !*** ./node_modules/graphlib/lib/alg/preorder.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var dfs = __webpack_require__(/*! ./dfs */ "./node_modules/graphlib/lib/alg/dfs.js");

module.exports = preorder;

function preorder(g, vs) {
  return dfs(g, vs, "pre");
}


/***/ }),

/***/ "./node_modules/graphlib/lib/alg/prim.js":
/*!***********************************************!*\
  !*** ./node_modules/graphlib/lib/alg/prim.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var _ = __webpack_require__(/*! ../lodash */ "./node_modules/graphlib/lib/lodash.js");
var Graph = __webpack_require__(/*! ../graph */ "./node_modules/graphlib/lib/graph.js");
var PriorityQueue = __webpack_require__(/*! ../data/priority-queue */ "./node_modules/graphlib/lib/data/priority-queue.js");

module.exports = prim;

function prim(g, weightFunc) {
  var result = new Graph();
  var parents = {};
  var pq = new PriorityQueue();
  var v;

  function updateNeighbors(edge) {
    var w = edge.v === v ? edge.w : edge.v;
    var pri = pq.priority(w);
    if (pri !== undefined) {
      var edgeWeight = weightFunc(edge);
      if (edgeWeight < pri) {
        parents[w] = v;
        pq.decrease(w, edgeWeight);
      }
    }
  }

  if (g.nodeCount() === 0) {
    return result;
  }

  _.each(g.nodes(), function(v) {
    pq.add(v, Number.POSITIVE_INFINITY);
    result.setNode(v);
  });

  // Start from an arbitrary node
  pq.decrease(g.nodes()[0], 0);

  var init = false;
  while (pq.size() > 0) {
    v = pq.removeMin();
    if (_.has(parents, v)) {
      result.setEdge(v, parents[v]);
    } else if (init) {
      throw new Error("Input graph is not connected: " + g);
    } else {
      init = true;
    }

    g.nodeEdges(v).forEach(updateNeighbors);
  }

  return result;
}


/***/ }),

/***/ "./node_modules/graphlib/lib/alg/tarjan.js":
/*!*************************************************!*\
  !*** ./node_modules/graphlib/lib/alg/tarjan.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var _ = __webpack_require__(/*! ../lodash */ "./node_modules/graphlib/lib/lodash.js");

module.exports = tarjan;

function tarjan(g) {
  var index = 0;
  var stack = [];
  var visited = {}; // node id -> { onStack, lowlink, index }
  var results = [];

  function dfs(v) {
    var entry = visited[v] = {
      onStack: true,
      lowlink: index,
      index: index++
    };
    stack.push(v);

    g.successors(v).forEach(function(w) {
      if (!_.has(visited, w)) {
        dfs(w);
        entry.lowlink = Math.min(entry.lowlink, visited[w].lowlink);
      } else if (visited[w].onStack) {
        entry.lowlink = Math.min(entry.lowlink, visited[w].index);
      }
    });

    if (entry.lowlink === entry.index) {
      var cmpt = [];
      var w;
      do {
        w = stack.pop();
        visited[w].onStack = false;
        cmpt.push(w);
      } while (v !== w);
      results.push(cmpt);
    }
  }

  g.nodes().forEach(function(v) {
    if (!_.has(visited, v)) {
      dfs(v);
    }
  });

  return results;
}


/***/ }),

/***/ "./node_modules/graphlib/lib/alg/topsort.js":
/*!**************************************************!*\
  !*** ./node_modules/graphlib/lib/alg/topsort.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var _ = __webpack_require__(/*! ../lodash */ "./node_modules/graphlib/lib/lodash.js");

module.exports = topsort;
topsort.CycleException = CycleException;

function topsort(g) {
  var visited = {};
  var stack = {};
  var results = [];

  function visit(node) {
    if (_.has(stack, node)) {
      throw new CycleException();
    }

    if (!_.has(visited, node)) {
      stack[node] = true;
      visited[node] = true;
      _.each(g.predecessors(node), visit);
      delete stack[node];
      results.push(node);
    }
  }

  _.each(g.sinks(), visit);

  if (_.size(visited) !== g.nodeCount()) {
    throw new CycleException();
  }

  return results;
}

function CycleException() {}
CycleException.prototype = new Error(); // must be an instance of Error to pass testing

/***/ }),

/***/ "./node_modules/graphlib/lib/data/priority-queue.js":
/*!**********************************************************!*\
  !*** ./node_modules/graphlib/lib/data/priority-queue.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var _ = __webpack_require__(/*! ../lodash */ "./node_modules/graphlib/lib/lodash.js");

module.exports = PriorityQueue;

/**
 * A min-priority queue data structure. This algorithm is derived from Cormen,
 * et al., "Introduction to Algorithms". The basic idea of a min-priority
 * queue is that you can efficiently (in O(1) time) get the smallest key in
 * the queue. Adding and removing elements takes O(log n) time. A key can
 * have its priority decreased in O(log n) time.
 */
function PriorityQueue() {
  this._arr = [];
  this._keyIndices = {};
}

/**
 * Returns the number of elements in the queue. Takes `O(1)` time.
 */
PriorityQueue.prototype.size = function() {
  return this._arr.length;
};

/**
 * Returns the keys that are in the queue. Takes `O(n)` time.
 */
PriorityQueue.prototype.keys = function() {
  return this._arr.map(function(x) { return x.key; });
};

/**
 * Returns `true` if **key** is in the queue and `false` if not.
 */
PriorityQueue.prototype.has = function(key) {
  return _.has(this._keyIndices, key);
};

/**
 * Returns the priority for **key**. If **key** is not present in the queue
 * then this function returns `undefined`. Takes `O(1)` time.
 *
 * @param {Object} key
 */
PriorityQueue.prototype.priority = function(key) {
  var index = this._keyIndices[key];
  if (index !== undefined) {
    return this._arr[index].priority;
  }
};

/**
 * Returns the key for the minimum element in this queue. If the queue is
 * empty this function throws an Error. Takes `O(1)` time.
 */
PriorityQueue.prototype.min = function() {
  if (this.size() === 0) {
    throw new Error("Queue underflow");
  }
  return this._arr[0].key;
};

/**
 * Inserts a new key into the priority queue. If the key already exists in
 * the queue this function returns `false`; otherwise it will return `true`.
 * Takes `O(n)` time.
 *
 * @param {Object} key the key to add
 * @param {Number} priority the initial priority for the key
 */
PriorityQueue.prototype.add = function(key, priority) {
  var keyIndices = this._keyIndices;
  key = String(key);
  if (!_.has(keyIndices, key)) {
    var arr = this._arr;
    var index = arr.length;
    keyIndices[key] = index;
    arr.push({key: key, priority: priority});
    this._decrease(index);
    return true;
  }
  return false;
};

/**
 * Removes and returns the smallest key in the queue. Takes `O(log n)` time.
 */
PriorityQueue.prototype.removeMin = function() {
  this._swap(0, this._arr.length - 1);
  var min = this._arr.pop();
  delete this._keyIndices[min.key];
  this._heapify(0);
  return min.key;
};

/**
 * Decreases the priority for **key** to **priority**. If the new priority is
 * greater than the previous priority, this function will throw an Error.
 *
 * @param {Object} key the key for which to raise priority
 * @param {Number} priority the new priority for the key
 */
PriorityQueue.prototype.decrease = function(key, priority) {
  var index = this._keyIndices[key];
  if (priority > this._arr[index].priority) {
    throw new Error("New priority is greater than current priority. " +
        "Key: " + key + " Old: " + this._arr[index].priority + " New: " + priority);
  }
  this._arr[index].priority = priority;
  this._decrease(index);
};

PriorityQueue.prototype._heapify = function(i) {
  var arr = this._arr;
  var l = 2 * i;
  var r = l + 1;
  var largest = i;
  if (l < arr.length) {
    largest = arr[l].priority < arr[largest].priority ? l : largest;
    if (r < arr.length) {
      largest = arr[r].priority < arr[largest].priority ? r : largest;
    }
    if (largest !== i) {
      this._swap(i, largest);
      this._heapify(largest);
    }
  }
};

PriorityQueue.prototype._decrease = function(index) {
  var arr = this._arr;
  var priority = arr[index].priority;
  var parent;
  while (index !== 0) {
    parent = index >> 1;
    if (arr[parent].priority < priority) {
      break;
    }
    this._swap(index, parent);
    index = parent;
  }
};

PriorityQueue.prototype._swap = function(i, j) {
  var arr = this._arr;
  var keyIndices = this._keyIndices;
  var origArrI = arr[i];
  var origArrJ = arr[j];
  arr[i] = origArrJ;
  arr[j] = origArrI;
  keyIndices[origArrJ.key] = i;
  keyIndices[origArrI.key] = j;
};


/***/ }),

/***/ "./node_modules/graphlib/lib/graph.js":
/*!********************************************!*\
  !*** ./node_modules/graphlib/lib/graph.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var _ = __webpack_require__(/*! ./lodash */ "./node_modules/graphlib/lib/lodash.js");

module.exports = Graph;

var DEFAULT_EDGE_NAME = "\x00";
var GRAPH_NODE = "\x00";
var EDGE_KEY_DELIM = "\x01";

// Implementation notes:
//
//  * Node id query functions should return string ids for the nodes
//  * Edge id query functions should return an "edgeObj", edge object, that is
//    composed of enough information to uniquely identify an edge: {v, w, name}.
//  * Internally we use an "edgeId", a stringified form of the edgeObj, to
//    reference edges. This is because we need a performant way to look these
//    edges up and, object properties, which have string keys, are the closest
//    we're going to get to a performant hashtable in JavaScript.

function Graph(opts) {
  this._isDirected = _.has(opts, "directed") ? opts.directed : true;
  this._isMultigraph = _.has(opts, "multigraph") ? opts.multigraph : false;
  this._isCompound = _.has(opts, "compound") ? opts.compound : false;

  // Label for the graph itself
  this._label = undefined;

  // Defaults to be set when creating a new node
  this._defaultNodeLabelFn = _.constant(undefined);

  // Defaults to be set when creating a new edge
  this._defaultEdgeLabelFn = _.constant(undefined);

  // v -> label
  this._nodes = {};

  if (this._isCompound) {
    // v -> parent
    this._parent = {};

    // v -> children
    this._children = {};
    this._children[GRAPH_NODE] = {};
  }

  // v -> edgeObj
  this._in = {};

  // u -> v -> Number
  this._preds = {};

  // v -> edgeObj
  this._out = {};

  // v -> w -> Number
  this._sucs = {};

  // e -> edgeObj
  this._edgeObjs = {};

  // e -> label
  this._edgeLabels = {};
}

/* Number of nodes in the graph. Should only be changed by the implementation. */
Graph.prototype._nodeCount = 0;

/* Number of edges in the graph. Should only be changed by the implementation. */
Graph.prototype._edgeCount = 0;


/* === Graph functions ========= */

Graph.prototype.isDirected = function() {
  return this._isDirected;
};

Graph.prototype.isMultigraph = function() {
  return this._isMultigraph;
};

Graph.prototype.isCompound = function() {
  return this._isCompound;
};

Graph.prototype.setGraph = function(label) {
  this._label = label;
  return this;
};

Graph.prototype.graph = function() {
  return this._label;
};


/* === Node functions ========== */

Graph.prototype.setDefaultNodeLabel = function(newDefault) {
  if (!_.isFunction(newDefault)) {
    newDefault = _.constant(newDefault);
  }
  this._defaultNodeLabelFn = newDefault;
  return this;
};

Graph.prototype.nodeCount = function() {
  return this._nodeCount;
};

Graph.prototype.nodes = function() {
  return _.keys(this._nodes);
};

Graph.prototype.sources = function() {
  var self = this;
  return _.filter(this.nodes(), function(v) {
    return _.isEmpty(self._in[v]);
  });
};

Graph.prototype.sinks = function() {
  var self = this;
  return _.filter(this.nodes(), function(v) {
    return _.isEmpty(self._out[v]);
  });
};

Graph.prototype.setNodes = function(vs, value) {
  var args = arguments;
  var self = this;
  _.each(vs, function(v) {
    if (args.length > 1) {
      self.setNode(v, value);
    } else {
      self.setNode(v);
    }
  });
  return this;
};

Graph.prototype.setNode = function(v, value) {
  if (_.has(this._nodes, v)) {
    if (arguments.length > 1) {
      this._nodes[v] = value;
    }
    return this;
  }

  this._nodes[v] = arguments.length > 1 ? value : this._defaultNodeLabelFn(v);
  if (this._isCompound) {
    this._parent[v] = GRAPH_NODE;
    this._children[v] = {};
    this._children[GRAPH_NODE][v] = true;
  }
  this._in[v] = {};
  this._preds[v] = {};
  this._out[v] = {};
  this._sucs[v] = {};
  ++this._nodeCount;
  return this;
};

Graph.prototype.node = function(v) {
  return this._nodes[v];
};

Graph.prototype.hasNode = function(v) {
  return _.has(this._nodes, v);
};

Graph.prototype.removeNode =  function(v) {
  var self = this;
  if (_.has(this._nodes, v)) {
    var removeEdge = function(e) { self.removeEdge(self._edgeObjs[e]); };
    delete this._nodes[v];
    if (this._isCompound) {
      this._removeFromParentsChildList(v);
      delete this._parent[v];
      _.each(this.children(v), function(child) {
        self.setParent(child);
      });
      delete this._children[v];
    }
    _.each(_.keys(this._in[v]), removeEdge);
    delete this._in[v];
    delete this._preds[v];
    _.each(_.keys(this._out[v]), removeEdge);
    delete this._out[v];
    delete this._sucs[v];
    --this._nodeCount;
  }
  return this;
};

Graph.prototype.setParent = function(v, parent) {
  if (!this._isCompound) {
    throw new Error("Cannot set parent in a non-compound graph");
  }

  if (_.isUndefined(parent)) {
    parent = GRAPH_NODE;
  } else {
    // Coerce parent to string
    parent += "";
    for (var ancestor = parent;
      !_.isUndefined(ancestor);
      ancestor = this.parent(ancestor)) {
      if (ancestor === v) {
        throw new Error("Setting " + parent+ " as parent of " + v +
                        " would create a cycle");
      }
    }

    this.setNode(parent);
  }

  this.setNode(v);
  this._removeFromParentsChildList(v);
  this._parent[v] = parent;
  this._children[parent][v] = true;
  return this;
};

Graph.prototype._removeFromParentsChildList = function(v) {
  delete this._children[this._parent[v]][v];
};

Graph.prototype.parent = function(v) {
  if (this._isCompound) {
    var parent = this._parent[v];
    if (parent !== GRAPH_NODE) {
      return parent;
    }
  }
};

Graph.prototype.children = function(v) {
  if (_.isUndefined(v)) {
    v = GRAPH_NODE;
  }

  if (this._isCompound) {
    var children = this._children[v];
    if (children) {
      return _.keys(children);
    }
  } else if (v === GRAPH_NODE) {
    return this.nodes();
  } else if (this.hasNode(v)) {
    return [];
  }
};

Graph.prototype.predecessors = function(v) {
  var predsV = this._preds[v];
  if (predsV) {
    return _.keys(predsV);
  }
};

Graph.prototype.successors = function(v) {
  var sucsV = this._sucs[v];
  if (sucsV) {
    return _.keys(sucsV);
  }
};

Graph.prototype.neighbors = function(v) {
  var preds = this.predecessors(v);
  if (preds) {
    return _.union(preds, this.successors(v));
  }
};

Graph.prototype.isLeaf = function (v) {
  var neighbors;
  if (this.isDirected()) {
    neighbors = this.successors(v);
  } else {
    neighbors = this.neighbors(v);
  }
  return neighbors.length === 0;
};

Graph.prototype.filterNodes = function(filter) {
  var copy = new this.constructor({
    directed: this._isDirected,
    multigraph: this._isMultigraph,
    compound: this._isCompound
  });

  copy.setGraph(this.graph());

  var self = this;
  _.each(this._nodes, function(value, v) {
    if (filter(v)) {
      copy.setNode(v, value);
    }
  });

  _.each(this._edgeObjs, function(e) {
    if (copy.hasNode(e.v) && copy.hasNode(e.w)) {
      copy.setEdge(e, self.edge(e));
    }
  });

  var parents = {};
  function findParent(v) {
    var parent = self.parent(v);
    if (parent === undefined || copy.hasNode(parent)) {
      parents[v] = parent;
      return parent;
    } else if (parent in parents) {
      return parents[parent];
    } else {
      return findParent(parent);
    }
  }

  if (this._isCompound) {
    _.each(copy.nodes(), function(v) {
      copy.setParent(v, findParent(v));
    });
  }

  return copy;
};

/* === Edge functions ========== */

Graph.prototype.setDefaultEdgeLabel = function(newDefault) {
  if (!_.isFunction(newDefault)) {
    newDefault = _.constant(newDefault);
  }
  this._defaultEdgeLabelFn = newDefault;
  return this;
};

Graph.prototype.edgeCount = function() {
  return this._edgeCount;
};

Graph.prototype.edges = function() {
  return _.values(this._edgeObjs);
};

Graph.prototype.setPath = function(vs, value) {
  var self = this;
  var args = arguments;
  _.reduce(vs, function(v, w) {
    if (args.length > 1) {
      self.setEdge(v, w, value);
    } else {
      self.setEdge(v, w);
    }
    return w;
  });
  return this;
};

/*
 * setEdge(v, w, [value, [name]])
 * setEdge({ v, w, [name] }, [value])
 */
Graph.prototype.setEdge = function() {
  var v, w, name, value;
  var valueSpecified = false;
  var arg0 = arguments[0];

  if (typeof arg0 === "object" && arg0 !== null && "v" in arg0) {
    v = arg0.v;
    w = arg0.w;
    name = arg0.name;
    if (arguments.length === 2) {
      value = arguments[1];
      valueSpecified = true;
    }
  } else {
    v = arg0;
    w = arguments[1];
    name = arguments[3];
    if (arguments.length > 2) {
      value = arguments[2];
      valueSpecified = true;
    }
  }

  v = "" + v;
  w = "" + w;
  if (!_.isUndefined(name)) {
    name = "" + name;
  }

  var e = edgeArgsToId(this._isDirected, v, w, name);
  if (_.has(this._edgeLabels, e)) {
    if (valueSpecified) {
      this._edgeLabels[e] = value;
    }
    return this;
  }

  if (!_.isUndefined(name) && !this._isMultigraph) {
    throw new Error("Cannot set a named edge when isMultigraph = false");
  }

  // It didn't exist, so we need to create it.
  // First ensure the nodes exist.
  this.setNode(v);
  this.setNode(w);

  this._edgeLabels[e] = valueSpecified ? value : this._defaultEdgeLabelFn(v, w, name);

  var edgeObj = edgeArgsToObj(this._isDirected, v, w, name);
  // Ensure we add undirected edges in a consistent way.
  v = edgeObj.v;
  w = edgeObj.w;

  Object.freeze(edgeObj);
  this._edgeObjs[e] = edgeObj;
  incrementOrInitEntry(this._preds[w], v);
  incrementOrInitEntry(this._sucs[v], w);
  this._in[w][e] = edgeObj;
  this._out[v][e] = edgeObj;
  this._edgeCount++;
  return this;
};

Graph.prototype.edge = function(v, w, name) {
  var e = (arguments.length === 1
    ? edgeObjToId(this._isDirected, arguments[0])
    : edgeArgsToId(this._isDirected, v, w, name));
  return this._edgeLabels[e];
};

Graph.prototype.hasEdge = function(v, w, name) {
  var e = (arguments.length === 1
    ? edgeObjToId(this._isDirected, arguments[0])
    : edgeArgsToId(this._isDirected, v, w, name));
  return _.has(this._edgeLabels, e);
};

Graph.prototype.removeEdge = function(v, w, name) {
  var e = (arguments.length === 1
    ? edgeObjToId(this._isDirected, arguments[0])
    : edgeArgsToId(this._isDirected, v, w, name));
  var edge = this._edgeObjs[e];
  if (edge) {
    v = edge.v;
    w = edge.w;
    delete this._edgeLabels[e];
    delete this._edgeObjs[e];
    decrementOrRemoveEntry(this._preds[w], v);
    decrementOrRemoveEntry(this._sucs[v], w);
    delete this._in[w][e];
    delete this._out[v][e];
    this._edgeCount--;
  }
  return this;
};

Graph.prototype.inEdges = function(v, u) {
  var inV = this._in[v];
  if (inV) {
    var edges = _.values(inV);
    if (!u) {
      return edges;
    }
    return _.filter(edges, function(edge) { return edge.v === u; });
  }
};

Graph.prototype.outEdges = function(v, w) {
  var outV = this._out[v];
  if (outV) {
    var edges = _.values(outV);
    if (!w) {
      return edges;
    }
    return _.filter(edges, function(edge) { return edge.w === w; });
  }
};

Graph.prototype.nodeEdges = function(v, w) {
  var inEdges = this.inEdges(v, w);
  if (inEdges) {
    return inEdges.concat(this.outEdges(v, w));
  }
};

function incrementOrInitEntry(map, k) {
  if (map[k]) {
    map[k]++;
  } else {
    map[k] = 1;
  }
}

function decrementOrRemoveEntry(map, k) {
  if (!--map[k]) { delete map[k]; }
}

function edgeArgsToId(isDirected, v_, w_, name) {
  var v = "" + v_;
  var w = "" + w_;
  if (!isDirected && v > w) {
    var tmp = v;
    v = w;
    w = tmp;
  }
  return v + EDGE_KEY_DELIM + w + EDGE_KEY_DELIM +
             (_.isUndefined(name) ? DEFAULT_EDGE_NAME : name);
}

function edgeArgsToObj(isDirected, v_, w_, name) {
  var v = "" + v_;
  var w = "" + w_;
  if (!isDirected && v > w) {
    var tmp = v;
    v = w;
    w = tmp;
  }
  var edgeObj =  { v: v, w: w };
  if (name) {
    edgeObj.name = name;
  }
  return edgeObj;
}

function edgeObjToId(isDirected, edgeObj) {
  return edgeArgsToId(isDirected, edgeObj.v, edgeObj.w, edgeObj.name);
}


/***/ }),

/***/ "./node_modules/graphlib/lib/index.js":
/*!********************************************!*\
  !*** ./node_modules/graphlib/lib/index.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// Includes only the "core" of graphlib
module.exports = {
  Graph: __webpack_require__(/*! ./graph */ "./node_modules/graphlib/lib/graph.js"),
  version: __webpack_require__(/*! ./version */ "./node_modules/graphlib/lib/version.js")
};


/***/ }),

/***/ "./node_modules/graphlib/lib/json.js":
/*!*******************************************!*\
  !*** ./node_modules/graphlib/lib/json.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var _ = __webpack_require__(/*! ./lodash */ "./node_modules/graphlib/lib/lodash.js");
var Graph = __webpack_require__(/*! ./graph */ "./node_modules/graphlib/lib/graph.js");

module.exports = {
  write: write,
  read: read
};

function write(g) {
  var json = {
    options: {
      directed: g.isDirected(),
      multigraph: g.isMultigraph(),
      compound: g.isCompound()
    },
    nodes: writeNodes(g),
    edges: writeEdges(g)
  };
  if (!_.isUndefined(g.graph())) {
    json.value = _.clone(g.graph());
  }
  return json;
}

function writeNodes(g) {
  return _.map(g.nodes(), function(v) {
    var nodeValue = g.node(v);
    var parent = g.parent(v);
    var node = { v: v };
    if (!_.isUndefined(nodeValue)) {
      node.value = nodeValue;
    }
    if (!_.isUndefined(parent)) {
      node.parent = parent;
    }
    return node;
  });
}

function writeEdges(g) {
  return _.map(g.edges(), function(e) {
    var edgeValue = g.edge(e);
    var edge = { v: e.v, w: e.w };
    if (!_.isUndefined(e.name)) {
      edge.name = e.name;
    }
    if (!_.isUndefined(edgeValue)) {
      edge.value = edgeValue;
    }
    return edge;
  });
}

function read(json) {
  var g = new Graph(json.options).setGraph(json.value);
  _.each(json.nodes, function(entry) {
    g.setNode(entry.v, entry.value);
    if (entry.parent) {
      g.setParent(entry.v, entry.parent);
    }
  });
  _.each(json.edges, function(entry) {
    g.setEdge({ v: entry.v, w: entry.w, name: entry.name }, entry.value);
  });
  return g;
}


/***/ }),

/***/ "./node_modules/graphlib/lib/lodash.js":
/*!*********************************************!*\
  !*** ./node_modules/graphlib/lib/lodash.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/* global window */

var lodash;

if (true) {
  try {
    lodash = {
      clone: __webpack_require__(/*! lodash/clone */ "./node_modules/lodash/clone.js"),
      constant: __webpack_require__(/*! lodash/constant */ "./node_modules/lodash/constant.js"),
      each: __webpack_require__(/*! lodash/each */ "./node_modules/lodash/each.js"),
      filter: __webpack_require__(/*! lodash/filter */ "./node_modules/lodash/filter.js"),
      has:  __webpack_require__(/*! lodash/has */ "./node_modules/lodash/has.js"),
      isArray: __webpack_require__(/*! lodash/isArray */ "./node_modules/lodash/isArray.js"),
      isEmpty: __webpack_require__(/*! lodash/isEmpty */ "./node_modules/lodash/isEmpty.js"),
      isFunction: __webpack_require__(/*! lodash/isFunction */ "./node_modules/lodash/isFunction.js"),
      isUndefined: __webpack_require__(/*! lodash/isUndefined */ "./node_modules/lodash/isUndefined.js"),
      keys: __webpack_require__(/*! lodash/keys */ "./node_modules/lodash/keys.js"),
      map: __webpack_require__(/*! lodash/map */ "./node_modules/lodash/map.js"),
      reduce: __webpack_require__(/*! lodash/reduce */ "./node_modules/lodash/reduce.js"),
      size: __webpack_require__(/*! lodash/size */ "./node_modules/lodash/size.js"),
      transform: __webpack_require__(/*! lodash/transform */ "./node_modules/lodash/transform.js"),
      union: __webpack_require__(/*! lodash/union */ "./node_modules/lodash/union.js"),
      values: __webpack_require__(/*! lodash/values */ "./node_modules/lodash/values.js")
    };
  } catch (e) {
    // continue regardless of error
  }
}

if (!lodash) {
  lodash = window._;
}

module.exports = lodash;


/***/ }),

/***/ "./node_modules/graphlib/lib/version.js":
/*!**********************************************!*\
  !*** ./node_modules/graphlib/lib/version.js ***!
  \**********************************************/
/***/ ((module) => {

module.exports = '2.1.8';


/***/ }),

/***/ "./node_modules/lits-extras/lib/dependency-diag.js":
/*!*********************************************************!*\
  !*** ./node_modules/lits-extras/lib/dependency-diag.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.createDependencyDiagram = void 0;
const tt = __webpack_require__(/*! taitto */ "./node_modules/taitto/lib/index.js");
let svg = tt.svg;
let arrow = {
    closed: false,
    className: "arrow",
    positions: [tt.ArrowPos.Destination],
    width: 5,
    length: 5
};
async function loadDependencies(url) {
    let resp = await fetch(url);
    return resp.ok ? JSON.parse(await resp.text()) : null;
}
async function createDependencyDiagram(params, parent) {
    let pars = params.split(/\s+/);
    let url = pars[0];
    let filter = pars[1] && new RegExp(pars[1]);
    let redir = url.substr(0, url.lastIndexOf("/"));
    let dgraph = await loadDependencies(url);
    if (!dgraph)
        throw Error(`Could not load dependency graph from "${url}"`);
    else {
        let modules = Object.getOwnPropertyNames(dgraph)
            .filter(n => !filter || n.match(filter));
        let nodes = modules.map(name => {
            let module = dgraph[name];
            let node = {
                name,
                label: name,
                link: module.url ? redir + "/" + module.url : undefined,
                shape: (p, x, y, w, h) => svg.rect(p, x, y, w, h, 8, 8)
            };
            module.node = node;
            return node;
        });
        let edges = tt.edges(modules.map(name => dgraph[name].dependencies.filter(dep => dgraph[dep].node)
            .map(dep => [dgraph[name].node, dgraph[dep].node]))
            .reduce((a, b) => a.concat(b)), arrow);
        tt.digraph({
            nodes,
            edges,
            direction: 'LR',
            curvedEdges: true,
            ranksep: 16,
            nodesep: 32
        }, parent);
    }
}
exports.createDependencyDiagram = createDependencyDiagram;
//# sourceMappingURL=dependency-diag.js.map

/***/ }),

/***/ "./node_modules/lits-extras/lib/index.js":
/*!***********************************************!*\
  !*** ./node_modules/lits-extras/lib/index.js ***!
  \***********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
__exportStar(__webpack_require__(/*! ./dependency-diag */ "./node_modules/lits-extras/lib/dependency-diag.js"), exports);
__exportStar(__webpack_require__(/*! ./test-visualizer */ "./node_modules/lits-extras/lib/test-visualizer.js"), exports);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/lits-extras/lib/test-reporter.js":
/*!*******************************************************!*\
  !*** ./node_modules/lits-extras/lib/test-reporter.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.createReporter = void 0;
function createTest(name) {
    return {
        name,
        passes: 0,
        fails: 0,
        duration: 0,
        tests: [],
        assertions: []
    };
}
function createReporter(name, render) {
    let rootTest = createTest(name);
    let teststack = [rootTest];
    return async (stream) => {
        for await (let message of stream) {
            switch (message.type) {
                case "TEST_START" /* TEST_START */:
                    let newtest = createTest(message
                        .data.description);
                    teststack[teststack.length - 1].tests.push(newtest);
                    teststack.push(newtest);
                    break;
                case "TEST_END" /* TEST_END */:
                    let ztest = message.data;
                    let test = teststack.pop();
                    test.pass = ztest.pass;
                    test.passes = ztest.successCount;
                    test.fails = ztest.failureCount;
                    test.error = ztest.error;
                    test.duration = ztest.executionTime;
                    render(rootTest);
                    break;
                case "ASSERTION" /* ASSERTION */:
                    let zass = message.data;
                    teststack[teststack.length - 1].assertions.push({
                        name: zass.description,
                        pass: zass.pass
                    });
                    break;
                case "BAIL_OUT" /* BAIL_OUT */:
                    teststack[teststack.length - 1].error =
                        message.data;
                    render(rootTest);
                    break;
            }
        }
    };
}
exports.createReporter = createReporter;
//# sourceMappingURL=test-reporter.js.map

/***/ }),

/***/ "./node_modules/lits-extras/lib/test-visualizer.js":
/*!*********************************************************!*\
  !*** ./node_modules/lits-extras/lib/test-visualizer.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.runTests = void 0;
const tr = __webpack_require__(/*! ./test-reporter */ "./node_modules/lits-extras/lib/test-reporter.js");
const tester = __webpack_require__(/*! ./tester */ "./node_modules/lits-extras/lib/tester.js");
function runTests(params, parent) {
    window.addEventListener('load', () => tester.getHarness().report(tr.createReporter(params, status => {
        while (parent.firstChild)
            parent.firstChild.remove();
        parent.appendChild(testStatus(status));
    })));
}
exports.runTests = runTests;
function elem(tagName, cls, text) {
    let res = document.createElement(tagName);
    if (cls)
        res.classList.add(cls);
    if (text)
        res.innerText = text;
    return res;
}
function statusIcon(assertion) {
    return assertion.pass ? "" : "";
}
function testStyle(test) {
    return test.pass ? '#f8fff8' : '#fff8f8';
}
function testStatus(rootTest) {
    let vis = elem("div", "test-visualizer");
    vis.style.backgroundColor = testStyle(rootTest);
    let sum = elem("div", "summary", `${statusIcon(rootTest)} ${rootTest.name}`);
    sum.appendChild(elem("span", "count", `Pass: ${rootTest.passes}`));
    sum.appendChild(elem("span", "count", `Fail: ${rootTest.fails}`));
    vis.appendChild(sum);
    vis.appendChild(testList(rootTest.tests));
    return vis;
}
function testList(tests) {
    let lst = elem("ol", "test-list");
    for (let i = 0; i < tests.length; i++)
        lst.appendChild(test(tests[i]));
    return lst;
}
function assertion(assertion) {
    return elem("li", undefined, `${statusIcon(assertion)} ${assertion.name}`);
}
function assertions(assertions) {
    let det = elem("details");
    det.appendChild(elem("summary", undefined, `${assertions.length} assertions`));
    let ol = elem("ol");
    for (let i = 0; i < assertions.length; i++)
        ol.appendChild(assertion(assertions[i]));
    det.appendChild(ol);
    return det;
}
function test(test) {
    if (test.error)
        return bailedOutTest(test);
    let li = elem("li", undefined, `${statusIcon(test)} ${test.name} in ${test.duration}ms`);
    if (test.assertions)
        li.appendChild(assertions(test.assertions));
    if (test.tests)
        li.appendChild(testList(test.tests));
    return li;
}
function bailedOutTest(test) {
    let res = document.createElement("li");
    res.innerHTML =
        `${statusIcon(test)} ${test.name} threw <b>${test.error.name}</b> exception:
        <br/><b>${test.error.message}</b>
        <pre>${test.error.stack}</pre>`;
    return res;
}
//# sourceMappingURL=test-visualizer.js.map

/***/ }),

/***/ "./node_modules/lits-extras/lib/tester.js":
/*!************************************************!*\
  !*** ./node_modules/lits-extras/lib/tester.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.test = exports.getHarness = void 0;
const zora = __webpack_require__(/*! zora */ "./node_modules/zora/dist/bundle/index.js");
let harness = zora.createHarness();
if (typeof window === 'undefined')
    setTimeout(runTests, 0);
function getHarness() {
    return harness;
}
exports.getHarness = getHarness;
async function runTests() {
    try {
        await harness.report(zora.mochaTapLike);
    }
    catch (e) {
        harness.pass = false;
        if (e instanceof Error) {
            console.error(e.name + " exception thrown: " + e.message);
            console.error(e.stack);
        }
    }
    if (harness.pass)
        console.log('Tests PASSED');
    else
        console.log('Tests FAILED');
    process.exit(harness.pass ? 0 : 1);
}
function test(description, spec, options) {
    return harness.test(description, spec, options);
}
exports.test = test;
//# sourceMappingURL=tester.js.map

/***/ }),

/***/ "./node_modules/litscript/lib/visualizer.js":
/*!**************************************************!*\
  !*** ./node_modules/litscript/lib/visualizer.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.error = exports.console = exports.html = exports.registerVisualizer = void 0;
const visualizers = {};
/**
 * ## Registering Visualizers
 *
 * Before you can use a visualizer you need to register it using the function
 * below. Another step that is required is to specify the file where the
 * visualizer resides in the `codeFile` setting of the front matter. The code
 * file can import other modules and it might be written in JavaScript or
 * TypeScript. The bundler transpiles TS modules to JS and packs them to a
 * single file.
 */
function registerVisualizer(name, visual) {
    if (name.match(/\s/))
        throw SyntaxError(`Visualizer name "${name}" contains whitespace.`);
    visualizers[name] = visual;
}
exports.registerVisualizer = registerVisualizer;
/**
 * ## Creating Visualizers
 *
 * It is possible to create your visualizers from scratch by defining a
 * function that implements the signature defined above. However, usually
 * it is easier to use some of the helper functions defined below.
 *
 * The first helper creates a new HTML elemenent and places it under the
 * parent element. You can specify the type of the element, its attributes,
 * and a function that returns the content inside the element. The content
 * is assumed to contain a valid HTML string.
 */
function html(render, tag, attrs) {
    return (input, parent) => {
        let res = document.createElement(tag);
        for (let attr in attrs)
            if (attrs.hasOwnProperty(attr))
                res.setAttribute(attr, attrs[attr]);
        res.innerHTML = render(input);
        parent.appendChild(res);
    };
}
exports.html = html;
/**
 * Armed with the `html` function we can define more helpers that output
 * the result of a function in a specific element with a specific style.
 * The first one shows the result inside a `<pre>` tag which is styled
 * as console ouput.
 */
function console(output) {
    return html(output, 'pre', { class: "console" });
}
exports.console = console;
/**
 * The second function shows a styled error message. The style used here
 * is defined in the default template. It is possible also to import your
 * own style sheets (Less or CSS) in the code files you include. They are
 * separated, compiled and packed by the bundler.
 */
function error(message) {
    return html(_ => message, 'div', { class: "error" });
}
exports.error = error;
/**
 * ## Running Visualizers
 *
 * The `runVisualizer` function is exported as a property of the `window`
 * object. It runs the named visualizer with the given parameters. LiTScript
 * generates code that calls this function from a HTML page.
 */
async function runVisualizer(name, params, parentId) {
    let parent = document.getElementById(parentId);
    if (!parent)
        throw Error(`Visualizer parent id "${parentId}" not found.`);
    let visualize = visualizers[name] ||
        error(`Visualizer "${name}" is not registered.`);
    try {
        await visualize(params, parent);
    }
    catch (e) {
        error(`Exception thrown by visualizer "${name}".<BR/>
        ${e.toString()}`)("", parent);
    }
}
if (typeof window !== 'undefined')
    window["runVisualizer"] = runVisualizer;
//# sourceMappingURL=visualizer.js.map

/***/ }),

/***/ "./node_modules/lodash/_DataView.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/_DataView.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var getNative = __webpack_require__(/*! ./_getNative */ "./node_modules/lodash/_getNative.js"),
    root = __webpack_require__(/*! ./_root */ "./node_modules/lodash/_root.js");

/* Built-in method references that are verified to be native. */
var DataView = getNative(root, 'DataView');

module.exports = DataView;


/***/ }),

/***/ "./node_modules/lodash/_Hash.js":
/*!**************************************!*\
  !*** ./node_modules/lodash/_Hash.js ***!
  \**************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var hashClear = __webpack_require__(/*! ./_hashClear */ "./node_modules/lodash/_hashClear.js"),
    hashDelete = __webpack_require__(/*! ./_hashDelete */ "./node_modules/lodash/_hashDelete.js"),
    hashGet = __webpack_require__(/*! ./_hashGet */ "./node_modules/lodash/_hashGet.js"),
    hashHas = __webpack_require__(/*! ./_hashHas */ "./node_modules/lodash/_hashHas.js"),
    hashSet = __webpack_require__(/*! ./_hashSet */ "./node_modules/lodash/_hashSet.js");

/**
 * Creates a hash object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Hash(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

// Add methods to `Hash`.
Hash.prototype.clear = hashClear;
Hash.prototype['delete'] = hashDelete;
Hash.prototype.get = hashGet;
Hash.prototype.has = hashHas;
Hash.prototype.set = hashSet;

module.exports = Hash;


/***/ }),

/***/ "./node_modules/lodash/_ListCache.js":
/*!*******************************************!*\
  !*** ./node_modules/lodash/_ListCache.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var listCacheClear = __webpack_require__(/*! ./_listCacheClear */ "./node_modules/lodash/_listCacheClear.js"),
    listCacheDelete = __webpack_require__(/*! ./_listCacheDelete */ "./node_modules/lodash/_listCacheDelete.js"),
    listCacheGet = __webpack_require__(/*! ./_listCacheGet */ "./node_modules/lodash/_listCacheGet.js"),
    listCacheHas = __webpack_require__(/*! ./_listCacheHas */ "./node_modules/lodash/_listCacheHas.js"),
    listCacheSet = __webpack_require__(/*! ./_listCacheSet */ "./node_modules/lodash/_listCacheSet.js");

/**
 * Creates an list cache object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function ListCache(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

// Add methods to `ListCache`.
ListCache.prototype.clear = listCacheClear;
ListCache.prototype['delete'] = listCacheDelete;
ListCache.prototype.get = listCacheGet;
ListCache.prototype.has = listCacheHas;
ListCache.prototype.set = listCacheSet;

module.exports = ListCache;


/***/ }),

/***/ "./node_modules/lodash/_Map.js":
/*!*************************************!*\
  !*** ./node_modules/lodash/_Map.js ***!
  \*************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var getNative = __webpack_require__(/*! ./_getNative */ "./node_modules/lodash/_getNative.js"),
    root = __webpack_require__(/*! ./_root */ "./node_modules/lodash/_root.js");

/* Built-in method references that are verified to be native. */
var Map = getNative(root, 'Map');

module.exports = Map;


/***/ }),

/***/ "./node_modules/lodash/_MapCache.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/_MapCache.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var mapCacheClear = __webpack_require__(/*! ./_mapCacheClear */ "./node_modules/lodash/_mapCacheClear.js"),
    mapCacheDelete = __webpack_require__(/*! ./_mapCacheDelete */ "./node_modules/lodash/_mapCacheDelete.js"),
    mapCacheGet = __webpack_require__(/*! ./_mapCacheGet */ "./node_modules/lodash/_mapCacheGet.js"),
    mapCacheHas = __webpack_require__(/*! ./_mapCacheHas */ "./node_modules/lodash/_mapCacheHas.js"),
    mapCacheSet = __webpack_require__(/*! ./_mapCacheSet */ "./node_modules/lodash/_mapCacheSet.js");

/**
 * Creates a map cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function MapCache(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

// Add methods to `MapCache`.
MapCache.prototype.clear = mapCacheClear;
MapCache.prototype['delete'] = mapCacheDelete;
MapCache.prototype.get = mapCacheGet;
MapCache.prototype.has = mapCacheHas;
MapCache.prototype.set = mapCacheSet;

module.exports = MapCache;


/***/ }),

/***/ "./node_modules/lodash/_Promise.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/_Promise.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var getNative = __webpack_require__(/*! ./_getNative */ "./node_modules/lodash/_getNative.js"),
    root = __webpack_require__(/*! ./_root */ "./node_modules/lodash/_root.js");

/* Built-in method references that are verified to be native. */
var Promise = getNative(root, 'Promise');

module.exports = Promise;


/***/ }),

/***/ "./node_modules/lodash/_Set.js":
/*!*************************************!*\
  !*** ./node_modules/lodash/_Set.js ***!
  \*************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var getNative = __webpack_require__(/*! ./_getNative */ "./node_modules/lodash/_getNative.js"),
    root = __webpack_require__(/*! ./_root */ "./node_modules/lodash/_root.js");

/* Built-in method references that are verified to be native. */
var Set = getNative(root, 'Set');

module.exports = Set;


/***/ }),

/***/ "./node_modules/lodash/_SetCache.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/_SetCache.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var MapCache = __webpack_require__(/*! ./_MapCache */ "./node_modules/lodash/_MapCache.js"),
    setCacheAdd = __webpack_require__(/*! ./_setCacheAdd */ "./node_modules/lodash/_setCacheAdd.js"),
    setCacheHas = __webpack_require__(/*! ./_setCacheHas */ "./node_modules/lodash/_setCacheHas.js");

/**
 *
 * Creates an array cache object to store unique values.
 *
 * @private
 * @constructor
 * @param {Array} [values] The values to cache.
 */
function SetCache(values) {
  var index = -1,
      length = values == null ? 0 : values.length;

  this.__data__ = new MapCache;
  while (++index < length) {
    this.add(values[index]);
  }
}

// Add methods to `SetCache`.
SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
SetCache.prototype.has = setCacheHas;

module.exports = SetCache;


/***/ }),

/***/ "./node_modules/lodash/_Stack.js":
/*!***************************************!*\
  !*** ./node_modules/lodash/_Stack.js ***!
  \***************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var ListCache = __webpack_require__(/*! ./_ListCache */ "./node_modules/lodash/_ListCache.js"),
    stackClear = __webpack_require__(/*! ./_stackClear */ "./node_modules/lodash/_stackClear.js"),
    stackDelete = __webpack_require__(/*! ./_stackDelete */ "./node_modules/lodash/_stackDelete.js"),
    stackGet = __webpack_require__(/*! ./_stackGet */ "./node_modules/lodash/_stackGet.js"),
    stackHas = __webpack_require__(/*! ./_stackHas */ "./node_modules/lodash/_stackHas.js"),
    stackSet = __webpack_require__(/*! ./_stackSet */ "./node_modules/lodash/_stackSet.js");

/**
 * Creates a stack cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Stack(entries) {
  var data = this.__data__ = new ListCache(entries);
  this.size = data.size;
}

// Add methods to `Stack`.
Stack.prototype.clear = stackClear;
Stack.prototype['delete'] = stackDelete;
Stack.prototype.get = stackGet;
Stack.prototype.has = stackHas;
Stack.prototype.set = stackSet;

module.exports = Stack;


/***/ }),

/***/ "./node_modules/lodash/_Symbol.js":
/*!****************************************!*\
  !*** ./node_modules/lodash/_Symbol.js ***!
  \****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var root = __webpack_require__(/*! ./_root */ "./node_modules/lodash/_root.js");

/** Built-in value references. */
var Symbol = root.Symbol;

module.exports = Symbol;


/***/ }),

/***/ "./node_modules/lodash/_Uint8Array.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_Uint8Array.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var root = __webpack_require__(/*! ./_root */ "./node_modules/lodash/_root.js");

/** Built-in value references. */
var Uint8Array = root.Uint8Array;

module.exports = Uint8Array;


/***/ }),

/***/ "./node_modules/lodash/_WeakMap.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/_WeakMap.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var getNative = __webpack_require__(/*! ./_getNative */ "./node_modules/lodash/_getNative.js"),
    root = __webpack_require__(/*! ./_root */ "./node_modules/lodash/_root.js");

/* Built-in method references that are verified to be native. */
var WeakMap = getNative(root, 'WeakMap');

module.exports = WeakMap;


/***/ }),

/***/ "./node_modules/lodash/_apply.js":
/*!***************************************!*\
  !*** ./node_modules/lodash/_apply.js ***!
  \***************************************/
/***/ ((module) => {

/**
 * A faster alternative to `Function#apply`, this function invokes `func`
 * with the `this` binding of `thisArg` and the arguments of `args`.
 *
 * @private
 * @param {Function} func The function to invoke.
 * @param {*} thisArg The `this` binding of `func`.
 * @param {Array} args The arguments to invoke `func` with.
 * @returns {*} Returns the result of `func`.
 */
function apply(func, thisArg, args) {
  switch (args.length) {
    case 0: return func.call(thisArg);
    case 1: return func.call(thisArg, args[0]);
    case 2: return func.call(thisArg, args[0], args[1]);
    case 3: return func.call(thisArg, args[0], args[1], args[2]);
  }
  return func.apply(thisArg, args);
}

module.exports = apply;


/***/ }),

/***/ "./node_modules/lodash/_arrayEach.js":
/*!*******************************************!*\
  !*** ./node_modules/lodash/_arrayEach.js ***!
  \*******************************************/
/***/ ((module) => {

/**
 * A specialized version of `_.forEach` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns `array`.
 */
function arrayEach(array, iteratee) {
  var index = -1,
      length = array == null ? 0 : array.length;

  while (++index < length) {
    if (iteratee(array[index], index, array) === false) {
      break;
    }
  }
  return array;
}

module.exports = arrayEach;


/***/ }),

/***/ "./node_modules/lodash/_arrayFilter.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash/_arrayFilter.js ***!
  \*********************************************/
/***/ ((module) => {

/**
 * A specialized version of `_.filter` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} predicate The function invoked per iteration.
 * @returns {Array} Returns the new filtered array.
 */
function arrayFilter(array, predicate) {
  var index = -1,
      length = array == null ? 0 : array.length,
      resIndex = 0,
      result = [];

  while (++index < length) {
    var value = array[index];
    if (predicate(value, index, array)) {
      result[resIndex++] = value;
    }
  }
  return result;
}

module.exports = arrayFilter;


/***/ }),

/***/ "./node_modules/lodash/_arrayIncludes.js":
/*!***********************************************!*\
  !*** ./node_modules/lodash/_arrayIncludes.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseIndexOf = __webpack_require__(/*! ./_baseIndexOf */ "./node_modules/lodash/_baseIndexOf.js");

/**
 * A specialized version of `_.includes` for arrays without support for
 * specifying an index to search from.
 *
 * @private
 * @param {Array} [array] The array to inspect.
 * @param {*} target The value to search for.
 * @returns {boolean} Returns `true` if `target` is found, else `false`.
 */
function arrayIncludes(array, value) {
  var length = array == null ? 0 : array.length;
  return !!length && baseIndexOf(array, value, 0) > -1;
}

module.exports = arrayIncludes;


/***/ }),

/***/ "./node_modules/lodash/_arrayIncludesWith.js":
/*!***************************************************!*\
  !*** ./node_modules/lodash/_arrayIncludesWith.js ***!
  \***************************************************/
/***/ ((module) => {

/**
 * This function is like `arrayIncludes` except that it accepts a comparator.
 *
 * @private
 * @param {Array} [array] The array to inspect.
 * @param {*} target The value to search for.
 * @param {Function} comparator The comparator invoked per element.
 * @returns {boolean} Returns `true` if `target` is found, else `false`.
 */
function arrayIncludesWith(array, value, comparator) {
  var index = -1,
      length = array == null ? 0 : array.length;

  while (++index < length) {
    if (comparator(value, array[index])) {
      return true;
    }
  }
  return false;
}

module.exports = arrayIncludesWith;


/***/ }),

/***/ "./node_modules/lodash/_arrayLikeKeys.js":
/*!***********************************************!*\
  !*** ./node_modules/lodash/_arrayLikeKeys.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseTimes = __webpack_require__(/*! ./_baseTimes */ "./node_modules/lodash/_baseTimes.js"),
    isArguments = __webpack_require__(/*! ./isArguments */ "./node_modules/lodash/isArguments.js"),
    isArray = __webpack_require__(/*! ./isArray */ "./node_modules/lodash/isArray.js"),
    isBuffer = __webpack_require__(/*! ./isBuffer */ "./node_modules/lodash/isBuffer.js"),
    isIndex = __webpack_require__(/*! ./_isIndex */ "./node_modules/lodash/_isIndex.js"),
    isTypedArray = __webpack_require__(/*! ./isTypedArray */ "./node_modules/lodash/isTypedArray.js");

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Creates an array of the enumerable property names of the array-like `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @param {boolean} inherited Specify returning inherited property names.
 * @returns {Array} Returns the array of property names.
 */
function arrayLikeKeys(value, inherited) {
  var isArr = isArray(value),
      isArg = !isArr && isArguments(value),
      isBuff = !isArr && !isArg && isBuffer(value),
      isType = !isArr && !isArg && !isBuff && isTypedArray(value),
      skipIndexes = isArr || isArg || isBuff || isType,
      result = skipIndexes ? baseTimes(value.length, String) : [],
      length = result.length;

  for (var key in value) {
    if ((inherited || hasOwnProperty.call(value, key)) &&
        !(skipIndexes && (
           // Safari 9 has enumerable `arguments.length` in strict mode.
           key == 'length' ||
           // Node.js 0.10 has enumerable non-index properties on buffers.
           (isBuff && (key == 'offset' || key == 'parent')) ||
           // PhantomJS 2 has enumerable non-index properties on typed arrays.
           (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||
           // Skip index properties.
           isIndex(key, length)
        ))) {
      result.push(key);
    }
  }
  return result;
}

module.exports = arrayLikeKeys;


/***/ }),

/***/ "./node_modules/lodash/_arrayMap.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/_arrayMap.js ***!
  \******************************************/
/***/ ((module) => {

/**
 * A specialized version of `_.map` for arrays without support for iteratee
 * shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the new mapped array.
 */
function arrayMap(array, iteratee) {
  var index = -1,
      length = array == null ? 0 : array.length,
      result = Array(length);

  while (++index < length) {
    result[index] = iteratee(array[index], index, array);
  }
  return result;
}

module.exports = arrayMap;


/***/ }),

/***/ "./node_modules/lodash/_arrayPush.js":
/*!*******************************************!*\
  !*** ./node_modules/lodash/_arrayPush.js ***!
  \*******************************************/
/***/ ((module) => {

/**
 * Appends the elements of `values` to `array`.
 *
 * @private
 * @param {Array} array The array to modify.
 * @param {Array} values The values to append.
 * @returns {Array} Returns `array`.
 */
function arrayPush(array, values) {
  var index = -1,
      length = values.length,
      offset = array.length;

  while (++index < length) {
    array[offset + index] = values[index];
  }
  return array;
}

module.exports = arrayPush;


/***/ }),

/***/ "./node_modules/lodash/_arrayReduce.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash/_arrayReduce.js ***!
  \*********************************************/
/***/ ((module) => {

/**
 * A specialized version of `_.reduce` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @param {*} [accumulator] The initial value.
 * @param {boolean} [initAccum] Specify using the first element of `array` as
 *  the initial value.
 * @returns {*} Returns the accumulated value.
 */
function arrayReduce(array, iteratee, accumulator, initAccum) {
  var index = -1,
      length = array == null ? 0 : array.length;

  if (initAccum && length) {
    accumulator = array[++index];
  }
  while (++index < length) {
    accumulator = iteratee(accumulator, array[index], index, array);
  }
  return accumulator;
}

module.exports = arrayReduce;


/***/ }),

/***/ "./node_modules/lodash/_arraySome.js":
/*!*******************************************!*\
  !*** ./node_modules/lodash/_arraySome.js ***!
  \*******************************************/
/***/ ((module) => {

/**
 * A specialized version of `_.some` for arrays without support for iteratee
 * shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} predicate The function invoked per iteration.
 * @returns {boolean} Returns `true` if any element passes the predicate check,
 *  else `false`.
 */
function arraySome(array, predicate) {
  var index = -1,
      length = array == null ? 0 : array.length;

  while (++index < length) {
    if (predicate(array[index], index, array)) {
      return true;
    }
  }
  return false;
}

module.exports = arraySome;


/***/ }),

/***/ "./node_modules/lodash/_asciiSize.js":
/*!*******************************************!*\
  !*** ./node_modules/lodash/_asciiSize.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseProperty = __webpack_require__(/*! ./_baseProperty */ "./node_modules/lodash/_baseProperty.js");

/**
 * Gets the size of an ASCII `string`.
 *
 * @private
 * @param {string} string The string inspect.
 * @returns {number} Returns the string size.
 */
var asciiSize = baseProperty('length');

module.exports = asciiSize;


/***/ }),

/***/ "./node_modules/lodash/_assignMergeValue.js":
/*!**************************************************!*\
  !*** ./node_modules/lodash/_assignMergeValue.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseAssignValue = __webpack_require__(/*! ./_baseAssignValue */ "./node_modules/lodash/_baseAssignValue.js"),
    eq = __webpack_require__(/*! ./eq */ "./node_modules/lodash/eq.js");

/**
 * This function is like `assignValue` except that it doesn't assign
 * `undefined` values.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */
function assignMergeValue(object, key, value) {
  if ((value !== undefined && !eq(object[key], value)) ||
      (value === undefined && !(key in object))) {
    baseAssignValue(object, key, value);
  }
}

module.exports = assignMergeValue;


/***/ }),

/***/ "./node_modules/lodash/_assignValue.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash/_assignValue.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseAssignValue = __webpack_require__(/*! ./_baseAssignValue */ "./node_modules/lodash/_baseAssignValue.js"),
    eq = __webpack_require__(/*! ./eq */ "./node_modules/lodash/eq.js");

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Assigns `value` to `key` of `object` if the existing value is not equivalent
 * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * for equality comparisons.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */
function assignValue(object, key, value) {
  var objValue = object[key];
  if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) ||
      (value === undefined && !(key in object))) {
    baseAssignValue(object, key, value);
  }
}

module.exports = assignValue;


/***/ }),

/***/ "./node_modules/lodash/_assocIndexOf.js":
/*!**********************************************!*\
  !*** ./node_modules/lodash/_assocIndexOf.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var eq = __webpack_require__(/*! ./eq */ "./node_modules/lodash/eq.js");

/**
 * Gets the index at which the `key` is found in `array` of key-value pairs.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} key The key to search for.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function assocIndexOf(array, key) {
  var length = array.length;
  while (length--) {
    if (eq(array[length][0], key)) {
      return length;
    }
  }
  return -1;
}

module.exports = assocIndexOf;


/***/ }),

/***/ "./node_modules/lodash/_baseAssign.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_baseAssign.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var copyObject = __webpack_require__(/*! ./_copyObject */ "./node_modules/lodash/_copyObject.js"),
    keys = __webpack_require__(/*! ./keys */ "./node_modules/lodash/keys.js");

/**
 * The base implementation of `_.assign` without support for multiple sources
 * or `customizer` functions.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @returns {Object} Returns `object`.
 */
function baseAssign(object, source) {
  return object && copyObject(source, keys(source), object);
}

module.exports = baseAssign;


/***/ }),

/***/ "./node_modules/lodash/_baseAssignIn.js":
/*!**********************************************!*\
  !*** ./node_modules/lodash/_baseAssignIn.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var copyObject = __webpack_require__(/*! ./_copyObject */ "./node_modules/lodash/_copyObject.js"),
    keysIn = __webpack_require__(/*! ./keysIn */ "./node_modules/lodash/keysIn.js");

/**
 * The base implementation of `_.assignIn` without support for multiple sources
 * or `customizer` functions.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @returns {Object} Returns `object`.
 */
function baseAssignIn(object, source) {
  return object && copyObject(source, keysIn(source), object);
}

module.exports = baseAssignIn;


/***/ }),

/***/ "./node_modules/lodash/_baseAssignValue.js":
/*!*************************************************!*\
  !*** ./node_modules/lodash/_baseAssignValue.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var defineProperty = __webpack_require__(/*! ./_defineProperty */ "./node_modules/lodash/_defineProperty.js");

/**
 * The base implementation of `assignValue` and `assignMergeValue` without
 * value checks.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */
function baseAssignValue(object, key, value) {
  if (key == '__proto__' && defineProperty) {
    defineProperty(object, key, {
      'configurable': true,
      'enumerable': true,
      'value': value,
      'writable': true
    });
  } else {
    object[key] = value;
  }
}

module.exports = baseAssignValue;


/***/ }),

/***/ "./node_modules/lodash/_baseClone.js":
/*!*******************************************!*\
  !*** ./node_modules/lodash/_baseClone.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var Stack = __webpack_require__(/*! ./_Stack */ "./node_modules/lodash/_Stack.js"),
    arrayEach = __webpack_require__(/*! ./_arrayEach */ "./node_modules/lodash/_arrayEach.js"),
    assignValue = __webpack_require__(/*! ./_assignValue */ "./node_modules/lodash/_assignValue.js"),
    baseAssign = __webpack_require__(/*! ./_baseAssign */ "./node_modules/lodash/_baseAssign.js"),
    baseAssignIn = __webpack_require__(/*! ./_baseAssignIn */ "./node_modules/lodash/_baseAssignIn.js"),
    cloneBuffer = __webpack_require__(/*! ./_cloneBuffer */ "./node_modules/lodash/_cloneBuffer.js"),
    copyArray = __webpack_require__(/*! ./_copyArray */ "./node_modules/lodash/_copyArray.js"),
    copySymbols = __webpack_require__(/*! ./_copySymbols */ "./node_modules/lodash/_copySymbols.js"),
    copySymbolsIn = __webpack_require__(/*! ./_copySymbolsIn */ "./node_modules/lodash/_copySymbolsIn.js"),
    getAllKeys = __webpack_require__(/*! ./_getAllKeys */ "./node_modules/lodash/_getAllKeys.js"),
    getAllKeysIn = __webpack_require__(/*! ./_getAllKeysIn */ "./node_modules/lodash/_getAllKeysIn.js"),
    getTag = __webpack_require__(/*! ./_getTag */ "./node_modules/lodash/_getTag.js"),
    initCloneArray = __webpack_require__(/*! ./_initCloneArray */ "./node_modules/lodash/_initCloneArray.js"),
    initCloneByTag = __webpack_require__(/*! ./_initCloneByTag */ "./node_modules/lodash/_initCloneByTag.js"),
    initCloneObject = __webpack_require__(/*! ./_initCloneObject */ "./node_modules/lodash/_initCloneObject.js"),
    isArray = __webpack_require__(/*! ./isArray */ "./node_modules/lodash/isArray.js"),
    isBuffer = __webpack_require__(/*! ./isBuffer */ "./node_modules/lodash/isBuffer.js"),
    isMap = __webpack_require__(/*! ./isMap */ "./node_modules/lodash/isMap.js"),
    isObject = __webpack_require__(/*! ./isObject */ "./node_modules/lodash/isObject.js"),
    isSet = __webpack_require__(/*! ./isSet */ "./node_modules/lodash/isSet.js"),
    keys = __webpack_require__(/*! ./keys */ "./node_modules/lodash/keys.js"),
    keysIn = __webpack_require__(/*! ./keysIn */ "./node_modules/lodash/keysIn.js");

/** Used to compose bitmasks for cloning. */
var CLONE_DEEP_FLAG = 1,
    CLONE_FLAT_FLAG = 2,
    CLONE_SYMBOLS_FLAG = 4;

/** `Object#toString` result references. */
var argsTag = '[object Arguments]',
    arrayTag = '[object Array]',
    boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    errorTag = '[object Error]',
    funcTag = '[object Function]',
    genTag = '[object GeneratorFunction]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    objectTag = '[object Object]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    symbolTag = '[object Symbol]',
    weakMapTag = '[object WeakMap]';

var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]',
    float32Tag = '[object Float32Array]',
    float64Tag = '[object Float64Array]',
    int8Tag = '[object Int8Array]',
    int16Tag = '[object Int16Array]',
    int32Tag = '[object Int32Array]',
    uint8Tag = '[object Uint8Array]',
    uint8ClampedTag = '[object Uint8ClampedArray]',
    uint16Tag = '[object Uint16Array]',
    uint32Tag = '[object Uint32Array]';

/** Used to identify `toStringTag` values supported by `_.clone`. */
var cloneableTags = {};
cloneableTags[argsTag] = cloneableTags[arrayTag] =
cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] =
cloneableTags[boolTag] = cloneableTags[dateTag] =
cloneableTags[float32Tag] = cloneableTags[float64Tag] =
cloneableTags[int8Tag] = cloneableTags[int16Tag] =
cloneableTags[int32Tag] = cloneableTags[mapTag] =
cloneableTags[numberTag] = cloneableTags[objectTag] =
cloneableTags[regexpTag] = cloneableTags[setTag] =
cloneableTags[stringTag] = cloneableTags[symbolTag] =
cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] =
cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
cloneableTags[errorTag] = cloneableTags[funcTag] =
cloneableTags[weakMapTag] = false;

/**
 * The base implementation of `_.clone` and `_.cloneDeep` which tracks
 * traversed objects.
 *
 * @private
 * @param {*} value The value to clone.
 * @param {boolean} bitmask The bitmask flags.
 *  1 - Deep clone
 *  2 - Flatten inherited properties
 *  4 - Clone symbols
 * @param {Function} [customizer] The function to customize cloning.
 * @param {string} [key] The key of `value`.
 * @param {Object} [object] The parent object of `value`.
 * @param {Object} [stack] Tracks traversed objects and their clone counterparts.
 * @returns {*} Returns the cloned value.
 */
function baseClone(value, bitmask, customizer, key, object, stack) {
  var result,
      isDeep = bitmask & CLONE_DEEP_FLAG,
      isFlat = bitmask & CLONE_FLAT_FLAG,
      isFull = bitmask & CLONE_SYMBOLS_FLAG;

  if (customizer) {
    result = object ? customizer(value, key, object, stack) : customizer(value);
  }
  if (result !== undefined) {
    return result;
  }
  if (!isObject(value)) {
    return value;
  }
  var isArr = isArray(value);
  if (isArr) {
    result = initCloneArray(value);
    if (!isDeep) {
      return copyArray(value, result);
    }
  } else {
    var tag = getTag(value),
        isFunc = tag == funcTag || tag == genTag;

    if (isBuffer(value)) {
      return cloneBuffer(value, isDeep);
    }
    if (tag == objectTag || tag == argsTag || (isFunc && !object)) {
      result = (isFlat || isFunc) ? {} : initCloneObject(value);
      if (!isDeep) {
        return isFlat
          ? copySymbolsIn(value, baseAssignIn(result, value))
          : copySymbols(value, baseAssign(result, value));
      }
    } else {
      if (!cloneableTags[tag]) {
        return object ? value : {};
      }
      result = initCloneByTag(value, tag, isDeep);
    }
  }
  // Check for circular references and return its corresponding clone.
  stack || (stack = new Stack);
  var stacked = stack.get(value);
  if (stacked) {
    return stacked;
  }
  stack.set(value, result);

  if (isSet(value)) {
    value.forEach(function(subValue) {
      result.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
    });
  } else if (isMap(value)) {
    value.forEach(function(subValue, key) {
      result.set(key, baseClone(subValue, bitmask, customizer, key, value, stack));
    });
  }

  var keysFunc = isFull
    ? (isFlat ? getAllKeysIn : getAllKeys)
    : (isFlat ? keysIn : keys);

  var props = isArr ? undefined : keysFunc(value);
  arrayEach(props || value, function(subValue, key) {
    if (props) {
      key = subValue;
      subValue = value[key];
    }
    // Recursively populate clone (susceptible to call stack limits).
    assignValue(result, key, baseClone(subValue, bitmask, customizer, key, value, stack));
  });
  return result;
}

module.exports = baseClone;


/***/ }),

/***/ "./node_modules/lodash/_baseCreate.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_baseCreate.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var isObject = __webpack_require__(/*! ./isObject */ "./node_modules/lodash/isObject.js");

/** Built-in value references. */
var objectCreate = Object.create;

/**
 * The base implementation of `_.create` without support for assigning
 * properties to the created object.
 *
 * @private
 * @param {Object} proto The object to inherit from.
 * @returns {Object} Returns the new object.
 */
var baseCreate = (function() {
  function object() {}
  return function(proto) {
    if (!isObject(proto)) {
      return {};
    }
    if (objectCreate) {
      return objectCreate(proto);
    }
    object.prototype = proto;
    var result = new object;
    object.prototype = undefined;
    return result;
  };
}());

module.exports = baseCreate;


/***/ }),

/***/ "./node_modules/lodash/_baseEach.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/_baseEach.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseForOwn = __webpack_require__(/*! ./_baseForOwn */ "./node_modules/lodash/_baseForOwn.js"),
    createBaseEach = __webpack_require__(/*! ./_createBaseEach */ "./node_modules/lodash/_createBaseEach.js");

/**
 * The base implementation of `_.forEach` without support for iteratee shorthands.
 *
 * @private
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array|Object} Returns `collection`.
 */
var baseEach = createBaseEach(baseForOwn);

module.exports = baseEach;


/***/ }),

/***/ "./node_modules/lodash/_baseExtremum.js":
/*!**********************************************!*\
  !*** ./node_modules/lodash/_baseExtremum.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var isSymbol = __webpack_require__(/*! ./isSymbol */ "./node_modules/lodash/isSymbol.js");

/**
 * The base implementation of methods like `_.max` and `_.min` which accepts a
 * `comparator` to determine the extremum value.
 *
 * @private
 * @param {Array} array The array to iterate over.
 * @param {Function} iteratee The iteratee invoked per iteration.
 * @param {Function} comparator The comparator used to compare values.
 * @returns {*} Returns the extremum value.
 */
function baseExtremum(array, iteratee, comparator) {
  var index = -1,
      length = array.length;

  while (++index < length) {
    var value = array[index],
        current = iteratee(value);

    if (current != null && (computed === undefined
          ? (current === current && !isSymbol(current))
          : comparator(current, computed)
        )) {
      var computed = current,
          result = value;
    }
  }
  return result;
}

module.exports = baseExtremum;


/***/ }),

/***/ "./node_modules/lodash/_baseFilter.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_baseFilter.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseEach = __webpack_require__(/*! ./_baseEach */ "./node_modules/lodash/_baseEach.js");

/**
 * The base implementation of `_.filter` without support for iteratee shorthands.
 *
 * @private
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} predicate The function invoked per iteration.
 * @returns {Array} Returns the new filtered array.
 */
function baseFilter(collection, predicate) {
  var result = [];
  baseEach(collection, function(value, index, collection) {
    if (predicate(value, index, collection)) {
      result.push(value);
    }
  });
  return result;
}

module.exports = baseFilter;


/***/ }),

/***/ "./node_modules/lodash/_baseFindIndex.js":
/*!***********************************************!*\
  !*** ./node_modules/lodash/_baseFindIndex.js ***!
  \***********************************************/
/***/ ((module) => {

/**
 * The base implementation of `_.findIndex` and `_.findLastIndex` without
 * support for iteratee shorthands.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {Function} predicate The function invoked per iteration.
 * @param {number} fromIndex The index to search from.
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function baseFindIndex(array, predicate, fromIndex, fromRight) {
  var length = array.length,
      index = fromIndex + (fromRight ? 1 : -1);

  while ((fromRight ? index-- : ++index < length)) {
    if (predicate(array[index], index, array)) {
      return index;
    }
  }
  return -1;
}

module.exports = baseFindIndex;


/***/ }),

/***/ "./node_modules/lodash/_baseFlatten.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash/_baseFlatten.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var arrayPush = __webpack_require__(/*! ./_arrayPush */ "./node_modules/lodash/_arrayPush.js"),
    isFlattenable = __webpack_require__(/*! ./_isFlattenable */ "./node_modules/lodash/_isFlattenable.js");

/**
 * The base implementation of `_.flatten` with support for restricting flattening.
 *
 * @private
 * @param {Array} array The array to flatten.
 * @param {number} depth The maximum recursion depth.
 * @param {boolean} [predicate=isFlattenable] The function invoked per iteration.
 * @param {boolean} [isStrict] Restrict to values that pass `predicate` checks.
 * @param {Array} [result=[]] The initial result value.
 * @returns {Array} Returns the new flattened array.
 */
function baseFlatten(array, depth, predicate, isStrict, result) {
  var index = -1,
      length = array.length;

  predicate || (predicate = isFlattenable);
  result || (result = []);

  while (++index < length) {
    var value = array[index];
    if (depth > 0 && predicate(value)) {
      if (depth > 1) {
        // Recursively flatten arrays (susceptible to call stack limits).
        baseFlatten(value, depth - 1, predicate, isStrict, result);
      } else {
        arrayPush(result, value);
      }
    } else if (!isStrict) {
      result[result.length] = value;
    }
  }
  return result;
}

module.exports = baseFlatten;


/***/ }),

/***/ "./node_modules/lodash/_baseFor.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/_baseFor.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var createBaseFor = __webpack_require__(/*! ./_createBaseFor */ "./node_modules/lodash/_createBaseFor.js");

/**
 * The base implementation of `baseForOwn` which iterates over `object`
 * properties returned by `keysFunc` and invokes `iteratee` for each property.
 * Iteratee functions may exit iteration early by explicitly returning `false`.
 *
 * @private
 * @param {Object} object The object to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @param {Function} keysFunc The function to get the keys of `object`.
 * @returns {Object} Returns `object`.
 */
var baseFor = createBaseFor();

module.exports = baseFor;


/***/ }),

/***/ "./node_modules/lodash/_baseForOwn.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_baseForOwn.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseFor = __webpack_require__(/*! ./_baseFor */ "./node_modules/lodash/_baseFor.js"),
    keys = __webpack_require__(/*! ./keys */ "./node_modules/lodash/keys.js");

/**
 * The base implementation of `_.forOwn` without support for iteratee shorthands.
 *
 * @private
 * @param {Object} object The object to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Object} Returns `object`.
 */
function baseForOwn(object, iteratee) {
  return object && baseFor(object, iteratee, keys);
}

module.exports = baseForOwn;


/***/ }),

/***/ "./node_modules/lodash/_baseGet.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/_baseGet.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var castPath = __webpack_require__(/*! ./_castPath */ "./node_modules/lodash/_castPath.js"),
    toKey = __webpack_require__(/*! ./_toKey */ "./node_modules/lodash/_toKey.js");

/**
 * The base implementation of `_.get` without support for default values.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array|string} path The path of the property to get.
 * @returns {*} Returns the resolved value.
 */
function baseGet(object, path) {
  path = castPath(path, object);

  var index = 0,
      length = path.length;

  while (object != null && index < length) {
    object = object[toKey(path[index++])];
  }
  return (index && index == length) ? object : undefined;
}

module.exports = baseGet;


/***/ }),

/***/ "./node_modules/lodash/_baseGetAllKeys.js":
/*!************************************************!*\
  !*** ./node_modules/lodash/_baseGetAllKeys.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var arrayPush = __webpack_require__(/*! ./_arrayPush */ "./node_modules/lodash/_arrayPush.js"),
    isArray = __webpack_require__(/*! ./isArray */ "./node_modules/lodash/isArray.js");

/**
 * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
 * `keysFunc` and `symbolsFunc` to get the enumerable property names and
 * symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Function} keysFunc The function to get the keys of `object`.
 * @param {Function} symbolsFunc The function to get the symbols of `object`.
 * @returns {Array} Returns the array of property names and symbols.
 */
function baseGetAllKeys(object, keysFunc, symbolsFunc) {
  var result = keysFunc(object);
  return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
}

module.exports = baseGetAllKeys;


/***/ }),

/***/ "./node_modules/lodash/_baseGetTag.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_baseGetTag.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var Symbol = __webpack_require__(/*! ./_Symbol */ "./node_modules/lodash/_Symbol.js"),
    getRawTag = __webpack_require__(/*! ./_getRawTag */ "./node_modules/lodash/_getRawTag.js"),
    objectToString = __webpack_require__(/*! ./_objectToString */ "./node_modules/lodash/_objectToString.js");

/** `Object#toString` result references. */
var nullTag = '[object Null]',
    undefinedTag = '[object Undefined]';

/** Built-in value references. */
var symToStringTag = Symbol ? Symbol.toStringTag : undefined;

/**
 * The base implementation of `getTag` without fallbacks for buggy environments.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
function baseGetTag(value) {
  if (value == null) {
    return value === undefined ? undefinedTag : nullTag;
  }
  return (symToStringTag && symToStringTag in Object(value))
    ? getRawTag(value)
    : objectToString(value);
}

module.exports = baseGetTag;


/***/ }),

/***/ "./node_modules/lodash/_baseGt.js":
/*!****************************************!*\
  !*** ./node_modules/lodash/_baseGt.js ***!
  \****************************************/
/***/ ((module) => {

/**
 * The base implementation of `_.gt` which doesn't coerce arguments.
 *
 * @private
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if `value` is greater than `other`,
 *  else `false`.
 */
function baseGt(value, other) {
  return value > other;
}

module.exports = baseGt;


/***/ }),

/***/ "./node_modules/lodash/_baseHas.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/_baseHas.js ***!
  \*****************************************/
/***/ ((module) => {

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * The base implementation of `_.has` without support for deep paths.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {Array|string} key The key to check.
 * @returns {boolean} Returns `true` if `key` exists, else `false`.
 */
function baseHas(object, key) {
  return object != null && hasOwnProperty.call(object, key);
}

module.exports = baseHas;


/***/ }),

/***/ "./node_modules/lodash/_baseHasIn.js":
/*!*******************************************!*\
  !*** ./node_modules/lodash/_baseHasIn.js ***!
  \*******************************************/
/***/ ((module) => {

/**
 * The base implementation of `_.hasIn` without support for deep paths.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {Array|string} key The key to check.
 * @returns {boolean} Returns `true` if `key` exists, else `false`.
 */
function baseHasIn(object, key) {
  return object != null && key in Object(object);
}

module.exports = baseHasIn;


/***/ }),

/***/ "./node_modules/lodash/_baseIndexOf.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash/_baseIndexOf.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseFindIndex = __webpack_require__(/*! ./_baseFindIndex */ "./node_modules/lodash/_baseFindIndex.js"),
    baseIsNaN = __webpack_require__(/*! ./_baseIsNaN */ "./node_modules/lodash/_baseIsNaN.js"),
    strictIndexOf = __webpack_require__(/*! ./_strictIndexOf */ "./node_modules/lodash/_strictIndexOf.js");

/**
 * The base implementation of `_.indexOf` without `fromIndex` bounds checks.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} value The value to search for.
 * @param {number} fromIndex The index to search from.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function baseIndexOf(array, value, fromIndex) {
  return value === value
    ? strictIndexOf(array, value, fromIndex)
    : baseFindIndex(array, baseIsNaN, fromIndex);
}

module.exports = baseIndexOf;


/***/ }),

/***/ "./node_modules/lodash/_baseIsArguments.js":
/*!*************************************************!*\
  !*** ./node_modules/lodash/_baseIsArguments.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseGetTag = __webpack_require__(/*! ./_baseGetTag */ "./node_modules/lodash/_baseGetTag.js"),
    isObjectLike = __webpack_require__(/*! ./isObjectLike */ "./node_modules/lodash/isObjectLike.js");

/** `Object#toString` result references. */
var argsTag = '[object Arguments]';

/**
 * The base implementation of `_.isArguments`.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 */
function baseIsArguments(value) {
  return isObjectLike(value) && baseGetTag(value) == argsTag;
}

module.exports = baseIsArguments;


/***/ }),

/***/ "./node_modules/lodash/_baseIsEqual.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash/_baseIsEqual.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseIsEqualDeep = __webpack_require__(/*! ./_baseIsEqualDeep */ "./node_modules/lodash/_baseIsEqualDeep.js"),
    isObjectLike = __webpack_require__(/*! ./isObjectLike */ "./node_modules/lodash/isObjectLike.js");

/**
 * The base implementation of `_.isEqual` which supports partial comparisons
 * and tracks traversed objects.
 *
 * @private
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @param {boolean} bitmask The bitmask flags.
 *  1 - Unordered comparison
 *  2 - Partial comparison
 * @param {Function} [customizer] The function to customize comparisons.
 * @param {Object} [stack] Tracks traversed `value` and `other` objects.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 */
function baseIsEqual(value, other, bitmask, customizer, stack) {
  if (value === other) {
    return true;
  }
  if (value == null || other == null || (!isObjectLike(value) && !isObjectLike(other))) {
    return value !== value && other !== other;
  }
  return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
}

module.exports = baseIsEqual;


/***/ }),

/***/ "./node_modules/lodash/_baseIsEqualDeep.js":
/*!*************************************************!*\
  !*** ./node_modules/lodash/_baseIsEqualDeep.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var Stack = __webpack_require__(/*! ./_Stack */ "./node_modules/lodash/_Stack.js"),
    equalArrays = __webpack_require__(/*! ./_equalArrays */ "./node_modules/lodash/_equalArrays.js"),
    equalByTag = __webpack_require__(/*! ./_equalByTag */ "./node_modules/lodash/_equalByTag.js"),
    equalObjects = __webpack_require__(/*! ./_equalObjects */ "./node_modules/lodash/_equalObjects.js"),
    getTag = __webpack_require__(/*! ./_getTag */ "./node_modules/lodash/_getTag.js"),
    isArray = __webpack_require__(/*! ./isArray */ "./node_modules/lodash/isArray.js"),
    isBuffer = __webpack_require__(/*! ./isBuffer */ "./node_modules/lodash/isBuffer.js"),
    isTypedArray = __webpack_require__(/*! ./isTypedArray */ "./node_modules/lodash/isTypedArray.js");

/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG = 1;

/** `Object#toString` result references. */
var argsTag = '[object Arguments]',
    arrayTag = '[object Array]',
    objectTag = '[object Object]';

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * A specialized version of `baseIsEqual` for arrays and objects which performs
 * deep comparisons and tracks traversed objects enabling objects with circular
 * references to be compared.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} [stack] Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */
function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
  var objIsArr = isArray(object),
      othIsArr = isArray(other),
      objTag = objIsArr ? arrayTag : getTag(object),
      othTag = othIsArr ? arrayTag : getTag(other);

  objTag = objTag == argsTag ? objectTag : objTag;
  othTag = othTag == argsTag ? objectTag : othTag;

  var objIsObj = objTag == objectTag,
      othIsObj = othTag == objectTag,
      isSameTag = objTag == othTag;

  if (isSameTag && isBuffer(object)) {
    if (!isBuffer(other)) {
      return false;
    }
    objIsArr = true;
    objIsObj = false;
  }
  if (isSameTag && !objIsObj) {
    stack || (stack = new Stack);
    return (objIsArr || isTypedArray(object))
      ? equalArrays(object, other, bitmask, customizer, equalFunc, stack)
      : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
  }
  if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
    var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),
        othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');

    if (objIsWrapped || othIsWrapped) {
      var objUnwrapped = objIsWrapped ? object.value() : object,
          othUnwrapped = othIsWrapped ? other.value() : other;

      stack || (stack = new Stack);
      return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
    }
  }
  if (!isSameTag) {
    return false;
  }
  stack || (stack = new Stack);
  return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
}

module.exports = baseIsEqualDeep;


/***/ }),

/***/ "./node_modules/lodash/_baseIsMap.js":
/*!*******************************************!*\
  !*** ./node_modules/lodash/_baseIsMap.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var getTag = __webpack_require__(/*! ./_getTag */ "./node_modules/lodash/_getTag.js"),
    isObjectLike = __webpack_require__(/*! ./isObjectLike */ "./node_modules/lodash/isObjectLike.js");

/** `Object#toString` result references. */
var mapTag = '[object Map]';

/**
 * The base implementation of `_.isMap` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a map, else `false`.
 */
function baseIsMap(value) {
  return isObjectLike(value) && getTag(value) == mapTag;
}

module.exports = baseIsMap;


/***/ }),

/***/ "./node_modules/lodash/_baseIsMatch.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash/_baseIsMatch.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var Stack = __webpack_require__(/*! ./_Stack */ "./node_modules/lodash/_Stack.js"),
    baseIsEqual = __webpack_require__(/*! ./_baseIsEqual */ "./node_modules/lodash/_baseIsEqual.js");

/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG = 1,
    COMPARE_UNORDERED_FLAG = 2;

/**
 * The base implementation of `_.isMatch` without support for iteratee shorthands.
 *
 * @private
 * @param {Object} object The object to inspect.
 * @param {Object} source The object of property values to match.
 * @param {Array} matchData The property names, values, and compare flags to match.
 * @param {Function} [customizer] The function to customize comparisons.
 * @returns {boolean} Returns `true` if `object` is a match, else `false`.
 */
function baseIsMatch(object, source, matchData, customizer) {
  var index = matchData.length,
      length = index,
      noCustomizer = !customizer;

  if (object == null) {
    return !length;
  }
  object = Object(object);
  while (index--) {
    var data = matchData[index];
    if ((noCustomizer && data[2])
          ? data[1] !== object[data[0]]
          : !(data[0] in object)
        ) {
      return false;
    }
  }
  while (++index < length) {
    data = matchData[index];
    var key = data[0],
        objValue = object[key],
        srcValue = data[1];

    if (noCustomizer && data[2]) {
      if (objValue === undefined && !(key in object)) {
        return false;
      }
    } else {
      var stack = new Stack;
      if (customizer) {
        var result = customizer(objValue, srcValue, key, object, source, stack);
      }
      if (!(result === undefined
            ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack)
            : result
          )) {
        return false;
      }
    }
  }
  return true;
}

module.exports = baseIsMatch;


/***/ }),

/***/ "./node_modules/lodash/_baseIsNaN.js":
/*!*******************************************!*\
  !*** ./node_modules/lodash/_baseIsNaN.js ***!
  \*******************************************/
/***/ ((module) => {

/**
 * The base implementation of `_.isNaN` without support for number objects.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
 */
function baseIsNaN(value) {
  return value !== value;
}

module.exports = baseIsNaN;


/***/ }),

/***/ "./node_modules/lodash/_baseIsNative.js":
/*!**********************************************!*\
  !*** ./node_modules/lodash/_baseIsNative.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var isFunction = __webpack_require__(/*! ./isFunction */ "./node_modules/lodash/isFunction.js"),
    isMasked = __webpack_require__(/*! ./_isMasked */ "./node_modules/lodash/_isMasked.js"),
    isObject = __webpack_require__(/*! ./isObject */ "./node_modules/lodash/isObject.js"),
    toSource = __webpack_require__(/*! ./_toSource */ "./node_modules/lodash/_toSource.js");

/**
 * Used to match `RegExp`
 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
 */
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;

/** Used to detect host constructors (Safari). */
var reIsHostCtor = /^\[object .+?Constructor\]$/;

/** Used for built-in method references. */
var funcProto = Function.prototype,
    objectProto = Object.prototype;

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/** Used to detect if a method is native. */
var reIsNative = RegExp('^' +
  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&')
  .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
);

/**
 * The base implementation of `_.isNative` without bad shim checks.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a native function,
 *  else `false`.
 */
function baseIsNative(value) {
  if (!isObject(value) || isMasked(value)) {
    return false;
  }
  var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
  return pattern.test(toSource(value));
}

module.exports = baseIsNative;


/***/ }),

/***/ "./node_modules/lodash/_baseIsSet.js":
/*!*******************************************!*\
  !*** ./node_modules/lodash/_baseIsSet.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var getTag = __webpack_require__(/*! ./_getTag */ "./node_modules/lodash/_getTag.js"),
    isObjectLike = __webpack_require__(/*! ./isObjectLike */ "./node_modules/lodash/isObjectLike.js");

/** `Object#toString` result references. */
var setTag = '[object Set]';

/**
 * The base implementation of `_.isSet` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a set, else `false`.
 */
function baseIsSet(value) {
  return isObjectLike(value) && getTag(value) == setTag;
}

module.exports = baseIsSet;


/***/ }),

/***/ "./node_modules/lodash/_baseIsTypedArray.js":
/*!**************************************************!*\
  !*** ./node_modules/lodash/_baseIsTypedArray.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseGetTag = __webpack_require__(/*! ./_baseGetTag */ "./node_modules/lodash/_baseGetTag.js"),
    isLength = __webpack_require__(/*! ./isLength */ "./node_modules/lodash/isLength.js"),
    isObjectLike = __webpack_require__(/*! ./isObjectLike */ "./node_modules/lodash/isObjectLike.js");

/** `Object#toString` result references. */
var argsTag = '[object Arguments]',
    arrayTag = '[object Array]',
    boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    errorTag = '[object Error]',
    funcTag = '[object Function]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    objectTag = '[object Object]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    weakMapTag = '[object WeakMap]';

var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]',
    float32Tag = '[object Float32Array]',
    float64Tag = '[object Float64Array]',
    int8Tag = '[object Int8Array]',
    int16Tag = '[object Int16Array]',
    int32Tag = '[object Int32Array]',
    uint8Tag = '[object Uint8Array]',
    uint8ClampedTag = '[object Uint8ClampedArray]',
    uint16Tag = '[object Uint16Array]',
    uint32Tag = '[object Uint32Array]';

/** Used to identify `toStringTag` values of typed arrays. */
var typedArrayTags = {};
typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =
typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =
typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =
typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =
typedArrayTags[uint32Tag] = true;
typedArrayTags[argsTag] = typedArrayTags[arrayTag] =
typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =
typedArrayTags[dataViewTag] = typedArrayTags[dateTag] =
typedArrayTags[errorTag] = typedArrayTags[funcTag] =
typedArrayTags[mapTag] = typedArrayTags[numberTag] =
typedArrayTags[objectTag] = typedArrayTags[regexpTag] =
typedArrayTags[setTag] = typedArrayTags[stringTag] =
typedArrayTags[weakMapTag] = false;

/**
 * The base implementation of `_.isTypedArray` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 */
function baseIsTypedArray(value) {
  return isObjectLike(value) &&
    isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
}

module.exports = baseIsTypedArray;


/***/ }),

/***/ "./node_modules/lodash/_baseIteratee.js":
/*!**********************************************!*\
  !*** ./node_modules/lodash/_baseIteratee.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseMatches = __webpack_require__(/*! ./_baseMatches */ "./node_modules/lodash/_baseMatches.js"),
    baseMatchesProperty = __webpack_require__(/*! ./_baseMatchesProperty */ "./node_modules/lodash/_baseMatchesProperty.js"),
    identity = __webpack_require__(/*! ./identity */ "./node_modules/lodash/identity.js"),
    isArray = __webpack_require__(/*! ./isArray */ "./node_modules/lodash/isArray.js"),
    property = __webpack_require__(/*! ./property */ "./node_modules/lodash/property.js");

/**
 * The base implementation of `_.iteratee`.
 *
 * @private
 * @param {*} [value=_.identity] The value to convert to an iteratee.
 * @returns {Function} Returns the iteratee.
 */
function baseIteratee(value) {
  // Don't store the `typeof` result in a variable to avoid a JIT bug in Safari 9.
  // See https://bugs.webkit.org/show_bug.cgi?id=156034 for more details.
  if (typeof value == 'function') {
    return value;
  }
  if (value == null) {
    return identity;
  }
  if (typeof value == 'object') {
    return isArray(value)
      ? baseMatchesProperty(value[0], value[1])
      : baseMatches(value);
  }
  return property(value);
}

module.exports = baseIteratee;


/***/ }),

/***/ "./node_modules/lodash/_baseKeys.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/_baseKeys.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var isPrototype = __webpack_require__(/*! ./_isPrototype */ "./node_modules/lodash/_isPrototype.js"),
    nativeKeys = __webpack_require__(/*! ./_nativeKeys */ "./node_modules/lodash/_nativeKeys.js");

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function baseKeys(object) {
  if (!isPrototype(object)) {
    return nativeKeys(object);
  }
  var result = [];
  for (var key in Object(object)) {
    if (hasOwnProperty.call(object, key) && key != 'constructor') {
      result.push(key);
    }
  }
  return result;
}

module.exports = baseKeys;


/***/ }),

/***/ "./node_modules/lodash/_baseKeysIn.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_baseKeysIn.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var isObject = __webpack_require__(/*! ./isObject */ "./node_modules/lodash/isObject.js"),
    isPrototype = __webpack_require__(/*! ./_isPrototype */ "./node_modules/lodash/_isPrototype.js"),
    nativeKeysIn = __webpack_require__(/*! ./_nativeKeysIn */ "./node_modules/lodash/_nativeKeysIn.js");

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function baseKeysIn(object) {
  if (!isObject(object)) {
    return nativeKeysIn(object);
  }
  var isProto = isPrototype(object),
      result = [];

  for (var key in object) {
    if (!(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {
      result.push(key);
    }
  }
  return result;
}

module.exports = baseKeysIn;


/***/ }),

/***/ "./node_modules/lodash/_baseLt.js":
/*!****************************************!*\
  !*** ./node_modules/lodash/_baseLt.js ***!
  \****************************************/
/***/ ((module) => {

/**
 * The base implementation of `_.lt` which doesn't coerce arguments.
 *
 * @private
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if `value` is less than `other`,
 *  else `false`.
 */
function baseLt(value, other) {
  return value < other;
}

module.exports = baseLt;


/***/ }),

/***/ "./node_modules/lodash/_baseMap.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/_baseMap.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseEach = __webpack_require__(/*! ./_baseEach */ "./node_modules/lodash/_baseEach.js"),
    isArrayLike = __webpack_require__(/*! ./isArrayLike */ "./node_modules/lodash/isArrayLike.js");

/**
 * The base implementation of `_.map` without support for iteratee shorthands.
 *
 * @private
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the new mapped array.
 */
function baseMap(collection, iteratee) {
  var index = -1,
      result = isArrayLike(collection) ? Array(collection.length) : [];

  baseEach(collection, function(value, key, collection) {
    result[++index] = iteratee(value, key, collection);
  });
  return result;
}

module.exports = baseMap;


/***/ }),

/***/ "./node_modules/lodash/_baseMatches.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash/_baseMatches.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseIsMatch = __webpack_require__(/*! ./_baseIsMatch */ "./node_modules/lodash/_baseIsMatch.js"),
    getMatchData = __webpack_require__(/*! ./_getMatchData */ "./node_modules/lodash/_getMatchData.js"),
    matchesStrictComparable = __webpack_require__(/*! ./_matchesStrictComparable */ "./node_modules/lodash/_matchesStrictComparable.js");

/**
 * The base implementation of `_.matches` which doesn't clone `source`.
 *
 * @private
 * @param {Object} source The object of property values to match.
 * @returns {Function} Returns the new spec function.
 */
function baseMatches(source) {
  var matchData = getMatchData(source);
  if (matchData.length == 1 && matchData[0][2]) {
    return matchesStrictComparable(matchData[0][0], matchData[0][1]);
  }
  return function(object) {
    return object === source || baseIsMatch(object, source, matchData);
  };
}

module.exports = baseMatches;


/***/ }),

/***/ "./node_modules/lodash/_baseMatchesProperty.js":
/*!*****************************************************!*\
  !*** ./node_modules/lodash/_baseMatchesProperty.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseIsEqual = __webpack_require__(/*! ./_baseIsEqual */ "./node_modules/lodash/_baseIsEqual.js"),
    get = __webpack_require__(/*! ./get */ "./node_modules/lodash/get.js"),
    hasIn = __webpack_require__(/*! ./hasIn */ "./node_modules/lodash/hasIn.js"),
    isKey = __webpack_require__(/*! ./_isKey */ "./node_modules/lodash/_isKey.js"),
    isStrictComparable = __webpack_require__(/*! ./_isStrictComparable */ "./node_modules/lodash/_isStrictComparable.js"),
    matchesStrictComparable = __webpack_require__(/*! ./_matchesStrictComparable */ "./node_modules/lodash/_matchesStrictComparable.js"),
    toKey = __webpack_require__(/*! ./_toKey */ "./node_modules/lodash/_toKey.js");

/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG = 1,
    COMPARE_UNORDERED_FLAG = 2;

/**
 * The base implementation of `_.matchesProperty` which doesn't clone `srcValue`.
 *
 * @private
 * @param {string} path The path of the property to get.
 * @param {*} srcValue The value to match.
 * @returns {Function} Returns the new spec function.
 */
function baseMatchesProperty(path, srcValue) {
  if (isKey(path) && isStrictComparable(srcValue)) {
    return matchesStrictComparable(toKey(path), srcValue);
  }
  return function(object) {
    var objValue = get(object, path);
    return (objValue === undefined && objValue === srcValue)
      ? hasIn(object, path)
      : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
  };
}

module.exports = baseMatchesProperty;


/***/ }),

/***/ "./node_modules/lodash/_baseMerge.js":
/*!*******************************************!*\
  !*** ./node_modules/lodash/_baseMerge.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var Stack = __webpack_require__(/*! ./_Stack */ "./node_modules/lodash/_Stack.js"),
    assignMergeValue = __webpack_require__(/*! ./_assignMergeValue */ "./node_modules/lodash/_assignMergeValue.js"),
    baseFor = __webpack_require__(/*! ./_baseFor */ "./node_modules/lodash/_baseFor.js"),
    baseMergeDeep = __webpack_require__(/*! ./_baseMergeDeep */ "./node_modules/lodash/_baseMergeDeep.js"),
    isObject = __webpack_require__(/*! ./isObject */ "./node_modules/lodash/isObject.js"),
    keysIn = __webpack_require__(/*! ./keysIn */ "./node_modules/lodash/keysIn.js"),
    safeGet = __webpack_require__(/*! ./_safeGet */ "./node_modules/lodash/_safeGet.js");

/**
 * The base implementation of `_.merge` without support for multiple sources.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @param {number} srcIndex The index of `source`.
 * @param {Function} [customizer] The function to customize merged values.
 * @param {Object} [stack] Tracks traversed source values and their merged
 *  counterparts.
 */
function baseMerge(object, source, srcIndex, customizer, stack) {
  if (object === source) {
    return;
  }
  baseFor(source, function(srcValue, key) {
    stack || (stack = new Stack);
    if (isObject(srcValue)) {
      baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
    }
    else {
      var newValue = customizer
        ? customizer(safeGet(object, key), srcValue, (key + ''), object, source, stack)
        : undefined;

      if (newValue === undefined) {
        newValue = srcValue;
      }
      assignMergeValue(object, key, newValue);
    }
  }, keysIn);
}

module.exports = baseMerge;


/***/ }),

/***/ "./node_modules/lodash/_baseMergeDeep.js":
/*!***********************************************!*\
  !*** ./node_modules/lodash/_baseMergeDeep.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var assignMergeValue = __webpack_require__(/*! ./_assignMergeValue */ "./node_modules/lodash/_assignMergeValue.js"),
    cloneBuffer = __webpack_require__(/*! ./_cloneBuffer */ "./node_modules/lodash/_cloneBuffer.js"),
    cloneTypedArray = __webpack_require__(/*! ./_cloneTypedArray */ "./node_modules/lodash/_cloneTypedArray.js"),
    copyArray = __webpack_require__(/*! ./_copyArray */ "./node_modules/lodash/_copyArray.js"),
    initCloneObject = __webpack_require__(/*! ./_initCloneObject */ "./node_modules/lodash/_initCloneObject.js"),
    isArguments = __webpack_require__(/*! ./isArguments */ "./node_modules/lodash/isArguments.js"),
    isArray = __webpack_require__(/*! ./isArray */ "./node_modules/lodash/isArray.js"),
    isArrayLikeObject = __webpack_require__(/*! ./isArrayLikeObject */ "./node_modules/lodash/isArrayLikeObject.js"),
    isBuffer = __webpack_require__(/*! ./isBuffer */ "./node_modules/lodash/isBuffer.js"),
    isFunction = __webpack_require__(/*! ./isFunction */ "./node_modules/lodash/isFunction.js"),
    isObject = __webpack_require__(/*! ./isObject */ "./node_modules/lodash/isObject.js"),
    isPlainObject = __webpack_require__(/*! ./isPlainObject */ "./node_modules/lodash/isPlainObject.js"),
    isTypedArray = __webpack_require__(/*! ./isTypedArray */ "./node_modules/lodash/isTypedArray.js"),
    safeGet = __webpack_require__(/*! ./_safeGet */ "./node_modules/lodash/_safeGet.js"),
    toPlainObject = __webpack_require__(/*! ./toPlainObject */ "./node_modules/lodash/toPlainObject.js");

/**
 * A specialized version of `baseMerge` for arrays and objects which performs
 * deep merges and tracks traversed objects enabling objects with circular
 * references to be merged.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @param {string} key The key of the value to merge.
 * @param {number} srcIndex The index of `source`.
 * @param {Function} mergeFunc The function to merge values.
 * @param {Function} [customizer] The function to customize assigned values.
 * @param {Object} [stack] Tracks traversed source values and their merged
 *  counterparts.
 */
function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
  var objValue = safeGet(object, key),
      srcValue = safeGet(source, key),
      stacked = stack.get(srcValue);

  if (stacked) {
    assignMergeValue(object, key, stacked);
    return;
  }
  var newValue = customizer
    ? customizer(objValue, srcValue, (key + ''), object, source, stack)
    : undefined;

  var isCommon = newValue === undefined;

  if (isCommon) {
    var isArr = isArray(srcValue),
        isBuff = !isArr && isBuffer(srcValue),
        isTyped = !isArr && !isBuff && isTypedArray(srcValue);

    newValue = srcValue;
    if (isArr || isBuff || isTyped) {
      if (isArray(objValue)) {
        newValue = objValue;
      }
      else if (isArrayLikeObject(objValue)) {
        newValue = copyArray(objValue);
      }
      else if (isBuff) {
        isCommon = false;
        newValue = cloneBuffer(srcValue, true);
      }
      else if (isTyped) {
        isCommon = false;
        newValue = cloneTypedArray(srcValue, true);
      }
      else {
        newValue = [];
      }
    }
    else if (isPlainObject(srcValue) || isArguments(srcValue)) {
      newValue = objValue;
      if (isArguments(objValue)) {
        newValue = toPlainObject(objValue);
      }
      else if (!isObject(objValue) || isFunction(objValue)) {
        newValue = initCloneObject(srcValue);
      }
    }
    else {
      isCommon = false;
    }
  }
  if (isCommon) {
    // Recursively merge objects and arrays (susceptible to call stack limits).
    stack.set(srcValue, newValue);
    mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
    stack['delete'](srcValue);
  }
  assignMergeValue(object, key, newValue);
}

module.exports = baseMergeDeep;


/***/ }),

/***/ "./node_modules/lodash/_baseOrderBy.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash/_baseOrderBy.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var arrayMap = __webpack_require__(/*! ./_arrayMap */ "./node_modules/lodash/_arrayMap.js"),
    baseGet = __webpack_require__(/*! ./_baseGet */ "./node_modules/lodash/_baseGet.js"),
    baseIteratee = __webpack_require__(/*! ./_baseIteratee */ "./node_modules/lodash/_baseIteratee.js"),
    baseMap = __webpack_require__(/*! ./_baseMap */ "./node_modules/lodash/_baseMap.js"),
    baseSortBy = __webpack_require__(/*! ./_baseSortBy */ "./node_modules/lodash/_baseSortBy.js"),
    baseUnary = __webpack_require__(/*! ./_baseUnary */ "./node_modules/lodash/_baseUnary.js"),
    compareMultiple = __webpack_require__(/*! ./_compareMultiple */ "./node_modules/lodash/_compareMultiple.js"),
    identity = __webpack_require__(/*! ./identity */ "./node_modules/lodash/identity.js"),
    isArray = __webpack_require__(/*! ./isArray */ "./node_modules/lodash/isArray.js");

/**
 * The base implementation of `_.orderBy` without param guards.
 *
 * @private
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function[]|Object[]|string[]} iteratees The iteratees to sort by.
 * @param {string[]} orders The sort orders of `iteratees`.
 * @returns {Array} Returns the new sorted array.
 */
function baseOrderBy(collection, iteratees, orders) {
  if (iteratees.length) {
    iteratees = arrayMap(iteratees, function(iteratee) {
      if (isArray(iteratee)) {
        return function(value) {
          return baseGet(value, iteratee.length === 1 ? iteratee[0] : iteratee);
        }
      }
      return iteratee;
    });
  } else {
    iteratees = [identity];
  }

  var index = -1;
  iteratees = arrayMap(iteratees, baseUnary(baseIteratee));

  var result = baseMap(collection, function(value, key, collection) {
    var criteria = arrayMap(iteratees, function(iteratee) {
      return iteratee(value);
    });
    return { 'criteria': criteria, 'index': ++index, 'value': value };
  });

  return baseSortBy(result, function(object, other) {
    return compareMultiple(object, other, orders);
  });
}

module.exports = baseOrderBy;


/***/ }),

/***/ "./node_modules/lodash/_basePick.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/_basePick.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var basePickBy = __webpack_require__(/*! ./_basePickBy */ "./node_modules/lodash/_basePickBy.js"),
    hasIn = __webpack_require__(/*! ./hasIn */ "./node_modules/lodash/hasIn.js");

/**
 * The base implementation of `_.pick` without support for individual
 * property identifiers.
 *
 * @private
 * @param {Object} object The source object.
 * @param {string[]} paths The property paths to pick.
 * @returns {Object} Returns the new object.
 */
function basePick(object, paths) {
  return basePickBy(object, paths, function(value, path) {
    return hasIn(object, path);
  });
}

module.exports = basePick;


/***/ }),

/***/ "./node_modules/lodash/_basePickBy.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_basePickBy.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseGet = __webpack_require__(/*! ./_baseGet */ "./node_modules/lodash/_baseGet.js"),
    baseSet = __webpack_require__(/*! ./_baseSet */ "./node_modules/lodash/_baseSet.js"),
    castPath = __webpack_require__(/*! ./_castPath */ "./node_modules/lodash/_castPath.js");

/**
 * The base implementation of  `_.pickBy` without support for iteratee shorthands.
 *
 * @private
 * @param {Object} object The source object.
 * @param {string[]} paths The property paths to pick.
 * @param {Function} predicate The function invoked per property.
 * @returns {Object} Returns the new object.
 */
function basePickBy(object, paths, predicate) {
  var index = -1,
      length = paths.length,
      result = {};

  while (++index < length) {
    var path = paths[index],
        value = baseGet(object, path);

    if (predicate(value, path)) {
      baseSet(result, castPath(path, object), value);
    }
  }
  return result;
}

module.exports = basePickBy;


/***/ }),

/***/ "./node_modules/lodash/_baseProperty.js":
/*!**********************************************!*\
  !*** ./node_modules/lodash/_baseProperty.js ***!
  \**********************************************/
/***/ ((module) => {

/**
 * The base implementation of `_.property` without support for deep paths.
 *
 * @private
 * @param {string} key The key of the property to get.
 * @returns {Function} Returns the new accessor function.
 */
function baseProperty(key) {
  return function(object) {
    return object == null ? undefined : object[key];
  };
}

module.exports = baseProperty;


/***/ }),

/***/ "./node_modules/lodash/_basePropertyDeep.js":
/*!**************************************************!*\
  !*** ./node_modules/lodash/_basePropertyDeep.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseGet = __webpack_require__(/*! ./_baseGet */ "./node_modules/lodash/_baseGet.js");

/**
 * A specialized version of `baseProperty` which supports deep paths.
 *
 * @private
 * @param {Array|string} path The path of the property to get.
 * @returns {Function} Returns the new accessor function.
 */
function basePropertyDeep(path) {
  return function(object) {
    return baseGet(object, path);
  };
}

module.exports = basePropertyDeep;


/***/ }),

/***/ "./node_modules/lodash/_baseRange.js":
/*!*******************************************!*\
  !*** ./node_modules/lodash/_baseRange.js ***!
  \*******************************************/
/***/ ((module) => {

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeCeil = Math.ceil,
    nativeMax = Math.max;

/**
 * The base implementation of `_.range` and `_.rangeRight` which doesn't
 * coerce arguments.
 *
 * @private
 * @param {number} start The start of the range.
 * @param {number} end The end of the range.
 * @param {number} step The value to increment or decrement by.
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {Array} Returns the range of numbers.
 */
function baseRange(start, end, step, fromRight) {
  var index = -1,
      length = nativeMax(nativeCeil((end - start) / (step || 1)), 0),
      result = Array(length);

  while (length--) {
    result[fromRight ? length : ++index] = start;
    start += step;
  }
  return result;
}

module.exports = baseRange;


/***/ }),

/***/ "./node_modules/lodash/_baseReduce.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_baseReduce.js ***!
  \********************************************/
/***/ ((module) => {

/**
 * The base implementation of `_.reduce` and `_.reduceRight`, without support
 * for iteratee shorthands, which iterates over `collection` using `eachFunc`.
 *
 * @private
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @param {*} accumulator The initial value.
 * @param {boolean} initAccum Specify using the first or last element of
 *  `collection` as the initial value.
 * @param {Function} eachFunc The function to iterate over `collection`.
 * @returns {*} Returns the accumulated value.
 */
function baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) {
  eachFunc(collection, function(value, index, collection) {
    accumulator = initAccum
      ? (initAccum = false, value)
      : iteratee(accumulator, value, index, collection);
  });
  return accumulator;
}

module.exports = baseReduce;


/***/ }),

/***/ "./node_modules/lodash/_baseRest.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/_baseRest.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var identity = __webpack_require__(/*! ./identity */ "./node_modules/lodash/identity.js"),
    overRest = __webpack_require__(/*! ./_overRest */ "./node_modules/lodash/_overRest.js"),
    setToString = __webpack_require__(/*! ./_setToString */ "./node_modules/lodash/_setToString.js");

/**
 * The base implementation of `_.rest` which doesn't validate or coerce arguments.
 *
 * @private
 * @param {Function} func The function to apply a rest parameter to.
 * @param {number} [start=func.length-1] The start position of the rest parameter.
 * @returns {Function} Returns the new function.
 */
function baseRest(func, start) {
  return setToString(overRest(func, start, identity), func + '');
}

module.exports = baseRest;


/***/ }),

/***/ "./node_modules/lodash/_baseSet.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/_baseSet.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var assignValue = __webpack_require__(/*! ./_assignValue */ "./node_modules/lodash/_assignValue.js"),
    castPath = __webpack_require__(/*! ./_castPath */ "./node_modules/lodash/_castPath.js"),
    isIndex = __webpack_require__(/*! ./_isIndex */ "./node_modules/lodash/_isIndex.js"),
    isObject = __webpack_require__(/*! ./isObject */ "./node_modules/lodash/isObject.js"),
    toKey = __webpack_require__(/*! ./_toKey */ "./node_modules/lodash/_toKey.js");

/**
 * The base implementation of `_.set`.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {Array|string} path The path of the property to set.
 * @param {*} value The value to set.
 * @param {Function} [customizer] The function to customize path creation.
 * @returns {Object} Returns `object`.
 */
function baseSet(object, path, value, customizer) {
  if (!isObject(object)) {
    return object;
  }
  path = castPath(path, object);

  var index = -1,
      length = path.length,
      lastIndex = length - 1,
      nested = object;

  while (nested != null && ++index < length) {
    var key = toKey(path[index]),
        newValue = value;

    if (key === '__proto__' || key === 'constructor' || key === 'prototype') {
      return object;
    }

    if (index != lastIndex) {
      var objValue = nested[key];
      newValue = customizer ? customizer(objValue, key, nested) : undefined;
      if (newValue === undefined) {
        newValue = isObject(objValue)
          ? objValue
          : (isIndex(path[index + 1]) ? [] : {});
      }
    }
    assignValue(nested, key, newValue);
    nested = nested[key];
  }
  return object;
}

module.exports = baseSet;


/***/ }),

/***/ "./node_modules/lodash/_baseSetToString.js":
/*!*************************************************!*\
  !*** ./node_modules/lodash/_baseSetToString.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var constant = __webpack_require__(/*! ./constant */ "./node_modules/lodash/constant.js"),
    defineProperty = __webpack_require__(/*! ./_defineProperty */ "./node_modules/lodash/_defineProperty.js"),
    identity = __webpack_require__(/*! ./identity */ "./node_modules/lodash/identity.js");

/**
 * The base implementation of `setToString` without support for hot loop shorting.
 *
 * @private
 * @param {Function} func The function to modify.
 * @param {Function} string The `toString` result.
 * @returns {Function} Returns `func`.
 */
var baseSetToString = !defineProperty ? identity : function(func, string) {
  return defineProperty(func, 'toString', {
    'configurable': true,
    'enumerable': false,
    'value': constant(string),
    'writable': true
  });
};

module.exports = baseSetToString;


/***/ }),

/***/ "./node_modules/lodash/_baseSortBy.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_baseSortBy.js ***!
  \********************************************/
/***/ ((module) => {

/**
 * The base implementation of `_.sortBy` which uses `comparer` to define the
 * sort order of `array` and replaces criteria objects with their corresponding
 * values.
 *
 * @private
 * @param {Array} array The array to sort.
 * @param {Function} comparer The function to define sort order.
 * @returns {Array} Returns `array`.
 */
function baseSortBy(array, comparer) {
  var length = array.length;

  array.sort(comparer);
  while (length--) {
    array[length] = array[length].value;
  }
  return array;
}

module.exports = baseSortBy;


/***/ }),

/***/ "./node_modules/lodash/_baseTimes.js":
/*!*******************************************!*\
  !*** ./node_modules/lodash/_baseTimes.js ***!
  \*******************************************/
/***/ ((module) => {

/**
 * The base implementation of `_.times` without support for iteratee shorthands
 * or max array length checks.
 *
 * @private
 * @param {number} n The number of times to invoke `iteratee`.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the array of results.
 */
function baseTimes(n, iteratee) {
  var index = -1,
      result = Array(n);

  while (++index < n) {
    result[index] = iteratee(index);
  }
  return result;
}

module.exports = baseTimes;


/***/ }),

/***/ "./node_modules/lodash/_baseToString.js":
/*!**********************************************!*\
  !*** ./node_modules/lodash/_baseToString.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var Symbol = __webpack_require__(/*! ./_Symbol */ "./node_modules/lodash/_Symbol.js"),
    arrayMap = __webpack_require__(/*! ./_arrayMap */ "./node_modules/lodash/_arrayMap.js"),
    isArray = __webpack_require__(/*! ./isArray */ "./node_modules/lodash/isArray.js"),
    isSymbol = __webpack_require__(/*! ./isSymbol */ "./node_modules/lodash/isSymbol.js");

/** Used as references for various `Number` constants. */
var INFINITY = 1 / 0;

/** Used to convert symbols to primitives and strings. */
var symbolProto = Symbol ? Symbol.prototype : undefined,
    symbolToString = symbolProto ? symbolProto.toString : undefined;

/**
 * The base implementation of `_.toString` which doesn't convert nullish
 * values to empty strings.
 *
 * @private
 * @param {*} value The value to process.
 * @returns {string} Returns the string.
 */
function baseToString(value) {
  // Exit early for strings to avoid a performance hit in some environments.
  if (typeof value == 'string') {
    return value;
  }
  if (isArray(value)) {
    // Recursively convert values (susceptible to call stack limits).
    return arrayMap(value, baseToString) + '';
  }
  if (isSymbol(value)) {
    return symbolToString ? symbolToString.call(value) : '';
  }
  var result = (value + '');
  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
}

module.exports = baseToString;


/***/ }),

/***/ "./node_modules/lodash/_baseTrim.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/_baseTrim.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var trimmedEndIndex = __webpack_require__(/*! ./_trimmedEndIndex */ "./node_modules/lodash/_trimmedEndIndex.js");

/** Used to match leading whitespace. */
var reTrimStart = /^\s+/;

/**
 * The base implementation of `_.trim`.
 *
 * @private
 * @param {string} string The string to trim.
 * @returns {string} Returns the trimmed string.
 */
function baseTrim(string) {
  return string
    ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, '')
    : string;
}

module.exports = baseTrim;


/***/ }),

/***/ "./node_modules/lodash/_baseUnary.js":
/*!*******************************************!*\
  !*** ./node_modules/lodash/_baseUnary.js ***!
  \*******************************************/
/***/ ((module) => {

/**
 * The base implementation of `_.unary` without support for storing metadata.
 *
 * @private
 * @param {Function} func The function to cap arguments for.
 * @returns {Function} Returns the new capped function.
 */
function baseUnary(func) {
  return function(value) {
    return func(value);
  };
}

module.exports = baseUnary;


/***/ }),

/***/ "./node_modules/lodash/_baseUniq.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/_baseUniq.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var SetCache = __webpack_require__(/*! ./_SetCache */ "./node_modules/lodash/_SetCache.js"),
    arrayIncludes = __webpack_require__(/*! ./_arrayIncludes */ "./node_modules/lodash/_arrayIncludes.js"),
    arrayIncludesWith = __webpack_require__(/*! ./_arrayIncludesWith */ "./node_modules/lodash/_arrayIncludesWith.js"),
    cacheHas = __webpack_require__(/*! ./_cacheHas */ "./node_modules/lodash/_cacheHas.js"),
    createSet = __webpack_require__(/*! ./_createSet */ "./node_modules/lodash/_createSet.js"),
    setToArray = __webpack_require__(/*! ./_setToArray */ "./node_modules/lodash/_setToArray.js");

/** Used as the size to enable large array optimizations. */
var LARGE_ARRAY_SIZE = 200;

/**
 * The base implementation of `_.uniqBy` without support for iteratee shorthands.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {Function} [iteratee] The iteratee invoked per element.
 * @param {Function} [comparator] The comparator invoked per element.
 * @returns {Array} Returns the new duplicate free array.
 */
function baseUniq(array, iteratee, comparator) {
  var index = -1,
      includes = arrayIncludes,
      length = array.length,
      isCommon = true,
      result = [],
      seen = result;

  if (comparator) {
    isCommon = false;
    includes = arrayIncludesWith;
  }
  else if (length >= LARGE_ARRAY_SIZE) {
    var set = iteratee ? null : createSet(array);
    if (set) {
      return setToArray(set);
    }
    isCommon = false;
    includes = cacheHas;
    seen = new SetCache;
  }
  else {
    seen = iteratee ? [] : result;
  }
  outer:
  while (++index < length) {
    var value = array[index],
        computed = iteratee ? iteratee(value) : value;

    value = (comparator || value !== 0) ? value : 0;
    if (isCommon && computed === computed) {
      var seenIndex = seen.length;
      while (seenIndex--) {
        if (seen[seenIndex] === computed) {
          continue outer;
        }
      }
      if (iteratee) {
        seen.push(computed);
      }
      result.push(value);
    }
    else if (!includes(seen, computed, comparator)) {
      if (seen !== result) {
        seen.push(computed);
      }
      result.push(value);
    }
  }
  return result;
}

module.exports = baseUniq;


/***/ }),

/***/ "./node_modules/lodash/_baseValues.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_baseValues.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var arrayMap = __webpack_require__(/*! ./_arrayMap */ "./node_modules/lodash/_arrayMap.js");

/**
 * The base implementation of `_.values` and `_.valuesIn` which creates an
 * array of `object` property values corresponding to the property names
 * of `props`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array} props The property names to get values for.
 * @returns {Object} Returns the array of property values.
 */
function baseValues(object, props) {
  return arrayMap(props, function(key) {
    return object[key];
  });
}

module.exports = baseValues;


/***/ }),

/***/ "./node_modules/lodash/_baseZipObject.js":
/*!***********************************************!*\
  !*** ./node_modules/lodash/_baseZipObject.js ***!
  \***********************************************/
/***/ ((module) => {

/**
 * This base implementation of `_.zipObject` which assigns values using `assignFunc`.
 *
 * @private
 * @param {Array} props The property identifiers.
 * @param {Array} values The property values.
 * @param {Function} assignFunc The function to assign values.
 * @returns {Object} Returns the new object.
 */
function baseZipObject(props, values, assignFunc) {
  var index = -1,
      length = props.length,
      valsLength = values.length,
      result = {};

  while (++index < length) {
    var value = index < valsLength ? values[index] : undefined;
    assignFunc(result, props[index], value);
  }
  return result;
}

module.exports = baseZipObject;


/***/ }),

/***/ "./node_modules/lodash/_cacheHas.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/_cacheHas.js ***!
  \******************************************/
/***/ ((module) => {

/**
 * Checks if a `cache` value for `key` exists.
 *
 * @private
 * @param {Object} cache The cache to query.
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function cacheHas(cache, key) {
  return cache.has(key);
}

module.exports = cacheHas;


/***/ }),

/***/ "./node_modules/lodash/_castFunction.js":
/*!**********************************************!*\
  !*** ./node_modules/lodash/_castFunction.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var identity = __webpack_require__(/*! ./identity */ "./node_modules/lodash/identity.js");

/**
 * Casts `value` to `identity` if it's not a function.
 *
 * @private
 * @param {*} value The value to inspect.
 * @returns {Function} Returns cast function.
 */
function castFunction(value) {
  return typeof value == 'function' ? value : identity;
}

module.exports = castFunction;


/***/ }),

/***/ "./node_modules/lodash/_castPath.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/_castPath.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var isArray = __webpack_require__(/*! ./isArray */ "./node_modules/lodash/isArray.js"),
    isKey = __webpack_require__(/*! ./_isKey */ "./node_modules/lodash/_isKey.js"),
    stringToPath = __webpack_require__(/*! ./_stringToPath */ "./node_modules/lodash/_stringToPath.js"),
    toString = __webpack_require__(/*! ./toString */ "./node_modules/lodash/toString.js");

/**
 * Casts `value` to a path array if it's not one.
 *
 * @private
 * @param {*} value The value to inspect.
 * @param {Object} [object] The object to query keys on.
 * @returns {Array} Returns the cast property path array.
 */
function castPath(value, object) {
  if (isArray(value)) {
    return value;
  }
  return isKey(value, object) ? [value] : stringToPath(toString(value));
}

module.exports = castPath;


/***/ }),

/***/ "./node_modules/lodash/_cloneArrayBuffer.js":
/*!**************************************************!*\
  !*** ./node_modules/lodash/_cloneArrayBuffer.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var Uint8Array = __webpack_require__(/*! ./_Uint8Array */ "./node_modules/lodash/_Uint8Array.js");

/**
 * Creates a clone of `arrayBuffer`.
 *
 * @private
 * @param {ArrayBuffer} arrayBuffer The array buffer to clone.
 * @returns {ArrayBuffer} Returns the cloned array buffer.
 */
function cloneArrayBuffer(arrayBuffer) {
  var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
  new Uint8Array(result).set(new Uint8Array(arrayBuffer));
  return result;
}

module.exports = cloneArrayBuffer;


/***/ }),

/***/ "./node_modules/lodash/_cloneBuffer.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash/_cloneBuffer.js ***!
  \*********************************************/
/***/ ((module, exports, __webpack_require__) => {

/* module decorator */ module = __webpack_require__.nmd(module);
var root = __webpack_require__(/*! ./_root */ "./node_modules/lodash/_root.js");

/** Detect free variable `exports`. */
var freeExports =  true && exports && !exports.nodeType && exports;

/** Detect free variable `module`. */
var freeModule = freeExports && "object" == 'object' && module && !module.nodeType && module;

/** Detect the popular CommonJS extension `module.exports`. */
var moduleExports = freeModule && freeModule.exports === freeExports;

/** Built-in value references. */
var Buffer = moduleExports ? root.Buffer : undefined,
    allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined;

/**
 * Creates a clone of  `buffer`.
 *
 * @private
 * @param {Buffer} buffer The buffer to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Buffer} Returns the cloned buffer.
 */
function cloneBuffer(buffer, isDeep) {
  if (isDeep) {
    return buffer.slice();
  }
  var length = buffer.length,
      result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);

  buffer.copy(result);
  return result;
}

module.exports = cloneBuffer;


/***/ }),

/***/ "./node_modules/lodash/_cloneDataView.js":
/*!***********************************************!*\
  !*** ./node_modules/lodash/_cloneDataView.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var cloneArrayBuffer = __webpack_require__(/*! ./_cloneArrayBuffer */ "./node_modules/lodash/_cloneArrayBuffer.js");

/**
 * Creates a clone of `dataView`.
 *
 * @private
 * @param {Object} dataView The data view to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the cloned data view.
 */
function cloneDataView(dataView, isDeep) {
  var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
  return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
}

module.exports = cloneDataView;


/***/ }),

/***/ "./node_modules/lodash/_cloneRegExp.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash/_cloneRegExp.js ***!
  \*********************************************/
/***/ ((module) => {

/** Used to match `RegExp` flags from their coerced string values. */
var reFlags = /\w*$/;

/**
 * Creates a clone of `regexp`.
 *
 * @private
 * @param {Object} regexp The regexp to clone.
 * @returns {Object} Returns the cloned regexp.
 */
function cloneRegExp(regexp) {
  var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
  result.lastIndex = regexp.lastIndex;
  return result;
}

module.exports = cloneRegExp;


/***/ }),

/***/ "./node_modules/lodash/_cloneSymbol.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash/_cloneSymbol.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var Symbol = __webpack_require__(/*! ./_Symbol */ "./node_modules/lodash/_Symbol.js");

/** Used to convert symbols to primitives and strings. */
var symbolProto = Symbol ? Symbol.prototype : undefined,
    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;

/**
 * Creates a clone of the `symbol` object.
 *
 * @private
 * @param {Object} symbol The symbol object to clone.
 * @returns {Object} Returns the cloned symbol object.
 */
function cloneSymbol(symbol) {
  return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
}

module.exports = cloneSymbol;


/***/ }),

/***/ "./node_modules/lodash/_cloneTypedArray.js":
/*!*************************************************!*\
  !*** ./node_modules/lodash/_cloneTypedArray.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var cloneArrayBuffer = __webpack_require__(/*! ./_cloneArrayBuffer */ "./node_modules/lodash/_cloneArrayBuffer.js");

/**
 * Creates a clone of `typedArray`.
 *
 * @private
 * @param {Object} typedArray The typed array to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the cloned typed array.
 */
function cloneTypedArray(typedArray, isDeep) {
  var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
  return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
}

module.exports = cloneTypedArray;


/***/ }),

/***/ "./node_modules/lodash/_compareAscending.js":
/*!**************************************************!*\
  !*** ./node_modules/lodash/_compareAscending.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var isSymbol = __webpack_require__(/*! ./isSymbol */ "./node_modules/lodash/isSymbol.js");

/**
 * Compares values to sort them in ascending order.
 *
 * @private
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {number} Returns the sort order indicator for `value`.
 */
function compareAscending(value, other) {
  if (value !== other) {
    var valIsDefined = value !== undefined,
        valIsNull = value === null,
        valIsReflexive = value === value,
        valIsSymbol = isSymbol(value);

    var othIsDefined = other !== undefined,
        othIsNull = other === null,
        othIsReflexive = other === other,
        othIsSymbol = isSymbol(other);

    if ((!othIsNull && !othIsSymbol && !valIsSymbol && value > other) ||
        (valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol) ||
        (valIsNull && othIsDefined && othIsReflexive) ||
        (!valIsDefined && othIsReflexive) ||
        !valIsReflexive) {
      return 1;
    }
    if ((!valIsNull && !valIsSymbol && !othIsSymbol && value < other) ||
        (othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol) ||
        (othIsNull && valIsDefined && valIsReflexive) ||
        (!othIsDefined && valIsReflexive) ||
        !othIsReflexive) {
      return -1;
    }
  }
  return 0;
}

module.exports = compareAscending;


/***/ }),

/***/ "./node_modules/lodash/_compareMultiple.js":
/*!*************************************************!*\
  !*** ./node_modules/lodash/_compareMultiple.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var compareAscending = __webpack_require__(/*! ./_compareAscending */ "./node_modules/lodash/_compareAscending.js");

/**
 * Used by `_.orderBy` to compare multiple properties of a value to another
 * and stable sort them.
 *
 * If `orders` is unspecified, all values are sorted in ascending order. Otherwise,
 * specify an order of "desc" for descending or "asc" for ascending sort order
 * of corresponding values.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {boolean[]|string[]} orders The order to sort by for each property.
 * @returns {number} Returns the sort order indicator for `object`.
 */
function compareMultiple(object, other, orders) {
  var index = -1,
      objCriteria = object.criteria,
      othCriteria = other.criteria,
      length = objCriteria.length,
      ordersLength = orders.length;

  while (++index < length) {
    var result = compareAscending(objCriteria[index], othCriteria[index]);
    if (result) {
      if (index >= ordersLength) {
        return result;
      }
      var order = orders[index];
      return result * (order == 'desc' ? -1 : 1);
    }
  }
  // Fixes an `Array#sort` bug in the JS engine embedded in Adobe applications
  // that causes it, under certain circumstances, to provide the same value for
  // `object` and `other`. See https://github.com/jashkenas/underscore/pull/1247
  // for more details.
  //
  // This also ensures a stable sort in V8 and other engines.
  // See https://bugs.chromium.org/p/v8/issues/detail?id=90 for more details.
  return object.index - other.index;
}

module.exports = compareMultiple;


/***/ }),

/***/ "./node_modules/lodash/_copyArray.js":
/*!*******************************************!*\
  !*** ./node_modules/lodash/_copyArray.js ***!
  \*******************************************/
/***/ ((module) => {

/**
 * Copies the values of `source` to `array`.
 *
 * @private
 * @param {Array} source The array to copy values from.
 * @param {Array} [array=[]] The array to copy values to.
 * @returns {Array} Returns `array`.
 */
function copyArray(source, array) {
  var index = -1,
      length = source.length;

  array || (array = Array(length));
  while (++index < length) {
    array[index] = source[index];
  }
  return array;
}

module.exports = copyArray;


/***/ }),

/***/ "./node_modules/lodash/_copyObject.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_copyObject.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var assignValue = __webpack_require__(/*! ./_assignValue */ "./node_modules/lodash/_assignValue.js"),
    baseAssignValue = __webpack_require__(/*! ./_baseAssignValue */ "./node_modules/lodash/_baseAssignValue.js");

/**
 * Copies properties of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy properties from.
 * @param {Array} props The property identifiers to copy.
 * @param {Object} [object={}] The object to copy properties to.
 * @param {Function} [customizer] The function to customize copied values.
 * @returns {Object} Returns `object`.
 */
function copyObject(source, props, object, customizer) {
  var isNew = !object;
  object || (object = {});

  var index = -1,
      length = props.length;

  while (++index < length) {
    var key = props[index];

    var newValue = customizer
      ? customizer(object[key], source[key], key, object, source)
      : undefined;

    if (newValue === undefined) {
      newValue = source[key];
    }
    if (isNew) {
      baseAssignValue(object, key, newValue);
    } else {
      assignValue(object, key, newValue);
    }
  }
  return object;
}

module.exports = copyObject;


/***/ }),

/***/ "./node_modules/lodash/_copySymbols.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash/_copySymbols.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var copyObject = __webpack_require__(/*! ./_copyObject */ "./node_modules/lodash/_copyObject.js"),
    getSymbols = __webpack_require__(/*! ./_getSymbols */ "./node_modules/lodash/_getSymbols.js");

/**
 * Copies own symbols of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy symbols from.
 * @param {Object} [object={}] The object to copy symbols to.
 * @returns {Object} Returns `object`.
 */
function copySymbols(source, object) {
  return copyObject(source, getSymbols(source), object);
}

module.exports = copySymbols;


/***/ }),

/***/ "./node_modules/lodash/_copySymbolsIn.js":
/*!***********************************************!*\
  !*** ./node_modules/lodash/_copySymbolsIn.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var copyObject = __webpack_require__(/*! ./_copyObject */ "./node_modules/lodash/_copyObject.js"),
    getSymbolsIn = __webpack_require__(/*! ./_getSymbolsIn */ "./node_modules/lodash/_getSymbolsIn.js");

/**
 * Copies own and inherited symbols of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy symbols from.
 * @param {Object} [object={}] The object to copy symbols to.
 * @returns {Object} Returns `object`.
 */
function copySymbolsIn(source, object) {
  return copyObject(source, getSymbolsIn(source), object);
}

module.exports = copySymbolsIn;


/***/ }),

/***/ "./node_modules/lodash/_coreJsData.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_coreJsData.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var root = __webpack_require__(/*! ./_root */ "./node_modules/lodash/_root.js");

/** Used to detect overreaching core-js shims. */
var coreJsData = root['__core-js_shared__'];

module.exports = coreJsData;


/***/ }),

/***/ "./node_modules/lodash/_createAssigner.js":
/*!************************************************!*\
  !*** ./node_modules/lodash/_createAssigner.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseRest = __webpack_require__(/*! ./_baseRest */ "./node_modules/lodash/_baseRest.js"),
    isIterateeCall = __webpack_require__(/*! ./_isIterateeCall */ "./node_modules/lodash/_isIterateeCall.js");

/**
 * Creates a function like `_.assign`.
 *
 * @private
 * @param {Function} assigner The function to assign values.
 * @returns {Function} Returns the new assigner function.
 */
function createAssigner(assigner) {
  return baseRest(function(object, sources) {
    var index = -1,
        length = sources.length,
        customizer = length > 1 ? sources[length - 1] : undefined,
        guard = length > 2 ? sources[2] : undefined;

    customizer = (assigner.length > 3 && typeof customizer == 'function')
      ? (length--, customizer)
      : undefined;

    if (guard && isIterateeCall(sources[0], sources[1], guard)) {
      customizer = length < 3 ? undefined : customizer;
      length = 1;
    }
    object = Object(object);
    while (++index < length) {
      var source = sources[index];
      if (source) {
        assigner(object, source, index, customizer);
      }
    }
    return object;
  });
}

module.exports = createAssigner;


/***/ }),

/***/ "./node_modules/lodash/_createBaseEach.js":
/*!************************************************!*\
  !*** ./node_modules/lodash/_createBaseEach.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var isArrayLike = __webpack_require__(/*! ./isArrayLike */ "./node_modules/lodash/isArrayLike.js");

/**
 * Creates a `baseEach` or `baseEachRight` function.
 *
 * @private
 * @param {Function} eachFunc The function to iterate over a collection.
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {Function} Returns the new base function.
 */
function createBaseEach(eachFunc, fromRight) {
  return function(collection, iteratee) {
    if (collection == null) {
      return collection;
    }
    if (!isArrayLike(collection)) {
      return eachFunc(collection, iteratee);
    }
    var length = collection.length,
        index = fromRight ? length : -1,
        iterable = Object(collection);

    while ((fromRight ? index-- : ++index < length)) {
      if (iteratee(iterable[index], index, iterable) === false) {
        break;
      }
    }
    return collection;
  };
}

module.exports = createBaseEach;


/***/ }),

/***/ "./node_modules/lodash/_createBaseFor.js":
/*!***********************************************!*\
  !*** ./node_modules/lodash/_createBaseFor.js ***!
  \***********************************************/
/***/ ((module) => {

/**
 * Creates a base function for methods like `_.forIn` and `_.forOwn`.
 *
 * @private
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {Function} Returns the new base function.
 */
function createBaseFor(fromRight) {
  return function(object, iteratee, keysFunc) {
    var index = -1,
        iterable = Object(object),
        props = keysFunc(object),
        length = props.length;

    while (length--) {
      var key = props[fromRight ? length : ++index];
      if (iteratee(iterable[key], key, iterable) === false) {
        break;
      }
    }
    return object;
  };
}

module.exports = createBaseFor;


/***/ }),

/***/ "./node_modules/lodash/_createFind.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_createFind.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseIteratee = __webpack_require__(/*! ./_baseIteratee */ "./node_modules/lodash/_baseIteratee.js"),
    isArrayLike = __webpack_require__(/*! ./isArrayLike */ "./node_modules/lodash/isArrayLike.js"),
    keys = __webpack_require__(/*! ./keys */ "./node_modules/lodash/keys.js");

/**
 * Creates a `_.find` or `_.findLast` function.
 *
 * @private
 * @param {Function} findIndexFunc The function to find the collection index.
 * @returns {Function} Returns the new find function.
 */
function createFind(findIndexFunc) {
  return function(collection, predicate, fromIndex) {
    var iterable = Object(collection);
    if (!isArrayLike(collection)) {
      var iteratee = baseIteratee(predicate, 3);
      collection = keys(collection);
      predicate = function(key) { return iteratee(iterable[key], key, iterable); };
    }
    var index = findIndexFunc(collection, predicate, fromIndex);
    return index > -1 ? iterable[iteratee ? collection[index] : index] : undefined;
  };
}

module.exports = createFind;


/***/ }),

/***/ "./node_modules/lodash/_createRange.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash/_createRange.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseRange = __webpack_require__(/*! ./_baseRange */ "./node_modules/lodash/_baseRange.js"),
    isIterateeCall = __webpack_require__(/*! ./_isIterateeCall */ "./node_modules/lodash/_isIterateeCall.js"),
    toFinite = __webpack_require__(/*! ./toFinite */ "./node_modules/lodash/toFinite.js");

/**
 * Creates a `_.range` or `_.rangeRight` function.
 *
 * @private
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {Function} Returns the new range function.
 */
function createRange(fromRight) {
  return function(start, end, step) {
    if (step && typeof step != 'number' && isIterateeCall(start, end, step)) {
      end = step = undefined;
    }
    // Ensure the sign of `-0` is preserved.
    start = toFinite(start);
    if (end === undefined) {
      end = start;
      start = 0;
    } else {
      end = toFinite(end);
    }
    step = step === undefined ? (start < end ? 1 : -1) : toFinite(step);
    return baseRange(start, end, step, fromRight);
  };
}

module.exports = createRange;


/***/ }),

/***/ "./node_modules/lodash/_createSet.js":
/*!*******************************************!*\
  !*** ./node_modules/lodash/_createSet.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var Set = __webpack_require__(/*! ./_Set */ "./node_modules/lodash/_Set.js"),
    noop = __webpack_require__(/*! ./noop */ "./node_modules/lodash/noop.js"),
    setToArray = __webpack_require__(/*! ./_setToArray */ "./node_modules/lodash/_setToArray.js");

/** Used as references for various `Number` constants. */
var INFINITY = 1 / 0;

/**
 * Creates a set object of `values`.
 *
 * @private
 * @param {Array} values The values to add to the set.
 * @returns {Object} Returns the new set.
 */
var createSet = !(Set && (1 / setToArray(new Set([,-0]))[1]) == INFINITY) ? noop : function(values) {
  return new Set(values);
};

module.exports = createSet;


/***/ }),

/***/ "./node_modules/lodash/_defineProperty.js":
/*!************************************************!*\
  !*** ./node_modules/lodash/_defineProperty.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var getNative = __webpack_require__(/*! ./_getNative */ "./node_modules/lodash/_getNative.js");

var defineProperty = (function() {
  try {
    var func = getNative(Object, 'defineProperty');
    func({}, '', {});
    return func;
  } catch (e) {}
}());

module.exports = defineProperty;


/***/ }),

/***/ "./node_modules/lodash/_equalArrays.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash/_equalArrays.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var SetCache = __webpack_require__(/*! ./_SetCache */ "./node_modules/lodash/_SetCache.js"),
    arraySome = __webpack_require__(/*! ./_arraySome */ "./node_modules/lodash/_arraySome.js"),
    cacheHas = __webpack_require__(/*! ./_cacheHas */ "./node_modules/lodash/_cacheHas.js");

/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG = 1,
    COMPARE_UNORDERED_FLAG = 2;

/**
 * A specialized version of `baseIsEqualDeep` for arrays with support for
 * partial deep comparisons.
 *
 * @private
 * @param {Array} array The array to compare.
 * @param {Array} other The other array to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} stack Tracks traversed `array` and `other` objects.
 * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
 */
function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
      arrLength = array.length,
      othLength = other.length;

  if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
    return false;
  }
  // Check that cyclic values are equal.
  var arrStacked = stack.get(array);
  var othStacked = stack.get(other);
  if (arrStacked && othStacked) {
    return arrStacked == other && othStacked == array;
  }
  var index = -1,
      result = true,
      seen = (bitmask & COMPARE_UNORDERED_FLAG) ? new SetCache : undefined;

  stack.set(array, other);
  stack.set(other, array);

  // Ignore non-index properties.
  while (++index < arrLength) {
    var arrValue = array[index],
        othValue = other[index];

    if (customizer) {
      var compared = isPartial
        ? customizer(othValue, arrValue, index, other, array, stack)
        : customizer(arrValue, othValue, index, array, other, stack);
    }
    if (compared !== undefined) {
      if (compared) {
        continue;
      }
      result = false;
      break;
    }
    // Recursively compare arrays (susceptible to call stack limits).
    if (seen) {
      if (!arraySome(other, function(othValue, othIndex) {
            if (!cacheHas(seen, othIndex) &&
                (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
              return seen.push(othIndex);
            }
          })) {
        result = false;
        break;
      }
    } else if (!(
          arrValue === othValue ||
            equalFunc(arrValue, othValue, bitmask, customizer, stack)
        )) {
      result = false;
      break;
    }
  }
  stack['delete'](array);
  stack['delete'](other);
  return result;
}

module.exports = equalArrays;


/***/ }),

/***/ "./node_modules/lodash/_equalByTag.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_equalByTag.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var Symbol = __webpack_require__(/*! ./_Symbol */ "./node_modules/lodash/_Symbol.js"),
    Uint8Array = __webpack_require__(/*! ./_Uint8Array */ "./node_modules/lodash/_Uint8Array.js"),
    eq = __webpack_require__(/*! ./eq */ "./node_modules/lodash/eq.js"),
    equalArrays = __webpack_require__(/*! ./_equalArrays */ "./node_modules/lodash/_equalArrays.js"),
    mapToArray = __webpack_require__(/*! ./_mapToArray */ "./node_modules/lodash/_mapToArray.js"),
    setToArray = __webpack_require__(/*! ./_setToArray */ "./node_modules/lodash/_setToArray.js");

/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG = 1,
    COMPARE_UNORDERED_FLAG = 2;

/** `Object#toString` result references. */
var boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    errorTag = '[object Error]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    symbolTag = '[object Symbol]';

var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]';

/** Used to convert symbols to primitives and strings. */
var symbolProto = Symbol ? Symbol.prototype : undefined,
    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;

/**
 * A specialized version of `baseIsEqualDeep` for comparing objects of
 * the same `toStringTag`.
 *
 * **Note:** This function only supports comparing values with tags of
 * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {string} tag The `toStringTag` of the objects to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} stack Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */
function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
  switch (tag) {
    case dataViewTag:
      if ((object.byteLength != other.byteLength) ||
          (object.byteOffset != other.byteOffset)) {
        return false;
      }
      object = object.buffer;
      other = other.buffer;

    case arrayBufferTag:
      if ((object.byteLength != other.byteLength) ||
          !equalFunc(new Uint8Array(object), new Uint8Array(other))) {
        return false;
      }
      return true;

    case boolTag:
    case dateTag:
    case numberTag:
      // Coerce booleans to `1` or `0` and dates to milliseconds.
      // Invalid dates are coerced to `NaN`.
      return eq(+object, +other);

    case errorTag:
      return object.name == other.name && object.message == other.message;

    case regexpTag:
    case stringTag:
      // Coerce regexes to strings and treat strings, primitives and objects,
      // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring
      // for more details.
      return object == (other + '');

    case mapTag:
      var convert = mapToArray;

    case setTag:
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
      convert || (convert = setToArray);

      if (object.size != other.size && !isPartial) {
        return false;
      }
      // Assume cyclic values are equal.
      var stacked = stack.get(object);
      if (stacked) {
        return stacked == other;
      }
      bitmask |= COMPARE_UNORDERED_FLAG;

      // Recursively compare objects (susceptible to call stack limits).
      stack.set(object, other);
      var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
      stack['delete'](object);
      return result;

    case symbolTag:
      if (symbolValueOf) {
        return symbolValueOf.call(object) == symbolValueOf.call(other);
      }
  }
  return false;
}

module.exports = equalByTag;


/***/ }),

/***/ "./node_modules/lodash/_equalObjects.js":
/*!**********************************************!*\
  !*** ./node_modules/lodash/_equalObjects.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var getAllKeys = __webpack_require__(/*! ./_getAllKeys */ "./node_modules/lodash/_getAllKeys.js");

/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG = 1;

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * A specialized version of `baseIsEqualDeep` for objects with support for
 * partial deep comparisons.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} stack Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */
function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
      objProps = getAllKeys(object),
      objLength = objProps.length,
      othProps = getAllKeys(other),
      othLength = othProps.length;

  if (objLength != othLength && !isPartial) {
    return false;
  }
  var index = objLength;
  while (index--) {
    var key = objProps[index];
    if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
      return false;
    }
  }
  // Check that cyclic values are equal.
  var objStacked = stack.get(object);
  var othStacked = stack.get(other);
  if (objStacked && othStacked) {
    return objStacked == other && othStacked == object;
  }
  var result = true;
  stack.set(object, other);
  stack.set(other, object);

  var skipCtor = isPartial;
  while (++index < objLength) {
    key = objProps[index];
    var objValue = object[key],
        othValue = other[key];

    if (customizer) {
      var compared = isPartial
        ? customizer(othValue, objValue, key, other, object, stack)
        : customizer(objValue, othValue, key, object, other, stack);
    }
    // Recursively compare objects (susceptible to call stack limits).
    if (!(compared === undefined
          ? (objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack))
          : compared
        )) {
      result = false;
      break;
    }
    skipCtor || (skipCtor = key == 'constructor');
  }
  if (result && !skipCtor) {
    var objCtor = object.constructor,
        othCtor = other.constructor;

    // Non `Object` object instances with different constructors are not equal.
    if (objCtor != othCtor &&
        ('constructor' in object && 'constructor' in other) &&
        !(typeof objCtor == 'function' && objCtor instanceof objCtor &&
          typeof othCtor == 'function' && othCtor instanceof othCtor)) {
      result = false;
    }
  }
  stack['delete'](object);
  stack['delete'](other);
  return result;
}

module.exports = equalObjects;


/***/ }),

/***/ "./node_modules/lodash/_flatRest.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/_flatRest.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var flatten = __webpack_require__(/*! ./flatten */ "./node_modules/lodash/flatten.js"),
    overRest = __webpack_require__(/*! ./_overRest */ "./node_modules/lodash/_overRest.js"),
    setToString = __webpack_require__(/*! ./_setToString */ "./node_modules/lodash/_setToString.js");

/**
 * A specialized version of `baseRest` which flattens the rest array.
 *
 * @private
 * @param {Function} func The function to apply a rest parameter to.
 * @returns {Function} Returns the new function.
 */
function flatRest(func) {
  return setToString(overRest(func, undefined, flatten), func + '');
}

module.exports = flatRest;


/***/ }),

/***/ "./node_modules/lodash/_freeGlobal.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_freeGlobal.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/** Detect free variable `global` from Node.js. */
var freeGlobal = typeof __webpack_require__.g == 'object' && __webpack_require__.g && __webpack_require__.g.Object === Object && __webpack_require__.g;

module.exports = freeGlobal;


/***/ }),

/***/ "./node_modules/lodash/_getAllKeys.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_getAllKeys.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseGetAllKeys = __webpack_require__(/*! ./_baseGetAllKeys */ "./node_modules/lodash/_baseGetAllKeys.js"),
    getSymbols = __webpack_require__(/*! ./_getSymbols */ "./node_modules/lodash/_getSymbols.js"),
    keys = __webpack_require__(/*! ./keys */ "./node_modules/lodash/keys.js");

/**
 * Creates an array of own enumerable property names and symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names and symbols.
 */
function getAllKeys(object) {
  return baseGetAllKeys(object, keys, getSymbols);
}

module.exports = getAllKeys;


/***/ }),

/***/ "./node_modules/lodash/_getAllKeysIn.js":
/*!**********************************************!*\
  !*** ./node_modules/lodash/_getAllKeysIn.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseGetAllKeys = __webpack_require__(/*! ./_baseGetAllKeys */ "./node_modules/lodash/_baseGetAllKeys.js"),
    getSymbolsIn = __webpack_require__(/*! ./_getSymbolsIn */ "./node_modules/lodash/_getSymbolsIn.js"),
    keysIn = __webpack_require__(/*! ./keysIn */ "./node_modules/lodash/keysIn.js");

/**
 * Creates an array of own and inherited enumerable property names and
 * symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names and symbols.
 */
function getAllKeysIn(object) {
  return baseGetAllKeys(object, keysIn, getSymbolsIn);
}

module.exports = getAllKeysIn;


/***/ }),

/***/ "./node_modules/lodash/_getMapData.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_getMapData.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var isKeyable = __webpack_require__(/*! ./_isKeyable */ "./node_modules/lodash/_isKeyable.js");

/**
 * Gets the data for `map`.
 *
 * @private
 * @param {Object} map The map to query.
 * @param {string} key The reference key.
 * @returns {*} Returns the map data.
 */
function getMapData(map, key) {
  var data = map.__data__;
  return isKeyable(key)
    ? data[typeof key == 'string' ? 'string' : 'hash']
    : data.map;
}

module.exports = getMapData;


/***/ }),

/***/ "./node_modules/lodash/_getMatchData.js":
/*!**********************************************!*\
  !*** ./node_modules/lodash/_getMatchData.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var isStrictComparable = __webpack_require__(/*! ./_isStrictComparable */ "./node_modules/lodash/_isStrictComparable.js"),
    keys = __webpack_require__(/*! ./keys */ "./node_modules/lodash/keys.js");

/**
 * Gets the property names, values, and compare flags of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the match data of `object`.
 */
function getMatchData(object) {
  var result = keys(object),
      length = result.length;

  while (length--) {
    var key = result[length],
        value = object[key];

    result[length] = [key, value, isStrictComparable(value)];
  }
  return result;
}

module.exports = getMatchData;


/***/ }),

/***/ "./node_modules/lodash/_getNative.js":
/*!*******************************************!*\
  !*** ./node_modules/lodash/_getNative.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseIsNative = __webpack_require__(/*! ./_baseIsNative */ "./node_modules/lodash/_baseIsNative.js"),
    getValue = __webpack_require__(/*! ./_getValue */ "./node_modules/lodash/_getValue.js");

/**
 * Gets the native function at `key` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the method to get.
 * @returns {*} Returns the function if it's native, else `undefined`.
 */
function getNative(object, key) {
  var value = getValue(object, key);
  return baseIsNative(value) ? value : undefined;
}

module.exports = getNative;


/***/ }),

/***/ "./node_modules/lodash/_getPrototype.js":
/*!**********************************************!*\
  !*** ./node_modules/lodash/_getPrototype.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var overArg = __webpack_require__(/*! ./_overArg */ "./node_modules/lodash/_overArg.js");

/** Built-in value references. */
var getPrototype = overArg(Object.getPrototypeOf, Object);

module.exports = getPrototype;


/***/ }),

/***/ "./node_modules/lodash/_getRawTag.js":
/*!*******************************************!*\
  !*** ./node_modules/lodash/_getRawTag.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var Symbol = __webpack_require__(/*! ./_Symbol */ "./node_modules/lodash/_Symbol.js");

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var nativeObjectToString = objectProto.toString;

/** Built-in value references. */
var symToStringTag = Symbol ? Symbol.toStringTag : undefined;

/**
 * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the raw `toStringTag`.
 */
function getRawTag(value) {
  var isOwn = hasOwnProperty.call(value, symToStringTag),
      tag = value[symToStringTag];

  try {
    value[symToStringTag] = undefined;
    var unmasked = true;
  } catch (e) {}

  var result = nativeObjectToString.call(value);
  if (unmasked) {
    if (isOwn) {
      value[symToStringTag] = tag;
    } else {
      delete value[symToStringTag];
    }
  }
  return result;
}

module.exports = getRawTag;


/***/ }),

/***/ "./node_modules/lodash/_getSymbols.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_getSymbols.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var arrayFilter = __webpack_require__(/*! ./_arrayFilter */ "./node_modules/lodash/_arrayFilter.js"),
    stubArray = __webpack_require__(/*! ./stubArray */ "./node_modules/lodash/stubArray.js");

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Built-in value references. */
var propertyIsEnumerable = objectProto.propertyIsEnumerable;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeGetSymbols = Object.getOwnPropertySymbols;

/**
 * Creates an array of the own enumerable symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of symbols.
 */
var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
  if (object == null) {
    return [];
  }
  object = Object(object);
  return arrayFilter(nativeGetSymbols(object), function(symbol) {
    return propertyIsEnumerable.call(object, symbol);
  });
};

module.exports = getSymbols;


/***/ }),

/***/ "./node_modules/lodash/_getSymbolsIn.js":
/*!**********************************************!*\
  !*** ./node_modules/lodash/_getSymbolsIn.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var arrayPush = __webpack_require__(/*! ./_arrayPush */ "./node_modules/lodash/_arrayPush.js"),
    getPrototype = __webpack_require__(/*! ./_getPrototype */ "./node_modules/lodash/_getPrototype.js"),
    getSymbols = __webpack_require__(/*! ./_getSymbols */ "./node_modules/lodash/_getSymbols.js"),
    stubArray = __webpack_require__(/*! ./stubArray */ "./node_modules/lodash/stubArray.js");

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeGetSymbols = Object.getOwnPropertySymbols;

/**
 * Creates an array of the own and inherited enumerable symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of symbols.
 */
var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {
  var result = [];
  while (object) {
    arrayPush(result, getSymbols(object));
    object = getPrototype(object);
  }
  return result;
};

module.exports = getSymbolsIn;


/***/ }),

/***/ "./node_modules/lodash/_getTag.js":
/*!****************************************!*\
  !*** ./node_modules/lodash/_getTag.js ***!
  \****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var DataView = __webpack_require__(/*! ./_DataView */ "./node_modules/lodash/_DataView.js"),
    Map = __webpack_require__(/*! ./_Map */ "./node_modules/lodash/_Map.js"),
    Promise = __webpack_require__(/*! ./_Promise */ "./node_modules/lodash/_Promise.js"),
    Set = __webpack_require__(/*! ./_Set */ "./node_modules/lodash/_Set.js"),
    WeakMap = __webpack_require__(/*! ./_WeakMap */ "./node_modules/lodash/_WeakMap.js"),
    baseGetTag = __webpack_require__(/*! ./_baseGetTag */ "./node_modules/lodash/_baseGetTag.js"),
    toSource = __webpack_require__(/*! ./_toSource */ "./node_modules/lodash/_toSource.js");

/** `Object#toString` result references. */
var mapTag = '[object Map]',
    objectTag = '[object Object]',
    promiseTag = '[object Promise]',
    setTag = '[object Set]',
    weakMapTag = '[object WeakMap]';

var dataViewTag = '[object DataView]';

/** Used to detect maps, sets, and weakmaps. */
var dataViewCtorString = toSource(DataView),
    mapCtorString = toSource(Map),
    promiseCtorString = toSource(Promise),
    setCtorString = toSource(Set),
    weakMapCtorString = toSource(WeakMap);

/**
 * Gets the `toStringTag` of `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
var getTag = baseGetTag;

// Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.
if ((DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag) ||
    (Map && getTag(new Map) != mapTag) ||
    (Promise && getTag(Promise.resolve()) != promiseTag) ||
    (Set && getTag(new Set) != setTag) ||
    (WeakMap && getTag(new WeakMap) != weakMapTag)) {
  getTag = function(value) {
    var result = baseGetTag(value),
        Ctor = result == objectTag ? value.constructor : undefined,
        ctorString = Ctor ? toSource(Ctor) : '';

    if (ctorString) {
      switch (ctorString) {
        case dataViewCtorString: return dataViewTag;
        case mapCtorString: return mapTag;
        case promiseCtorString: return promiseTag;
        case setCtorString: return setTag;
        case weakMapCtorString: return weakMapTag;
      }
    }
    return result;
  };
}

module.exports = getTag;


/***/ }),

/***/ "./node_modules/lodash/_getValue.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/_getValue.js ***!
  \******************************************/
/***/ ((module) => {

/**
 * Gets the value at `key` of `object`.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */
function getValue(object, key) {
  return object == null ? undefined : object[key];
}

module.exports = getValue;


/***/ }),

/***/ "./node_modules/lodash/_hasPath.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/_hasPath.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var castPath = __webpack_require__(/*! ./_castPath */ "./node_modules/lodash/_castPath.js"),
    isArguments = __webpack_require__(/*! ./isArguments */ "./node_modules/lodash/isArguments.js"),
    isArray = __webpack_require__(/*! ./isArray */ "./node_modules/lodash/isArray.js"),
    isIndex = __webpack_require__(/*! ./_isIndex */ "./node_modules/lodash/_isIndex.js"),
    isLength = __webpack_require__(/*! ./isLength */ "./node_modules/lodash/isLength.js"),
    toKey = __webpack_require__(/*! ./_toKey */ "./node_modules/lodash/_toKey.js");

/**
 * Checks if `path` exists on `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array|string} path The path to check.
 * @param {Function} hasFunc The function to check properties.
 * @returns {boolean} Returns `true` if `path` exists, else `false`.
 */
function hasPath(object, path, hasFunc) {
  path = castPath(path, object);

  var index = -1,
      length = path.length,
      result = false;

  while (++index < length) {
    var key = toKey(path[index]);
    if (!(result = object != null && hasFunc(object, key))) {
      break;
    }
    object = object[key];
  }
  if (result || ++index != length) {
    return result;
  }
  length = object == null ? 0 : object.length;
  return !!length && isLength(length) && isIndex(key, length) &&
    (isArray(object) || isArguments(object));
}

module.exports = hasPath;


/***/ }),

/***/ "./node_modules/lodash/_hasUnicode.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_hasUnicode.js ***!
  \********************************************/
/***/ ((module) => {

/** Used to compose unicode character classes. */
var rsAstralRange = '\\ud800-\\udfff',
    rsComboMarksRange = '\\u0300-\\u036f',
    reComboHalfMarksRange = '\\ufe20-\\ufe2f',
    rsComboSymbolsRange = '\\u20d0-\\u20ff',
    rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange,
    rsVarRange = '\\ufe0e\\ufe0f';

/** Used to compose unicode capture groups. */
var rsZWJ = '\\u200d';

/** Used to detect strings with [zero-width joiners or code points from the astral planes](http://eev.ee/blog/2015/09/12/dark-corners-of-unicode/). */
var reHasUnicode = RegExp('[' + rsZWJ + rsAstralRange  + rsComboRange + rsVarRange + ']');

/**
 * Checks if `string` contains Unicode symbols.
 *
 * @private
 * @param {string} string The string to inspect.
 * @returns {boolean} Returns `true` if a symbol is found, else `false`.
 */
function hasUnicode(string) {
  return reHasUnicode.test(string);
}

module.exports = hasUnicode;


/***/ }),

/***/ "./node_modules/lodash/_hashClear.js":
/*!*******************************************!*\
  !*** ./node_modules/lodash/_hashClear.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var nativeCreate = __webpack_require__(/*! ./_nativeCreate */ "./node_modules/lodash/_nativeCreate.js");

/**
 * Removes all key-value entries from the hash.
 *
 * @private
 * @name clear
 * @memberOf Hash
 */
function hashClear() {
  this.__data__ = nativeCreate ? nativeCreate(null) : {};
  this.size = 0;
}

module.exports = hashClear;


/***/ }),

/***/ "./node_modules/lodash/_hashDelete.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_hashDelete.js ***!
  \********************************************/
/***/ ((module) => {

/**
 * Removes `key` and its value from the hash.
 *
 * @private
 * @name delete
 * @memberOf Hash
 * @param {Object} hash The hash to modify.
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function hashDelete(key) {
  var result = this.has(key) && delete this.__data__[key];
  this.size -= result ? 1 : 0;
  return result;
}

module.exports = hashDelete;


/***/ }),

/***/ "./node_modules/lodash/_hashGet.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/_hashGet.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var nativeCreate = __webpack_require__(/*! ./_nativeCreate */ "./node_modules/lodash/_nativeCreate.js");

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED = '__lodash_hash_undefined__';

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Gets the hash value for `key`.
 *
 * @private
 * @name get
 * @memberOf Hash
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function hashGet(key) {
  var data = this.__data__;
  if (nativeCreate) {
    var result = data[key];
    return result === HASH_UNDEFINED ? undefined : result;
  }
  return hasOwnProperty.call(data, key) ? data[key] : undefined;
}

module.exports = hashGet;


/***/ }),

/***/ "./node_modules/lodash/_hashHas.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/_hashHas.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var nativeCreate = __webpack_require__(/*! ./_nativeCreate */ "./node_modules/lodash/_nativeCreate.js");

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Checks if a hash value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Hash
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function hashHas(key) {
  var data = this.__data__;
  return nativeCreate ? (data[key] !== undefined) : hasOwnProperty.call(data, key);
}

module.exports = hashHas;


/***/ }),

/***/ "./node_modules/lodash/_hashSet.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/_hashSet.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var nativeCreate = __webpack_require__(/*! ./_nativeCreate */ "./node_modules/lodash/_nativeCreate.js");

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED = '__lodash_hash_undefined__';

/**
 * Sets the hash `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Hash
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the hash instance.
 */
function hashSet(key, value) {
  var data = this.__data__;
  this.size += this.has(key) ? 0 : 1;
  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;
  return this;
}

module.exports = hashSet;


/***/ }),

/***/ "./node_modules/lodash/_initCloneArray.js":
/*!************************************************!*\
  !*** ./node_modules/lodash/_initCloneArray.js ***!
  \************************************************/
/***/ ((module) => {

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Initializes an array clone.
 *
 * @private
 * @param {Array} array The array to clone.
 * @returns {Array} Returns the initialized clone.
 */
function initCloneArray(array) {
  var length = array.length,
      result = new array.constructor(length);

  // Add properties assigned by `RegExp#exec`.
  if (length && typeof array[0] == 'string' && hasOwnProperty.call(array, 'index')) {
    result.index = array.index;
    result.input = array.input;
  }
  return result;
}

module.exports = initCloneArray;


/***/ }),

/***/ "./node_modules/lodash/_initCloneByTag.js":
/*!************************************************!*\
  !*** ./node_modules/lodash/_initCloneByTag.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var cloneArrayBuffer = __webpack_require__(/*! ./_cloneArrayBuffer */ "./node_modules/lodash/_cloneArrayBuffer.js"),
    cloneDataView = __webpack_require__(/*! ./_cloneDataView */ "./node_modules/lodash/_cloneDataView.js"),
    cloneRegExp = __webpack_require__(/*! ./_cloneRegExp */ "./node_modules/lodash/_cloneRegExp.js"),
    cloneSymbol = __webpack_require__(/*! ./_cloneSymbol */ "./node_modules/lodash/_cloneSymbol.js"),
    cloneTypedArray = __webpack_require__(/*! ./_cloneTypedArray */ "./node_modules/lodash/_cloneTypedArray.js");

/** `Object#toString` result references. */
var boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    symbolTag = '[object Symbol]';

var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]',
    float32Tag = '[object Float32Array]',
    float64Tag = '[object Float64Array]',
    int8Tag = '[object Int8Array]',
    int16Tag = '[object Int16Array]',
    int32Tag = '[object Int32Array]',
    uint8Tag = '[object Uint8Array]',
    uint8ClampedTag = '[object Uint8ClampedArray]',
    uint16Tag = '[object Uint16Array]',
    uint32Tag = '[object Uint32Array]';

/**
 * Initializes an object clone based on its `toStringTag`.
 *
 * **Note:** This function only supports cloning values with tags of
 * `Boolean`, `Date`, `Error`, `Map`, `Number`, `RegExp`, `Set`, or `String`.
 *
 * @private
 * @param {Object} object The object to clone.
 * @param {string} tag The `toStringTag` of the object to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the initialized clone.
 */
function initCloneByTag(object, tag, isDeep) {
  var Ctor = object.constructor;
  switch (tag) {
    case arrayBufferTag:
      return cloneArrayBuffer(object);

    case boolTag:
    case dateTag:
      return new Ctor(+object);

    case dataViewTag:
      return cloneDataView(object, isDeep);

    case float32Tag: case float64Tag:
    case int8Tag: case int16Tag: case int32Tag:
    case uint8Tag: case uint8ClampedTag: case uint16Tag: case uint32Tag:
      return cloneTypedArray(object, isDeep);

    case mapTag:
      return new Ctor;

    case numberTag:
    case stringTag:
      return new Ctor(object);

    case regexpTag:
      return cloneRegExp(object);

    case setTag:
      return new Ctor;

    case symbolTag:
      return cloneSymbol(object);
  }
}

module.exports = initCloneByTag;


/***/ }),

/***/ "./node_modules/lodash/_initCloneObject.js":
/*!*************************************************!*\
  !*** ./node_modules/lodash/_initCloneObject.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseCreate = __webpack_require__(/*! ./_baseCreate */ "./node_modules/lodash/_baseCreate.js"),
    getPrototype = __webpack_require__(/*! ./_getPrototype */ "./node_modules/lodash/_getPrototype.js"),
    isPrototype = __webpack_require__(/*! ./_isPrototype */ "./node_modules/lodash/_isPrototype.js");

/**
 * Initializes an object clone.
 *
 * @private
 * @param {Object} object The object to clone.
 * @returns {Object} Returns the initialized clone.
 */
function initCloneObject(object) {
  return (typeof object.constructor == 'function' && !isPrototype(object))
    ? baseCreate(getPrototype(object))
    : {};
}

module.exports = initCloneObject;


/***/ }),

/***/ "./node_modules/lodash/_isFlattenable.js":
/*!***********************************************!*\
  !*** ./node_modules/lodash/_isFlattenable.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var Symbol = __webpack_require__(/*! ./_Symbol */ "./node_modules/lodash/_Symbol.js"),
    isArguments = __webpack_require__(/*! ./isArguments */ "./node_modules/lodash/isArguments.js"),
    isArray = __webpack_require__(/*! ./isArray */ "./node_modules/lodash/isArray.js");

/** Built-in value references. */
var spreadableSymbol = Symbol ? Symbol.isConcatSpreadable : undefined;

/**
 * Checks if `value` is a flattenable `arguments` object or array.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is flattenable, else `false`.
 */
function isFlattenable(value) {
  return isArray(value) || isArguments(value) ||
    !!(spreadableSymbol && value && value[spreadableSymbol]);
}

module.exports = isFlattenable;


/***/ }),

/***/ "./node_modules/lodash/_isIndex.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/_isIndex.js ***!
  \*****************************************/
/***/ ((module) => {

/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER = 9007199254740991;

/** Used to detect unsigned integer values. */
var reIsUint = /^(?:0|[1-9]\d*)$/;

/**
 * Checks if `value` is a valid array-like index.
 *
 * @private
 * @param {*} value The value to check.
 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
 */
function isIndex(value, length) {
  var type = typeof value;
  length = length == null ? MAX_SAFE_INTEGER : length;

  return !!length &&
    (type == 'number' ||
      (type != 'symbol' && reIsUint.test(value))) &&
        (value > -1 && value % 1 == 0 && value < length);
}

module.exports = isIndex;


/***/ }),

/***/ "./node_modules/lodash/_isIterateeCall.js":
/*!************************************************!*\
  !*** ./node_modules/lodash/_isIterateeCall.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var eq = __webpack_require__(/*! ./eq */ "./node_modules/lodash/eq.js"),
    isArrayLike = __webpack_require__(/*! ./isArrayLike */ "./node_modules/lodash/isArrayLike.js"),
    isIndex = __webpack_require__(/*! ./_isIndex */ "./node_modules/lodash/_isIndex.js"),
    isObject = __webpack_require__(/*! ./isObject */ "./node_modules/lodash/isObject.js");

/**
 * Checks if the given arguments are from an iteratee call.
 *
 * @private
 * @param {*} value The potential iteratee value argument.
 * @param {*} index The potential iteratee index or key argument.
 * @param {*} object The potential iteratee object argument.
 * @returns {boolean} Returns `true` if the arguments are from an iteratee call,
 *  else `false`.
 */
function isIterateeCall(value, index, object) {
  if (!isObject(object)) {
    return false;
  }
  var type = typeof index;
  if (type == 'number'
        ? (isArrayLike(object) && isIndex(index, object.length))
        : (type == 'string' && index in object)
      ) {
    return eq(object[index], value);
  }
  return false;
}

module.exports = isIterateeCall;


/***/ }),

/***/ "./node_modules/lodash/_isKey.js":
/*!***************************************!*\
  !*** ./node_modules/lodash/_isKey.js ***!
  \***************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var isArray = __webpack_require__(/*! ./isArray */ "./node_modules/lodash/isArray.js"),
    isSymbol = __webpack_require__(/*! ./isSymbol */ "./node_modules/lodash/isSymbol.js");

/** Used to match property names within property paths. */
var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
    reIsPlainProp = /^\w*$/;

/**
 * Checks if `value` is a property name and not a property path.
 *
 * @private
 * @param {*} value The value to check.
 * @param {Object} [object] The object to query keys on.
 * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
 */
function isKey(value, object) {
  if (isArray(value)) {
    return false;
  }
  var type = typeof value;
  if (type == 'number' || type == 'symbol' || type == 'boolean' ||
      value == null || isSymbol(value)) {
    return true;
  }
  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||
    (object != null && value in Object(object));
}

module.exports = isKey;


/***/ }),

/***/ "./node_modules/lodash/_isKeyable.js":
/*!*******************************************!*\
  !*** ./node_modules/lodash/_isKeyable.js ***!
  \*******************************************/
/***/ ((module) => {

/**
 * Checks if `value` is suitable for use as unique object key.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
 */
function isKeyable(value) {
  var type = typeof value;
  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
    ? (value !== '__proto__')
    : (value === null);
}

module.exports = isKeyable;


/***/ }),

/***/ "./node_modules/lodash/_isMasked.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/_isMasked.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var coreJsData = __webpack_require__(/*! ./_coreJsData */ "./node_modules/lodash/_coreJsData.js");

/** Used to detect methods masquerading as native. */
var maskSrcKey = (function() {
  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
  return uid ? ('Symbol(src)_1.' + uid) : '';
}());

/**
 * Checks if `func` has its source masked.
 *
 * @private
 * @param {Function} func The function to check.
 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
 */
function isMasked(func) {
  return !!maskSrcKey && (maskSrcKey in func);
}

module.exports = isMasked;


/***/ }),

/***/ "./node_modules/lodash/_isPrototype.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash/_isPrototype.js ***!
  \*********************************************/
/***/ ((module) => {

/** Used for built-in method references. */
var objectProto = Object.prototype;

/**
 * Checks if `value` is likely a prototype object.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
 */
function isPrototype(value) {
  var Ctor = value && value.constructor,
      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;

  return value === proto;
}

module.exports = isPrototype;


/***/ }),

/***/ "./node_modules/lodash/_isStrictComparable.js":
/*!****************************************************!*\
  !*** ./node_modules/lodash/_isStrictComparable.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var isObject = __webpack_require__(/*! ./isObject */ "./node_modules/lodash/isObject.js");

/**
 * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` if suitable for strict
 *  equality comparisons, else `false`.
 */
function isStrictComparable(value) {
  return value === value && !isObject(value);
}

module.exports = isStrictComparable;


/***/ }),

/***/ "./node_modules/lodash/_listCacheClear.js":
/*!************************************************!*\
  !*** ./node_modules/lodash/_listCacheClear.js ***!
  \************************************************/
/***/ ((module) => {

/**
 * Removes all key-value entries from the list cache.
 *
 * @private
 * @name clear
 * @memberOf ListCache
 */
function listCacheClear() {
  this.__data__ = [];
  this.size = 0;
}

module.exports = listCacheClear;


/***/ }),

/***/ "./node_modules/lodash/_listCacheDelete.js":
/*!*************************************************!*\
  !*** ./node_modules/lodash/_listCacheDelete.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var assocIndexOf = __webpack_require__(/*! ./_assocIndexOf */ "./node_modules/lodash/_assocIndexOf.js");

/** Used for built-in method references. */
var arrayProto = Array.prototype;

/** Built-in value references. */
var splice = arrayProto.splice;

/**
 * Removes `key` and its value from the list cache.
 *
 * @private
 * @name delete
 * @memberOf ListCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function listCacheDelete(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    return false;
  }
  var lastIndex = data.length - 1;
  if (index == lastIndex) {
    data.pop();
  } else {
    splice.call(data, index, 1);
  }
  --this.size;
  return true;
}

module.exports = listCacheDelete;


/***/ }),

/***/ "./node_modules/lodash/_listCacheGet.js":
/*!**********************************************!*\
  !*** ./node_modules/lodash/_listCacheGet.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var assocIndexOf = __webpack_require__(/*! ./_assocIndexOf */ "./node_modules/lodash/_assocIndexOf.js");

/**
 * Gets the list cache value for `key`.
 *
 * @private
 * @name get
 * @memberOf ListCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function listCacheGet(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  return index < 0 ? undefined : data[index][1];
}

module.exports = listCacheGet;


/***/ }),

/***/ "./node_modules/lodash/_listCacheHas.js":
/*!**********************************************!*\
  !*** ./node_modules/lodash/_listCacheHas.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var assocIndexOf = __webpack_require__(/*! ./_assocIndexOf */ "./node_modules/lodash/_assocIndexOf.js");

/**
 * Checks if a list cache value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf ListCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function listCacheHas(key) {
  return assocIndexOf(this.__data__, key) > -1;
}

module.exports = listCacheHas;


/***/ }),

/***/ "./node_modules/lodash/_listCacheSet.js":
/*!**********************************************!*\
  !*** ./node_modules/lodash/_listCacheSet.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var assocIndexOf = __webpack_require__(/*! ./_assocIndexOf */ "./node_modules/lodash/_assocIndexOf.js");

/**
 * Sets the list cache `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf ListCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the list cache instance.
 */
function listCacheSet(key, value) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    ++this.size;
    data.push([key, value]);
  } else {
    data[index][1] = value;
  }
  return this;
}

module.exports = listCacheSet;


/***/ }),

/***/ "./node_modules/lodash/_mapCacheClear.js":
/*!***********************************************!*\
  !*** ./node_modules/lodash/_mapCacheClear.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var Hash = __webpack_require__(/*! ./_Hash */ "./node_modules/lodash/_Hash.js"),
    ListCache = __webpack_require__(/*! ./_ListCache */ "./node_modules/lodash/_ListCache.js"),
    Map = __webpack_require__(/*! ./_Map */ "./node_modules/lodash/_Map.js");

/**
 * Removes all key-value entries from the map.
 *
 * @private
 * @name clear
 * @memberOf MapCache
 */
function mapCacheClear() {
  this.size = 0;
  this.__data__ = {
    'hash': new Hash,
    'map': new (Map || ListCache),
    'string': new Hash
  };
}

module.exports = mapCacheClear;


/***/ }),

/***/ "./node_modules/lodash/_mapCacheDelete.js":
/*!************************************************!*\
  !*** ./node_modules/lodash/_mapCacheDelete.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var getMapData = __webpack_require__(/*! ./_getMapData */ "./node_modules/lodash/_getMapData.js");

/**
 * Removes `key` and its value from the map.
 *
 * @private
 * @name delete
 * @memberOf MapCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function mapCacheDelete(key) {
  var result = getMapData(this, key)['delete'](key);
  this.size -= result ? 1 : 0;
  return result;
}

module.exports = mapCacheDelete;


/***/ }),

/***/ "./node_modules/lodash/_mapCacheGet.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash/_mapCacheGet.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var getMapData = __webpack_require__(/*! ./_getMapData */ "./node_modules/lodash/_getMapData.js");

/**
 * Gets the map value for `key`.
 *
 * @private
 * @name get
 * @memberOf MapCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function mapCacheGet(key) {
  return getMapData(this, key).get(key);
}

module.exports = mapCacheGet;


/***/ }),

/***/ "./node_modules/lodash/_mapCacheHas.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash/_mapCacheHas.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var getMapData = __webpack_require__(/*! ./_getMapData */ "./node_modules/lodash/_getMapData.js");

/**
 * Checks if a map value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf MapCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function mapCacheHas(key) {
  return getMapData(this, key).has(key);
}

module.exports = mapCacheHas;


/***/ }),

/***/ "./node_modules/lodash/_mapCacheSet.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash/_mapCacheSet.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var getMapData = __webpack_require__(/*! ./_getMapData */ "./node_modules/lodash/_getMapData.js");

/**
 * Sets the map `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf MapCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the map cache instance.
 */
function mapCacheSet(key, value) {
  var data = getMapData(this, key),
      size = data.size;

  data.set(key, value);
  this.size += data.size == size ? 0 : 1;
  return this;
}

module.exports = mapCacheSet;


/***/ }),

/***/ "./node_modules/lodash/_mapToArray.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_mapToArray.js ***!
  \********************************************/
/***/ ((module) => {

/**
 * Converts `map` to its key-value pairs.
 *
 * @private
 * @param {Object} map The map to convert.
 * @returns {Array} Returns the key-value pairs.
 */
function mapToArray(map) {
  var index = -1,
      result = Array(map.size);

  map.forEach(function(value, key) {
    result[++index] = [key, value];
  });
  return result;
}

module.exports = mapToArray;


/***/ }),

/***/ "./node_modules/lodash/_matchesStrictComparable.js":
/*!*********************************************************!*\
  !*** ./node_modules/lodash/_matchesStrictComparable.js ***!
  \*********************************************************/
/***/ ((module) => {

/**
 * A specialized version of `matchesProperty` for source values suitable
 * for strict equality comparisons, i.e. `===`.
 *
 * @private
 * @param {string} key The key of the property to get.
 * @param {*} srcValue The value to match.
 * @returns {Function} Returns the new spec function.
 */
function matchesStrictComparable(key, srcValue) {
  return function(object) {
    if (object == null) {
      return false;
    }
    return object[key] === srcValue &&
      (srcValue !== undefined || (key in Object(object)));
  };
}

module.exports = matchesStrictComparable;


/***/ }),

/***/ "./node_modules/lodash/_memoizeCapped.js":
/*!***********************************************!*\
  !*** ./node_modules/lodash/_memoizeCapped.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var memoize = __webpack_require__(/*! ./memoize */ "./node_modules/lodash/memoize.js");

/** Used as the maximum memoize cache size. */
var MAX_MEMOIZE_SIZE = 500;

/**
 * A specialized version of `_.memoize` which clears the memoized function's
 * cache when it exceeds `MAX_MEMOIZE_SIZE`.
 *
 * @private
 * @param {Function} func The function to have its output memoized.
 * @returns {Function} Returns the new memoized function.
 */
function memoizeCapped(func) {
  var result = memoize(func, function(key) {
    if (cache.size === MAX_MEMOIZE_SIZE) {
      cache.clear();
    }
    return key;
  });

  var cache = result.cache;
  return result;
}

module.exports = memoizeCapped;


/***/ }),

/***/ "./node_modules/lodash/_nativeCreate.js":
/*!**********************************************!*\
  !*** ./node_modules/lodash/_nativeCreate.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var getNative = __webpack_require__(/*! ./_getNative */ "./node_modules/lodash/_getNative.js");

/* Built-in method references that are verified to be native. */
var nativeCreate = getNative(Object, 'create');

module.exports = nativeCreate;


/***/ }),

/***/ "./node_modules/lodash/_nativeKeys.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_nativeKeys.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var overArg = __webpack_require__(/*! ./_overArg */ "./node_modules/lodash/_overArg.js");

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeKeys = overArg(Object.keys, Object);

module.exports = nativeKeys;


/***/ }),

/***/ "./node_modules/lodash/_nativeKeysIn.js":
/*!**********************************************!*\
  !*** ./node_modules/lodash/_nativeKeysIn.js ***!
  \**********************************************/
/***/ ((module) => {

/**
 * This function is like
 * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * except that it includes inherited enumerable properties.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function nativeKeysIn(object) {
  var result = [];
  if (object != null) {
    for (var key in Object(object)) {
      result.push(key);
    }
  }
  return result;
}

module.exports = nativeKeysIn;


/***/ }),

/***/ "./node_modules/lodash/_nodeUtil.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/_nodeUtil.js ***!
  \******************************************/
/***/ ((module, exports, __webpack_require__) => {

/* module decorator */ module = __webpack_require__.nmd(module);
var freeGlobal = __webpack_require__(/*! ./_freeGlobal */ "./node_modules/lodash/_freeGlobal.js");

/** Detect free variable `exports`. */
var freeExports =  true && exports && !exports.nodeType && exports;

/** Detect free variable `module`. */
var freeModule = freeExports && "object" == 'object' && module && !module.nodeType && module;

/** Detect the popular CommonJS extension `module.exports`. */
var moduleExports = freeModule && freeModule.exports === freeExports;

/** Detect free variable `process` from Node.js. */
var freeProcess = moduleExports && freeGlobal.process;

/** Used to access faster Node.js helpers. */
var nodeUtil = (function() {
  try {
    // Use `util.types` for Node.js 10+.
    var types = freeModule && freeModule.require && freeModule.require('util').types;

    if (types) {
      return types;
    }

    // Legacy `process.binding('util')` for Node.js < 10.
    return freeProcess && freeProcess.binding && freeProcess.binding('util');
  } catch (e) {}
}());

module.exports = nodeUtil;


/***/ }),

/***/ "./node_modules/lodash/_objectToString.js":
/*!************************************************!*\
  !*** ./node_modules/lodash/_objectToString.js ***!
  \************************************************/
/***/ ((module) => {

/** Used for built-in method references. */
var objectProto = Object.prototype;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var nativeObjectToString = objectProto.toString;

/**
 * Converts `value` to a string using `Object.prototype.toString`.
 *
 * @private
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 */
function objectToString(value) {
  return nativeObjectToString.call(value);
}

module.exports = objectToString;


/***/ }),

/***/ "./node_modules/lodash/_overArg.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/_overArg.js ***!
  \*****************************************/
/***/ ((module) => {

/**
 * Creates a unary function that invokes `func` with its argument transformed.
 *
 * @private
 * @param {Function} func The function to wrap.
 * @param {Function} transform The argument transform.
 * @returns {Function} Returns the new function.
 */
function overArg(func, transform) {
  return function(arg) {
    return func(transform(arg));
  };
}

module.exports = overArg;


/***/ }),

/***/ "./node_modules/lodash/_overRest.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/_overRest.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var apply = __webpack_require__(/*! ./_apply */ "./node_modules/lodash/_apply.js");

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMax = Math.max;

/**
 * A specialized version of `baseRest` which transforms the rest array.
 *
 * @private
 * @param {Function} func The function to apply a rest parameter to.
 * @param {number} [start=func.length-1] The start position of the rest parameter.
 * @param {Function} transform The rest array transform.
 * @returns {Function} Returns the new function.
 */
function overRest(func, start, transform) {
  start = nativeMax(start === undefined ? (func.length - 1) : start, 0);
  return function() {
    var args = arguments,
        index = -1,
        length = nativeMax(args.length - start, 0),
        array = Array(length);

    while (++index < length) {
      array[index] = args[start + index];
    }
    index = -1;
    var otherArgs = Array(start + 1);
    while (++index < start) {
      otherArgs[index] = args[index];
    }
    otherArgs[start] = transform(array);
    return apply(func, this, otherArgs);
  };
}

module.exports = overRest;


/***/ }),

/***/ "./node_modules/lodash/_root.js":
/*!**************************************!*\
  !*** ./node_modules/lodash/_root.js ***!
  \**************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var freeGlobal = __webpack_require__(/*! ./_freeGlobal */ "./node_modules/lodash/_freeGlobal.js");

/** Detect free variable `self`. */
var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

/** Used as a reference to the global object. */
var root = freeGlobal || freeSelf || Function('return this')();

module.exports = root;


/***/ }),

/***/ "./node_modules/lodash/_safeGet.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/_safeGet.js ***!
  \*****************************************/
/***/ ((module) => {

/**
 * Gets the value at `key`, unless `key` is "__proto__" or "constructor".
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */
function safeGet(object, key) {
  if (key === 'constructor' && typeof object[key] === 'function') {
    return;
  }

  if (key == '__proto__') {
    return;
  }

  return object[key];
}

module.exports = safeGet;


/***/ }),

/***/ "./node_modules/lodash/_setCacheAdd.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash/_setCacheAdd.js ***!
  \*********************************************/
/***/ ((module) => {

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED = '__lodash_hash_undefined__';

/**
 * Adds `value` to the array cache.
 *
 * @private
 * @name add
 * @memberOf SetCache
 * @alias push
 * @param {*} value The value to cache.
 * @returns {Object} Returns the cache instance.
 */
function setCacheAdd(value) {
  this.__data__.set(value, HASH_UNDEFINED);
  return this;
}

module.exports = setCacheAdd;


/***/ }),

/***/ "./node_modules/lodash/_setCacheHas.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash/_setCacheHas.js ***!
  \*********************************************/
/***/ ((module) => {

/**
 * Checks if `value` is in the array cache.
 *
 * @private
 * @name has
 * @memberOf SetCache
 * @param {*} value The value to search for.
 * @returns {number} Returns `true` if `value` is found, else `false`.
 */
function setCacheHas(value) {
  return this.__data__.has(value);
}

module.exports = setCacheHas;


/***/ }),

/***/ "./node_modules/lodash/_setToArray.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_setToArray.js ***!
  \********************************************/
/***/ ((module) => {

/**
 * Converts `set` to an array of its values.
 *
 * @private
 * @param {Object} set The set to convert.
 * @returns {Array} Returns the values.
 */
function setToArray(set) {
  var index = -1,
      result = Array(set.size);

  set.forEach(function(value) {
    result[++index] = value;
  });
  return result;
}

module.exports = setToArray;


/***/ }),

/***/ "./node_modules/lodash/_setToString.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash/_setToString.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseSetToString = __webpack_require__(/*! ./_baseSetToString */ "./node_modules/lodash/_baseSetToString.js"),
    shortOut = __webpack_require__(/*! ./_shortOut */ "./node_modules/lodash/_shortOut.js");

/**
 * Sets the `toString` method of `func` to return `string`.
 *
 * @private
 * @param {Function} func The function to modify.
 * @param {Function} string The `toString` result.
 * @returns {Function} Returns `func`.
 */
var setToString = shortOut(baseSetToString);

module.exports = setToString;


/***/ }),

/***/ "./node_modules/lodash/_shortOut.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/_shortOut.js ***!
  \******************************************/
/***/ ((module) => {

/** Used to detect hot functions by number of calls within a span of milliseconds. */
var HOT_COUNT = 800,
    HOT_SPAN = 16;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeNow = Date.now;

/**
 * Creates a function that'll short out and invoke `identity` instead
 * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`
 * milliseconds.
 *
 * @private
 * @param {Function} func The function to restrict.
 * @returns {Function} Returns the new shortable function.
 */
function shortOut(func) {
  var count = 0,
      lastCalled = 0;

  return function() {
    var stamp = nativeNow(),
        remaining = HOT_SPAN - (stamp - lastCalled);

    lastCalled = stamp;
    if (remaining > 0) {
      if (++count >= HOT_COUNT) {
        return arguments[0];
      }
    } else {
      count = 0;
    }
    return func.apply(undefined, arguments);
  };
}

module.exports = shortOut;


/***/ }),

/***/ "./node_modules/lodash/_stackClear.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_stackClear.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var ListCache = __webpack_require__(/*! ./_ListCache */ "./node_modules/lodash/_ListCache.js");

/**
 * Removes all key-value entries from the stack.
 *
 * @private
 * @name clear
 * @memberOf Stack
 */
function stackClear() {
  this.__data__ = new ListCache;
  this.size = 0;
}

module.exports = stackClear;


/***/ }),

/***/ "./node_modules/lodash/_stackDelete.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash/_stackDelete.js ***!
  \*********************************************/
/***/ ((module) => {

/**
 * Removes `key` and its value from the stack.
 *
 * @private
 * @name delete
 * @memberOf Stack
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function stackDelete(key) {
  var data = this.__data__,
      result = data['delete'](key);

  this.size = data.size;
  return result;
}

module.exports = stackDelete;


/***/ }),

/***/ "./node_modules/lodash/_stackGet.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/_stackGet.js ***!
  \******************************************/
/***/ ((module) => {

/**
 * Gets the stack value for `key`.
 *
 * @private
 * @name get
 * @memberOf Stack
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function stackGet(key) {
  return this.__data__.get(key);
}

module.exports = stackGet;


/***/ }),

/***/ "./node_modules/lodash/_stackHas.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/_stackHas.js ***!
  \******************************************/
/***/ ((module) => {

/**
 * Checks if a stack value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Stack
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function stackHas(key) {
  return this.__data__.has(key);
}

module.exports = stackHas;


/***/ }),

/***/ "./node_modules/lodash/_stackSet.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/_stackSet.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var ListCache = __webpack_require__(/*! ./_ListCache */ "./node_modules/lodash/_ListCache.js"),
    Map = __webpack_require__(/*! ./_Map */ "./node_modules/lodash/_Map.js"),
    MapCache = __webpack_require__(/*! ./_MapCache */ "./node_modules/lodash/_MapCache.js");

/** Used as the size to enable large array optimizations. */
var LARGE_ARRAY_SIZE = 200;

/**
 * Sets the stack `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Stack
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the stack cache instance.
 */
function stackSet(key, value) {
  var data = this.__data__;
  if (data instanceof ListCache) {
    var pairs = data.__data__;
    if (!Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {
      pairs.push([key, value]);
      this.size = ++data.size;
      return this;
    }
    data = this.__data__ = new MapCache(pairs);
  }
  data.set(key, value);
  this.size = data.size;
  return this;
}

module.exports = stackSet;


/***/ }),

/***/ "./node_modules/lodash/_strictIndexOf.js":
/*!***********************************************!*\
  !*** ./node_modules/lodash/_strictIndexOf.js ***!
  \***********************************************/
/***/ ((module) => {

/**
 * A specialized version of `_.indexOf` which performs strict equality
 * comparisons of values, i.e. `===`.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} value The value to search for.
 * @param {number} fromIndex The index to search from.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function strictIndexOf(array, value, fromIndex) {
  var index = fromIndex - 1,
      length = array.length;

  while (++index < length) {
    if (array[index] === value) {
      return index;
    }
  }
  return -1;
}

module.exports = strictIndexOf;


/***/ }),

/***/ "./node_modules/lodash/_stringSize.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_stringSize.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var asciiSize = __webpack_require__(/*! ./_asciiSize */ "./node_modules/lodash/_asciiSize.js"),
    hasUnicode = __webpack_require__(/*! ./_hasUnicode */ "./node_modules/lodash/_hasUnicode.js"),
    unicodeSize = __webpack_require__(/*! ./_unicodeSize */ "./node_modules/lodash/_unicodeSize.js");

/**
 * Gets the number of symbols in `string`.
 *
 * @private
 * @param {string} string The string to inspect.
 * @returns {number} Returns the string size.
 */
function stringSize(string) {
  return hasUnicode(string)
    ? unicodeSize(string)
    : asciiSize(string);
}

module.exports = stringSize;


/***/ }),

/***/ "./node_modules/lodash/_stringToPath.js":
/*!**********************************************!*\
  !*** ./node_modules/lodash/_stringToPath.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var memoizeCapped = __webpack_require__(/*! ./_memoizeCapped */ "./node_modules/lodash/_memoizeCapped.js");

/** Used to match property names within property paths. */
var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;

/** Used to match backslashes in property paths. */
var reEscapeChar = /\\(\\)?/g;

/**
 * Converts `string` to a property path array.
 *
 * @private
 * @param {string} string The string to convert.
 * @returns {Array} Returns the property path array.
 */
var stringToPath = memoizeCapped(function(string) {
  var result = [];
  if (string.charCodeAt(0) === 46 /* . */) {
    result.push('');
  }
  string.replace(rePropName, function(match, number, quote, subString) {
    result.push(quote ? subString.replace(reEscapeChar, '$1') : (number || match));
  });
  return result;
});

module.exports = stringToPath;


/***/ }),

/***/ "./node_modules/lodash/_toKey.js":
/*!***************************************!*\
  !*** ./node_modules/lodash/_toKey.js ***!
  \***************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var isSymbol = __webpack_require__(/*! ./isSymbol */ "./node_modules/lodash/isSymbol.js");

/** Used as references for various `Number` constants. */
var INFINITY = 1 / 0;

/**
 * Converts `value` to a string key if it's not a string or symbol.
 *
 * @private
 * @param {*} value The value to inspect.
 * @returns {string|symbol} Returns the key.
 */
function toKey(value) {
  if (typeof value == 'string' || isSymbol(value)) {
    return value;
  }
  var result = (value + '');
  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
}

module.exports = toKey;


/***/ }),

/***/ "./node_modules/lodash/_toSource.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/_toSource.js ***!
  \******************************************/
/***/ ((module) => {

/** Used for built-in method references. */
var funcProto = Function.prototype;

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/**
 * Converts `func` to its source code.
 *
 * @private
 * @param {Function} func The function to convert.
 * @returns {string} Returns the source code.
 */
function toSource(func) {
  if (func != null) {
    try {
      return funcToString.call(func);
    } catch (e) {}
    try {
      return (func + '');
    } catch (e) {}
  }
  return '';
}

module.exports = toSource;


/***/ }),

/***/ "./node_modules/lodash/_trimmedEndIndex.js":
/*!*************************************************!*\
  !*** ./node_modules/lodash/_trimmedEndIndex.js ***!
  \*************************************************/
/***/ ((module) => {

/** Used to match a single whitespace character. */
var reWhitespace = /\s/;

/**
 * Used by `_.trim` and `_.trimEnd` to get the index of the last non-whitespace
 * character of `string`.
 *
 * @private
 * @param {string} string The string to inspect.
 * @returns {number} Returns the index of the last non-whitespace character.
 */
function trimmedEndIndex(string) {
  var index = string.length;

  while (index-- && reWhitespace.test(string.charAt(index))) {}
  return index;
}

module.exports = trimmedEndIndex;


/***/ }),

/***/ "./node_modules/lodash/_unicodeSize.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash/_unicodeSize.js ***!
  \*********************************************/
/***/ ((module) => {

/** Used to compose unicode character classes. */
var rsAstralRange = '\\ud800-\\udfff',
    rsComboMarksRange = '\\u0300-\\u036f',
    reComboHalfMarksRange = '\\ufe20-\\ufe2f',
    rsComboSymbolsRange = '\\u20d0-\\u20ff',
    rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange,
    rsVarRange = '\\ufe0e\\ufe0f';

/** Used to compose unicode capture groups. */
var rsAstral = '[' + rsAstralRange + ']',
    rsCombo = '[' + rsComboRange + ']',
    rsFitz = '\\ud83c[\\udffb-\\udfff]',
    rsModifier = '(?:' + rsCombo + '|' + rsFitz + ')',
    rsNonAstral = '[^' + rsAstralRange + ']',
    rsRegional = '(?:\\ud83c[\\udde6-\\uddff]){2}',
    rsSurrPair = '[\\ud800-\\udbff][\\udc00-\\udfff]',
    rsZWJ = '\\u200d';

/** Used to compose unicode regexes. */
var reOptMod = rsModifier + '?',
    rsOptVar = '[' + rsVarRange + ']?',
    rsOptJoin = '(?:' + rsZWJ + '(?:' + [rsNonAstral, rsRegional, rsSurrPair].join('|') + ')' + rsOptVar + reOptMod + ')*',
    rsSeq = rsOptVar + reOptMod + rsOptJoin,
    rsSymbol = '(?:' + [rsNonAstral + rsCombo + '?', rsCombo, rsRegional, rsSurrPair, rsAstral].join('|') + ')';

/** Used to match [string symbols](https://mathiasbynens.be/notes/javascript-unicode). */
var reUnicode = RegExp(rsFitz + '(?=' + rsFitz + ')|' + rsSymbol + rsSeq, 'g');

/**
 * Gets the size of a Unicode `string`.
 *
 * @private
 * @param {string} string The string inspect.
 * @returns {number} Returns the string size.
 */
function unicodeSize(string) {
  var result = reUnicode.lastIndex = 0;
  while (reUnicode.test(string)) {
    ++result;
  }
  return result;
}

module.exports = unicodeSize;


/***/ }),

/***/ "./node_modules/lodash/clone.js":
/*!**************************************!*\
  !*** ./node_modules/lodash/clone.js ***!
  \**************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseClone = __webpack_require__(/*! ./_baseClone */ "./node_modules/lodash/_baseClone.js");

/** Used to compose bitmasks for cloning. */
var CLONE_SYMBOLS_FLAG = 4;

/**
 * Creates a shallow clone of `value`.
 *
 * **Note:** This method is loosely based on the
 * [structured clone algorithm](https://mdn.io/Structured_clone_algorithm)
 * and supports cloning arrays, array buffers, booleans, date objects, maps,
 * numbers, `Object` objects, regexes, sets, strings, symbols, and typed
 * arrays. The own enumerable properties of `arguments` objects are cloned
 * as plain objects. An empty object is returned for uncloneable values such
 * as error objects, functions, DOM nodes, and WeakMaps.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to clone.
 * @returns {*} Returns the cloned value.
 * @see _.cloneDeep
 * @example
 *
 * var objects = [{ 'a': 1 }, { 'b': 2 }];
 *
 * var shallow = _.clone(objects);
 * console.log(shallow[0] === objects[0]);
 * // => true
 */
function clone(value) {
  return baseClone(value, CLONE_SYMBOLS_FLAG);
}

module.exports = clone;


/***/ }),

/***/ "./node_modules/lodash/cloneDeep.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/cloneDeep.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseClone = __webpack_require__(/*! ./_baseClone */ "./node_modules/lodash/_baseClone.js");

/** Used to compose bitmasks for cloning. */
var CLONE_DEEP_FLAG = 1,
    CLONE_SYMBOLS_FLAG = 4;

/**
 * This method is like `_.clone` except that it recursively clones `value`.
 *
 * @static
 * @memberOf _
 * @since 1.0.0
 * @category Lang
 * @param {*} value The value to recursively clone.
 * @returns {*} Returns the deep cloned value.
 * @see _.clone
 * @example
 *
 * var objects = [{ 'a': 1 }, { 'b': 2 }];
 *
 * var deep = _.cloneDeep(objects);
 * console.log(deep[0] === objects[0]);
 * // => false
 */
function cloneDeep(value) {
  return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
}

module.exports = cloneDeep;


/***/ }),

/***/ "./node_modules/lodash/constant.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/constant.js ***!
  \*****************************************/
/***/ ((module) => {

/**
 * Creates a function that returns `value`.
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Util
 * @param {*} value The value to return from the new function.
 * @returns {Function} Returns the new constant function.
 * @example
 *
 * var objects = _.times(2, _.constant({ 'a': 1 }));
 *
 * console.log(objects);
 * // => [{ 'a': 1 }, { 'a': 1 }]
 *
 * console.log(objects[0] === objects[1]);
 * // => true
 */
function constant(value) {
  return function() {
    return value;
  };
}

module.exports = constant;


/***/ }),

/***/ "./node_modules/lodash/defaults.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/defaults.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseRest = __webpack_require__(/*! ./_baseRest */ "./node_modules/lodash/_baseRest.js"),
    eq = __webpack_require__(/*! ./eq */ "./node_modules/lodash/eq.js"),
    isIterateeCall = __webpack_require__(/*! ./_isIterateeCall */ "./node_modules/lodash/_isIterateeCall.js"),
    keysIn = __webpack_require__(/*! ./keysIn */ "./node_modules/lodash/keysIn.js");

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Assigns own and inherited enumerable string keyed properties of source
 * objects to the destination object for all destination properties that
 * resolve to `undefined`. Source objects are applied from left to right.
 * Once a property is set, additional values of the same property are ignored.
 *
 * **Note:** This method mutates `object`.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The destination object.
 * @param {...Object} [sources] The source objects.
 * @returns {Object} Returns `object`.
 * @see _.defaultsDeep
 * @example
 *
 * _.defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
 * // => { 'a': 1, 'b': 2 }
 */
var defaults = baseRest(function(object, sources) {
  object = Object(object);

  var index = -1;
  var length = sources.length;
  var guard = length > 2 ? sources[2] : undefined;

  if (guard && isIterateeCall(sources[0], sources[1], guard)) {
    length = 1;
  }

  while (++index < length) {
    var source = sources[index];
    var props = keysIn(source);
    var propsIndex = -1;
    var propsLength = props.length;

    while (++propsIndex < propsLength) {
      var key = props[propsIndex];
      var value = object[key];

      if (value === undefined ||
          (eq(value, objectProto[key]) && !hasOwnProperty.call(object, key))) {
        object[key] = source[key];
      }
    }
  }

  return object;
});

module.exports = defaults;


/***/ }),

/***/ "./node_modules/lodash/each.js":
/*!*************************************!*\
  !*** ./node_modules/lodash/each.js ***!
  \*************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = __webpack_require__(/*! ./forEach */ "./node_modules/lodash/forEach.js");


/***/ }),

/***/ "./node_modules/lodash/eq.js":
/*!***********************************!*\
  !*** ./node_modules/lodash/eq.js ***!
  \***********************************/
/***/ ((module) => {

/**
 * Performs a
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * comparison between two values to determine if they are equivalent.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.eq(object, object);
 * // => true
 *
 * _.eq(object, other);
 * // => false
 *
 * _.eq('a', 'a');
 * // => true
 *
 * _.eq('a', Object('a'));
 * // => false
 *
 * _.eq(NaN, NaN);
 * // => true
 */
function eq(value, other) {
  return value === other || (value !== value && other !== other);
}

module.exports = eq;


/***/ }),

/***/ "./node_modules/lodash/filter.js":
/*!***************************************!*\
  !*** ./node_modules/lodash/filter.js ***!
  \***************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var arrayFilter = __webpack_require__(/*! ./_arrayFilter */ "./node_modules/lodash/_arrayFilter.js"),
    baseFilter = __webpack_require__(/*! ./_baseFilter */ "./node_modules/lodash/_baseFilter.js"),
    baseIteratee = __webpack_require__(/*! ./_baseIteratee */ "./node_modules/lodash/_baseIteratee.js"),
    isArray = __webpack_require__(/*! ./isArray */ "./node_modules/lodash/isArray.js");

/**
 * Iterates over elements of `collection`, returning an array of all elements
 * `predicate` returns truthy for. The predicate is invoked with three
 * arguments: (value, index|key, collection).
 *
 * **Note:** Unlike `_.remove`, this method returns a new array.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Collection
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} [predicate=_.identity] The function invoked per iteration.
 * @returns {Array} Returns the new filtered array.
 * @see _.reject
 * @example
 *
 * var users = [
 *   { 'user': 'barney', 'age': 36, 'active': true },
 *   { 'user': 'fred',   'age': 40, 'active': false }
 * ];
 *
 * _.filter(users, function(o) { return !o.active; });
 * // => objects for ['fred']
 *
 * // The `_.matches` iteratee shorthand.
 * _.filter(users, { 'age': 36, 'active': true });
 * // => objects for ['barney']
 *
 * // The `_.matchesProperty` iteratee shorthand.
 * _.filter(users, ['active', false]);
 * // => objects for ['fred']
 *
 * // The `_.property` iteratee shorthand.
 * _.filter(users, 'active');
 * // => objects for ['barney']
 *
 * // Combining several predicates using `_.overEvery` or `_.overSome`.
 * _.filter(users, _.overSome([{ 'age': 36 }, ['age', 40]]));
 * // => objects for ['fred', 'barney']
 */
function filter(collection, predicate) {
  var func = isArray(collection) ? arrayFilter : baseFilter;
  return func(collection, baseIteratee(predicate, 3));
}

module.exports = filter;


/***/ }),

/***/ "./node_modules/lodash/find.js":
/*!*************************************!*\
  !*** ./node_modules/lodash/find.js ***!
  \*************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var createFind = __webpack_require__(/*! ./_createFind */ "./node_modules/lodash/_createFind.js"),
    findIndex = __webpack_require__(/*! ./findIndex */ "./node_modules/lodash/findIndex.js");

/**
 * Iterates over elements of `collection`, returning the first element
 * `predicate` returns truthy for. The predicate is invoked with three
 * arguments: (value, index|key, collection).
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Collection
 * @param {Array|Object} collection The collection to inspect.
 * @param {Function} [predicate=_.identity] The function invoked per iteration.
 * @param {number} [fromIndex=0] The index to search from.
 * @returns {*} Returns the matched element, else `undefined`.
 * @example
 *
 * var users = [
 *   { 'user': 'barney',  'age': 36, 'active': true },
 *   { 'user': 'fred',    'age': 40, 'active': false },
 *   { 'user': 'pebbles', 'age': 1,  'active': true }
 * ];
 *
 * _.find(users, function(o) { return o.age < 40; });
 * // => object for 'barney'
 *
 * // The `_.matches` iteratee shorthand.
 * _.find(users, { 'age': 1, 'active': true });
 * // => object for 'pebbles'
 *
 * // The `_.matchesProperty` iteratee shorthand.
 * _.find(users, ['active', false]);
 * // => object for 'fred'
 *
 * // The `_.property` iteratee shorthand.
 * _.find(users, 'active');
 * // => object for 'barney'
 */
var find = createFind(findIndex);

module.exports = find;


/***/ }),

/***/ "./node_modules/lodash/findIndex.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/findIndex.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseFindIndex = __webpack_require__(/*! ./_baseFindIndex */ "./node_modules/lodash/_baseFindIndex.js"),
    baseIteratee = __webpack_require__(/*! ./_baseIteratee */ "./node_modules/lodash/_baseIteratee.js"),
    toInteger = __webpack_require__(/*! ./toInteger */ "./node_modules/lodash/toInteger.js");

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMax = Math.max;

/**
 * This method is like `_.find` except that it returns the index of the first
 * element `predicate` returns truthy for instead of the element itself.
 *
 * @static
 * @memberOf _
 * @since 1.1.0
 * @category Array
 * @param {Array} array The array to inspect.
 * @param {Function} [predicate=_.identity] The function invoked per iteration.
 * @param {number} [fromIndex=0] The index to search from.
 * @returns {number} Returns the index of the found element, else `-1`.
 * @example
 *
 * var users = [
 *   { 'user': 'barney',  'active': false },
 *   { 'user': 'fred',    'active': false },
 *   { 'user': 'pebbles', 'active': true }
 * ];
 *
 * _.findIndex(users, function(o) { return o.user == 'barney'; });
 * // => 0
 *
 * // The `_.matches` iteratee shorthand.
 * _.findIndex(users, { 'user': 'fred', 'active': false });
 * // => 1
 *
 * // The `_.matchesProperty` iteratee shorthand.
 * _.findIndex(users, ['active', false]);
 * // => 0
 *
 * // The `_.property` iteratee shorthand.
 * _.findIndex(users, 'active');
 * // => 2
 */
function findIndex(array, predicate, fromIndex) {
  var length = array == null ? 0 : array.length;
  if (!length) {
    return -1;
  }
  var index = fromIndex == null ? 0 : toInteger(fromIndex);
  if (index < 0) {
    index = nativeMax(length + index, 0);
  }
  return baseFindIndex(array, baseIteratee(predicate, 3), index);
}

module.exports = findIndex;


/***/ }),

/***/ "./node_modules/lodash/flatten.js":
/*!****************************************!*\
  !*** ./node_modules/lodash/flatten.js ***!
  \****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseFlatten = __webpack_require__(/*! ./_baseFlatten */ "./node_modules/lodash/_baseFlatten.js");

/**
 * Flattens `array` a single level deep.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Array
 * @param {Array} array The array to flatten.
 * @returns {Array} Returns the new flattened array.
 * @example
 *
 * _.flatten([1, [2, [3, [4]], 5]]);
 * // => [1, 2, [3, [4]], 5]
 */
function flatten(array) {
  var length = array == null ? 0 : array.length;
  return length ? baseFlatten(array, 1) : [];
}

module.exports = flatten;


/***/ }),

/***/ "./node_modules/lodash/forEach.js":
/*!****************************************!*\
  !*** ./node_modules/lodash/forEach.js ***!
  \****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var arrayEach = __webpack_require__(/*! ./_arrayEach */ "./node_modules/lodash/_arrayEach.js"),
    baseEach = __webpack_require__(/*! ./_baseEach */ "./node_modules/lodash/_baseEach.js"),
    castFunction = __webpack_require__(/*! ./_castFunction */ "./node_modules/lodash/_castFunction.js"),
    isArray = __webpack_require__(/*! ./isArray */ "./node_modules/lodash/isArray.js");

/**
 * Iterates over elements of `collection` and invokes `iteratee` for each element.
 * The iteratee is invoked with three arguments: (value, index|key, collection).
 * Iteratee functions may exit iteration early by explicitly returning `false`.
 *
 * **Note:** As with other "Collections" methods, objects with a "length"
 * property are iterated like arrays. To avoid this behavior use `_.forIn`
 * or `_.forOwn` for object iteration.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @alias each
 * @category Collection
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} [iteratee=_.identity] The function invoked per iteration.
 * @returns {Array|Object} Returns `collection`.
 * @see _.forEachRight
 * @example
 *
 * _.forEach([1, 2], function(value) {
 *   console.log(value);
 * });
 * // => Logs `1` then `2`.
 *
 * _.forEach({ 'a': 1, 'b': 2 }, function(value, key) {
 *   console.log(key);
 * });
 * // => Logs 'a' then 'b' (iteration order is not guaranteed).
 */
function forEach(collection, iteratee) {
  var func = isArray(collection) ? arrayEach : baseEach;
  return func(collection, castFunction(iteratee));
}

module.exports = forEach;


/***/ }),

/***/ "./node_modules/lodash/forIn.js":
/*!**************************************!*\
  !*** ./node_modules/lodash/forIn.js ***!
  \**************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseFor = __webpack_require__(/*! ./_baseFor */ "./node_modules/lodash/_baseFor.js"),
    castFunction = __webpack_require__(/*! ./_castFunction */ "./node_modules/lodash/_castFunction.js"),
    keysIn = __webpack_require__(/*! ./keysIn */ "./node_modules/lodash/keysIn.js");

/**
 * Iterates over own and inherited enumerable string keyed properties of an
 * object and invokes `iteratee` for each property. The iteratee is invoked
 * with three arguments: (value, key, object). Iteratee functions may exit
 * iteration early by explicitly returning `false`.
 *
 * @static
 * @memberOf _
 * @since 0.3.0
 * @category Object
 * @param {Object} object The object to iterate over.
 * @param {Function} [iteratee=_.identity] The function invoked per iteration.
 * @returns {Object} Returns `object`.
 * @see _.forInRight
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.forIn(new Foo, function(value, key) {
 *   console.log(key);
 * });
 * // => Logs 'a', 'b', then 'c' (iteration order is not guaranteed).
 */
function forIn(object, iteratee) {
  return object == null
    ? object
    : baseFor(object, castFunction(iteratee), keysIn);
}

module.exports = forIn;


/***/ }),

/***/ "./node_modules/lodash/get.js":
/*!************************************!*\
  !*** ./node_modules/lodash/get.js ***!
  \************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseGet = __webpack_require__(/*! ./_baseGet */ "./node_modules/lodash/_baseGet.js");

/**
 * Gets the value at `path` of `object`. If the resolved value is
 * `undefined`, the `defaultValue` is returned in its place.
 *
 * @static
 * @memberOf _
 * @since 3.7.0
 * @category Object
 * @param {Object} object The object to query.
 * @param {Array|string} path The path of the property to get.
 * @param {*} [defaultValue] The value returned for `undefined` resolved values.
 * @returns {*} Returns the resolved value.
 * @example
 *
 * var object = { 'a': [{ 'b': { 'c': 3 } }] };
 *
 * _.get(object, 'a[0].b.c');
 * // => 3
 *
 * _.get(object, ['a', '0', 'b', 'c']);
 * // => 3
 *
 * _.get(object, 'a.b.c', 'default');
 * // => 'default'
 */
function get(object, path, defaultValue) {
  var result = object == null ? undefined : baseGet(object, path);
  return result === undefined ? defaultValue : result;
}

module.exports = get;


/***/ }),

/***/ "./node_modules/lodash/has.js":
/*!************************************!*\
  !*** ./node_modules/lodash/has.js ***!
  \************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseHas = __webpack_require__(/*! ./_baseHas */ "./node_modules/lodash/_baseHas.js"),
    hasPath = __webpack_require__(/*! ./_hasPath */ "./node_modules/lodash/_hasPath.js");

/**
 * Checks if `path` is a direct property of `object`.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The object to query.
 * @param {Array|string} path The path to check.
 * @returns {boolean} Returns `true` if `path` exists, else `false`.
 * @example
 *
 * var object = { 'a': { 'b': 2 } };
 * var other = _.create({ 'a': _.create({ 'b': 2 }) });
 *
 * _.has(object, 'a');
 * // => true
 *
 * _.has(object, 'a.b');
 * // => true
 *
 * _.has(object, ['a', 'b']);
 * // => true
 *
 * _.has(other, 'a');
 * // => false
 */
function has(object, path) {
  return object != null && hasPath(object, path, baseHas);
}

module.exports = has;


/***/ }),

/***/ "./node_modules/lodash/hasIn.js":
/*!**************************************!*\
  !*** ./node_modules/lodash/hasIn.js ***!
  \**************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseHasIn = __webpack_require__(/*! ./_baseHasIn */ "./node_modules/lodash/_baseHasIn.js"),
    hasPath = __webpack_require__(/*! ./_hasPath */ "./node_modules/lodash/_hasPath.js");

/**
 * Checks if `path` is a direct or inherited property of `object`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Object
 * @param {Object} object The object to query.
 * @param {Array|string} path The path to check.
 * @returns {boolean} Returns `true` if `path` exists, else `false`.
 * @example
 *
 * var object = _.create({ 'a': _.create({ 'b': 2 }) });
 *
 * _.hasIn(object, 'a');
 * // => true
 *
 * _.hasIn(object, 'a.b');
 * // => true
 *
 * _.hasIn(object, ['a', 'b']);
 * // => true
 *
 * _.hasIn(object, 'b');
 * // => false
 */
function hasIn(object, path) {
  return object != null && hasPath(object, path, baseHasIn);
}

module.exports = hasIn;


/***/ }),

/***/ "./node_modules/lodash/identity.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/identity.js ***!
  \*****************************************/
/***/ ((module) => {

/**
 * This method returns the first argument it receives.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Util
 * @param {*} value Any value.
 * @returns {*} Returns `value`.
 * @example
 *
 * var object = { 'a': 1 };
 *
 * console.log(_.identity(object) === object);
 * // => true
 */
function identity(value) {
  return value;
}

module.exports = identity;


/***/ }),

/***/ "./node_modules/lodash/isArguments.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/isArguments.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseIsArguments = __webpack_require__(/*! ./_baseIsArguments */ "./node_modules/lodash/_baseIsArguments.js"),
    isObjectLike = __webpack_require__(/*! ./isObjectLike */ "./node_modules/lodash/isObjectLike.js");

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/** Built-in value references. */
var propertyIsEnumerable = objectProto.propertyIsEnumerable;

/**
 * Checks if `value` is likely an `arguments` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 *  else `false`.
 * @example
 *
 * _.isArguments(function() { return arguments; }());
 * // => true
 *
 * _.isArguments([1, 2, 3]);
 * // => false
 */
var isArguments = baseIsArguments(function() { return arguments; }()) ? baseIsArguments : function(value) {
  return isObjectLike(value) && hasOwnProperty.call(value, 'callee') &&
    !propertyIsEnumerable.call(value, 'callee');
};

module.exports = isArguments;


/***/ }),

/***/ "./node_modules/lodash/isArray.js":
/*!****************************************!*\
  !*** ./node_modules/lodash/isArray.js ***!
  \****************************************/
/***/ ((module) => {

/**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(document.body.children);
 * // => false
 *
 * _.isArray('abc');
 * // => false
 *
 * _.isArray(_.noop);
 * // => false
 */
var isArray = Array.isArray;

module.exports = isArray;


/***/ }),

/***/ "./node_modules/lodash/isArrayLike.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/isArrayLike.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var isFunction = __webpack_require__(/*! ./isFunction */ "./node_modules/lodash/isFunction.js"),
    isLength = __webpack_require__(/*! ./isLength */ "./node_modules/lodash/isLength.js");

/**
 * Checks if `value` is array-like. A value is considered array-like if it's
 * not a function and has a `value.length` that's an integer greater than or
 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
 * @example
 *
 * _.isArrayLike([1, 2, 3]);
 * // => true
 *
 * _.isArrayLike(document.body.children);
 * // => true
 *
 * _.isArrayLike('abc');
 * // => true
 *
 * _.isArrayLike(_.noop);
 * // => false
 */
function isArrayLike(value) {
  return value != null && isLength(value.length) && !isFunction(value);
}

module.exports = isArrayLike;


/***/ }),

/***/ "./node_modules/lodash/isArrayLikeObject.js":
/*!**************************************************!*\
  !*** ./node_modules/lodash/isArrayLikeObject.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var isArrayLike = __webpack_require__(/*! ./isArrayLike */ "./node_modules/lodash/isArrayLike.js"),
    isObjectLike = __webpack_require__(/*! ./isObjectLike */ "./node_modules/lodash/isObjectLike.js");

/**
 * This method is like `_.isArrayLike` except that it also checks if `value`
 * is an object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array-like object,
 *  else `false`.
 * @example
 *
 * _.isArrayLikeObject([1, 2, 3]);
 * // => true
 *
 * _.isArrayLikeObject(document.body.children);
 * // => true
 *
 * _.isArrayLikeObject('abc');
 * // => false
 *
 * _.isArrayLikeObject(_.noop);
 * // => false
 */
function isArrayLikeObject(value) {
  return isObjectLike(value) && isArrayLike(value);
}

module.exports = isArrayLikeObject;


/***/ }),

/***/ "./node_modules/lodash/isBuffer.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/isBuffer.js ***!
  \*****************************************/
/***/ ((module, exports, __webpack_require__) => {

/* module decorator */ module = __webpack_require__.nmd(module);
var root = __webpack_require__(/*! ./_root */ "./node_modules/lodash/_root.js"),
    stubFalse = __webpack_require__(/*! ./stubFalse */ "./node_modules/lodash/stubFalse.js");

/** Detect free variable `exports`. */
var freeExports =  true && exports && !exports.nodeType && exports;

/** Detect free variable `module`. */
var freeModule = freeExports && "object" == 'object' && module && !module.nodeType && module;

/** Detect the popular CommonJS extension `module.exports`. */
var moduleExports = freeModule && freeModule.exports === freeExports;

/** Built-in value references. */
var Buffer = moduleExports ? root.Buffer : undefined;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined;

/**
 * Checks if `value` is a buffer.
 *
 * @static
 * @memberOf _
 * @since 4.3.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
 * @example
 *
 * _.isBuffer(new Buffer(2));
 * // => true
 *
 * _.isBuffer(new Uint8Array(2));
 * // => false
 */
var isBuffer = nativeIsBuffer || stubFalse;

module.exports = isBuffer;


/***/ }),

/***/ "./node_modules/lodash/isEmpty.js":
/*!****************************************!*\
  !*** ./node_modules/lodash/isEmpty.js ***!
  \****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseKeys = __webpack_require__(/*! ./_baseKeys */ "./node_modules/lodash/_baseKeys.js"),
    getTag = __webpack_require__(/*! ./_getTag */ "./node_modules/lodash/_getTag.js"),
    isArguments = __webpack_require__(/*! ./isArguments */ "./node_modules/lodash/isArguments.js"),
    isArray = __webpack_require__(/*! ./isArray */ "./node_modules/lodash/isArray.js"),
    isArrayLike = __webpack_require__(/*! ./isArrayLike */ "./node_modules/lodash/isArrayLike.js"),
    isBuffer = __webpack_require__(/*! ./isBuffer */ "./node_modules/lodash/isBuffer.js"),
    isPrototype = __webpack_require__(/*! ./_isPrototype */ "./node_modules/lodash/_isPrototype.js"),
    isTypedArray = __webpack_require__(/*! ./isTypedArray */ "./node_modules/lodash/isTypedArray.js");

/** `Object#toString` result references. */
var mapTag = '[object Map]',
    setTag = '[object Set]';

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Checks if `value` is an empty object, collection, map, or set.
 *
 * Objects are considered empty if they have no own enumerable string keyed
 * properties.
 *
 * Array-like values such as `arguments` objects, arrays, buffers, strings, or
 * jQuery-like collections are considered empty if they have a `length` of `0`.
 * Similarly, maps and sets are considered empty if they have a `size` of `0`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is empty, else `false`.
 * @example
 *
 * _.isEmpty(null);
 * // => true
 *
 * _.isEmpty(true);
 * // => true
 *
 * _.isEmpty(1);
 * // => true
 *
 * _.isEmpty([1, 2, 3]);
 * // => false
 *
 * _.isEmpty({ 'a': 1 });
 * // => false
 */
function isEmpty(value) {
  if (value == null) {
    return true;
  }
  if (isArrayLike(value) &&
      (isArray(value) || typeof value == 'string' || typeof value.splice == 'function' ||
        isBuffer(value) || isTypedArray(value) || isArguments(value))) {
    return !value.length;
  }
  var tag = getTag(value);
  if (tag == mapTag || tag == setTag) {
    return !value.size;
  }
  if (isPrototype(value)) {
    return !baseKeys(value).length;
  }
  for (var key in value) {
    if (hasOwnProperty.call(value, key)) {
      return false;
    }
  }
  return true;
}

module.exports = isEmpty;


/***/ }),

/***/ "./node_modules/lodash/isFunction.js":
/*!*******************************************!*\
  !*** ./node_modules/lodash/isFunction.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseGetTag = __webpack_require__(/*! ./_baseGetTag */ "./node_modules/lodash/_baseGetTag.js"),
    isObject = __webpack_require__(/*! ./isObject */ "./node_modules/lodash/isObject.js");

/** `Object#toString` result references. */
var asyncTag = '[object AsyncFunction]',
    funcTag = '[object Function]',
    genTag = '[object GeneratorFunction]',
    proxyTag = '[object Proxy]';

/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */
function isFunction(value) {
  if (!isObject(value)) {
    return false;
  }
  // The use of `Object#toString` avoids issues with the `typeof` operator
  // in Safari 9 which returns 'object' for typed arrays and other constructors.
  var tag = baseGetTag(value);
  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
}

module.exports = isFunction;


/***/ }),

/***/ "./node_modules/lodash/isLength.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/isLength.js ***!
  \*****************************************/
/***/ ((module) => {

/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER = 9007199254740991;

/**
 * Checks if `value` is a valid array-like length.
 *
 * **Note:** This method is loosely based on
 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
 * @example
 *
 * _.isLength(3);
 * // => true
 *
 * _.isLength(Number.MIN_VALUE);
 * // => false
 *
 * _.isLength(Infinity);
 * // => false
 *
 * _.isLength('3');
 * // => false
 */
function isLength(value) {
  return typeof value == 'number' &&
    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}

module.exports = isLength;


/***/ }),

/***/ "./node_modules/lodash/isMap.js":
/*!**************************************!*\
  !*** ./node_modules/lodash/isMap.js ***!
  \**************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseIsMap = __webpack_require__(/*! ./_baseIsMap */ "./node_modules/lodash/_baseIsMap.js"),
    baseUnary = __webpack_require__(/*! ./_baseUnary */ "./node_modules/lodash/_baseUnary.js"),
    nodeUtil = __webpack_require__(/*! ./_nodeUtil */ "./node_modules/lodash/_nodeUtil.js");

/* Node.js helper references. */
var nodeIsMap = nodeUtil && nodeUtil.isMap;

/**
 * Checks if `value` is classified as a `Map` object.
 *
 * @static
 * @memberOf _
 * @since 4.3.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a map, else `false`.
 * @example
 *
 * _.isMap(new Map);
 * // => true
 *
 * _.isMap(new WeakMap);
 * // => false
 */
var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;

module.exports = isMap;


/***/ }),

/***/ "./node_modules/lodash/isObject.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/isObject.js ***!
  \*****************************************/
/***/ ((module) => {

/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject(value) {
  var type = typeof value;
  return value != null && (type == 'object' || type == 'function');
}

module.exports = isObject;


/***/ }),

/***/ "./node_modules/lodash/isObjectLike.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash/isObjectLike.js ***!
  \*********************************************/
/***/ ((module) => {

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return value != null && typeof value == 'object';
}

module.exports = isObjectLike;


/***/ }),

/***/ "./node_modules/lodash/isPlainObject.js":
/*!**********************************************!*\
  !*** ./node_modules/lodash/isPlainObject.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseGetTag = __webpack_require__(/*! ./_baseGetTag */ "./node_modules/lodash/_baseGetTag.js"),
    getPrototype = __webpack_require__(/*! ./_getPrototype */ "./node_modules/lodash/_getPrototype.js"),
    isObjectLike = __webpack_require__(/*! ./isObjectLike */ "./node_modules/lodash/isObjectLike.js");

/** `Object#toString` result references. */
var objectTag = '[object Object]';

/** Used for built-in method references. */
var funcProto = Function.prototype,
    objectProto = Object.prototype;

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/** Used to infer the `Object` constructor. */
var objectCtorString = funcToString.call(Object);

/**
 * Checks if `value` is a plain object, that is, an object created by the
 * `Object` constructor or one with a `[[Prototype]]` of `null`.
 *
 * @static
 * @memberOf _
 * @since 0.8.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 * }
 *
 * _.isPlainObject(new Foo);
 * // => false
 *
 * _.isPlainObject([1, 2, 3]);
 * // => false
 *
 * _.isPlainObject({ 'x': 0, 'y': 0 });
 * // => true
 *
 * _.isPlainObject(Object.create(null));
 * // => true
 */
function isPlainObject(value) {
  if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
    return false;
  }
  var proto = getPrototype(value);
  if (proto === null) {
    return true;
  }
  var Ctor = hasOwnProperty.call(proto, 'constructor') && proto.constructor;
  return typeof Ctor == 'function' && Ctor instanceof Ctor &&
    funcToString.call(Ctor) == objectCtorString;
}

module.exports = isPlainObject;


/***/ }),

/***/ "./node_modules/lodash/isSet.js":
/*!**************************************!*\
  !*** ./node_modules/lodash/isSet.js ***!
  \**************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseIsSet = __webpack_require__(/*! ./_baseIsSet */ "./node_modules/lodash/_baseIsSet.js"),
    baseUnary = __webpack_require__(/*! ./_baseUnary */ "./node_modules/lodash/_baseUnary.js"),
    nodeUtil = __webpack_require__(/*! ./_nodeUtil */ "./node_modules/lodash/_nodeUtil.js");

/* Node.js helper references. */
var nodeIsSet = nodeUtil && nodeUtil.isSet;

/**
 * Checks if `value` is classified as a `Set` object.
 *
 * @static
 * @memberOf _
 * @since 4.3.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a set, else `false`.
 * @example
 *
 * _.isSet(new Set);
 * // => true
 *
 * _.isSet(new WeakSet);
 * // => false
 */
var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;

module.exports = isSet;


/***/ }),

/***/ "./node_modules/lodash/isString.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/isString.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseGetTag = __webpack_require__(/*! ./_baseGetTag */ "./node_modules/lodash/_baseGetTag.js"),
    isArray = __webpack_require__(/*! ./isArray */ "./node_modules/lodash/isArray.js"),
    isObjectLike = __webpack_require__(/*! ./isObjectLike */ "./node_modules/lodash/isObjectLike.js");

/** `Object#toString` result references. */
var stringTag = '[object String]';

/**
 * Checks if `value` is classified as a `String` primitive or object.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a string, else `false`.
 * @example
 *
 * _.isString('abc');
 * // => true
 *
 * _.isString(1);
 * // => false
 */
function isString(value) {
  return typeof value == 'string' ||
    (!isArray(value) && isObjectLike(value) && baseGetTag(value) == stringTag);
}

module.exports = isString;


/***/ }),

/***/ "./node_modules/lodash/isSymbol.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/isSymbol.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseGetTag = __webpack_require__(/*! ./_baseGetTag */ "./node_modules/lodash/_baseGetTag.js"),
    isObjectLike = __webpack_require__(/*! ./isObjectLike */ "./node_modules/lodash/isObjectLike.js");

/** `Object#toString` result references. */
var symbolTag = '[object Symbol]';

/**
 * Checks if `value` is classified as a `Symbol` primitive or object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
 * @example
 *
 * _.isSymbol(Symbol.iterator);
 * // => true
 *
 * _.isSymbol('abc');
 * // => false
 */
function isSymbol(value) {
  return typeof value == 'symbol' ||
    (isObjectLike(value) && baseGetTag(value) == symbolTag);
}

module.exports = isSymbol;


/***/ }),

/***/ "./node_modules/lodash/isTypedArray.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash/isTypedArray.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseIsTypedArray = __webpack_require__(/*! ./_baseIsTypedArray */ "./node_modules/lodash/_baseIsTypedArray.js"),
    baseUnary = __webpack_require__(/*! ./_baseUnary */ "./node_modules/lodash/_baseUnary.js"),
    nodeUtil = __webpack_require__(/*! ./_nodeUtil */ "./node_modules/lodash/_nodeUtil.js");

/* Node.js helper references. */
var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;

/**
 * Checks if `value` is classified as a typed array.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 * @example
 *
 * _.isTypedArray(new Uint8Array);
 * // => true
 *
 * _.isTypedArray([]);
 * // => false
 */
var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;

module.exports = isTypedArray;


/***/ }),

/***/ "./node_modules/lodash/isUndefined.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/isUndefined.js ***!
  \********************************************/
/***/ ((module) => {

/**
 * Checks if `value` is `undefined`.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is `undefined`, else `false`.
 * @example
 *
 * _.isUndefined(void 0);
 * // => true
 *
 * _.isUndefined(null);
 * // => false
 */
function isUndefined(value) {
  return value === undefined;
}

module.exports = isUndefined;


/***/ }),

/***/ "./node_modules/lodash/keys.js":
/*!*************************************!*\
  !*** ./node_modules/lodash/keys.js ***!
  \*************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var arrayLikeKeys = __webpack_require__(/*! ./_arrayLikeKeys */ "./node_modules/lodash/_arrayLikeKeys.js"),
    baseKeys = __webpack_require__(/*! ./_baseKeys */ "./node_modules/lodash/_baseKeys.js"),
    isArrayLike = __webpack_require__(/*! ./isArrayLike */ "./node_modules/lodash/isArrayLike.js");

/**
 * Creates an array of the own enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects. See the
 * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * for more details.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keys(new Foo);
 * // => ['a', 'b'] (iteration order is not guaranteed)
 *
 * _.keys('hi');
 * // => ['0', '1']
 */
function keys(object) {
  return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
}

module.exports = keys;


/***/ }),

/***/ "./node_modules/lodash/keysIn.js":
/*!***************************************!*\
  !*** ./node_modules/lodash/keysIn.js ***!
  \***************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var arrayLikeKeys = __webpack_require__(/*! ./_arrayLikeKeys */ "./node_modules/lodash/_arrayLikeKeys.js"),
    baseKeysIn = __webpack_require__(/*! ./_baseKeysIn */ "./node_modules/lodash/_baseKeysIn.js"),
    isArrayLike = __webpack_require__(/*! ./isArrayLike */ "./node_modules/lodash/isArrayLike.js");

/**
 * Creates an array of the own and inherited enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keysIn(new Foo);
 * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
 */
function keysIn(object) {
  return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
}

module.exports = keysIn;


/***/ }),

/***/ "./node_modules/lodash/last.js":
/*!*************************************!*\
  !*** ./node_modules/lodash/last.js ***!
  \*************************************/
/***/ ((module) => {

/**
 * Gets the last element of `array`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Array
 * @param {Array} array The array to query.
 * @returns {*} Returns the last element of `array`.
 * @example
 *
 * _.last([1, 2, 3]);
 * // => 3
 */
function last(array) {
  var length = array == null ? 0 : array.length;
  return length ? array[length - 1] : undefined;
}

module.exports = last;


/***/ }),

/***/ "./node_modules/lodash/map.js":
/*!************************************!*\
  !*** ./node_modules/lodash/map.js ***!
  \************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var arrayMap = __webpack_require__(/*! ./_arrayMap */ "./node_modules/lodash/_arrayMap.js"),
    baseIteratee = __webpack_require__(/*! ./_baseIteratee */ "./node_modules/lodash/_baseIteratee.js"),
    baseMap = __webpack_require__(/*! ./_baseMap */ "./node_modules/lodash/_baseMap.js"),
    isArray = __webpack_require__(/*! ./isArray */ "./node_modules/lodash/isArray.js");

/**
 * Creates an array of values by running each element in `collection` thru
 * `iteratee`. The iteratee is invoked with three arguments:
 * (value, index|key, collection).
 *
 * Many lodash methods are guarded to work as iteratees for methods like
 * `_.every`, `_.filter`, `_.map`, `_.mapValues`, `_.reject`, and `_.some`.
 *
 * The guarded methods are:
 * `ary`, `chunk`, `curry`, `curryRight`, `drop`, `dropRight`, `every`,
 * `fill`, `invert`, `parseInt`, `random`, `range`, `rangeRight`, `repeat`,
 * `sampleSize`, `slice`, `some`, `sortBy`, `split`, `take`, `takeRight`,
 * `template`, `trim`, `trimEnd`, `trimStart`, and `words`
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Collection
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} [iteratee=_.identity] The function invoked per iteration.
 * @returns {Array} Returns the new mapped array.
 * @example
 *
 * function square(n) {
 *   return n * n;
 * }
 *
 * _.map([4, 8], square);
 * // => [16, 64]
 *
 * _.map({ 'a': 4, 'b': 8 }, square);
 * // => [16, 64] (iteration order is not guaranteed)
 *
 * var users = [
 *   { 'user': 'barney' },
 *   { 'user': 'fred' }
 * ];
 *
 * // The `_.property` iteratee shorthand.
 * _.map(users, 'user');
 * // => ['barney', 'fred']
 */
function map(collection, iteratee) {
  var func = isArray(collection) ? arrayMap : baseMap;
  return func(collection, baseIteratee(iteratee, 3));
}

module.exports = map;


/***/ }),

/***/ "./node_modules/lodash/mapValues.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/mapValues.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseAssignValue = __webpack_require__(/*! ./_baseAssignValue */ "./node_modules/lodash/_baseAssignValue.js"),
    baseForOwn = __webpack_require__(/*! ./_baseForOwn */ "./node_modules/lodash/_baseForOwn.js"),
    baseIteratee = __webpack_require__(/*! ./_baseIteratee */ "./node_modules/lodash/_baseIteratee.js");

/**
 * Creates an object with the same keys as `object` and values generated
 * by running each own enumerable string keyed property of `object` thru
 * `iteratee`. The iteratee is invoked with three arguments:
 * (value, key, object).
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Object
 * @param {Object} object The object to iterate over.
 * @param {Function} [iteratee=_.identity] The function invoked per iteration.
 * @returns {Object} Returns the new mapped object.
 * @see _.mapKeys
 * @example
 *
 * var users = {
 *   'fred':    { 'user': 'fred',    'age': 40 },
 *   'pebbles': { 'user': 'pebbles', 'age': 1 }
 * };
 *
 * _.mapValues(users, function(o) { return o.age; });
 * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)
 *
 * // The `_.property` iteratee shorthand.
 * _.mapValues(users, 'age');
 * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)
 */
function mapValues(object, iteratee) {
  var result = {};
  iteratee = baseIteratee(iteratee, 3);

  baseForOwn(object, function(value, key, object) {
    baseAssignValue(result, key, iteratee(value, key, object));
  });
  return result;
}

module.exports = mapValues;


/***/ }),

/***/ "./node_modules/lodash/max.js":
/*!************************************!*\
  !*** ./node_modules/lodash/max.js ***!
  \************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseExtremum = __webpack_require__(/*! ./_baseExtremum */ "./node_modules/lodash/_baseExtremum.js"),
    baseGt = __webpack_require__(/*! ./_baseGt */ "./node_modules/lodash/_baseGt.js"),
    identity = __webpack_require__(/*! ./identity */ "./node_modules/lodash/identity.js");

/**
 * Computes the maximum value of `array`. If `array` is empty or falsey,
 * `undefined` is returned.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Math
 * @param {Array} array The array to iterate over.
 * @returns {*} Returns the maximum value.
 * @example
 *
 * _.max([4, 2, 8, 6]);
 * // => 8
 *
 * _.max([]);
 * // => undefined
 */
function max(array) {
  return (array && array.length)
    ? baseExtremum(array, identity, baseGt)
    : undefined;
}

module.exports = max;


/***/ }),

/***/ "./node_modules/lodash/memoize.js":
/*!****************************************!*\
  !*** ./node_modules/lodash/memoize.js ***!
  \****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var MapCache = __webpack_require__(/*! ./_MapCache */ "./node_modules/lodash/_MapCache.js");

/** Error message constants. */
var FUNC_ERROR_TEXT = 'Expected a function';

/**
 * Creates a function that memoizes the result of `func`. If `resolver` is
 * provided, it determines the cache key for storing the result based on the
 * arguments provided to the memoized function. By default, the first argument
 * provided to the memoized function is used as the map cache key. The `func`
 * is invoked with the `this` binding of the memoized function.
 *
 * **Note:** The cache is exposed as the `cache` property on the memoized
 * function. Its creation may be customized by replacing the `_.memoize.Cache`
 * constructor with one whose instances implement the
 * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
 * method interface of `clear`, `delete`, `get`, `has`, and `set`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to have its output memoized.
 * @param {Function} [resolver] The function to resolve the cache key.
 * @returns {Function} Returns the new memoized function.
 * @example
 *
 * var object = { 'a': 1, 'b': 2 };
 * var other = { 'c': 3, 'd': 4 };
 *
 * var values = _.memoize(_.values);
 * values(object);
 * // => [1, 2]
 *
 * values(other);
 * // => [3, 4]
 *
 * object.a = 2;
 * values(object);
 * // => [1, 2]
 *
 * // Modify the result cache.
 * values.cache.set(object, ['a', 'b']);
 * values(object);
 * // => ['a', 'b']
 *
 * // Replace `_.memoize.Cache`.
 * _.memoize.Cache = WeakMap;
 */
function memoize(func, resolver) {
  if (typeof func != 'function' || (resolver != null && typeof resolver != 'function')) {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  var memoized = function() {
    var args = arguments,
        key = resolver ? resolver.apply(this, args) : args[0],
        cache = memoized.cache;

    if (cache.has(key)) {
      return cache.get(key);
    }
    var result = func.apply(this, args);
    memoized.cache = cache.set(key, result) || cache;
    return result;
  };
  memoized.cache = new (memoize.Cache || MapCache);
  return memoized;
}

// Expose `MapCache`.
memoize.Cache = MapCache;

module.exports = memoize;


/***/ }),

/***/ "./node_modules/lodash/merge.js":
/*!**************************************!*\
  !*** ./node_modules/lodash/merge.js ***!
  \**************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseMerge = __webpack_require__(/*! ./_baseMerge */ "./node_modules/lodash/_baseMerge.js"),
    createAssigner = __webpack_require__(/*! ./_createAssigner */ "./node_modules/lodash/_createAssigner.js");

/**
 * This method is like `_.assign` except that it recursively merges own and
 * inherited enumerable string keyed properties of source objects into the
 * destination object. Source properties that resolve to `undefined` are
 * skipped if a destination value exists. Array and plain object properties
 * are merged recursively. Other objects and value types are overridden by
 * assignment. Source objects are applied from left to right. Subsequent
 * sources overwrite property assignments of previous sources.
 *
 * **Note:** This method mutates `object`.
 *
 * @static
 * @memberOf _
 * @since 0.5.0
 * @category Object
 * @param {Object} object The destination object.
 * @param {...Object} [sources] The source objects.
 * @returns {Object} Returns `object`.
 * @example
 *
 * var object = {
 *   'a': [{ 'b': 2 }, { 'd': 4 }]
 * };
 *
 * var other = {
 *   'a': [{ 'c': 3 }, { 'e': 5 }]
 * };
 *
 * _.merge(object, other);
 * // => { 'a': [{ 'b': 2, 'c': 3 }, { 'd': 4, 'e': 5 }] }
 */
var merge = createAssigner(function(object, source, srcIndex) {
  baseMerge(object, source, srcIndex);
});

module.exports = merge;


/***/ }),

/***/ "./node_modules/lodash/min.js":
/*!************************************!*\
  !*** ./node_modules/lodash/min.js ***!
  \************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseExtremum = __webpack_require__(/*! ./_baseExtremum */ "./node_modules/lodash/_baseExtremum.js"),
    baseLt = __webpack_require__(/*! ./_baseLt */ "./node_modules/lodash/_baseLt.js"),
    identity = __webpack_require__(/*! ./identity */ "./node_modules/lodash/identity.js");

/**
 * Computes the minimum value of `array`. If `array` is empty or falsey,
 * `undefined` is returned.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Math
 * @param {Array} array The array to iterate over.
 * @returns {*} Returns the minimum value.
 * @example
 *
 * _.min([4, 2, 8, 6]);
 * // => 2
 *
 * _.min([]);
 * // => undefined
 */
function min(array) {
  return (array && array.length)
    ? baseExtremum(array, identity, baseLt)
    : undefined;
}

module.exports = min;


/***/ }),

/***/ "./node_modules/lodash/minBy.js":
/*!**************************************!*\
  !*** ./node_modules/lodash/minBy.js ***!
  \**************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseExtremum = __webpack_require__(/*! ./_baseExtremum */ "./node_modules/lodash/_baseExtremum.js"),
    baseIteratee = __webpack_require__(/*! ./_baseIteratee */ "./node_modules/lodash/_baseIteratee.js"),
    baseLt = __webpack_require__(/*! ./_baseLt */ "./node_modules/lodash/_baseLt.js");

/**
 * This method is like `_.min` except that it accepts `iteratee` which is
 * invoked for each element in `array` to generate the criterion by which
 * the value is ranked. The iteratee is invoked with one argument: (value).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Math
 * @param {Array} array The array to iterate over.
 * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
 * @returns {*} Returns the minimum value.
 * @example
 *
 * var objects = [{ 'n': 1 }, { 'n': 2 }];
 *
 * _.minBy(objects, function(o) { return o.n; });
 * // => { 'n': 1 }
 *
 * // The `_.property` iteratee shorthand.
 * _.minBy(objects, 'n');
 * // => { 'n': 1 }
 */
function minBy(array, iteratee) {
  return (array && array.length)
    ? baseExtremum(array, baseIteratee(iteratee, 2), baseLt)
    : undefined;
}

module.exports = minBy;


/***/ }),

/***/ "./node_modules/lodash/noop.js":
/*!*************************************!*\
  !*** ./node_modules/lodash/noop.js ***!
  \*************************************/
/***/ ((module) => {

/**
 * This method returns `undefined`.
 *
 * @static
 * @memberOf _
 * @since 2.3.0
 * @category Util
 * @example
 *
 * _.times(2, _.noop);
 * // => [undefined, undefined]
 */
function noop() {
  // No operation performed.
}

module.exports = noop;


/***/ }),

/***/ "./node_modules/lodash/now.js":
/*!************************************!*\
  !*** ./node_modules/lodash/now.js ***!
  \************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var root = __webpack_require__(/*! ./_root */ "./node_modules/lodash/_root.js");

/**
 * Gets the timestamp of the number of milliseconds that have elapsed since
 * the Unix epoch (1 January 1970 00:00:00 UTC).
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Date
 * @returns {number} Returns the timestamp.
 * @example
 *
 * _.defer(function(stamp) {
 *   console.log(_.now() - stamp);
 * }, _.now());
 * // => Logs the number of milliseconds it took for the deferred invocation.
 */
var now = function() {
  return root.Date.now();
};

module.exports = now;


/***/ }),

/***/ "./node_modules/lodash/pick.js":
/*!*************************************!*\
  !*** ./node_modules/lodash/pick.js ***!
  \*************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var basePick = __webpack_require__(/*! ./_basePick */ "./node_modules/lodash/_basePick.js"),
    flatRest = __webpack_require__(/*! ./_flatRest */ "./node_modules/lodash/_flatRest.js");

/**
 * Creates an object composed of the picked `object` properties.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The source object.
 * @param {...(string|string[])} [paths] The property paths to pick.
 * @returns {Object} Returns the new object.
 * @example
 *
 * var object = { 'a': 1, 'b': '2', 'c': 3 };
 *
 * _.pick(object, ['a', 'c']);
 * // => { 'a': 1, 'c': 3 }
 */
var pick = flatRest(function(object, paths) {
  return object == null ? {} : basePick(object, paths);
});

module.exports = pick;


/***/ }),

/***/ "./node_modules/lodash/property.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/property.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseProperty = __webpack_require__(/*! ./_baseProperty */ "./node_modules/lodash/_baseProperty.js"),
    basePropertyDeep = __webpack_require__(/*! ./_basePropertyDeep */ "./node_modules/lodash/_basePropertyDeep.js"),
    isKey = __webpack_require__(/*! ./_isKey */ "./node_modules/lodash/_isKey.js"),
    toKey = __webpack_require__(/*! ./_toKey */ "./node_modules/lodash/_toKey.js");

/**
 * Creates a function that returns the value at `path` of a given object.
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Util
 * @param {Array|string} path The path of the property to get.
 * @returns {Function} Returns the new accessor function.
 * @example
 *
 * var objects = [
 *   { 'a': { 'b': 2 } },
 *   { 'a': { 'b': 1 } }
 * ];
 *
 * _.map(objects, _.property('a.b'));
 * // => [2, 1]
 *
 * _.map(_.sortBy(objects, _.property(['a', 'b'])), 'a.b');
 * // => [1, 2]
 */
function property(path) {
  return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
}

module.exports = property;


/***/ }),

/***/ "./node_modules/lodash/range.js":
/*!**************************************!*\
  !*** ./node_modules/lodash/range.js ***!
  \**************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var createRange = __webpack_require__(/*! ./_createRange */ "./node_modules/lodash/_createRange.js");

/**
 * Creates an array of numbers (positive and/or negative) progressing from
 * `start` up to, but not including, `end`. A step of `-1` is used if a negative
 * `start` is specified without an `end` or `step`. If `end` is not specified,
 * it's set to `start` with `start` then set to `0`.
 *
 * **Note:** JavaScript follows the IEEE-754 standard for resolving
 * floating-point values which can produce unexpected results.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Util
 * @param {number} [start=0] The start of the range.
 * @param {number} end The end of the range.
 * @param {number} [step=1] The value to increment or decrement by.
 * @returns {Array} Returns the range of numbers.
 * @see _.inRange, _.rangeRight
 * @example
 *
 * _.range(4);
 * // => [0, 1, 2, 3]
 *
 * _.range(-4);
 * // => [0, -1, -2, -3]
 *
 * _.range(1, 5);
 * // => [1, 2, 3, 4]
 *
 * _.range(0, 20, 5);
 * // => [0, 5, 10, 15]
 *
 * _.range(0, -4, -1);
 * // => [0, -1, -2, -3]
 *
 * _.range(1, 4, 0);
 * // => [1, 1, 1]
 *
 * _.range(0);
 * // => []
 */
var range = createRange();

module.exports = range;


/***/ }),

/***/ "./node_modules/lodash/reduce.js":
/*!***************************************!*\
  !*** ./node_modules/lodash/reduce.js ***!
  \***************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var arrayReduce = __webpack_require__(/*! ./_arrayReduce */ "./node_modules/lodash/_arrayReduce.js"),
    baseEach = __webpack_require__(/*! ./_baseEach */ "./node_modules/lodash/_baseEach.js"),
    baseIteratee = __webpack_require__(/*! ./_baseIteratee */ "./node_modules/lodash/_baseIteratee.js"),
    baseReduce = __webpack_require__(/*! ./_baseReduce */ "./node_modules/lodash/_baseReduce.js"),
    isArray = __webpack_require__(/*! ./isArray */ "./node_modules/lodash/isArray.js");

/**
 * Reduces `collection` to a value which is the accumulated result of running
 * each element in `collection` thru `iteratee`, where each successive
 * invocation is supplied the return value of the previous. If `accumulator`
 * is not given, the first element of `collection` is used as the initial
 * value. The iteratee is invoked with four arguments:
 * (accumulator, value, index|key, collection).
 *
 * Many lodash methods are guarded to work as iteratees for methods like
 * `_.reduce`, `_.reduceRight`, and `_.transform`.
 *
 * The guarded methods are:
 * `assign`, `defaults`, `defaultsDeep`, `includes`, `merge`, `orderBy`,
 * and `sortBy`
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Collection
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} [iteratee=_.identity] The function invoked per iteration.
 * @param {*} [accumulator] The initial value.
 * @returns {*} Returns the accumulated value.
 * @see _.reduceRight
 * @example
 *
 * _.reduce([1, 2], function(sum, n) {
 *   return sum + n;
 * }, 0);
 * // => 3
 *
 * _.reduce({ 'a': 1, 'b': 2, 'c': 1 }, function(result, value, key) {
 *   (result[value] || (result[value] = [])).push(key);
 *   return result;
 * }, {});
 * // => { '1': ['a', 'c'], '2': ['b'] } (iteration order is not guaranteed)
 */
function reduce(collection, iteratee, accumulator) {
  var func = isArray(collection) ? arrayReduce : baseReduce,
      initAccum = arguments.length < 3;

  return func(collection, baseIteratee(iteratee, 4), accumulator, initAccum, baseEach);
}

module.exports = reduce;


/***/ }),

/***/ "./node_modules/lodash/size.js":
/*!*************************************!*\
  !*** ./node_modules/lodash/size.js ***!
  \*************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseKeys = __webpack_require__(/*! ./_baseKeys */ "./node_modules/lodash/_baseKeys.js"),
    getTag = __webpack_require__(/*! ./_getTag */ "./node_modules/lodash/_getTag.js"),
    isArrayLike = __webpack_require__(/*! ./isArrayLike */ "./node_modules/lodash/isArrayLike.js"),
    isString = __webpack_require__(/*! ./isString */ "./node_modules/lodash/isString.js"),
    stringSize = __webpack_require__(/*! ./_stringSize */ "./node_modules/lodash/_stringSize.js");

/** `Object#toString` result references. */
var mapTag = '[object Map]',
    setTag = '[object Set]';

/**
 * Gets the size of `collection` by returning its length for array-like
 * values or the number of own enumerable string keyed properties for objects.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Collection
 * @param {Array|Object|string} collection The collection to inspect.
 * @returns {number} Returns the collection size.
 * @example
 *
 * _.size([1, 2, 3]);
 * // => 3
 *
 * _.size({ 'a': 1, 'b': 2 });
 * // => 2
 *
 * _.size('pebbles');
 * // => 7
 */
function size(collection) {
  if (collection == null) {
    return 0;
  }
  if (isArrayLike(collection)) {
    return isString(collection) ? stringSize(collection) : collection.length;
  }
  var tag = getTag(collection);
  if (tag == mapTag || tag == setTag) {
    return collection.size;
  }
  return baseKeys(collection).length;
}

module.exports = size;


/***/ }),

/***/ "./node_modules/lodash/sortBy.js":
/*!***************************************!*\
  !*** ./node_modules/lodash/sortBy.js ***!
  \***************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseFlatten = __webpack_require__(/*! ./_baseFlatten */ "./node_modules/lodash/_baseFlatten.js"),
    baseOrderBy = __webpack_require__(/*! ./_baseOrderBy */ "./node_modules/lodash/_baseOrderBy.js"),
    baseRest = __webpack_require__(/*! ./_baseRest */ "./node_modules/lodash/_baseRest.js"),
    isIterateeCall = __webpack_require__(/*! ./_isIterateeCall */ "./node_modules/lodash/_isIterateeCall.js");

/**
 * Creates an array of elements, sorted in ascending order by the results of
 * running each element in a collection thru each iteratee. This method
 * performs a stable sort, that is, it preserves the original sort order of
 * equal elements. The iteratees are invoked with one argument: (value).
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Collection
 * @param {Array|Object} collection The collection to iterate over.
 * @param {...(Function|Function[])} [iteratees=[_.identity]]
 *  The iteratees to sort by.
 * @returns {Array} Returns the new sorted array.
 * @example
 *
 * var users = [
 *   { 'user': 'fred',   'age': 48 },
 *   { 'user': 'barney', 'age': 36 },
 *   { 'user': 'fred',   'age': 30 },
 *   { 'user': 'barney', 'age': 34 }
 * ];
 *
 * _.sortBy(users, [function(o) { return o.user; }]);
 * // => objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 30]]
 *
 * _.sortBy(users, ['user', 'age']);
 * // => objects for [['barney', 34], ['barney', 36], ['fred', 30], ['fred', 48]]
 */
var sortBy = baseRest(function(collection, iteratees) {
  if (collection == null) {
    return [];
  }
  var length = iteratees.length;
  if (length > 1 && isIterateeCall(collection, iteratees[0], iteratees[1])) {
    iteratees = [];
  } else if (length > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) {
    iteratees = [iteratees[0]];
  }
  return baseOrderBy(collection, baseFlatten(iteratees, 1), []);
});

module.exports = sortBy;


/***/ }),

/***/ "./node_modules/lodash/stubArray.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/stubArray.js ***!
  \******************************************/
/***/ ((module) => {

/**
 * This method returns a new empty array.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {Array} Returns the new empty array.
 * @example
 *
 * var arrays = _.times(2, _.stubArray);
 *
 * console.log(arrays);
 * // => [[], []]
 *
 * console.log(arrays[0] === arrays[1]);
 * // => false
 */
function stubArray() {
  return [];
}

module.exports = stubArray;


/***/ }),

/***/ "./node_modules/lodash/stubFalse.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/stubFalse.js ***!
  \******************************************/
/***/ ((module) => {

/**
 * This method returns `false`.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {boolean} Returns `false`.
 * @example
 *
 * _.times(2, _.stubFalse);
 * // => [false, false]
 */
function stubFalse() {
  return false;
}

module.exports = stubFalse;


/***/ }),

/***/ "./node_modules/lodash/toFinite.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/toFinite.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var toNumber = __webpack_require__(/*! ./toNumber */ "./node_modules/lodash/toNumber.js");

/** Used as references for various `Number` constants. */
var INFINITY = 1 / 0,
    MAX_INTEGER = 1.7976931348623157e+308;

/**
 * Converts `value` to a finite number.
 *
 * @static
 * @memberOf _
 * @since 4.12.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {number} Returns the converted number.
 * @example
 *
 * _.toFinite(3.2);
 * // => 3.2
 *
 * _.toFinite(Number.MIN_VALUE);
 * // => 5e-324
 *
 * _.toFinite(Infinity);
 * // => 1.7976931348623157e+308
 *
 * _.toFinite('3.2');
 * // => 3.2
 */
function toFinite(value) {
  if (!value) {
    return value === 0 ? value : 0;
  }
  value = toNumber(value);
  if (value === INFINITY || value === -INFINITY) {
    var sign = (value < 0 ? -1 : 1);
    return sign * MAX_INTEGER;
  }
  return value === value ? value : 0;
}

module.exports = toFinite;


/***/ }),

/***/ "./node_modules/lodash/toInteger.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/toInteger.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var toFinite = __webpack_require__(/*! ./toFinite */ "./node_modules/lodash/toFinite.js");

/**
 * Converts `value` to an integer.
 *
 * **Note:** This method is loosely based on
 * [`ToInteger`](http://www.ecma-international.org/ecma-262/7.0/#sec-tointeger).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {number} Returns the converted integer.
 * @example
 *
 * _.toInteger(3.2);
 * // => 3
 *
 * _.toInteger(Number.MIN_VALUE);
 * // => 0
 *
 * _.toInteger(Infinity);
 * // => 1.7976931348623157e+308
 *
 * _.toInteger('3.2');
 * // => 3
 */
function toInteger(value) {
  var result = toFinite(value),
      remainder = result % 1;

  return result === result ? (remainder ? result - remainder : result) : 0;
}

module.exports = toInteger;


/***/ }),

/***/ "./node_modules/lodash/toNumber.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/toNumber.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseTrim = __webpack_require__(/*! ./_baseTrim */ "./node_modules/lodash/_baseTrim.js"),
    isObject = __webpack_require__(/*! ./isObject */ "./node_modules/lodash/isObject.js"),
    isSymbol = __webpack_require__(/*! ./isSymbol */ "./node_modules/lodash/isSymbol.js");

/** Used as references for various `Number` constants. */
var NAN = 0 / 0;

/** Used to detect bad signed hexadecimal string values. */
var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;

/** Used to detect binary string values. */
var reIsBinary = /^0b[01]+$/i;

/** Used to detect octal string values. */
var reIsOctal = /^0o[0-7]+$/i;

/** Built-in method references without a dependency on `root`. */
var freeParseInt = parseInt;

/**
 * Converts `value` to a number.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to process.
 * @returns {number} Returns the number.
 * @example
 *
 * _.toNumber(3.2);
 * // => 3.2
 *
 * _.toNumber(Number.MIN_VALUE);
 * // => 5e-324
 *
 * _.toNumber(Infinity);
 * // => Infinity
 *
 * _.toNumber('3.2');
 * // => 3.2
 */
function toNumber(value) {
  if (typeof value == 'number') {
    return value;
  }
  if (isSymbol(value)) {
    return NAN;
  }
  if (isObject(value)) {
    var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
    value = isObject(other) ? (other + '') : other;
  }
  if (typeof value != 'string') {
    return value === 0 ? value : +value;
  }
  value = baseTrim(value);
  var isBinary = reIsBinary.test(value);
  return (isBinary || reIsOctal.test(value))
    ? freeParseInt(value.slice(2), isBinary ? 2 : 8)
    : (reIsBadHex.test(value) ? NAN : +value);
}

module.exports = toNumber;


/***/ }),

/***/ "./node_modules/lodash/toPlainObject.js":
/*!**********************************************!*\
  !*** ./node_modules/lodash/toPlainObject.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var copyObject = __webpack_require__(/*! ./_copyObject */ "./node_modules/lodash/_copyObject.js"),
    keysIn = __webpack_require__(/*! ./keysIn */ "./node_modules/lodash/keysIn.js");

/**
 * Converts `value` to a plain object flattening inherited enumerable string
 * keyed properties of `value` to own properties of the plain object.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {Object} Returns the converted plain object.
 * @example
 *
 * function Foo() {
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.assign({ 'a': 1 }, new Foo);
 * // => { 'a': 1, 'b': 2 }
 *
 * _.assign({ 'a': 1 }, _.toPlainObject(new Foo));
 * // => { 'a': 1, 'b': 2, 'c': 3 }
 */
function toPlainObject(value) {
  return copyObject(value, keysIn(value));
}

module.exports = toPlainObject;


/***/ }),

/***/ "./node_modules/lodash/toString.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/toString.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseToString = __webpack_require__(/*! ./_baseToString */ "./node_modules/lodash/_baseToString.js");

/**
 * Converts `value` to a string. An empty string is returned for `null`
 * and `undefined` values. The sign of `-0` is preserved.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 * @example
 *
 * _.toString(null);
 * // => ''
 *
 * _.toString(-0);
 * // => '-0'
 *
 * _.toString([1, 2, 3]);
 * // => '1,2,3'
 */
function toString(value) {
  return value == null ? '' : baseToString(value);
}

module.exports = toString;


/***/ }),

/***/ "./node_modules/lodash/transform.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/transform.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var arrayEach = __webpack_require__(/*! ./_arrayEach */ "./node_modules/lodash/_arrayEach.js"),
    baseCreate = __webpack_require__(/*! ./_baseCreate */ "./node_modules/lodash/_baseCreate.js"),
    baseForOwn = __webpack_require__(/*! ./_baseForOwn */ "./node_modules/lodash/_baseForOwn.js"),
    baseIteratee = __webpack_require__(/*! ./_baseIteratee */ "./node_modules/lodash/_baseIteratee.js"),
    getPrototype = __webpack_require__(/*! ./_getPrototype */ "./node_modules/lodash/_getPrototype.js"),
    isArray = __webpack_require__(/*! ./isArray */ "./node_modules/lodash/isArray.js"),
    isBuffer = __webpack_require__(/*! ./isBuffer */ "./node_modules/lodash/isBuffer.js"),
    isFunction = __webpack_require__(/*! ./isFunction */ "./node_modules/lodash/isFunction.js"),
    isObject = __webpack_require__(/*! ./isObject */ "./node_modules/lodash/isObject.js"),
    isTypedArray = __webpack_require__(/*! ./isTypedArray */ "./node_modules/lodash/isTypedArray.js");

/**
 * An alternative to `_.reduce`; this method transforms `object` to a new
 * `accumulator` object which is the result of running each of its own
 * enumerable string keyed properties thru `iteratee`, with each invocation
 * potentially mutating the `accumulator` object. If `accumulator` is not
 * provided, a new object with the same `[[Prototype]]` will be used. The
 * iteratee is invoked with four arguments: (accumulator, value, key, object).
 * Iteratee functions may exit iteration early by explicitly returning `false`.
 *
 * @static
 * @memberOf _
 * @since 1.3.0
 * @category Object
 * @param {Object} object The object to iterate over.
 * @param {Function} [iteratee=_.identity] The function invoked per iteration.
 * @param {*} [accumulator] The custom accumulator value.
 * @returns {*} Returns the accumulated value.
 * @example
 *
 * _.transform([2, 3, 4], function(result, n) {
 *   result.push(n *= n);
 *   return n % 2 == 0;
 * }, []);
 * // => [4, 9]
 *
 * _.transform({ 'a': 1, 'b': 2, 'c': 1 }, function(result, value, key) {
 *   (result[value] || (result[value] = [])).push(key);
 * }, {});
 * // => { '1': ['a', 'c'], '2': ['b'] }
 */
function transform(object, iteratee, accumulator) {
  var isArr = isArray(object),
      isArrLike = isArr || isBuffer(object) || isTypedArray(object);

  iteratee = baseIteratee(iteratee, 4);
  if (accumulator == null) {
    var Ctor = object && object.constructor;
    if (isArrLike) {
      accumulator = isArr ? new Ctor : [];
    }
    else if (isObject(object)) {
      accumulator = isFunction(Ctor) ? baseCreate(getPrototype(object)) : {};
    }
    else {
      accumulator = {};
    }
  }
  (isArrLike ? arrayEach : baseForOwn)(object, function(value, index, object) {
    return iteratee(accumulator, value, index, object);
  });
  return accumulator;
}

module.exports = transform;


/***/ }),

/***/ "./node_modules/lodash/union.js":
/*!**************************************!*\
  !*** ./node_modules/lodash/union.js ***!
  \**************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseFlatten = __webpack_require__(/*! ./_baseFlatten */ "./node_modules/lodash/_baseFlatten.js"),
    baseRest = __webpack_require__(/*! ./_baseRest */ "./node_modules/lodash/_baseRest.js"),
    baseUniq = __webpack_require__(/*! ./_baseUniq */ "./node_modules/lodash/_baseUniq.js"),
    isArrayLikeObject = __webpack_require__(/*! ./isArrayLikeObject */ "./node_modules/lodash/isArrayLikeObject.js");

/**
 * Creates an array of unique values, in order, from all given arrays using
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * for equality comparisons.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Array
 * @param {...Array} [arrays] The arrays to inspect.
 * @returns {Array} Returns the new array of combined values.
 * @example
 *
 * _.union([2], [1, 2]);
 * // => [2, 1]
 */
var union = baseRest(function(arrays) {
  return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true));
});

module.exports = union;


/***/ }),

/***/ "./node_modules/lodash/uniqueId.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/uniqueId.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var toString = __webpack_require__(/*! ./toString */ "./node_modules/lodash/toString.js");

/** Used to generate unique IDs. */
var idCounter = 0;

/**
 * Generates a unique ID. If `prefix` is given, the ID is appended to it.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Util
 * @param {string} [prefix=''] The value to prefix the ID with.
 * @returns {string} Returns the unique ID.
 * @example
 *
 * _.uniqueId('contact_');
 * // => 'contact_104'
 *
 * _.uniqueId();
 * // => '105'
 */
function uniqueId(prefix) {
  var id = ++idCounter;
  return toString(prefix) + id;
}

module.exports = uniqueId;


/***/ }),

/***/ "./node_modules/lodash/values.js":
/*!***************************************!*\
  !*** ./node_modules/lodash/values.js ***!
  \***************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseValues = __webpack_require__(/*! ./_baseValues */ "./node_modules/lodash/_baseValues.js"),
    keys = __webpack_require__(/*! ./keys */ "./node_modules/lodash/keys.js");

/**
 * Creates an array of the own enumerable string keyed property values of `object`.
 *
 * **Note:** Non-object values are coerced to objects.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property values.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.values(new Foo);
 * // => [1, 2] (iteration order is not guaranteed)
 *
 * _.values('hi');
 * // => ['h', 'i']
 */
function values(object) {
  return object == null ? [] : baseValues(object, keys(object));
}

module.exports = values;


/***/ }),

/***/ "./node_modules/lodash/zipObject.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/zipObject.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var assignValue = __webpack_require__(/*! ./_assignValue */ "./node_modules/lodash/_assignValue.js"),
    baseZipObject = __webpack_require__(/*! ./_baseZipObject */ "./node_modules/lodash/_baseZipObject.js");

/**
 * This method is like `_.fromPairs` except that it accepts two arrays,
 * one of property identifiers and one of corresponding values.
 *
 * @static
 * @memberOf _
 * @since 0.4.0
 * @category Array
 * @param {Array} [props=[]] The property identifiers.
 * @param {Array} [values=[]] The property values.
 * @returns {Object} Returns the new object.
 * @example
 *
 * _.zipObject(['a', 'b'], [1, 2]);
 * // => { 'a': 1, 'b': 2 }
 */
function zipObject(props, values) {
  return baseZipObject(props || [], values || [], assignValue);
}

module.exports = zipObject;


/***/ }),

/***/ "./src/visualizers/run-json-tests.less":
/*!*********************************************!*\
  !*** ./src/visualizers/run-json-tests.less ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin


/***/ }),

/***/ "./node_modules/taitto/lib/anim/anim.js":
/*!**********************************************!*\
  !*** ./node_modules/taitto/lib/anim/anim.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AnimSequence = exports.Anim = void 0;
class Anim {
    constructor(target, duration = 1000) {
        this.target = target;
        this.duration = duration;
        this.start = 0;
    }
    get stop() {
        return this.start + this.duration;
    }
    play() {
        return new Promise(resolve => this.start != 0 ?
            setTimeout(() => this.run(resolve), this.start) :
            this.run(resolve));
    }
}
exports.Anim = Anim;
class AnimSequence {
    constructor() {
        this.anims = [];
    }
    play() {
        return Promise.all(this.anims.map(a => a.play()));
    }
    add(anim, start) {
        anim.start = start;
        let i = this.anims.findIndex(a => a.start > start);
        if (i < 0)
            this.anims.push(anim);
        else
            this.anims.splice(i, 0, anim);
    }
    addAt(anim, start) {
        if (Array.isArray(anim))
            anim.forEach(a => this.add(a, start));
        else
            this.add(anim, start);
        return this;
    }
    addAfter(anim, after, delay = 0) {
        if (typeof after === "number")
            after = this.anims[after];
        this.addAt(anim, after.stop + delay);
        return this;
    }
    addToEnd(anim, delay = 0) {
        let maxstop = this.anims.length == 0 ? 0 :
            Math.max(...this.anims.map(a => a.stop));
        this.addAt(anim, maxstop + delay);
        return this;
    }
    addToEndStaggered(anims, gap, delay = 0) {
        let maxstop = this.anims.length == 0 ? 0 :
            Math.max(...this.anims.map(a => a.stop));
        for (let i = 0; i < anims.length; ++i)
            this.addAt(anims[i], maxstop + delay + (i * gap));
        return this;
    }
}
exports.AnimSequence = AnimSequence;
//# sourceMappingURL=anim.js.map

/***/ }),

/***/ "./node_modules/taitto/lib/anim/animated-view.js":
/*!*******************************************************!*\
  !*** ./node_modules/taitto/lib/anim/animated-view.js ***!
  \*******************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.animatedView = exports.AnimatedView = void 0;
const el = __importStar(__webpack_require__(/*! ../svg/elem */ "./node_modules/taitto/lib/svg/elem.js"));
const ad = __importStar(__webpack_require__(/*! ./animated */ "./node_modules/taitto/lib/anim/animated.js"));
const kfa = __importStar(__webpack_require__(/*! ./keyframe-anim */ "./node_modules/taitto/lib/anim/keyframe-anim.js"));
class AnimatedView extends ad.Animated {
    constructor(parent) {
        super(parent.element);
        this.svgparent = parent;
    }
    get parentVBox() {
        return el.getViewBox(this.svgparent);
    }
    zoom(to, duration = 1000) {
        let vbox = this.parentVBox;
        let scale = Math.min(vbox.width / to.width, vbox.height / to.height);
        let x = vbox.left - to.left;
        let y = vbox.top - to.top;
        return new kfa.KeyframeAnim(this, [ad.current, a => a.state.scale(scale, scale).move(x, y)], duration);
    }
    zoomFactor(scale, x, y, duration = 1000) {
        let vbox = this.parentVBox;
        let sx = vbox.centerX - x;
        let sy = vbox.centerY - y;
        return new kfa.KeyframeAnim(this, [ad.current, a => a.state.scale(scale, scale).move(sx, sy)], duration);
    }
    zoomHome(duration = 1000) {
        return new kfa.KeyframeAnim(this, [ad.current, a => a.state.scale(1, 1).move(0, 0)], duration);
    }
    pan(x, y, duration = 1000) {
        return new kfa.KeyframeAnim(this, [ad.current,
            ad.moveRelative(-x, -y)], duration);
    }
    panTo(x, y, duration = 1000) {
        return new kfa.KeyframeAnim(this, [ad.current, ad.move(x, y)], duration);
    }
}
exports.AnimatedView = AnimatedView;
function animatedView(parent) {
    return new AnimatedView(parent);
}
exports.animatedView = animatedView;
//# sourceMappingURL=animated-view.js.map

/***/ }),

/***/ "./node_modules/taitto/lib/anim/animated.js":
/*!**************************************************!*\
  !*** ./node_modules/taitto/lib/anim/animated.js ***!
  \**************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.bounceDown = exports.bounceUp = exports.bounceRight = exports.bounceLeft = exports.wobbleXY = exports.wobbleY = exports.wobbleX = exports.scaleXY = exports.scaleY = exports.scaleX = exports.shiftDown = exports.shiftUp = exports.shiftRight = exports.shiftLeft = exports.shift = exports.moveRelative = exports.move = exports.normalSize = exports.zeroSize = exports.current = exports.reset = exports.offset = exports.animated = exports.Animated = exports.AnimState = void 0;
/**
 * # Animating SVG Elements
 */
const el = __importStar(__webpack_require__(/*! ../svg/elem */ "./node_modules/taitto/lib/svg/elem.js"));
const vec = __importStar(__webpack_require__(/*! ../svg/vector */ "./node_modules/taitto/lib/svg/vector.js"));
class AnimState {
    constructor(scaling, rotation, position, shift) {
        this.scaling = scaling;
        this.rotation = rotation;
        this.position = position;
        this.shift = shift;
    }
    scale(x, y) {
        return new AnimState([x, y], this.rotation, this.position, this.shift);
    }
    rotate(angle) {
        return new AnimState(this.scaling, angle, this.position, this.shift);
    }
    move(x, y) {
        return new AnimState(this.scaling, this.rotation, [x, y], this.shift);
    }
    moveRelative(dx, dy) {
        let [x, y] = this.position;
        return new AnimState(this.scaling, this.rotation, [x + dx, y + dy], this.shift);
    }
    shiftPosition(x, y) {
        return new AnimState(this.scaling, this.rotation, this.position, [x, y]);
    }
    get matrix() {
        let [sx, sy] = this.scaling;
        let [x, y] = vec.addVec(this.position, this.shift);
        return new DOMMatrix()
            .scale(sx, sy)
            .rotate(0, 0, this.rotation)
            .translate(x, y);
    }
    toKeyframe() {
        let [sx, sy] = this.scaling;
        let [x, y] = vec.addVec(this.position, this.shift);
        return {
            transform: `rotateZ(${this.rotation}deg) ` +
                `translate3d(${x}px, ${y}px, 0) ` +
                `scale3d(${sx}, ${sy}, 1)`,
            offset: this.offset
        };
    }
}
exports.AnimState = AnimState;
AnimState.zero = new AnimState(vec.oneVector, 0, vec.zeroVector, vec.zeroVector);
class Animated extends el.GraphElem {
    constructor(parent) {
        super(document.createElementNS(el.ns, 'g'), parent);
        this.state = AnimState.zero;
        this.styles({
            transformOrigin: 'center',
            transformBox: 'fill-box'
        });
    }
    get animatedBBox() {
        return this.bbox.transform(this.state.matrix);
    }
    position(pos) {
        let [x, y] = pos;
        this.state = this.state.move(x, y);
        return this;
    }
}
exports.Animated = Animated;
function animated(parent) {
    return new Animated(parent instanceof el.Elem ? parent.element : parent);
}
exports.animated = animated;
function offset(getState, offset) {
    return a => {
        let state = getState(a);
        state.offset = offset;
        return state;
    };
}
exports.offset = offset;
const reset = a => new AnimState([1, 1], 0, [0, 0], [0, 0]);
exports.reset = reset;
const current = a => a.state;
exports.current = current;
const zeroSize = a => a.state.scale(0, 0);
exports.zeroSize = zeroSize;
const normalSize = a => a.state.scale(1, 1);
exports.normalSize = normalSize;
function move(x, y) {
    return a => a.state.move(x, y);
}
exports.move = move;
function moveRelative(x, y) {
    return a => a.state.moveRelative(x, y);
}
exports.moveRelative = moveRelative;
function shift(x, y) {
    return a => a.state.shiftPosition(x, y);
}
exports.shift = shift;
function shiftLeft(dist) {
    return a => a.state.shiftPosition(-dist * 100, 0);
}
exports.shiftLeft = shiftLeft;
function shiftRight(dist) {
    return a => a.state.shiftPosition(dist * 100, 0);
}
exports.shiftRight = shiftRight;
function shiftUp(dist) {
    return a => a.state.shiftPosition(0, -dist * 100);
}
exports.shiftUp = shiftUp;
function shiftDown(dist) {
    return a => a.state.shiftPosition(0, dist * 100);
}
exports.shiftDown = shiftDown;
function scaleX(scale) {
    return a => a.state.scale(scale, 1);
}
exports.scaleX = scaleX;
function scaleY(scale) {
    return a => a.state.scale(1, scale);
}
exports.scaleY = scaleY;
function scaleXY(scale) {
    return a => a.state.scale(scale, scale);
}
exports.scaleXY = scaleXY;
function* pulsate(times, amplitude) {
    times *= 2;
    for (let i = 0; i < times; i++)
        yield i % 2 == 1 ? 1 : (1 - amplitude) + ((i / times) * amplitude);
}
function pulsateTransform(times, amplitude, transform) {
    return Array.from(pulsate(times, amplitude)).map(transform);
}
function oneMinus(transform) {
    return scale => transform(1 - scale);
}
function createPulsator(transform) {
    return (times = 5, amplitude = times / 10) => pulsateTransform(times, amplitude, transform);
}
exports.wobbleX = createPulsator(scaleX);
exports.wobbleY = createPulsator(scaleY);
exports.wobbleXY = createPulsator(scaleXY);
exports.bounceLeft = createPulsator(oneMinus(shiftLeft));
exports.bounceRight = createPulsator(oneMinus(shiftRight));
exports.bounceUp = createPulsator(oneMinus(shiftUp));
exports.bounceDown = createPulsator(oneMinus(shiftDown));
//# sourceMappingURL=animated.js.map

/***/ }),

/***/ "./node_modules/taitto/lib/anim/custom-anim.js":
/*!*****************************************************!*\
  !*** ./node_modules/taitto/lib/anim/custom-anim.js ***!
  \*****************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.customAnim = exports.CustomAnim = void 0;
const an = __importStar(__webpack_require__(/*! ./anim */ "./node_modules/taitto/lib/anim/anim.js"));
class CustomAnim extends an.Anim {
    constructor(target, action, duration = 1000) {
        super(target, duration);
        this.action = action;
    }
    run(resolve) {
        this.action(this);
        resolve(this);
    }
}
exports.CustomAnim = CustomAnim;
function customAnim(target, action, duration = 1000) {
    return new CustomAnim(target, action, duration);
}
exports.customAnim = customAnim;
//# sourceMappingURL=custom-anim.js.map

/***/ }),

/***/ "./node_modules/taitto/lib/anim/index.js":
/*!***********************************************!*\
  !*** ./node_modules/taitto/lib/anim/index.js ***!
  \***********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
__exportStar(__webpack_require__(/*! ./animated */ "./node_modules/taitto/lib/anim/animated.js"), exports);
__exportStar(__webpack_require__(/*! ./anim */ "./node_modules/taitto/lib/anim/anim.js"), exports);
__exportStar(__webpack_require__(/*! ./keyframe-anim */ "./node_modules/taitto/lib/anim/keyframe-anim.js"), exports);
__exportStar(__webpack_require__(/*! ./custom-anim */ "./node_modules/taitto/lib/anim/custom-anim.js"), exports);
__exportStar(__webpack_require__(/*! ./animated-view */ "./node_modules/taitto/lib/anim/animated-view.js"), exports);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/taitto/lib/anim/keyframe-anim.js":
/*!*******************************************************!*\
  !*** ./node_modules/taitto/lib/anim/keyframe-anim.js ***!
  \*******************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.spreadAround = exports.fadeInOut = exports.fadeOut = exports.fadeIn = exports.zoomIn = exports.slideOutBottom = exports.slideOutTop = exports.slideOutRight = exports.slideOutLeft = exports.slideInBottom = exports.slideInTop = exports.slideInRight = exports.slideInLeft = exports.slideTo = exports.visible = exports.invisible = exports.KeyframeAnim = void 0;
const ad = __importStar(__webpack_require__(/*! ./animated */ "./node_modules/taitto/lib/anim/animated.js"));
const an = __importStar(__webpack_require__(/*! ./anim */ "./node_modules/taitto/lib/anim/anim.js"));
class KeyframeAnim extends an.Anim {
    constructor(target, keyframes, duration = 1000, fill = "both", direction = "normal", iterations = 1) {
        super(target, duration);
        this.keyframes = keyframes;
        this.fill = fill;
        this.direction = direction;
        this.iterations = iterations;
    }
    stopOn(event) {
        this.stopEvent = event;
        return this;
    }
    getKeyframe(kf) {
        if (typeof kf === 'function') {
            if (!(this.target instanceof ad.Animated))
                throw Error("Target not of type Animated");
            let state = kf(this.target);
            this.target.state = state;
            return state.toKeyframe();
        }
        return kf;
    }
    run(resolve) {
        let a = this.target.element.animate(this.keyframes.map(kf => this.getKeyframe(kf)), {
            duration: this.duration,
            fill: this.fill,
            direction: this.direction,
            iterations: this.iterations
        });
        a.onfinish = () => resolve(this);
        a.oncancel = () => resolve(this);
        if (this.stopEvent)
            this.target.element.addEventListener(this.stopEvent, () => a.cancel());
    }
}
exports.KeyframeAnim = KeyframeAnim;
function invisible() { return { opacity: 0 }; }
exports.invisible = invisible;
function visible() { return { opacity: 1 }; }
exports.visible = visible;
function slideTo(elem, pos, duration = 1000) {
    let [x, y] = pos;
    return new KeyframeAnim(elem, [ad.current, ad.move(x, y)], duration);
}
exports.slideTo = slideTo;
function createSlideIn(move, bounce) {
    return (elem, distance = 1, duration = 1000) => {
        let kfs = [move(distance), move(0)].concat(bounce(2));
        kfs[1] = ad.offset(kfs[1], 0.5 + Math.min(duration / 10000, 0.5));
        return new KeyframeAnim(elem, kfs, duration);
    };
}
function createSlideOut(move) {
    return (elem, distance = 1, duration = 1000) => {
        let kfs = ([move(0), move(-distance / 20), move(distance)]);
        kfs[1] = ad.offset(kfs[1], 0.2);
        return new KeyframeAnim(elem, kfs, duration);
    };
}
exports.slideInLeft = createSlideIn(ad.shiftLeft, ad.bounceLeft);
exports.slideInRight = createSlideIn(ad.shiftRight, ad.bounceRight);
exports.slideInTop = createSlideIn(ad.shiftUp, ad.bounceUp);
exports.slideInBottom = createSlideIn(ad.shiftDown, ad.bounceDown);
exports.slideOutLeft = createSlideOut(ad.shiftLeft);
exports.slideOutRight = createSlideOut(ad.shiftRight);
exports.slideOutTop = createSlideOut(ad.shiftUp);
exports.slideOutBottom = createSlideOut(ad.shiftDown);
function zoomIn(elem, duration = 1000) {
    let kfs = [ad.scaleXY(0), ad.scaleXY(1)].concat(ad.wobbleXY(2));
    kfs[1] = ad.offset(kfs[1], 0.5 + Math.min(duration / 10000, 0.5));
    return new KeyframeAnim(elem, kfs, duration);
}
exports.zoomIn = zoomIn;
function fadeIn(elem, duration = 1000) {
    return new KeyframeAnim(elem, [invisible(), visible()], duration);
}
exports.fadeIn = fadeIn;
function fadeOut(elem, duration = 1000) {
    return new KeyframeAnim(elem, [visible(), invisible()], duration);
}
exports.fadeOut = fadeOut;
function fadeInOut(elem, duration = 1000, iterations = 1) {
    return new KeyframeAnim(elem, [invisible(), visible()], duration, "auto", "alternate", iterations * 2);
}
exports.fadeInOut = fadeInOut;
function semiCirclePositions(count, radius) {
    let res = new Array(count);
    let angle = Math.PI / (count + 1);
    for (let i = 0; i < count; i++) {
        let x = -Math.cos((i + 1) * angle) * radius;
        let y = -Math.sin((i + 1) * angle) * radius;
        res[i] = [x, y];
    }
    return res;
}
function spreadAround(elems, radius, duration) {
    let pos = semiCirclePositions(elems.length, radius);
    return elems.map((e, i) => {
        let [x, y] = pos[i];
        return new KeyframeAnim(e, [ad.moveRelative(0, 0), ad.moveRelative(x, y)], duration);
    });
}
exports.spreadAround = spreadAround;
//# sourceMappingURL=keyframe-anim.js.map

/***/ }),

/***/ "./node_modules/taitto/lib/digraph.js":
/*!********************************************!*\
  !*** ./node_modules/taitto/lib/digraph.js ***!
  \********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.digraph = exports.edges = exports.nodes = exports.ArrowPos = void 0;
const svg = __importStar(__webpack_require__(/*! ./svg */ "./node_modules/taitto/lib/svg/index.js"));
const anim = __importStar(__webpack_require__(/*! ./anim */ "./node_modules/taitto/lib/anim/index.js"));
const dagre = __importStar(__webpack_require__(/*! dagre */ "./node_modules/dagre/index.js"));
var ArrowPos;
(function (ArrowPos) {
    ArrowPos[ArrowPos["Source"] = 0] = "Source";
    ArrowPos[ArrowPos["Destination"] = 1] = "Destination";
})(ArrowPos = exports.ArrowPos || (exports.ArrowPos = {}));
const defaultNodesep = 16;
const defaultRanksep = 16;
function nodes(...nodes) {
    return nodes.map(n => {
        return typeof (n) == 'string' ?
            { name: n, label: n } :
            { name: n[0], label: n[1] };
    });
}
exports.nodes = nodes;
function edges(edges, arrow) {
    return edges.map(e => {
        return e.length < 3 ?
            { arrow, source: e[0], destination: e[1] } :
            { arrow, source: e[0], destination: e[1], label: e[2] };
    });
}
exports.edges = edges;
function drawNode(node, parent, margin = 10) {
    let group = svg.group(parent);
    let p = node.link ? svg.link(group, node.link) : group;
    let text = svg.text(p, node.label);
    let bb = text.bbox.inflate(margin, margin);
    let shape = node.shape || svg.rect;
    shape(p, bb.left, bb.top, bb.width, bb.height).moveToBack();
    group.translate(svg.RectPos.Center);
    node.elem = group.addClass("node");
}
function drawEdgeLabel(edge, parent) {
    let text = svg.text(parent, edge.label);
    text.translate(svg.RectPos.Center);
    edge.elem = text.addClass("edgelabel");
}
function addArrow(arrow, svgroot, path) {
    if (!arrow.elem)
        arrow.elem = svg.arrow(svgroot.child('defs'), arrow.width, arrow.length, arrow.closed).addClass(arrow.className);
    if (arrow.positions.includes(ArrowPos.Source))
        svg.setMarker(path, arrow.elem, svg.MarkerPos.Start);
    if (arrow.positions.includes(ArrowPos.Destination))
        svg.setMarker(path, arrow.elem, svg.MarkerPos.End);
}
function dist(pt1, pt2) {
    let dx = pt1.x - pt2.x;
    let dy = pt1.y - pt2.y;
    return Math.sqrt(dx * dx + dy * dy);
}
function drawEdge(edge, svgroot, parent, arrow, curvedEdges, ranksep) {
    let p = edge.points;
    let cmds = [new svg.MoveTo('M', p[0].x, p[0].y)];
    let len = p.length;
    let i = 1;
    while (i < len)
        if (!curvedEdges ||
            (len <= 3 && (i == len - 1 || dist(p[i], p[i + 1]) < ranksep))) {
            cmds.push(new svg.LineTo('L', p[i].x, p[i].y));
            i++;
        }
        else if (i < len - 1) {
            cmds.push(new svg.ContCubicCurveTo('S', p[i].x, p[i].y, p[i + 1].x, p[i + 1].y));
            i += 2;
        }
        else {
            cmds.push(new svg.ContQuadCurveTo('T', p[i].x, p[i].y));
            i++;
        }
    let res = svg.path(parent, cmds).addClass("edge");
    if (arrow)
        addArrow(arrow, svgroot, res);
    return res.moveToBack();
}
function defineDigraph(digraph, svgroot, viewport, dg) {
    digraph.nodes.forEach(node => {
        drawNode(node, viewport, digraph.nodeMargin);
        let bbox = node.elem.bbox;
        dg.setNode(node.name, {
            label: node.label,
            width: bbox.width,
            height: bbox.height
        });
    });
    digraph.edges.forEach(edge => {
        if (edge.label) {
            drawEdgeLabel(edge, viewport);
            let { width, height } = edge.elem.bbox;
            dg.setEdge(edge.source.name, edge.destination.name, {
                label: edge.label,
                labelpos: digraph.edgeLabelPos || 'r',
                width, height
            });
        }
        else
            dg.setEdge(edge.source.name, edge.destination.name);
    });
}
function layoutDigraph(digraph, svgroot, viewport, dg) {
    digraph.nodes.forEach(node => {
        let dn = dg.node(node.name);
        let e = node.elem;
        e.transform = e.transform.translate(dn.x, dn.y);
    });
    digraph.edges.forEach(edge => {
        let de = dg.edge(edge.source.name, edge.destination.name);
        drawEdge(de, svgroot, viewport, edge.arrow, digraph.curvedEdges, digraph.ranksep || defaultRanksep);
        let e = edge.elem;
        if (e)
            e.transform = e.transform.translate(de.x, de.y);
    });
}
function createDigraph(digraph, parent) {
    let svgroot = svg.create('svg', parent).addClass("digraph")
        .styles({ cursor: "zoom-in" });
    svg.defs(svgroot);
    let graph = new dagre.graphlib.Graph();
    graph.setGraph({
        rankdir: digraph.direction || 'TB',
        nodesep: digraph.nodesep || defaultNodesep,
        ranksep: digraph.ranksep || defaultRanksep
    });
    graph.setDefaultEdgeLabel((v, w) => { return {}; });
    let viewport = anim.animatedView(svgroot).styles({ cursor: "zoom-in" });
    defineDigraph(digraph, svgroot, viewport, graph);
    dagre.layout(graph);
    layoutDigraph(digraph, svgroot, viewport, graph);
    svg.setBounds(svgroot, digraph.margin || 10);
    return svgroot.clicked(e => zoomInOut(svgroot, viewport, e));
}
let zoomed = false;
const zoomSpeed = 300;
function zoomInOut(svgroot, viewport, event) {
    let zoomAnim = null;
    if (!zoomed) {
        let s = svgroot.element;
        let pt = s.createSVGPoint();
        pt.x = event.clientX;
        pt.y = event.clientY;
        let { x, y } = pt.matrixTransform(s.getScreenCTM().inverse());
        zoomAnim = viewport.zoomFactor(2, x, y, zoomSpeed);
    }
    else
        zoomAnim = viewport.zoomHome(zoomSpeed);
    zoomed = !zoomed;
    svgroot.styles({ cursor: zoomed ? "zoom-out" : "zoom-in" });
    new anim.AnimSequence().addAt(zoomAnim, 0).play();
}
function digraph(dg, parent) {
    let svgroot = null;
    if (!document.fonts || document.fonts.status == "loaded")
        svgroot = createDigraph(dg, parent);
    else
        document.fonts.onloadingdone = () => {
            if (svgroot)
                svgroot.delete();
            svgroot = createDigraph(dg, parent);
        };
}
exports.digraph = digraph;
//# sourceMappingURL=digraph.js.map

/***/ }),

/***/ "./node_modules/taitto/lib/file-diagram.js":
/*!*************************************************!*\
  !*** ./node_modules/taitto/lib/file-diagram.js ***!
  \*************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.fileDiagram = exports.terminal = exports.file = exports.folder = exports.terminalDimensions = exports.fileDimensions = exports.folderDimensions = void 0;
const svg = __importStar(__webpack_require__(/*! ./svg */ "./node_modules/taitto/lib/svg/index.js"));
const anim = __importStar(__webpack_require__(/*! ./anim */ "./node_modules/taitto/lib/anim/index.js"));
exports.folderDimensions = {
    width: 80,
    height: 60,
    radius: 4
};
exports.fileDimensions = {
    width: 60,
    height: 80,
    radius: 4
};
exports.terminalDimensions = {
    width: 100,
    height: 80,
    radius: 4
};
function container3D(parent) {
    return svg.group(parent).addClass("container3D");
}
function iconRect(parent, dims) {
    let x = dims.width / 2;
    let y = dims.height / 2;
    return svg.rect(parent, -x, -y, dims.width, dims.height, dims.radius);
}
function folder(parent, caption, dims = exports.folderDimensions) {
    let res = container3D(parent);
    let back = svg.group(res).addClass("folder-back");
    iconRect(back, dims);
    let x = dims.width / 2;
    let y = dims.height / 2;
    let tw = 0.30 * dims.width;
    let th = 0.25 * dims.height;
    svg.rect(back, -x, -y - (th / 2), tw, th, dims.radius);
    let front = svg.group(res).addClass("folder-front")
        .styles({
        transformOrigin: `${x}px ${y}px`
    });
    iconRect(front, dims);
    svg.text(front, caption).translate(svg.RectPos.Center);
    let kfs = [
        { transform: 'rotateX(0deg)' },
        { transform: 'rotateX(30deg)' }
    ];
    res.open = new anim.KeyframeAnim(front, kfs, 200);
    res.close = new anim.KeyframeAnim(front, kfs.slice().reverse(), 200);
    return res;
}
exports.folder = folder;
function docLines(dims) {
    let w = dims.width - 20;
    let h = dims.height - 20;
    let res = [];
    for (let y = 0; y < h; y += 5) {
        if (Math.random() > 0.2) {
            res.push(new svg.MoveTo("M", 0, y));
            res.push(new svg.HLineTo("h", w - (Math.random() * 5)));
        }
    }
    return res;
}
function file(parent, typeStr, caption, dims = exports.fileDimensions) {
    let container = container3D(parent);
    let doc = svg.group(container).addClass("document");
    let mask = svg.mask(doc);
    iconRect(mask, dims).attrs({
        fill: "white",
        stroke: "white"
    });
    let mw = dims.width / 2;
    let mh = dims.height / 2;
    let fsize = mw / 2;
    svg.path(mask, `M0 -1 h${mw} v${mw} z`).attrs({
        transform: `translate(${fsize} ${-mh})`,
        fill: "black",
        stroke: "black"
    });
    let group = svg.group(doc).attrs({
        mask: `url(#${mask.id})`
    });
    iconRect(group, dims);
    svg.path(group, docLines(dims)).attrs({
        "stroke-width": 2
    })
        .translate(svg.RectPos.Center);
    svg.text(group, typeStr).addClass("doc-bg");
    svg.rect(group, fsize, -mh, fsize, fsize, dims.radius / 2);
    svg.text(doc, caption).addClass("doc-text")
        .translate(svg.RectPos.Center, [0, fsize]);
    return container;
}
exports.file = file;
function titleButton(parent, x, y, th) {
    let bd = th / 2;
    let br = th / 4;
    return svg.ellipse(parent, x - bd, -y + bd, br, br);
}
function terminal(parent, caption, dims = exports.terminalDimensions) {
    let container = container3D(parent);
    let term = svg.group(container).addClass("terminal");
    iconRect(term, dims);
    let x = dims.width / 2;
    let y = dims.height / 2;
    let th = dims.height / 8;
    svg.rect(term, -x, -y, dims.width, th, dims.radius / 2)
        .addClass("title-bar");
    let sp = th * 0.75;
    titleButton(term, x, y, th);
    titleButton(term, x - sp, y, th);
    titleButton(term, x - (sp * 2), y, th);
    caption = ">" + caption + "_";
    let text = svg.text(term, caption).addClass("terminal-text")
        .translate(svg.RectPos.Center);
    container.setCaption = value => Array.from({ length: value.length + 1 })
        .map((_, i) => anim.customAnim(text, a => a.target.text = ">" + value.slice(0, i) + "_", 0));
    return container;
}
exports.terminal = terminal;
function fileDiagram(parent, width, height) {
    let vb = new svg.Rect(0, 0, width, height);
    let res = svg.create('svg', parent).addClass("file-diagram").attrs({ width: vb.width, height: vb.height });
    svg.setViewBox(res, vb);
    return res;
}
exports.fileDiagram = fileDiagram;
//# sourceMappingURL=file-diagram.js.map

/***/ }),

/***/ "./node_modules/taitto/lib/index.js":
/*!******************************************!*\
  !*** ./node_modules/taitto/lib/index.js ***!
  \******************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.anim = exports.svg = void 0;
const svg = __importStar(__webpack_require__(/*! ./svg */ "./node_modules/taitto/lib/svg/index.js"));
exports.svg = svg;
const anim = __importStar(__webpack_require__(/*! ./anim */ "./node_modules/taitto/lib/anim/index.js"));
exports.anim = anim;
__exportStar(__webpack_require__(/*! ./digraph */ "./node_modules/taitto/lib/digraph.js"), exports);
__exportStar(__webpack_require__(/*! ./file-diagram */ "./node_modules/taitto/lib/file-diagram.js"), exports);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/taitto/lib/svg/elem.js":
/*!*********************************************!*\
  !*** ./node_modules/taitto/lib/svg/elem.js ***!
  \*********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.link = exports.mask = exports.polygon = exports.polyline = exports.path = exports.ellipse = exports.circle = exports.rect = exports.tspan = exports.text = exports.group = exports.css = exports.setViewBox = exports.getViewBox = exports.setBounds = exports.defs = exports.create = exports.GraphElem = exports.Elem = exports.xlink = exports.ns = void 0;
const rt = __importStar(__webpack_require__(/*! ./rect */ "./node_modules/taitto/lib/svg/rect.js"));
exports.ns = 'http://www.w3.org/2000/svg';
exports.xlink = 'http://www.w3.org/1999/xlink';
var lastGenId = 0;
class Elem {
    constructor(elem, parent) {
        this.elem = elem;
        parent.appendChild(this.elem);
    }
    get element() {
        return this.elem;
    }
    get id() {
        return this.elem.id;
    }
    set id(value) {
        this.elem.id = value;
    }
    get parent() {
        return this.elem.parentElement;
    }
    get classes() {
        return this.elem.classList;
    }
    get style() {
        return this.elem.style;
    }
    get text() {
        return this.elem.textContent;
    }
    set text(content) {
        this.elem.textContent = content;
    }
    addClass(name) {
        this.elem.classList.add(name);
        return this;
    }
    removeClass(name) {
        this.elem.classList.remove(name);
        return this;
    }
    toggleClass(name) {
        this.elem.classList.toggle(name);
        return this;
    }
    attr(name) {
        return this.elem.getAttribute(name);
    }
    attrs(obj, namespace = null) {
        for (const key in obj)
            if (obj.hasOwnProperty(key)) {
                let val = obj[key];
                if (val instanceof Array)
                    val = val.join(" ");
                this.elem.setAttributeNS(namespace, key, val);
            }
        return this;
    }
    child(tag) {
        let el = this.elem.querySelector(tag);
        return (el instanceof SVGGraphicsElement ? new GraphElem(el, this.elem) :
            el instanceof SVGElement ? new Elem(el, this.elem) :
                null);
    }
    styles(obj) {
        for (const key in obj)
            if (obj.hasOwnProperty(key))
                this.elem.style[key] = obj[key];
        return this;
    }
    delete() {
        this.elem.parentElement.removeChild(this.elem);
    }
    deleteChildren() {
        while (this.elem.firstChild)
            this.elem.removeChild(this.elem.firstChild);
    }
    moveUnder(parent) {
        parent.elem.appendChild(this.elem);
    }
    moveToBack() {
        let parent = this.elem.parentElement;
        parent.insertBefore(this.elem, parent.children[0]);
        return this;
    }
    moveToFront() {
        this.elem.parentElement.appendChild(this.elem);
        return this;
    }
}
exports.Elem = Elem;
class GraphElem extends Elem {
    get bbox() {
        return rt.Rect.fromDOMRect(this.elem.getBBox({ stroke: true }));
    }
    get transform() {
        return this.elem.getCTM();
    }
    set transform(mat) {
        let tr = this.elem.ownerSVGElement.createSVGTransformFromMatrix(mat);
        this.elem.transform.baseVal.initialize(tr);
    }
    hide() {
        this.styles({ opacity: '0' });
        return this;
    }
    show() {
        this.styles({ opacity: '1' });
        return this;
    }
    translate(pos, to = [0, 0]) {
        this.transform = this.bbox.translateTo(this.transform, pos, to);
        return this;
    }
    clicked(handler) {
        this.elem.onclick = handler;
        return this;
    }
    mouseover(handler) {
        this.elem.onmouseover = handler;
        return this;
    }
    mousemove(handler) {
        this.elem.onmousemove = handler;
        return this;
    }
}
exports.GraphElem = GraphElem;
function create(tag, parent) {
    let e = document.createElementNS(exports.ns, tag);
    let p = parent instanceof Elem ? parent.element : parent;
    return (e instanceof SVGGraphicsElement ?
        new GraphElem(e, p) : new Elem(e, p));
}
exports.create = create;
function defs(svgroot) {
    return create('defs', svgroot);
}
exports.defs = defs;
function setBounds(svgroot, hmargin, vmargin = hmargin) {
    let vb = svgroot.bbox.inflate(hmargin, vmargin);
    setViewBox(svgroot, vb);
    svgroot.attrs({ width: vb.width, height: vb.height });
}
exports.setBounds = setBounds;
function getViewBox(elem) {
    return rt.Rect.fromDOMRect(elem.element.viewBox.baseVal);
}
exports.getViewBox = getViewBox;
function setViewBox(elem, viewBox) {
    let { left, top, width, height } = viewBox;
    elem.attrs({ viewBox: `${left} ${top} ${width} ${height}` });
}
exports.setViewBox = setViewBox;
function css(parent) {
    return parent.child('style') || create('style', parent);
}
exports.css = css;
function group(parent) {
    return create('g', parent);
}
exports.group = group;
function text(parent, caption) {
    let res = create('text', parent);
    if (caption)
        res.text = caption;
    return res;
}
exports.text = text;
function tspan(parent, caption) {
    let res = create('tspan', parent);
    if (caption)
        res.text = caption;
    return res;
}
exports.tspan = tspan;
function rect(parent, x, y, width, height, rx = 0, ry = rx) {
    return create('rect', parent).attrs({ x, y, width, height, rx, ry });
}
exports.rect = rect;
function circle(parent, cx, cy, r) {
    return create('circle', parent).attrs({ cx, cy, r });
}
exports.circle = circle;
function ellipse(parent, cx, cy, rx, ry) {
    return create('ellipse', parent).attrs({ cx, cy, rx, ry });
}
exports.ellipse = ellipse;
function path(parent, commands) {
    return create('path', parent).attrs({
        d: typeof commands === 'string' ? commands : commands.join(' ')
    });
}
exports.path = path;
function polyline(parent, points) {
    return create('polyline', parent).attrs({ points: points.join(' ') });
}
exports.polyline = polyline;
function polygon(parent, points) {
    return create('polygon', parent).attrs({ points: points.join(' ') });
}
exports.polygon = polygon;
function mask(parent) {
    let res = create("mask", parent);
    res.id = "mask" + (++lastGenId);
    return res;
}
exports.mask = mask;
function link(parent, href) {
    return create('a', parent).attrs({ href }, exports.xlink);
}
exports.link = link;
//# sourceMappingURL=elem.js.map

/***/ }),

/***/ "./node_modules/taitto/lib/svg/filter.js":
/*!***********************************************!*\
  !*** ./node_modules/taitto/lib/svg/filter.js ***!
  \***********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.shadow = exports.setFilter = exports.filter = void 0;
const el = __importStar(__webpack_require__(/*! ./elem */ "./node_modules/taitto/lib/svg/elem.js"));
var lastId = 0;
function filter(parent, id) {
    return el.create('filter', parent).attrs({ id });
}
exports.filter = filter;
function setFilter(elem, filter) {
    elem.attrs({ filter: `url(#${typeof filter === 'string' ?
            filter : filter.id})` });
    return elem;
}
exports.setFilter = setFilter;
function shadow(parent, dx, dy = dx, stdDeviation = dx) {
    let res = filter(parent, "filter" + ++lastId);
    el.create('feOffset', res).attrs({
        result: 'offOut', in: 'sourceGraphic', dx: 4, dy: 4
    });
    el.create('feBlend', res).attrs({
        in: 'sourceGraphic', in2: 'offOut', mode: 'normal'
    });
    return res;
}
exports.shadow = shadow;
//# sourceMappingURL=filter.js.map

/***/ }),

/***/ "./node_modules/taitto/lib/svg/index.js":
/*!**********************************************!*\
  !*** ./node_modules/taitto/lib/svg/index.js ***!
  \**********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
__exportStar(__webpack_require__(/*! ./vector */ "./node_modules/taitto/lib/svg/vector.js"), exports);
__exportStar(__webpack_require__(/*! ./rect */ "./node_modules/taitto/lib/svg/rect.js"), exports);
__exportStar(__webpack_require__(/*! ./path */ "./node_modules/taitto/lib/svg/path.js"), exports);
__exportStar(__webpack_require__(/*! ./elem */ "./node_modules/taitto/lib/svg/elem.js"), exports);
__exportStar(__webpack_require__(/*! ./marker */ "./node_modules/taitto/lib/svg/marker.js"), exports);
__exportStar(__webpack_require__(/*! ./filter */ "./node_modules/taitto/lib/svg/filter.js"), exports);
__exportStar(__webpack_require__(/*! ./text */ "./node_modules/taitto/lib/svg/text.js"), exports);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/taitto/lib/svg/marker.js":
/*!***********************************************!*\
  !*** ./node_modules/taitto/lib/svg/marker.js ***!
  \***********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.arrow = exports.setMarker = exports.marker = exports.MarkerPos = void 0;
const el = __importStar(__webpack_require__(/*! ./elem */ "./node_modules/taitto/lib/svg/elem.js"));
var MarkerPos;
(function (MarkerPos) {
    MarkerPos[MarkerPos["Start"] = 0] = "Start";
    MarkerPos[MarkerPos["Mid"] = 1] = "Mid";
    MarkerPos[MarkerPos["End"] = 2] = "End";
})(MarkerPos = exports.MarkerPos || (exports.MarkerPos = {}));
var lastId = 0;
function marker(parent, id) {
    return el.create('marker', parent).attrs({ id });
}
exports.marker = marker;
function setMarker(elem, marker, pos) {
    let markerUrl = `url(#${typeof marker === 'string' ? marker : marker.id})`;
    switch (pos) {
        case MarkerPos.Start:
            return elem.attrs({ "marker-start": markerUrl });
        case MarkerPos.Mid:
            return elem.attrs({ "marker-mid": markerUrl });
        case MarkerPos.End:
            return elem.attrs({ "marker-end": markerUrl });
    }
    return elem;
}
exports.setMarker = setMarker;
function arrow(parent, width, length = width, closed = true) {
    let res = marker(parent, "arrow" + ++lastId).attrs({
        viewBox: "-1 -1 12 12",
        refX: 10, refY: 5,
        orient: "auto-start-reverse",
        markerWidth: length, markerHeight: width,
        preserveAspectRatio: "none"
    });
    el.path(res, "M 0 0 L 10 5 L 0 10" + (closed ? " z" : ""));
    return res;
}
exports.arrow = arrow;
//# sourceMappingURL=marker.js.map

/***/ }),

/***/ "./node_modules/taitto/lib/svg/path.js":
/*!*********************************************!*\
  !*** ./node_modules/taitto/lib/svg/path.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ClosePath = exports.ArcTo = exports.Sweep = exports.Arc = exports.ContQuadCurveTo = exports.QuadCurveTo = exports.ContCubicCurveTo = exports.CubicCurveTo = exports.VLineTo = exports.HLineTo = exports.LineTo = exports.MoveTo = void 0;
class MoveTo {
    constructor(command, x, y) {
        this.command = command;
        this.x = x;
        this.y = y;
        this.toString = () => `${this.command}${this.x} ${this.y}`;
    }
}
exports.MoveTo = MoveTo;
class LineTo {
    constructor(command, x, y) {
        this.command = command;
        this.x = x;
        this.y = y;
        this.toString = () => `${this.command}${this.x} ${this.y}`;
    }
}
exports.LineTo = LineTo;
class HLineTo {
    constructor(command, x) {
        this.command = command;
        this.x = x;
        this.toString = () => `${this.command}${this.x}`;
    }
}
exports.HLineTo = HLineTo;
class VLineTo {
    constructor(command, y) {
        this.command = command;
        this.y = y;
        this.toString = () => `${this.command}${this.y}`;
    }
}
exports.VLineTo = VLineTo;
class CubicCurveTo {
    constructor(command, x1, y1, x2, y2, x, y) {
        this.command = command;
        this.x1 = x1;
        this.y1 = y1;
        this.x2 = x2;
        this.y2 = y2;
        this.x = x;
        this.y = y;
        this.toString = () => `${this.command}${this.x1} ${this.y1} ${this.x2} ${this.y2} ${this.x} ${this.y}`;
    }
}
exports.CubicCurveTo = CubicCurveTo;
class ContCubicCurveTo {
    constructor(command, x2, y2, x, y) {
        this.command = command;
        this.x2 = x2;
        this.y2 = y2;
        this.x = x;
        this.y = y;
        this.toString = () => `${this.command}${this.x2} ${this.y2} ${this.x} ${this.y}`;
    }
}
exports.ContCubicCurveTo = ContCubicCurveTo;
class QuadCurveTo {
    constructor(command, x1, y1, x, y) {
        this.command = command;
        this.x1 = x1;
        this.y1 = y1;
        this.x = x;
        this.y = y;
        this.toString = () => `${this.command}${this.x1} ${this.y1} ${this.x} ${this.y}`;
    }
}
exports.QuadCurveTo = QuadCurveTo;
class ContQuadCurveTo {
    constructor(command, x, y) {
        this.command = command;
        this.x = x;
        this.y = y;
        this.toString = () => `${this.command}${this.x} ${this.y}`;
    }
}
exports.ContQuadCurveTo = ContQuadCurveTo;
var Arc;
(function (Arc) {
    Arc[Arc["Small"] = 0] = "Small";
    Arc[Arc["Large"] = 1] = "Large";
})(Arc = exports.Arc || (exports.Arc = {}));
var Sweep;
(function (Sweep) {
    Sweep[Sweep["CW"] = 0] = "CW";
    Sweep[Sweep["CCW"] = 1] = "CCW";
})(Sweep = exports.Sweep || (exports.Sweep = {}));
class ArcTo {
    constructor(command, rx, ry, rot, arc, sweep, x, y) {
        this.command = command;
        this.rx = rx;
        this.ry = ry;
        this.rot = rot;
        this.arc = arc;
        this.sweep = sweep;
        this.x = x;
        this.y = y;
        this.toString = () => `${this.command}${this.rx} ${this.ry} ${this.rot} ${this.arc} ${this.sweep} ${this.x} ${this.y}`;
    }
}
exports.ArcTo = ArcTo;
class ClosePath {
    constructor() {
        this.toString = () => this.command;
    }
}
exports.ClosePath = ClosePath;
//# sourceMappingURL=path.js.map

/***/ }),

/***/ "./node_modules/taitto/lib/svg/rect.js":
/*!*********************************************!*\
  !*** ./node_modules/taitto/lib/svg/rect.js ***!
  \*********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Rect = exports.RectPos = void 0;
const vec = __importStar(__webpack_require__(/*! ./vector */ "./node_modules/taitto/lib/svg/vector.js"));
var RectPos;
(function (RectPos) {
    RectPos[RectPos["Center"] = 0] = "Center";
    RectPos[RectPos["TopLeft"] = 1] = "TopLeft";
    RectPos[RectPos["TopRight"] = 2] = "TopRight";
    RectPos[RectPos["BottomLeft"] = 3] = "BottomLeft";
    RectPos[RectPos["BottomRight"] = 4] = "BottomRight";
})(RectPos = exports.RectPos || (exports.RectPos = {}));
/**
 * Defines a rectangle which covers area [left, right) along x-axis
 * and [top, bottom) along y-axis.
 */
class Rect {
    constructor(left, top, right, bottom) {
        this.left = left;
        this.top = top;
        this.right = right;
        this.bottom = bottom;
    }
    get width() {
        return this.right - this.left;
    }
    get height() {
        return this.bottom - this.top;
    }
    get centerX() {
        return this.left + (this.width / 2);
    }
    get centerY() {
        return this.top + (this.height / 2);
    }
    get isEmpty() {
        return this.width <= 0 || this.height <= 0;
    }
    containsPoint(x, y) {
        return x >= this.left && x < this.right &&
            y >= this.top && y < this.bottom;
    }
    rectPos(pos) {
        switch (pos) {
            case RectPos.Center: return [this.centerX, this.centerY];
            case RectPos.TopLeft: return [this.left, this.top];
            case RectPos.TopRight: return [this.right, this.top];
            case RectPos.BottomLeft: return [this.left, this.bottom];
            case RectPos.BottomRight: return [this.right, this.bottom];
        }
    }
    cornerPoints(closeLoop = false) {
        let res = [
            this.rectPos(RectPos.TopLeft),
            this.rectPos(RectPos.TopRight),
            this.rectPos(RectPos.BottomRight),
            this.rectPos(RectPos.BottomLeft)
        ];
        if (closeLoop)
            res.push(res[0]);
        return res;
    }
    containsRect(other) {
        return other.left >= this.left && other.right <= this.right &&
            other.top >= this.top && other.bottom <= this.bottom;
    }
    equals(other) {
        return this.left == other.left && this.top == other.top &&
            this.width == other.width && this.height == other.height;
    }
    inflate(dx, dy) {
        return new Rect(this.left - dx, this.top - dy, this.right + dx, this.bottom + dy);
    }
    intersect(other) {
        return new Rect(Math.max(this.left, other.left), Math.max(this.top, other.top), Math.min(this.right, other.right), Math.min(this.bottom, other.bottom));
    }
    intersectsWith(other) {
        return !this.intersect(other).isEmpty;
    }
    offset(dx, dy) {
        return new Rect(this.left + dx, this.top + dy, this.right + dx, this.bottom + dy);
    }
    translateTo(mat, pos, to = [0, 0]) {
        let [sx, sy] = pos instanceof Array ? pos : this.rectPos(pos);
        let [tx, ty] = to;
        return mat.translate(tx - sx, ty - sy);
    }
    transform(mat) {
        return Rect.fromPoints(this.cornerPoints().map(pt => {
            let [x, y] = pt;
            let tp = mat.transformPoint({ x, y });
            return [tp.x, tp.y];
        }));
    }
    union(other) {
        return new Rect(Math.min(this.left, other.left), Math.min(this.top, other.top), Math.max(this.right, other.right), Math.max(this.bottom, other.bottom));
    }
    static fromDOMRect(domRect) {
        return new Rect(domRect.x, domRect.y, domRect.x + domRect.width, domRect.y + domRect.height);
    }
    static fromPoints(points) {
        return new Rect(Math.min(...points.map(vec.vecX)), Math.min(...points.map(vec.vecY)), Math.max(...points.map(vec.vecX)), Math.max(...points.map(vec.vecY)));
    }
    static fromRects(rects) {
        return rects.reduce((r, c) => c.union(r));
    }
    static fromString(value) {
        let [left, top, width, height] = value.split(" ").map(Number);
        return new Rect(left, top, left + width, top + height);
    }
}
exports.Rect = Rect;
//# sourceMappingURL=rect.js.map

/***/ }),

/***/ "./node_modules/taitto/lib/svg/text.js":
/*!*********************************************!*\
  !*** ./node_modules/taitto/lib/svg/text.js ***!
  \*********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.changeWordWrapText = exports.wordWrapText = void 0;
const el = __importStar(__webpack_require__(/*! ./elem */ "./node_modules/taitto/lib/svg/elem.js"));
function wordWrapText(parent, x, y, wrapAfter, caption) {
    let text = el.text(parent).attrs({ x, y, "data-wrapAfter": wrapAfter });
    changeWordWrapText(text, caption);
    return text;
}
exports.wordWrapText = wordWrapText;
function changeWordWrapText(text, caption, x, wrapAfter) {
    text.deleteChildren();
    let words = caption.split(" ");
    if (x)
        text.attrs({ x });
    else
        x = Number(text.attr("x"));
    if (wrapAfter)
        text.attrs({ "data-wrapAfter": wrapAfter });
    else
        wrapAfter = Number(text.attr("data-wrapAfter") || 100);
    let i = 0;
    let bb = null;
    while (i < words.length) {
        let ts = el.tspan(text, words[i]);
        let w = ts.element.getComputedTextLength();
        while (++i < words.length && w < wrapAfter) {
            ts.text = ts.text + " " + words[i];
            w = ts.element.getComputedTextLength();
        }
        if (!bb)
            bb = text.bbox;
        else
            ts.attrs({ x, dy: bb.height });
    }
}
exports.changeWordWrapText = changeWordWrapText;
//# sourceMappingURL=text.js.map

/***/ }),

/***/ "./node_modules/taitto/lib/svg/vector.js":
/*!***********************************************!*\
  !*** ./node_modules/taitto/lib/svg/vector.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.divVec = exports.mulVec = exports.subVec = exports.addVec = exports.vecY = exports.vecX = exports.oneVector = exports.zeroVector = void 0;
exports.zeroVector = [0, 0];
exports.oneVector = [1, 1];
function vecX(vec) {
    return vec[0];
}
exports.vecX = vecX;
function vecY(vec) {
    return vec[1];
}
exports.vecY = vecY;
function addVec(vec1, vec2) {
    return vec1.map((a, i) => a + vec2[i]);
}
exports.addVec = addVec;
function subVec(vec1, vec2) {
    return vec1.map((a, i) => a - vec2[i]);
}
exports.subVec = subVec;
function mulVec(vec1, vec2) {
    return vec1.map((a, i) => a * vec2[i]);
}
exports.mulVec = mulVec;
function divVec(vec1, vec2) {
    return vec1.map((a, i) => a / vec2[i]);
}
exports.divVec = divVec;
//# sourceMappingURL=vector.js.map

/***/ }),

/***/ "./src/arrayparsers.ts":
/*!*****************************!*\
  !*** ./src/arrayparsers.ts ***!
  \*****************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.operators = void 0;
/**
 * # Combinators for Parsing Arrays and Expressions
 *
 * This module contains additional combinators that are useful when parsing
 * sequences or expressions. They are adapted from the original
 * [Parsec](http://hackage.haskell.org/package/parsec-3.1.13.0/docs/Text-Parsec-Combinator.html)
 * library.
 */
const par = __webpack_require__(/*! ./parser */ "./src/parser.ts");
/**
 * ## Parsing Separated Lists
 *
 * Parse an array containing at least one element. The items of the array are
 * recognized by `parser`. The items are separated by input recognized by
 * `separator`. The function returns an array of parsed elements.
 */
par.Parser.prototype.oneOrMoreSeparatedBy = function (separator) {
    return this.bind(x => separator.seq(this).zeroOrMore().bind(xs => par.mret([x].concat(xs))));
};
/**
 * Parse a potentially empty array. The items of the array are recognized by
 * `parser`. The items are separated by input recognized by `separator`.
 */
par.Parser.prototype.zeroOrMoreSeparatedBy = function (separator) {
    return this.oneOrMoreSeparatedBy(separator).or(par.mret([]));
};
/**
 * ## Terminators & Brackets
 *
 * Parse item(s) followed by a terminator given in the `after` parser. The
 * result of `parser` is returned, and result of `after` is ignored.
 */
par.Parser.prototype.followedBy = function (after) {
    return this.bind(p => after.bind(_ => par.mret(p)));
};
/**
 * Parse item(s) surrounded by input recognized by the `surround` parser. The
 * result of `parser` is returned.
 */
par.Parser.prototype.surroundedBy = function (surround) {
    return surround.bind(o => this.bind(p => surround.bind(c => par.mret(p))));
};
/**
 * Parse item(s) surrounded by an open and closing bracket. The result `parser`
 * is returned.
 */
par.Parser.prototype.bracketedBy = function (open, close) {
    return open.bind(o => this.bind(p => close.bind(c => par.mret(p))));
};
/**
 * ## Parsing Expressions
 *
 * Parse one or more occurrences of `parser`, separated by `operation`.
 * Return a value obtained by a left associative application of all functions
 * returned by `operation` to the values returned by `parser`. This parser can
 * for example be used to eliminate left recursion which typically occurs in
 * expression grammars.
 */
par.Parser.prototype.chainOneOrMore = function (operation) {
    return this.bind(x => operation.bind(f => this.bind(y => par.mret([f, y]))).zeroOrMore().bind(fys => par.mret(fys.reduce((z, [f, y]) => f(z, y), x))));
};
/**
 * Parse zero or more occurrences of `parser`, separated by `operation`.
 * Return a value obtained by a left associative application of all functions
 * returned by `operation` to the values returned by `parser`. If there are
 * zero occurrences of `parser`, the `value` is returned.
 */
par.Parser.prototype.chainZeroOrMore = function (operation, value) {
    return this.chainOneOrMore(operation).or(par.mret(value));
};
/**
 * Construct a parser for operator selection. Used typically in conjunction
 * with `chain*` functions.
 */
function operators(...ops) {
    return par.any(...ops.map(([p, o]) => p.map(_ => o)));
}
exports.operators = operators;


/***/ }),

/***/ "./src/error.ts":
/*!**********************!*\
  !*** ./src/error.ts ***!
  \**********************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ParseError = exports.ErrorSource = void 0;
/**
 * # Error Reporting
 *
 * We define a custom Error class for parsing errors.
 *
 * The possible sources of errors are defined in the enumeration below.
 */
var ErrorSource;
(function (ErrorSource) {
    ErrorSource["Input"] = "Input";
    ErrorSource["Lexer"] = "Lexer";
    ErrorSource["Parser"] = "Parsing";
})(ErrorSource = exports.ErrorSource || (exports.ErrorSource = {}));
/**
 * The ParseError class contains information about the parsing error in
 * an easily accessible form.
 */
class ParseError extends Error {
    constructor(
    /**
     * The source of the error.
     */
    source, 
    /**
     * The position where the error happened.
     */
    position, 
    /**
     * Input found at `position`.
     */
    found, 
    /**
     * Input expected at `position`. There can be multiple terminals.
     */
    expected = []) {
        /**
         * Constructor formats the error message using the parameters provided.
         */
        super(`${source} error at position ${position + 1}.\n` +
            `\tFound: "${found}"\n` +
            `\tExpected: ${expected.map(s => `"${s}"`).join(", ")}`);
        this.source = source;
        this.position = position;
        this.found = found;
        this.expected = expected;
    }
}
exports.ParseError = ParseError;


/***/ }),

/***/ "./src/index.ts":
/*!**********************!*\
  !*** ./src/index.ts ***!
  \**********************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
/**
 * ---
 * {
 *  "visualizers": [
 *      {
 *          "path": "./src/visualizers/dependency-diag.ts",
 *          "includeStyles": true
 *      }
 *  ]
 * }
 * ---
 * # Library Structure
 *
 * Below is the dependency graph showing the module hierarchy. Note that it
 * shows also the testing modules which are not included in the published
 * package. You can jump to a module by clicking it in the diagram.
 *
 * <<v:dependency-diag ../dependencies.json src\/(?!extras)>>
 *
 * ## Exports
 *
 * Parzec library consists of following modules. All of them are exported
 * outside the library.
 */
__exportStar(__webpack_require__(/*! ./ref */ "./src/ref.ts"), exports);
__exportStar(__webpack_require__(/*! ./error */ "./src/error.ts"), exports);
__exportStar(__webpack_require__(/*! ./input */ "./src/input.ts"), exports);
__exportStar(__webpack_require__(/*! ./result */ "./src/result.ts"), exports);
__exportStar(__webpack_require__(/*! ./error */ "./src/error.ts"), exports);
__exportStar(__webpack_require__(/*! ./lexer */ "./src/lexer.ts"), exports);
__exportStar(__webpack_require__(/*! ./parser */ "./src/parser.ts"), exports);
__exportStar(__webpack_require__(/*! ./arrayparsers */ "./src/arrayparsers.ts"), exports);
__exportStar(__webpack_require__(/*! ./utils */ "./src/utils.ts"), exports);


/***/ }),

/***/ "./src/input.ts":
/*!**********************!*\
  !*** ./src/input.ts ***!
  \**********************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.arrayInput = void 0;
/**
 * ## Array Input
 *
 * Arrays are the most common input data type. Therefore we provide a generic
 * implementation for them. Array items may have any type `S`. The class is
 * not exported outside the module. Users can create it using the `arrayInput`
 * function.
 */
class ArrayInput {
    /**
     * We set the position initially to -1 to indicate that no input has been
     * consumed. The current item is `undefined`.
     */
    constructor(array, eof) {
        this.array = array;
        this.position = -1;
        this.current = undefined;
        this.eof = eof;
    }
    /**
     * Return the next item in the array. Update `position` and
     * `current` fields.
     */
    next() {
        let pos = this.position + 1;
        if (pos >= this.array.length)
            return this.eof;
        this.position = pos;
        this.current = this.array[pos];
        return this.current;
    }
}
/**
 * ## Exported Functions
 *
 * Create a ParserInput wrapper for an array.
 */
function arrayInput(array, eof) {
    return new ArrayInput(array, eof);
}
exports.arrayInput = arrayInput;


/***/ }),

/***/ "./src/lexer.ts":
/*!**********************!*\
  !*** ./src/lexer.ts ***!
  \**********************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.lexerInput = exports.Lexer = exports.Token = void 0;
const utils = __webpack_require__(/*! ./utils */ "./src/utils.ts");
const err = __webpack_require__(/*! ./error */ "./src/error.ts");
/**
 * ## Representing a Token
 *
 * When a token is recognized it is wrapped in a `Token<S>` object. This
 * contains also the recognized string for error reporting and diagnostics.
 */
class Token {
    constructor(token, text) {
        this.token = token;
        this.text = text;
    }
    /**
     * We override the `toString` function so we can output a token
     * to screen.
     */
    toString() {
        return this.text ? utils.escapeWhitespace(this.text) : this.token;
    }
}
exports.Token = Token;
/**
 * ## Lexer
 *
 * The lexer itself is a simple class that contains all the TokenMatchers and
 * recognizes the next token in a string.
 */
class Lexer {
    /**
     * The constructor adds two flags to the regular expressions given as
     * arguments. The `y` flag makes the search sticky so that it scans the
     * input string from the position indicated by the `lastIndex` property.
     * The `u` flag makes the search support unicode characters.
     */
    constructor(...tokens) {
        this.matchers = tokens.map(t => ({
            regex: new RegExp(t[0], "yu"),
            token: t[1]
        }));
    }
    /**
     * We check matchers one-by-one in the order they were given to
     * recognize the token in the given position. If none of the matchers
     * succeed, we return `null`.
     */
    matchToken(input, pos) {
        for (let i = 0; i < this.matchers.length; i++) {
            let matcher = this.matchers[i];
            matcher.regex.lastIndex = pos;
            let match = matcher.regex.exec(input);
            if (match != null)
                return new Token(matcher.token, match[0]);
        }
        return null;
    }
}
exports.Lexer = Lexer;
/**
 * ## Lexer as Input
 *
 * We can integrate lexing directly into the parsing process by implementing
 * the `ParserInput` interface for any token. We don't expose `LexerInput`
 * class outside the module. It can be created with the `lexerInput` function.
 */
class LexerInput {
    /**
     * Create an input stream for given string and lexer. Initialize the
     * instance variables.
     */
    constructor(input, lexer, eof) {
        this.input = input;
        this.lexer = lexer;
        this.tokens = new Array(input.length);
        this.position = -1;
        this.eof = eof;
        this.current = this.eof;
    }
    /**
     * The iterator implementation is fairly straightforward. We need to make
     * sure that the state variables `position` and `current` are kept in sync
     * while we advance in the input string. We must also do a lookup in the
     * cach before calling the lexer to recognize the token. If the lexer finds
     * a match, we update the cach. If the lexer cannot recognize the next
     * token, we throw a `ParseError`.
     */
    next() {
        let pos = this.position;
        pos += this.tokens[pos] ? this.tokens[pos].text.length : 1;
        if (pos >= this.input.length)
            return this.eof;
        this.position = pos;
        let match = this.tokens[pos] || this.lexer.matchToken(this.input, pos);
        if (!match)
            throw new err.ParseError(err.ErrorSource.Lexer, pos, this.input.substr(pos, 10) + "...", ["<valid token>"]);
        this.tokens[pos] = match;
        this.current = match;
        return match;
    }
}
/**
 * Create an input stream for given `text` string using the given `lexer`.
 */
function lexerInput(text, lexer, eof) {
    return new LexerInput(text, lexer, eof);
}
exports.lexerInput = lexerInput;


/***/ }),

/***/ "./src/parser.ts":
/*!***********************!*\
  !*** ./src/parser.ts ***!
  \***********************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.terminal = exports.token = exports.is = exports.anything = exports.forwardRef = exports.cleanupState = exports.checkState = exports.mutateState = exports.setState = exports.getState = exports.position = exports.choose = exports.peek = exports.any = exports.notSatisfy = exports.satisfy = exports.fail = exports.mret = exports.parse = exports.tryParse = exports.parserDebug = exports.Parser = void 0;
const pr = __webpack_require__(/*! ./result */ "./src/result.ts");
const utils = __webpack_require__(/*! ./utils */ "./src/utils.ts");
const err = __webpack_require__(/*! ./error */ "./src/error.ts");
/**
 * ## Parser Class
 *
 * The central type in the Parzec library is the `Parser<T, S>` class. It wraps
 * a parsing function and provides the core combinators to combine parsers in
 * various ways.
 */
class Parser {
    /**
     * Constructor wraps the parsing function.
     */
    constructor(parse) {
        this.parse = parse;
    }
    /**
     * The monadic bind that corresponds to Haskell's `>>=` operator. Runs
     * `this` parser, and if it succeeds, feeds its result to the `binder`
     * function that returns a new Parser. This is the basic operation that is
     * used in other combinators to glue parsers together.
     */
    bind(binder) {
        return new Parser(input => {
            let pos = input.position;
            let res1 = this.parse(input);
            if (res1.kind == "ok") {
                let res2 = binder(res1.result).parse(input);
                if (res2.kind == "fail" && pos !== input.position)
                    input.position = pos; // backtrack
                return res2;
            }
            return res1;
        });
    }
    /**
     * The sequence operator. Runs `this` parser, and if it succeeds, runs the
     * `other` parser ignoring the result of `this` one.
     */
    seq(other) {
        return this.bind(_ => other);
    }
    /**
     * Map result of the parser to another value. This function implements a
     * [_functor_](https://en.wikipedia.org/wiki/Functor) which is a superclass
     * of monad.
     */
    map(mapper) {
        return this.bind(x => mret(mapper(x)));
    }
    /**
     * ## Conditional Parsing
     *
     * The ordered choice operation. Creates a parser that first runs `this`
     * parser, and if that fails, runs the `other` one. Corresponds to the `/`
     * operation in [PEG grammars](https://en.wikipedia.org/wiki/Parsing_expression_grammar).
     */
    or(other) {
        return new Parser(input => {
            let pos = input.position;
            let res1 = this.parse(input);
            if (res1.kind == "ok")
                return res1;
            if (res1.position > pos)
                return res1;
            let res2 = other.parse(input);
            if (res2.kind == "ok")
                return res2;
            pr.joinExpected(res2, res1);
            return res2;
        });
    }
    /**
     * Parse an optional value, if the parser fails then the default value is
     * returned.
     */
    optional(defaultValue) {
        return this.or(mret(defaultValue));
    }
    /**
     * Parse an optional reference value, if the parser fails then null is
     * returned.
     */
    optionalRef() {
        return this.or(mret(null));
    }
    /**
     * Runs parser and checks that it succeeds and that the result it returns
     * satisfies a given predicate.
     */
    where(predicate) {
        return this.bind(x => predicate(x) ? mret(x) : fail(`${x}`, "predicate"));
    }
    /**
     * ## Parsing Multiple Items
     *
     * Creates a parser that will run `this` parser zero or more times. The
     * results of the input parser are added to an array.
     */
    zeroOrMore() {
        return new Parser(input => {
            let list = [];
            while (true) {
                let pos = input.position;
                let res = this.parse(input);
                if (res.kind == "fail")
                    return res.position > pos ?
                        res : pr.succeeded(res.position, list);
                list.push(res.result);
            }
        });
    }
    /**
     * Creates a parser that runs `this` parser one or more times.
     */
    oneOrMore() {
        return new Parser(input => {
            let res = this.parse(input);
            if (res.kind == "fail")
                return res;
            let list = [res.result];
            while (true) {
                let pos = input.position;
                res = this.parse(input);
                if (res.kind == "fail")
                    return res.position > pos ?
                        res : pr.succeeded(res.position, list);
                list.push(res.result);
            }
        });
    }
    /**
     * Parsing succeeds if `this` parser succeeds from `min` to `max` times.
     */
    occurrences(min, max) {
        return this.zeroOrMore().bind(list => {
            let cnt = list.length;
            return cnt >= min && cnt <= max ?
                mret(list) :
                fail(`${cnt} occurrences`, `${min}-${max} occurrences`);
        });
    }
    /**
     * ## Lookahead & Backtracking
     *
     * Check that `this` parser succeeds without consuming any input.
     * Corresponds to the `&` operator in PEG grammars.
     */
    and() {
        return new Parser(input => {
            let pos = input.position;
            let res = this.parse(input);
            input.position = pos;
            return res;
        });
    }
    /**
     * Check that `this` parser fails without consuming any input. Corresponds
     * to the `!` operator in PEG grammars.
     */
    not() {
        return new Parser(input => {
            let pos = input.position;
            let res = this.parse(input);
            input.position = pos;
            if (res.kind == "ok") {
                let found = `${res.result}`;
                return pr.failed(res.position, found, ["not " + found]);
            }
            return pr.succeeded(res.position, undefined);
        });
    }
    /**
     * Bactrack to the current input position, even if the given parser fails
     * and has advanced the input position. Normally we do not bactrack when a
     * parser has advanced in the input. Doing so would loose the position where
     * the parsing failed and make error messages more vague. Sometimes,
     * however, we need more input lookahead. In these cases, you can use the
     * backtrack operation to retry the next rule.
     */
    backtrack() {
        return new Parser(input => {
            let pos = input.position;
            let res = this.parse(input);
            if (res.kind == "fail" && res.position > pos)
                res.position = pos;
            return res;
        });
    }
    /**
     * ## Error Reporting and Debugging
     *
     * Give a human-readable name to the "thing" that the given parser matches.
     * This name is reported as expected value, if the parsing fails.
     */
    expect(expected) {
        if (!exports.parserDebug.errorMessages)
            return this;
        let resParser = new Parser((input) => {
            let res = this.parse(input);
            if (res.kind == "fail")
                res.expected.push(expected);
            return res;
        });
        return exports.parserDebug.debugging ? resParser.trace(expected) : resParser;
    }
    /**
     * Attach debugging information to a parser. To trace which rules are
     * triggered during parsing, you can add debugging info to any parser. This
     * combinator produces a hierarchical tree of parser invocations which
     * includes information about input symbol and its position. If debugging
     * is disabled, this function does nothing.
     */
    trace(ruleName) {
        if (!exports.parserDebug.debugging)
            return this;
        return new Parser(input => {
            exports.parserDebug.write(`${ruleName} called with input '${input.current}'.`);
            exports.parserDebug.indent();
            let res = this.parse(input);
            exports.parserDebug.rulesEvaluated++;
            exports.parserDebug.unindent();
            exports.parserDebug.write((res.kind == "ok" ?
                `${ruleName} SUCCEEDED with value '${utils.escapeWhitespace(`${res.result}`)}'` :
                `${ruleName} FAILED with value '${utils.escapeWhitespace(`${res.found}`)}'. Expected values: ${pr.expectedAsCsv(res)}`) +
                ` at position ${res.position}`);
            return res;
        });
    }
}
exports.Parser = Parser;
/**
 * ## Debugging Options
 *
 * The following object contains the global settings that control the parser
 * reporting.
 */
exports.parserDebug = {
    /**
     * When `debugging` flag is on parsers count the number of rules evaluated
     * during their operation. The `rulesEvaluated` field contains this
     * information.
     */
    debugging: false,
    rulesEvaluated: 0,
    /**
     * If errorMessages flag is turned off, the expected information will not be
     * available in parse errors. This speeds up the parsing nominally.
     */
    errorMessages: true,
    /**
     * The current indentation level in the debugging output is stored in this
     * field.
     */
    indentation: 0,
    /**
     * Indent the debug output by one level.
     */
    indent() {
        this.indentation++;
    },
    /**
     * Unndent the debug output by one level.
     */
    unindent() {
        this.indentation--;
    },
    /**
     * Write a string to the debug output.
     */
    write(text) {
        let tabs = "  ".repeat(this.indentation);
        console.log(tabs + text);
    }
};
/**
 * ## Main Functions
 *
 * Attempt to parse an input with a given parser. Takes a Parser and a
 * ParserInput as arguments and return a ParseResult.
 */
function tryParse(parser, input) {
    exports.parserDebug.rulesEvaluated = 0;
    let res = parser.parse(input);
    if (exports.parserDebug.debugging)
        console.info("Number of rules evaluated: " + exports.parserDebug.rulesEvaluated);
    return res;
}
exports.tryParse = tryParse;
/**
 * Parse an input using a given parser, or throw an exception, if parsing fails.
 */
function parse(parser, input) {
    var res = tryParse(parser, input);
    if (res.kind == "fail")
        throw new err.ParseError(err.ErrorSource.Parser, res.position, res.found, res.expected);
    return res.result;
}
exports.parse = parse;
/**
 * ## Monadic Returns
 *
 * Create a parser that always succeeds and returns the given value without
 * consuming any input. This function implements the monadic return, that is,
 * it lifts a value to the parser monad.
 */
function mret(value) {
    return new Parser(input => pr.succeeded(input.position, value));
}
exports.mret = mret;
/**
 * Create a parser that always fails. The terminals reported as
 * found or expected are given as an argument.
 */
function fail(found, ...expected) {
    return new Parser(input => pr.failed(input.position, found, expected));
}
exports.fail = fail;
/**
 * ## Parsing Terminals
 *
 * Creates a parser that reads one terminal from the input and returns it, if it
 * satisfies the given predicate; otherwise the parser fails.
 */
function satisfy(predicate) {
    return new Parser(input => {
        let pos = input.position;
        let item = input.next();
        if (predicate(item))
            return pr.succeeded(input.position, item);
        input.position = pos;
        return pr.failed(input.position, `${item}`);
    });
}
exports.satisfy = satisfy;
/**
 * Creates a parser that reads one terminal from the input and returns it, if it
 * does **not** satisfy a given predicate.
 */
function notSatisfy(predicate) {
    return satisfy(x => !predicate(x));
}
exports.notSatisfy = notSatisfy;
/**
 * Any of the given parsers must succeed. The operation is the same
 * as the `or` combinator generalized to arbitrary number of choices.
 */
function any(...parsers) {
    if (parsers.length == 0)
        throw Error("At least one parser must be given.");
    return new Parser(input => {
        let res = null;
        let i = 0;
        let pos = input.position;
        do {
            let r = parsers[i++].parse(input);
            if (r.kind == "ok")
                return r;
            if (r.position > pos)
                return r;
            if (res == null)
                res = r;
            else
                pr.joinExpected(res, r);
        } while (i < parsers.length);
        return res;
    });
}
exports.any = any;
/**
 * Peek next symbol in the input stream without changing the position.
 */
function peek() {
    return new Parser(input => {
        let pos = input.position;
        let next = input.next();
        input.position = pos;
        return pr.succeeded(pos, next);
    });
}
exports.peek = peek;
/**
 * Select a parser to be used based on the next symbol in the input. This
 * function is an alternative to the the "any" combinator. It reduces
 * backtracking when the parser to be applied can be deduced from the next
 * symbol.
 */
function choose(selector) {
    return peek().bind(selector);
}
exports.choose = choose;
/**
 * ## Getting Current Position
 *
 * A parser that returns the current position of the input. This is useful
 * when binding parsers together and you want to know the position where you
 * currently are. The position can be also used for backtracking.
 */
function position() {
    return new Parser(input => pr.succeeded(input.position, input.position));
}
exports.position = position;
/**
 * ## User-Managed State
 *
 * Get the current satellite state stored in the input.
 */
function getState() {
    return new Parser(input => pr.succeeded(input.position, input.state));
}
exports.getState = getState;
/**
 * Set the current satellite state stored in the input. The new state
 * is not given explicitly. Rather, a funcion which returns the new
 * state is specified.
 */
function setState(newValue) {
    return new Parser(input => pr.succeeded(input.position, input.state = newValue()));
}
exports.setState = setState;
/**
 * Mutate the satellite state stored in the input. The mutation is done
 * with a function given as an argument.
 */
function mutateState(mutate) {
    return new Parser(input => {
        mutate(input.state);
        return pr.succeeded(input.position, input.state);
    });
}
exports.mutateState = mutateState;
/**
 * Check that the current state matches a predicate. If not, the result parser
 * fails.
 */
function checkState(predicate) {
    return new Parser(input => predicate(input.state) ?
        pr.succeeded(input.position, input.state) :
        pr.failed(input.position, "Matching predicate."));
}
exports.checkState = checkState;
/**
 * Clean up the current state after a parser has been executed. The clean-up
 * function is run regardless of whether the parser succeeds or fails.
 */
function cleanupState(parser, cleanup) {
    return new Parser(input => {
        let res = parser.parse(input);
        cleanup(input.state);
        return res;
    });
}
exports.cleanupState = cleanupState;
/**
 * ## Defining Mutually Recursive Parsers
 *
 * Often grammar rules are mutually recursive, which means that there is no way
 * to write them in an order where all the dependent rules are defined. In these
 * occasions, you can just create a _reference_ to a parser and set its
 * implementation later. To refer to the parser that is not yet defined, you can
 * use this function.
 */
function forwardRef(parser) {
    return new Parser(input => parser.target.parse(input));
}
exports.forwardRef = forwardRef;
/**
 * ## General Parsers
 *
 * The catch-all parser that will match any symbol read from the input.
 */
function anything() {
    return satisfy(_ => true);
}
exports.anything = anything;
/**
 * Parser that succeeds if the symbol read from the input is equal (===) to
 * given parameter; otherwise parsing fails.
 */
function is(value) {
    return satisfy(x => x === value);
}
exports.is = is;
/**
 * Parse a specific token from the lexer input stream.
 */
function token(token) {
    return satisfy(t => t.token === token);
}
exports.token = token;
/**
 * Helper function to create a terminal parser.
 */
function terminal(tok, name) {
    return token(tok).expect(name);
}
exports.terminal = terminal;


/***/ }),

/***/ "./src/ref.ts":
/*!********************!*\
  !*** ./src/ref.ts ***!
  \********************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Ref = void 0;
/**
 * # Reference Cells
 *
 * `Ref<T>` class provides a simple reference cell, which can be used
 * as a surrogate for a parser that is defined later on. We can define
 * a _reference_ to parser, but we don't have to give the target right
 * away. When composing parsers we can use the `forwardRef` function
 * to pass a reference to any combinator expecting a `Parser<T, S>`.
 * Of course, we have to eventually assign a real parser as the target
 * of the reference before running the parser.
 */
class Ref {
    /**
     * Constructing a reference. The target value is optional.
     */
    constructor(value) {
        this._target = null;
        if (value)
            this._target = value;
    }
    /**
     * Get the target of the reference. If no target is set, a
     * `ReferenceError` is thrown.
     */
    get target() {
        if (this._target)
            return this._target;
        throw ReferenceError("Target not set.");
    }
    /**
     * Set the target.
     */
    set target(value) {
        this._target = value;
    }
}
exports.Ref = Ref;


/***/ }),

/***/ "./src/result.ts":
/*!***********************!*\
  !*** ./src/result.ts ***!
  \***********************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.failed = exports.succeeded = exports.expectedAsCsv = exports.joinExpected = void 0;
/**
 * ## Helper Functions
 *
 * The `joinExpected` function concatenates the list of expected
 * inputs from the `other` failed parse result into the `expected`
 * array of the first one.
 */
function joinExpected(result, other) {
    if (other.expected.length > 0)
        result.expected = result.expected.concat(other.expected);
}
exports.joinExpected = joinExpected;
/**
 * This function formats the array of expected inputs as a string for
 * printing.
 */
function expectedAsCsv(result) {
    return result.expected.map(s => `"${s}"`).join(", ");
}
exports.expectedAsCsv = expectedAsCsv;
/**
 * ## Constructor Functions
 *
 * The following function is used to construct an `Ok<T>` result.
 */
function succeeded(pos, res) {
    return {
        kind: "ok",
        position: pos,
        result: res
    };
}
exports.succeeded = succeeded;
/**
 * The next one constructs a `Fail` result.
 */
function failed(pos, fnd, exp = []) {
    return {
        kind: "fail",
        position: pos,
        found: fnd,
        expected: exp
    };
}
exports.failed = failed;


/***/ }),

/***/ "./src/test/jsonparser.ts":
/*!********************************!*\
  !*** ./src/test/jsonparser.ts ***!
  \********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.parseJson = exports.jsonInput = exports.JsonToken = void 0;
/**
 * # Parsing JSON
 *
 * The next example parser converts JSON strings to JavaScript objects. It
 * effectively does the same thing as the `JSON.parse` function. So, it serves
 * no practical purpose, but is a nice example due to simplicity of the JSON
 * grammar. To make our implementation marginally more useful, let's allow to
 * include comments inside JSON.
 */
const pz = __webpack_require__(/*! .. */ "./src/index.ts");
/**
 * ## Tokens
 *
 * First we define all the tokens that JSON files may contain. These are all
 * specified in [json.org][].
 *
 * [json.org]: https://www.json.org
 */
var JsonToken;
(function (JsonToken) {
    JsonToken[JsonToken["True"] = 0] = "True";
    JsonToken[JsonToken["False"] = 1] = "False";
    JsonToken[JsonToken["Null"] = 2] = "Null";
    JsonToken[JsonToken["LeftBrace"] = 3] = "LeftBrace";
    JsonToken[JsonToken["RightBrace"] = 4] = "RightBrace";
    JsonToken[JsonToken["LeftBracket"] = 5] = "LeftBracket";
    JsonToken[JsonToken["RightBracket"] = 6] = "RightBracket";
    JsonToken[JsonToken["Comma"] = 7] = "Comma";
    JsonToken[JsonToken["Colon"] = 8] = "Colon";
    JsonToken[JsonToken["Number"] = 9] = "Number";
    JsonToken[JsonToken["String"] = 10] = "String";
    JsonToken[JsonToken["Whitespace"] = 11] = "Whitespace";
    JsonToken[JsonToken["Comment"] = 12] = "Comment";
    JsonToken[JsonToken["EOF"] = 13] = "EOF";
})(JsonToken = exports.JsonToken || (exports.JsonToken = {}));
//#region -c Debug settings
pz.parserDebug.debugging = false;
//#endregion
/**
 * ## Lexer
 *
 * We define lexers for all the tokens. First we handle constants and separator
 * characters. They are trivial to recognize.
 *
 * Numbers are a bit trickier as we need to support decimal formats with
 * and without exponents.
 *
 * ![number](../../images/number.png)
 *
 * Strings can be a bit tricky as well, as there are special characters that
 * have to be accounted for. Another notable thing is that we need to use the
 * `u` specifier in our regex for unicode support.
 *
 * ![string](../../images/string.png)
 *
 * Below we see how whitespace is scanned in JSON. We'll add a lexer for inline
 * comments `//...` as well.
 *
 * ![string](../../images/whitespace.png)
 */
const lexer = new pz.Lexer([/true/, JsonToken.True], [/false/, JsonToken.False], [/null/, JsonToken.Null], [/\{/, JsonToken.LeftBrace], [/\}/, JsonToken.RightBrace], [/\[/, JsonToken.LeftBracket], [/\]/, JsonToken.RightBracket], [/,/, JsonToken.Comma], [/:/, JsonToken.Colon], [/-?(?:[1-9]\d+|\d(?!\d))(?:\.\d+)?(?:[eE][+-]?\d+)?/, JsonToken.Number], [/"(?:(?:(?!["\\])[\u{0020}-\u{ffff}])|(?:\\(?:["\\\/bnfrt]|(?:u[0-9a-fA-F]{4}))))*"/u,
    JsonToken.String], [/[\t\n\r ]+/, JsonToken.Whitespace], [/\/\/[^\n\r]*/, JsonToken.Comment]);
/**
 * ## Terminals
 *
 * With tokens defined, parsers for terminals are trivial to write. Note how
 * we map the terminals to JavaScript types. We even cheat a bit, and convert
 * strings using `JSON.parse`. We skip the trailing whitespace (including
 * comments) for each token which makes our other rules simpler.
 */
const comment = pz.token(JsonToken.Comment);
const whitespace = pz.token(JsonToken.Whitespace).or(comment).zeroOrMore();
const number = pz.terminal(JsonToken.Number, "<number>")
    .map(t => Number(t.text)).followedBy(whitespace);
const string = pz.terminal(JsonToken.String, "<string>")
    .map(t => JSON.parse(t.text)).followedBy(whitespace);
const littrue = pz.terminal(JsonToken.True, "true").map(t => true)
    .followedBy(whitespace);
const litfalse = pz.terminal(JsonToken.False, "false").map(t => false)
    .followedBy(whitespace);
const litnull = pz.terminal(JsonToken.Null, "null").map(t => null)
    .followedBy(whitespace);
const comma = pz.terminal(JsonToken.Comma, ",").followedBy(whitespace);
const colon = pz.terminal(JsonToken.Colon, ":").followedBy(whitespace);
const beginarray = pz.terminal(JsonToken.LeftBracket, "[").followedBy(whitespace);
const endarray = pz.terminal(JsonToken.RightBracket, "]").followedBy(whitespace);
const beginobject = pz.terminal(JsonToken.LeftBrace, "{").followedBy(whitespace);
const endobject = pz.terminal(JsonToken.RightBrace, "}").followedBy(whitespace);
const eof = pz.terminal(JsonToken.EOF, "<end of input>");
/**
 * ## Nonterminals
 *
 * Now we can define parsers for nonterminals, the abstract and recursive part
 * of the grammar. `element` is a recursive parsing rule that we need to define
 * later since it depends on other rules. We create a reference cell for it and
 * then define that multiple elements can be separated by comma.
 */
const element = new pz.Ref();
const elements = pz.forwardRef(element).zeroOrMoreSeparatedBy(comma)
    .trace("elements");
/**
 * An array consists of list of elements separated by comma and bracketed by
 * `[` and `]`.
 */
const array = elements.bracketedBy(beginarray, endarray).trace("array");
/**
 * A member (of an object) consist of a string key, a colon, and an element.
 * The `member` parser returns a [_key_, _value_] pair. The `members` parses a
 * list of members separated by commas and returns array of pairs.
 */
const member = string.bind(s => colon.bind(c => pz.forwardRef(element).bind(e => pz.mret([s, e]))))
    .trace("member");
const members = member.zeroOrMoreSeparatedBy(comma).trace("members");
/**
 * An object is list of members surrounded by `{` and `}`. The parser returns a
 * JavaScript object which is created by the `initObject` helper function. It
 * constructs an object from an array of [_key_, _value_] pairs.
 */
const object = members.bracketedBy(beginobject, endobject)
    .map(ms => pz.initObject(ms)).trace("object");
/**
 * Now we can define the `element` rule. It chooses the next parser to be
 * applied based on a lookahead token. If it is a left brace or bracket, we
 * parse an object or an array respectively. If it is a primitive element
 * (string, number, boolean, or null), we jump directly to the correct parser.
 * This speeds up parsing as we don't need to use the `or` combinator, which
 * tries alternative parsers in turn.
 */
element.target = pz.choose((token) => {
    switch (token.token) {
        case JsonToken.LeftBrace: return object;
        case JsonToken.LeftBracket: return array;
        case JsonToken.String: return string;
        case JsonToken.Number: return number;
        case JsonToken.True: return littrue;
        case JsonToken.False: return litfalse;
        case JsonToken.Null: return litnull;
        default: return pz.fail(token.text, "{", "[", "<string>", "<number>", "true", "false", "null");
    }
}).trace("element");
/**
 * Finally we can define the root parser for JSON. It is just an `element`
 * parser preceded by optional whitespace.
 */
const json = whitespace.seq(element.target).followedBy(eof).trace("json");
/**
 * If you compare the definitions above to the official grammar in [json.org][],
 * you'll find that they are almost identical. The only difference is that we
 * need to declare the rules bottom-up as you cannot refer to a rule which is
 * not yet defined. Otherwise it is almost mechanical exercise to convert the
 * grammar to Parzec combinators.
 *
 * ## Exported Parsing Functions
 *
 * First we provide a function that creates a lexer input stream for a JSON
 * string.
 */
function jsonInput(text) {
    return pz.lexerInput(text, lexer, new pz.Token(JsonToken.EOF, "<end of input>"));
}
exports.jsonInput = jsonInput;
/**
 * Then we can define a function that takes a string and returns a JS object.
 * It throws an exception, if parsing fails. So, it works the same way as
 * `JSON.parse`.
 */
function parseJson(text) {
    return pz.parse(json, jsonInput(text));
}
exports.parseJson = parseJson;


/***/ }),

/***/ "./src/test/jsontests.ts":
/*!*******************************!*\
  !*** ./src/test/jsontests.ts ***!
  \*******************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
/**
 * ---
 * {
 *  "visualizers": [
 *      {
 *          "path": "./src/visualizers/run-json-tests.ts",
 *          "includeStyles": true
 *      }
 *  ]
 * }
 * ---
 *
 * # Testing JSON Parser
 *
 * To manually test the parser enter or paste some JSON to the text box below.
 * Try also add comments anywhere inside JSON.
 *
 * <<v:json-parser>>
 *
 * Manually entering test data becomes boring soon, so we'll again use
 * **fast-check** to automate test case generation. In this case we can use the
 * built-in combinator that generates arbitrary JSON data. So, our job is made
 * easy for us.
 */
const jsonparser_1 = __webpack_require__(/*! ./jsonparser */ "./src/test/jsonparser.ts");
const tester_1 = __webpack_require__(/*! lits-extras/lib/tester */ "./node_modules/lits-extras/lib/tester.js");
const fc = __webpack_require__(/*! fast-check */ "./node_modules/fast-check/lib/fast-check.js");
/**
 * We should get interesting test data. You can check the test cases below.
 *
 * <<v:run-json-tests JSON tests>>
 *
 * Using `JSON.parse` as the baseline for our parser, we can check that it and
 * our parsing functions produce identical JavaScript objects. We use the
 * `deepEqual` assertion to check that.
 */
tester_1.test("Test arbitrary JSON data", (t) => __awaiter(void 0, void 0, void 0, function* () {
    return fc.assert(fc.property(fc.json(), str => {
        let obj1 = JSON.parse(str);
        let obj2 = jsonparser_1.parseJson(str);
        t.deepEqual(obj2, obj1, JSON.stringify(obj2) +
            " should be deep equal to " + JSON.stringify(obj1));
    }));
}));


/***/ }),

/***/ "./src/utils.ts":
/*!**********************!*\
  !*** ./src/utils.ts ***!
  \**********************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.escapeWhitespace = exports.initObject = void 0;
/**
 * # Utility Functions
 *
 * This module contains general functions used elsewhere in the library.
 *
 * The first function initializes an object from an array of `[string, any]`
 * pairs. It is used to populate an object dynamically.
 */
function initObject(members) {
    let res = {};
    for (let i = 0; i < members.length; i++) {
        let [m, v] = members[i];
        res[m] = v;
    }
    return res;
}
exports.initObject = initObject;
/**
 * The `escapeWhitespace` function helps printing strings containing whitespace
 * characters. It replaces them with their escape codes.
 */
function escapeWhitespace(text) {
    return text.replace("\n", "\\n").replace("\r", "\\r").replace("\t", "\\t");
}
exports.escapeWhitespace = escapeWhitespace;


/***/ }),

/***/ "./node_modules/zora/dist/bundle/index.js":
/*!************************************************!*\
  !*** ./node_modules/zora/dist/bundle/index.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

const startTestMessage = (test, offset) => ({
    type: "TEST_START" /* TEST_START */,
    data: test,
    offset
});
const assertionMessage = (assertion, offset) => ({
    type: "ASSERTION" /* ASSERTION */,
    data: assertion,
    offset
});
const endTestMessage = (test, offset) => ({
    type: "TEST_END" /* TEST_END */,
    data: test,
    offset
});
const bailout = (error, offset) => ({
    type: "BAIL_OUT" /* BAIL_OUT */,
    data: error,
    offset
});

const delegateToCounter = (counter) => (target) => Object.defineProperties(target, {
    skipCount: {
        get() {
            return counter.skipCount;
        }
    },
    failureCount: {
        get() {
            return counter.failureCount;
        }
    },
    successCount: {
        get() {
            return counter.successCount;
        }
    },
    count: {
        get() {
            return counter.count;
        }
    }
});
const counter = () => {
    let success = 0;
    let failure = 0;
    let skip = 0;
    return Object.defineProperties({
        update(assertion) {
            const { pass, skip: isSkipped } = assertion;
            if (isSkipped) {
                skip++;
            }
            else if (!isAssertionResult(assertion)) {
                skip += assertion.skipCount;
                success += assertion.successCount;
                failure += assertion.failureCount;
            }
            else if (pass) {
                success++;
            }
            else {
                failure++;
            }
        }
    }, {
        successCount: {
            get() {
                return success;
            }
        },
        failureCount: {
            get() {
                return failure;
            }
        },
        skipCount: {
            get() {
                return skip;
            }
        },
        count: {
            get() {
                return skip + success + failure;
            }
        }
    });
};

const defaultTestOptions = Object.freeze({
    offset: 0,
    skip: false,
    runOnly: false
});
const noop = () => {
};
const TesterPrototype = {
    [Symbol.asyncIterator]: async function* () {
        await this.routine;
        for (const assertion of this.assertions) {
            if (assertion[Symbol.asyncIterator]) {
                // Sub test
                yield startTestMessage({ description: assertion.description }, this.offset);
                yield* assertion;
                if (assertion.error !== null) {
                    // Bubble up the error and return
                    this.error = assertion.error;
                    this.pass = false;
                    return;
                }
            }
            yield assertionMessage(assertion, this.offset);
            this.pass = this.pass && assertion.pass;
            this.counter.update(assertion);
        }
        return this.error !== null ?
            yield bailout(this.error, this.offset) :
            yield endTestMessage(this, this.offset);
    }
};
const testerLikeProvider = (BaseProto = TesterPrototype) => (assertions, routine, offset) => {
    const testCounter = counter();
    const withTestCounter = delegateToCounter(testCounter);
    let pass = true;
    return withTestCounter(Object.create(BaseProto, {
        routine: {
            value: routine
        },
        assertions: {
            value: assertions
        },
        offset: {
            value: offset
        },
        counter: {
            value: testCounter
        },
        length: {
            get() {
                return assertions.length;
            }
        },
        pass: {
            enumerable: true,
            get() {
                return pass;
            },
            set(val) {
                pass = val;
            }
        }
    }));
};
const testerFactory = testerLikeProvider();

const tester = (description, spec, { offset = 0, skip = false, runOnly = false } = defaultTestOptions) => {
    let executionTime = 0;
    let error = null;
    let done = false;
    const assertions = [];
    const collect = item => {
        if (done) {
            throw new Error(`test "${description}" 
tried to collect an assertion after it has run to its completion. 
You might have forgotten to wait for an asynchronous task to complete
------
${spec.toString()}
`);
        }
        assertions.push(item);
    };
    const specFunction = skip === true ? noop : function zora_spec_fn() {
        return spec(assert(collect, offset, runOnly));
    };
    const testRoutine = (async function () {
        try {
            const start = Date.now();
            const result = await specFunction();
            executionTime = Date.now() - start;
            return result;
        }
        catch (e) {
            error = e;
        }
        finally {
            done = true;
        }
    })();
    return Object.defineProperties(testerFactory(assertions, testRoutine, offset), {
        error: {
            get() {
                return error;
            },
            set(val) {
                error = val;
            }
        },
        executionTime: {
            enumerable: true,
            get() {
                return executionTime;
            }
        },
        skip: {
            value: skip
        },
        description: {
            enumerable: true,
            value: description
        }
    });
};

// do not edit .js files directly - edit src/index.jst



var fastDeepEqual = function equal(a, b) {
  if (a === b) return true;

  if (a && b && typeof a == 'object' && typeof b == 'object') {
    if (a.constructor !== b.constructor) return false;

    var length, i, keys;
    if (Array.isArray(a)) {
      length = a.length;
      if (length != b.length) return false;
      for (i = length; i-- !== 0;)
        if (!equal(a[i], b[i])) return false;
      return true;
    }



    if (a.constructor === RegExp) return a.source === b.source && a.flags === b.flags;
    if (a.valueOf !== Object.prototype.valueOf) return a.valueOf() === b.valueOf();
    if (a.toString !== Object.prototype.toString) return a.toString() === b.toString();

    keys = Object.keys(a);
    length = keys.length;
    if (length !== Object.keys(b).length) return false;

    for (i = length; i-- !== 0;)
      if (!Object.prototype.hasOwnProperty.call(b, keys[i])) return false;

    for (i = length; i-- !== 0;) {
      var key = keys[i];

      if (!equal(a[key], b[key])) return false;
    }

    return true;
  }

  // true if both NaN, false otherwise
  return a!==a && b!==b;
};

const isAssertionResult = (result) => {
    return 'operator' in result;
};
const specFnRegexp = /zora_spec_fn/;
const zoraInternal = /zora\/dist\/bundle/;
const filterStackLine = l => (l && !zoraInternal.test(l) && !l.startsWith('Error') || specFnRegexp.test(l));
const getAssertionLocation = () => {
    const err = new Error();
    const stack = (err.stack || '')
        .split('\n')
        .map(l => l.trim())
        .filter(filterStackLine);
    const userLandIndex = stack.findIndex(l => specFnRegexp.test(l));
    const stackline = userLandIndex >= 1 ? stack[userLandIndex - 1] : (stack[0] || 'N/A');
    return stackline
        .replace(/^at|^@/, '');
};
const assertMethodHook = (fn) => function (...args) {
    // @ts-ignore
    return this.collect(fn(...args));
};
const aliasMethodHook = (methodName) => function (...args) {
    return this[methodName](...args);
};
const unbindAssert = (target) => Object.fromEntries([...Object.keys(AssertPrototype), 'collect']
    .map((methodName) => [methodName, (...args) => target[methodName](...args)]));
const AssertPrototype = {
    equal: assertMethodHook((actual, expected, description = 'should be equivalent') => ({
        pass: fastDeepEqual(actual, expected),
        actual,
        expected,
        description,
        operator: "equal" /* EQUAL */
    })),
    equals: aliasMethodHook('equal'),
    eq: aliasMethodHook('equal'),
    deepEqual: aliasMethodHook('equal'),
    same: aliasMethodHook('equal'),
    notEqual: assertMethodHook((actual, expected, description = 'should not be equivalent') => ({
        pass: !fastDeepEqual(actual, expected),
        actual,
        expected,
        description,
        operator: "notEqual" /* NOT_EQUAL */
    })),
    notEquals: aliasMethodHook('notEqual'),
    notEq: aliasMethodHook('notEqual'),
    notDeepEqual: aliasMethodHook('notEqual'),
    is: assertMethodHook((actual, expected, description = 'should be the same') => ({
        pass: Object.is(actual, expected),
        actual,
        expected,
        description,
        operator: "is" /* IS */
    })),
    isNot: assertMethodHook((actual, expected, description = 'should not be the same') => ({
        pass: !Object.is(actual, expected),
        actual,
        expected,
        description,
        operator: "isNot" /* IS_NOT */
    })),
    notSame: aliasMethodHook('isNot'),
    ok: assertMethodHook((actual, description = 'should be truthy') => ({
        pass: Boolean(actual),
        actual,
        expected: 'truthy value',
        description,
        operator: "ok" /* OK */
    })),
    truthy: aliasMethodHook('ok'),
    notOk: assertMethodHook((actual, description = 'should be falsy') => ({
        pass: !Boolean(actual),
        actual,
        expected: 'falsy value',
        description,
        operator: "notOk" /* NOT_OK */
    })),
    falsy: aliasMethodHook('notOk'),
    fail: assertMethodHook((description = 'fail called') => ({
        pass: false,
        actual: 'fail called',
        expected: 'fail not called',
        description,
        operator: "fail" /* FAIL */
    })),
    throws: assertMethodHook((func, expected, description) => {
        let caught;
        let pass;
        let actual;
        if (typeof expected === 'string') {
            [expected, description] = [description, expected];
        }
        try {
            func();
        }
        catch (err) {
            caught = { error: err };
        }
        pass = caught !== undefined;
        actual = caught && caught.error;
        if (expected instanceof RegExp) {
            pass = expected.test(actual) || expected.test(actual && actual.message);
            actual = actual && actual.message || actual;
            expected = String(expected);
        }
        else if (typeof expected === 'function' && caught) {
            pass = actual instanceof expected;
            actual = actual.constructor;
        }
        return {
            pass,
            actual,
            expected,
            description: description || 'should throw',
            operator: "throws" /* THROWS */
        };
    }),
    doesNotThrow: assertMethodHook((func, expected, description) => {
        let caught;
        if (typeof expected === 'string') {
            [expected, description] = [description, expected];
        }
        try {
            func();
        }
        catch (err) {
            caught = { error: err };
        }
        return {
            pass: caught === undefined,
            expected: 'no thrown error',
            actual: caught && caught.error,
            operator: "doesNotThrow" /* DOES_NOT_THROW */,
            description: description || 'should not throw'
        };
    })
};
const assert = (collect, offset, runOnly = false) => {
    const actualCollect = item => {
        if (!item.pass) {
            item.at = getAssertionLocation();
        }
        collect(item);
        return item;
    };
    const test = (description, spec, opts) => {
        const options = Object.assign({}, defaultTestOptions, opts, { offset: offset + 1, runOnly });
        const subTest = tester(description, spec, options);
        collect(subTest);
        return subTest.routine;
    };
    const skip = (description, spec, opts) => {
        return test(description, spec, Object.assign({}, opts, { skip: true }));
    };
    // @ts-ignore
    return {
        ...unbindAssert(Object.create(AssertPrototype, { collect: { value: actualCollect } })),
        test(description, spec, opts = {}) {
            if (runOnly) {
                return skip(description, spec, opts);
            }
            return test(description, spec, opts);
        },
        skip(description, spec = noop, opts = {}) {
            return skip(description, spec, opts);
        },
        only(description, spec, opts = {}) {
            const specFn = runOnly === false ? _ => {
                throw new Error(`Can not use "only" method when not in run only mode`);
            } : spec;
            return test(description, specFn, opts);
        }
    };
};

const map = (fn) => async function* (stream) {
    for await (const m of stream) {
        yield fn(m);
    }
};
// ! it mutates the underlying structure yet it is more efficient regarding performances
const flatten = map((m) => {
    m.offset = 0;
    return m;
});
const isAssertionResult$1 = (result) => {
    return 'operator' in result;
};
const stringifySymbol = (key, value) => {
    if (typeof value === 'symbol') {
        return value.toString();
    }
    return value;
};

// @ts-ignore
const flatDiagnostic = ({ pass, description, ...rest }) => rest;
const Tap = {
    print(message, offset = 0) {
        this.log(message.padStart(message.length + (offset * 4))); // 4 white space used as indent (see tap-parser)
    },
    printYAML(obj, offset = 0) {
        const YAMLOffset = offset + 0.5;
        this.print('---', YAMLOffset);
        for (const [prop, value] of Object.entries(obj)) {
            this.print(`${prop}: ${JSON.stringify(value, stringifySymbol)}`, YAMLOffset + 0.5);
        }
        this.print('...', YAMLOffset);
    },
    printComment(comment, offset = 0) {
        this.print(`# ${comment}`, offset);
    },
    printBailOut(message) {
        this.print('Bail out! Unhandled error.');
    },
    printTestStart(message) {
        const { data: { description }, offset } = message;
        this.printComment(description, offset);
    },
    printTestEnd(message) {
        // do nothing
    },
    printAssertion(message) {
        const { data, offset } = message;
        const { pass, description } = data;
        const label = pass === true ? 'ok' : 'not ok';
        if (isAssertionResult$1(data)) {
            const id = this.nextId();
            this.print(`${label} ${id} - ${description}`, offset);
            if (pass === false) {
                this.printYAML(flatDiagnostic(data), offset);
            }
        }
        else if (data.skip) {
            const id = this.nextId();
            this.print(`${pass ? 'ok' : 'not ok'} ${id} - ${description} # SKIP`, offset);
        }
    },
    printSummary(endMessage) {
        this.print('', 0);
        this.printComment(endMessage.data.pass ? 'ok' : 'not ok', 0);
        this.printComment(`success: ${endMessage.data.successCount}`, 0);
        this.printComment(`skipped: ${endMessage.data.skipCount}`, 0);
        this.printComment(`failure: ${endMessage.data.failureCount}`, 0);
    },
    async report(stream) {
        const src = flatten(stream);
        let lastMessage = null;
        this.print('TAP version 13');
        for await (const message of src) {
            lastMessage = message;
            switch (message.type) {
                case "TEST_START" /* TEST_START */:
                    this.printTestStart(message);
                    break;
                case "ASSERTION" /* ASSERTION */:
                    this.printAssertion(message);
                    break;
                case "BAIL_OUT" /* BAIL_OUT */:
                    this.printBailOut(message);
                    throw message.data;
            }
        }
        this.print(`1..${lastMessage.data.count}`, 0);
        this.printSummary(lastMessage);
    }
};
const factory = (log) => {
    let i = 0;
    return Object.create(Tap, {
        nextId: {
            enumerable: true,
            value: () => {
                return ++i;
            }
        },
        log: { value: log }
    });
};

const indentedDiagnostic = ({ expected, pass, description, actual, operator, at = 'N/A', ...rest }) => ({
    wanted: expected,
    found: actual,
    at,
    operator,
    ...rest
});
const id = function* () {
    let i = 0;
    while (true) {
        yield ++i;
    }
};
const idGen = () => {
    let stack = [id()];
    return {
        [Symbol.iterator]() {
            return this;
        },
        next() {
            return stack[0].next();
        },
        fork() {
            stack.unshift(id());
        },
        merge() {
            stack.shift();
        }
    };
};
const IndentedTap = Object.assign({}, Tap, {
    printTestStart(message) {
        const { data: { description }, offset } = message;
        this.printComment(`Subtest: ${description}`, offset);
    },
    printAssertion(message) {
        const { data, offset } = message;
        const { pass, description } = data;
        const label = pass === true ? 'ok' : 'not ok';
        const id = this.nextId();
        if (isAssertionResult$1(data)) {
            this.print(`${label} ${id} - ${description}`, offset);
            if (pass === false) {
                this.printYAML(indentedDiagnostic(data), offset);
            }
        }
        else {
            const comment = data.skip === true ? 'SKIP' : `${data.executionTime}ms`;
            this.print(`${pass ? 'ok' : 'not ok'} ${id} - ${description} # ${comment}`, message.offset);
        }
    },
    printTestEnd(message) {
        const length = message.data.length;
        const { offset } = message;
        this.print(`1..${length}`, offset);
    }
});
const factory$1 = (log) => {
    const id = idGen();
    return Object.create(IndentedTap, {
        nextId: {
            enumerable: true,
            value: () => {
                return id.next().value;
            }
        },
        report: {
            enumerable: true,
            value: async function (stream) {
                this.print('TAP version 13');
                let lastMessage = null;
                for await (const message of stream) {
                    lastMessage = message;
                    switch (message.type) {
                        case "TEST_START" /* TEST_START */:
                            id.fork();
                            this.printTestStart(message);
                            break;
                        case "ASSERTION" /* ASSERTION */:
                            this.printAssertion(message);
                            break;
                        case "TEST_END" /* TEST_END */:
                            id.merge();
                            this.printTestEnd(message);
                            break;
                        case "BAIL_OUT" /* BAIL_OUT */:
                            this.printBailOut(message);
                            throw message.data;
                    }
                }
                this.printSummary(lastMessage);
            }
        },
        log: { value: log }
    });
};

const report = (factory) => (logger = console) => {
    const log = logger.log.bind(logger);
    return async (stream) => factory(log).report(stream);
};
const tapReporter = report(factory);
const indentedTapReporter = report(factory$1);

//@ts-ignore
const mochaTapLike = indentedTapReporter();
//@ts-ignore
const tapeTapLike = tapReporter();

const harnessFactory = ({ runOnly = false, indent = false } = {
    runOnly: false,
    indent: false
}) => {
    const tests = [];
    const rootOffset = 0;
    const collect = item => tests.push(item);
    const api = assert(collect, rootOffset, runOnly);
    let error = null;
    const factory = testerLikeProvider(Object.assign(api, TesterPrototype, {
        report: async function (reporter) {
            const rep = reporter || (indent ? mochaTapLike : tapeTapLike);
            return rep(this);
        }
    }));
    return Object.defineProperties(factory(tests, Promise.resolve(), rootOffset), {
        error: {
            get() {
                return error;
            },
            set(val) {
                error = val;
            }
        }
    });
};

const findConfigurationFlag = (name) => {
    if (typeof process !== 'undefined') {
        return process.env[name] === 'true';
        // @ts-ignore
    }
    else if (typeof Deno !== 'undefined') {
        // @ts-ignore
        return Deno.env.get(name) === 'true';
        // @ts-ignore
    }
    else if (typeof window !== 'undefined') {
        // @ts-ignore
        return Boolean(window[name]);
    }
    return false;
};
const defaultTestHarness = harnessFactory({
    runOnly: findConfigurationFlag('RUN_ONLY')
});
let autoStart = true;
let indent = findConfigurationFlag('INDENT');
const rootTest = defaultTestHarness.test.bind(defaultTestHarness);
rootTest.indent = () => {
    console.warn('indent function is deprecated, use "INDENT" configuration flag instead');
    indent = true;
};
const test = rootTest;
const skip = defaultTestHarness.skip.bind(defaultTestHarness);
const only = defaultTestHarness.only.bind(defaultTestHarness);
rootTest.skip = skip;
const equal = defaultTestHarness.equal.bind(defaultTestHarness);
const equals = equal;
const eq = equal;
const deepEqual = equal;
const notEqual = defaultTestHarness.notEqual.bind(defaultTestHarness);
const notEquals = notEqual;
const notEq = notEqual;
const notDeepEqual = notEqual;
const is = defaultTestHarness.is.bind(defaultTestHarness);
const same = is;
const isNot = defaultTestHarness.isNot.bind(defaultTestHarness);
const notSame = isNot;
const ok = defaultTestHarness.ok.bind(defaultTestHarness);
const truthy = ok;
const notOk = defaultTestHarness.notOk.bind(defaultTestHarness);
const falsy = notOk;
const fail = defaultTestHarness.fail.bind(defaultTestHarness);
const throws = defaultTestHarness.throws.bind(defaultTestHarness);
const doesNotThrow = defaultTestHarness.doesNotThrow.bind(defaultTestHarness);
const createHarness = (opts = {}) => {
    autoStart = false;
    return harnessFactory(opts);
};
const start = () => {
    if (autoStart) {
        defaultTestHarness.report(indent ? mochaTapLike : tapeTapLike);
    }
};
// on next tick start reporting
// @ts-ignore
if (typeof window === 'undefined') {
    setTimeout(start, 0);
}
else {
    // @ts-ignore
    window.addEventListener('load', start);
}

exports.AssertPrototype = AssertPrototype;
exports.createHarness = createHarness;
exports.deepEqual = deepEqual;
exports.doesNotThrow = doesNotThrow;
exports.eq = eq;
exports.equal = equal;
exports.equals = equals;
exports.fail = fail;
exports.falsy = falsy;
exports.is = is;
exports.isNot = isNot;
exports.mochaTapLike = mochaTapLike;
exports.notDeepEqual = notDeepEqual;
exports.notEq = notEq;
exports.notEqual = notEqual;
exports.notEquals = notEquals;
exports.notOk = notOk;
exports.notSame = notSame;
exports.ok = ok;
exports.only = only;
exports.same = same;
exports.skip = skip;
exports.tapeTapLike = tapeTapLike;
exports.test = test;
exports.throws = throws;
exports.truthy = truthy;


/***/ }),

/***/ "./node_modules/fast-check/lib/arbitrary/_internals/ArrayArbitrary.js":
/*!****************************************************************************!*\
  !*** ./node_modules/fast-check/lib/arbitrary/_internals/ArrayArbitrary.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ArrayArbitrary = void 0;
const Stream_1 = __webpack_require__(/*! ../../stream/Stream */ "./node_modules/fast-check/lib/stream/Stream.js");
const symbols_1 = __webpack_require__(/*! ../../check/symbols */ "./node_modules/fast-check/lib/check/symbols.js");
const integer_1 = __webpack_require__(/*! ../integer */ "./node_modules/fast-check/lib/arbitrary/integer.js");
const LazyIterableIterator_1 = __webpack_require__(/*! ../../stream/LazyIterableIterator */ "./node_modules/fast-check/lib/stream/LazyIterableIterator.js");
const BuildCompareFilter_1 = __webpack_require__(/*! ./helpers/BuildCompareFilter */ "./node_modules/fast-check/lib/arbitrary/_internals/helpers/BuildCompareFilter.js");
const NextArbitrary_1 = __webpack_require__(/*! ../../check/arbitrary/definition/NextArbitrary */ "./node_modules/fast-check/lib/check/arbitrary/definition/NextArbitrary.js");
const Converters_1 = __webpack_require__(/*! ../../check/arbitrary/definition/Converters */ "./node_modules/fast-check/lib/check/arbitrary/definition/Converters.js");
const NextValue_1 = __webpack_require__(/*! ../../check/arbitrary/definition/NextValue */ "./node_modules/fast-check/lib/check/arbitrary/definition/NextValue.js");
class ArrayArbitrary extends NextArbitrary_1.NextArbitrary {
    constructor(arb, minLength, maxLength, isEqual) {
        super();
        this.arb = arb;
        this.minLength = minLength;
        this.maxLength = maxLength;
        this.isEqual = isEqual;
        this.lengthArb = Converters_1.convertToNext(integer_1.integer(minLength, maxLength));
        this.preFilter = this.isEqual !== undefined ? BuildCompareFilter_1.buildCompareFilter(this.isEqual) : (tab) => tab;
    }
    static makeItCloneable(vs, shrinkables) {
        vs[symbols_1.cloneMethod] = () => {
            const cloned = [];
            for (let idx = 0; idx !== shrinkables.length; ++idx) {
                cloned.push(shrinkables[idx].value);
            }
            this.makeItCloneable(cloned, shrinkables);
            return cloned;
        };
        return vs;
    }
    static canAppendItem(items, newItem, isEqual) {
        for (let idx = 0; idx !== items.length; ++idx) {
            if (isEqual(items[idx].value_, newItem.value_)) {
                return false;
            }
        }
        return true;
    }
    generateNItemsNoDuplicates(N, mrng, biasFactorItems) {
        let numSkippedInRow = 0;
        const items = [];
        while (items.length < N && numSkippedInRow < this.maxLength) {
            const current = this.arb.generate(mrng, biasFactorItems);
            if (this.isEqual === undefined || ArrayArbitrary.canAppendItem(items, current, this.isEqual)) {
                numSkippedInRow = 0;
                items.push(current);
            }
            else {
                numSkippedInRow += 1;
            }
        }
        return items;
    }
    generateNItems(N, mrng, biasFactorItems) {
        const items = [];
        for (let index = 0; index !== N; ++index) {
            const current = this.arb.generate(mrng, biasFactorItems);
            items.push(current);
        }
        return items;
    }
    wrapper(itemsRaw, shrunkOnce, itemsRawLengthContext) {
        const items = shrunkOnce ? this.preFilter(itemsRaw) : itemsRaw;
        let cloneable = false;
        const vs = [];
        const itemsContexts = [];
        for (let idx = 0; idx !== items.length; ++idx) {
            const s = items[idx];
            cloneable = cloneable || s.hasToBeCloned;
            vs.push(s.value);
            itemsContexts.push(s.context);
        }
        if (cloneable) {
            ArrayArbitrary.makeItCloneable(vs, items);
        }
        const context = {
            shrunkOnce,
            lengthContext: itemsRaw.length === items.length && itemsRawLengthContext !== undefined
                ? itemsRawLengthContext
                : undefined,
            itemsContexts,
        };
        return new NextValue_1.NextValue(vs, context);
    }
    generate(mrng, biasFactor) {
        const biasMeta = this.applyBias(mrng, biasFactor);
        const targetSize = biasMeta.size;
        const items = this.isEqual !== undefined
            ? this.generateNItemsNoDuplicates(targetSize, mrng, biasMeta.biasFactorItems)
            : this.generateNItems(targetSize, mrng, biasMeta.biasFactorItems);
        return this.wrapper(items, false, undefined);
    }
    applyBias(mrng, biasFactor) {
        if (biasFactor === undefined || mrng.nextInt(1, biasFactor) !== 1) {
            return { size: this.lengthArb.generate(mrng, undefined).value };
        }
        if (mrng.nextInt(1, biasFactor) !== 1 || this.minLength === this.maxLength) {
            return { size: this.lengthArb.generate(mrng, undefined).value, biasFactorItems: biasFactor };
        }
        const maxBiasedLength = this.minLength + Math.floor(Math.log(this.maxLength - this.minLength) / Math.log(2));
        const targetSizeValue = Converters_1.convertToNext(integer_1.integer(this.minLength, maxBiasedLength)).generate(mrng, undefined);
        return { size: targetSizeValue.value, biasFactorItems: biasFactor };
    }
    canShrinkWithoutContext(value) {
        if (!Array.isArray(value) || this.minLength > value.length || value.length > this.maxLength) {
            return false;
        }
        for (let index = 0; index !== value.length; ++index) {
            if (!(index in value)) {
                return false;
            }
            if (!this.arb.canShrinkWithoutContext(value[index])) {
                return false;
            }
        }
        const filtered = this.preFilter(value.map((item) => new NextValue_1.NextValue(item, undefined)));
        return filtered.length === value.length;
    }
    shrinkImpl(value, context) {
        if (value.length === 0) {
            return Stream_1.Stream.nil();
        }
        const safeContext = context !== undefined
            ? context
            : { shrunkOnce: false, lengthContext: undefined, itemsContexts: [] };
        return (this.lengthArb
            .shrink(value.length, safeContext.lengthContext)
            .drop(safeContext.shrunkOnce && safeContext.lengthContext === undefined && value.length > this.minLength + 1 ? 1 : 0)
            .map((lengthValue) => {
            const sliceStart = value.length - lengthValue.value;
            return [
                value
                    .slice(sliceStart)
                    .map((v, index) => new NextValue_1.NextValue(symbols_1.cloneIfNeeded(v), safeContext.itemsContexts[index + sliceStart])),
                lengthValue.context,
            ];
        })
            .join(this.arb.shrink(value[0], safeContext.itemsContexts[0]).map((v) => {
            return [
                [v].concat(value.slice(1).map((v, index) => new NextValue_1.NextValue(symbols_1.cloneIfNeeded(v), safeContext.itemsContexts[index + 1]))),
                undefined,
            ];
        }))
            .join(value.length > this.minLength
            ? LazyIterableIterator_1.makeLazy(() => this.shrinkImpl(value.slice(1), {
                shrunkOnce: false,
                lengthContext: undefined,
                itemsContexts: safeContext.itemsContexts.slice(1),
            })
                .filter((v) => this.minLength <= v[0].length + 1)
                .map((v) => {
                return [
                    [new NextValue_1.NextValue(symbols_1.cloneIfNeeded(value[0]), safeContext.itemsContexts[0])].concat(v[0]),
                    undefined,
                ];
            }))
            : Stream_1.Stream.nil()));
    }
    shrink(value, context) {
        return this.shrinkImpl(value, context).map((contextualValue) => this.wrapper(contextualValue[0], true, contextualValue[1]));
    }
}
exports.ArrayArbitrary = ArrayArbitrary;


/***/ }),

/***/ "./node_modules/fast-check/lib/arbitrary/_internals/BigIntArbitrary.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/fast-check/lib/arbitrary/_internals/BigIntArbitrary.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BigIntArbitrary = void 0;
const Stream_1 = __webpack_require__(/*! ../../stream/Stream */ "./node_modules/fast-check/lib/stream/Stream.js");
const NextArbitrary_1 = __webpack_require__(/*! ../../check/arbitrary/definition/NextArbitrary */ "./node_modules/fast-check/lib/check/arbitrary/definition/NextArbitrary.js");
const NextValue_1 = __webpack_require__(/*! ../../check/arbitrary/definition/NextValue */ "./node_modules/fast-check/lib/check/arbitrary/definition/NextValue.js");
const BiasNumericRange_1 = __webpack_require__(/*! ./helpers/BiasNumericRange */ "./node_modules/fast-check/lib/arbitrary/_internals/helpers/BiasNumericRange.js");
const ShrinkBigInt_1 = __webpack_require__(/*! ./helpers/ShrinkBigInt */ "./node_modules/fast-check/lib/arbitrary/_internals/helpers/ShrinkBigInt.js");
class BigIntArbitrary extends NextArbitrary_1.NextArbitrary {
    constructor(min, max) {
        super();
        this.min = min;
        this.max = max;
    }
    generate(mrng, biasFactor) {
        const range = this.computeGenerateRange(mrng, biasFactor);
        return new NextValue_1.NextValue(mrng.nextBigInt(range.min, range.max), undefined);
    }
    computeGenerateRange(mrng, biasFactor) {
        if (biasFactor === undefined || mrng.nextInt(1, biasFactor) !== 1) {
            return { min: this.min, max: this.max };
        }
        const ranges = BiasNumericRange_1.biasNumericRange(this.min, this.max, BiasNumericRange_1.bigIntLogLike);
        if (ranges.length === 1) {
            return ranges[0];
        }
        const id = mrng.nextInt(-2 * (ranges.length - 1), ranges.length - 2);
        return id < 0 ? ranges[0] : ranges[id + 1];
    }
    canShrinkWithoutContext(value) {
        return typeof value === 'bigint' && this.min <= value && value <= this.max;
    }
    shrink(current, context) {
        if (!BigIntArbitrary.isValidContext(current, context)) {
            const target = this.defaultTarget();
            return ShrinkBigInt_1.shrinkBigInt(current, target, true);
        }
        if (this.isLastChanceTry(current, context)) {
            return Stream_1.Stream.of(new NextValue_1.NextValue(context, undefined));
        }
        return ShrinkBigInt_1.shrinkBigInt(current, context, false);
    }
    defaultTarget() {
        if (this.min <= 0 && this.max >= 0) {
            return BigInt(0);
        }
        return this.min < 0 ? this.max : this.min;
    }
    isLastChanceTry(current, context) {
        if (current > 0)
            return current === context + BigInt(1) && current > this.min;
        if (current < 0)
            return current === context - BigInt(1) && current < this.max;
        return false;
    }
    static isValidContext(current, context) {
        if (context === undefined) {
            return false;
        }
        if (typeof context !== 'bigint') {
            throw new Error(`Invalid context type passed to BigIntArbitrary (#1)`);
        }
        const differentSigns = (current > 0 && context < 0) || (current < 0 && context > 0);
        if (context !== BigInt(0) && differentSigns) {
            throw new Error(`Invalid context value passed to BigIntArbitrary (#2)`);
        }
        return true;
    }
}
exports.BigIntArbitrary = BigIntArbitrary;


/***/ }),

/***/ "./node_modules/fast-check/lib/arbitrary/_internals/CloneArbitrary.js":
/*!****************************************************************************!*\
  !*** ./node_modules/fast-check/lib/arbitrary/_internals/CloneArbitrary.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CloneArbitrary = void 0;
const NextArbitrary_1 = __webpack_require__(/*! ../../check/arbitrary/definition/NextArbitrary */ "./node_modules/fast-check/lib/check/arbitrary/definition/NextArbitrary.js");
const NextValue_1 = __webpack_require__(/*! ../../check/arbitrary/definition/NextValue */ "./node_modules/fast-check/lib/check/arbitrary/definition/NextValue.js");
const symbols_1 = __webpack_require__(/*! ../../check/symbols */ "./node_modules/fast-check/lib/check/symbols.js");
const Stream_1 = __webpack_require__(/*! ../../stream/Stream */ "./node_modules/fast-check/lib/stream/Stream.js");
class CloneArbitrary extends NextArbitrary_1.NextArbitrary {
    constructor(arb, numValues) {
        super();
        this.arb = arb;
        this.numValues = numValues;
    }
    generate(mrng, biasFactor) {
        const items = [];
        if (this.numValues <= 0) {
            return this.wrapper(items);
        }
        for (let idx = 0; idx !== this.numValues - 1; ++idx) {
            items.push(this.arb.generate(mrng.clone(), biasFactor));
        }
        items.push(this.arb.generate(mrng, biasFactor));
        return this.wrapper(items);
    }
    canShrinkWithoutContext(value) {
        if (!Array.isArray(value) || value.length !== this.numValues) {
            return false;
        }
        if (value.length === 0) {
            return true;
        }
        for (let index = 1; index < value.length; ++index) {
            if (!Object.is(value[0], value[index])) {
                return false;
            }
        }
        return this.arb.canShrinkWithoutContext(value[0]);
    }
    shrink(value, context) {
        if (value.length === 0) {
            return Stream_1.Stream.nil();
        }
        return new Stream_1.Stream(this.shrinkImpl(value, context !== undefined ? context : [])).map((v) => this.wrapper(v));
    }
    *shrinkImpl(value, contexts) {
        const its = value.map((v, idx) => this.arb.shrink(v, contexts[idx])[Symbol.iterator]());
        let cur = its.map((it) => it.next());
        while (!cur[0].done) {
            yield cur.map((c) => c.value);
            cur = its.map((it) => it.next());
        }
    }
    static makeItCloneable(vs, shrinkables) {
        vs[symbols_1.cloneMethod] = () => {
            const cloned = [];
            for (let idx = 0; idx !== shrinkables.length; ++idx) {
                cloned.push(shrinkables[idx].value);
            }
            this.makeItCloneable(cloned, shrinkables);
            return cloned;
        };
        return vs;
    }
    wrapper(items) {
        let cloneable = false;
        const vs = [];
        const contexts = [];
        for (let idx = 0; idx !== items.length; ++idx) {
            const s = items[idx];
            cloneable = cloneable || s.hasToBeCloned;
            vs.push(s.value);
            contexts.push(s.context);
        }
        if (cloneable) {
            CloneArbitrary.makeItCloneable(vs, items);
        }
        return new NextValue_1.NextValue(vs, contexts);
    }
}
exports.CloneArbitrary = CloneArbitrary;


/***/ }),

/***/ "./node_modules/fast-check/lib/arbitrary/_internals/ConstantArbitrary.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/fast-check/lib/arbitrary/_internals/ConstantArbitrary.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ConstantArbitrary = void 0;
const Stream_1 = __webpack_require__(/*! ../../stream/Stream */ "./node_modules/fast-check/lib/stream/Stream.js");
const NextArbitrary_1 = __webpack_require__(/*! ../../check/arbitrary/definition/NextArbitrary */ "./node_modules/fast-check/lib/check/arbitrary/definition/NextArbitrary.js");
const NextValue_1 = __webpack_require__(/*! ../../check/arbitrary/definition/NextValue */ "./node_modules/fast-check/lib/check/arbitrary/definition/NextValue.js");
const symbols_1 = __webpack_require__(/*! ../../check/symbols */ "./node_modules/fast-check/lib/check/symbols.js");
class ConstantArbitrary extends NextArbitrary_1.NextArbitrary {
    constructor(values) {
        super();
        this.values = values;
    }
    generate(mrng, _biasFactor) {
        const idx = this.values.length === 1 ? 0 : mrng.nextInt(0, this.values.length - 1);
        const value = this.values[idx];
        if (!symbols_1.hasCloneMethod(value)) {
            return new NextValue_1.NextValue(value, idx);
        }
        return new NextValue_1.NextValue(value, idx, () => value[symbols_1.cloneMethod]());
    }
    canShrinkWithoutContext(value) {
        for (let idx = 0; idx !== this.values.length; ++idx) {
            if (Object.is(this.values[idx], value)) {
                return true;
            }
        }
        return false;
    }
    shrink(value, context) {
        if (context === 0 || Object.is(value, this.values[0])) {
            return Stream_1.Stream.nil();
        }
        return Stream_1.Stream.of(new NextValue_1.NextValue(this.values[0], 0));
    }
}
exports.ConstantArbitrary = ConstantArbitrary;


/***/ }),

/***/ "./node_modules/fast-check/lib/arbitrary/_internals/FrequencyArbitrary.js":
/*!********************************************************************************!*\
  !*** ./node_modules/fast-check/lib/arbitrary/_internals/FrequencyArbitrary.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FrequencyArbitrary = void 0;
const Stream_1 = __webpack_require__(/*! ../../stream/Stream */ "./node_modules/fast-check/lib/stream/Stream.js");
const Converters_1 = __webpack_require__(/*! ../../check/arbitrary/definition/Converters */ "./node_modules/fast-check/lib/check/arbitrary/definition/Converters.js");
const NextArbitrary_1 = __webpack_require__(/*! ../../check/arbitrary/definition/NextArbitrary */ "./node_modules/fast-check/lib/check/arbitrary/definition/NextArbitrary.js");
const NextValue_1 = __webpack_require__(/*! ../../check/arbitrary/definition/NextValue */ "./node_modules/fast-check/lib/check/arbitrary/definition/NextValue.js");
const DepthContext_1 = __webpack_require__(/*! ./helpers/DepthContext */ "./node_modules/fast-check/lib/arbitrary/_internals/helpers/DepthContext.js");
class FrequencyArbitrary extends NextArbitrary_1.NextArbitrary {
    constructor(warbs, constraints, context) {
        super();
        this.warbs = warbs;
        this.constraints = constraints;
        this.context = context;
        let currentWeight = 0;
        this.cumulatedWeights = [];
        for (let idx = 0; idx !== warbs.length; ++idx) {
            currentWeight += warbs[idx].weight;
            this.cumulatedWeights.push(currentWeight);
        }
        this.totalWeight = currentWeight;
    }
    static fromOld(warbs, constraints, label) {
        return Converters_1.convertFromNext(FrequencyArbitrary.from(warbs.map((w) => (Object.assign(Object.assign({}, w), { arbitrary: Converters_1.convertToNext(w.arbitrary) }))), constraints, label));
    }
    static from(warbs, constraints, label) {
        if (warbs.length === 0) {
            throw new Error(`${label} expects at least one weigthed arbitrary`);
        }
        let totalWeight = 0;
        for (let idx = 0; idx !== warbs.length; ++idx) {
            const currentArbitrary = warbs[idx].arbitrary;
            if (currentArbitrary === undefined) {
                throw new Error(`${label} expects arbitraries to be specified`);
            }
            const currentWeight = warbs[idx].weight;
            totalWeight += currentWeight;
            if (!Number.isInteger(currentWeight)) {
                throw new Error(`${label} expects weights to be integer values`);
            }
            if (currentWeight < 0) {
                throw new Error(`${label} expects weights to be superior or equal to 0`);
            }
        }
        if (totalWeight <= 0) {
            throw new Error(`${label} expects the sum of weights to be strictly superior to 0`);
        }
        return new FrequencyArbitrary(warbs, constraints, DepthContext_1.getDepthContextFor(constraints.depthIdentifier));
    }
    generate(mrng, biasFactor) {
        if (this.mustGenerateFirst()) {
            return this.safeGenerateForIndex(mrng, 0, biasFactor);
        }
        const selected = mrng.nextInt(this.computeNegDepthBenefit(), this.totalWeight - 1);
        for (let idx = 0; idx !== this.cumulatedWeights.length; ++idx) {
            if (selected < this.cumulatedWeights[idx]) {
                return this.safeGenerateForIndex(mrng, idx, biasFactor);
            }
        }
        throw new Error(`Unable to generate from fc.frequency`);
    }
    canShrinkWithoutContext(value) {
        return this.canShrinkWithoutContextIndex(value) !== -1;
    }
    shrink(value, context) {
        if (context !== undefined) {
            const safeContext = context;
            const selectedIndex = safeContext.selectedIndex;
            const originalBias = safeContext.originalBias;
            const originalArbitrary = this.warbs[selectedIndex].arbitrary;
            const originalShrinks = originalArbitrary
                .shrink(value, safeContext.originalContext)
                .map((v) => this.mapIntoNextValue(selectedIndex, v, null, originalBias));
            if (safeContext.clonedMrngForFallbackFirst !== null) {
                if (safeContext.cachedGeneratedForFirst === undefined) {
                    safeContext.cachedGeneratedForFirst = this.safeGenerateForIndex(safeContext.clonedMrngForFallbackFirst, 0, originalBias);
                }
                const valueFromFirst = safeContext.cachedGeneratedForFirst;
                return Stream_1.Stream.of(valueFromFirst).join(originalShrinks);
            }
            return originalShrinks;
        }
        const potentialSelectedIndex = this.canShrinkWithoutContextIndex(value);
        if (potentialSelectedIndex === -1) {
            return Stream_1.Stream.nil();
        }
        return this.defaultShrinkForFirst(potentialSelectedIndex).join(this.warbs[potentialSelectedIndex].arbitrary
            .shrink(value, undefined)
            .map((v) => this.mapIntoNextValue(potentialSelectedIndex, v, null, undefined)));
    }
    defaultShrinkForFirst(selectedIndex) {
        ++this.context.depth;
        try {
            if (!this.mustFallbackToFirstInShrink(selectedIndex) || this.warbs[0].fallbackValue === undefined) {
                return Stream_1.Stream.nil();
            }
        }
        finally {
            --this.context.depth;
        }
        const rawShrinkValue = new NextValue_1.NextValue(this.warbs[0].fallbackValue.default, undefined);
        return Stream_1.Stream.of(this.mapIntoNextValue(0, rawShrinkValue, null, undefined));
    }
    canShrinkWithoutContextIndex(value) {
        if (this.mustGenerateFirst()) {
            return this.warbs[0].arbitrary.canShrinkWithoutContext(value) ? 0 : -1;
        }
        try {
            ++this.context.depth;
            for (let idx = 0; idx !== this.warbs.length; ++idx) {
                const warb = this.warbs[idx];
                if (warb.weight !== 0 && warb.arbitrary.canShrinkWithoutContext(value)) {
                    return idx;
                }
            }
            return -1;
        }
        finally {
            --this.context.depth;
        }
    }
    mapIntoNextValue(idx, value, clonedMrngForFallbackFirst, biasFactor) {
        const context = {
            selectedIndex: idx,
            originalBias: biasFactor,
            originalContext: value.context,
            clonedMrngForFallbackFirst,
        };
        return new NextValue_1.NextValue(value.value, context);
    }
    safeGenerateForIndex(mrng, idx, biasFactor) {
        ++this.context.depth;
        try {
            const value = this.warbs[idx].arbitrary.generate(mrng, biasFactor);
            const clonedMrngForFallbackFirst = this.mustFallbackToFirstInShrink(idx) ? mrng.clone() : null;
            return this.mapIntoNextValue(idx, value, clonedMrngForFallbackFirst, biasFactor);
        }
        finally {
            --this.context.depth;
        }
    }
    mustGenerateFirst() {
        return this.constraints.maxDepth !== undefined && this.constraints.maxDepth <= this.context.depth;
    }
    mustFallbackToFirstInShrink(idx) {
        return idx !== 0 && !!this.constraints.withCrossShrink && this.warbs[0].weight !== 0;
    }
    computeNegDepthBenefit() {
        const depthFactor = this.constraints.depthFactor;
        if (depthFactor === undefined || depthFactor <= 0) {
            return 0;
        }
        const depthBenefit = Math.floor(Math.pow(1 + depthFactor, this.context.depth)) - 1;
        return -Math.min(this.warbs[0].weight * depthBenefit, Number.MAX_SAFE_INTEGER) || 0;
    }
}
exports.FrequencyArbitrary = FrequencyArbitrary;


/***/ }),

/***/ "./node_modules/fast-check/lib/arbitrary/_internals/IntegerArbitrary.js":
/*!******************************************************************************!*\
  !*** ./node_modules/fast-check/lib/arbitrary/_internals/IntegerArbitrary.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.IntegerArbitrary = void 0;
const NextArbitrary_1 = __webpack_require__(/*! ../../check/arbitrary/definition/NextArbitrary */ "./node_modules/fast-check/lib/check/arbitrary/definition/NextArbitrary.js");
const NextValue_1 = __webpack_require__(/*! ../../check/arbitrary/definition/NextValue */ "./node_modules/fast-check/lib/check/arbitrary/definition/NextValue.js");
const Stream_1 = __webpack_require__(/*! ../../stream/Stream */ "./node_modules/fast-check/lib/stream/Stream.js");
const BiasNumericRange_1 = __webpack_require__(/*! ./helpers/BiasNumericRange */ "./node_modules/fast-check/lib/arbitrary/_internals/helpers/BiasNumericRange.js");
const ShrinkInteger_1 = __webpack_require__(/*! ./helpers/ShrinkInteger */ "./node_modules/fast-check/lib/arbitrary/_internals/helpers/ShrinkInteger.js");
class IntegerArbitrary extends NextArbitrary_1.NextArbitrary {
    constructor(min, max) {
        super();
        this.min = min;
        this.max = max;
    }
    generate(mrng, biasFactor) {
        const range = this.computeGenerateRange(mrng, biasFactor);
        return new NextValue_1.NextValue(mrng.nextInt(range.min, range.max), undefined);
    }
    canShrinkWithoutContext(value) {
        return (typeof value === 'number' &&
            Number.isInteger(value) &&
            !Object.is(value, -0) &&
            this.min <= value &&
            value <= this.max);
    }
    shrink(current, context) {
        if (!IntegerArbitrary.isValidContext(current, context)) {
            const target = this.defaultTarget();
            return ShrinkInteger_1.shrinkInteger(current, target, true);
        }
        if (this.isLastChanceTry(current, context)) {
            return Stream_1.Stream.of(new NextValue_1.NextValue(context, undefined));
        }
        return ShrinkInteger_1.shrinkInteger(current, context, false);
    }
    defaultTarget() {
        if (this.min <= 0 && this.max >= 0) {
            return 0;
        }
        return this.min < 0 ? this.max : this.min;
    }
    computeGenerateRange(mrng, biasFactor) {
        if (biasFactor === undefined || mrng.nextInt(1, biasFactor) !== 1) {
            return { min: this.min, max: this.max };
        }
        const ranges = BiasNumericRange_1.biasNumericRange(this.min, this.max, BiasNumericRange_1.integerLogLike);
        if (ranges.length === 1) {
            return ranges[0];
        }
        const id = mrng.nextInt(-2 * (ranges.length - 1), ranges.length - 2);
        return id < 0 ? ranges[0] : ranges[id + 1];
    }
    isLastChanceTry(current, context) {
        if (current > 0)
            return current === context + 1 && current > this.min;
        if (current < 0)
            return current === context - 1 && current < this.max;
        return false;
    }
    static isValidContext(current, context) {
        if (context === undefined) {
            return false;
        }
        if (typeof context !== 'number') {
            throw new Error(`Invalid context type passed to IntegerArbitrary (#1)`);
        }
        if (context !== 0 && Math.sign(current) !== Math.sign(context)) {
            throw new Error(`Invalid context value passed to IntegerArbitrary (#2)`);
        }
        return true;
    }
}
exports.IntegerArbitrary = IntegerArbitrary;


/***/ }),

/***/ "./node_modules/fast-check/lib/arbitrary/_internals/LazyArbitrary.js":
/*!***************************************************************************!*\
  !*** ./node_modules/fast-check/lib/arbitrary/_internals/LazyArbitrary.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LazyArbitrary = void 0;
const NextArbitrary_1 = __webpack_require__(/*! ../../check/arbitrary/definition/NextArbitrary */ "./node_modules/fast-check/lib/check/arbitrary/definition/NextArbitrary.js");
class LazyArbitrary extends NextArbitrary_1.NextArbitrary {
    constructor(name) {
        super();
        this.name = name;
        this.underlying = null;
    }
    generate(mrng, biasFactor) {
        if (!this.underlying) {
            throw new Error(`Lazy arbitrary ${JSON.stringify(this.name)} not correctly initialized`);
        }
        return this.underlying.generate(mrng, biasFactor);
    }
    canShrinkWithoutContext(value) {
        if (!this.underlying) {
            throw new Error(`Lazy arbitrary ${JSON.stringify(this.name)} not correctly initialized`);
        }
        return this.underlying.canShrinkWithoutContext(value);
    }
    shrink(value, context) {
        if (!this.underlying) {
            throw new Error(`Lazy arbitrary ${JSON.stringify(this.name)} not correctly initialized`);
        }
        return this.underlying.shrink(value, context);
    }
}
exports.LazyArbitrary = LazyArbitrary;


/***/ }),

/***/ "./node_modules/fast-check/lib/arbitrary/_internals/MixedCaseArbitrary.js":
/*!********************************************************************************!*\
  !*** ./node_modules/fast-check/lib/arbitrary/_internals/MixedCaseArbitrary.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MixedCaseArbitrary = exports.computeNextFlags = exports.countToggledBits = void 0;
const Stream_1 = __webpack_require__(/*! ../../stream/Stream */ "./node_modules/fast-check/lib/stream/Stream.js");
const bigUintN_1 = __webpack_require__(/*! ../bigUintN */ "./node_modules/fast-check/lib/arbitrary/bigUintN.js");
const NextArbitrary_1 = __webpack_require__(/*! ../../check/arbitrary/definition/NextArbitrary */ "./node_modules/fast-check/lib/check/arbitrary/definition/NextArbitrary.js");
const Converters_1 = __webpack_require__(/*! ../../check/arbitrary/definition/Converters */ "./node_modules/fast-check/lib/check/arbitrary/definition/Converters.js");
const NextValue_1 = __webpack_require__(/*! ../../check/arbitrary/definition/NextValue */ "./node_modules/fast-check/lib/check/arbitrary/definition/NextValue.js");
const LazyIterableIterator_1 = __webpack_require__(/*! ../../stream/LazyIterableIterator */ "./node_modules/fast-check/lib/stream/LazyIterableIterator.js");
function countToggledBits(n) {
    let count = 0;
    while (n > BigInt(0)) {
        if (n & BigInt(1))
            ++count;
        n >>= BigInt(1);
    }
    return count;
}
exports.countToggledBits = countToggledBits;
function computeNextFlags(flags, nextSize) {
    const allowedMask = (BigInt(1) << BigInt(nextSize)) - BigInt(1);
    const preservedFlags = flags & allowedMask;
    let numMissingFlags = countToggledBits(flags - preservedFlags);
    let nFlags = preservedFlags;
    for (let mask = BigInt(1); mask <= allowedMask && numMissingFlags !== 0; mask <<= BigInt(1)) {
        if (!(nFlags & mask)) {
            nFlags |= mask;
            --numMissingFlags;
        }
    }
    return nFlags;
}
exports.computeNextFlags = computeNextFlags;
class MixedCaseArbitrary extends NextArbitrary_1.NextArbitrary {
    constructor(stringArb, toggleCase) {
        super();
        this.stringArb = stringArb;
        this.toggleCase = toggleCase;
    }
    computeTogglePositions(chars) {
        const positions = [];
        for (let idx = 0; idx !== chars.length; ++idx) {
            if (this.toggleCase(chars[idx]) !== chars[idx])
                positions.push(idx);
        }
        return positions;
    }
    applyFlagsOnChars(chars, flags, togglePositions) {
        for (let idx = 0, mask = BigInt(1); idx !== togglePositions.length; ++idx, mask <<= BigInt(1)) {
            if (flags & mask)
                chars[togglePositions[idx]] = this.toggleCase(chars[togglePositions[idx]]);
        }
        return chars;
    }
    buildContextFor(rawStringNextValue, flagsNextValue) {
        return {
            rawString: rawStringNextValue.value,
            rawStringContext: rawStringNextValue.context,
            flags: flagsNextValue.value,
            flagsContext: flagsNextValue.context,
        };
    }
    generate(mrng, biasFactor) {
        const rawStringNextValue = this.stringArb.generate(mrng, biasFactor);
        const chars = [...rawStringNextValue.value];
        const togglePositions = this.computeTogglePositions(chars);
        const flagsArb = Converters_1.convertToNext(bigUintN_1.bigUintN(togglePositions.length));
        const flagsNextValue = flagsArb.generate(mrng, undefined);
        this.applyFlagsOnChars(chars, flagsNextValue.value, togglePositions);
        return new NextValue_1.NextValue(chars.join(''), this.buildContextFor(rawStringNextValue, flagsNextValue));
    }
    canShrinkWithoutContext(value) {
        return false;
    }
    shrink(_value, context) {
        if (context === undefined) {
            return Stream_1.Stream.nil();
        }
        const contextSafe = context;
        const rawString = contextSafe.rawString;
        const flags = contextSafe.flags;
        return this.stringArb
            .shrink(rawString, contextSafe.rawStringContext)
            .map((nRawStringNextValue) => {
            const nChars = [...nRawStringNextValue.value];
            const nTogglePositions = this.computeTogglePositions(nChars);
            const nFlags = computeNextFlags(flags, nTogglePositions.length);
            this.applyFlagsOnChars(nChars, nFlags, nTogglePositions);
            return new NextValue_1.NextValue(nChars.join(''), this.buildContextFor(nRawStringNextValue, new NextValue_1.NextValue(nFlags, undefined)));
        })
            .join(LazyIterableIterator_1.makeLazy(() => {
            const chars = [...rawString];
            const togglePositions = this.computeTogglePositions(chars);
            return Converters_1.convertToNext(bigUintN_1.bigUintN(togglePositions.length))
                .shrink(flags, contextSafe.flagsContext)
                .map((nFlagsNextValue) => {
                const nChars = chars.slice();
                this.applyFlagsOnChars(nChars, nFlagsNextValue.value, togglePositions);
                return new NextValue_1.NextValue(nChars.join(''), this.buildContextFor(new NextValue_1.NextValue(rawString, contextSafe.rawStringContext), nFlagsNextValue));
            });
        }));
    }
}
exports.MixedCaseArbitrary = MixedCaseArbitrary;


/***/ }),

/***/ "./node_modules/fast-check/lib/arbitrary/_internals/SchedulerArbitrary.js":
/*!********************************************************************************!*\
  !*** ./node_modules/fast-check/lib/arbitrary/_internals/SchedulerArbitrary.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SchedulerArbitrary = void 0;
const NextArbitrary_1 = __webpack_require__(/*! ../../check/arbitrary/definition/NextArbitrary */ "./node_modules/fast-check/lib/check/arbitrary/definition/NextArbitrary.js");
const NextValue_1 = __webpack_require__(/*! ../../check/arbitrary/definition/NextValue */ "./node_modules/fast-check/lib/check/arbitrary/definition/NextValue.js");
const Stream_1 = __webpack_require__(/*! ../../stream/Stream */ "./node_modules/fast-check/lib/stream/Stream.js");
const SchedulerImplem_1 = __webpack_require__(/*! ./implementations/SchedulerImplem */ "./node_modules/fast-check/lib/arbitrary/_internals/implementations/SchedulerImplem.js");
function buildNextTaskIndex(mrng) {
    const clonedMrng = mrng.clone();
    return {
        clone: () => buildNextTaskIndex(clonedMrng),
        nextTaskIndex: (scheduledTasks) => {
            return mrng.nextInt(0, scheduledTasks.length - 1);
        },
    };
}
class SchedulerArbitrary extends NextArbitrary_1.NextArbitrary {
    constructor(act) {
        super();
        this.act = act;
    }
    generate(mrng, _biasFactor) {
        return new NextValue_1.NextValue(new SchedulerImplem_1.SchedulerImplem(this.act, buildNextTaskIndex(mrng.clone())), undefined);
    }
    canShrinkWithoutContext(value) {
        return false;
    }
    shrink(_value, _context) {
        return Stream_1.Stream.nil();
    }
}
exports.SchedulerArbitrary = SchedulerArbitrary;


/***/ }),

/***/ "./node_modules/fast-check/lib/arbitrary/_internals/StreamArbitrary.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/fast-check/lib/arbitrary/_internals/StreamArbitrary.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.StreamArbitrary = void 0;
const NextArbitrary_1 = __webpack_require__(/*! ../../check/arbitrary/definition/NextArbitrary */ "./node_modules/fast-check/lib/check/arbitrary/definition/NextArbitrary.js");
const NextValue_1 = __webpack_require__(/*! ../../check/arbitrary/definition/NextValue */ "./node_modules/fast-check/lib/check/arbitrary/definition/NextValue.js");
const symbols_1 = __webpack_require__(/*! ../../check/symbols */ "./node_modules/fast-check/lib/check/symbols.js");
const Stream_1 = __webpack_require__(/*! ../../stream/Stream */ "./node_modules/fast-check/lib/stream/Stream.js");
const stringify_1 = __webpack_require__(/*! ../../utils/stringify */ "./node_modules/fast-check/lib/utils/stringify.js");
function prettyPrint(seenValuesStrings) {
    return `Stream(${seenValuesStrings.join(',')})`;
}
class StreamArbitrary extends NextArbitrary_1.NextArbitrary {
    constructor(arb) {
        super();
        this.arb = arb;
    }
    generate(mrng, biasFactor) {
        const appliedBiasFactor = biasFactor !== undefined && mrng.nextInt(1, biasFactor) === 1 ? biasFactor : undefined;
        const enrichedProducer = () => {
            const seenValues = [];
            const g = function* (arb, clonedMrng) {
                while (true) {
                    const value = arb.generate(clonedMrng, appliedBiasFactor).value;
                    seenValues.push(value);
                    yield value;
                }
            };
            const s = new Stream_1.Stream(g(this.arb, mrng.clone()));
            return Object.defineProperties(s, {
                toString: { value: () => prettyPrint(seenValues.map(stringify_1.stringify)) },
                [stringify_1.toStringMethod]: { value: () => prettyPrint(seenValues.map(stringify_1.stringify)) },
                [stringify_1.asyncToStringMethod]: { value: async () => prettyPrint(await Promise.all(seenValues.map(stringify_1.asyncStringify))) },
                [symbols_1.cloneMethod]: { value: enrichedProducer, enumerable: true },
            });
        };
        return new NextValue_1.NextValue(enrichedProducer(), undefined);
    }
    canShrinkWithoutContext(value) {
        return false;
    }
    shrink(_value, _context) {
        return Stream_1.Stream.nil();
    }
}
exports.StreamArbitrary = StreamArbitrary;


/***/ }),

/***/ "./node_modules/fast-check/lib/arbitrary/_internals/TupleArbitrary.js":
/*!****************************************************************************!*\
  !*** ./node_modules/fast-check/lib/arbitrary/_internals/TupleArbitrary.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TupleArbitrary = void 0;
const Stream_1 = __webpack_require__(/*! ../../stream/Stream */ "./node_modules/fast-check/lib/stream/Stream.js");
const symbols_1 = __webpack_require__(/*! ../../check/symbols */ "./node_modules/fast-check/lib/check/symbols.js");
const NextArbitrary_1 = __webpack_require__(/*! ../../check/arbitrary/definition/NextArbitrary */ "./node_modules/fast-check/lib/check/arbitrary/definition/NextArbitrary.js");
const NextValue_1 = __webpack_require__(/*! ../../check/arbitrary/definition/NextValue */ "./node_modules/fast-check/lib/check/arbitrary/definition/NextValue.js");
class TupleArbitrary extends NextArbitrary_1.NextArbitrary {
    constructor(arbs) {
        super();
        this.arbs = arbs;
        for (let idx = 0; idx !== arbs.length; ++idx) {
            const arb = arbs[idx];
            if (arb == null || arb.generate == null)
                throw new Error(`Invalid parameter encountered at index ${idx}: expecting an Arbitrary`);
        }
    }
    static makeItCloneable(vs, values) {
        return Object.defineProperty(vs, symbols_1.cloneMethod, {
            value: () => {
                const cloned = [];
                for (let idx = 0; idx !== values.length; ++idx) {
                    cloned.push(values[idx].value);
                }
                TupleArbitrary.makeItCloneable(cloned, values);
                return cloned;
            },
        });
    }
    static wrapper(values) {
        let cloneable = false;
        const vs = [];
        const ctxs = [];
        for (let idx = 0; idx !== values.length; ++idx) {
            const v = values[idx];
            cloneable = cloneable || v.hasToBeCloned;
            vs.push(v.value);
            ctxs.push(v.context);
        }
        if (cloneable) {
            TupleArbitrary.makeItCloneable(vs, values);
        }
        return new NextValue_1.NextValue(vs, ctxs);
    }
    generate(mrng, biasFactor) {
        return TupleArbitrary.wrapper(this.arbs.map((a) => a.generate(mrng, biasFactor)));
    }
    canShrinkWithoutContext(value) {
        if (!Array.isArray(value) || value.length !== this.arbs.length) {
            return false;
        }
        for (let index = 0; index !== this.arbs.length; ++index) {
            if (!this.arbs[index].canShrinkWithoutContext(value[index])) {
                return false;
            }
        }
        return true;
    }
    shrink(value, context) {
        let s = Stream_1.Stream.nil();
        const safeContext = Array.isArray(context) ? context : [];
        for (let idx = 0; idx !== this.arbs.length; ++idx) {
            const shrinksForIndex = this.arbs[idx]
                .shrink(value[idx], safeContext[idx])
                .map((v) => {
                const nextValues = value.map((v, idx) => new NextValue_1.NextValue(symbols_1.cloneIfNeeded(v), safeContext[idx]));
                return nextValues
                    .slice(0, idx)
                    .concat([v])
                    .concat(nextValues.slice(idx + 1));
            })
                .map((values) => TupleArbitrary.wrapper(values));
            s = s.join(shrinksForIndex);
        }
        return s;
    }
}
exports.TupleArbitrary = TupleArbitrary;


/***/ }),

/***/ "./node_modules/fast-check/lib/arbitrary/_internals/builders/CharacterArbitraryBuilder.js":
/*!************************************************************************************************!*\
  !*** ./node_modules/fast-check/lib/arbitrary/_internals/builders/CharacterArbitraryBuilder.js ***!
  \************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.buildCharacterArbitrary = void 0;
const Converters_1 = __webpack_require__(/*! ../../../check/arbitrary/definition/Converters */ "./node_modules/fast-check/lib/check/arbitrary/definition/Converters.js");
const integer_1 = __webpack_require__(/*! ../../integer */ "./node_modules/fast-check/lib/arbitrary/integer.js");
const IndexToCharString_1 = __webpack_require__(/*! ../mappers/IndexToCharString */ "./node_modules/fast-check/lib/arbitrary/_internals/mappers/IndexToCharString.js");
function buildCharacterArbitrary(min, max, mapToCode, unmapFromCode) {
    return Converters_1.convertFromNext(Converters_1.convertToNext(integer_1.integer(min, max)).map((n) => IndexToCharString_1.indexToCharStringMapper(mapToCode(n)), (c) => unmapFromCode(IndexToCharString_1.indexToCharStringUnmapper(c))));
}
exports.buildCharacterArbitrary = buildCharacterArbitrary;


/***/ }),

/***/ "./node_modules/fast-check/lib/arbitrary/_internals/builders/CompareFunctionArbitraryBuilder.js":
/*!******************************************************************************************************!*\
  !*** ./node_modules/fast-check/lib/arbitrary/_internals/builders/CompareFunctionArbitraryBuilder.js ***!
  \******************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.buildCompareFunctionArbitrary = void 0;
const TextEscaper_1 = __webpack_require__(/*! ../../../check/arbitrary/helpers/TextEscaper */ "./node_modules/fast-check/lib/check/arbitrary/helpers/TextEscaper.js");
const symbols_1 = __webpack_require__(/*! ../../../check/symbols */ "./node_modules/fast-check/lib/check/symbols.js");
const hash_1 = __webpack_require__(/*! ../../../utils/hash */ "./node_modules/fast-check/lib/utils/hash.js");
const stringify_1 = __webpack_require__(/*! ../../../utils/stringify */ "./node_modules/fast-check/lib/utils/stringify.js");
const integer_1 = __webpack_require__(/*! ../../integer */ "./node_modules/fast-check/lib/arbitrary/integer.js");
const tuple_1 = __webpack_require__(/*! ../../tuple */ "./node_modules/fast-check/lib/arbitrary/tuple.js");
function buildCompareFunctionArbitrary(cmp) {
    return tuple_1.tuple(integer_1.integer().noShrink(), integer_1.integer(1, 0xffffffff).noShrink()).map(([seed, hashEnvSize]) => {
        const producer = () => {
            const recorded = {};
            const f = (a, b) => {
                const reprA = stringify_1.stringify(a);
                const reprB = stringify_1.stringify(b);
                const hA = hash_1.hash(`${seed}${reprA}`) % hashEnvSize;
                const hB = hash_1.hash(`${seed}${reprB}`) % hashEnvSize;
                const val = cmp(hA, hB);
                recorded[`[${reprA},${reprB}]`] = val;
                return val;
            };
            return Object.assign(f, {
                toString: () => {
                    const seenValues = Object.keys(recorded)
                        .sort()
                        .map((k) => `${k} => ${stringify_1.stringify(recorded[k])}`)
                        .map((line) => `/* ${TextEscaper_1.escapeForMultilineComments(line)} */`);
                    return `function(a, b) {
  // With hash and stringify coming from fast-check${seenValues.length !== 0 ? `\n  ${seenValues.join('\n  ')}` : ''}
  const cmp = ${cmp};
  const hA = hash('${seed}' + stringify(a)) % ${hashEnvSize};
  const hB = hash('${seed}' + stringify(b)) % ${hashEnvSize};
  return cmp(hA, hB);
}`;
                },
                [symbols_1.cloneMethod]: producer,
            });
        };
        return producer();
    });
}
exports.buildCompareFunctionArbitrary = buildCompareFunctionArbitrary;


/***/ }),

/***/ "./node_modules/fast-check/lib/arbitrary/_internals/builders/PartialRecordArbitraryBuilder.js":
/*!****************************************************************************************************!*\
  !*** ./node_modules/fast-check/lib/arbitrary/_internals/builders/PartialRecordArbitraryBuilder.js ***!
  \****************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.buildPartialRecordArbitrary = void 0;
const Converters_1 = __webpack_require__(/*! ../../../check/arbitrary/definition/Converters */ "./node_modules/fast-check/lib/check/arbitrary/definition/Converters.js");
const option_1 = __webpack_require__(/*! ../../option */ "./node_modules/fast-check/lib/arbitrary/option.js");
const tuple_1 = __webpack_require__(/*! ../../tuple */ "./node_modules/fast-check/lib/arbitrary/tuple.js");
const EnumerableKeysExtractor_1 = __webpack_require__(/*! ../helpers/EnumerableKeysExtractor */ "./node_modules/fast-check/lib/arbitrary/_internals/helpers/EnumerableKeysExtractor.js");
const ValuesAndSeparateKeysToObject_1 = __webpack_require__(/*! ../mappers/ValuesAndSeparateKeysToObject */ "./node_modules/fast-check/lib/arbitrary/_internals/mappers/ValuesAndSeparateKeysToObject.js");
const noKeyValue = Symbol('no-key');
function buildPartialRecordArbitrary(recordModel, requiredKeys) {
    const keys = EnumerableKeysExtractor_1.extractEnumerableKeys(recordModel);
    const arbs = [];
    for (let index = 0; index !== keys.length; ++index) {
        const k = keys[index];
        const requiredArbitrary = recordModel[k];
        if (requiredKeys === undefined || requiredKeys.indexOf(k) !== -1)
            arbs.push(requiredArbitrary);
        else
            arbs.push(option_1.option(requiredArbitrary, { nil: noKeyValue }));
    }
    return Converters_1.convertFromNext(Converters_1.convertToNext(tuple_1.tuple(...arbs)).map(ValuesAndSeparateKeysToObject_1.buildValuesAndSeparateKeysToObjectMapper(keys, noKeyValue), ValuesAndSeparateKeysToObject_1.buildValuesAndSeparateKeysToObjectUnmapper(keys, noKeyValue)));
}
exports.buildPartialRecordArbitrary = buildPartialRecordArbitrary;


/***/ }),

/***/ "./node_modules/fast-check/lib/arbitrary/_internals/builders/StringifiedNatArbitraryBuilder.js":
/*!*****************************************************************************************************!*\
  !*** ./node_modules/fast-check/lib/arbitrary/_internals/builders/StringifiedNatArbitraryBuilder.js ***!
  \*****************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.buildStringifiedNatArbitrary = void 0;
const Converters_1 = __webpack_require__(/*! ../../../check/arbitrary/definition/Converters */ "./node_modules/fast-check/lib/check/arbitrary/definition/Converters.js");
const constantFrom_1 = __webpack_require__(/*! ../../constantFrom */ "./node_modules/fast-check/lib/arbitrary/constantFrom.js");
const nat_1 = __webpack_require__(/*! ../../nat */ "./node_modules/fast-check/lib/arbitrary/nat.js");
const tuple_1 = __webpack_require__(/*! ../../tuple */ "./node_modules/fast-check/lib/arbitrary/tuple.js");
const NatToStringifiedNat_1 = __webpack_require__(/*! ../mappers/NatToStringifiedNat */ "./node_modules/fast-check/lib/arbitrary/_internals/mappers/NatToStringifiedNat.js");
function buildStringifiedNatArbitrary(maxValue) {
    return Converters_1.convertFromNext(Converters_1.convertToNext(tuple_1.tuple(constantFrom_1.constantFrom('dec', 'oct', 'hex'), nat_1.nat(maxValue))).map(NatToStringifiedNat_1.natToStringifiedNatMapper, NatToStringifiedNat_1.natToStringifiedNatUnmapper));
}
exports.buildStringifiedNatArbitrary = buildStringifiedNatArbitrary;


/***/ }),

/***/ "./node_modules/fast-check/lib/arbitrary/_internals/builders/TypedIntArrayArbitraryBuilder.js":
/*!****************************************************************************************************!*\
  !*** ./node_modules/fast-check/lib/arbitrary/_internals/builders/TypedIntArrayArbitraryBuilder.js ***!
  \****************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.typedIntArrayArbitraryArbitraryBuilder = void 0;
const array_1 = __webpack_require__(/*! ../../array */ "./node_modules/fast-check/lib/arbitrary/array.js");
function typedIntArrayArbitraryArbitraryBuilder(constraints, defaultMin, defaultMax, TypedArrayClass, arbitraryBuilder) {
    const generatorName = TypedArrayClass.name;
    const { min = defaultMin, max = defaultMax } = constraints, arrayConstraints = __rest(constraints, ["min", "max"]);
    if (min > max) {
        throw new Error(`Invalid range passed to ${generatorName}: min must be lower than or equal to max`);
    }
    if (min < defaultMin) {
        throw new Error(`Invalid min value passed to ${generatorName}: min must be greater than or equal to ${defaultMin}`);
    }
    if (max > defaultMax) {
        throw new Error(`Invalid max value passed to ${generatorName}: max must be lower than or equal to ${defaultMax}`);
    }
    return array_1.array(arbitraryBuilder({ min, max }), arrayConstraints).map((data) => TypedArrayClass.from(data));
}
exports.typedIntArrayArbitraryArbitraryBuilder = typedIntArrayArbitraryArbitraryBuilder;


/***/ }),

/***/ "./node_modules/fast-check/lib/arbitrary/_internals/helpers/BiasNumericRange.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/fast-check/lib/arbitrary/_internals/helpers/BiasNumericRange.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.biasNumericRange = exports.bigIntLogLike = exports.integerLogLike = void 0;
function integerLogLike(v) {
    return Math.floor(Math.log(v) / Math.log(2));
}
exports.integerLogLike = integerLogLike;
function bigIntLogLike(v) {
    if (v === BigInt(0))
        return BigInt(0);
    return BigInt(v.toString().length);
}
exports.bigIntLogLike = bigIntLogLike;
function biasNumericRange(min, max, logLike) {
    if (min === max) {
        return [{ min: min, max: max }];
    }
    if (min < 0 && max > 0) {
        const logMin = logLike(-min);
        const logMax = logLike(max);
        return [
            { min: -logMin, max: logMax },
            { min: (max - logMax), max: max },
            { min: min, max: min + logMin },
        ];
    }
    const logGap = logLike((max - min));
    const arbCloseToMin = { min: min, max: min + logGap };
    const arbCloseToMax = { min: (max - logGap), max: max };
    return min < 0
        ? [arbCloseToMax, arbCloseToMin]
        : [arbCloseToMin, arbCloseToMax];
}
exports.biasNumericRange = biasNumericRange;


/***/ }),

/***/ "./node_modules/fast-check/lib/arbitrary/_internals/helpers/BuildCompareFilter.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/fast-check/lib/arbitrary/_internals/helpers/BuildCompareFilter.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.buildCompareFilter = void 0;
function subArrayContains(tab, upperBound, includeValue) {
    for (let idx = 0; idx < upperBound; ++idx) {
        if (includeValue(tab[idx]))
            return true;
    }
    return false;
}
function swap(tab, idx1, idx2) {
    const temp = tab[idx1];
    tab[idx1] = tab[idx2];
    tab[idx2] = temp;
}
function buildCompareFilter(compare) {
    return (tab) => {
        let finalLength = tab.length;
        for (let idx = tab.length - 1; idx !== -1; --idx) {
            if (subArrayContains(tab, idx, (t) => compare(t.value_, tab[idx].value_))) {
                --finalLength;
                swap(tab, idx, finalLength);
            }
        }
        return tab.slice(0, finalLength);
    };
}
exports.buildCompareFilter = buildCompareFilter;


/***/ }),

/***/ "./node_modules/fast-check/lib/arbitrary/_internals/helpers/BuildSchedulerFor.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/fast-check/lib/arbitrary/_internals/helpers/BuildSchedulerFor.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.buildSchedulerFor = void 0;
const SchedulerImplem_1 = __webpack_require__(/*! ../implementations/SchedulerImplem */ "./node_modules/fast-check/lib/arbitrary/_internals/implementations/SchedulerImplem.js");
function buildNextTaskIndex(ordering) {
    let numTasks = 0;
    return {
        clone: () => buildNextTaskIndex(ordering),
        nextTaskIndex: (scheduledTasks) => {
            if (ordering.length <= numTasks) {
                throw new Error(`Invalid schedulerFor defined: too many tasks have been scheduled`);
            }
            const taskIndex = scheduledTasks.findIndex((t) => t.taskId === ordering[numTasks]);
            if (taskIndex === -1) {
                throw new Error(`Invalid schedulerFor defined: unable to find next task`);
            }
            ++numTasks;
            return taskIndex;
        },
    };
}
function buildSchedulerFor(act, ordering) {
    return new SchedulerImplem_1.SchedulerImplem(act, buildNextTaskIndex(ordering));
}
exports.buildSchedulerFor = buildSchedulerFor;


/***/ }),

/***/ "./node_modules/fast-check/lib/arbitrary/_internals/helpers/DepthContext.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/fast-check/lib/arbitrary/_internals/helpers/DepthContext.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getDepthContextFor = void 0;
const depthContextCache = new Map();
function getDepthContextFor(contextMeta) {
    if (contextMeta === undefined) {
        return { depth: 0 };
    }
    if (typeof contextMeta !== 'string') {
        return contextMeta;
    }
    const cachedContext = depthContextCache.get(contextMeta);
    if (cachedContext !== undefined) {
        return cachedContext;
    }
    const context = { depth: 0 };
    depthContextCache.set(contextMeta, context);
    return context;
}
exports.getDepthContextFor = getDepthContextFor;


/***/ }),

/***/ "./node_modules/fast-check/lib/arbitrary/_internals/helpers/EnumerableKeysExtractor.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/fast-check/lib/arbitrary/_internals/helpers/EnumerableKeysExtractor.js ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.extractEnumerableKeys = void 0;
function extractEnumerableKeys(instance) {
    const keys = Object.keys(instance);
    const symbols = Object.getOwnPropertySymbols(instance);
    for (let index = 0; index !== symbols.length; ++index) {
        const symbol = symbols[index];
        const descriptor = Object.getOwnPropertyDescriptor(instance, symbol);
        if (descriptor && descriptor.enumerable) {
            keys.push(symbol);
        }
    }
    return keys;
}
exports.extractEnumerableKeys = extractEnumerableKeys;


/***/ }),

/***/ "./node_modules/fast-check/lib/arbitrary/_internals/helpers/MaxLengthFromMinLength.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/fast-check/lib/arbitrary/_internals/helpers/MaxLengthFromMinLength.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.maxLengthFromMinLength = void 0;
function maxLengthFromMinLength(minLength) {
    return 2 * minLength + 10;
}
exports.maxLengthFromMinLength = maxLengthFromMinLength;


/***/ }),

/***/ "./node_modules/fast-check/lib/arbitrary/_internals/helpers/ShrinkBigInt.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/fast-check/lib/arbitrary/_internals/helpers/ShrinkBigInt.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.shrinkBigInt = void 0;
const Stream_1 = __webpack_require__(/*! ../../../stream/Stream */ "./node_modules/fast-check/lib/stream/Stream.js");
const NextValue_1 = __webpack_require__(/*! ../../../check/arbitrary/definition/NextValue */ "./node_modules/fast-check/lib/check/arbitrary/definition/NextValue.js");
function halveBigInt(n) {
    return n / BigInt(2);
}
function shrinkBigInt(current, target, tryTargetAsap) {
    const realGap = current - target;
    function* shrinkDecr() {
        let previous = tryTargetAsap ? undefined : target;
        const gap = tryTargetAsap ? realGap : halveBigInt(realGap);
        for (let toremove = gap; toremove > 0; toremove = halveBigInt(toremove)) {
            const next = current - toremove;
            yield new NextValue_1.NextValue(next, previous);
            previous = next;
        }
    }
    function* shrinkIncr() {
        let previous = tryTargetAsap ? undefined : target;
        const gap = tryTargetAsap ? realGap : halveBigInt(realGap);
        for (let toremove = gap; toremove < 0; toremove = halveBigInt(toremove)) {
            const next = current - toremove;
            yield new NextValue_1.NextValue(next, previous);
            previous = next;
        }
    }
    return realGap > 0 ? Stream_1.stream(shrinkDecr()) : Stream_1.stream(shrinkIncr());
}
exports.shrinkBigInt = shrinkBigInt;


/***/ }),

/***/ "./node_modules/fast-check/lib/arbitrary/_internals/helpers/ShrinkInteger.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/fast-check/lib/arbitrary/_internals/helpers/ShrinkInteger.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.shrinkInteger = void 0;
const NextValue_1 = __webpack_require__(/*! ../../../check/arbitrary/definition/NextValue */ "./node_modules/fast-check/lib/check/arbitrary/definition/NextValue.js");
const Stream_1 = __webpack_require__(/*! ../../../stream/Stream */ "./node_modules/fast-check/lib/stream/Stream.js");
function halvePosInteger(n) {
    return Math.floor(n / 2);
}
function halveNegInteger(n) {
    return Math.ceil(n / 2);
}
function shrinkInteger(current, target, tryTargetAsap) {
    const realGap = current - target;
    function* shrinkDecr() {
        let previous = tryTargetAsap ? undefined : target;
        const gap = tryTargetAsap ? realGap : halvePosInteger(realGap);
        for (let toremove = gap; toremove > 0; toremove = halvePosInteger(toremove)) {
            const next = toremove === realGap ? target : current - toremove;
            yield new NextValue_1.NextValue(next, previous);
            previous = next;
        }
    }
    function* shrinkIncr() {
        let previous = tryTargetAsap ? undefined : target;
        const gap = tryTargetAsap ? realGap : halveNegInteger(realGap);
        for (let toremove = gap; toremove < 0; toremove = halveNegInteger(toremove)) {
            const next = toremove === realGap ? target : current - toremove;
            yield new NextValue_1.NextValue(next, previous);
            previous = next;
        }
    }
    return realGap > 0 ? Stream_1.stream(shrinkDecr()) : Stream_1.stream(shrinkIncr());
}
exports.shrinkInteger = shrinkInteger;


/***/ }),

/***/ "./node_modules/fast-check/lib/arbitrary/_internals/helpers/StringConstraintsExtractor.js":
/*!************************************************************************************************!*\
  !*** ./node_modules/fast-check/lib/arbitrary/_internals/helpers/StringConstraintsExtractor.js ***!
  \************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.extractStringConstraints = void 0;
function extractStringConstraints(options) {
    return options[0] !== undefined
        ? typeof options[0] === 'number'
            ? typeof options[1] === 'number'
                ? { minLength: options[0], maxLength: options[1] }
                : { maxLength: options[0] }
            : options[0]
        : {};
}
exports.extractStringConstraints = extractStringConstraints;


/***/ }),

/***/ "./node_modules/fast-check/lib/arbitrary/_internals/implementations/SchedulerImplem.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/fast-check/lib/arbitrary/_internals/implementations/SchedulerImplem.js ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SchedulerImplem = void 0;
const TextEscaper_1 = __webpack_require__(/*! ../../../check/arbitrary/helpers/TextEscaper */ "./node_modules/fast-check/lib/check/arbitrary/helpers/TextEscaper.js");
const symbols_1 = __webpack_require__(/*! ../../../check/symbols */ "./node_modules/fast-check/lib/check/symbols.js");
const stringify_1 = __webpack_require__(/*! ../../../utils/stringify */ "./node_modules/fast-check/lib/utils/stringify.js");
class SchedulerImplem {
    constructor(act, taskSelector) {
        this.act = act;
        this.taskSelector = taskSelector;
        this.lastTaskId = 0;
        this.sourceTaskSelector = taskSelector.clone();
        this.scheduledTasks = [];
        this.triggeredTasks = [];
    }
    static buildLog(reportItem) {
        return `[task\${${reportItem.taskId}}] ${reportItem.label.length !== 0 ? `${reportItem.schedulingType}::${reportItem.label}` : reportItem.schedulingType} ${reportItem.status}${reportItem.outputValue !== undefined ? ` with value ${TextEscaper_1.escapeForTemplateString(reportItem.outputValue)}` : ''}`;
    }
    log(schedulingType, taskId, label, metadata, status, data) {
        this.triggeredTasks.push({
            status,
            schedulingType,
            taskId,
            label,
            metadata,
            outputValue: data !== undefined ? stringify_1.stringify(data) : undefined,
        });
    }
    scheduleInternal(schedulingType, label, task, metadata, thenTaskToBeAwaited) {
        let trigger = null;
        const taskId = ++this.lastTaskId;
        const scheduledPromise = new Promise((resolve, reject) => {
            trigger = () => {
                (thenTaskToBeAwaited ? task.then(() => thenTaskToBeAwaited()) : task).then((data) => {
                    this.log(schedulingType, taskId, label, metadata, 'resolved', data);
                    return resolve(data);
                }, (err) => {
                    this.log(schedulingType, taskId, label, metadata, 'rejected', err);
                    return reject(err);
                });
            };
        });
        this.scheduledTasks.push({
            original: task,
            scheduled: scheduledPromise,
            trigger: trigger,
            schedulingType,
            taskId,
            label,
            metadata,
        });
        return scheduledPromise;
    }
    schedule(task, label, metadata) {
        return this.scheduleInternal('promise', label || '', task, metadata);
    }
    scheduleFunction(asyncFunction) {
        return (...args) => this.scheduleInternal('function', `${asyncFunction.name}(${args.map(stringify_1.stringify).join(',')})`, asyncFunction(...args), undefined);
    }
    scheduleSequence(sequenceBuilders) {
        const status = { done: false, faulty: false };
        const dummyResolvedPromise = { then: (f) => f() };
        let resolveSequenceTask = () => { };
        const sequenceTask = new Promise((resolve) => (resolveSequenceTask = resolve));
        sequenceBuilders
            .reduce((previouslyScheduled, item) => {
            const [builder, label, metadata] = typeof item === 'function' ? [item, item.name, undefined] : [item.builder, item.label, item.metadata];
            return previouslyScheduled.then(() => {
                const scheduled = this.scheduleInternal('sequence', label, dummyResolvedPromise, metadata, () => builder());
                scheduled.catch(() => {
                    status.faulty = true;
                    resolveSequenceTask();
                });
                return scheduled;
            });
        }, dummyResolvedPromise)
            .then(() => {
            status.done = true;
            resolveSequenceTask();
        }, () => {
        });
        return Object.assign(status, {
            task: Promise.resolve(sequenceTask).then(() => {
                return { done: status.done, faulty: status.faulty };
            }),
        });
    }
    count() {
        return this.scheduledTasks.length;
    }
    async internalWaitOne() {
        if (this.scheduledTasks.length === 0) {
            throw new Error('No task scheduled');
        }
        const taskIndex = this.taskSelector.nextTaskIndex(this.scheduledTasks);
        const [scheduledTask] = this.scheduledTasks.splice(taskIndex, 1);
        scheduledTask.trigger();
        try {
            await scheduledTask.scheduled;
        }
        catch (_err) {
        }
    }
    async waitOne() {
        await this.act(async () => await this.internalWaitOne());
    }
    async waitAll() {
        while (this.scheduledTasks.length > 0) {
            await this.waitOne();
        }
    }
    report() {
        return [
            ...this.triggeredTasks,
            ...this.scheduledTasks.map((t) => ({
                status: 'pending',
                schedulingType: t.schedulingType,
                taskId: t.taskId,
                label: t.label,
                metadata: t.metadata,
            })),
        ];
    }
    toString() {
        return ('schedulerFor()`\n' +
            this.report()
                .map(SchedulerImplem.buildLog)
                .map((log) => `-> ${log}`)
                .join('\n') +
            '`');
    }
    [symbols_1.cloneMethod]() {
        return new SchedulerImplem(this.act, this.sourceTaskSelector);
    }
}
exports.SchedulerImplem = SchedulerImplem;


/***/ }),

/***/ "./node_modules/fast-check/lib/arbitrary/_internals/mappers/CharsToString.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/fast-check/lib/arbitrary/_internals/mappers/CharsToString.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.charsToStringUnmapper = exports.charsToStringMapper = void 0;
function charsToStringMapper(tab) {
    return tab.join('');
}
exports.charsToStringMapper = charsToStringMapper;
function charsToStringUnmapper(value) {
    if (typeof value !== 'string') {
        throw new Error('Cannot unmap the passed value');
    }
    return value.split('');
}
exports.charsToStringUnmapper = charsToStringUnmapper;


/***/ }),

/***/ "./node_modules/fast-check/lib/arbitrary/_internals/mappers/CodePointsToString.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/fast-check/lib/arbitrary/_internals/mappers/CodePointsToString.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.codePointsToStringUnmapper = exports.codePointsToStringMapper = void 0;
function codePointsToStringMapper(tab) {
    return tab.join('');
}
exports.codePointsToStringMapper = codePointsToStringMapper;
function codePointsToStringUnmapper(value) {
    if (typeof value !== 'string') {
        throw new Error('Cannot unmap the passed value');
    }
    return [...value];
}
exports.codePointsToStringUnmapper = codePointsToStringUnmapper;


/***/ }),

/***/ "./node_modules/fast-check/lib/arbitrary/_internals/mappers/EntitiesToIPv6.js":
/*!************************************************************************************!*\
  !*** ./node_modules/fast-check/lib/arbitrary/_internals/mappers/EntitiesToIPv6.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.noTrailingUnmapper = exports.noTrailingMapper = exports.singleTrailingUnmapper = exports.singleTrailingMapper = exports.multiTrailingUnmapperOne = exports.multiTrailingMapperOne = exports.multiTrailingUnmapper = exports.multiTrailingMapper = exports.onlyTrailingUnmapper = exports.onlyTrailingMapper = exports.fullySpecifiedUnmapper = exports.fullySpecifiedMapper = void 0;
function readBh(value) {
    if (value.length === 0)
        return [];
    else
        return value.split(':');
}
function extractEhAndL(value) {
    const valueSplits = value.split(':');
    if (valueSplits.length >= 2 && valueSplits[valueSplits.length - 1].length <= 4) {
        return [
            valueSplits.slice(0, valueSplits.length - 2),
            `${valueSplits[valueSplits.length - 2]}:${valueSplits[valueSplits.length - 1]}`,
        ];
    }
    return [valueSplits.slice(0, valueSplits.length - 1), valueSplits[valueSplits.length - 1]];
}
function fullySpecifiedMapper(data) {
    return `${data[0].join(':')}:${data[1]}`;
}
exports.fullySpecifiedMapper = fullySpecifiedMapper;
function fullySpecifiedUnmapper(value) {
    if (typeof value !== 'string')
        throw new Error('Invalid type');
    return extractEhAndL(value);
}
exports.fullySpecifiedUnmapper = fullySpecifiedUnmapper;
function onlyTrailingMapper(data) {
    return `::${data[0].join(':')}:${data[1]}`;
}
exports.onlyTrailingMapper = onlyTrailingMapper;
function onlyTrailingUnmapper(value) {
    if (typeof value !== 'string')
        throw new Error('Invalid type');
    if (!value.startsWith('::'))
        throw new Error('Invalid value');
    return extractEhAndL(value.substring(2));
}
exports.onlyTrailingUnmapper = onlyTrailingUnmapper;
function multiTrailingMapper(data) {
    return `${data[0].join(':')}::${data[1].join(':')}:${data[2]}`;
}
exports.multiTrailingMapper = multiTrailingMapper;
function multiTrailingUnmapper(value) {
    if (typeof value !== 'string')
        throw new Error('Invalid type');
    const [bhString, trailingString] = value.split('::', 2);
    const [eh, l] = extractEhAndL(trailingString);
    return [readBh(bhString), eh, l];
}
exports.multiTrailingUnmapper = multiTrailingUnmapper;
function multiTrailingMapperOne(data) {
    return multiTrailingMapper([data[0], [data[1]], data[2]]);
}
exports.multiTrailingMapperOne = multiTrailingMapperOne;
function multiTrailingUnmapperOne(value) {
    const out = multiTrailingUnmapper(value);
    return [out[0], out[1].join(':'), out[2]];
}
exports.multiTrailingUnmapperOne = multiTrailingUnmapperOne;
function singleTrailingMapper(data) {
    return `${data[0].join(':')}::${data[1]}`;
}
exports.singleTrailingMapper = singleTrailingMapper;
function singleTrailingUnmapper(value) {
    if (typeof value !== 'string')
        throw new Error('Invalid type');
    const [bhString, trailing] = value.split('::', 2);
    return [readBh(bhString), trailing];
}
exports.singleTrailingUnmapper = singleTrailingUnmapper;
function noTrailingMapper(data) {
    return `${data[0].join(':')}::`;
}
exports.noTrailingMapper = noTrailingMapper;
function noTrailingUnmapper(value) {
    if (typeof value !== 'string')
        throw new Error('Invalid type');
    if (!value.endsWith('::'))
        throw new Error('Invalid value');
    return [readBh(value.substring(0, value.length - 2))];
}
exports.noTrailingUnmapper = noTrailingUnmapper;


/***/ }),

/***/ "./node_modules/fast-check/lib/arbitrary/_internals/mappers/IndexToCharString.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/fast-check/lib/arbitrary/_internals/mappers/IndexToCharString.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.indexToCharStringUnmapper = exports.indexToCharStringMapper = void 0;
exports.indexToCharStringMapper = String.fromCodePoint;
function indexToCharStringUnmapper(c) {
    if (typeof c !== 'string') {
        throw new Error('Cannot unmap non-string');
    }
    if (c.length === 0 || c.length > 2) {
        throw new Error('Cannot unmap string with more or less than one character');
    }
    const c1 = c.charCodeAt(0);
    if (c.length === 1) {
        return c1;
    }
    const c2 = c.charCodeAt(1);
    if (c1 < 0xd800 || c1 > 0xdbff || c2 < 0xdc00 || c2 > 0xdfff) {
        throw new Error('Cannot unmap invalid surrogate pairs');
    }
    return c.codePointAt(0);
}
exports.indexToCharStringUnmapper = indexToCharStringUnmapper;


/***/ }),

/***/ "./node_modules/fast-check/lib/arbitrary/_internals/mappers/IndexToMappedConstant.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/fast-check/lib/arbitrary/_internals/mappers/IndexToMappedConstant.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.indexToMappedConstantUnmapperFor = exports.indexToMappedConstantMapperFor = void 0;
function indexToMappedConstantMapperFor(entries) {
    return function indexToMappedConstantMapper(choiceIndex) {
        let idx = -1;
        let numSkips = 0;
        while (choiceIndex >= numSkips) {
            numSkips += entries[++idx].num;
        }
        return entries[idx].build(choiceIndex - numSkips + entries[idx].num);
    };
}
exports.indexToMappedConstantMapperFor = indexToMappedConstantMapperFor;
function buildReverseMapping(entries) {
    const reverseMapping = { mapping: new Map(), negativeZeroIndex: undefined };
    let choiceIndex = 0;
    for (let entryIdx = 0; entryIdx !== entries.length; ++entryIdx) {
        const entry = entries[entryIdx];
        for (let idxInEntry = 0; idxInEntry !== entry.num; ++idxInEntry) {
            const value = entry.build(idxInEntry);
            if (value === 0 && 1 / value === Number.NEGATIVE_INFINITY) {
                reverseMapping.negativeZeroIndex = choiceIndex;
            }
            else {
                reverseMapping.mapping.set(value, choiceIndex);
            }
            ++choiceIndex;
        }
    }
    return reverseMapping;
}
function indexToMappedConstantUnmapperFor(entries) {
    let reverseMapping = null;
    return function indexToMappedConstantUnmapper(value) {
        if (reverseMapping === null) {
            reverseMapping = buildReverseMapping(entries);
        }
        const choiceIndex = Object.is(value, -0) ? reverseMapping.negativeZeroIndex : reverseMapping.mapping.get(value);
        if (choiceIndex === undefined) {
            throw new Error('Unknown value encountered cannot be built using this mapToConstant');
        }
        return choiceIndex;
    };
}
exports.indexToMappedConstantUnmapperFor = indexToMappedConstantUnmapperFor;


/***/ }),

/***/ "./node_modules/fast-check/lib/arbitrary/_internals/mappers/IndexToPrintableIndex.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/fast-check/lib/arbitrary/_internals/mappers/IndexToPrintableIndex.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.indexToPrintableIndexUnmapper = exports.indexToPrintableIndexMapper = void 0;
function indexToPrintableIndexMapper(v) {
    if (v < 95)
        return v + 0x20;
    if (v <= 0x7e)
        return v - 95;
    return v;
}
exports.indexToPrintableIndexMapper = indexToPrintableIndexMapper;
function indexToPrintableIndexUnmapper(v) {
    if (v >= 0x20 && v <= 0x7e)
        return v - 0x20;
    if (v >= 0 && v <= 0x1f)
        return v + 95;
    return v;
}
exports.indexToPrintableIndexUnmapper = indexToPrintableIndexUnmapper;


/***/ }),

/***/ "./node_modules/fast-check/lib/arbitrary/_internals/mappers/KeyValuePairsToObject.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/fast-check/lib/arbitrary/_internals/mappers/KeyValuePairsToObject.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.keyValuePairsToObjectUnmapper = exports.keyValuePairsToObjectMapper = void 0;
function keyValuePairsToObjectMapper(items) {
    const obj = {};
    for (const keyValue of items) {
        obj[keyValue[0]] = keyValue[1];
    }
    return obj;
}
exports.keyValuePairsToObjectMapper = keyValuePairsToObjectMapper;
function buildInvalidPropertyNameFilter(obj) {
    return function invalidPropertyNameFilter(key) {
        const descriptor = Object.getOwnPropertyDescriptor(obj, key);
        return (descriptor === undefined ||
            !descriptor.configurable ||
            !descriptor.enumerable ||
            !descriptor.writable ||
            descriptor.get !== undefined ||
            descriptor.set !== undefined);
    };
}
function keyValuePairsToObjectUnmapper(value) {
    if (typeof value !== 'object' || value === null) {
        throw new Error('Incompatible instance received: should be a non-null object');
    }
    if (!('constructor' in value) || value.constructor !== Object) {
        throw new Error('Incompatible instance received: should be of exact type Object');
    }
    if (Object.getOwnPropertySymbols(value).length > 0) {
        throw new Error('Incompatible instance received: should contain symbols');
    }
    if (Object.getOwnPropertyNames(value).find(buildInvalidPropertyNameFilter(value)) !== undefined) {
        throw new Error('Incompatible instance received: should contain only c/e/w properties without get/set');
    }
    return Object.entries(value);
}
exports.keyValuePairsToObjectUnmapper = keyValuePairsToObjectUnmapper;


/***/ }),

/***/ "./node_modules/fast-check/lib/arbitrary/_internals/mappers/NatToStringifiedNat.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/fast-check/lib/arbitrary/_internals/mappers/NatToStringifiedNat.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.natToStringifiedNatUnmapper = exports.tryParseStringifiedNat = exports.natToStringifiedNatMapper = void 0;
function natToStringifiedNatMapper(options) {
    const [style, v] = options;
    switch (style) {
        case 'oct':
            return `0${Number(v).toString(8)}`;
        case 'hex':
            return `0x${Number(v).toString(16)}`;
        case 'dec':
        default:
            return `${v}`;
    }
}
exports.natToStringifiedNatMapper = natToStringifiedNatMapper;
function tryParseStringifiedNat(stringValue, radix) {
    const parsedNat = Number.parseInt(stringValue, radix);
    if (parsedNat.toString(radix) !== stringValue) {
        throw new Error('Invalid value');
    }
    return parsedNat;
}
exports.tryParseStringifiedNat = tryParseStringifiedNat;
function natToStringifiedNatUnmapper(value) {
    if (typeof value !== 'string') {
        throw new Error('Invalid type');
    }
    if (value.length >= 2 && value[0] === '0') {
        if (value[1] === 'x') {
            return ['hex', tryParseStringifiedNat(value.substr(2), 16)];
        }
        return ['oct', tryParseStringifiedNat(value.substr(1), 8)];
    }
    return ['dec', tryParseStringifiedNat(value, 10)];
}
exports.natToStringifiedNatUnmapper = natToStringifiedNatUnmapper;


/***/ }),

/***/ "./node_modules/fast-check/lib/arbitrary/_internals/mappers/PatternsToString.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/fast-check/lib/arbitrary/_internals/mappers/PatternsToString.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.patternsToStringUnmapperFor = exports.patternsToStringMapper = void 0;
const MaxLengthFromMinLength_1 = __webpack_require__(/*! ../helpers/MaxLengthFromMinLength */ "./node_modules/fast-check/lib/arbitrary/_internals/helpers/MaxLengthFromMinLength.js");
function patternsToStringMapper(tab) {
    return tab.join('');
}
exports.patternsToStringMapper = patternsToStringMapper;
function patternsToStringUnmapperFor(patternsArb, constraints) {
    return function patternsToStringUnmapper(value) {
        if (typeof value !== 'string') {
            throw new Error('Unsupported value');
        }
        const minLength = constraints.minLength !== undefined ? constraints.minLength : 0;
        const maxLength = constraints.maxLength !== undefined ? constraints.maxLength : MaxLengthFromMinLength_1.maxLengthFromMinLength(minLength);
        if (value.length === 0) {
            if (minLength > 0) {
                throw new Error('Unable to unmap received string');
            }
            return [];
        }
        const stack = [{ endIndexChunks: 0, nextStartIndex: 1, chunks: [] }];
        while (stack.length > 0) {
            const last = stack.pop();
            for (let index = last.nextStartIndex; index <= value.length; ++index) {
                const chunk = value.substring(last.endIndexChunks, index);
                if (patternsArb.canShrinkWithoutContext(chunk)) {
                    const newChunks = last.chunks.concat([chunk]);
                    if (index === value.length) {
                        if (newChunks.length < minLength || newChunks.length > maxLength) {
                            break;
                        }
                        return newChunks;
                    }
                    stack.push({ endIndexChunks: last.endIndexChunks, nextStartIndex: index + 1, chunks: last.chunks });
                    stack.push({ endIndexChunks: index, nextStartIndex: index + 1, chunks: newChunks });
                    break;
                }
            }
        }
        throw new Error('Unable to unmap received string');
    };
}
exports.patternsToStringUnmapperFor = patternsToStringUnmapperFor;


/***/ }),

/***/ "./node_modules/fast-check/lib/arbitrary/_internals/mappers/StringToBase64.js":
/*!************************************************************************************!*\
  !*** ./node_modules/fast-check/lib/arbitrary/_internals/mappers/StringToBase64.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.stringToBase64Unmapper = exports.stringToBase64Mapper = void 0;
function stringToBase64Mapper(s) {
    switch (s.length % 4) {
        case 0:
            return s;
        case 3:
            return `${s}=`;
        case 2:
            return `${s}==`;
        default:
            return s.slice(1);
    }
}
exports.stringToBase64Mapper = stringToBase64Mapper;
function stringToBase64Unmapper(value) {
    if (typeof value !== 'string' || value.length % 4 !== 0) {
        throw new Error('Invalid string received');
    }
    const lastTrailingIndex = value.indexOf('=');
    if (lastTrailingIndex === -1) {
        return value;
    }
    const numTrailings = value.length - lastTrailingIndex;
    if (numTrailings > 2) {
        throw new Error('Cannot unmap the passed value');
    }
    return value.substring(0, lastTrailingIndex);
}
exports.stringToBase64Unmapper = stringToBase64Unmapper;


/***/ }),

/***/ "./node_modules/fast-check/lib/arbitrary/_internals/mappers/TimeToDate.js":
/*!********************************************************************************!*\
  !*** ./node_modules/fast-check/lib/arbitrary/_internals/mappers/TimeToDate.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.timeToDateUnmapper = exports.timeToDateMapper = void 0;
function timeToDateMapper(time) {
    return new Date(time);
}
exports.timeToDateMapper = timeToDateMapper;
function timeToDateUnmapper(value) {
    if (!(value instanceof Date) || value.constructor !== Date) {
        throw new Error('Not a valid value for date unmapper');
    }
    return value.getTime();
}
exports.timeToDateUnmapper = timeToDateUnmapper;


/***/ }),

/***/ "./node_modules/fast-check/lib/arbitrary/_internals/mappers/ValuesAndSeparateKeysToObject.js":
/*!***************************************************************************************************!*\
  !*** ./node_modules/fast-check/lib/arbitrary/_internals/mappers/ValuesAndSeparateKeysToObject.js ***!
  \***************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.buildValuesAndSeparateKeysToObjectUnmapper = exports.buildValuesAndSeparateKeysToObjectMapper = void 0;
function buildValuesAndSeparateKeysToObjectMapper(keys, noKeyValue) {
    return function valuesAndSeparateKeysToObjectMapper(gs) {
        const obj = {};
        for (let idx = 0; idx !== keys.length; ++idx) {
            const valueWrapper = gs[idx];
            if (valueWrapper !== noKeyValue) {
                obj[keys[idx]] = valueWrapper;
            }
        }
        return obj;
    };
}
exports.buildValuesAndSeparateKeysToObjectMapper = buildValuesAndSeparateKeysToObjectMapper;
function buildValuesAndSeparateKeysToObjectUnmapper(keys, noKeyValue) {
    return function valuesAndSeparateKeysToObjectUnmapper(value) {
        if (typeof value !== 'object' || value === null) {
            throw new Error('Incompatible instance received: should be a non-null object');
        }
        if (!('constructor' in value) || value.constructor !== Object) {
            throw new Error('Incompatible instance received: should be of exact type Object');
        }
        let extractedPropertiesCount = 0;
        const extractedValues = [];
        for (let idx = 0; idx !== keys.length; ++idx) {
            const descriptor = Object.getOwnPropertyDescriptor(value, keys[idx]);
            if (descriptor !== undefined) {
                if (!descriptor.configurable || !descriptor.enumerable || !descriptor.writable) {
                    throw new Error('Incompatible instance received: should contain only c/e/w properties');
                }
                if (descriptor.get !== undefined || descriptor.set !== undefined) {
                    throw new Error('Incompatible instance received: should contain only no get/set properties');
                }
                ++extractedPropertiesCount;
                extractedValues.push(descriptor.value);
            }
            else {
                extractedValues.push(noKeyValue);
            }
        }
        const namePropertiesCount = Object.getOwnPropertyNames(value).length;
        const symbolPropertiesCount = Object.getOwnPropertySymbols(value).length;
        if (extractedPropertiesCount !== namePropertiesCount + symbolPropertiesCount) {
            throw new Error('Incompatible instance received: should not contain extra properties');
        }
        return extractedValues;
    };
}
exports.buildValuesAndSeparateKeysToObjectUnmapper = buildValuesAndSeparateKeysToObjectUnmapper;


/***/ }),

/***/ "./node_modules/fast-check/lib/arbitrary/_internals/mappers/WordsToLorem.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/fast-check/lib/arbitrary/_internals/mappers/WordsToLorem.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.sentencesToParagraphUnmapper = exports.sentencesToParagraphMapper = exports.wordsToSentenceUnmapperFor = exports.wordsToSentenceMapper = exports.wordsToJoinedStringUnmapperFor = exports.wordsToJoinedStringMapper = void 0;
function wordsToJoinedStringMapper(words) {
    return words.map((w) => (w[w.length - 1] === ',' ? w.substr(0, w.length - 1) : w)).join(' ');
}
exports.wordsToJoinedStringMapper = wordsToJoinedStringMapper;
function wordsToJoinedStringUnmapperFor(wordsArbitrary) {
    return function wordsToJoinedStringUnmapper(value) {
        if (typeof value !== 'string') {
            throw new Error('Unsupported type');
        }
        const words = [];
        for (const candidate of value.split(' ')) {
            if (wordsArbitrary.canShrinkWithoutContext(candidate))
                words.push(candidate);
            else if (wordsArbitrary.canShrinkWithoutContext(candidate + ','))
                words.push(candidate + ',');
            else
                throw new Error('Unsupported word');
        }
        return words;
    };
}
exports.wordsToJoinedStringUnmapperFor = wordsToJoinedStringUnmapperFor;
function wordsToSentenceMapper(words) {
    let sentence = words.join(' ');
    if (sentence[sentence.length - 1] === ',') {
        sentence = sentence.substr(0, sentence.length - 1);
    }
    return sentence[0].toUpperCase() + sentence.substring(1) + '.';
}
exports.wordsToSentenceMapper = wordsToSentenceMapper;
function wordsToSentenceUnmapperFor(wordsArbitrary) {
    return function wordsToSentenceUnmapper(value) {
        if (typeof value !== 'string') {
            throw new Error('Unsupported type');
        }
        if (value.length < 2 ||
            value[value.length - 1] !== '.' ||
            value[value.length - 2] === ',' ||
            value[0].toLowerCase().toUpperCase() !== value[0]) {
            throw new Error('Unsupported value');
        }
        const adaptedValue = value[0].toLowerCase() + value.substring(1, value.length - 1);
        const words = [];
        const candidates = adaptedValue.split(' ');
        for (let idx = 0; idx !== candidates.length; ++idx) {
            const candidate = candidates[idx];
            if (wordsArbitrary.canShrinkWithoutContext(candidate))
                words.push(candidate);
            else if (idx === candidates.length - 1 && wordsArbitrary.canShrinkWithoutContext(candidate + ','))
                words.push(candidate + ',');
            else
                throw new Error('Unsupported word');
        }
        return words;
    };
}
exports.wordsToSentenceUnmapperFor = wordsToSentenceUnmapperFor;
function sentencesToParagraphMapper(sentences) {
    return sentences.join(' ');
}
exports.sentencesToParagraphMapper = sentencesToParagraphMapper;
function sentencesToParagraphUnmapper(value) {
    if (typeof value !== 'string') {
        throw new Error('Unsupported type');
    }
    const sentences = value.split('. ');
    for (let idx = 0; idx < sentences.length - 1; ++idx) {
        sentences[idx] += '.';
    }
    return sentences;
}
exports.sentencesToParagraphUnmapper = sentencesToParagraphUnmapper;


/***/ }),

/***/ "./node_modules/fast-check/lib/arbitrary/array.js":
/*!********************************************************!*\
  !*** ./node_modules/fast-check/lib/arbitrary/array.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.array = void 0;
const Converters_1 = __webpack_require__(/*! ../check/arbitrary/definition/Converters */ "./node_modules/fast-check/lib/check/arbitrary/definition/Converters.js");
const ArrayArbitrary_1 = __webpack_require__(/*! ./_internals/ArrayArbitrary */ "./node_modules/fast-check/lib/arbitrary/_internals/ArrayArbitrary.js");
const MaxLengthFromMinLength_1 = __webpack_require__(/*! ./_internals/helpers/MaxLengthFromMinLength */ "./node_modules/fast-check/lib/arbitrary/_internals/helpers/MaxLengthFromMinLength.js");
function array(arb, ...args) {
    const nextArb = Converters_1.convertToNext(arb);
    if (args[0] === undefined)
        return Converters_1.convertFromNext(new ArrayArbitrary_1.ArrayArbitrary(nextArb, 0, MaxLengthFromMinLength_1.maxLengthFromMinLength(0)));
    if (typeof args[0] === 'object') {
        const minLength = args[0].minLength || 0;
        const specifiedMaxLength = args[0].maxLength;
        const maxLength = specifiedMaxLength !== undefined ? specifiedMaxLength : MaxLengthFromMinLength_1.maxLengthFromMinLength(minLength);
        return Converters_1.convertFromNext(new ArrayArbitrary_1.ArrayArbitrary(nextArb, minLength, maxLength));
    }
    if (args[1] !== undefined)
        return Converters_1.convertFromNext(new ArrayArbitrary_1.ArrayArbitrary(nextArb, args[0], args[1]));
    return Converters_1.convertFromNext(new ArrayArbitrary_1.ArrayArbitrary(nextArb, 0, args[0]));
}
exports.array = array;


/***/ }),

/***/ "./node_modules/fast-check/lib/arbitrary/ascii.js":
/*!********************************************************!*\
  !*** ./node_modules/fast-check/lib/arbitrary/ascii.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ascii = void 0;
const CharacterArbitraryBuilder_1 = __webpack_require__(/*! ./_internals/builders/CharacterArbitraryBuilder */ "./node_modules/fast-check/lib/arbitrary/_internals/builders/CharacterArbitraryBuilder.js");
const IndexToPrintableIndex_1 = __webpack_require__(/*! ./_internals/mappers/IndexToPrintableIndex */ "./node_modules/fast-check/lib/arbitrary/_internals/mappers/IndexToPrintableIndex.js");
function ascii() {
    return CharacterArbitraryBuilder_1.buildCharacterArbitrary(0x00, 0x7f, IndexToPrintableIndex_1.indexToPrintableIndexMapper, IndexToPrintableIndex_1.indexToPrintableIndexUnmapper);
}
exports.ascii = ascii;


/***/ }),

/***/ "./node_modules/fast-check/lib/arbitrary/asciiString.js":
/*!**************************************************************!*\
  !*** ./node_modules/fast-check/lib/arbitrary/asciiString.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.asciiString = void 0;
const Converters_1 = __webpack_require__(/*! ../check/arbitrary/definition/Converters */ "./node_modules/fast-check/lib/check/arbitrary/definition/Converters.js");
const array_1 = __webpack_require__(/*! ./array */ "./node_modules/fast-check/lib/arbitrary/array.js");
const ascii_1 = __webpack_require__(/*! ./ascii */ "./node_modules/fast-check/lib/arbitrary/ascii.js");
const StringConstraintsExtractor_1 = __webpack_require__(/*! ./_internals/helpers/StringConstraintsExtractor */ "./node_modules/fast-check/lib/arbitrary/_internals/helpers/StringConstraintsExtractor.js");
const CodePointsToString_1 = __webpack_require__(/*! ./_internals/mappers/CodePointsToString */ "./node_modules/fast-check/lib/arbitrary/_internals/mappers/CodePointsToString.js");
function asciiString(...args) {
    const constraints = StringConstraintsExtractor_1.extractStringConstraints(args);
    return Converters_1.convertFromNext(Converters_1.convertToNext(array_1.array(ascii_1.ascii(), constraints)).map(CodePointsToString_1.codePointsToStringMapper, CodePointsToString_1.codePointsToStringUnmapper));
}
exports.asciiString = asciiString;


/***/ }),

/***/ "./node_modules/fast-check/lib/arbitrary/base64.js":
/*!*********************************************************!*\
  !*** ./node_modules/fast-check/lib/arbitrary/base64.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.base64 = void 0;
const CharacterArbitraryBuilder_1 = __webpack_require__(/*! ./_internals/builders/CharacterArbitraryBuilder */ "./node_modules/fast-check/lib/arbitrary/_internals/builders/CharacterArbitraryBuilder.js");
function base64Mapper(v) {
    if (v < 26)
        return v + 65;
    if (v < 52)
        return v + 97 - 26;
    if (v < 62)
        return v + 48 - 52;
    return v === 62 ? 43 : 47;
}
function base64Unmapper(v) {
    if (v >= 65 && v <= 90)
        return v - 65;
    if (v >= 97 && v <= 122)
        return v - 97 + 26;
    if (v >= 48 && v <= 57)
        return v - 48 + 52;
    return v === 43 ? 62 : v === 47 ? 63 : -1;
}
function base64() {
    return CharacterArbitraryBuilder_1.buildCharacterArbitrary(0, 63, base64Mapper, base64Unmapper);
}
exports.base64 = base64;


/***/ }),

/***/ "./node_modules/fast-check/lib/arbitrary/base64String.js":
/*!***************************************************************!*\
  !*** ./node_modules/fast-check/lib/arbitrary/base64String.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.base64String = void 0;
const Converters_1 = __webpack_require__(/*! ../check/arbitrary/definition/Converters */ "./node_modules/fast-check/lib/check/arbitrary/definition/Converters.js");
const array_1 = __webpack_require__(/*! ./array */ "./node_modules/fast-check/lib/arbitrary/array.js");
const base64_1 = __webpack_require__(/*! ./base64 */ "./node_modules/fast-check/lib/arbitrary/base64.js");
const MaxLengthFromMinLength_1 = __webpack_require__(/*! ./_internals/helpers/MaxLengthFromMinLength */ "./node_modules/fast-check/lib/arbitrary/_internals/helpers/MaxLengthFromMinLength.js");
const StringConstraintsExtractor_1 = __webpack_require__(/*! ./_internals/helpers/StringConstraintsExtractor */ "./node_modules/fast-check/lib/arbitrary/_internals/helpers/StringConstraintsExtractor.js");
const CodePointsToString_1 = __webpack_require__(/*! ./_internals/mappers/CodePointsToString */ "./node_modules/fast-check/lib/arbitrary/_internals/mappers/CodePointsToString.js");
const StringToBase64_1 = __webpack_require__(/*! ./_internals/mappers/StringToBase64 */ "./node_modules/fast-check/lib/arbitrary/_internals/mappers/StringToBase64.js");
function extractMinMaxConstraints(args) {
    const constraints = StringConstraintsExtractor_1.extractStringConstraints(args);
    const minLength = constraints.minLength !== undefined ? constraints.minLength : 0;
    const maxLength = constraints.maxLength !== undefined ? constraints.maxLength : MaxLengthFromMinLength_1.maxLengthFromMinLength(minLength);
    return { minLength, maxLength };
}
function base64String(...args) {
    const constraints = extractMinMaxConstraints(args);
    const unscaledMinLength = constraints.minLength;
    const unscaledMaxLength = constraints.maxLength;
    const minLength = unscaledMinLength + 3 - ((unscaledMinLength + 3) % 4);
    const maxLength = unscaledMaxLength - (unscaledMaxLength % 4);
    if (minLength > maxLength)
        throw new Error('Minimal length should be inferior or equal to maximal length');
    if (minLength % 4 !== 0)
        throw new Error('Minimal length of base64 strings must be a multiple of 4');
    if (maxLength % 4 !== 0)
        throw new Error('Maximal length of base64 strings must be a multiple of 4');
    return Converters_1.convertFromNext(Converters_1.convertToNext(array_1.array(base64_1.base64(), { minLength, maxLength }))
        .map(CodePointsToString_1.codePointsToStringMapper, CodePointsToString_1.codePointsToStringUnmapper)
        .map(StringToBase64_1.stringToBase64Mapper, StringToBase64_1.stringToBase64Unmapper));
}
exports.base64String = base64String;


/***/ }),

/***/ "./node_modules/fast-check/lib/arbitrary/bigInt.js":
/*!*********************************************************!*\
  !*** ./node_modules/fast-check/lib/arbitrary/bigInt.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.bigInt = void 0;
const Converters_1 = __webpack_require__(/*! ../check/arbitrary/definition/Converters */ "./node_modules/fast-check/lib/check/arbitrary/definition/Converters.js");
const BigIntArbitrary_1 = __webpack_require__(/*! ./_internals/BigIntArbitrary */ "./node_modules/fast-check/lib/arbitrary/_internals/BigIntArbitrary.js");
function buildCompleteBigIntConstraints(constraints) {
    const DefaultPow = 256;
    const DefaultMin = BigInt(-1) << BigInt(DefaultPow - 1);
    const DefaultMax = (BigInt(1) << BigInt(DefaultPow - 1)) - BigInt(1);
    const min = constraints.min;
    const max = constraints.max;
    return {
        min: min !== undefined ? min : DefaultMin - (max !== undefined && max < BigInt(0) ? max * max : BigInt(0)),
        max: max !== undefined ? max : DefaultMax + (min !== undefined && min > BigInt(0) ? min * min : BigInt(0)),
    };
}
function extractBigIntConstraints(args) {
    if (args[0] === undefined) {
        return {};
    }
    if (args[1] === undefined) {
        const constraints = args[0];
        return constraints;
    }
    return { min: args[0], max: args[1] };
}
function bigInt(...args) {
    const constraints = buildCompleteBigIntConstraints(extractBigIntConstraints(args));
    if (constraints.min > constraints.max) {
        throw new Error('fc.bigInt expects max to be greater than or equal to min');
    }
    const arb = new BigIntArbitrary_1.BigIntArbitrary(constraints.min, constraints.max);
    return Converters_1.convertFromNextWithShrunkOnce(arb, arb.defaultTarget());
}
exports.bigInt = bigInt;


/***/ }),

/***/ "./node_modules/fast-check/lib/arbitrary/bigIntN.js":
/*!**********************************************************!*\
  !*** ./node_modules/fast-check/lib/arbitrary/bigIntN.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.bigIntN = void 0;
const Converters_1 = __webpack_require__(/*! ../check/arbitrary/definition/Converters */ "./node_modules/fast-check/lib/check/arbitrary/definition/Converters.js");
const BigIntArbitrary_1 = __webpack_require__(/*! ./_internals/BigIntArbitrary */ "./node_modules/fast-check/lib/arbitrary/_internals/BigIntArbitrary.js");
function bigIntN(n) {
    if (n < 1) {
        throw new Error('fc.bigIntN expects requested number of bits to be superior or equal to 1');
    }
    const min = BigInt(-1) << BigInt(n - 1);
    const max = (BigInt(1) << BigInt(n - 1)) - BigInt(1);
    const arb = new BigIntArbitrary_1.BigIntArbitrary(min, max);
    return Converters_1.convertFromNextWithShrunkOnce(arb, arb.defaultTarget());
}
exports.bigIntN = bigIntN;


/***/ }),

/***/ "./node_modules/fast-check/lib/arbitrary/bigUint.js":
/*!**********************************************************!*\
  !*** ./node_modules/fast-check/lib/arbitrary/bigUint.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.bigUint = void 0;
const Converters_1 = __webpack_require__(/*! ../check/arbitrary/definition/Converters */ "./node_modules/fast-check/lib/check/arbitrary/definition/Converters.js");
const BigIntArbitrary_1 = __webpack_require__(/*! ./_internals/BigIntArbitrary */ "./node_modules/fast-check/lib/arbitrary/_internals/BigIntArbitrary.js");
function computeDefaultMax() {
    return (BigInt(1) << BigInt(256)) - BigInt(1);
}
function bigUint(constraints) {
    const requestedMax = typeof constraints === 'object' ? constraints.max : constraints;
    const max = requestedMax !== undefined ? requestedMax : computeDefaultMax();
    if (max < 0) {
        throw new Error('fc.bigUint expects max to be greater than or equal to zero');
    }
    const arb = new BigIntArbitrary_1.BigIntArbitrary(BigInt(0), max);
    return Converters_1.convertFromNextWithShrunkOnce(arb, arb.defaultTarget());
}
exports.bigUint = bigUint;


/***/ }),

/***/ "./node_modules/fast-check/lib/arbitrary/bigUintN.js":
/*!***********************************************************!*\
  !*** ./node_modules/fast-check/lib/arbitrary/bigUintN.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.bigUintN = void 0;
const Converters_1 = __webpack_require__(/*! ../check/arbitrary/definition/Converters */ "./node_modules/fast-check/lib/check/arbitrary/definition/Converters.js");
const BigIntArbitrary_1 = __webpack_require__(/*! ./_internals/BigIntArbitrary */ "./node_modules/fast-check/lib/arbitrary/_internals/BigIntArbitrary.js");
function bigUintN(n) {
    if (n < 0) {
        throw new Error('fc.bigUintN expects requested number of bits to be superior or equal to 0');
    }
    const min = BigInt(0);
    const max = (BigInt(1) << BigInt(n)) - BigInt(1);
    const arb = new BigIntArbitrary_1.BigIntArbitrary(min, max);
    return Converters_1.convertFromNextWithShrunkOnce(arb, arb.defaultTarget());
}
exports.bigUintN = bigUintN;


/***/ }),

/***/ "./node_modules/fast-check/lib/arbitrary/boolean.js":
/*!**********************************************************!*\
  !*** ./node_modules/fast-check/lib/arbitrary/boolean.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.boolean = void 0;
const Converters_1 = __webpack_require__(/*! ../check/arbitrary/definition/Converters */ "./node_modules/fast-check/lib/check/arbitrary/definition/Converters.js");
const integer_1 = __webpack_require__(/*! ./integer */ "./node_modules/fast-check/lib/arbitrary/integer.js");
function booleanMapper(v) {
    return v === 1;
}
function booleanUnmapper(v) {
    if (typeof v !== 'boolean')
        throw new Error('Unsupported input type');
    return v === true ? 1 : 0;
}
function boolean() {
    return Converters_1.convertFromNext(Converters_1.convertToNext(integer_1.integer({ min: 0, max: 1 }))
        .map(booleanMapper, booleanUnmapper)
        .noBias());
}
exports.boolean = boolean;


/***/ }),

/***/ "./node_modules/fast-check/lib/arbitrary/char.js":
/*!*******************************************************!*\
  !*** ./node_modules/fast-check/lib/arbitrary/char.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.char = void 0;
const CharacterArbitraryBuilder_1 = __webpack_require__(/*! ./_internals/builders/CharacterArbitraryBuilder */ "./node_modules/fast-check/lib/arbitrary/_internals/builders/CharacterArbitraryBuilder.js");
function identity(v) {
    return v;
}
function char() {
    return CharacterArbitraryBuilder_1.buildCharacterArbitrary(0x20, 0x7e, identity, identity);
}
exports.char = char;


/***/ }),

/***/ "./node_modules/fast-check/lib/arbitrary/char16bits.js":
/*!*************************************************************!*\
  !*** ./node_modules/fast-check/lib/arbitrary/char16bits.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.char16bits = void 0;
const CharacterArbitraryBuilder_1 = __webpack_require__(/*! ./_internals/builders/CharacterArbitraryBuilder */ "./node_modules/fast-check/lib/arbitrary/_internals/builders/CharacterArbitraryBuilder.js");
const IndexToPrintableIndex_1 = __webpack_require__(/*! ./_internals/mappers/IndexToPrintableIndex */ "./node_modules/fast-check/lib/arbitrary/_internals/mappers/IndexToPrintableIndex.js");
function char16bits() {
    return CharacterArbitraryBuilder_1.buildCharacterArbitrary(0x0000, 0xffff, IndexToPrintableIndex_1.indexToPrintableIndexMapper, IndexToPrintableIndex_1.indexToPrintableIndexUnmapper);
}
exports.char16bits = char16bits;


/***/ }),

/***/ "./node_modules/fast-check/lib/arbitrary/clone.js":
/*!********************************************************!*\
  !*** ./node_modules/fast-check/lib/arbitrary/clone.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.clone = void 0;
const Converters_1 = __webpack_require__(/*! ../check/arbitrary/definition/Converters */ "./node_modules/fast-check/lib/check/arbitrary/definition/Converters.js");
const CloneArbitrary_1 = __webpack_require__(/*! ./_internals/CloneArbitrary */ "./node_modules/fast-check/lib/arbitrary/_internals/CloneArbitrary.js");
function clone(arb, numValues) {
    return Converters_1.convertFromNext(new CloneArbitrary_1.CloneArbitrary(Converters_1.convertToNext(arb), numValues));
}
exports.clone = clone;


/***/ }),

/***/ "./node_modules/fast-check/lib/arbitrary/clonedConstant.js":
/*!*****************************************************************!*\
  !*** ./node_modules/fast-check/lib/arbitrary/clonedConstant.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.clonedConstant = void 0;
const constant_1 = __webpack_require__(/*! ./constant */ "./node_modules/fast-check/lib/arbitrary/constant.js");
exports.clonedConstant = constant_1.constant;


/***/ }),

/***/ "./node_modules/fast-check/lib/arbitrary/compareBooleanFunc.js":
/*!*********************************************************************!*\
  !*** ./node_modules/fast-check/lib/arbitrary/compareBooleanFunc.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.compareBooleanFunc = void 0;
const CompareFunctionArbitraryBuilder_1 = __webpack_require__(/*! ./_internals/builders/CompareFunctionArbitraryBuilder */ "./node_modules/fast-check/lib/arbitrary/_internals/builders/CompareFunctionArbitraryBuilder.js");
function compareBooleanFunc() {
    return CompareFunctionArbitraryBuilder_1.buildCompareFunctionArbitrary(Object.assign((hA, hB) => hA < hB, {
        toString() {
            return '(hA, hB) => hA < hB';
        },
    }));
}
exports.compareBooleanFunc = compareBooleanFunc;


/***/ }),

/***/ "./node_modules/fast-check/lib/arbitrary/compareFunc.js":
/*!**************************************************************!*\
  !*** ./node_modules/fast-check/lib/arbitrary/compareFunc.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.compareFunc = void 0;
const CompareFunctionArbitraryBuilder_1 = __webpack_require__(/*! ./_internals/builders/CompareFunctionArbitraryBuilder */ "./node_modules/fast-check/lib/arbitrary/_internals/builders/CompareFunctionArbitraryBuilder.js");
function compareFunc() {
    return CompareFunctionArbitraryBuilder_1.buildCompareFunctionArbitrary(Object.assign((hA, hB) => hA - hB, {
        toString() {
            return '(hA, hB) => hA - hB';
        },
    }));
}
exports.compareFunc = compareFunc;


/***/ }),

/***/ "./node_modules/fast-check/lib/arbitrary/constant.js":
/*!***********************************************************!*\
  !*** ./node_modules/fast-check/lib/arbitrary/constant.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.constant = void 0;
const Converters_1 = __webpack_require__(/*! ../check/arbitrary/definition/Converters */ "./node_modules/fast-check/lib/check/arbitrary/definition/Converters.js");
const ConstantArbitrary_1 = __webpack_require__(/*! ./_internals/ConstantArbitrary */ "./node_modules/fast-check/lib/arbitrary/_internals/ConstantArbitrary.js");
function constant(value) {
    return Converters_1.convertFromNext(new ConstantArbitrary_1.ConstantArbitrary([value]));
}
exports.constant = constant;


/***/ }),

/***/ "./node_modules/fast-check/lib/arbitrary/constantFrom.js":
/*!***************************************************************!*\
  !*** ./node_modules/fast-check/lib/arbitrary/constantFrom.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.constantFrom = void 0;
const Converters_1 = __webpack_require__(/*! ../check/arbitrary/definition/Converters */ "./node_modules/fast-check/lib/check/arbitrary/definition/Converters.js");
const ConstantArbitrary_1 = __webpack_require__(/*! ./_internals/ConstantArbitrary */ "./node_modules/fast-check/lib/arbitrary/_internals/ConstantArbitrary.js");
function constantFrom(...values) {
    if (values.length === 0) {
        throw new Error('fc.constantFrom expects at least one parameter');
    }
    return Converters_1.convertFromNext(new ConstantArbitrary_1.ConstantArbitrary(values));
}
exports.constantFrom = constantFrom;


/***/ }),

/***/ "./node_modules/fast-check/lib/arbitrary/context.js":
/*!**********************************************************!*\
  !*** ./node_modules/fast-check/lib/arbitrary/context.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.context = void 0;
const symbols_1 = __webpack_require__(/*! ../check/symbols */ "./node_modules/fast-check/lib/check/symbols.js");
const constant_1 = __webpack_require__(/*! ./constant */ "./node_modules/fast-check/lib/arbitrary/constant.js");
class ContextImplem {
    constructor() {
        this.receivedLogs = [];
    }
    log(data) {
        this.receivedLogs.push(data);
    }
    size() {
        return this.receivedLogs.length;
    }
    toString() {
        return JSON.stringify({ logs: this.receivedLogs });
    }
    [symbols_1.cloneMethod]() {
        return new ContextImplem();
    }
}
function context() {
    return constant_1.constant(new ContextImplem());
}
exports.context = context;


/***/ }),

/***/ "./node_modules/fast-check/lib/arbitrary/date.js":
/*!*******************************************************!*\
  !*** ./node_modules/fast-check/lib/arbitrary/date.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.date = void 0;
const Converters_1 = __webpack_require__(/*! ../check/arbitrary/definition/Converters */ "./node_modules/fast-check/lib/check/arbitrary/definition/Converters.js");
const integer_1 = __webpack_require__(/*! ./integer */ "./node_modules/fast-check/lib/arbitrary/integer.js");
const TimeToDate_1 = __webpack_require__(/*! ./_internals/mappers/TimeToDate */ "./node_modules/fast-check/lib/arbitrary/_internals/mappers/TimeToDate.js");
function date(constraints) {
    const intMin = constraints && constraints.min !== undefined ? constraints.min.getTime() : -8640000000000000;
    const intMax = constraints && constraints.max !== undefined ? constraints.max.getTime() : 8640000000000000;
    if (Number.isNaN(intMin))
        throw new Error('fc.date min must be valid instance of Date');
    if (Number.isNaN(intMax))
        throw new Error('fc.date max must be valid instance of Date');
    if (intMin > intMax)
        throw new Error('fc.date max must be greater or equal to min');
    return Converters_1.convertFromNext(Converters_1.convertToNext(integer_1.integer(intMin, intMax)).map(TimeToDate_1.timeToDateMapper, TimeToDate_1.timeToDateUnmapper));
}
exports.date = date;


/***/ }),

/***/ "./node_modules/fast-check/lib/arbitrary/dedup.js":
/*!********************************************************!*\
  !*** ./node_modules/fast-check/lib/arbitrary/dedup.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.dedup = void 0;
const clone_1 = __webpack_require__(/*! ./clone */ "./node_modules/fast-check/lib/arbitrary/clone.js");
exports.dedup = clone_1.clone;


/***/ }),

/***/ "./node_modules/fast-check/lib/arbitrary/dictionary.js":
/*!*************************************************************!*\
  !*** ./node_modules/fast-check/lib/arbitrary/dictionary.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.dictionary = void 0;
const Converters_1 = __webpack_require__(/*! ../check/arbitrary/definition/Converters */ "./node_modules/fast-check/lib/check/arbitrary/definition/Converters.js");
const set_1 = __webpack_require__(/*! ./set */ "./node_modules/fast-check/lib/arbitrary/set.js");
const tuple_1 = __webpack_require__(/*! ./tuple */ "./node_modules/fast-check/lib/arbitrary/tuple.js");
const KeyValuePairsToObject_1 = __webpack_require__(/*! ./_internals/mappers/KeyValuePairsToObject */ "./node_modules/fast-check/lib/arbitrary/_internals/mappers/KeyValuePairsToObject.js");
function dictionary(keyArb, valueArb) {
    return Converters_1.convertFromNext(Converters_1.convertToNext(set_1.set(tuple_1.tuple(keyArb, valueArb), { compare: (t1, t2) => t1[0] === t2[0] })).map(KeyValuePairsToObject_1.keyValuePairsToObjectMapper, KeyValuePairsToObject_1.keyValuePairsToObjectUnmapper));
}
exports.dictionary = dictionary;


/***/ }),

/***/ "./node_modules/fast-check/lib/arbitrary/falsy.js":
/*!********************************************************!*\
  !*** ./node_modules/fast-check/lib/arbitrary/falsy.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.falsy = void 0;
const constantFrom_1 = __webpack_require__(/*! ./constantFrom */ "./node_modules/fast-check/lib/arbitrary/constantFrom.js");
function falsy(constraints) {
    if (!constraints || !constraints.withBigInt) {
        return constantFrom_1.constantFrom(false, null, undefined, 0, '', NaN);
    }
    return constantFrom_1.constantFrom(false, null, undefined, 0, '', NaN, BigInt(0));
}
exports.falsy = falsy;


/***/ }),

/***/ "./node_modules/fast-check/lib/arbitrary/float32Array.js":
/*!***************************************************************!*\
  !*** ./node_modules/fast-check/lib/arbitrary/float32Array.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.float32Array = void 0;
const FloatingPointArbitrary_1 = __webpack_require__(/*! ../check/arbitrary/FloatingPointArbitrary */ "./node_modules/fast-check/lib/check/arbitrary/FloatingPointArbitrary.js");
const array_1 = __webpack_require__(/*! ./array */ "./node_modules/fast-check/lib/arbitrary/array.js");
function float32Array(constraints = {}) {
    return array_1.array(FloatingPointArbitrary_1.float(Object.assign(Object.assign({}, constraints), { next: true })), constraints).map((data) => Float32Array.from(data));
}
exports.float32Array = float32Array;


/***/ }),

/***/ "./node_modules/fast-check/lib/arbitrary/float64Array.js":
/*!***************************************************************!*\
  !*** ./node_modules/fast-check/lib/arbitrary/float64Array.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.float64Array = void 0;
const FloatingPointArbitrary_1 = __webpack_require__(/*! ../check/arbitrary/FloatingPointArbitrary */ "./node_modules/fast-check/lib/check/arbitrary/FloatingPointArbitrary.js");
const array_1 = __webpack_require__(/*! ./array */ "./node_modules/fast-check/lib/arbitrary/array.js");
function float64Array(constraints = {}) {
    return array_1.array(FloatingPointArbitrary_1.double(Object.assign(Object.assign({}, constraints), { next: true })), constraints).map((data) => Float64Array.from(data));
}
exports.float64Array = float64Array;


/***/ }),

/***/ "./node_modules/fast-check/lib/arbitrary/frequency.js":
/*!************************************************************!*\
  !*** ./node_modules/fast-check/lib/arbitrary/frequency.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.frequency = void 0;
const FrequencyArbitrary_1 = __webpack_require__(/*! ./_internals/FrequencyArbitrary */ "./node_modules/fast-check/lib/arbitrary/_internals/FrequencyArbitrary.js");
function isFrequencyContraints(param) {
    return param != null && typeof param === 'object' && !('arbitrary' in param);
}
function frequency(...args) {
    const label = 'fc.frequency';
    const constraints = args[0];
    if (isFrequencyContraints(constraints)) {
        return FrequencyArbitrary_1.FrequencyArbitrary.fromOld(args.slice(1), constraints, label);
    }
    return FrequencyArbitrary_1.FrequencyArbitrary.fromOld(args, {}, label);
}
exports.frequency = frequency;


/***/ }),

/***/ "./node_modules/fast-check/lib/arbitrary/fullUnicode.js":
/*!**************************************************************!*\
  !*** ./node_modules/fast-check/lib/arbitrary/fullUnicode.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.fullUnicode = void 0;
const CharacterArbitraryBuilder_1 = __webpack_require__(/*! ./_internals/builders/CharacterArbitraryBuilder */ "./node_modules/fast-check/lib/arbitrary/_internals/builders/CharacterArbitraryBuilder.js");
const IndexToPrintableIndex_1 = __webpack_require__(/*! ./_internals/mappers/IndexToPrintableIndex */ "./node_modules/fast-check/lib/arbitrary/_internals/mappers/IndexToPrintableIndex.js");
const gapSize = 0xdfff + 1 - 0xd800;
function unicodeMapper(v) {
    if (v < 0xd800)
        return IndexToPrintableIndex_1.indexToPrintableIndexMapper(v);
    return v + gapSize;
}
function unicodeUnmapper(v) {
    if (v < 0xd800)
        return IndexToPrintableIndex_1.indexToPrintableIndexUnmapper(v);
    if (v <= 0xdfff)
        return -1;
    return v - gapSize;
}
function fullUnicode() {
    return CharacterArbitraryBuilder_1.buildCharacterArbitrary(0x0000, 0x10ffff - gapSize, unicodeMapper, unicodeUnmapper);
}
exports.fullUnicode = fullUnicode;


/***/ }),

/***/ "./node_modules/fast-check/lib/arbitrary/fullUnicodeString.js":
/*!********************************************************************!*\
  !*** ./node_modules/fast-check/lib/arbitrary/fullUnicodeString.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.fullUnicodeString = void 0;
const Converters_1 = __webpack_require__(/*! ../check/arbitrary/definition/Converters */ "./node_modules/fast-check/lib/check/arbitrary/definition/Converters.js");
const array_1 = __webpack_require__(/*! ./array */ "./node_modules/fast-check/lib/arbitrary/array.js");
const fullUnicode_1 = __webpack_require__(/*! ./fullUnicode */ "./node_modules/fast-check/lib/arbitrary/fullUnicode.js");
const StringConstraintsExtractor_1 = __webpack_require__(/*! ./_internals/helpers/StringConstraintsExtractor */ "./node_modules/fast-check/lib/arbitrary/_internals/helpers/StringConstraintsExtractor.js");
const CodePointsToString_1 = __webpack_require__(/*! ./_internals/mappers/CodePointsToString */ "./node_modules/fast-check/lib/arbitrary/_internals/mappers/CodePointsToString.js");
function fullUnicodeString(...args) {
    const constraints = StringConstraintsExtractor_1.extractStringConstraints(args);
    return Converters_1.convertFromNext(Converters_1.convertToNext(array_1.array(fullUnicode_1.fullUnicode(), constraints)).map(CodePointsToString_1.codePointsToStringMapper, CodePointsToString_1.codePointsToStringUnmapper));
}
exports.fullUnicodeString = fullUnicodeString;


/***/ }),

/***/ "./node_modules/fast-check/lib/arbitrary/func.js":
/*!*******************************************************!*\
  !*** ./node_modules/fast-check/lib/arbitrary/func.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.func = void 0;
const hash_1 = __webpack_require__(/*! ../utils/hash */ "./node_modules/fast-check/lib/utils/hash.js");
const stringify_1 = __webpack_require__(/*! ../utils/stringify */ "./node_modules/fast-check/lib/utils/stringify.js");
const symbols_1 = __webpack_require__(/*! ../check/symbols */ "./node_modules/fast-check/lib/check/symbols.js");
const array_1 = __webpack_require__(/*! ./array */ "./node_modules/fast-check/lib/arbitrary/array.js");
const integer_1 = __webpack_require__(/*! ./integer */ "./node_modules/fast-check/lib/arbitrary/integer.js");
const tuple_1 = __webpack_require__(/*! ./tuple */ "./node_modules/fast-check/lib/arbitrary/tuple.js");
const TextEscaper_1 = __webpack_require__(/*! ../check/arbitrary/helpers/TextEscaper */ "./node_modules/fast-check/lib/check/arbitrary/helpers/TextEscaper.js");
function func(arb) {
    return tuple_1.tuple(array_1.array(arb, { minLength: 1 }), integer_1.integer().noShrink()).map(([outs, seed]) => {
        const producer = () => {
            const recorded = {};
            const f = (...args) => {
                const repr = stringify_1.stringify(args);
                const val = outs[hash_1.hash(`${seed}${repr}`) % outs.length];
                recorded[repr] = val;
                return symbols_1.hasCloneMethod(val) ? val[symbols_1.cloneMethod]() : val;
            };
            function prettyPrint(stringifiedOuts) {
                const seenValues = Object.keys(recorded)
                    .sort()
                    .map((k) => `${k} => ${stringify_1.stringify(recorded[k])}`)
                    .map((line) => `/* ${TextEscaper_1.escapeForMultilineComments(line)} */`);
                return `function(...args) {
  // With hash and stringify coming from fast-check${seenValues.length !== 0 ? `\n  ${seenValues.join('\n  ')}` : ''}
  const outs = ${stringifiedOuts};
  return outs[hash('${seed}' + stringify(args)) % outs.length];
}`;
            }
            return Object.defineProperties(f, {
                toString: { value: () => prettyPrint(stringify_1.stringify(outs)) },
                [stringify_1.toStringMethod]: { value: () => prettyPrint(stringify_1.stringify(outs)) },
                [stringify_1.asyncToStringMethod]: { value: async () => prettyPrint(await stringify_1.asyncStringify(outs)) },
                [symbols_1.cloneMethod]: { value: producer, configurable: true },
            });
        };
        return producer();
    });
}
exports.func = func;


/***/ }),

/***/ "./node_modules/fast-check/lib/arbitrary/genericTuple.js":
/*!***************************************************************!*\
  !*** ./node_modules/fast-check/lib/arbitrary/genericTuple.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.genericTuple = void 0;
const Converters_1 = __webpack_require__(/*! ../check/arbitrary/definition/Converters */ "./node_modules/fast-check/lib/check/arbitrary/definition/Converters.js");
const TupleArbitrary_1 = __webpack_require__(/*! ./_internals/TupleArbitrary */ "./node_modules/fast-check/lib/arbitrary/_internals/TupleArbitrary.js");
function genericTuple(arbs) {
    const nextArbs = arbs.map((arb) => Converters_1.convertToNext(arb));
    return Converters_1.convertFromNext(new TupleArbitrary_1.TupleArbitrary(nextArbs));
}
exports.genericTuple = genericTuple;


/***/ }),

/***/ "./node_modules/fast-check/lib/arbitrary/hexa.js":
/*!*******************************************************!*\
  !*** ./node_modules/fast-check/lib/arbitrary/hexa.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.hexa = void 0;
const CharacterArbitraryBuilder_1 = __webpack_require__(/*! ./_internals/builders/CharacterArbitraryBuilder */ "./node_modules/fast-check/lib/arbitrary/_internals/builders/CharacterArbitraryBuilder.js");
function hexaMapper(v) {
    return v < 10
        ? v + 48
        : v + 97 - 10;
}
function hexaUnmapper(v) {
    return v < 58
        ? v - 48
        : v < 103
            ? v - 97 + 10
            : -1;
}
function hexa() {
    return CharacterArbitraryBuilder_1.buildCharacterArbitrary(0, 15, hexaMapper, hexaUnmapper);
}
exports.hexa = hexa;


/***/ }),

/***/ "./node_modules/fast-check/lib/arbitrary/hexaString.js":
/*!*************************************************************!*\
  !*** ./node_modules/fast-check/lib/arbitrary/hexaString.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.hexaString = void 0;
const Converters_1 = __webpack_require__(/*! ../check/arbitrary/definition/Converters */ "./node_modules/fast-check/lib/check/arbitrary/definition/Converters.js");
const array_1 = __webpack_require__(/*! ./array */ "./node_modules/fast-check/lib/arbitrary/array.js");
const hexa_1 = __webpack_require__(/*! ./hexa */ "./node_modules/fast-check/lib/arbitrary/hexa.js");
const StringConstraintsExtractor_1 = __webpack_require__(/*! ./_internals/helpers/StringConstraintsExtractor */ "./node_modules/fast-check/lib/arbitrary/_internals/helpers/StringConstraintsExtractor.js");
const CodePointsToString_1 = __webpack_require__(/*! ./_internals/mappers/CodePointsToString */ "./node_modules/fast-check/lib/arbitrary/_internals/mappers/CodePointsToString.js");
function hexaString(...args) {
    const constraints = StringConstraintsExtractor_1.extractStringConstraints(args);
    return Converters_1.convertFromNext(Converters_1.convertToNext(array_1.array(hexa_1.hexa(), constraints)).map(CodePointsToString_1.codePointsToStringMapper, CodePointsToString_1.codePointsToStringUnmapper));
}
exports.hexaString = hexaString;


/***/ }),

/***/ "./node_modules/fast-check/lib/arbitrary/infiniteStream.js":
/*!*****************************************************************!*\
  !*** ./node_modules/fast-check/lib/arbitrary/infiniteStream.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.infiniteStream = void 0;
const Converters_1 = __webpack_require__(/*! ../check/arbitrary/definition/Converters */ "./node_modules/fast-check/lib/check/arbitrary/definition/Converters.js");
const StreamArbitrary_1 = __webpack_require__(/*! ./_internals/StreamArbitrary */ "./node_modules/fast-check/lib/arbitrary/_internals/StreamArbitrary.js");
function infiniteStream(arb) {
    return Converters_1.convertFromNext(new StreamArbitrary_1.StreamArbitrary(Converters_1.convertToNext(arb)));
}
exports.infiniteStream = infiniteStream;


/***/ }),

/***/ "./node_modules/fast-check/lib/arbitrary/int16Array.js":
/*!*************************************************************!*\
  !*** ./node_modules/fast-check/lib/arbitrary/int16Array.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.int16Array = void 0;
const integer_1 = __webpack_require__(/*! ./integer */ "./node_modules/fast-check/lib/arbitrary/integer.js");
const TypedIntArrayArbitraryBuilder_1 = __webpack_require__(/*! ./_internals/builders/TypedIntArrayArbitraryBuilder */ "./node_modules/fast-check/lib/arbitrary/_internals/builders/TypedIntArrayArbitraryBuilder.js");
function int16Array(constraints = {}) {
    return TypedIntArrayArbitraryBuilder_1.typedIntArrayArbitraryArbitraryBuilder(constraints, -32768, 32767, Int16Array, integer_1.integer);
}
exports.int16Array = int16Array;


/***/ }),

/***/ "./node_modules/fast-check/lib/arbitrary/int32Array.js":
/*!*************************************************************!*\
  !*** ./node_modules/fast-check/lib/arbitrary/int32Array.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.int32Array = void 0;
const integer_1 = __webpack_require__(/*! ./integer */ "./node_modules/fast-check/lib/arbitrary/integer.js");
const TypedIntArrayArbitraryBuilder_1 = __webpack_require__(/*! ./_internals/builders/TypedIntArrayArbitraryBuilder */ "./node_modules/fast-check/lib/arbitrary/_internals/builders/TypedIntArrayArbitraryBuilder.js");
function int32Array(constraints = {}) {
    return TypedIntArrayArbitraryBuilder_1.typedIntArrayArbitraryArbitraryBuilder(constraints, -0x80000000, 0x7fffffff, Int32Array, integer_1.integer);
}
exports.int32Array = int32Array;


/***/ }),

/***/ "./node_modules/fast-check/lib/arbitrary/int8Array.js":
/*!************************************************************!*\
  !*** ./node_modules/fast-check/lib/arbitrary/int8Array.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.int8Array = void 0;
const integer_1 = __webpack_require__(/*! ./integer */ "./node_modules/fast-check/lib/arbitrary/integer.js");
const TypedIntArrayArbitraryBuilder_1 = __webpack_require__(/*! ./_internals/builders/TypedIntArrayArbitraryBuilder */ "./node_modules/fast-check/lib/arbitrary/_internals/builders/TypedIntArrayArbitraryBuilder.js");
function int8Array(constraints = {}) {
    return TypedIntArrayArbitraryBuilder_1.typedIntArrayArbitraryArbitraryBuilder(constraints, -128, 127, Int8Array, integer_1.integer);
}
exports.int8Array = int8Array;


/***/ }),

/***/ "./node_modules/fast-check/lib/arbitrary/integer.js":
/*!**********************************************************!*\
  !*** ./node_modules/fast-check/lib/arbitrary/integer.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.integer = void 0;
const Converters_1 = __webpack_require__(/*! ../check/arbitrary/definition/Converters */ "./node_modules/fast-check/lib/check/arbitrary/definition/Converters.js");
const IntegerArbitrary_1 = __webpack_require__(/*! ./_internals/IntegerArbitrary */ "./node_modules/fast-check/lib/arbitrary/_internals/IntegerArbitrary.js");
function buildCompleteIntegerConstraints(constraints) {
    const min = constraints.min !== undefined ? constraints.min : -0x80000000;
    const max = constraints.max !== undefined ? constraints.max : 0x7fffffff;
    return { min, max };
}
function extractIntegerConstraints(args) {
    if (args[0] === undefined) {
        return {};
    }
    if (args[1] === undefined) {
        const sargs = args;
        if (typeof sargs[0] === 'number')
            return { max: sargs[0] };
        return sargs[0];
    }
    const sargs = args;
    return { min: sargs[0], max: sargs[1] };
}
function integer(...args) {
    const constraints = buildCompleteIntegerConstraints(extractIntegerConstraints(args));
    if (constraints.min > constraints.max) {
        throw new Error('fc.integer maximum value should be equal or greater than the minimum one');
    }
    const arb = new IntegerArbitrary_1.IntegerArbitrary(constraints.min, constraints.max);
    return Converters_1.convertFromNextWithShrunkOnce(arb, arb.defaultTarget());
}
exports.integer = integer;


/***/ }),

/***/ "./node_modules/fast-check/lib/arbitrary/ipV4.js":
/*!*******************************************************!*\
  !*** ./node_modules/fast-check/lib/arbitrary/ipV4.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ipV4 = void 0;
const Converters_1 = __webpack_require__(/*! ../check/arbitrary/definition/Converters */ "./node_modules/fast-check/lib/check/arbitrary/definition/Converters.js");
const nat_1 = __webpack_require__(/*! ./nat */ "./node_modules/fast-check/lib/arbitrary/nat.js");
const tuple_1 = __webpack_require__(/*! ./tuple */ "./node_modules/fast-check/lib/arbitrary/tuple.js");
const NatToStringifiedNat_1 = __webpack_require__(/*! ./_internals/mappers/NatToStringifiedNat */ "./node_modules/fast-check/lib/arbitrary/_internals/mappers/NatToStringifiedNat.js");
function dotJoinerMapper(data) {
    return data.join('.');
}
function dotJoinerUnmapper(value) {
    if (typeof value !== 'string') {
        throw new Error('Invalid type');
    }
    return value.split('.').map((v) => NatToStringifiedNat_1.tryParseStringifiedNat(v, 10));
}
function ipV4() {
    return Converters_1.convertFromNext(Converters_1.convertToNext(tuple_1.tuple(nat_1.nat(255), nat_1.nat(255), nat_1.nat(255), nat_1.nat(255))).map(dotJoinerMapper, dotJoinerUnmapper));
}
exports.ipV4 = ipV4;


/***/ }),

/***/ "./node_modules/fast-check/lib/arbitrary/ipV4Extended.js":
/*!***************************************************************!*\
  !*** ./node_modules/fast-check/lib/arbitrary/ipV4Extended.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ipV4Extended = void 0;
const oneof_1 = __webpack_require__(/*! ./oneof */ "./node_modules/fast-check/lib/arbitrary/oneof.js");
const tuple_1 = __webpack_require__(/*! ./tuple */ "./node_modules/fast-check/lib/arbitrary/tuple.js");
const StringifiedNatArbitraryBuilder_1 = __webpack_require__(/*! ./_internals/builders/StringifiedNatArbitraryBuilder */ "./node_modules/fast-check/lib/arbitrary/_internals/builders/StringifiedNatArbitraryBuilder.js");
const Converters_1 = __webpack_require__(/*! ../check/arbitrary/definition/Converters */ "./node_modules/fast-check/lib/check/arbitrary/definition/Converters.js");
function dotJoinerMapper(data) {
    return data.join('.');
}
function dotJoinerUnmapper(value) {
    if (typeof value !== 'string') {
        throw new Error('Invalid type');
    }
    return value.split('.');
}
function ipV4Extended() {
    return oneof_1.oneof(Converters_1.convertFromNext(Converters_1.convertToNext(tuple_1.tuple(StringifiedNatArbitraryBuilder_1.buildStringifiedNatArbitrary(255), StringifiedNatArbitraryBuilder_1.buildStringifiedNatArbitrary(255), StringifiedNatArbitraryBuilder_1.buildStringifiedNatArbitrary(255), StringifiedNatArbitraryBuilder_1.buildStringifiedNatArbitrary(255))).map(dotJoinerMapper, dotJoinerUnmapper)), Converters_1.convertFromNext(Converters_1.convertToNext(tuple_1.tuple(StringifiedNatArbitraryBuilder_1.buildStringifiedNatArbitrary(255), StringifiedNatArbitraryBuilder_1.buildStringifiedNatArbitrary(255), StringifiedNatArbitraryBuilder_1.buildStringifiedNatArbitrary(65535))).map(dotJoinerMapper, dotJoinerUnmapper)), Converters_1.convertFromNext(Converters_1.convertToNext(tuple_1.tuple(StringifiedNatArbitraryBuilder_1.buildStringifiedNatArbitrary(255), StringifiedNatArbitraryBuilder_1.buildStringifiedNatArbitrary(16777215))).map(dotJoinerMapper, dotJoinerUnmapper)), StringifiedNatArbitraryBuilder_1.buildStringifiedNatArbitrary(4294967295));
}
exports.ipV4Extended = ipV4Extended;


/***/ }),

/***/ "./node_modules/fast-check/lib/arbitrary/ipV6.js":
/*!*******************************************************!*\
  !*** ./node_modules/fast-check/lib/arbitrary/ipV6.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ipV6 = void 0;
const array_1 = __webpack_require__(/*! ./array */ "./node_modules/fast-check/lib/arbitrary/array.js");
const Converters_1 = __webpack_require__(/*! ../check/arbitrary/definition/Converters */ "./node_modules/fast-check/lib/check/arbitrary/definition/Converters.js");
const oneof_1 = __webpack_require__(/*! ./oneof */ "./node_modules/fast-check/lib/arbitrary/oneof.js");
const hexaString_1 = __webpack_require__(/*! ./hexaString */ "./node_modules/fast-check/lib/arbitrary/hexaString.js");
const tuple_1 = __webpack_require__(/*! ./tuple */ "./node_modules/fast-check/lib/arbitrary/tuple.js");
const ipV4_1 = __webpack_require__(/*! ./ipV4 */ "./node_modules/fast-check/lib/arbitrary/ipV4.js");
const EntitiesToIPv6_1 = __webpack_require__(/*! ./_internals/mappers/EntitiesToIPv6 */ "./node_modules/fast-check/lib/arbitrary/_internals/mappers/EntitiesToIPv6.js");
function h16sTol32Mapper([a, b]) {
    return `${a}:${b}`;
}
function h16sTol32Unmapper(value) {
    if (typeof value !== 'string')
        throw new Error('Invalid type');
    if (!value.includes(':'))
        throw new Error('Invalid value');
    return value.split(':', 2);
}
function ipV6() {
    const h16Arb = hexaString_1.hexaString({ minLength: 1, maxLength: 4 });
    const ls32Arb = oneof_1.oneof(Converters_1.convertFromNext(Converters_1.convertToNext(tuple_1.tuple(h16Arb, h16Arb)).map(h16sTol32Mapper, h16sTol32Unmapper)), ipV4_1.ipV4());
    return oneof_1.oneof(Converters_1.convertFromNext(Converters_1.convertToNext(tuple_1.tuple(array_1.array(h16Arb, { minLength: 6, maxLength: 6 }), ls32Arb)).map(EntitiesToIPv6_1.fullySpecifiedMapper, EntitiesToIPv6_1.fullySpecifiedUnmapper)), Converters_1.convertFromNext(Converters_1.convertToNext(tuple_1.tuple(array_1.array(h16Arb, { minLength: 5, maxLength: 5 }), ls32Arb)).map(EntitiesToIPv6_1.onlyTrailingMapper, EntitiesToIPv6_1.onlyTrailingUnmapper)), Converters_1.convertFromNext(Converters_1.convertToNext(tuple_1.tuple(array_1.array(h16Arb, { minLength: 0, maxLength: 1 }), array_1.array(h16Arb, { minLength: 4, maxLength: 4 }), ls32Arb)).map(EntitiesToIPv6_1.multiTrailingMapper, EntitiesToIPv6_1.multiTrailingUnmapper)), Converters_1.convertFromNext(Converters_1.convertToNext(tuple_1.tuple(array_1.array(h16Arb, { minLength: 0, maxLength: 2 }), array_1.array(h16Arb, { minLength: 3, maxLength: 3 }), ls32Arb)).map(EntitiesToIPv6_1.multiTrailingMapper, EntitiesToIPv6_1.multiTrailingUnmapper)), Converters_1.convertFromNext(Converters_1.convertToNext(tuple_1.tuple(array_1.array(h16Arb, { minLength: 0, maxLength: 3 }), array_1.array(h16Arb, { minLength: 2, maxLength: 2 }), ls32Arb)).map(EntitiesToIPv6_1.multiTrailingMapper, EntitiesToIPv6_1.multiTrailingUnmapper)), Converters_1.convertFromNext(Converters_1.convertToNext(tuple_1.tuple(array_1.array(h16Arb, { minLength: 0, maxLength: 4 }), h16Arb, ls32Arb)).map(EntitiesToIPv6_1.multiTrailingMapperOne, EntitiesToIPv6_1.multiTrailingUnmapperOne)), Converters_1.convertFromNext(Converters_1.convertToNext(tuple_1.tuple(array_1.array(h16Arb, { minLength: 0, maxLength: 5 }), ls32Arb)).map(EntitiesToIPv6_1.singleTrailingMapper, EntitiesToIPv6_1.singleTrailingUnmapper)), Converters_1.convertFromNext(Converters_1.convertToNext(tuple_1.tuple(array_1.array(h16Arb, { minLength: 0, maxLength: 6 }), h16Arb)).map(EntitiesToIPv6_1.singleTrailingMapper, EntitiesToIPv6_1.singleTrailingUnmapper)), Converters_1.convertFromNext(Converters_1.convertToNext(tuple_1.tuple(array_1.array(h16Arb, { minLength: 0, maxLength: 7 }))).map(EntitiesToIPv6_1.noTrailingMapper, EntitiesToIPv6_1.noTrailingUnmapper)));
}
exports.ipV6 = ipV6;


/***/ }),

/***/ "./node_modules/fast-check/lib/arbitrary/letrec.js":
/*!*********************************************************!*\
  !*** ./node_modules/fast-check/lib/arbitrary/letrec.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.letrec = void 0;
const LazyArbitrary_1 = __webpack_require__(/*! ./_internals/LazyArbitrary */ "./node_modules/fast-check/lib/arbitrary/_internals/LazyArbitrary.js");
const Converters_1 = __webpack_require__(/*! ../check/arbitrary/definition/Converters */ "./node_modules/fast-check/lib/check/arbitrary/definition/Converters.js");
function letrec(builder) {
    const lazyArbs = Object.create(null);
    const tie = (key) => {
        if (!Object.prototype.hasOwnProperty.call(lazyArbs, key)) {
            lazyArbs[key] = new LazyArbitrary_1.LazyArbitrary(String(key));
        }
        return Converters_1.convertFromNext(lazyArbs[key]);
    };
    const strictArbs = builder(tie);
    for (const key in strictArbs) {
        if (!Object.prototype.hasOwnProperty.call(strictArbs, key)) {
            continue;
        }
        const lazyAtKey = lazyArbs[key];
        const lazyArb = lazyAtKey !== undefined ? lazyAtKey : new LazyArbitrary_1.LazyArbitrary(key);
        lazyArb.underlying = Converters_1.convertToNext(strictArbs[key]);
        lazyArbs[key] = lazyArb;
    }
    return strictArbs;
}
exports.letrec = letrec;


/***/ }),

/***/ "./node_modules/fast-check/lib/arbitrary/lorem.js":
/*!********************************************************!*\
  !*** ./node_modules/fast-check/lib/arbitrary/lorem.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.lorem = void 0;
const array_1 = __webpack_require__(/*! ./array */ "./node_modules/fast-check/lib/arbitrary/array.js");
const constant_1 = __webpack_require__(/*! ./constant */ "./node_modules/fast-check/lib/arbitrary/constant.js");
const frequency_1 = __webpack_require__(/*! ./frequency */ "./node_modules/fast-check/lib/arbitrary/frequency.js");
const WordsToLorem_1 = __webpack_require__(/*! ./_internals/mappers/WordsToLorem */ "./node_modules/fast-check/lib/arbitrary/_internals/mappers/WordsToLorem.js");
const Converters_1 = __webpack_require__(/*! ../check/arbitrary/definition/Converters */ "./node_modules/fast-check/lib/check/arbitrary/definition/Converters.js");
const h = (v, w) => {
    return { arbitrary: constant_1.constant(v), weight: w };
};
function loremWord() {
    return frequency_1.frequency(h('non', 6), h('adipiscing', 5), h('ligula', 5), h('enim', 5), h('pellentesque', 5), h('in', 5), h('augue', 5), h('et', 5), h('nulla', 5), h('lorem', 4), h('sit', 4), h('sed', 4), h('diam', 4), h('fermentum', 4), h('ut', 4), h('eu', 4), h('aliquam', 4), h('mauris', 4), h('vitae', 4), h('felis', 4), h('ipsum', 3), h('dolor', 3), h('amet,', 3), h('elit', 3), h('euismod', 3), h('mi', 3), h('orci', 3), h('erat', 3), h('praesent', 3), h('egestas', 3), h('leo', 3), h('vel', 3), h('sapien', 3), h('integer', 3), h('curabitur', 3), h('convallis', 3), h('purus', 3), h('risus', 2), h('suspendisse', 2), h('lectus', 2), h('nec,', 2), h('ultricies', 2), h('sed,', 2), h('cras', 2), h('elementum', 2), h('ultrices', 2), h('maecenas', 2), h('massa,', 2), h('varius', 2), h('a,', 2), h('semper', 2), h('proin', 2), h('nec', 2), h('nisl', 2), h('amet', 2), h('duis', 2), h('congue', 2), h('libero', 2), h('vestibulum', 2), h('pede', 2), h('blandit', 2), h('sodales', 2), h('ante', 2), h('nibh', 2), h('ac', 2), h('aenean', 2), h('massa', 2), h('suscipit', 2), h('sollicitudin', 2), h('fusce', 2), h('tempus', 2), h('aliquam,', 2), h('nunc', 2), h('ullamcorper', 2), h('rhoncus', 2), h('metus', 2), h('faucibus,', 2), h('justo', 2), h('magna', 2), h('at', 2), h('tincidunt', 2), h('consectetur', 1), h('tortor,', 1), h('dignissim', 1), h('congue,', 1), h('non,', 1), h('porttitor,', 1), h('nonummy', 1), h('molestie,', 1), h('est', 1), h('eleifend', 1), h('mi,', 1), h('arcu', 1), h('scelerisque', 1), h('vitae,', 1), h('consequat', 1), h('in,', 1), h('pretium', 1), h('volutpat', 1), h('pharetra', 1), h('tempor', 1), h('bibendum', 1), h('odio', 1), h('dui', 1), h('primis', 1), h('faucibus', 1), h('luctus', 1), h('posuere', 1), h('cubilia', 1), h('curae,', 1), h('hendrerit', 1), h('velit', 1), h('mauris,', 1), h('gravida', 1), h('ornare', 1), h('ut,', 1), h('pulvinar', 1), h('varius,', 1), h('turpis', 1), h('nibh,', 1), h('eros', 1), h('id', 1), h('aliquet', 1), h('quis', 1), h('lobortis', 1), h('consectetuer', 1), h('morbi', 1), h('vehicula', 1), h('tortor', 1), h('tellus,', 1), h('id,', 1), h('eu,', 1), h('quam', 1), h('feugiat,', 1), h('posuere,', 1), h('iaculis', 1), h('lectus,', 1), h('tristique', 1), h('mollis,', 1), h('nisl,', 1), h('vulputate', 1), h('sem', 1), h('vivamus', 1), h('placerat', 1), h('imperdiet', 1), h('cursus', 1), h('rutrum', 1), h('iaculis,', 1), h('augue,', 1), h('lacus', 1));
}
function lorem(...args) {
    const maxWordsCount = typeof args[0] === 'object' ? args[0].maxCount : args[0];
    const sentencesMode = typeof args[0] === 'object' ? args[0].mode === 'sentences' : args[1];
    const maxCount = maxWordsCount !== undefined ? maxWordsCount : 5;
    if (maxCount < 1) {
        throw new Error(`lorem has to produce at least one word/sentence`);
    }
    const wordArbitrary = loremWord();
    const wordArbitraryNext = Converters_1.convertToNext(wordArbitrary);
    if (sentencesMode) {
        const sentence = Converters_1.convertToNext(array_1.array(wordArbitrary, { minLength: 1 })).map(WordsToLorem_1.wordsToSentenceMapper, WordsToLorem_1.wordsToSentenceUnmapperFor(wordArbitraryNext));
        return Converters_1.convertFromNext(Converters_1.convertToNext(array_1.array(Converters_1.convertFromNext(sentence), { minLength: 1, maxLength: maxCount })).map(WordsToLorem_1.sentencesToParagraphMapper, WordsToLorem_1.sentencesToParagraphUnmapper));
    }
    else {
        return Converters_1.convertFromNext(Converters_1.convertToNext(array_1.array(wordArbitrary, { minLength: 1, maxLength: maxCount })).map(WordsToLorem_1.wordsToJoinedStringMapper, WordsToLorem_1.wordsToJoinedStringUnmapperFor(wordArbitraryNext)));
    }
}
exports.lorem = lorem;


/***/ }),

/***/ "./node_modules/fast-check/lib/arbitrary/mapToConstant.js":
/*!****************************************************************!*\
  !*** ./node_modules/fast-check/lib/arbitrary/mapToConstant.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.mapToConstant = void 0;
const Converters_1 = __webpack_require__(/*! ../check/arbitrary/definition/Converters */ "./node_modules/fast-check/lib/check/arbitrary/definition/Converters.js");
const nat_1 = __webpack_require__(/*! ./nat */ "./node_modules/fast-check/lib/arbitrary/nat.js");
const IndexToMappedConstant_1 = __webpack_require__(/*! ./_internals/mappers/IndexToMappedConstant */ "./node_modules/fast-check/lib/arbitrary/_internals/mappers/IndexToMappedConstant.js");
function computeNumChoices(options) {
    if (options.length === 0)
        throw new Error(`fc.mapToConstant expects at least one option`);
    let numChoices = 0;
    for (let idx = 0; idx !== options.length; ++idx) {
        if (options[idx].num < 0)
            throw new Error(`fc.mapToConstant expects all options to have a number of entries greater or equal to zero`);
        numChoices += options[idx].num;
    }
    if (numChoices === 0)
        throw new Error(`fc.mapToConstant expects at least one choice among options`);
    return numChoices;
}
function mapToConstant(...entries) {
    const numChoices = computeNumChoices(entries);
    return Converters_1.convertFromNext(Converters_1.convertToNext(nat_1.nat({ max: numChoices - 1 })).map(IndexToMappedConstant_1.indexToMappedConstantMapperFor(entries), IndexToMappedConstant_1.indexToMappedConstantUnmapperFor(entries)));
}
exports.mapToConstant = mapToConstant;


/***/ }),

/***/ "./node_modules/fast-check/lib/arbitrary/maxSafeInteger.js":
/*!*****************************************************************!*\
  !*** ./node_modules/fast-check/lib/arbitrary/maxSafeInteger.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.maxSafeInteger = void 0;
const Converters_1 = __webpack_require__(/*! ../check/arbitrary/definition/Converters */ "./node_modules/fast-check/lib/check/arbitrary/definition/Converters.js");
const IntegerArbitrary_1 = __webpack_require__(/*! ./_internals/IntegerArbitrary */ "./node_modules/fast-check/lib/arbitrary/_internals/IntegerArbitrary.js");
function maxSafeInteger() {
    const arb = new IntegerArbitrary_1.IntegerArbitrary(Number.MIN_SAFE_INTEGER, Number.MAX_SAFE_INTEGER);
    return Converters_1.convertFromNextWithShrunkOnce(arb, arb.defaultTarget());
}
exports.maxSafeInteger = maxSafeInteger;


/***/ }),

/***/ "./node_modules/fast-check/lib/arbitrary/maxSafeNat.js":
/*!*************************************************************!*\
  !*** ./node_modules/fast-check/lib/arbitrary/maxSafeNat.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.maxSafeNat = void 0;
const Converters_1 = __webpack_require__(/*! ../check/arbitrary/definition/Converters */ "./node_modules/fast-check/lib/check/arbitrary/definition/Converters.js");
const IntegerArbitrary_1 = __webpack_require__(/*! ./_internals/IntegerArbitrary */ "./node_modules/fast-check/lib/arbitrary/_internals/IntegerArbitrary.js");
function maxSafeNat() {
    const arb = new IntegerArbitrary_1.IntegerArbitrary(0, Number.MAX_SAFE_INTEGER);
    return Converters_1.convertFromNextWithShrunkOnce(arb, arb.defaultTarget());
}
exports.maxSafeNat = maxSafeNat;


/***/ }),

/***/ "./node_modules/fast-check/lib/arbitrary/memo.js":
/*!*******************************************************!*\
  !*** ./node_modules/fast-check/lib/arbitrary/memo.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.memo = void 0;
let contextRemainingDepth = 10;
function memo(builder) {
    const previous = {};
    return ((maxDepth) => {
        const n = maxDepth !== undefined ? maxDepth : contextRemainingDepth;
        if (!Object.prototype.hasOwnProperty.call(previous, n)) {
            const prev = contextRemainingDepth;
            contextRemainingDepth = n - 1;
            previous[n] = builder(n);
            contextRemainingDepth = prev;
        }
        return previous[n];
    });
}
exports.memo = memo;


/***/ }),

/***/ "./node_modules/fast-check/lib/arbitrary/mixedCase.js":
/*!************************************************************!*\
  !*** ./node_modules/fast-check/lib/arbitrary/mixedCase.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.mixedCase = void 0;
const Converters_1 = __webpack_require__(/*! ../check/arbitrary/definition/Converters */ "./node_modules/fast-check/lib/check/arbitrary/definition/Converters.js");
const MixedCaseArbitrary_1 = __webpack_require__(/*! ./_internals/MixedCaseArbitrary */ "./node_modules/fast-check/lib/arbitrary/_internals/MixedCaseArbitrary.js");
function defaultToggleCase(rawChar) {
    const upper = rawChar.toUpperCase();
    if (upper !== rawChar)
        return upper;
    return rawChar.toLowerCase();
}
function mixedCase(stringArb, constraints) {
    if (typeof BigInt === 'undefined') {
        throw new Error(`mixedCase requires BigInt support`);
    }
    const toggleCase = (constraints && constraints.toggleCase) || defaultToggleCase;
    return Converters_1.convertFromNext(new MixedCaseArbitrary_1.MixedCaseArbitrary(Converters_1.convertToNext(stringArb), toggleCase));
}
exports.mixedCase = mixedCase;


/***/ }),

/***/ "./node_modules/fast-check/lib/arbitrary/nat.js":
/*!******************************************************!*\
  !*** ./node_modules/fast-check/lib/arbitrary/nat.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.nat = void 0;
const Converters_1 = __webpack_require__(/*! ../check/arbitrary/definition/Converters */ "./node_modules/fast-check/lib/check/arbitrary/definition/Converters.js");
const IntegerArbitrary_1 = __webpack_require__(/*! ./_internals/IntegerArbitrary */ "./node_modules/fast-check/lib/arbitrary/_internals/IntegerArbitrary.js");
function nat(arg) {
    const max = typeof arg === 'number' ? arg : arg && arg.max !== undefined ? arg.max : 0x7fffffff;
    if (max < 0) {
        throw new Error('fc.nat value should be greater than or equal to 0');
    }
    const arb = new IntegerArbitrary_1.IntegerArbitrary(0, max);
    return Converters_1.convertFromNextWithShrunkOnce(arb, arb.defaultTarget());
}
exports.nat = nat;


/***/ }),

/***/ "./node_modules/fast-check/lib/arbitrary/oneof.js":
/*!********************************************************!*\
  !*** ./node_modules/fast-check/lib/arbitrary/oneof.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.oneof = void 0;
const FrequencyArbitrary_1 = __webpack_require__(/*! ./_internals/FrequencyArbitrary */ "./node_modules/fast-check/lib/arbitrary/_internals/FrequencyArbitrary.js");
function isOneOfContraints(param) {
    return param != null && typeof param === 'object' && !('generate' in param);
}
function oneof(...args) {
    const constraints = args[0];
    if (isOneOfContraints(constraints)) {
        const weightedArbs = args.slice(1).map((arbitrary) => ({ arbitrary, weight: 1 }));
        return FrequencyArbitrary_1.FrequencyArbitrary.fromOld(weightedArbs, constraints, 'fc.oneof');
    }
    const weightedArbs = args.map((arbitrary) => ({ arbitrary, weight: 1 }));
    return FrequencyArbitrary_1.FrequencyArbitrary.fromOld(weightedArbs, {}, 'fc.oneof');
}
exports.oneof = oneof;


/***/ }),

/***/ "./node_modules/fast-check/lib/arbitrary/option.js":
/*!*********************************************************!*\
  !*** ./node_modules/fast-check/lib/arbitrary/option.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.option = void 0;
const constant_1 = __webpack_require__(/*! ./constant */ "./node_modules/fast-check/lib/arbitrary/constant.js");
const FrequencyArbitrary_1 = __webpack_require__(/*! ./_internals/FrequencyArbitrary */ "./node_modules/fast-check/lib/arbitrary/_internals/FrequencyArbitrary.js");
function extractOptionConstraints(constraints) {
    if (typeof constraints === 'number')
        return { freq: constraints };
    if (!constraints)
        return {};
    return constraints;
}
function option(arb, rawConstraints) {
    const constraints = extractOptionConstraints(rawConstraints);
    const freq = constraints.freq == null ? 5 : constraints.freq;
    const nilValue = Object.prototype.hasOwnProperty.call(constraints, 'nil') ? constraints.nil : null;
    const nilArb = constant_1.constant(nilValue);
    const weightedArbs = [
        { arbitrary: nilArb, weight: 1, fallbackValue: { default: nilValue } },
        { arbitrary: arb, weight: freq },
    ];
    const frequencyConstraints = {
        withCrossShrink: true,
        depthFactor: constraints.depthFactor,
        maxDepth: constraints.maxDepth,
        depthIdentifier: constraints.depthIdentifier,
    };
    return FrequencyArbitrary_1.FrequencyArbitrary.fromOld(weightedArbs, frequencyConstraints, 'fc.option');
}
exports.option = option;


/***/ }),

/***/ "./node_modules/fast-check/lib/arbitrary/record.js":
/*!*********************************************************!*\
  !*** ./node_modules/fast-check/lib/arbitrary/record.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.record = void 0;
const PartialRecordArbitraryBuilder_1 = __webpack_require__(/*! ./_internals/builders/PartialRecordArbitraryBuilder */ "./node_modules/fast-check/lib/arbitrary/_internals/builders/PartialRecordArbitraryBuilder.js");
function record(recordModel, constraints) {
    if (constraints == null) {
        return PartialRecordArbitraryBuilder_1.buildPartialRecordArbitrary(recordModel, undefined);
    }
    if ('withDeletedKeys' in constraints && 'requiredKeys' in constraints) {
        throw new Error(`requiredKeys and withDeletedKeys cannot be used together in fc.record`);
    }
    const requireDeletedKeys = ('requiredKeys' in constraints && constraints.requiredKeys !== undefined) ||
        ('withDeletedKeys' in constraints && !!constraints.withDeletedKeys);
    if (!requireDeletedKeys) {
        return PartialRecordArbitraryBuilder_1.buildPartialRecordArbitrary(recordModel, undefined);
    }
    const requiredKeys = ('requiredKeys' in constraints ? constraints.requiredKeys : undefined) || [];
    for (let idx = 0; idx !== requiredKeys.length; ++idx) {
        const descriptor = Object.getOwnPropertyDescriptor(recordModel, requiredKeys[idx]);
        if (descriptor === undefined) {
            throw new Error(`requiredKeys cannot reference keys that have not been defined in recordModel`);
        }
        if (!descriptor.enumerable) {
            throw new Error(`requiredKeys cannot reference keys that have are enumerable in recordModel`);
        }
    }
    return PartialRecordArbitraryBuilder_1.buildPartialRecordArbitrary(recordModel, requiredKeys);
}
exports.record = record;


/***/ }),

/***/ "./node_modules/fast-check/lib/arbitrary/scheduler.js":
/*!************************************************************!*\
  !*** ./node_modules/fast-check/lib/arbitrary/scheduler.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.schedulerFor = exports.scheduler = void 0;
const Converters_1 = __webpack_require__(/*! ../check/arbitrary/definition/Converters */ "./node_modules/fast-check/lib/check/arbitrary/definition/Converters.js");
const BuildSchedulerFor_1 = __webpack_require__(/*! ./_internals/helpers/BuildSchedulerFor */ "./node_modules/fast-check/lib/arbitrary/_internals/helpers/BuildSchedulerFor.js");
const SchedulerArbitrary_1 = __webpack_require__(/*! ./_internals/SchedulerArbitrary */ "./node_modules/fast-check/lib/arbitrary/_internals/SchedulerArbitrary.js");
function scheduler(constraints) {
    const { act = (f) => f() } = constraints || {};
    return Converters_1.convertFromNext(new SchedulerArbitrary_1.SchedulerArbitrary(act));
}
exports.scheduler = scheduler;
function schedulerFor(customOrderingOrConstraints, constraintsOrUndefined) {
    const { act = (f) => f() } = Array.isArray(customOrderingOrConstraints)
        ? constraintsOrUndefined || {}
        : customOrderingOrConstraints || {};
    if (Array.isArray(customOrderingOrConstraints)) {
        return BuildSchedulerFor_1.buildSchedulerFor(act, customOrderingOrConstraints);
    }
    return function (_strs, ...ordering) {
        return BuildSchedulerFor_1.buildSchedulerFor(act, ordering);
    };
}
exports.schedulerFor = schedulerFor;


/***/ }),

/***/ "./node_modules/fast-check/lib/arbitrary/set.js":
/*!******************************************************!*\
  !*** ./node_modules/fast-check/lib/arbitrary/set.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.set = void 0;
const ArrayArbitrary_1 = __webpack_require__(/*! ./_internals/ArrayArbitrary */ "./node_modules/fast-check/lib/arbitrary/_internals/ArrayArbitrary.js");
const Converters_1 = __webpack_require__(/*! ../check/arbitrary/definition/Converters */ "./node_modules/fast-check/lib/check/arbitrary/definition/Converters.js");
const MaxLengthFromMinLength_1 = __webpack_require__(/*! ./_internals/helpers/MaxLengthFromMinLength */ "./node_modules/fast-check/lib/arbitrary/_internals/helpers/MaxLengthFromMinLength.js");
function buildCompleteSetConstraints(constraints) {
    const minLength = constraints.minLength !== undefined ? constraints.minLength : 0;
    const maxLength = constraints.maxLength !== undefined ? constraints.maxLength : MaxLengthFromMinLength_1.maxLengthFromMinLength(minLength);
    const compare = constraints.compare !== undefined ? constraints.compare : (a, b) => a === b;
    return { minLength, maxLength, compare };
}
function extractSetConstraints(args) {
    if (args[0] === undefined) {
        return {};
    }
    if (args[1] === undefined) {
        const sargs = args;
        if (typeof sargs[0] === 'number')
            return { maxLength: sargs[0] };
        if (typeof sargs[0] === 'function')
            return { compare: sargs[0] };
        return sargs[0];
    }
    if (args[2] === undefined) {
        const sargs = args;
        if (typeof sargs[1] === 'number')
            return { minLength: sargs[0], maxLength: sargs[1] };
        return { maxLength: sargs[0], compare: sargs[1] };
    }
    const sargs = args;
    return { minLength: sargs[0], maxLength: sargs[1], compare: sargs[2] };
}
function set(arb, ...args) {
    const constraints = buildCompleteSetConstraints(extractSetConstraints(args));
    const minLength = constraints.minLength;
    const maxLength = constraints.maxLength;
    const compare = constraints.compare;
    const nextArb = Converters_1.convertToNext(arb);
    const arrayArb = Converters_1.convertFromNext(new ArrayArbitrary_1.ArrayArbitrary(nextArb, minLength, maxLength, compare));
    if (minLength === 0)
        return arrayArb;
    return arrayArb.filter((tab) => tab.length >= minLength);
}
exports.set = set;


/***/ }),

/***/ "./node_modules/fast-check/lib/arbitrary/string.js":
/*!*********************************************************!*\
  !*** ./node_modules/fast-check/lib/arbitrary/string.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.string = void 0;
const Converters_1 = __webpack_require__(/*! ../check/arbitrary/definition/Converters */ "./node_modules/fast-check/lib/check/arbitrary/definition/Converters.js");
const array_1 = __webpack_require__(/*! ./array */ "./node_modules/fast-check/lib/arbitrary/array.js");
const char_1 = __webpack_require__(/*! ./char */ "./node_modules/fast-check/lib/arbitrary/char.js");
const StringConstraintsExtractor_1 = __webpack_require__(/*! ./_internals/helpers/StringConstraintsExtractor */ "./node_modules/fast-check/lib/arbitrary/_internals/helpers/StringConstraintsExtractor.js");
const CodePointsToString_1 = __webpack_require__(/*! ./_internals/mappers/CodePointsToString */ "./node_modules/fast-check/lib/arbitrary/_internals/mappers/CodePointsToString.js");
function string(...args) {
    const constraints = StringConstraintsExtractor_1.extractStringConstraints(args);
    return Converters_1.convertFromNext(Converters_1.convertToNext(array_1.array(char_1.char(), constraints)).map(CodePointsToString_1.codePointsToStringMapper, CodePointsToString_1.codePointsToStringUnmapper));
}
exports.string = string;


/***/ }),

/***/ "./node_modules/fast-check/lib/arbitrary/string16bits.js":
/*!***************************************************************!*\
  !*** ./node_modules/fast-check/lib/arbitrary/string16bits.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.string16bits = void 0;
const Converters_1 = __webpack_require__(/*! ../check/arbitrary/definition/Converters */ "./node_modules/fast-check/lib/check/arbitrary/definition/Converters.js");
const array_1 = __webpack_require__(/*! ./array */ "./node_modules/fast-check/lib/arbitrary/array.js");
const char16bits_1 = __webpack_require__(/*! ./char16bits */ "./node_modules/fast-check/lib/arbitrary/char16bits.js");
const StringConstraintsExtractor_1 = __webpack_require__(/*! ./_internals/helpers/StringConstraintsExtractor */ "./node_modules/fast-check/lib/arbitrary/_internals/helpers/StringConstraintsExtractor.js");
const CharsToString_1 = __webpack_require__(/*! ./_internals/mappers/CharsToString */ "./node_modules/fast-check/lib/arbitrary/_internals/mappers/CharsToString.js");
function string16bits(...args) {
    const constraints = StringConstraintsExtractor_1.extractStringConstraints(args);
    return Converters_1.convertFromNext(Converters_1.convertToNext(array_1.array(char16bits_1.char16bits(), constraints)).map(CharsToString_1.charsToStringMapper, CharsToString_1.charsToStringUnmapper));
}
exports.string16bits = string16bits;


/***/ }),

/***/ "./node_modules/fast-check/lib/arbitrary/stringOf.js":
/*!***********************************************************!*\
  !*** ./node_modules/fast-check/lib/arbitrary/stringOf.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.stringOf = void 0;
const Converters_1 = __webpack_require__(/*! ../check/arbitrary/definition/Converters */ "./node_modules/fast-check/lib/check/arbitrary/definition/Converters.js");
const array_1 = __webpack_require__(/*! ./array */ "./node_modules/fast-check/lib/arbitrary/array.js");
const StringConstraintsExtractor_1 = __webpack_require__(/*! ./_internals/helpers/StringConstraintsExtractor */ "./node_modules/fast-check/lib/arbitrary/_internals/helpers/StringConstraintsExtractor.js");
const PatternsToString_1 = __webpack_require__(/*! ./_internals/mappers/PatternsToString */ "./node_modules/fast-check/lib/arbitrary/_internals/mappers/PatternsToString.js");
function stringOf(charArb, ...args) {
    const constraints = StringConstraintsExtractor_1.extractStringConstraints(args);
    return Converters_1.convertFromNext(Converters_1.convertToNext(array_1.array(charArb, constraints)).map(PatternsToString_1.patternsToStringMapper, PatternsToString_1.patternsToStringUnmapperFor(Converters_1.convertToNext(charArb), constraints)));
}
exports.stringOf = stringOf;


/***/ }),

/***/ "./node_modules/fast-check/lib/arbitrary/tuple.js":
/*!********************************************************!*\
  !*** ./node_modules/fast-check/lib/arbitrary/tuple.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.tuple = void 0;
const Converters_1 = __webpack_require__(/*! ../check/arbitrary/definition/Converters */ "./node_modules/fast-check/lib/check/arbitrary/definition/Converters.js");
const TupleArbitrary_1 = __webpack_require__(/*! ./_internals/TupleArbitrary */ "./node_modules/fast-check/lib/arbitrary/_internals/TupleArbitrary.js");
function tuple(...arbs) {
    const nextArbs = arbs.map((arb) => Converters_1.convertToNext(arb));
    return Converters_1.convertFromNext(new TupleArbitrary_1.TupleArbitrary(nextArbs));
}
exports.tuple = tuple;


/***/ }),

/***/ "./node_modules/fast-check/lib/arbitrary/uint16Array.js":
/*!**************************************************************!*\
  !*** ./node_modules/fast-check/lib/arbitrary/uint16Array.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.uint16Array = void 0;
const integer_1 = __webpack_require__(/*! ./integer */ "./node_modules/fast-check/lib/arbitrary/integer.js");
const TypedIntArrayArbitraryBuilder_1 = __webpack_require__(/*! ./_internals/builders/TypedIntArrayArbitraryBuilder */ "./node_modules/fast-check/lib/arbitrary/_internals/builders/TypedIntArrayArbitraryBuilder.js");
function uint16Array(constraints = {}) {
    return TypedIntArrayArbitraryBuilder_1.typedIntArrayArbitraryArbitraryBuilder(constraints, 0, 65535, Uint16Array, integer_1.integer);
}
exports.uint16Array = uint16Array;


/***/ }),

/***/ "./node_modules/fast-check/lib/arbitrary/uint32Array.js":
/*!**************************************************************!*\
  !*** ./node_modules/fast-check/lib/arbitrary/uint32Array.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.uint32Array = void 0;
const integer_1 = __webpack_require__(/*! ./integer */ "./node_modules/fast-check/lib/arbitrary/integer.js");
const TypedIntArrayArbitraryBuilder_1 = __webpack_require__(/*! ./_internals/builders/TypedIntArrayArbitraryBuilder */ "./node_modules/fast-check/lib/arbitrary/_internals/builders/TypedIntArrayArbitraryBuilder.js");
function uint32Array(constraints = {}) {
    return TypedIntArrayArbitraryBuilder_1.typedIntArrayArbitraryArbitraryBuilder(constraints, 0, 0xffffffff, Uint32Array, integer_1.integer);
}
exports.uint32Array = uint32Array;


/***/ }),

/***/ "./node_modules/fast-check/lib/arbitrary/uint8Array.js":
/*!*************************************************************!*\
  !*** ./node_modules/fast-check/lib/arbitrary/uint8Array.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.uint8Array = void 0;
const integer_1 = __webpack_require__(/*! ./integer */ "./node_modules/fast-check/lib/arbitrary/integer.js");
const TypedIntArrayArbitraryBuilder_1 = __webpack_require__(/*! ./_internals/builders/TypedIntArrayArbitraryBuilder */ "./node_modules/fast-check/lib/arbitrary/_internals/builders/TypedIntArrayArbitraryBuilder.js");
function uint8Array(constraints = {}) {
    return TypedIntArrayArbitraryBuilder_1.typedIntArrayArbitraryArbitraryBuilder(constraints, 0, 255, Uint8Array, integer_1.integer);
}
exports.uint8Array = uint8Array;


/***/ }),

/***/ "./node_modules/fast-check/lib/arbitrary/uint8ClampedArray.js":
/*!********************************************************************!*\
  !*** ./node_modules/fast-check/lib/arbitrary/uint8ClampedArray.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.uint8ClampedArray = void 0;
const integer_1 = __webpack_require__(/*! ./integer */ "./node_modules/fast-check/lib/arbitrary/integer.js");
const TypedIntArrayArbitraryBuilder_1 = __webpack_require__(/*! ./_internals/builders/TypedIntArrayArbitraryBuilder */ "./node_modules/fast-check/lib/arbitrary/_internals/builders/TypedIntArrayArbitraryBuilder.js");
function uint8ClampedArray(constraints = {}) {
    return TypedIntArrayArbitraryBuilder_1.typedIntArrayArbitraryArbitraryBuilder(constraints, 0, 255, Uint8ClampedArray, integer_1.integer);
}
exports.uint8ClampedArray = uint8ClampedArray;


/***/ }),

/***/ "./node_modules/fast-check/lib/arbitrary/unicode.js":
/*!**********************************************************!*\
  !*** ./node_modules/fast-check/lib/arbitrary/unicode.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.unicode = void 0;
const CharacterArbitraryBuilder_1 = __webpack_require__(/*! ./_internals/builders/CharacterArbitraryBuilder */ "./node_modules/fast-check/lib/arbitrary/_internals/builders/CharacterArbitraryBuilder.js");
const IndexToPrintableIndex_1 = __webpack_require__(/*! ./_internals/mappers/IndexToPrintableIndex */ "./node_modules/fast-check/lib/arbitrary/_internals/mappers/IndexToPrintableIndex.js");
const gapSize = 0xdfff + 1 - 0xd800;
function unicodeMapper(v) {
    if (v < 0xd800)
        return IndexToPrintableIndex_1.indexToPrintableIndexMapper(v);
    return v + gapSize;
}
function unicodeUnmapper(v) {
    if (v < 0xd800)
        return IndexToPrintableIndex_1.indexToPrintableIndexUnmapper(v);
    if (v <= 0xdfff)
        return -1;
    return v - gapSize;
}
function unicode() {
    return CharacterArbitraryBuilder_1.buildCharacterArbitrary(0x0000, 0xffff - gapSize, unicodeMapper, unicodeUnmapper);
}
exports.unicode = unicode;


/***/ }),

/***/ "./node_modules/fast-check/lib/arbitrary/unicodeString.js":
/*!****************************************************************!*\
  !*** ./node_modules/fast-check/lib/arbitrary/unicodeString.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.unicodeString = void 0;
const Converters_1 = __webpack_require__(/*! ../check/arbitrary/definition/Converters */ "./node_modules/fast-check/lib/check/arbitrary/definition/Converters.js");
const array_1 = __webpack_require__(/*! ./array */ "./node_modules/fast-check/lib/arbitrary/array.js");
const unicode_1 = __webpack_require__(/*! ./unicode */ "./node_modules/fast-check/lib/arbitrary/unicode.js");
const StringConstraintsExtractor_1 = __webpack_require__(/*! ./_internals/helpers/StringConstraintsExtractor */ "./node_modules/fast-check/lib/arbitrary/_internals/helpers/StringConstraintsExtractor.js");
const CodePointsToString_1 = __webpack_require__(/*! ./_internals/mappers/CodePointsToString */ "./node_modules/fast-check/lib/arbitrary/_internals/mappers/CodePointsToString.js");
function unicodeString(...args) {
    const constraints = StringConstraintsExtractor_1.extractStringConstraints(args);
    return Converters_1.convertFromNext(Converters_1.convertToNext(array_1.array(unicode_1.unicode(), constraints)).map(CodePointsToString_1.codePointsToStringMapper, CodePointsToString_1.codePointsToStringUnmapper));
}
exports.unicodeString = unicodeString;


/***/ }),

/***/ "./node_modules/fast-check/lib/check/arbitrary/DoubleNextArbitrary.js":
/*!****************************************************************************!*\
  !*** ./node_modules/fast-check/lib/check/arbitrary/DoubleNextArbitrary.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.doubleNext = exports.indexToDouble = exports.doubleToIndex = exports.decomposeDouble = void 0;
const ArrayInt64_1 = __webpack_require__(/*! ./helpers/ArrayInt64 */ "./node_modules/fast-check/lib/check/arbitrary/helpers/ArrayInt64.js");
const ArrayInt64Arbitrary_1 = __webpack_require__(/*! ./helpers/ArrayInt64Arbitrary */ "./node_modules/fast-check/lib/check/arbitrary/helpers/ArrayInt64Arbitrary.js");
const INDEX_POSITIVE_INFINITY = { sign: 1, data: [2146435072, 0] };
const INDEX_NEGATIVE_INFINITY = { sign: -1, data: [2146435072, 1] };
function decomposeDouble(d) {
    const maxSignificand = 2 - Number.EPSILON;
    for (let exponent = -1022; exponent !== 1024; ++exponent) {
        const powExponent = 2 ** exponent;
        const maxForExponent = maxSignificand * powExponent;
        if (Math.abs(d) <= maxForExponent) {
            return { exponent, significand: d / powExponent };
        }
    }
    return { exponent: Number.NaN, significand: Number.NaN };
}
exports.decomposeDouble = decomposeDouble;
function positiveNumberToInt64(n) {
    return [~~(n / 0x100000000), n >>> 0];
}
function indexInDoubleFromDecomp(exponent, significand) {
    if (exponent === -1022) {
        const rescaledSignificand = significand * 2 ** 52;
        return positiveNumberToInt64(rescaledSignificand);
    }
    const rescaledSignificand = (significand - 1) * 2 ** 52;
    const exponentOnlyHigh = (exponent + 1023) * 2 ** 20;
    const index = positiveNumberToInt64(rescaledSignificand);
    index[0] += exponentOnlyHigh;
    return index;
}
function doubleToIndex(d) {
    if (d === Number.POSITIVE_INFINITY) {
        return ArrayInt64_1.clone64(INDEX_POSITIVE_INFINITY);
    }
    if (d === Number.NEGATIVE_INFINITY) {
        return ArrayInt64_1.clone64(INDEX_NEGATIVE_INFINITY);
    }
    const decomp = decomposeDouble(d);
    const exponent = decomp.exponent;
    const significand = decomp.significand;
    if (d > 0 || (d === 0 && 1 / d === Number.POSITIVE_INFINITY)) {
        return { sign: 1, data: indexInDoubleFromDecomp(exponent, significand) };
    }
    else {
        const indexOpposite = indexInDoubleFromDecomp(exponent, -significand);
        if (indexOpposite[1] === 0xffffffff) {
            indexOpposite[0] += 1;
            indexOpposite[1] = 0;
        }
        else {
            indexOpposite[1] += 1;
        }
        return { sign: -1, data: indexOpposite };
    }
}
exports.doubleToIndex = doubleToIndex;
function indexToDouble(index) {
    if (index.sign === -1) {
        const indexOpposite = { sign: 1, data: [index.data[0], index.data[1]] };
        if (indexOpposite.data[1] === 0) {
            indexOpposite.data[0] -= 1;
            indexOpposite.data[1] = 0xffffffff;
        }
        else {
            indexOpposite.data[1] -= 1;
        }
        return -indexToDouble(indexOpposite);
    }
    if (ArrayInt64_1.isEqual64(index, INDEX_POSITIVE_INFINITY)) {
        return Number.POSITIVE_INFINITY;
    }
    if (index.data[0] < 0x200000) {
        return (index.data[0] * 0x100000000 + index.data[1]) * 2 ** -1074;
    }
    const postIndexHigh = index.data[0] - 0x200000;
    const exponent = -1021 + (postIndexHigh >> 20);
    const significand = 1 + ((postIndexHigh & 0xfffff) * 2 ** 32 + index.data[1]) * Number.EPSILON;
    return significand * 2 ** exponent;
}
exports.indexToDouble = indexToDouble;
function safeDoubleToIndex(d, constraintsLabel) {
    if (Number.isNaN(d)) {
        throw new Error('fc.doubleNext constraints.' + constraintsLabel + ' must be a 32-bit float');
    }
    return doubleToIndex(d);
}
function doubleNext(constraints = {}) {
    const { noDefaultInfinity = false, noNaN = false, min = noDefaultInfinity ? -Number.MAX_VALUE : Number.NEGATIVE_INFINITY, max = noDefaultInfinity ? Number.MAX_VALUE : Number.POSITIVE_INFINITY, } = constraints;
    const minIndex = safeDoubleToIndex(min, 'min');
    const maxIndex = safeDoubleToIndex(max, 'max');
    if (ArrayInt64_1.isStrictlySmaller64(maxIndex, minIndex)) {
        throw new Error('fc.doubleNext constraints.min must be smaller or equal to constraints.max');
    }
    if (noNaN) {
        return ArrayInt64Arbitrary_1.arrayInt64(minIndex, maxIndex).map(indexToDouble);
    }
    const positiveMaxIdx = ArrayInt64_1.isStrictlyPositive64(maxIndex);
    const minIndexWithNaN = positiveMaxIdx ? minIndex : ArrayInt64_1.substract64(minIndex, ArrayInt64_1.Unit64);
    const maxIndexWithNaN = positiveMaxIdx ? ArrayInt64_1.add64(maxIndex, ArrayInt64_1.Unit64) : maxIndex;
    return ArrayInt64Arbitrary_1.arrayInt64(minIndexWithNaN, maxIndexWithNaN).map((index) => {
        if (ArrayInt64_1.isStrictlySmaller64(maxIndex, index) || ArrayInt64_1.isStrictlySmaller64(index, minIndex))
            return Number.NaN;
        else
            return indexToDouble(index);
    });
}
exports.doubleNext = doubleNext;


/***/ }),

/***/ "./node_modules/fast-check/lib/check/arbitrary/EmailArbitrary.js":
/*!***********************************************************************!*\
  !*** ./node_modules/fast-check/lib/check/arbitrary/EmailArbitrary.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.emailAddress = void 0;
const array_1 = __webpack_require__(/*! ../../arbitrary/array */ "./node_modules/fast-check/lib/arbitrary/array.js");
const SpecificCharacterRange_1 = __webpack_require__(/*! ./helpers/SpecificCharacterRange */ "./node_modules/fast-check/lib/check/arbitrary/helpers/SpecificCharacterRange.js");
const HostArbitrary_1 = __webpack_require__(/*! ./HostArbitrary */ "./node_modules/fast-check/lib/check/arbitrary/HostArbitrary.js");
const stringOf_1 = __webpack_require__(/*! ../../arbitrary/stringOf */ "./node_modules/fast-check/lib/arbitrary/stringOf.js");
const tuple_1 = __webpack_require__(/*! ../../arbitrary/tuple */ "./node_modules/fast-check/lib/arbitrary/tuple.js");
function emailAddress() {
    const others = ['!', '#', '$', '%', '&', "'", '*', '+', '-', '/', '=', '?', '^', '_', '`', '{', '|', '}', '~'];
    const atextArb = SpecificCharacterRange_1.buildLowerAlphaNumericArb(others);
    const localPartArb = array_1.array(stringOf_1.stringOf(atextArb, { minLength: 1, maxLength: 10 }), { minLength: 1, maxLength: 5 })
        .map((a) => a.join('.'))
        .filter((lp) => lp.length <= 64);
    return tuple_1.tuple(localPartArb, HostArbitrary_1.domain()).map(([lp, d]) => `${lp}@${d}`);
}
exports.emailAddress = emailAddress;


/***/ }),

/***/ "./node_modules/fast-check/lib/check/arbitrary/FloatNextArbitrary.js":
/*!***************************************************************************!*\
  !*** ./node_modules/fast-check/lib/check/arbitrary/FloatNextArbitrary.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.floatNext = exports.indexToFloat = exports.floatToIndex = exports.decomposeFloat = exports.EPSILON_32 = exports.MAX_VALUE_32 = exports.MIN_VALUE_32 = void 0;
const integer_1 = __webpack_require__(/*! ../../arbitrary/integer */ "./node_modules/fast-check/lib/arbitrary/integer.js");
exports.MIN_VALUE_32 = 2 ** -126 * 2 ** -23;
exports.MAX_VALUE_32 = 2 ** 127 * (1 + (2 ** 23 - 1) / 2 ** 23);
exports.EPSILON_32 = 2 ** -23;
const INDEX_POSITIVE_INFINITY = 2139095040;
const INDEX_NEGATIVE_INFINITY = -2139095041;
function decomposeFloat(f) {
    const maxSignificand = 1 + (2 ** 23 - 1) / 2 ** 23;
    for (let exponent = -126; exponent !== 128; ++exponent) {
        const powExponent = 2 ** exponent;
        const maxForExponent = maxSignificand * powExponent;
        if (Math.abs(f) <= maxForExponent) {
            return { exponent, significand: f / powExponent };
        }
    }
    return { exponent: Number.NaN, significand: Number.NaN };
}
exports.decomposeFloat = decomposeFloat;
function indexInFloatFromDecomp(exponent, significand) {
    if (exponent === -126) {
        return significand * 0x800000;
    }
    return (exponent + 127) * 0x800000 + (significand - 1) * 0x800000;
}
function floatToIndex(f) {
    if (f === Number.POSITIVE_INFINITY) {
        return INDEX_POSITIVE_INFINITY;
    }
    if (f === Number.NEGATIVE_INFINITY) {
        return INDEX_NEGATIVE_INFINITY;
    }
    const decomp = decomposeFloat(f);
    const exponent = decomp.exponent;
    const significand = decomp.significand;
    if (Number.isNaN(exponent) || Number.isNaN(significand) || !Number.isInteger(significand * 0x800000)) {
        return Number.NaN;
    }
    if (f > 0 || (f === 0 && 1 / f === Number.POSITIVE_INFINITY)) {
        return indexInFloatFromDecomp(exponent, significand);
    }
    else {
        return -indexInFloatFromDecomp(exponent, -significand) - 1;
    }
}
exports.floatToIndex = floatToIndex;
function indexToFloat(index) {
    if (index < 0) {
        return -indexToFloat(-index - 1);
    }
    if (index === INDEX_POSITIVE_INFINITY) {
        return Number.POSITIVE_INFINITY;
    }
    if (index < 0x1000000) {
        return index * 2 ** -149;
    }
    const postIndex = index - 0x1000000;
    const exponent = -125 + (postIndex >> 23);
    const significand = 1 + (postIndex & 0x7fffff) / 0x800000;
    return significand * 2 ** exponent;
}
exports.indexToFloat = indexToFloat;
function safeFloatToIndex(f, constraintsLabel) {
    const conversionTrick = 'you can convert any double to a 32-bit float by using `new Float32Array([myDouble])[0]`';
    const errorMessage = 'fc.floatNext constraints.' + constraintsLabel + ' must be a 32-bit float - ' + conversionTrick;
    if (Number.isNaN(f) || (Number.isFinite(f) && (f < -exports.MAX_VALUE_32 || f > exports.MAX_VALUE_32))) {
        throw new Error(errorMessage);
    }
    const index = floatToIndex(f);
    if (!Number.isInteger(index)) {
        throw new Error(errorMessage);
    }
    return index;
}
function floatNext(constraints = {}) {
    const { noDefaultInfinity = false, noNaN = false, min = noDefaultInfinity ? -exports.MAX_VALUE_32 : Number.NEGATIVE_INFINITY, max = noDefaultInfinity ? exports.MAX_VALUE_32 : Number.POSITIVE_INFINITY, } = constraints;
    const minIndex = safeFloatToIndex(min, 'min');
    const maxIndex = safeFloatToIndex(max, 'max');
    if (minIndex > maxIndex) {
        throw new Error('fc.floatNext constraints.min must be smaller or equal to constraints.max');
    }
    if (noNaN) {
        return integer_1.integer({ min: minIndex, max: maxIndex }).map(indexToFloat);
    }
    const minIndexWithNaN = maxIndex > 0 ? minIndex : minIndex - 1;
    const maxIndexWithNaN = maxIndex > 0 ? maxIndex + 1 : maxIndex;
    return integer_1.integer({ min: minIndexWithNaN, max: maxIndexWithNaN }).map((index) => {
        if (index > maxIndex || index < minIndex)
            return Number.NaN;
        else
            return indexToFloat(index);
    });
}
exports.floatNext = floatNext;


/***/ }),

/***/ "./node_modules/fast-check/lib/check/arbitrary/FloatingPointArbitrary.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/fast-check/lib/check/arbitrary/FloatingPointArbitrary.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.double = exports.float = void 0;
const DoubleNextArbitrary_1 = __webpack_require__(/*! ./DoubleNextArbitrary */ "./node_modules/fast-check/lib/check/arbitrary/DoubleNextArbitrary.js");
const FloatNextArbitrary_1 = __webpack_require__(/*! ./FloatNextArbitrary */ "./node_modules/fast-check/lib/check/arbitrary/FloatNextArbitrary.js");
const integer_1 = __webpack_require__(/*! ../../arbitrary/integer */ "./node_modules/fast-check/lib/arbitrary/integer.js");
const tuple_1 = __webpack_require__(/*! ../../arbitrary/tuple */ "./node_modules/fast-check/lib/arbitrary/tuple.js");
function next(n) {
    return integer_1.integer(0, (1 << n) - 1);
}
const floatInternal = () => {
    return next(24).map((v) => v / (1 << 24));
};
function float(...args) {
    if (typeof args[0] === 'object') {
        if (args[0].next) {
            return FloatNextArbitrary_1.floatNext(args[0]);
        }
        const min = args[0].min !== undefined ? args[0].min : 0;
        const max = args[0].max !== undefined ? args[0].max : 1;
        return (floatInternal()
            .map((v) => min + v * (max - min))
            .filter((g) => g !== max || g === min));
    }
    else {
        const a = args[0];
        const b = args[1];
        if (a === undefined)
            return floatInternal();
        if (b === undefined)
            return (floatInternal()
                .map((v) => v * a)
                .filter((g) => g !== a || g === 0));
        return (floatInternal()
            .map((v) => a + v * (b - a))
            .filter((g) => g !== b || g === a));
    }
}
exports.float = float;
const doubleFactor = Math.pow(2, 27);
const doubleDivisor = Math.pow(2, -53);
const doubleInternal = () => {
    return tuple_1.tuple(next(26), next(27)).map((v) => (v[0] * doubleFactor + v[1]) * doubleDivisor);
};
function double(...args) {
    if (typeof args[0] === 'object') {
        if (args[0].next) {
            return DoubleNextArbitrary_1.doubleNext(args[0]);
        }
        const min = args[0].min !== undefined ? args[0].min : 0;
        const max = args[0].max !== undefined ? args[0].max : 1;
        return (doubleInternal()
            .map((v) => min + v * (max - min))
            .filter((g) => g !== max || g === min));
    }
    else {
        const a = args[0];
        const b = args[1];
        if (a === undefined)
            return doubleInternal();
        if (b === undefined)
            return (doubleInternal()
                .map((v) => v * a)
                .filter((g) => g !== a || g === 0));
        return (doubleInternal()
            .map((v) => a + v * (b - a))
            .filter((g) => g !== b || g === a));
    }
}
exports.double = double;


/***/ }),

/***/ "./node_modules/fast-check/lib/check/arbitrary/HostArbitrary.js":
/*!**********************************************************************!*\
  !*** ./node_modules/fast-check/lib/check/arbitrary/HostArbitrary.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.hostUserInfo = exports.domain = exports.filterInvalidSubdomainLabel = void 0;
const array_1 = __webpack_require__(/*! ../../arbitrary/array */ "./node_modules/fast-check/lib/arbitrary/array.js");
const SpecificCharacterRange_1 = __webpack_require__(/*! ./helpers/SpecificCharacterRange */ "./node_modules/fast-check/lib/check/arbitrary/helpers/SpecificCharacterRange.js");
const option_1 = __webpack_require__(/*! ../../arbitrary/option */ "./node_modules/fast-check/lib/arbitrary/option.js");
const stringOf_1 = __webpack_require__(/*! ../../arbitrary/stringOf */ "./node_modules/fast-check/lib/arbitrary/stringOf.js");
const tuple_1 = __webpack_require__(/*! ../../arbitrary/tuple */ "./node_modules/fast-check/lib/arbitrary/tuple.js");
function filterInvalidSubdomainLabel(subdomainLabel) {
    if (subdomainLabel.length > 63) {
        return false;
    }
    return (subdomainLabel.length < 4 ||
        subdomainLabel[0] !== 'x' ||
        subdomainLabel[1] !== 'n' ||
        subdomainLabel[2] !== '-' ||
        subdomainLabel[3] !== '-');
}
exports.filterInvalidSubdomainLabel = filterInvalidSubdomainLabel;
function subdomainLabel() {
    const alphaNumericArb = SpecificCharacterRange_1.buildLowerAlphaNumericArb([]);
    const alphaNumericHyphenArb = SpecificCharacterRange_1.buildLowerAlphaNumericArb(['-']);
    return tuple_1.tuple(alphaNumericArb, option_1.option(tuple_1.tuple(stringOf_1.stringOf(alphaNumericHyphenArb, { maxLength: 61 }), alphaNumericArb)))
        .map(([f, d]) => (d === null ? f : `${f}${d[0]}${d[1]}`))
        .filter(filterInvalidSubdomainLabel);
}
function domain() {
    const alphaNumericArb = SpecificCharacterRange_1.buildLowerAlphaArb([]);
    const publicSuffixArb = stringOf_1.stringOf(alphaNumericArb, { minLength: 2, maxLength: 10 });
    return (tuple_1.tuple(array_1.array(subdomainLabel(), { minLength: 1, maxLength: 5 }), publicSuffixArb)
        .map(([mid, ext]) => `${mid.join('.')}.${ext}`)
        .filter((d) => d.length <= 255));
}
exports.domain = domain;
function hostUserInfo() {
    const others = ['-', '.', '_', '~', '!', '$', '&', "'", '(', ')', '*', '+', ',', ';', '=', ':'];
    return stringOf_1.stringOf(SpecificCharacterRange_1.buildAlphaNumericPercentArb(others));
}
exports.hostUserInfo = hostUserInfo;


/***/ }),

/***/ "./node_modules/fast-check/lib/check/arbitrary/ObjectArbitrary.js":
/*!************************************************************************!*\
  !*** ./node_modules/fast-check/lib/check/arbitrary/ObjectArbitrary.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.unicodeJson = exports.json = exports.unicodeJsonObject = exports.jsonObject = exports.object = exports.anything = exports.boxArbitrary = void 0;
const stringify_1 = __webpack_require__(/*! ../../utils/stringify */ "./node_modules/fast-check/lib/utils/stringify.js");
const array_1 = __webpack_require__(/*! ../../arbitrary/array */ "./node_modules/fast-check/lib/arbitrary/array.js");
const boolean_1 = __webpack_require__(/*! ../../arbitrary/boolean */ "./node_modules/fast-check/lib/arbitrary/boolean.js");
const constant_1 = __webpack_require__(/*! ../../arbitrary/constant */ "./node_modules/fast-check/lib/arbitrary/constant.js");
const dictionary_1 = __webpack_require__(/*! ../../arbitrary/dictionary */ "./node_modules/fast-check/lib/arbitrary/dictionary.js");
const FloatingPointArbitrary_1 = __webpack_require__(/*! ./FloatingPointArbitrary */ "./node_modules/fast-check/lib/check/arbitrary/FloatingPointArbitrary.js");
const frequency_1 = __webpack_require__(/*! ../../arbitrary/frequency */ "./node_modules/fast-check/lib/arbitrary/frequency.js");
const maxSafeInteger_1 = __webpack_require__(/*! ../../arbitrary/maxSafeInteger */ "./node_modules/fast-check/lib/arbitrary/maxSafeInteger.js");
const memo_1 = __webpack_require__(/*! ../../arbitrary/memo */ "./node_modules/fast-check/lib/arbitrary/memo.js");
const oneof_1 = __webpack_require__(/*! ../../arbitrary/oneof */ "./node_modules/fast-check/lib/arbitrary/oneof.js");
const set_1 = __webpack_require__(/*! ../../arbitrary/set */ "./node_modules/fast-check/lib/arbitrary/set.js");
const string_1 = __webpack_require__(/*! ../../arbitrary/string */ "./node_modules/fast-check/lib/arbitrary/string.js");
const unicodeString_1 = __webpack_require__(/*! ../../arbitrary/unicodeString */ "./node_modules/fast-check/lib/arbitrary/unicodeString.js");
const tuple_1 = __webpack_require__(/*! ../../arbitrary/tuple */ "./node_modules/fast-check/lib/arbitrary/tuple.js");
const bigInt_1 = __webpack_require__(/*! ../../arbitrary/bigInt */ "./node_modules/fast-check/lib/arbitrary/bigInt.js");
const date_1 = __webpack_require__(/*! ../../arbitrary/date */ "./node_modules/fast-check/lib/arbitrary/date.js");
const float32Array_1 = __webpack_require__(/*! ../../arbitrary/float32Array */ "./node_modules/fast-check/lib/arbitrary/float32Array.js");
const float64Array_1 = __webpack_require__(/*! ../../arbitrary/float64Array */ "./node_modules/fast-check/lib/arbitrary/float64Array.js");
const int16Array_1 = __webpack_require__(/*! ../../arbitrary/int16Array */ "./node_modules/fast-check/lib/arbitrary/int16Array.js");
const int32Array_1 = __webpack_require__(/*! ../../arbitrary/int32Array */ "./node_modules/fast-check/lib/arbitrary/int32Array.js");
const int8Array_1 = __webpack_require__(/*! ../../arbitrary/int8Array */ "./node_modules/fast-check/lib/arbitrary/int8Array.js");
const uint16Array_1 = __webpack_require__(/*! ../../arbitrary/uint16Array */ "./node_modules/fast-check/lib/arbitrary/uint16Array.js");
const uint32Array_1 = __webpack_require__(/*! ../../arbitrary/uint32Array */ "./node_modules/fast-check/lib/arbitrary/uint32Array.js");
const uint8Array_1 = __webpack_require__(/*! ../../arbitrary/uint8Array */ "./node_modules/fast-check/lib/arbitrary/uint8Array.js");
const uint8ClampedArray_1 = __webpack_require__(/*! ../../arbitrary/uint8ClampedArray */ "./node_modules/fast-check/lib/arbitrary/uint8ClampedArray.js");
const SparseArrayArbitrary_1 = __webpack_require__(/*! ./SparseArrayArbitrary */ "./node_modules/fast-check/lib/check/arbitrary/SparseArrayArbitrary.js");
const KeyValuePairsToObject_1 = __webpack_require__(/*! ../../arbitrary/_internals/mappers/KeyValuePairsToObject */ "./node_modules/fast-check/lib/arbitrary/_internals/mappers/KeyValuePairsToObject.js");
function boxArbitrary(arb) {
    return arb.map((v) => {
        switch (typeof v) {
            case 'boolean':
                return new Boolean(v);
            case 'number':
                return new Number(v);
            case 'string':
                return new String(v);
            default:
                return v;
        }
    });
}
exports.boxArbitrary = boxArbitrary;
class QualifiedObjectConstraints {
    constructor(key, values, maxDepth, maxKeys, withSet, withMap, withObjectString, withNullPrototype, withBigInt, withDate, withTypedArray, withSparseArray) {
        this.key = key;
        this.values = values;
        this.maxDepth = maxDepth;
        this.maxKeys = maxKeys;
        this.withSet = withSet;
        this.withMap = withMap;
        this.withObjectString = withObjectString;
        this.withNullPrototype = withNullPrototype;
        this.withBigInt = withBigInt;
        this.withDate = withDate;
        this.withTypedArray = withTypedArray;
        this.withSparseArray = withSparseArray;
    }
    static defaultValues() {
        return [
            boolean_1.boolean(),
            maxSafeInteger_1.maxSafeInteger(),
            FloatingPointArbitrary_1.double({ next: true }),
            string_1.string(),
            oneof_1.oneof(string_1.string(), constant_1.constant(null), constant_1.constant(undefined)),
        ];
    }
    static boxArbitraries(arbs) {
        return arbs.map((arb) => boxArbitrary(arb));
    }
    static boxArbitrariesIfNeeded(arbs, boxEnabled) {
        return boxEnabled ? QualifiedObjectConstraints.boxArbitraries(arbs).concat(arbs) : arbs;
    }
    static from(settings = {}) {
        function orDefault(optionalValue, defaultValue) {
            return optionalValue !== undefined ? optionalValue : defaultValue;
        }
        return new QualifiedObjectConstraints(orDefault(settings.key, string_1.string()), QualifiedObjectConstraints.boxArbitrariesIfNeeded(orDefault(settings.values, QualifiedObjectConstraints.defaultValues()), orDefault(settings.withBoxedValues, false)), orDefault(settings.maxDepth, 2), orDefault(settings.maxKeys, 5), orDefault(settings.withSet, false), orDefault(settings.withMap, false), orDefault(settings.withObjectString, false), orDefault(settings.withNullPrototype, false), orDefault(settings.withBigInt, false), orDefault(settings.withDate, false), orDefault(settings.withTypedArray, false), orDefault(settings.withSparseArray, false));
    }
}
const anythingInternal = (constraints) => {
    const arbKeys = constraints.withObjectString
        ? memo_1.memo((n) => frequency_1.frequency({ arbitrary: constraints.key, weight: 10 }, { arbitrary: anythingArb(n).map((o) => stringify_1.stringify(o)), weight: 1 }))
        : memo_1.memo(() => constraints.key);
    const arbitrariesForBase = constraints.values;
    const maxDepth = constraints.maxDepth;
    const maxKeys = constraints.maxKeys;
    const entriesOf = (keyArb, valueArb) => set_1.set(tuple_1.tuple(keyArb, valueArb), { maxLength: maxKeys, compare: (t1, t2) => t1[0] === t2[0] });
    const mapOf = (ka, va) => entriesOf(ka, va).map((v) => new Map(v));
    const dictOf = (ka, va) => entriesOf(ka, va).map((v) => KeyValuePairsToObject_1.keyValuePairsToObjectMapper(v));
    const baseArb = oneof_1.oneof(...arbitrariesForBase);
    const arrayBaseArb = oneof_1.oneof(...arbitrariesForBase.map((arb) => array_1.array(arb, { maxLength: maxKeys })));
    const objectBaseArb = (n) => oneof_1.oneof(...arbitrariesForBase.map((arb) => dictOf(arbKeys(n), arb)));
    const setBaseArb = () => oneof_1.oneof(...arbitrariesForBase.map((arb) => set_1.set(arb, { maxLength: maxKeys }).map((v) => new Set(v))));
    const mapBaseArb = (n) => oneof_1.oneof(...arbitrariesForBase.map((arb) => mapOf(arbKeys(n), arb)));
    const arrayArb = memo_1.memo((n) => oneof_1.oneof(arrayBaseArb, array_1.array(anythingArb(n), { maxLength: maxKeys })));
    const setArb = memo_1.memo((n) => oneof_1.oneof(setBaseArb(), set_1.set(anythingArb(n), { maxLength: maxKeys }).map((v) => new Set(v))));
    const mapArb = memo_1.memo((n) => oneof_1.oneof(mapBaseArb(n), oneof_1.oneof(mapOf(arbKeys(n), anythingArb(n)), mapOf(anythingArb(n), anythingArb(n)))));
    const objectArb = memo_1.memo((n) => oneof_1.oneof(objectBaseArb(n), dictOf(arbKeys(n), anythingArb(n))));
    const anythingArb = memo_1.memo((n) => {
        if (n <= 0)
            return oneof_1.oneof(baseArb);
        return oneof_1.oneof(baseArb, arrayArb(), objectArb(), ...(constraints.withMap ? [mapArb()] : []), ...(constraints.withSet ? [setArb()] : []), ...(constraints.withObjectString ? [anythingArb().map((o) => stringify_1.stringify(o))] : []), ...(constraints.withNullPrototype ? [objectArb().map((o) => Object.assign(Object.create(null), o))] : []), ...(constraints.withBigInt ? [bigInt_1.bigInt()] : []), ...(constraints.withDate ? [date_1.date()] : []), ...(constraints.withTypedArray
            ? [
                oneof_1.oneof(int8Array_1.int8Array(), uint8Array_1.uint8Array(), uint8ClampedArray_1.uint8ClampedArray(), int16Array_1.int16Array(), uint16Array_1.uint16Array(), int32Array_1.int32Array(), uint32Array_1.uint32Array(), float32Array_1.float32Array(), float64Array_1.float64Array()),
            ]
            : []), ...(constraints.withSparseArray ? [SparseArrayArbitrary_1.sparseArray(anythingArb())] : []));
    });
    return anythingArb(maxDepth);
};
const objectInternal = (constraints) => {
    return dictionary_1.dictionary(constraints.key, anythingInternal(constraints));
};
function anything(constraints) {
    return anythingInternal(QualifiedObjectConstraints.from(constraints));
}
exports.anything = anything;
function object(constraints) {
    return objectInternal(QualifiedObjectConstraints.from(constraints));
}
exports.object = object;
function jsonSettings(stringArbitrary, constraints) {
    const key = stringArbitrary;
    const values = [
        boolean_1.boolean(),
        maxSafeInteger_1.maxSafeInteger(),
        FloatingPointArbitrary_1.double({ next: true, noDefaultInfinity: true, noNaN: true }),
        stringArbitrary,
        constant_1.constant(null),
    ];
    return constraints != null
        ? typeof constraints === 'number'
            ? { key, values, maxDepth: constraints }
            : { key, values, maxDepth: constraints.maxDepth }
        : { key, values };
}
function jsonObject(constraints) {
    return anything(jsonSettings(string_1.string(), constraints));
}
exports.jsonObject = jsonObject;
function unicodeJsonObject(constraints) {
    return anything(jsonSettings(unicodeString_1.unicodeString(), constraints));
}
exports.unicodeJsonObject = unicodeJsonObject;
function json(constraints) {
    const arb = constraints != null ? jsonObject(constraints) : jsonObject();
    return arb.map(JSON.stringify);
}
exports.json = json;
function unicodeJson(constraints) {
    const arb = constraints != null ? unicodeJsonObject(constraints) : unicodeJsonObject();
    return arb.map(JSON.stringify);
}
exports.unicodeJson = unicodeJson;


/***/ }),

/***/ "./node_modules/fast-check/lib/check/arbitrary/SparseArrayArbitrary.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/fast-check/lib/check/arbitrary/SparseArrayArbitrary.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.sparseArray = void 0;
const nat_1 = __webpack_require__(/*! ../../arbitrary/nat */ "./node_modules/fast-check/lib/arbitrary/nat.js");
const set_1 = __webpack_require__(/*! ../../arbitrary/set */ "./node_modules/fast-check/lib/arbitrary/set.js");
const tuple_1 = __webpack_require__(/*! ../../arbitrary/tuple */ "./node_modules/fast-check/lib/arbitrary/tuple.js");
const MaxLengthFromMinLength_1 = __webpack_require__(/*! ../../arbitrary/_internals/helpers/MaxLengthFromMinLength */ "./node_modules/fast-check/lib/arbitrary/_internals/helpers/MaxLengthFromMinLength.js");
function extractMaxIndex(indexesAndValues) {
    let maxIndex = -1;
    for (let index = 0; index !== indexesAndValues.length; ++index) {
        maxIndex = Math.max(maxIndex, indexesAndValues[index][0]);
    }
    return maxIndex;
}
function arrayFromItems(length, indexesAndValues) {
    const array = Array(length);
    for (let index = 0; index !== indexesAndValues.length; ++index) {
        const it = indexesAndValues[index];
        if (it[0] < length)
            array[it[0]] = it[1];
    }
    return array;
}
function sparseArray(arb, constraints = {}) {
    const { minNumElements = 0, maxNumElements = MaxLengthFromMinLength_1.maxLengthFromMinLength(minNumElements), maxLength = Math.min(MaxLengthFromMinLength_1.maxLengthFromMinLength(maxNumElements), 4294967295), noTrailingHole, } = constraints;
    if (minNumElements > maxLength) {
        throw new Error(`The minimal number of non-hole elements cannot be higher than the maximal length of the array`);
    }
    if (minNumElements > maxNumElements) {
        throw new Error(`The minimal number of non-hole elements cannot be higher than the maximal number of non-holes`);
    }
    const resultedMaxNumElements = Math.min(maxNumElements, maxLength);
    if (noTrailingHole) {
        const maxIndexAuthorized = Math.max(maxLength - 1, 0);
        return set_1.set(tuple_1.tuple(nat_1.nat(maxIndexAuthorized), arb), {
            minLength: minNumElements,
            maxLength: resultedMaxNumElements,
            compare: (itemA, itemB) => itemA[0] === itemB[0],
        }).map((items) => {
            const lastIndex = extractMaxIndex(items);
            return arrayFromItems(lastIndex + 1, items);
        });
    }
    return set_1.set(tuple_1.tuple(nat_1.nat(maxLength), arb), {
        minLength: minNumElements + 1,
        maxLength: resultedMaxNumElements + 1,
        compare: (itemA, itemB) => itemA[0] === itemB[0],
    }).map((items) => {
        const length = extractMaxIndex(items);
        return arrayFromItems(length, items);
    });
}
exports.sparseArray = sparseArray;


/***/ }),

/***/ "./node_modules/fast-check/lib/check/arbitrary/SubarrayArbitrary.js":
/*!**************************************************************************!*\
  !*** ./node_modules/fast-check/lib/check/arbitrary/SubarrayArbitrary.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.shuffledSubarray = exports.subarray = void 0;
const Stream_1 = __webpack_require__(/*! ../../stream/Stream */ "./node_modules/fast-check/lib/stream/Stream.js");
const Arbitrary_1 = __webpack_require__(/*! ./definition/Arbitrary */ "./node_modules/fast-check/lib/check/arbitrary/definition/Arbitrary.js");
const BiasedArbitraryWrapper_1 = __webpack_require__(/*! ./definition/BiasedArbitraryWrapper */ "./node_modules/fast-check/lib/check/arbitrary/definition/BiasedArbitraryWrapper.js");
const Shrinkable_1 = __webpack_require__(/*! ./definition/Shrinkable */ "./node_modules/fast-check/lib/check/arbitrary/definition/Shrinkable.js");
const integer_1 = __webpack_require__(/*! ../../arbitrary/integer */ "./node_modules/fast-check/lib/arbitrary/integer.js");
const LazyIterableIterator_1 = __webpack_require__(/*! ../../stream/LazyIterableIterator */ "./node_modules/fast-check/lib/stream/LazyIterableIterator.js");
class SubarrayArbitrary extends Arbitrary_1.Arbitrary {
    constructor(originalArray, isOrdered, minLength, maxLength) {
        super();
        this.originalArray = originalArray;
        this.isOrdered = isOrdered;
        this.minLength = minLength;
        this.maxLength = maxLength;
        if (minLength < 0 || minLength > originalArray.length)
            throw new Error('fc.*{s|S}ubarrayOf expects the minimal length to be between 0 and the size of the original array');
        if (maxLength < 0 || maxLength > originalArray.length)
            throw new Error('fc.*{s|S}ubarrayOf expects the maximal length to be between 0 and the size of the original array');
        if (minLength > maxLength)
            throw new Error('fc.*{s|S}ubarrayOf expects the minimal length to be inferior or equal to the maximal length');
        this.lengthArb = integer_1.integer(minLength, maxLength);
    }
    wrapper(items, itemsLengthContext) {
        return new Shrinkable_1.Shrinkable(items, () => this.shrinkImpl(items, itemsLengthContext).map((contextualValue) => this.wrapper(contextualValue[0], contextualValue[1])));
    }
    generate(mrng) {
        const remainingElements = this.originalArray.map((_v, idx) => idx);
        const size = this.lengthArb.generate(mrng).value;
        const ids = [];
        for (let idx = 0; idx !== size; ++idx) {
            const selectedIdIndex = mrng.nextInt(0, remainingElements.length - 1);
            ids.push(remainingElements[selectedIdIndex]);
            remainingElements.splice(selectedIdIndex, 1);
        }
        if (this.isOrdered)
            ids.sort((a, b) => a - b);
        return this.wrapper(ids.map((i) => this.originalArray[i]), undefined);
    }
    shrinkImpl(items, itemsLengthContext) {
        if (items.length === 0) {
            return Stream_1.Stream.nil();
        }
        return this.lengthArb
            .contextualShrink(items.length, itemsLengthContext)
            .map((contextualValue) => {
            return [
                items.slice(items.length - contextualValue[0]),
                contextualValue[1],
            ];
        })
            .join(items.length > this.minLength
            ? LazyIterableIterator_1.makeLazy(() => this.shrinkImpl(items.slice(1), undefined)
                .filter((contextualValue) => this.minLength <= contextualValue[0].length + 1)
                .map((contextualValue) => [[items[0]].concat(contextualValue[0]), undefined]))
            : Stream_1.Stream.nil());
    }
    withBias(freq) {
        return this.minLength !== this.maxLength
            ? BiasedArbitraryWrapper_1.biasWrapper(freq, this, (originalArbitrary) => {
                return new SubarrayArbitrary(originalArbitrary.originalArray, originalArbitrary.isOrdered, originalArbitrary.minLength, originalArbitrary.minLength +
                    Math.floor(Math.log(originalArbitrary.maxLength - originalArbitrary.minLength) / Math.log(2)));
            })
            : this;
    }
}
function subarray(originalArray, ...args) {
    if (typeof args[0] === 'number' && typeof args[1] === 'number') {
        return new SubarrayArbitrary(originalArray, true, args[0], args[1]);
    }
    const ct = args[0];
    const minLength = ct !== undefined && ct.minLength !== undefined ? ct.minLength : 0;
    const maxLength = ct !== undefined && ct.maxLength !== undefined ? ct.maxLength : originalArray.length;
    return new SubarrayArbitrary(originalArray, true, minLength, maxLength);
}
exports.subarray = subarray;
function shuffledSubarray(originalArray, ...args) {
    if (typeof args[0] === 'number' && typeof args[1] === 'number') {
        return new SubarrayArbitrary(originalArray, false, args[0], args[1]);
    }
    const ct = args[0];
    const minLength = ct !== undefined && ct.minLength !== undefined ? ct.minLength : 0;
    const maxLength = ct !== undefined && ct.maxLength !== undefined ? ct.maxLength : originalArray.length;
    return new SubarrayArbitrary(originalArray, false, minLength, maxLength);
}
exports.shuffledSubarray = shuffledSubarray;


/***/ }),

/***/ "./node_modules/fast-check/lib/check/arbitrary/UuidArbitrary.js":
/*!**********************************************************************!*\
  !*** ./node_modules/fast-check/lib/check/arbitrary/UuidArbitrary.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.uuidV = exports.uuid = void 0;
const integer_1 = __webpack_require__(/*! ../../arbitrary/integer */ "./node_modules/fast-check/lib/arbitrary/integer.js");
const nat_1 = __webpack_require__(/*! ../../arbitrary/nat */ "./node_modules/fast-check/lib/arbitrary/nat.js");
const tuple_1 = __webpack_require__(/*! ../../arbitrary/tuple */ "./node_modules/fast-check/lib/arbitrary/tuple.js");
const padEight = (arb) => arb.map((n) => n.toString(16).padStart(8, '0'));
function uuid() {
    const padded = padEight(nat_1.nat(0xffffffff));
    const secondPadded = padEight(integer_1.integer(0x10000000, 0x5fffffff));
    const thirdPadded = padEight(integer_1.integer(0x80000000, 0xbfffffff));
    return tuple_1.tuple(padded, secondPadded, thirdPadded, padded).map((t) => {
        return `${t[0]}-${t[1].substring(4)}-${t[1].substring(0, 4)}-${t[2].substring(0, 4)}-${t[2].substring(4)}${t[3]}`;
    });
}
exports.uuid = uuid;
function uuidV(versionNumber) {
    const padded = padEight(nat_1.nat(0xffffffff));
    const secondPadded = padEight(nat_1.nat(0x0fffffff));
    const thirdPadded = padEight(integer_1.integer(0x80000000, 0xbfffffff));
    return tuple_1.tuple(padded, secondPadded, thirdPadded, padded).map((t) => {
        return `${t[0]}-${t[1].substring(4)}-${versionNumber}${t[1].substring(1, 4)}-${t[2].substring(0, 4)}-${t[2].substring(4)}${t[3]}`;
    });
}
exports.uuidV = uuidV;


/***/ }),

/***/ "./node_modules/fast-check/lib/check/arbitrary/WebArbitrary.js":
/*!*********************************************************************!*\
  !*** ./node_modules/fast-check/lib/check/arbitrary/WebArbitrary.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.webUrl = exports.webFragments = exports.webQueryParameters = exports.webSegment = exports.webAuthority = void 0;
const array_1 = __webpack_require__(/*! ../../arbitrary/array */ "./node_modules/fast-check/lib/arbitrary/array.js");
const constantFrom_1 = __webpack_require__(/*! ../../arbitrary/constantFrom */ "./node_modules/fast-check/lib/arbitrary/constantFrom.js");
const constant_1 = __webpack_require__(/*! ../../arbitrary/constant */ "./node_modules/fast-check/lib/arbitrary/constant.js");
const SpecificCharacterRange_1 = __webpack_require__(/*! ./helpers/SpecificCharacterRange */ "./node_modules/fast-check/lib/check/arbitrary/helpers/SpecificCharacterRange.js");
const HostArbitrary_1 = __webpack_require__(/*! ./HostArbitrary */ "./node_modules/fast-check/lib/check/arbitrary/HostArbitrary.js");
const nat_1 = __webpack_require__(/*! ../../arbitrary/nat */ "./node_modules/fast-check/lib/arbitrary/nat.js");
const ipV4_1 = __webpack_require__(/*! ../../arbitrary/ipV4 */ "./node_modules/fast-check/lib/arbitrary/ipV4.js");
const ipV4Extended_1 = __webpack_require__(/*! ../../arbitrary/ipV4Extended */ "./node_modules/fast-check/lib/arbitrary/ipV4Extended.js");
const ipV6_1 = __webpack_require__(/*! ../../arbitrary/ipV6 */ "./node_modules/fast-check/lib/arbitrary/ipV6.js");
const oneof_1 = __webpack_require__(/*! ../../arbitrary/oneof */ "./node_modules/fast-check/lib/arbitrary/oneof.js");
const option_1 = __webpack_require__(/*! ../../arbitrary/option */ "./node_modules/fast-check/lib/arbitrary/option.js");
const stringOf_1 = __webpack_require__(/*! ../../arbitrary/stringOf */ "./node_modules/fast-check/lib/arbitrary/stringOf.js");
const tuple_1 = __webpack_require__(/*! ../../arbitrary/tuple */ "./node_modules/fast-check/lib/arbitrary/tuple.js");
function webAuthority(constraints) {
    const c = constraints || {};
    const hostnameArbs = [HostArbitrary_1.domain()]
        .concat(c.withIPv4 === true ? [ipV4_1.ipV4()] : [])
        .concat(c.withIPv6 === true ? [ipV6_1.ipV6().map((ip) => `[${ip}]`)] : [])
        .concat(c.withIPv4Extended === true ? [ipV4Extended_1.ipV4Extended()] : []);
    return tuple_1.tuple(c.withUserInfo === true ? option_1.option(HostArbitrary_1.hostUserInfo()) : constant_1.constant(null), oneof_1.oneof(...hostnameArbs), c.withPort === true ? option_1.option(nat_1.nat(65535)) : constant_1.constant(null)).map(([u, h, p]) => (u === null ? '' : `${u}@`) + h + (p === null ? '' : `:${p}`));
}
exports.webAuthority = webAuthority;
function webSegment() {
    const others = ['-', '.', '_', '~', '!', '$', '&', "'", '(', ')', '*', '+', ',', ';', '=', ':', '@'];
    return stringOf_1.stringOf(SpecificCharacterRange_1.buildAlphaNumericPercentArb(others));
}
exports.webSegment = webSegment;
function uriQueryOrFragment() {
    const others = ['-', '.', '_', '~', '!', '$', '&', "'", '(', ')', '*', '+', ',', ';', '=', ':', '@', '/', '?'];
    return stringOf_1.stringOf(SpecificCharacterRange_1.buildAlphaNumericPercentArb(others));
}
function webQueryParameters() {
    return uriQueryOrFragment();
}
exports.webQueryParameters = webQueryParameters;
function webFragments() {
    return uriQueryOrFragment();
}
exports.webFragments = webFragments;
function webUrl(constraints) {
    const c = constraints || {};
    const validSchemes = c.validSchemes || ['http', 'https'];
    const schemeArb = constantFrom_1.constantFrom(...validSchemes);
    const authorityArb = webAuthority(c.authoritySettings);
    const pathArb = array_1.array(webSegment()).map((p) => p.map((v) => `/${v}`).join(''));
    return tuple_1.tuple(schemeArb, authorityArb, pathArb, c.withQueryParameters === true ? option_1.option(webQueryParameters()) : constant_1.constant(null), c.withFragments === true ? option_1.option(webFragments()) : constant_1.constant(null)).map(([s, a, p, q, f]) => `${s}://${a}${p}${q === null ? '' : `?${q}`}${f === null ? '' : `#${f}`}`);
}
exports.webUrl = webUrl;


/***/ }),

/***/ "./node_modules/fast-check/lib/check/arbitrary/definition/Arbitrary.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/fast-check/lib/check/arbitrary/definition/Arbitrary.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.assertIsArbitrary = exports.Arbitrary = void 0;
const Shrinkable_1 = __webpack_require__(/*! ./Shrinkable */ "./node_modules/fast-check/lib/check/arbitrary/definition/Shrinkable.js");
class Arbitrary {
    filter(refinement) {
        return new FilterArbitrary(this, refinement);
    }
    map(mapper) {
        return new MapArbitrary(this, mapper);
    }
    chain(fmapper) {
        return new ChainArbitrary(this, fmapper);
    }
    noShrink() {
        return new NoShrinkArbitrary(this);
    }
    withBias(_freq) {
        return this;
    }
    noBias() {
        return new NoBiasArbitrary(this);
    }
}
exports.Arbitrary = Arbitrary;
class ChainArbitrary extends Arbitrary {
    constructor(arb, fmapper) {
        super();
        this.arb = arb;
        this.fmapper = fmapper;
    }
    generate(mrng) {
        const clonedMrng = mrng.clone();
        const src = this.arb.generate(mrng);
        const dst = this.fmapper(src.value).generate(mrng);
        return ChainArbitrary.shrinkChain(clonedMrng, src, dst, this.fmapper);
    }
    withBias(freq) {
        return this.arb.withBias(freq).chain((t) => this.fmapper(t).withBias(freq));
    }
    static shrinkChain(mrng, src, dst, fmapper) {
        return new Shrinkable_1.Shrinkable(dst.value, () => src
            .shrink()
            .map((v) => ChainArbitrary.shrinkChain(mrng.clone(), v, fmapper(v.value).generate(mrng.clone()), fmapper))
            .join(dst.shrink()));
    }
}
class MapArbitrary extends Arbitrary {
    constructor(arb, mapper) {
        super();
        this.arb = arb;
        this.mapper = mapper;
    }
    generate(mrng) {
        return this.arb.generate(mrng).map(this.mapper);
    }
    withBias(freq) {
        return this.arb.withBias(freq).map(this.mapper);
    }
}
class FilterArbitrary extends Arbitrary {
    constructor(arb, refinement) {
        super();
        this.arb = arb;
        this.refinement = refinement;
    }
    generate(mrng) {
        let g = this.arb.generate(mrng);
        while (!this.refinementOnShrinkable(g)) {
            g = this.arb.generate(mrng);
        }
        return g.filter(this.refinement);
    }
    withBias(freq) {
        return this.arb.withBias(freq).filter(this.refinement);
    }
    refinementOnShrinkable(s) {
        return this.refinement(s.value);
    }
}
class NoShrinkArbitrary extends Arbitrary {
    constructor(arb) {
        super();
        this.arb = arb;
    }
    generate(mrng) {
        return new Shrinkable_1.Shrinkable(this.arb.generate(mrng).value);
    }
    withBias(freq) {
        return this.arb.withBias(freq).noShrink();
    }
}
class NoBiasArbitrary extends Arbitrary {
    constructor(arb) {
        super();
        this.arb = arb;
    }
    generate(mrng) {
        return this.arb.generate(mrng);
    }
}
function assertIsArbitrary(instance) {
    if (typeof instance !== 'object' || instance === null || !('generate' in instance)) {
        throw new Error('Unexpected value received: not an instance of Arbitrary');
    }
}
exports.assertIsArbitrary = assertIsArbitrary;


/***/ }),

/***/ "./node_modules/fast-check/lib/check/arbitrary/definition/ArbitraryWithContextualShrink.js":
/*!*************************************************************************************************!*\
  !*** ./node_modules/fast-check/lib/check/arbitrary/definition/ArbitraryWithContextualShrink.js ***!
  \*************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ArbitraryWithContextualShrink = void 0;
const Arbitrary_1 = __webpack_require__(/*! ./Arbitrary */ "./node_modules/fast-check/lib/check/arbitrary/definition/Arbitrary.js");
const Shrinkable_1 = __webpack_require__(/*! ./Shrinkable */ "./node_modules/fast-check/lib/check/arbitrary/definition/Shrinkable.js");
function removeContextFromContextualValue(contextualValue) {
    return contextualValue[0];
}
class ArbitraryWithContextualShrink extends Arbitrary_1.Arbitrary {
    contextualShrinkableFor(value, context) {
        return new Shrinkable_1.Shrinkable(value, () => this.contextualShrink(value, context).map((contextualValue) => this.contextualShrinkableFor(contextualValue[0], contextualValue[1])));
    }
    shrink(value, shrunkOnce) {
        const context = shrunkOnce === true ? this.shrunkOnceContext() : undefined;
        return this.contextualShrink(value, context).map(removeContextFromContextualValue);
    }
    shrinkableFor(value, shrunkOnce) {
        return new Shrinkable_1.Shrinkable(value, () => {
            return this.shrink(value, shrunkOnce).map((value) => this.shrinkableFor(value, true));
        });
    }
}
exports.ArbitraryWithContextualShrink = ArbitraryWithContextualShrink;


/***/ }),

/***/ "./node_modules/fast-check/lib/check/arbitrary/definition/ArbitraryWithShrink.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/fast-check/lib/check/arbitrary/definition/ArbitraryWithShrink.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ArbitraryWithShrink = void 0;
const Arbitrary_1 = __webpack_require__(/*! ./Arbitrary */ "./node_modules/fast-check/lib/check/arbitrary/definition/Arbitrary.js");
const Shrinkable_1 = __webpack_require__(/*! ./Shrinkable */ "./node_modules/fast-check/lib/check/arbitrary/definition/Shrinkable.js");
class ArbitraryWithShrink extends Arbitrary_1.Arbitrary {
    shrinkableFor(value, shrunkOnce) {
        return new Shrinkable_1.Shrinkable(value, () => this.shrink(value, shrunkOnce === true).map((v) => this.shrinkableFor(v, true)));
    }
}
exports.ArbitraryWithShrink = ArbitraryWithShrink;


/***/ }),

/***/ "./node_modules/fast-check/lib/check/arbitrary/definition/BiasedArbitraryWrapper.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/fast-check/lib/check/arbitrary/definition/BiasedArbitraryWrapper.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.biasWrapper = void 0;
const Arbitrary_1 = __webpack_require__(/*! ./Arbitrary */ "./node_modules/fast-check/lib/check/arbitrary/definition/Arbitrary.js");
class BiasedArbitraryWrapper extends Arbitrary_1.Arbitrary {
    constructor(freq, arb, biasedArbBuilder) {
        super();
        this.freq = freq;
        this.arb = arb;
        this.biasedArbBuilder = biasedArbBuilder;
    }
    generate(mrng) {
        return mrng.nextInt(1, this.freq) === 1 ? this.biasedArbBuilder(this.arb).generate(mrng) : this.arb.generate(mrng);
    }
}
function biasWrapper(freq, arb, biasedArbBuilder) {
    return new BiasedArbitraryWrapper(freq, arb, biasedArbBuilder);
}
exports.biasWrapper = biasWrapper;


/***/ }),

/***/ "./node_modules/fast-check/lib/check/arbitrary/definition/ConverterFromNext.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/fast-check/lib/check/arbitrary/definition/ConverterFromNext.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var _a;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ConverterFromNext = void 0;
const ArbitraryWithContextualShrink_1 = __webpack_require__(/*! ./ArbitraryWithContextualShrink */ "./node_modules/fast-check/lib/check/arbitrary/definition/ArbitraryWithContextualShrink.js");
const ConverterToNext_1 = __webpack_require__(/*! ./ConverterToNext */ "./node_modules/fast-check/lib/check/arbitrary/definition/ConverterToNext.js");
const Shrinkable_1 = __webpack_require__(/*! ./Shrinkable */ "./node_modules/fast-check/lib/check/arbitrary/definition/Shrinkable.js");
const identifier = '__ConverterFromNext__';
function fromNextValueToShrinkableFor(arb) {
    return function fromNextValueToShrinkable(v) {
        const value_ = v.value_;
        const shrinker = () => arb.shrink(value_, v.context).map(fromNextValueToShrinkable);
        if (!v.hasToBeCloned) {
            return new Shrinkable_1.Shrinkable(value_, shrinker);
        }
        return new Shrinkable_1.Shrinkable(value_, shrinker, () => v.value);
    };
}
class ConverterFromNext extends ArbitraryWithContextualShrink_1.ArbitraryWithContextualShrink {
    constructor(arb, legacyShrunkOnceContext, biasFactor = undefined) {
        super();
        this.arb = arb;
        this.legacyShrunkOnceContext = legacyShrunkOnceContext;
        this.biasFactor = biasFactor;
        this[_a] = true;
        this.toShrinkable = fromNextValueToShrinkableFor(arb);
    }
    static isConverterFromNext(arb) {
        return identifier in arb;
    }
    static convertIfNeeded(arb) {
        if (ConverterToNext_1.ConverterToNext.isConverterToNext(arb))
            return arb.arb;
        else
            return new ConverterFromNext(arb);
    }
    generate(mrng) {
        const g = this.arb.generate(mrng, this.biasFactor);
        return this.toShrinkable(g);
    }
    contextualShrink(value, context) {
        return this.arb.shrink(value, context).map((v) => [v.value_, v.context]);
    }
    shrunkOnceContext() {
        return this.legacyShrunkOnceContext;
    }
    filter(refinement) {
        return ConverterFromNext.convertIfNeeded(this.arb.filter(refinement));
    }
    map(mapper) {
        return ConverterFromNext.convertIfNeeded(this.arb.map(mapper));
    }
    chain(fmapper) {
        return ConverterFromNext.convertIfNeeded(this.arb.chain((t) => {
            const fmapped = fmapper(t);
            if (ConverterFromNext.isConverterFromNext(fmapped))
                return fmapped.arb;
            else
                return new ConverterToNext_1.ConverterToNext(fmapped);
        }));
    }
    noShrink() {
        return ConverterFromNext.convertIfNeeded(this.arb.noShrink());
    }
    withBias(freq) {
        return new ConverterFromNext(this.arb, this.legacyShrunkOnceContext, freq);
    }
    noBias() {
        return ConverterFromNext.convertIfNeeded(this.arb.noBias());
    }
}
exports.ConverterFromNext = ConverterFromNext;
_a = identifier;


/***/ }),

/***/ "./node_modules/fast-check/lib/check/arbitrary/definition/ConverterToNext.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/fast-check/lib/check/arbitrary/definition/ConverterToNext.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var _a;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ConverterToNext = void 0;
const Stream_1 = __webpack_require__(/*! ../../../stream/Stream */ "./node_modules/fast-check/lib/stream/Stream.js");
const ConverterFromNext_1 = __webpack_require__(/*! ./ConverterFromNext */ "./node_modules/fast-check/lib/check/arbitrary/definition/ConverterFromNext.js");
const NextArbitrary_1 = __webpack_require__(/*! ./NextArbitrary */ "./node_modules/fast-check/lib/check/arbitrary/definition/NextArbitrary.js");
const NextValue_1 = __webpack_require__(/*! ./NextValue */ "./node_modules/fast-check/lib/check/arbitrary/definition/NextValue.js");
const identifier = '__ConverterToNext__';
function fromShrinkableToNextValue(g) {
    if (!g.hasToBeCloned) {
        return new NextValue_1.NextValue(g.value_, g);
    }
    return new NextValue_1.NextValue(g.value_, g, () => g.value);
}
class ConverterToNext extends NextArbitrary_1.NextArbitrary {
    constructor(arb) {
        super();
        this.arb = arb;
        this[_a] = true;
    }
    static isConverterToNext(arb) {
        return identifier in arb;
    }
    static convertIfNeeded(arb) {
        if (ConverterFromNext_1.ConverterFromNext.isConverterFromNext(arb))
            return arb.arb;
        else
            return new ConverterToNext(arb);
    }
    generate(mrng, biasFactor) {
        const g = biasFactor !== undefined ? this.arb.withBias(biasFactor).generate(mrng) : this.arb.generate(mrng);
        return fromShrinkableToNextValue(g);
    }
    canShrinkWithoutContext(_value) {
        return false;
    }
    shrink(_value, context) {
        if (this.isSafeContext(context)) {
            return context.shrink().map(fromShrinkableToNextValue);
        }
        return Stream_1.Stream.nil();
    }
    isSafeContext(context) {
        return (context != null && typeof context === 'object' && 'value' in context && 'shrink' in context);
    }
    filter(refinement) {
        return ConverterToNext.convertIfNeeded(this.arb.filter(refinement));
    }
    map(mapper) {
        return ConverterToNext.convertIfNeeded(this.arb.map(mapper));
    }
    chain(fmapper) {
        return ConverterToNext.convertIfNeeded(this.arb.chain((t) => {
            const fmapped = fmapper(t);
            if (ConverterToNext.isConverterToNext(fmapped))
                return fmapped.arb;
            else
                return new ConverterFromNext_1.ConverterFromNext(fmapped);
        }));
    }
    noShrink() {
        return ConverterToNext.convertIfNeeded(this.arb.noShrink());
    }
    noBias() {
        return ConverterToNext.convertIfNeeded(this.arb.noBias());
    }
}
exports.ConverterToNext = ConverterToNext;
_a = identifier;


/***/ }),

/***/ "./node_modules/fast-check/lib/check/arbitrary/definition/Converters.js":
/*!******************************************************************************!*\
  !*** ./node_modules/fast-check/lib/check/arbitrary/definition/Converters.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.convertToNext = exports.convertFromNextWithShrunkOnce = exports.convertFromNext = void 0;
const Arbitrary_1 = __webpack_require__(/*! ./Arbitrary */ "./node_modules/fast-check/lib/check/arbitrary/definition/Arbitrary.js");
const ConverterFromNext_1 = __webpack_require__(/*! ./ConverterFromNext */ "./node_modules/fast-check/lib/check/arbitrary/definition/ConverterFromNext.js");
const ConverterToNext_1 = __webpack_require__(/*! ./ConverterToNext */ "./node_modules/fast-check/lib/check/arbitrary/definition/ConverterToNext.js");
const NextArbitrary_1 = __webpack_require__(/*! ./NextArbitrary */ "./node_modules/fast-check/lib/check/arbitrary/definition/NextArbitrary.js");
function convertFromNext(arb) {
    if (ConverterToNext_1.ConverterToNext.isConverterToNext(arb)) {
        return arb.arb;
    }
    NextArbitrary_1.assertIsNextArbitrary(arb);
    return new ConverterFromNext_1.ConverterFromNext(arb);
}
exports.convertFromNext = convertFromNext;
function convertFromNextWithShrunkOnce(arb, legacyShrunkOnceContext) {
    if (ConverterToNext_1.ConverterToNext.isConverterToNext(arb)) {
        if (!('contextualShrink' in arb.arb) ||
            !('contextualShrinkableFor' in arb.arb) ||
            !('shrunkOnceContext' in arb.arb) ||
            !('shrink' in arb.arb) ||
            !('shrinkableFor' in arb.arb)) {
            throw new Error('Conversion rejected: Underlying arbitrary is not compatible with ArbitraryWithContextualShrink');
        }
        return arb.arb;
    }
    NextArbitrary_1.assertIsNextArbitrary(arb);
    return new ConverterFromNext_1.ConverterFromNext(arb, legacyShrunkOnceContext);
}
exports.convertFromNextWithShrunkOnce = convertFromNextWithShrunkOnce;
function convertToNext(arb) {
    if (ConverterFromNext_1.ConverterFromNext.isConverterFromNext(arb)) {
        return arb.arb;
    }
    Arbitrary_1.assertIsArbitrary(arb);
    return new ConverterToNext_1.ConverterToNext(arb);
}
exports.convertToNext = convertToNext;


/***/ }),

/***/ "./node_modules/fast-check/lib/check/arbitrary/definition/NextArbitrary.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/fast-check/lib/check/arbitrary/definition/NextArbitrary.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.assertIsNextArbitrary = exports.NextArbitrary = void 0;
const Stream_1 = __webpack_require__(/*! ../../../stream/Stream */ "./node_modules/fast-check/lib/stream/Stream.js");
const symbols_1 = __webpack_require__(/*! ../../symbols */ "./node_modules/fast-check/lib/check/symbols.js");
const NextValue_1 = __webpack_require__(/*! ./NextValue */ "./node_modules/fast-check/lib/check/arbitrary/definition/NextValue.js");
class NextArbitrary {
    filter(refinement) {
        return new FilterArbitrary(this, refinement);
    }
    map(mapper, unmapper) {
        return new MapArbitrary(this, mapper, unmapper);
    }
    chain(chainer) {
        return new ChainArbitrary(this, chainer);
    }
    noShrink() {
        return new NoShrinkArbitrary(this);
    }
    noBias() {
        return new NoBiasArbitrary(this);
    }
}
exports.NextArbitrary = NextArbitrary;
class ChainArbitrary extends NextArbitrary {
    constructor(arb, chainer) {
        super();
        this.arb = arb;
        this.chainer = chainer;
    }
    generate(mrng, biasFactor) {
        const clonedMrng = mrng.clone();
        const src = this.arb.generate(mrng, biasFactor);
        return this.valueChainer(src, mrng, clonedMrng, biasFactor);
    }
    canShrinkWithoutContext(value) {
        return false;
    }
    shrink(value, context) {
        if (this.isSafeContext(context)) {
            return (!context.stoppedForOriginal
                ? this.arb
                    .shrink(context.originalValue, context.originalContext)
                    .map((v) => this.valueChainer(v, context.clonedMrng.clone(), context.clonedMrng, context.originalBias))
                : Stream_1.Stream.nil()).join(context.chainedArbitrary.shrink(value, context.chainedContext).map((dst) => {
                const newContext = Object.assign(Object.assign({}, context), { chainedContext: dst.context, stoppedForOriginal: true });
                return new NextValue_1.NextValue(dst.value_, newContext);
            }));
        }
        return Stream_1.Stream.nil();
    }
    valueChainer(v, generateMrng, clonedMrng, biasFactor) {
        const chainedArbitrary = this.chainer(v.value_);
        const dst = chainedArbitrary.generate(generateMrng, biasFactor);
        const context = {
            originalBias: biasFactor,
            originalValue: v.value_,
            originalContext: v.context,
            stoppedForOriginal: false,
            chainedArbitrary,
            chainedContext: dst.context,
            clonedMrng,
        };
        return new NextValue_1.NextValue(dst.value_, context);
    }
    isSafeContext(context) {
        return (context != null &&
            typeof context === 'object' &&
            'originalBias' in context &&
            'originalValue' in context &&
            'originalContext' in context &&
            'stoppedForOriginal' in context &&
            'chainedArbitrary' in context &&
            'chainedContext' in context &&
            'clonedMrng' in context);
    }
}
class MapArbitrary extends NextArbitrary {
    constructor(arb, mapper, unmapper) {
        super();
        this.arb = arb;
        this.mapper = mapper;
        this.unmapper = unmapper;
        this.bindValueMapper = this.valueMapper.bind(this);
    }
    generate(mrng, biasFactor) {
        const g = this.arb.generate(mrng, biasFactor);
        return this.valueMapper(g);
    }
    canShrinkWithoutContext(value) {
        if (this.unmapper !== undefined) {
            try {
                const unmapped = this.unmapper(value);
                return this.arb.canShrinkWithoutContext(unmapped);
            }
            catch (_err) {
                return false;
            }
        }
        return false;
    }
    shrink(value, context) {
        if (this.isSafeContext(context)) {
            return this.arb.shrink(context.originalValue, context.originalContext).map(this.bindValueMapper);
        }
        if (this.unmapper !== undefined) {
            const unmapped = this.unmapper(value);
            return this.arb.shrink(unmapped, undefined).map(this.bindValueMapper);
        }
        return Stream_1.Stream.nil();
    }
    mapperWithCloneIfNeeded(v) {
        const sourceValue = v.value;
        const mappedValue = this.mapper(sourceValue);
        if (v.hasToBeCloned &&
            ((typeof mappedValue === 'object' && mappedValue !== null) || typeof mappedValue === 'function') &&
            Object.isExtensible(mappedValue)) {
            Object.defineProperty(mappedValue, symbols_1.cloneMethod, { get: () => () => this.mapperWithCloneIfNeeded(v)[0] });
        }
        return [mappedValue, sourceValue];
    }
    valueMapper(v) {
        const [mappedValue, sourceValue] = this.mapperWithCloneIfNeeded(v);
        const context = { originalValue: sourceValue, originalContext: v.context };
        return new NextValue_1.NextValue(mappedValue, context);
    }
    isSafeContext(context) {
        return (context != null &&
            typeof context === 'object' &&
            'originalValue' in context &&
            'originalContext' in context);
    }
}
class FilterArbitrary extends NextArbitrary {
    constructor(arb, refinement) {
        super();
        this.arb = arb;
        this.refinement = refinement;
        this.bindRefinementOnValue = this.refinementOnValue.bind(this);
    }
    generate(mrng, biasFactor) {
        while (true) {
            const g = this.arb.generate(mrng, biasFactor);
            if (this.refinementOnValue(g)) {
                return g;
            }
        }
    }
    canShrinkWithoutContext(value) {
        return this.arb.canShrinkWithoutContext(value) && this.refinement(value);
    }
    shrink(value, context) {
        return this.arb.shrink(value, context).filter(this.bindRefinementOnValue);
    }
    refinementOnValue(v) {
        return this.refinement(v.value);
    }
}
class NoShrinkArbitrary extends NextArbitrary {
    constructor(arb) {
        super();
        this.arb = arb;
    }
    generate(mrng, biasFactor) {
        return this.arb.generate(mrng, biasFactor);
    }
    canShrinkWithoutContext(value) {
        return this.arb.canShrinkWithoutContext(value);
    }
    shrink(_value, _context) {
        return Stream_1.Stream.nil();
    }
    noShrink() {
        return this;
    }
}
class NoBiasArbitrary extends NextArbitrary {
    constructor(arb) {
        super();
        this.arb = arb;
    }
    generate(mrng, _biasFactor) {
        return this.arb.generate(mrng, undefined);
    }
    canShrinkWithoutContext(value) {
        return this.arb.canShrinkWithoutContext(value);
    }
    shrink(value, context) {
        return this.arb.shrink(value, context);
    }
    noBias() {
        return this;
    }
}
function assertIsNextArbitrary(instance) {
    if (typeof instance !== 'object' ||
        instance === null ||
        !('generate' in instance) ||
        !('shrink' in instance) ||
        'shrinkableFor' in instance) {
        throw new Error('Unexpected value received: not an instance of NextArbitrary');
    }
}
exports.assertIsNextArbitrary = assertIsNextArbitrary;


/***/ }),

/***/ "./node_modules/fast-check/lib/check/arbitrary/definition/NextValue.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/fast-check/lib/check/arbitrary/definition/NextValue.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.NextValue = void 0;
const symbols_1 = __webpack_require__(/*! ../../symbols */ "./node_modules/fast-check/lib/check/symbols.js");
class NextValue {
    constructor(value_, context, customGetValue = undefined) {
        this.value_ = value_;
        this.context = context;
        this.hasToBeCloned = customGetValue !== undefined || symbols_1.hasCloneMethod(value_);
        this.readOnce = false;
        if (this.hasToBeCloned) {
            Object.defineProperty(this, 'value', { get: customGetValue !== undefined ? customGetValue : this.getValue });
        }
        else {
            this.value = value_;
        }
    }
    getValue() {
        if (this.hasToBeCloned) {
            if (!this.readOnce) {
                this.readOnce = true;
                return this.value_;
            }
            return this.value_[symbols_1.cloneMethod]();
        }
        return this.value_;
    }
}
exports.NextValue = NextValue;


/***/ }),

/***/ "./node_modules/fast-check/lib/check/arbitrary/definition/Shrinkable.js":
/*!******************************************************************************!*\
  !*** ./node_modules/fast-check/lib/check/arbitrary/definition/Shrinkable.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Shrinkable = void 0;
const Stream_1 = __webpack_require__(/*! ../../../stream/Stream */ "./node_modules/fast-check/lib/stream/Stream.js");
const symbols_1 = __webpack_require__(/*! ../../symbols */ "./node_modules/fast-check/lib/check/symbols.js");
class Shrinkable {
    constructor(value_, shrink = () => Stream_1.Stream.nil(), customGetValue = undefined) {
        this.value_ = value_;
        this.shrink = shrink;
        this.hasToBeCloned = customGetValue !== undefined || symbols_1.hasCloneMethod(value_);
        this.readOnce = false;
        if (this.hasToBeCloned) {
            Object.defineProperty(this, 'value', { get: customGetValue !== undefined ? customGetValue : this.getValue });
        }
        else {
            this.value = value_;
        }
    }
    getValue() {
        if (!this.readOnce) {
            this.readOnce = true;
            return this.value_;
        }
        return this.value_[symbols_1.cloneMethod]();
    }
    applyMapper(mapper) {
        if (this.hasToBeCloned) {
            const out = mapper(this.value);
            if (out instanceof Object) {
                out[symbols_1.cloneMethod] = () => this.applyMapper(mapper);
            }
            return out;
        }
        return mapper(this.value);
    }
    map(mapper) {
        return new Shrinkable(this.applyMapper(mapper), () => this.shrink().map((v) => v.map(mapper)));
    }
    filter(refinement) {
        const refinementOnShrinkable = (s) => {
            return refinement(s.value_);
        };
        return new Shrinkable(this.value, () => this.shrink()
            .filter(refinementOnShrinkable)
            .map((v) => v.filter(refinement)));
    }
}
exports.Shrinkable = Shrinkable;


/***/ }),

/***/ "./node_modules/fast-check/lib/check/arbitrary/helpers/ArrayInt64.js":
/*!***************************************************************************!*\
  !*** ./node_modules/fast-check/lib/check/arbitrary/helpers/ArrayInt64.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.logLike64 = exports.halve64 = exports.add64 = exports.negative64 = exports.substract64 = exports.clone64 = exports.isStrictlySmaller64 = exports.isEqual64 = exports.isStrictlyPositive64 = exports.isStrictlyNegative64 = exports.isZero64 = exports.Unit64 = exports.Zero64 = void 0;
exports.Zero64 = { sign: 1, data: [0, 0] };
exports.Unit64 = { sign: 1, data: [0, 1] };
function isZero64(a) {
    return a.data[0] === 0 && a.data[1] === 0;
}
exports.isZero64 = isZero64;
function isStrictlyNegative64(a) {
    return a.sign === -1 && !isZero64(a);
}
exports.isStrictlyNegative64 = isStrictlyNegative64;
function isStrictlyPositive64(a) {
    return a.sign === 1 && !isZero64(a);
}
exports.isStrictlyPositive64 = isStrictlyPositive64;
function isEqual64(a, b) {
    if (a.data[0] === b.data[0] && a.data[1] === b.data[1]) {
        return a.sign === b.sign || (a.data[0] === 0 && a.data[1] === 0);
    }
    return false;
}
exports.isEqual64 = isEqual64;
function isStrictlySmaller64Internal(a, b) {
    return a[0] < b[0] || (a[0] === b[0] && a[1] < b[1]);
}
function isStrictlySmaller64(a, b) {
    if (a.sign === b.sign) {
        return a.sign === 1
            ? isStrictlySmaller64Internal(a.data, b.data)
            : isStrictlySmaller64Internal(b.data, a.data);
    }
    return a.sign === -1 && (!isZero64(a) || !isZero64(b));
}
exports.isStrictlySmaller64 = isStrictlySmaller64;
function clone64(a) {
    return { sign: a.sign, data: [a.data[0], a.data[1]] };
}
exports.clone64 = clone64;
function substract64DataInternal(a, b) {
    let reminderLow = 0;
    let low = a[1] - b[1];
    if (low < 0) {
        reminderLow = 1;
        low = low >>> 0;
    }
    return [a[0] - b[0] - reminderLow, low];
}
function substract64Internal(a, b) {
    if (a.sign === 1 && b.sign === -1) {
        const low = a.data[1] + b.data[1];
        const high = a.data[0] + b.data[0] + (low > 0xffffffff ? 1 : 0);
        return { sign: 1, data: [high >>> 0, low >>> 0] };
    }
    return {
        sign: 1,
        data: a.sign === 1 ? substract64DataInternal(a.data, b.data) : substract64DataInternal(b.data, a.data),
    };
}
function substract64(arrayIntA, arrayIntB) {
    if (isStrictlySmaller64(arrayIntA, arrayIntB)) {
        const out = substract64Internal(arrayIntB, arrayIntA);
        out.sign = -1;
        return out;
    }
    return substract64Internal(arrayIntA, arrayIntB);
}
exports.substract64 = substract64;
function negative64(arrayIntA) {
    return {
        sign: -arrayIntA.sign,
        data: [arrayIntA.data[0], arrayIntA.data[1]],
    };
}
exports.negative64 = negative64;
function add64(arrayIntA, arrayIntB) {
    if (isZero64(arrayIntB)) {
        if (isZero64(arrayIntA)) {
            return clone64(exports.Zero64);
        }
        return clone64(arrayIntA);
    }
    return substract64(arrayIntA, negative64(arrayIntB));
}
exports.add64 = add64;
function halve64(a) {
    return {
        sign: a.sign,
        data: [Math.floor(a.data[0] / 2), (a.data[0] % 2 === 1 ? 0x80000000 : 0) + Math.floor(a.data[1] / 2)],
    };
}
exports.halve64 = halve64;
function logLike64(a) {
    return {
        sign: a.sign,
        data: [0, Math.floor(Math.log(a.data[0] * 0x100000000 + a.data[1]) / Math.log(2))],
    };
}
exports.logLike64 = logLike64;


/***/ }),

/***/ "./node_modules/fast-check/lib/check/arbitrary/helpers/ArrayInt64Arbitrary.js":
/*!************************************************************************************!*\
  !*** ./node_modules/fast-check/lib/check/arbitrary/helpers/ArrayInt64Arbitrary.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.arrayInt64 = void 0;
const Stream_1 = __webpack_require__(/*! ../../../stream/Stream */ "./node_modules/fast-check/lib/stream/Stream.js");
const Converters_1 = __webpack_require__(/*! ../definition/Converters */ "./node_modules/fast-check/lib/check/arbitrary/definition/Converters.js");
const NextArbitrary_1 = __webpack_require__(/*! ../definition/NextArbitrary */ "./node_modules/fast-check/lib/check/arbitrary/definition/NextArbitrary.js");
const NextValue_1 = __webpack_require__(/*! ../definition/NextValue */ "./node_modules/fast-check/lib/check/arbitrary/definition/NextValue.js");
const ArrayInt64_1 = __webpack_require__(/*! ./ArrayInt64 */ "./node_modules/fast-check/lib/check/arbitrary/helpers/ArrayInt64.js");
class ArrayInt64Arbitrary extends NextArbitrary_1.NextArbitrary {
    constructor(min, max) {
        super();
        this.min = min;
        this.max = max;
        this.biasedRanges = null;
    }
    generate(mrng, biasFactor) {
        const range = this.computeGenerateRange(mrng, biasFactor);
        const uncheckedValue = mrng.nextArrayInt(range.min, range.max);
        if (uncheckedValue.data.length === 1) {
            uncheckedValue.data.unshift(0);
        }
        return new NextValue_1.NextValue(uncheckedValue, undefined);
    }
    computeGenerateRange(mrng, biasFactor) {
        if (biasFactor === undefined || mrng.nextInt(1, biasFactor) !== 1) {
            return { min: this.min, max: this.max };
        }
        const ranges = this.retrieveBiasedRanges();
        if (ranges.length === 1) {
            return ranges[0];
        }
        const id = mrng.nextInt(-2 * (ranges.length - 1), ranges.length - 2);
        return id < 0 ? ranges[0] : ranges[id + 1];
    }
    canShrinkWithoutContext(value) {
        const unsafeValue = value;
        return (typeof value === 'object' &&
            value !== null &&
            (unsafeValue.sign === -1 || unsafeValue.sign === 1) &&
            Array.isArray(unsafeValue.data) &&
            unsafeValue.data.length === 2 &&
            ((ArrayInt64_1.isStrictlySmaller64(this.min, unsafeValue) && ArrayInt64_1.isStrictlySmaller64(unsafeValue, this.max)) ||
                ArrayInt64_1.isEqual64(this.min, unsafeValue) ||
                ArrayInt64_1.isEqual64(this.max, unsafeValue)));
    }
    shrinkArrayInt64(value, target, tryTargetAsap) {
        const realGap = ArrayInt64_1.substract64(value, target);
        function* shrinkGen() {
            let previous = tryTargetAsap ? undefined : target;
            const gap = tryTargetAsap ? realGap : ArrayInt64_1.halve64(realGap);
            for (let toremove = gap; !ArrayInt64_1.isZero64(toremove); toremove = ArrayInt64_1.halve64(toremove)) {
                const next = ArrayInt64_1.substract64(value, toremove);
                yield new NextValue_1.NextValue(next, previous);
                previous = next;
            }
        }
        return Stream_1.stream(shrinkGen());
    }
    shrink(current, context) {
        if (!ArrayInt64Arbitrary.isValidContext(current, context)) {
            const target = this.defaultTarget();
            return this.shrinkArrayInt64(current, target, true);
        }
        if (this.isLastChanceTry(current, context)) {
            return Stream_1.Stream.of(new NextValue_1.NextValue(context, undefined));
        }
        return this.shrinkArrayInt64(current, context, false);
    }
    defaultTarget() {
        if (!ArrayInt64_1.isStrictlyPositive64(this.min) && !ArrayInt64_1.isStrictlyNegative64(this.max)) {
            return ArrayInt64_1.Zero64;
        }
        return ArrayInt64_1.isStrictlyNegative64(this.min) ? this.max : this.min;
    }
    isLastChanceTry(current, context) {
        if (ArrayInt64_1.isZero64(current)) {
            return false;
        }
        if (current.sign === 1) {
            return ArrayInt64_1.isEqual64(current, ArrayInt64_1.add64(context, ArrayInt64_1.Unit64)) && ArrayInt64_1.isStrictlyPositive64(ArrayInt64_1.substract64(current, this.min));
        }
        else {
            return ArrayInt64_1.isEqual64(current, ArrayInt64_1.substract64(context, ArrayInt64_1.Unit64)) && ArrayInt64_1.isStrictlyNegative64(ArrayInt64_1.substract64(current, this.max));
        }
    }
    static isValidContext(_current, context) {
        if (context === undefined) {
            return false;
        }
        if (typeof context !== 'object' || context === null || !('sign' in context) || !('data' in context)) {
            throw new Error(`Invalid context type passed to ArrayInt64Arbitrary (#1)`);
        }
        return true;
    }
    retrieveBiasedRanges() {
        if (this.biasedRanges != null) {
            return this.biasedRanges;
        }
        if (ArrayInt64_1.isEqual64(this.min, this.max)) {
            this.biasedRanges = [{ min: this.min, max: this.max }];
            return this.biasedRanges;
        }
        const minStrictlySmallerZero = ArrayInt64_1.isStrictlyNegative64(this.min);
        const maxStrictlyGreaterZero = ArrayInt64_1.isStrictlyPositive64(this.max);
        if (minStrictlySmallerZero && maxStrictlyGreaterZero) {
            const logMin = ArrayInt64_1.logLike64(this.min);
            const logMax = ArrayInt64_1.logLike64(this.max);
            this.biasedRanges = [
                { min: logMin, max: logMax },
                { min: ArrayInt64_1.substract64(this.max, logMax), max: this.max },
                { min: this.min, max: ArrayInt64_1.substract64(this.min, logMin) },
            ];
        }
        else {
            const logGap = ArrayInt64_1.logLike64(ArrayInt64_1.substract64(this.max, this.min));
            const arbCloseToMin = { min: this.min, max: ArrayInt64_1.add64(this.min, logGap) };
            const arbCloseToMax = { min: ArrayInt64_1.substract64(this.max, logGap), max: this.max };
            this.biasedRanges = minStrictlySmallerZero
                ? [arbCloseToMax, arbCloseToMin]
                : [arbCloseToMin, arbCloseToMax];
        }
        return this.biasedRanges;
    }
}
function arrayInt64(min, max) {
    const arb = new ArrayInt64Arbitrary(min, max);
    return Converters_1.convertFromNextWithShrunkOnce(arb, arb.defaultTarget());
}
exports.arrayInt64 = arrayInt64;


/***/ }),

/***/ "./node_modules/fast-check/lib/check/arbitrary/helpers/SpecificCharacterRange.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/fast-check/lib/check/arbitrary/helpers/SpecificCharacterRange.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.buildAlphaNumericPercentArb = exports.buildAlphaNumericArb = exports.buildLowerAlphaNumericArb = exports.buildLowerAlphaArb = void 0;
const fullUnicode_1 = __webpack_require__(/*! ../../../arbitrary/fullUnicode */ "./node_modules/fast-check/lib/arbitrary/fullUnicode.js");
const frequency_1 = __webpack_require__(/*! ../../../arbitrary/frequency */ "./node_modules/fast-check/lib/arbitrary/frequency.js");
const mapToConstant_1 = __webpack_require__(/*! ../../../arbitrary/mapToConstant */ "./node_modules/fast-check/lib/arbitrary/mapToConstant.js");
const lowerCaseMapper = { num: 26, build: (v) => String.fromCharCode(v + 0x61) };
const upperCaseMapper = { num: 26, build: (v) => String.fromCharCode(v + 0x41) };
const numericMapper = { num: 10, build: (v) => String.fromCharCode(v + 0x30) };
const percentCharArb = fullUnicode_1.fullUnicode().map((c) => {
    const encoded = encodeURIComponent(c);
    return c !== encoded ? encoded : `%${c.charCodeAt(0).toString(16)}`;
});
const buildLowerAlphaArb = (others) => mapToConstant_1.mapToConstant(lowerCaseMapper, { num: others.length, build: (v) => others[v] });
exports.buildLowerAlphaArb = buildLowerAlphaArb;
const buildLowerAlphaNumericArb = (others) => mapToConstant_1.mapToConstant(lowerCaseMapper, numericMapper, { num: others.length, build: (v) => others[v] });
exports.buildLowerAlphaNumericArb = buildLowerAlphaNumericArb;
const buildAlphaNumericArb = (others) => mapToConstant_1.mapToConstant(lowerCaseMapper, upperCaseMapper, numericMapper, { num: others.length, build: (v) => others[v] });
exports.buildAlphaNumericArb = buildAlphaNumericArb;
const buildAlphaNumericPercentArb = (others) => frequency_1.frequency({
    weight: 10,
    arbitrary: exports.buildAlphaNumericArb(others),
}, {
    weight: 1,
    arbitrary: percentCharArb,
});
exports.buildAlphaNumericPercentArb = buildAlphaNumericPercentArb;


/***/ }),

/***/ "./node_modules/fast-check/lib/check/arbitrary/helpers/TextEscaper.js":
/*!****************************************************************************!*\
  !*** ./node_modules/fast-check/lib/check/arbitrary/helpers/TextEscaper.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.escapeForMultilineComments = exports.escapeForTemplateString = void 0;
function escapeForTemplateString(originalText) {
    return originalText.replace(/([$`\\])/g, '\\$1').replace(/\r/g, '\\r');
}
exports.escapeForTemplateString = escapeForTemplateString;
function escapeForMultilineComments(originalText) {
    return originalText.replace(/\*\//g, '*\\/');
}
exports.escapeForMultilineComments = escapeForMultilineComments;


/***/ }),

/***/ "./node_modules/fast-check/lib/check/model/ModelRunner.js":
/*!****************************************************************!*\
  !*** ./node_modules/fast-check/lib/check/model/ModelRunner.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.scheduledModelRun = exports.asyncModelRun = exports.modelRun = void 0;
const ScheduledCommand_1 = __webpack_require__(/*! ./commands/ScheduledCommand */ "./node_modules/fast-check/lib/check/model/commands/ScheduledCommand.js");
const genericModelRun = (s, cmds, initialValue, runCmd, then) => {
    return s.then((o) => {
        const { model, real } = o;
        let state = initialValue;
        for (const c of cmds) {
            state = then(state, () => {
                return runCmd(c, model, real);
            });
        }
        return state;
    });
};
const internalModelRun = (s, cmds) => {
    const then = (_p, c) => c();
    const setupProducer = {
        then: (fun) => {
            fun(s());
            return undefined;
        },
    };
    const runSync = (cmd, m, r) => {
        if (cmd.check(m))
            cmd.run(m, r);
        return undefined;
    };
    return genericModelRun(setupProducer, cmds, undefined, runSync, then);
};
const isAsyncSetup = (s) => {
    return typeof s.then === 'function';
};
const internalAsyncModelRun = async (s, cmds, defaultPromise = Promise.resolve()) => {
    const then = (p, c) => p.then(c);
    const setupProducer = {
        then: (fun) => {
            const out = s();
            if (isAsyncSetup(out))
                return out.then(fun);
            else
                return fun(out);
        },
    };
    const runAsync = async (cmd, m, r) => {
        if (await cmd.check(m))
            await cmd.run(m, r);
    };
    return await genericModelRun(setupProducer, cmds, defaultPromise, runAsync, then);
};
function modelRun(s, cmds) {
    internalModelRun(s, cmds);
}
exports.modelRun = modelRun;
async function asyncModelRun(s, cmds) {
    await internalAsyncModelRun(s, cmds);
}
exports.asyncModelRun = asyncModelRun;
async function scheduledModelRun(scheduler, s, cmds) {
    const scheduledCommands = ScheduledCommand_1.scheduleCommands(scheduler, cmds);
    const out = internalAsyncModelRun(s, scheduledCommands, scheduler.schedule(Promise.resolve(), 'startModel'));
    await scheduler.waitAll();
    await out;
}
exports.scheduledModelRun = scheduledModelRun;


/***/ }),

/***/ "./node_modules/fast-check/lib/check/model/ReplayPath.js":
/*!***************************************************************!*\
  !*** ./node_modules/fast-check/lib/check/model/ReplayPath.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ReplayPath = void 0;
class ReplayPath {
    static parse(replayPathStr) {
        const [serializedCount, serializedChanges] = replayPathStr.split(':');
        const counts = this.parseCounts(serializedCount);
        const changes = this.parseChanges(serializedChanges);
        return this.parseOccurences(counts, changes);
    }
    static stringify(replayPath) {
        const occurences = this.countOccurences(replayPath);
        const serializedCount = this.stringifyCounts(occurences);
        const serializedChanges = this.stringifyChanges(occurences);
        return `${serializedCount}:${serializedChanges}`;
    }
    static intToB64(n) {
        if (n < 26)
            return String.fromCharCode(n + 65);
        if (n < 52)
            return String.fromCharCode(n + 97 - 26);
        if (n < 62)
            return String.fromCharCode(n + 48 - 52);
        return String.fromCharCode(n === 62 ? 43 : 47);
    }
    static b64ToInt(c) {
        if (c >= 'a')
            return c.charCodeAt(0) - 97 + 26;
        if (c >= 'A')
            return c.charCodeAt(0) - 65;
        if (c >= '0')
            return c.charCodeAt(0) - 48 + 52;
        return c === '+' ? 62 : 63;
    }
    static countOccurences(replayPath) {
        return replayPath.reduce((counts, cur) => {
            if (counts.length === 0 || counts[counts.length - 1].count === 64 || counts[counts.length - 1].value !== cur)
                counts.push({ value: cur, count: 1 });
            else
                counts[counts.length - 1].count += 1;
            return counts;
        }, []);
    }
    static parseOccurences(counts, changes) {
        const replayPath = [];
        for (let idx = 0; idx !== counts.length; ++idx) {
            const count = counts[idx];
            const value = changes[idx];
            for (let num = 0; num !== count; ++num)
                replayPath.push(value);
        }
        return replayPath;
    }
    static stringifyChanges(occurences) {
        let serializedChanges = '';
        for (let idx = 0; idx < occurences.length; idx += 6) {
            const changesInt = occurences
                .slice(idx, idx + 6)
                .reduceRight((prev, cur) => prev * 2 + (cur.value ? 1 : 0), 0);
            serializedChanges += this.intToB64(changesInt);
        }
        return serializedChanges;
    }
    static parseChanges(serializedChanges) {
        const changesInt = serializedChanges.split('').map((c) => this.b64ToInt(c));
        const changes = [];
        for (let idx = 0; idx !== changesInt.length; ++idx) {
            let current = changesInt[idx];
            for (let n = 0; n !== 6; ++n, current >>= 1) {
                changes.push(current % 2 === 1);
            }
        }
        return changes;
    }
    static stringifyCounts(occurences) {
        return occurences.map(({ count }) => this.intToB64(count - 1)).join('');
    }
    static parseCounts(serializedCount) {
        return serializedCount.split('').map((c) => this.b64ToInt(c) + 1);
    }
}
exports.ReplayPath = ReplayPath;


/***/ }),

/***/ "./node_modules/fast-check/lib/check/model/commands/CommandWrapper.js":
/*!****************************************************************************!*\
  !*** ./node_modules/fast-check/lib/check/model/commands/CommandWrapper.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CommandWrapper = void 0;
const stringify_1 = __webpack_require__(/*! ../../../utils/stringify */ "./node_modules/fast-check/lib/utils/stringify.js");
const symbols_1 = __webpack_require__(/*! ../../symbols */ "./node_modules/fast-check/lib/check/symbols.js");
class CommandWrapper {
    constructor(cmd) {
        this.cmd = cmd;
        this.hasRan = false;
        if (stringify_1.hasToStringMethod(cmd)) {
            const method = cmd[stringify_1.toStringMethod];
            this[stringify_1.toStringMethod] = function toStringMethod() {
                return method.call(cmd);
            };
        }
        if (stringify_1.hasAsyncToStringMethod(cmd)) {
            const method = cmd[stringify_1.asyncToStringMethod];
            this[stringify_1.asyncToStringMethod] = function asyncToStringMethod() {
                return method.call(cmd);
            };
        }
    }
    check(m) {
        return this.cmd.check(m);
    }
    run(m, r) {
        this.hasRan = true;
        return this.cmd.run(m, r);
    }
    clone() {
        if (symbols_1.hasCloneMethod(this.cmd))
            return new CommandWrapper(this.cmd[symbols_1.cloneMethod]());
        return new CommandWrapper(this.cmd);
    }
    toString() {
        return this.cmd.toString();
    }
}
exports.CommandWrapper = CommandWrapper;


/***/ }),

/***/ "./node_modules/fast-check/lib/check/model/commands/CommandsArbitrary.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/fast-check/lib/check/model/commands/CommandsArbitrary.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.commands = void 0;
const Stream_1 = __webpack_require__(/*! ../../../stream/Stream */ "./node_modules/fast-check/lib/stream/Stream.js");
const Arbitrary_1 = __webpack_require__(/*! ../../arbitrary/definition/Arbitrary */ "./node_modules/fast-check/lib/check/arbitrary/definition/Arbitrary.js");
const Shrinkable_1 = __webpack_require__(/*! ../../arbitrary/definition/Shrinkable */ "./node_modules/fast-check/lib/check/arbitrary/definition/Shrinkable.js");
const nat_1 = __webpack_require__(/*! ../../../arbitrary/nat */ "./node_modules/fast-check/lib/arbitrary/nat.js");
const oneof_1 = __webpack_require__(/*! ../../../arbitrary/oneof */ "./node_modules/fast-check/lib/arbitrary/oneof.js");
const ReplayPath_1 = __webpack_require__(/*! ../ReplayPath */ "./node_modules/fast-check/lib/check/model/ReplayPath.js");
const CommandsIterable_1 = __webpack_require__(/*! ./CommandsIterable */ "./node_modules/fast-check/lib/check/model/commands/CommandsIterable.js");
const CommandWrapper_1 = __webpack_require__(/*! ./CommandWrapper */ "./node_modules/fast-check/lib/check/model/commands/CommandWrapper.js");
const LazyIterableIterator_1 = __webpack_require__(/*! ../../../stream/LazyIterableIterator */ "./node_modules/fast-check/lib/stream/LazyIterableIterator.js");
class CommandsArbitrary extends Arbitrary_1.Arbitrary {
    constructor(commandArbs, maxCommands, sourceReplayPath, disableReplayLog) {
        super();
        this.sourceReplayPath = sourceReplayPath;
        this.disableReplayLog = disableReplayLog;
        this.oneCommandArb = oneof_1.oneof(...commandArbs).map((c) => new CommandWrapper_1.CommandWrapper(c));
        this.lengthArb = nat_1.nat(maxCommands);
        this.replayPath = [];
        this.replayPathPosition = 0;
    }
    metadataForReplay() {
        return this.disableReplayLog ? '' : `replayPath=${JSON.stringify(ReplayPath_1.ReplayPath.stringify(this.replayPath))}`;
    }
    wrapper(items, shrunkOnce) {
        return new Shrinkable_1.Shrinkable(new CommandsIterable_1.CommandsIterable(items.map((s) => s.value_), () => this.metadataForReplay()), () => this.shrinkImpl(items, shrunkOnce).map((v) => this.wrapper(v, true)));
    }
    generate(mrng) {
        const size = this.lengthArb.generate(mrng);
        const items = Array(size.value_);
        for (let idx = 0; idx !== size.value_; ++idx) {
            const item = this.oneCommandArb.generate(mrng);
            items[idx] = item;
        }
        this.replayPathPosition = 0;
        return this.wrapper(items, false);
    }
    filterOnExecution(itemsRaw) {
        const items = [];
        for (const c of itemsRaw) {
            if (c.value_.hasRan) {
                this.replayPath.push(true);
                items.push(c);
            }
            else
                this.replayPath.push(false);
        }
        return items;
    }
    filterOnReplay(itemsRaw) {
        return itemsRaw.filter((c, idx) => {
            const state = this.replayPath[this.replayPathPosition + idx];
            if (state === undefined)
                throw new Error(`Too short replayPath`);
            if (!state && c.value_.hasRan)
                throw new Error(`Mismatch between replayPath and real execution`);
            return state;
        });
    }
    filterForShrinkImpl(itemsRaw) {
        if (this.replayPathPosition === 0) {
            this.replayPath = this.sourceReplayPath !== null ? ReplayPath_1.ReplayPath.parse(this.sourceReplayPath) : [];
        }
        const items = this.replayPathPosition < this.replayPath.length
            ? this.filterOnReplay(itemsRaw)
            : this.filterOnExecution(itemsRaw);
        this.replayPathPosition += itemsRaw.length;
        return items;
    }
    shrinkImpl(itemsRaw, shrunkOnce) {
        const items = this.filterForShrinkImpl(itemsRaw);
        if (items.length === 0) {
            return Stream_1.Stream.nil();
        }
        const rootShrink = shrunkOnce
            ? Stream_1.Stream.nil()
            : new Stream_1.Stream([[]][Symbol.iterator]());
        const nextShrinks = [];
        for (let numToKeep = 0; numToKeep !== items.length; ++numToKeep) {
            nextShrinks.push(LazyIterableIterator_1.makeLazy(() => {
                const size = this.lengthArb.contextualShrinkableFor(items.length - 1 - numToKeep);
                const fixedStart = items.slice(0, numToKeep);
                return size.shrink().map((l) => fixedStart.concat(items.slice(items.length - (l.value + 1))));
            }));
        }
        for (let itemAt = 0; itemAt !== items.length; ++itemAt) {
            nextShrinks.push(LazyIterableIterator_1.makeLazy(() => items[itemAt].shrink().map((v) => items.slice(0, itemAt).concat([v], items.slice(itemAt + 1)))));
        }
        return rootShrink.join(...nextShrinks).map((shrinkables) => {
            return shrinkables.map((c) => {
                return new Shrinkable_1.Shrinkable(c.value_.clone(), c.shrink);
            });
        });
    }
}
function commands(commandArbs, constraints) {
    const config = constraints == null ? {} : typeof constraints === 'number' ? { maxCommands: constraints } : constraints;
    return new CommandsArbitrary(commandArbs, config.maxCommands != null ? config.maxCommands : 10, config.replayPath != null ? config.replayPath : null, !!config.disableReplayLog);
}
exports.commands = commands;


/***/ }),

/***/ "./node_modules/fast-check/lib/check/model/commands/CommandsIterable.js":
/*!******************************************************************************!*\
  !*** ./node_modules/fast-check/lib/check/model/commands/CommandsIterable.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CommandsIterable = void 0;
const symbols_1 = __webpack_require__(/*! ../../symbols */ "./node_modules/fast-check/lib/check/symbols.js");
class CommandsIterable {
    constructor(commands, metadataForReplay) {
        this.commands = commands;
        this.metadataForReplay = metadataForReplay;
    }
    [Symbol.iterator]() {
        return this.commands[Symbol.iterator]();
    }
    [symbols_1.cloneMethod]() {
        return new CommandsIterable(this.commands.map((c) => c.clone()), this.metadataForReplay);
    }
    toString() {
        const serializedCommands = this.commands
            .filter((c) => c.hasRan)
            .map((c) => c.toString())
            .join(',');
        const metadata = this.metadataForReplay();
        return metadata.length !== 0 ? `${serializedCommands} /*${metadata}*/` : serializedCommands;
    }
}
exports.CommandsIterable = CommandsIterable;


/***/ }),

/***/ "./node_modules/fast-check/lib/check/model/commands/ScheduledCommand.js":
/*!******************************************************************************!*\
  !*** ./node_modules/fast-check/lib/check/model/commands/ScheduledCommand.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.scheduleCommands = exports.ScheduledCommand = void 0;
class ScheduledCommand {
    constructor(s, cmd) {
        this.s = s;
        this.cmd = cmd;
    }
    async check(m) {
        let error = null;
        let checkPassed = false;
        const status = await this.s.scheduleSequence([
            {
                label: `check@${this.cmd.toString()}`,
                builder: async () => {
                    try {
                        checkPassed = await Promise.resolve(this.cmd.check(m));
                    }
                    catch (err) {
                        error = err;
                        throw err;
                    }
                },
            },
        ]).task;
        if (status.faulty) {
            throw error;
        }
        return checkPassed;
    }
    async run(m, r) {
        let error = null;
        const status = await this.s.scheduleSequence([
            {
                label: `run@${this.cmd.toString()}`,
                builder: async () => {
                    try {
                        await this.cmd.run(m, r);
                    }
                    catch (err) {
                        error = err;
                        throw err;
                    }
                },
            },
        ]).task;
        if (status.faulty) {
            throw error;
        }
    }
}
exports.ScheduledCommand = ScheduledCommand;
const scheduleCommands = function* (s, cmds) {
    for (const cmd of cmds) {
        yield new ScheduledCommand(s, cmd);
    }
};
exports.scheduleCommands = scheduleCommands;


/***/ }),

/***/ "./node_modules/fast-check/lib/check/precondition/Pre.js":
/*!***************************************************************!*\
  !*** ./node_modules/fast-check/lib/check/precondition/Pre.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.pre = void 0;
const PreconditionFailure_1 = __webpack_require__(/*! ./PreconditionFailure */ "./node_modules/fast-check/lib/check/precondition/PreconditionFailure.js");
function pre(expectTruthy) {
    if (!expectTruthy) {
        throw new PreconditionFailure_1.PreconditionFailure();
    }
}
exports.pre = pre;


/***/ }),

/***/ "./node_modules/fast-check/lib/check/precondition/PreconditionFailure.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/fast-check/lib/check/precondition/PreconditionFailure.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PreconditionFailure = void 0;
class PreconditionFailure extends Error {
    constructor(interruptExecution = false) {
        super();
        this.interruptExecution = interruptExecution;
        this.footprint = PreconditionFailure.SharedFootPrint;
    }
    static isFailure(err) {
        return err != null && err.footprint === PreconditionFailure.SharedFootPrint;
    }
}
exports.PreconditionFailure = PreconditionFailure;
PreconditionFailure.SharedFootPrint = Symbol('fast-check/PreconditionFailure');


/***/ }),

/***/ "./node_modules/fast-check/lib/check/property/AsyncProperty.generated.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/fast-check/lib/check/property/AsyncProperty.generated.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.asyncProperty = void 0;
const genericTuple_1 = __webpack_require__(/*! ../../arbitrary/genericTuple */ "./node_modules/fast-check/lib/arbitrary/genericTuple.js");
const AsyncProperty_generic_1 = __webpack_require__(/*! ./AsyncProperty.generic */ "./node_modules/fast-check/lib/check/property/AsyncProperty.generic.js");
function asyncProperty(...args) {
    if (args.length < 2)
        throw new Error('asyncProperty expects at least two parameters');
    const arbs = args.slice(0, args.length - 1);
    const p = args[args.length - 1];
    return new AsyncProperty_generic_1.AsyncProperty(genericTuple_1.genericTuple(arbs), t => p(...t));
}
exports.asyncProperty = asyncProperty;


/***/ }),

/***/ "./node_modules/fast-check/lib/check/property/AsyncProperty.generic.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/fast-check/lib/check/property/AsyncProperty.generic.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AsyncProperty = void 0;
const PreconditionFailure_1 = __webpack_require__(/*! ../precondition/PreconditionFailure */ "./node_modules/fast-check/lib/check/precondition/PreconditionFailure.js");
const IRawProperty_1 = __webpack_require__(/*! ./IRawProperty */ "./node_modules/fast-check/lib/check/property/IRawProperty.js");
const GlobalParameters_1 = __webpack_require__(/*! ../runner/configuration/GlobalParameters */ "./node_modules/fast-check/lib/check/runner/configuration/GlobalParameters.js");
const ConverterFromNext_1 = __webpack_require__(/*! ../arbitrary/definition/ConverterFromNext */ "./node_modules/fast-check/lib/check/arbitrary/definition/ConverterFromNext.js");
class AsyncProperty {
    constructor(arb, predicate) {
        this.arb = arb;
        this.predicate = predicate;
        this.isAsync = () => true;
        const { asyncBeforeEach, asyncAfterEach, beforeEach, afterEach } = GlobalParameters_1.readConfigureGlobal() || {};
        if (asyncBeforeEach !== undefined && beforeEach !== undefined) {
            throw Error('Global "asyncBeforeEach" and "beforeEach" parameters can\'t be set at the same time when running async properties');
        }
        if (asyncAfterEach !== undefined && afterEach !== undefined) {
            throw Error('Global "asyncAfterEach" and "afterEach" parameters can\'t be set at the same time when running async properties');
        }
        this.beforeEachHook = asyncBeforeEach || beforeEach || AsyncProperty.dummyHook;
        this.afterEachHook = asyncAfterEach || afterEach || AsyncProperty.dummyHook;
    }
    generate(mrng, runId) {
        if (ConverterFromNext_1.ConverterFromNext.isConverterFromNext(this.arb)) {
            return this.arb.toShrinkable(this.arb.arb.generate(mrng, runId != null ? IRawProperty_1.runIdToFrequency(runId) : undefined));
        }
        return runId != null ? this.arb.withBias(IRawProperty_1.runIdToFrequency(runId)).generate(mrng) : this.arb.generate(mrng);
    }
    async run(v) {
        await this.beforeEachHook();
        try {
            const output = await this.predicate(v);
            return output == null || output === true ? null : 'Property failed by returning false';
        }
        catch (err) {
            if (PreconditionFailure_1.PreconditionFailure.isFailure(err))
                return err;
            if (err instanceof Error && err.stack)
                return `${err}\n\nStack trace: ${err.stack}`;
            return `${err}`;
        }
        finally {
            await this.afterEachHook();
        }
    }
    beforeEach(hookFunction) {
        const previousBeforeEachHook = this.beforeEachHook;
        this.beforeEachHook = () => hookFunction(previousBeforeEachHook);
        return this;
    }
    afterEach(hookFunction) {
        const previousAfterEachHook = this.afterEachHook;
        this.afterEachHook = () => hookFunction(previousAfterEachHook);
        return this;
    }
}
exports.AsyncProperty = AsyncProperty;
AsyncProperty.dummyHook = () => { };


/***/ }),

/***/ "./node_modules/fast-check/lib/check/property/AsyncProperty.js":
/*!*********************************************************************!*\
  !*** ./node_modules/fast-check/lib/check/property/AsyncProperty.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.asyncProperty = void 0;
const AsyncProperty_generated_1 = __webpack_require__(/*! ./AsyncProperty.generated */ "./node_modules/fast-check/lib/check/property/AsyncProperty.generated.js");
Object.defineProperty(exports, "asyncProperty", ({ enumerable: true, get: function () { return AsyncProperty_generated_1.asyncProperty; } }));


/***/ }),

/***/ "./node_modules/fast-check/lib/check/property/IRawProperty.js":
/*!********************************************************************!*\
  !*** ./node_modules/fast-check/lib/check/property/IRawProperty.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.runIdToFrequency = void 0;
const runIdToFrequency = (runId) => 2 + Math.floor(Math.log(runId + 1) / Math.log(10));
exports.runIdToFrequency = runIdToFrequency;


/***/ }),

/***/ "./node_modules/fast-check/lib/check/property/IgnoreEqualValuesProperty.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/fast-check/lib/check/property/IgnoreEqualValuesProperty.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.IgnoreEqualValuesProperty = void 0;
const stringify_1 = __webpack_require__(/*! ../../utils/stringify */ "./node_modules/fast-check/lib/utils/stringify.js");
const PreconditionFailure_1 = __webpack_require__(/*! ../precondition/PreconditionFailure */ "./node_modules/fast-check/lib/check/precondition/PreconditionFailure.js");
function fromSyncCached(cachedValue) {
    return cachedValue === null ? new PreconditionFailure_1.PreconditionFailure() : cachedValue;
}
function fromCached(...data) {
    if (data[1])
        return data[0].then(fromSyncCached);
    return fromSyncCached(data[0]);
}
function fromCachedUnsafe(cachedValue, isAsync) {
    return fromCached(cachedValue, isAsync);
}
class IgnoreEqualValuesProperty {
    constructor(property, skipRuns) {
        this.property = property;
        this.skipRuns = skipRuns;
        this.coveredCases = new Map();
        this.isAsync = () => this.property.isAsync();
        this.generate = (mrng, runId) => this.property.generate(mrng, runId);
        this.run = (v) => {
            const stringifiedValue = stringify_1.stringify(v);
            if (this.coveredCases.has(stringifiedValue)) {
                const lastOutput = this.coveredCases.get(stringifiedValue);
                if (!this.skipRuns) {
                    return lastOutput;
                }
                return fromCachedUnsafe(lastOutput, this.property.isAsync());
            }
            const out = this.property.run(v);
            this.coveredCases.set(stringifiedValue, out);
            return out;
        };
    }
}
exports.IgnoreEqualValuesProperty = IgnoreEqualValuesProperty;


/***/ }),

/***/ "./node_modules/fast-check/lib/check/property/Property.generated.js":
/*!**************************************************************************!*\
  !*** ./node_modules/fast-check/lib/check/property/Property.generated.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.property = void 0;
const genericTuple_1 = __webpack_require__(/*! ../../arbitrary/genericTuple */ "./node_modules/fast-check/lib/arbitrary/genericTuple.js");
const Property_generic_1 = __webpack_require__(/*! ./Property.generic */ "./node_modules/fast-check/lib/check/property/Property.generic.js");
function property(...args) {
    if (args.length < 2)
        throw new Error('property expects at least two parameters');
    const arbs = args.slice(0, args.length - 1);
    const p = args[args.length - 1];
    return new Property_generic_1.Property(genericTuple_1.genericTuple(arbs), t => p(...t));
}
exports.property = property;


/***/ }),

/***/ "./node_modules/fast-check/lib/check/property/Property.generic.js":
/*!************************************************************************!*\
  !*** ./node_modules/fast-check/lib/check/property/Property.generic.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Property = void 0;
const PreconditionFailure_1 = __webpack_require__(/*! ../precondition/PreconditionFailure */ "./node_modules/fast-check/lib/check/precondition/PreconditionFailure.js");
const IRawProperty_1 = __webpack_require__(/*! ./IRawProperty */ "./node_modules/fast-check/lib/check/property/IRawProperty.js");
const GlobalParameters_1 = __webpack_require__(/*! ../runner/configuration/GlobalParameters */ "./node_modules/fast-check/lib/check/runner/configuration/GlobalParameters.js");
const ConverterFromNext_1 = __webpack_require__(/*! ../arbitrary/definition/ConverterFromNext */ "./node_modules/fast-check/lib/check/arbitrary/definition/ConverterFromNext.js");
class Property {
    constructor(arb, predicate) {
        this.arb = arb;
        this.predicate = predicate;
        this.isAsync = () => false;
        const { beforeEach = Property.dummyHook, afterEach = Property.dummyHook, asyncBeforeEach, asyncAfterEach, } = GlobalParameters_1.readConfigureGlobal() || {};
        if (asyncBeforeEach !== undefined) {
            throw Error('"asyncBeforeEach" can\'t be set when running synchronous properties');
        }
        if (asyncAfterEach !== undefined) {
            throw Error('"asyncAfterEach" can\'t be set when running synchronous properties');
        }
        this.beforeEachHook = beforeEach;
        this.afterEachHook = afterEach;
    }
    generate(mrng, runId) {
        if (ConverterFromNext_1.ConverterFromNext.isConverterFromNext(this.arb)) {
            return this.arb.toShrinkable(this.arb.arb.generate(mrng, runId != null ? IRawProperty_1.runIdToFrequency(runId) : undefined));
        }
        return runId != null ? this.arb.withBias(IRawProperty_1.runIdToFrequency(runId)).generate(mrng) : this.arb.generate(mrng);
    }
    run(v) {
        this.beforeEachHook();
        try {
            const output = this.predicate(v);
            return output == null || output === true ? null : 'Property failed by returning false';
        }
        catch (err) {
            if (PreconditionFailure_1.PreconditionFailure.isFailure(err))
                return err;
            if (err instanceof Error && err.stack)
                return `${err}\n\nStack trace: ${err.stack}`;
            return `${err}`;
        }
        finally {
            this.afterEachHook();
        }
    }
    beforeEach(hookFunction) {
        const previousBeforeEachHook = this.beforeEachHook;
        this.beforeEachHook = () => hookFunction(previousBeforeEachHook);
        return this;
    }
    afterEach(hookFunction) {
        const previousAfterEachHook = this.afterEachHook;
        this.afterEachHook = () => hookFunction(previousAfterEachHook);
        return this;
    }
}
exports.Property = Property;
Property.dummyHook = () => { };


/***/ }),

/***/ "./node_modules/fast-check/lib/check/property/Property.js":
/*!****************************************************************!*\
  !*** ./node_modules/fast-check/lib/check/property/Property.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.property = void 0;
const Property_generated_1 = __webpack_require__(/*! ./Property.generated */ "./node_modules/fast-check/lib/check/property/Property.generated.js");
Object.defineProperty(exports, "property", ({ enumerable: true, get: function () { return Property_generated_1.property; } }));


/***/ }),

/***/ "./node_modules/fast-check/lib/check/property/SkipAfterProperty.js":
/*!*************************************************************************!*\
  !*** ./node_modules/fast-check/lib/check/property/SkipAfterProperty.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SkipAfterProperty = void 0;
const PreconditionFailure_1 = __webpack_require__(/*! ../precondition/PreconditionFailure */ "./node_modules/fast-check/lib/check/precondition/PreconditionFailure.js");
class SkipAfterProperty {
    constructor(property, getTime, timeLimit, interruptExecution) {
        this.property = property;
        this.getTime = getTime;
        this.interruptExecution = interruptExecution;
        this.isAsync = () => this.property.isAsync();
        this.generate = (mrng, runId) => this.property.generate(mrng, runId);
        this.run = (v) => {
            if (this.getTime() >= this.skipAfterTime) {
                const preconditionFailure = new PreconditionFailure_1.PreconditionFailure(this.interruptExecution);
                if (this.isAsync()) {
                    return Promise.resolve(preconditionFailure);
                }
                else {
                    return preconditionFailure;
                }
            }
            return this.property.run(v);
        };
        this.skipAfterTime = this.getTime() + timeLimit;
    }
}
exports.SkipAfterProperty = SkipAfterProperty;


/***/ }),

/***/ "./node_modules/fast-check/lib/check/property/TimeoutProperty.js":
/*!***********************************************************************!*\
  !*** ./node_modules/fast-check/lib/check/property/TimeoutProperty.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TimeoutProperty = void 0;
const timeoutAfter = (timeMs) => {
    let timeoutHandle = null;
    const promise = new Promise((resolve) => {
        timeoutHandle = setTimeout(() => {
            resolve(`Property timeout: exceeded limit of ${timeMs} milliseconds`);
        }, timeMs);
    });
    return {
        clear: () => clearTimeout(timeoutHandle),
        promise,
    };
};
class TimeoutProperty {
    constructor(property, timeMs) {
        this.property = property;
        this.timeMs = timeMs;
        this.isAsync = () => true;
    }
    generate(mrng, runId) {
        return this.property.generate(mrng, runId);
    }
    async run(v) {
        const t = timeoutAfter(this.timeMs);
        const propRun = Promise.race([this.property.run(v), t.promise]);
        propRun.then(t.clear, t.clear);
        return propRun;
    }
}
exports.TimeoutProperty = TimeoutProperty;


/***/ }),

/***/ "./node_modules/fast-check/lib/check/property/UnbiasedProperty.js":
/*!************************************************************************!*\
  !*** ./node_modules/fast-check/lib/check/property/UnbiasedProperty.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UnbiasedProperty = void 0;
class UnbiasedProperty {
    constructor(property) {
        this.property = property;
        this.isAsync = () => this.property.isAsync();
        this.generate = (mrng, _runId) => this.property.generate(mrng);
        this.run = (v) => this.property.run(v);
    }
}
exports.UnbiasedProperty = UnbiasedProperty;


/***/ }),

/***/ "./node_modules/fast-check/lib/check/runner/DecorateProperty.js":
/*!**********************************************************************!*\
  !*** ./node_modules/fast-check/lib/check/runner/DecorateProperty.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.decorateProperty = void 0;
const SkipAfterProperty_1 = __webpack_require__(/*! ../property/SkipAfterProperty */ "./node_modules/fast-check/lib/check/property/SkipAfterProperty.js");
const TimeoutProperty_1 = __webpack_require__(/*! ../property/TimeoutProperty */ "./node_modules/fast-check/lib/check/property/TimeoutProperty.js");
const UnbiasedProperty_1 = __webpack_require__(/*! ../property/UnbiasedProperty */ "./node_modules/fast-check/lib/check/property/UnbiasedProperty.js");
const IgnoreEqualValuesProperty_1 = __webpack_require__(/*! ../property/IgnoreEqualValuesProperty */ "./node_modules/fast-check/lib/check/property/IgnoreEqualValuesProperty.js");
function decorateProperty(rawProperty, qParams) {
    let prop = rawProperty;
    if (rawProperty.isAsync() && qParams.timeout != null) {
        prop = new TimeoutProperty_1.TimeoutProperty(prop, qParams.timeout);
    }
    if (qParams.unbiased) {
        prop = new UnbiasedProperty_1.UnbiasedProperty(prop);
    }
    if (qParams.skipAllAfterTimeLimit != null) {
        prop = new SkipAfterProperty_1.SkipAfterProperty(prop, Date.now, qParams.skipAllAfterTimeLimit, false);
    }
    if (qParams.interruptAfterTimeLimit != null) {
        prop = new SkipAfterProperty_1.SkipAfterProperty(prop, Date.now, qParams.interruptAfterTimeLimit, true);
    }
    if (qParams.skipEqualValues) {
        prop = new IgnoreEqualValuesProperty_1.IgnoreEqualValuesProperty(prop, true);
    }
    if (qParams.ignoreEqualValues) {
        prop = new IgnoreEqualValuesProperty_1.IgnoreEqualValuesProperty(prop, false);
    }
    return prop;
}
exports.decorateProperty = decorateProperty;


/***/ }),

/***/ "./node_modules/fast-check/lib/check/runner/Runner.js":
/*!************************************************************!*\
  !*** ./node_modules/fast-check/lib/check/runner/Runner.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.assert = exports.check = void 0;
const Stream_1 = __webpack_require__(/*! ../../stream/Stream */ "./node_modules/fast-check/lib/stream/Stream.js");
const Shrinkable_1 = __webpack_require__(/*! ../arbitrary/definition/Shrinkable */ "./node_modules/fast-check/lib/check/arbitrary/definition/Shrinkable.js");
const GlobalParameters_1 = __webpack_require__(/*! ./configuration/GlobalParameters */ "./node_modules/fast-check/lib/check/runner/configuration/GlobalParameters.js");
const QualifiedParameters_1 = __webpack_require__(/*! ./configuration/QualifiedParameters */ "./node_modules/fast-check/lib/check/runner/configuration/QualifiedParameters.js");
const DecorateProperty_1 = __webpack_require__(/*! ./DecorateProperty */ "./node_modules/fast-check/lib/check/runner/DecorateProperty.js");
const RunnerIterator_1 = __webpack_require__(/*! ./RunnerIterator */ "./node_modules/fast-check/lib/check/runner/RunnerIterator.js");
const SourceValuesIterator_1 = __webpack_require__(/*! ./SourceValuesIterator */ "./node_modules/fast-check/lib/check/runner/SourceValuesIterator.js");
const Tosser_1 = __webpack_require__(/*! ./Tosser */ "./node_modules/fast-check/lib/check/runner/Tosser.js");
const PathWalker_1 = __webpack_require__(/*! ./utils/PathWalker */ "./node_modules/fast-check/lib/check/runner/utils/PathWalker.js");
const RunDetailsFormatter_1 = __webpack_require__(/*! ./utils/RunDetailsFormatter */ "./node_modules/fast-check/lib/check/runner/utils/RunDetailsFormatter.js");
function runIt(property, sourceValues, verbose, interruptedAsFailure) {
    const runner = new RunnerIterator_1.RunnerIterator(sourceValues, verbose, interruptedAsFailure);
    for (const v of runner) {
        const out = property.run(v);
        runner.handleResult(out);
    }
    return runner.runExecution;
}
async function asyncRunIt(property, sourceValues, verbose, interruptedAsFailure) {
    const runner = new RunnerIterator_1.RunnerIterator(sourceValues, verbose, interruptedAsFailure);
    for (const v of runner) {
        const out = await property.run(v);
        runner.handleResult(out);
    }
    return runner.runExecution;
}
function runnerPathWalker(valueProducers, path) {
    const pathPoints = path.split(':');
    const pathStream = Stream_1.stream(valueProducers)
        .drop(pathPoints.length > 0 ? +pathPoints[0] : 0)
        .map((producer) => producer());
    const adaptedPath = ['0', ...pathPoints.slice(1)].join(':');
    return Stream_1.stream(PathWalker_1.pathWalk(adaptedPath, pathStream)).map((v) => () => v);
}
function buildInitialValues(valueProducers, qParams) {
    const rawValues = qParams.path.length === 0 ? Stream_1.stream(valueProducers) : runnerPathWalker(valueProducers, qParams.path);
    if (!qParams.endOnFailure)
        return rawValues;
    return rawValues.map((shrinkableGen) => {
        return () => {
            const s = shrinkableGen();
            return new Shrinkable_1.Shrinkable(s.value_);
        };
    });
}
function check(rawProperty, params) {
    if (rawProperty == null || rawProperty.generate == null)
        throw new Error('Invalid property encountered, please use a valid property');
    if (rawProperty.run == null)
        throw new Error('Invalid property encountered, please use a valid property not an arbitrary');
    const qParams = QualifiedParameters_1.QualifiedParameters.read(Object.assign(Object.assign({}, GlobalParameters_1.readConfigureGlobal()), params));
    if (qParams.reporter !== null && qParams.asyncReporter !== null)
        throw new Error('Invalid parameters encountered, reporter and asyncReporter cannot be specified together');
    if (qParams.asyncReporter !== null && !rawProperty.isAsync())
        throw new Error('Invalid parameters encountered, only asyncProperty can be used when asyncReporter specified');
    const property = DecorateProperty_1.decorateProperty(rawProperty, qParams);
    const generator = Tosser_1.toss(property, qParams.seed, qParams.randomType, qParams.examples);
    const maxInitialIterations = qParams.path.indexOf(':') === -1 ? qParams.numRuns : -1;
    const maxSkips = qParams.numRuns * qParams.maxSkipsPerRun;
    const initialValues = buildInitialValues(generator, qParams);
    const sourceValues = new SourceValuesIterator_1.SourceValuesIterator(initialValues, maxInitialIterations, maxSkips);
    return property.isAsync()
        ? asyncRunIt(property, sourceValues, qParams.verbose, qParams.markInterruptAsFailure).then((e) => e.toRunDetails(qParams.seed, qParams.path, maxSkips, qParams))
        : runIt(property, sourceValues, qParams.verbose, qParams.markInterruptAsFailure).toRunDetails(qParams.seed, qParams.path, maxSkips, qParams);
}
exports.check = check;
function assert(property, params) {
    const out = check(property, params);
    if (property.isAsync())
        return out.then(RunDetailsFormatter_1.asyncReportRunDetails);
    else
        RunDetailsFormatter_1.reportRunDetails(out);
}
exports.assert = assert;


/***/ }),

/***/ "./node_modules/fast-check/lib/check/runner/RunnerIterator.js":
/*!********************************************************************!*\
  !*** ./node_modules/fast-check/lib/check/runner/RunnerIterator.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RunnerIterator = void 0;
const RunExecution_1 = __webpack_require__(/*! ./reporter/RunExecution */ "./node_modules/fast-check/lib/check/runner/reporter/RunExecution.js");
class RunnerIterator {
    constructor(sourceValues, verbose, interruptedAsFailure) {
        this.sourceValues = sourceValues;
        this.runExecution = new RunExecution_1.RunExecution(verbose, interruptedAsFailure);
        this.currentIdx = -1;
        this.nextValues = sourceValues;
    }
    [Symbol.iterator]() {
        return this;
    }
    next() {
        const nextValue = this.nextValues.next();
        if (nextValue.done || this.runExecution.interrupted) {
            return { done: true, value: undefined };
        }
        this.currentShrinkable = nextValue.value;
        ++this.currentIdx;
        return { done: false, value: nextValue.value.value_ };
    }
    handleResult(result) {
        if (result != null && typeof result === 'string') {
            this.runExecution.fail(this.currentShrinkable.value_, this.currentIdx, result);
            this.currentIdx = -1;
            this.nextValues = this.currentShrinkable.shrink();
        }
        else if (result != null) {
            if (!result.interruptExecution) {
                this.runExecution.skip(this.currentShrinkable.value_);
                this.sourceValues.skippedOne();
            }
            else {
                this.runExecution.interrupt();
            }
        }
        else {
            this.runExecution.success(this.currentShrinkable.value_);
        }
    }
}
exports.RunnerIterator = RunnerIterator;


/***/ }),

/***/ "./node_modules/fast-check/lib/check/runner/Sampler.js":
/*!*************************************************************!*\
  !*** ./node_modules/fast-check/lib/check/runner/Sampler.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.statistics = exports.sample = void 0;
const Stream_1 = __webpack_require__(/*! ../../stream/Stream */ "./node_modules/fast-check/lib/stream/Stream.js");
const Property_generic_1 = __webpack_require__(/*! ../property/Property.generic */ "./node_modules/fast-check/lib/check/property/Property.generic.js");
const UnbiasedProperty_1 = __webpack_require__(/*! ../property/UnbiasedProperty */ "./node_modules/fast-check/lib/check/property/UnbiasedProperty.js");
const GlobalParameters_1 = __webpack_require__(/*! ./configuration/GlobalParameters */ "./node_modules/fast-check/lib/check/runner/configuration/GlobalParameters.js");
const QualifiedParameters_1 = __webpack_require__(/*! ./configuration/QualifiedParameters */ "./node_modules/fast-check/lib/check/runner/configuration/QualifiedParameters.js");
const Tosser_1 = __webpack_require__(/*! ./Tosser */ "./node_modules/fast-check/lib/check/runner/Tosser.js");
const PathWalker_1 = __webpack_require__(/*! ./utils/PathWalker */ "./node_modules/fast-check/lib/check/runner/utils/PathWalker.js");
function toProperty(generator, qParams) {
    const prop = !Object.prototype.hasOwnProperty.call(generator, 'isAsync')
        ? new Property_generic_1.Property(generator, () => true)
        : generator;
    return qParams.unbiased === true ? new UnbiasedProperty_1.UnbiasedProperty(prop) : prop;
}
function streamSample(generator, params) {
    const extendedParams = typeof params === 'number'
        ? Object.assign(Object.assign({}, GlobalParameters_1.readConfigureGlobal()), { numRuns: params }) : Object.assign(Object.assign({}, GlobalParameters_1.readConfigureGlobal()), params);
    const qParams = QualifiedParameters_1.QualifiedParameters.read(extendedParams);
    const tossedValues = Stream_1.stream(Tosser_1.toss(toProperty(generator, qParams), qParams.seed, qParams.randomType, qParams.examples));
    if (qParams.path.length === 0) {
        return tossedValues.take(qParams.numRuns).map((s) => s().value_);
    }
    return Stream_1.stream(PathWalker_1.pathWalk(qParams.path, tossedValues.map((s) => s())))
        .take(qParams.numRuns)
        .map((s) => s.value_);
}
function sample(generator, params) {
    return [...streamSample(generator, params)];
}
exports.sample = sample;
function statistics(generator, classify, params) {
    const extendedParams = typeof params === 'number'
        ? Object.assign(Object.assign({}, GlobalParameters_1.readConfigureGlobal()), { numRuns: params }) : Object.assign(Object.assign({}, GlobalParameters_1.readConfigureGlobal()), params);
    const qParams = QualifiedParameters_1.QualifiedParameters.read(extendedParams);
    const recorded = {};
    for (const g of streamSample(generator, params)) {
        const out = classify(g);
        const categories = Array.isArray(out) ? out : [out];
        for (const c of categories) {
            recorded[c] = (recorded[c] || 0) + 1;
        }
    }
    const data = Object.entries(recorded)
        .sort((a, b) => b[1] - a[1])
        .map((i) => [i[0], `${((i[1] * 100.0) / qParams.numRuns).toFixed(2)}%`]);
    const longestName = data.map((i) => i[0].length).reduce((p, c) => Math.max(p, c), 0);
    const longestPercent = data.map((i) => i[1].length).reduce((p, c) => Math.max(p, c), 0);
    for (const item of data) {
        qParams.logger(`${item[0].padEnd(longestName, '.')}..${item[1].padStart(longestPercent, '.')}`);
    }
}
exports.statistics = statistics;


/***/ }),

/***/ "./node_modules/fast-check/lib/check/runner/SourceValuesIterator.js":
/*!**************************************************************************!*\
  !*** ./node_modules/fast-check/lib/check/runner/SourceValuesIterator.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SourceValuesIterator = void 0;
class SourceValuesIterator {
    constructor(initialValues, maxInitialIterations, remainingSkips) {
        this.initialValues = initialValues;
        this.maxInitialIterations = maxInitialIterations;
        this.remainingSkips = remainingSkips;
    }
    [Symbol.iterator]() {
        return this;
    }
    next() {
        if (--this.maxInitialIterations !== -1 && this.remainingSkips >= 0) {
            const n = this.initialValues.next();
            if (!n.done)
                return { value: n.value(), done: false };
        }
        return { value: undefined, done: true };
    }
    skippedOne() {
        --this.remainingSkips;
        ++this.maxInitialIterations;
    }
}
exports.SourceValuesIterator = SourceValuesIterator;


/***/ }),

/***/ "./node_modules/fast-check/lib/check/runner/Tosser.js":
/*!************************************************************!*\
  !*** ./node_modules/fast-check/lib/check/runner/Tosser.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.toss = void 0;
const pure_rand_1 = __webpack_require__(/*! pure-rand */ "./node_modules/pure-rand/lib/pure-rand.js");
const Random_1 = __webpack_require__(/*! ../../random/generator/Random */ "./node_modules/fast-check/lib/random/generator/Random.js");
const Shrinkable_1 = __webpack_require__(/*! ../arbitrary/definition/Shrinkable */ "./node_modules/fast-check/lib/check/arbitrary/definition/Shrinkable.js");
const PureRandom_1 = __webpack_require__(/*! ../../random/generator/PureRandom */ "./node_modules/fast-check/lib/random/generator/PureRandom.js");
function lazyGenerate(generator, rng, idx) {
    return () => generator.generate(new Random_1.Random(rng), idx);
}
function* toss(generator, seed, random, examples) {
    yield* examples.map((e) => () => new Shrinkable_1.Shrinkable(e));
    let idx = 0;
    let rng = PureRandom_1.convertToRandomGenerator(random(seed));
    for (;;) {
        rng = rng.jump ? rng.jump() : pure_rand_1.skipN(rng, 42);
        yield lazyGenerate(generator, rng, idx++);
    }
}
exports.toss = toss;


/***/ }),

/***/ "./node_modules/fast-check/lib/check/runner/configuration/GlobalParameters.js":
/*!************************************************************************************!*\
  !*** ./node_modules/fast-check/lib/check/runner/configuration/GlobalParameters.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.resetConfigureGlobal = exports.readConfigureGlobal = exports.configureGlobal = void 0;
let globalParameters = {};
function configureGlobal(parameters) {
    globalParameters = parameters;
}
exports.configureGlobal = configureGlobal;
function readConfigureGlobal() {
    return globalParameters;
}
exports.readConfigureGlobal = readConfigureGlobal;
function resetConfigureGlobal() {
    globalParameters = {};
}
exports.resetConfigureGlobal = resetConfigureGlobal;


/***/ }),

/***/ "./node_modules/fast-check/lib/check/runner/configuration/QualifiedParameters.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/fast-check/lib/check/runner/configuration/QualifiedParameters.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.QualifiedParameters = void 0;
const pure_rand_1 = __webpack_require__(/*! pure-rand */ "./node_modules/pure-rand/lib/pure-rand.js");
const VerbosityLevel_1 = __webpack_require__(/*! ./VerbosityLevel */ "./node_modules/fast-check/lib/check/runner/configuration/VerbosityLevel.js");
class QualifiedParameters {
    constructor(op) {
        const p = op || {};
        this.seed = QualifiedParameters.readSeed(p);
        this.randomType = QualifiedParameters.readRandomType(p);
        this.numRuns = QualifiedParameters.readNumRuns(p);
        this.verbose = QualifiedParameters.readVerbose(p);
        this.maxSkipsPerRun = QualifiedParameters.readOrDefault(p, 'maxSkipsPerRun', 100);
        this.timeout = QualifiedParameters.readOrDefault(p, 'timeout', null);
        this.skipAllAfterTimeLimit = QualifiedParameters.readOrDefault(p, 'skipAllAfterTimeLimit', null);
        this.interruptAfterTimeLimit = QualifiedParameters.readOrDefault(p, 'interruptAfterTimeLimit', null);
        this.markInterruptAsFailure = QualifiedParameters.readBoolean(p, 'markInterruptAsFailure');
        this.skipEqualValues = QualifiedParameters.readBoolean(p, 'skipEqualValues');
        this.ignoreEqualValues = QualifiedParameters.readBoolean(p, 'ignoreEqualValues');
        this.logger = QualifiedParameters.readOrDefault(p, 'logger', (v) => {
            console.log(v);
        });
        this.path = QualifiedParameters.readOrDefault(p, 'path', '');
        this.unbiased = QualifiedParameters.readBoolean(p, 'unbiased');
        this.examples = QualifiedParameters.readOrDefault(p, 'examples', []);
        this.endOnFailure = QualifiedParameters.readBoolean(p, 'endOnFailure');
        this.reporter = QualifiedParameters.readOrDefault(p, 'reporter', null);
        this.asyncReporter = QualifiedParameters.readOrDefault(p, 'asyncReporter', null);
    }
    toParameters() {
        const orUndefined = (value) => (value !== null ? value : undefined);
        return {
            seed: this.seed,
            randomType: this.randomType,
            numRuns: this.numRuns,
            maxSkipsPerRun: this.maxSkipsPerRun,
            timeout: orUndefined(this.timeout),
            skipAllAfterTimeLimit: orUndefined(this.skipAllAfterTimeLimit),
            interruptAfterTimeLimit: orUndefined(this.interruptAfterTimeLimit),
            markInterruptAsFailure: this.markInterruptAsFailure,
            skipEqualValues: this.skipEqualValues,
            ignoreEqualValues: this.ignoreEqualValues,
            path: this.path,
            logger: this.logger,
            unbiased: this.unbiased,
            verbose: this.verbose,
            examples: this.examples,
            endOnFailure: this.endOnFailure,
            reporter: orUndefined(this.reporter),
            asyncReporter: orUndefined(this.asyncReporter),
        };
    }
    static read(op) {
        return new QualifiedParameters(op);
    }
}
exports.QualifiedParameters = QualifiedParameters;
QualifiedParameters.readSeed = (p) => {
    if (p.seed == null)
        return Date.now() ^ (Math.random() * 0x100000000);
    const seed32 = p.seed | 0;
    if (p.seed === seed32)
        return seed32;
    const gap = p.seed - seed32;
    return seed32 ^ (gap * 0x100000000);
};
QualifiedParameters.readRandomType = (p) => {
    if (p.randomType == null)
        return pure_rand_1.default.xorshift128plus;
    if (typeof p.randomType === 'string') {
        switch (p.randomType) {
            case 'mersenne':
                return pure_rand_1.default.mersenne;
            case 'congruential':
                return pure_rand_1.default.congruential;
            case 'congruential32':
                return pure_rand_1.default.congruential32;
            case 'xorshift128plus':
                return pure_rand_1.default.xorshift128plus;
            case 'xoroshiro128plus':
                return pure_rand_1.default.xoroshiro128plus;
            default:
                throw new Error(`Invalid random specified: '${p.randomType}'`);
        }
    }
    return p.randomType;
};
QualifiedParameters.readNumRuns = (p) => {
    const defaultValue = 100;
    if (p.numRuns != null)
        return p.numRuns;
    if (p.num_runs != null)
        return p.num_runs;
    return defaultValue;
};
QualifiedParameters.readVerbose = (p) => {
    if (p.verbose == null)
        return VerbosityLevel_1.VerbosityLevel.None;
    if (typeof p.verbose === 'boolean') {
        return p.verbose === true ? VerbosityLevel_1.VerbosityLevel.Verbose : VerbosityLevel_1.VerbosityLevel.None;
    }
    if (p.verbose <= VerbosityLevel_1.VerbosityLevel.None) {
        return VerbosityLevel_1.VerbosityLevel.None;
    }
    if (p.verbose >= VerbosityLevel_1.VerbosityLevel.VeryVerbose) {
        return VerbosityLevel_1.VerbosityLevel.VeryVerbose;
    }
    return p.verbose | 0;
};
QualifiedParameters.readBoolean = (p, key) => p[key] === true;
QualifiedParameters.readOrDefault = (p, key, defaultValue) => {
    const value = p[key];
    return value != null ? value : defaultValue;
};


/***/ }),

/***/ "./node_modules/fast-check/lib/check/runner/configuration/VerbosityLevel.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/fast-check/lib/check/runner/configuration/VerbosityLevel.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.VerbosityLevel = void 0;
var VerbosityLevel;
(function (VerbosityLevel) {
    VerbosityLevel[VerbosityLevel["None"] = 0] = "None";
    VerbosityLevel[VerbosityLevel["Verbose"] = 1] = "Verbose";
    VerbosityLevel[VerbosityLevel["VeryVerbose"] = 2] = "VeryVerbose";
})(VerbosityLevel = exports.VerbosityLevel || (exports.VerbosityLevel = {}));


/***/ }),

/***/ "./node_modules/fast-check/lib/check/runner/reporter/ExecutionStatus.js":
/*!******************************************************************************!*\
  !*** ./node_modules/fast-check/lib/check/runner/reporter/ExecutionStatus.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ExecutionStatus = void 0;
var ExecutionStatus;
(function (ExecutionStatus) {
    ExecutionStatus[ExecutionStatus["Success"] = 0] = "Success";
    ExecutionStatus[ExecutionStatus["Skipped"] = -1] = "Skipped";
    ExecutionStatus[ExecutionStatus["Failure"] = 1] = "Failure";
})(ExecutionStatus = exports.ExecutionStatus || (exports.ExecutionStatus = {}));


/***/ }),

/***/ "./node_modules/fast-check/lib/check/runner/reporter/RunExecution.js":
/*!***************************************************************************!*\
  !*** ./node_modules/fast-check/lib/check/runner/reporter/RunExecution.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RunExecution = void 0;
const VerbosityLevel_1 = __webpack_require__(/*! ../configuration/VerbosityLevel */ "./node_modules/fast-check/lib/check/runner/configuration/VerbosityLevel.js");
const ExecutionStatus_1 = __webpack_require__(/*! ./ExecutionStatus */ "./node_modules/fast-check/lib/check/runner/reporter/ExecutionStatus.js");
class RunExecution {
    constructor(verbosity, interruptedAsFailure) {
        this.verbosity = verbosity;
        this.interruptedAsFailure = interruptedAsFailure;
        this.isSuccess = () => this.pathToFailure == null;
        this.firstFailure = () => (this.pathToFailure ? +this.pathToFailure.split(':')[0] : -1);
        this.numShrinks = () => (this.pathToFailure ? this.pathToFailure.split(':').length - 1 : 0);
        this.rootExecutionTrees = [];
        this.currentLevelExecutionTrees = this.rootExecutionTrees;
        this.failure = null;
        this.numSkips = 0;
        this.numSuccesses = 0;
        this.interrupted = false;
    }
    appendExecutionTree(status, value) {
        const currentTree = { status, value, children: [] };
        this.currentLevelExecutionTrees.push(currentTree);
        return currentTree;
    }
    fail(value, id, message) {
        if (this.verbosity >= VerbosityLevel_1.VerbosityLevel.Verbose) {
            const currentTree = this.appendExecutionTree(ExecutionStatus_1.ExecutionStatus.Failure, value);
            this.currentLevelExecutionTrees = currentTree.children;
        }
        if (this.pathToFailure == null)
            this.pathToFailure = `${id}`;
        else
            this.pathToFailure += `:${id}`;
        this.value = value;
        this.failure = message;
    }
    skip(value) {
        if (this.verbosity >= VerbosityLevel_1.VerbosityLevel.VeryVerbose) {
            this.appendExecutionTree(ExecutionStatus_1.ExecutionStatus.Skipped, value);
        }
        if (this.pathToFailure == null) {
            ++this.numSkips;
        }
    }
    success(value) {
        if (this.verbosity >= VerbosityLevel_1.VerbosityLevel.VeryVerbose) {
            this.appendExecutionTree(ExecutionStatus_1.ExecutionStatus.Success, value);
        }
        if (this.pathToFailure == null) {
            ++this.numSuccesses;
        }
    }
    interrupt() {
        this.interrupted = true;
    }
    extractFailures() {
        if (this.isSuccess()) {
            return [];
        }
        const failures = [];
        let cursor = this.rootExecutionTrees;
        while (cursor.length > 0 && cursor[cursor.length - 1].status === ExecutionStatus_1.ExecutionStatus.Failure) {
            const failureTree = cursor[cursor.length - 1];
            failures.push(failureTree.value);
            cursor = failureTree.children;
        }
        return failures;
    }
    toRunDetails(seed, basePath, maxSkips, qParams) {
        if (!this.isSuccess()) {
            return {
                failed: true,
                interrupted: this.interrupted,
                numRuns: this.firstFailure() + 1 - this.numSkips,
                numSkips: this.numSkips,
                numShrinks: this.numShrinks(),
                seed,
                counterexample: this.value,
                counterexamplePath: RunExecution.mergePaths(basePath, this.pathToFailure),
                error: this.failure,
                failures: this.extractFailures(),
                executionSummary: this.rootExecutionTrees,
                verbose: this.verbosity,
                runConfiguration: qParams.toParameters(),
            };
        }
        const failed = this.numSkips > maxSkips || (this.interrupted && this.interruptedAsFailure);
        return {
            failed,
            interrupted: this.interrupted,
            numRuns: this.numSuccesses,
            numSkips: this.numSkips,
            numShrinks: 0,
            seed,
            counterexample: null,
            counterexamplePath: null,
            error: null,
            failures: [],
            executionSummary: this.rootExecutionTrees,
            verbose: this.verbosity,
            runConfiguration: qParams.toParameters(),
        };
    }
}
exports.RunExecution = RunExecution;
RunExecution.mergePaths = (offsetPath, path) => {
    if (offsetPath.length === 0)
        return path;
    const offsetItems = offsetPath.split(':');
    const remainingItems = path.split(':');
    const middle = +offsetItems[offsetItems.length - 1] + +remainingItems[0];
    return [...offsetItems.slice(0, offsetItems.length - 1), `${middle}`, ...remainingItems.slice(1)].join(':');
};


/***/ }),

/***/ "./node_modules/fast-check/lib/check/runner/utils/PathWalker.js":
/*!**********************************************************************!*\
  !*** ./node_modules/fast-check/lib/check/runner/utils/PathWalker.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.pathWalk = void 0;
const Stream_1 = __webpack_require__(/*! ../../../stream/Stream */ "./node_modules/fast-check/lib/stream/Stream.js");
function pathWalk(path, initialValues) {
    let values = Stream_1.stream(initialValues);
    const segments = path.split(':').map((text) => +text);
    if (segments.length === 0)
        return values;
    if (!segments.every((v) => !Number.isNaN(v))) {
        throw new Error(`Unable to replay, got invalid path=${path}`);
    }
    values = values.drop(segments[0]);
    for (const s of segments.slice(1)) {
        const valueToShrink = values.getNthOrLast(0);
        if (valueToShrink == null) {
            throw new Error(`Unable to replay, got wrong path=${path}`);
        }
        values = valueToShrink.shrink().drop(s);
    }
    return values;
}
exports.pathWalk = pathWalk;


/***/ }),

/***/ "./node_modules/fast-check/lib/check/runner/utils/RunDetailsFormatter.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/fast-check/lib/check/runner/utils/RunDetailsFormatter.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.asyncDefaultReportMessage = exports.defaultReportMessage = exports.asyncReportRunDetails = exports.reportRunDetails = void 0;
const stringify_1 = __webpack_require__(/*! ../../../utils/stringify */ "./node_modules/fast-check/lib/utils/stringify.js");
const VerbosityLevel_1 = __webpack_require__(/*! ../configuration/VerbosityLevel */ "./node_modules/fast-check/lib/check/runner/configuration/VerbosityLevel.js");
const ExecutionStatus_1 = __webpack_require__(/*! ../reporter/ExecutionStatus */ "./node_modules/fast-check/lib/check/runner/reporter/ExecutionStatus.js");
function formatHints(hints) {
    if (hints.length === 1) {
        return `Hint: ${hints[0]}`;
    }
    return hints.map((h, idx) => `Hint (${idx + 1}): ${h}`).join('\n');
}
function formatFailures(failures, stringifyOne) {
    return `Encountered failures were:\n- ${failures.map(stringifyOne).join('\n- ')}`;
}
function formatExecutionSummary(executionTrees, stringifyOne) {
    const summaryLines = [];
    const remainingTreesAndDepth = [];
    for (const tree of executionTrees.slice().reverse()) {
        remainingTreesAndDepth.push({ depth: 1, tree });
    }
    while (remainingTreesAndDepth.length !== 0) {
        const currentTreeAndDepth = remainingTreesAndDepth.pop();
        const currentTree = currentTreeAndDepth.tree;
        const currentDepth = currentTreeAndDepth.depth;
        const statusIcon = currentTree.status === ExecutionStatus_1.ExecutionStatus.Success
            ? '\x1b[32m\u221A\x1b[0m'
            : currentTree.status === ExecutionStatus_1.ExecutionStatus.Failure
                ? '\x1b[31m\xD7\x1b[0m'
                : '\x1b[33m!\x1b[0m';
        const leftPadding = Array(currentDepth).join('. ');
        summaryLines.push(`${leftPadding}${statusIcon} ${stringifyOne(currentTree.value)}`);
        for (const tree of currentTree.children.slice().reverse()) {
            remainingTreesAndDepth.push({ depth: currentDepth + 1, tree });
        }
    }
    return `Execution summary:\n${summaryLines.join('\n')}`;
}
function preFormatTooManySkipped(out, stringifyOne) {
    const message = `Failed to run property, too many pre-condition failures encountered\n{ seed: ${out.seed} }\n\nRan ${out.numRuns} time(s)\nSkipped ${out.numSkips} time(s)`;
    let details = null;
    const hints = [
        'Try to reduce the number of rejected values by combining map, flatMap and built-in arbitraries',
        'Increase failure tolerance by setting maxSkipsPerRun to an higher value',
    ];
    if (out.verbose >= VerbosityLevel_1.VerbosityLevel.VeryVerbose) {
        details = formatExecutionSummary(out.executionSummary, stringifyOne);
    }
    else {
        hints.push('Enable verbose mode at level VeryVerbose in order to check all generated values and their associated status');
    }
    return { message, details, hints };
}
function preFormatFailure(out, stringifyOne) {
    const message = `Property failed after ${out.numRuns} tests\n{ seed: ${out.seed}, path: "${out.counterexamplePath}", endOnFailure: true }\nCounterexample: ${stringifyOne(out.counterexample)}\nShrunk ${out.numShrinks} time(s)\nGot error: ${out.error}`;
    let details = null;
    const hints = [];
    if (out.verbose >= VerbosityLevel_1.VerbosityLevel.VeryVerbose) {
        details = formatExecutionSummary(out.executionSummary, stringifyOne);
    }
    else if (out.verbose === VerbosityLevel_1.VerbosityLevel.Verbose) {
        details = formatFailures(out.failures, stringifyOne);
    }
    else {
        hints.push('Enable verbose mode in order to have the list of all failing values encountered during the run');
    }
    return { message, details, hints };
}
function preFormatEarlyInterrupted(out, stringifyOne) {
    const message = `Property interrupted after ${out.numRuns} tests\n{ seed: ${out.seed} }`;
    let details = null;
    const hints = [];
    if (out.verbose >= VerbosityLevel_1.VerbosityLevel.VeryVerbose) {
        details = formatExecutionSummary(out.executionSummary, stringifyOne);
    }
    else {
        hints.push('Enable verbose mode at level VeryVerbose in order to check all generated values and their associated status');
    }
    return { message, details, hints };
}
function defaultReportMessageInternal(out, stringifyOne) {
    if (!out.failed)
        return;
    const { message, details, hints } = out.counterexamplePath === null
        ? out.interrupted
            ? preFormatEarlyInterrupted(out, stringifyOne)
            : preFormatTooManySkipped(out, stringifyOne)
        : preFormatFailure(out, stringifyOne);
    let errorMessage = message;
    if (details != null)
        errorMessage += `\n\n${details}`;
    if (hints.length > 0)
        errorMessage += `\n\n${formatHints(hints)}`;
    return errorMessage;
}
function defaultReportMessage(out) {
    return defaultReportMessageInternal(out, stringify_1.stringify);
}
exports.defaultReportMessage = defaultReportMessage;
async function asyncDefaultReportMessage(out) {
    const pendingStringifieds = [];
    function stringifyOne(value) {
        const stringified = stringify_1.possiblyAsyncStringify(value);
        if (typeof stringified === 'string') {
            return stringified;
        }
        pendingStringifieds.push(Promise.all([value, stringified]));
        return '\u2026';
    }
    const firstTryMessage = defaultReportMessageInternal(out, stringifyOne);
    if (pendingStringifieds.length === 0) {
        return firstTryMessage;
    }
    const registeredValues = new Map(await Promise.all(pendingStringifieds));
    function stringifySecond(value) {
        const asyncStringifiedIfRegistered = registeredValues.get(value);
        if (asyncStringifiedIfRegistered !== undefined) {
            return asyncStringifiedIfRegistered;
        }
        return stringify_1.stringify(value);
    }
    return defaultReportMessageInternal(out, stringifySecond);
}
exports.asyncDefaultReportMessage = asyncDefaultReportMessage;
function throwIfFailed(out) {
    if (!out.failed)
        return;
    throw new Error(defaultReportMessage(out));
}
async function asyncThrowIfFailed(out) {
    if (!out.failed)
        return;
    throw new Error(await asyncDefaultReportMessage(out));
}
function reportRunDetails(out) {
    if (out.runConfiguration.asyncReporter)
        return out.runConfiguration.asyncReporter(out);
    else if (out.runConfiguration.reporter)
        return out.runConfiguration.reporter(out);
    else
        return throwIfFailed(out);
}
exports.reportRunDetails = reportRunDetails;
async function asyncReportRunDetails(out) {
    if (out.runConfiguration.asyncReporter)
        return out.runConfiguration.asyncReporter(out);
    else if (out.runConfiguration.reporter)
        return out.runConfiguration.reporter(out);
    else
        return asyncThrowIfFailed(out);
}
exports.asyncReportRunDetails = asyncReportRunDetails;


/***/ }),

/***/ "./node_modules/fast-check/lib/check/symbols.js":
/*!******************************************************!*\
  !*** ./node_modules/fast-check/lib/check/symbols.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.cloneIfNeeded = exports.hasCloneMethod = exports.cloneMethod = void 0;
exports.cloneMethod = Symbol('fast-check/cloneMethod');
function hasCloneMethod(instance) {
    return (instance !== null &&
        (typeof instance === 'object' || typeof instance === 'function') &&
        exports.cloneMethod in instance &&
        typeof instance[exports.cloneMethod] === 'function');
}
exports.hasCloneMethod = hasCloneMethod;
function cloneIfNeeded(instance) {
    return hasCloneMethod(instance) ? instance[exports.cloneMethod]() : instance;
}
exports.cloneIfNeeded = cloneIfNeeded;


/***/ }),

/***/ "./node_modules/fast-check/lib/fast-check-default.js":
/*!***********************************************************!*\
  !*** ./node_modules/fast-check/lib/fast-check-default.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.shuffledSubarray = exports.dedup = exports.clone = exports.frequency = exports.oneof = exports.option = exports.mapToConstant = exports.clonedConstant = exports.constantFrom = exports.constant = exports.lorem = exports.base64String = exports.hexaString = exports.fullUnicodeString = exports.unicodeString = exports.stringOf = exports.string16bits = exports.asciiString = exports.string = exports.mixedCase = exports.base64 = exports.hexa = exports.fullUnicode = exports.unicode = exports.char16bits = exports.ascii = exports.char = exports.bigUint = exports.bigInt = exports.bigUintN = exports.bigIntN = exports.maxSafeNat = exports.maxSafeInteger = exports.nat = exports.integer = exports.double = exports.float = exports.falsy = exports.boolean = exports.asyncProperty = exports.property = exports.PreconditionFailure = exports.pre = exports.assert = exports.check = exports.statistics = exports.sample = exports.__commitHash = exports.__version = exports.__type = void 0;
exports.Arbitrary = exports.schedulerFor = exports.scheduler = exports.commands = exports.scheduledModelRun = exports.modelRun = exports.asyncModelRun = exports.float64Array = exports.float32Array = exports.uint32Array = exports.int32Array = exports.uint16Array = exports.int16Array = exports.uint8ClampedArray = exports.uint8Array = exports.int8Array = exports.uuidV = exports.uuid = exports.emailAddress = exports.webUrl = exports.webQueryParameters = exports.webFragments = exports.webSegment = exports.webAuthority = exports.domain = exports.ipV6 = exports.ipV4Extended = exports.ipV4 = exports.date = exports.context = exports.func = exports.compareFunc = exports.compareBooleanFunc = exports.memo = exports.letrec = exports.unicodeJsonObject = exports.unicodeJson = exports.jsonObject = exports.json = exports.object = exports.anything = exports.dictionary = exports.record = exports.genericTuple = exports.tuple = exports.set = exports.infiniteStream = exports.sparseArray = exports.array = exports.subarray = void 0;
exports.stream = exports.Stream = exports.Random = exports.ExecutionStatus = exports.resetConfigureGlobal = exports.readConfigureGlobal = exports.configureGlobal = exports.VerbosityLevel = exports.hash = exports.asyncDefaultReportMessage = exports.defaultReportMessage = exports.asyncStringify = exports.stringify = exports.hasAsyncToStringMethod = exports.asyncToStringMethod = exports.hasToStringMethod = exports.toStringMethod = exports.convertToNext = exports.convertFromNextWithShrunkOnce = exports.convertFromNext = exports.hasCloneMethod = exports.cloneIfNeeded = exports.cloneMethod = exports.NextValue = exports.Shrinkable = exports.ArbitraryWithContextualShrink = exports.ArbitraryWithShrink = exports.NextArbitrary = void 0;
const Pre_1 = __webpack_require__(/*! ./check/precondition/Pre */ "./node_modules/fast-check/lib/check/precondition/Pre.js");
Object.defineProperty(exports, "pre", ({ enumerable: true, get: function () { return Pre_1.pre; } }));
const AsyncProperty_1 = __webpack_require__(/*! ./check/property/AsyncProperty */ "./node_modules/fast-check/lib/check/property/AsyncProperty.js");
Object.defineProperty(exports, "asyncProperty", ({ enumerable: true, get: function () { return AsyncProperty_1.asyncProperty; } }));
const Property_1 = __webpack_require__(/*! ./check/property/Property */ "./node_modules/fast-check/lib/check/property/Property.js");
Object.defineProperty(exports, "property", ({ enumerable: true, get: function () { return Property_1.property; } }));
const Runner_1 = __webpack_require__(/*! ./check/runner/Runner */ "./node_modules/fast-check/lib/check/runner/Runner.js");
Object.defineProperty(exports, "assert", ({ enumerable: true, get: function () { return Runner_1.assert; } }));
Object.defineProperty(exports, "check", ({ enumerable: true, get: function () { return Runner_1.check; } }));
const Sampler_1 = __webpack_require__(/*! ./check/runner/Sampler */ "./node_modules/fast-check/lib/check/runner/Sampler.js");
Object.defineProperty(exports, "sample", ({ enumerable: true, get: function () { return Sampler_1.sample; } }));
Object.defineProperty(exports, "statistics", ({ enumerable: true, get: function () { return Sampler_1.statistics; } }));
const array_1 = __webpack_require__(/*! ./arbitrary/array */ "./node_modules/fast-check/lib/arbitrary/array.js");
Object.defineProperty(exports, "array", ({ enumerable: true, get: function () { return array_1.array; } }));
const bigInt_1 = __webpack_require__(/*! ./arbitrary/bigInt */ "./node_modules/fast-check/lib/arbitrary/bigInt.js");
Object.defineProperty(exports, "bigInt", ({ enumerable: true, get: function () { return bigInt_1.bigInt; } }));
const bigIntN_1 = __webpack_require__(/*! ./arbitrary/bigIntN */ "./node_modules/fast-check/lib/arbitrary/bigIntN.js");
Object.defineProperty(exports, "bigIntN", ({ enumerable: true, get: function () { return bigIntN_1.bigIntN; } }));
const bigUint_1 = __webpack_require__(/*! ./arbitrary/bigUint */ "./node_modules/fast-check/lib/arbitrary/bigUint.js");
Object.defineProperty(exports, "bigUint", ({ enumerable: true, get: function () { return bigUint_1.bigUint; } }));
const bigUintN_1 = __webpack_require__(/*! ./arbitrary/bigUintN */ "./node_modules/fast-check/lib/arbitrary/bigUintN.js");
Object.defineProperty(exports, "bigUintN", ({ enumerable: true, get: function () { return bigUintN_1.bigUintN; } }));
const boolean_1 = __webpack_require__(/*! ./arbitrary/boolean */ "./node_modules/fast-check/lib/arbitrary/boolean.js");
Object.defineProperty(exports, "boolean", ({ enumerable: true, get: function () { return boolean_1.boolean; } }));
const falsy_1 = __webpack_require__(/*! ./arbitrary/falsy */ "./node_modules/fast-check/lib/arbitrary/falsy.js");
Object.defineProperty(exports, "falsy", ({ enumerable: true, get: function () { return falsy_1.falsy; } }));
const ascii_1 = __webpack_require__(/*! ./arbitrary/ascii */ "./node_modules/fast-check/lib/arbitrary/ascii.js");
Object.defineProperty(exports, "ascii", ({ enumerable: true, get: function () { return ascii_1.ascii; } }));
const base64_1 = __webpack_require__(/*! ./arbitrary/base64 */ "./node_modules/fast-check/lib/arbitrary/base64.js");
Object.defineProperty(exports, "base64", ({ enumerable: true, get: function () { return base64_1.base64; } }));
const char_1 = __webpack_require__(/*! ./arbitrary/char */ "./node_modules/fast-check/lib/arbitrary/char.js");
Object.defineProperty(exports, "char", ({ enumerable: true, get: function () { return char_1.char; } }));
const char16bits_1 = __webpack_require__(/*! ./arbitrary/char16bits */ "./node_modules/fast-check/lib/arbitrary/char16bits.js");
Object.defineProperty(exports, "char16bits", ({ enumerable: true, get: function () { return char16bits_1.char16bits; } }));
const fullUnicode_1 = __webpack_require__(/*! ./arbitrary/fullUnicode */ "./node_modules/fast-check/lib/arbitrary/fullUnicode.js");
Object.defineProperty(exports, "fullUnicode", ({ enumerable: true, get: function () { return fullUnicode_1.fullUnicode; } }));
const hexa_1 = __webpack_require__(/*! ./arbitrary/hexa */ "./node_modules/fast-check/lib/arbitrary/hexa.js");
Object.defineProperty(exports, "hexa", ({ enumerable: true, get: function () { return hexa_1.hexa; } }));
const unicode_1 = __webpack_require__(/*! ./arbitrary/unicode */ "./node_modules/fast-check/lib/arbitrary/unicode.js");
Object.defineProperty(exports, "unicode", ({ enumerable: true, get: function () { return unicode_1.unicode; } }));
const clonedConstant_1 = __webpack_require__(/*! ./arbitrary/clonedConstant */ "./node_modules/fast-check/lib/arbitrary/clonedConstant.js");
Object.defineProperty(exports, "clonedConstant", ({ enumerable: true, get: function () { return clonedConstant_1.clonedConstant; } }));
const constant_1 = __webpack_require__(/*! ./arbitrary/constant */ "./node_modules/fast-check/lib/arbitrary/constant.js");
Object.defineProperty(exports, "constant", ({ enumerable: true, get: function () { return constant_1.constant; } }));
const constantFrom_1 = __webpack_require__(/*! ./arbitrary/constantFrom */ "./node_modules/fast-check/lib/arbitrary/constantFrom.js");
Object.defineProperty(exports, "constantFrom", ({ enumerable: true, get: function () { return constantFrom_1.constantFrom; } }));
const context_1 = __webpack_require__(/*! ./arbitrary/context */ "./node_modules/fast-check/lib/arbitrary/context.js");
Object.defineProperty(exports, "context", ({ enumerable: true, get: function () { return context_1.context; } }));
const date_1 = __webpack_require__(/*! ./arbitrary/date */ "./node_modules/fast-check/lib/arbitrary/date.js");
Object.defineProperty(exports, "date", ({ enumerable: true, get: function () { return date_1.date; } }));
const clone_1 = __webpack_require__(/*! ./arbitrary/clone */ "./node_modules/fast-check/lib/arbitrary/clone.js");
Object.defineProperty(exports, "clone", ({ enumerable: true, get: function () { return clone_1.clone; } }));
const dedup_1 = __webpack_require__(/*! ./arbitrary/dedup */ "./node_modules/fast-check/lib/arbitrary/dedup.js");
Object.defineProperty(exports, "dedup", ({ enumerable: true, get: function () { return dedup_1.dedup; } }));
const Arbitrary_1 = __webpack_require__(/*! ./check/arbitrary/definition/Arbitrary */ "./node_modules/fast-check/lib/check/arbitrary/definition/Arbitrary.js");
Object.defineProperty(exports, "Arbitrary", ({ enumerable: true, get: function () { return Arbitrary_1.Arbitrary; } }));
const Shrinkable_1 = __webpack_require__(/*! ./check/arbitrary/definition/Shrinkable */ "./node_modules/fast-check/lib/check/arbitrary/definition/Shrinkable.js");
Object.defineProperty(exports, "Shrinkable", ({ enumerable: true, get: function () { return Shrinkable_1.Shrinkable; } }));
const dictionary_1 = __webpack_require__(/*! ./arbitrary/dictionary */ "./node_modules/fast-check/lib/arbitrary/dictionary.js");
Object.defineProperty(exports, "dictionary", ({ enumerable: true, get: function () { return dictionary_1.dictionary; } }));
const EmailArbitrary_1 = __webpack_require__(/*! ./check/arbitrary/EmailArbitrary */ "./node_modules/fast-check/lib/check/arbitrary/EmailArbitrary.js");
Object.defineProperty(exports, "emailAddress", ({ enumerable: true, get: function () { return EmailArbitrary_1.emailAddress; } }));
const FloatingPointArbitrary_1 = __webpack_require__(/*! ./check/arbitrary/FloatingPointArbitrary */ "./node_modules/fast-check/lib/check/arbitrary/FloatingPointArbitrary.js");
Object.defineProperty(exports, "double", ({ enumerable: true, get: function () { return FloatingPointArbitrary_1.double; } }));
Object.defineProperty(exports, "float", ({ enumerable: true, get: function () { return FloatingPointArbitrary_1.float; } }));
const frequency_1 = __webpack_require__(/*! ./arbitrary/frequency */ "./node_modules/fast-check/lib/arbitrary/frequency.js");
Object.defineProperty(exports, "frequency", ({ enumerable: true, get: function () { return frequency_1.frequency; } }));
const compareBooleanFunc_1 = __webpack_require__(/*! ./arbitrary/compareBooleanFunc */ "./node_modules/fast-check/lib/arbitrary/compareBooleanFunc.js");
Object.defineProperty(exports, "compareBooleanFunc", ({ enumerable: true, get: function () { return compareBooleanFunc_1.compareBooleanFunc; } }));
const compareFunc_1 = __webpack_require__(/*! ./arbitrary/compareFunc */ "./node_modules/fast-check/lib/arbitrary/compareFunc.js");
Object.defineProperty(exports, "compareFunc", ({ enumerable: true, get: function () { return compareFunc_1.compareFunc; } }));
const func_1 = __webpack_require__(/*! ./arbitrary/func */ "./node_modules/fast-check/lib/arbitrary/func.js");
Object.defineProperty(exports, "func", ({ enumerable: true, get: function () { return func_1.func; } }));
const HostArbitrary_1 = __webpack_require__(/*! ./check/arbitrary/HostArbitrary */ "./node_modules/fast-check/lib/check/arbitrary/HostArbitrary.js");
Object.defineProperty(exports, "domain", ({ enumerable: true, get: function () { return HostArbitrary_1.domain; } }));
const integer_1 = __webpack_require__(/*! ./arbitrary/integer */ "./node_modules/fast-check/lib/arbitrary/integer.js");
Object.defineProperty(exports, "integer", ({ enumerable: true, get: function () { return integer_1.integer; } }));
const maxSafeInteger_1 = __webpack_require__(/*! ./arbitrary/maxSafeInteger */ "./node_modules/fast-check/lib/arbitrary/maxSafeInteger.js");
Object.defineProperty(exports, "maxSafeInteger", ({ enumerable: true, get: function () { return maxSafeInteger_1.maxSafeInteger; } }));
const maxSafeNat_1 = __webpack_require__(/*! ./arbitrary/maxSafeNat */ "./node_modules/fast-check/lib/arbitrary/maxSafeNat.js");
Object.defineProperty(exports, "maxSafeNat", ({ enumerable: true, get: function () { return maxSafeNat_1.maxSafeNat; } }));
const nat_1 = __webpack_require__(/*! ./arbitrary/nat */ "./node_modules/fast-check/lib/arbitrary/nat.js");
Object.defineProperty(exports, "nat", ({ enumerable: true, get: function () { return nat_1.nat; } }));
const ipV4_1 = __webpack_require__(/*! ./arbitrary/ipV4 */ "./node_modules/fast-check/lib/arbitrary/ipV4.js");
Object.defineProperty(exports, "ipV4", ({ enumerable: true, get: function () { return ipV4_1.ipV4; } }));
const ipV4Extended_1 = __webpack_require__(/*! ./arbitrary/ipV4Extended */ "./node_modules/fast-check/lib/arbitrary/ipV4Extended.js");
Object.defineProperty(exports, "ipV4Extended", ({ enumerable: true, get: function () { return ipV4Extended_1.ipV4Extended; } }));
const ipV6_1 = __webpack_require__(/*! ./arbitrary/ipV6 */ "./node_modules/fast-check/lib/arbitrary/ipV6.js");
Object.defineProperty(exports, "ipV6", ({ enumerable: true, get: function () { return ipV6_1.ipV6; } }));
const letrec_1 = __webpack_require__(/*! ./arbitrary/letrec */ "./node_modules/fast-check/lib/arbitrary/letrec.js");
Object.defineProperty(exports, "letrec", ({ enumerable: true, get: function () { return letrec_1.letrec; } }));
const lorem_1 = __webpack_require__(/*! ./arbitrary/lorem */ "./node_modules/fast-check/lib/arbitrary/lorem.js");
Object.defineProperty(exports, "lorem", ({ enumerable: true, get: function () { return lorem_1.lorem; } }));
const mapToConstant_1 = __webpack_require__(/*! ./arbitrary/mapToConstant */ "./node_modules/fast-check/lib/arbitrary/mapToConstant.js");
Object.defineProperty(exports, "mapToConstant", ({ enumerable: true, get: function () { return mapToConstant_1.mapToConstant; } }));
const memo_1 = __webpack_require__(/*! ./arbitrary/memo */ "./node_modules/fast-check/lib/arbitrary/memo.js");
Object.defineProperty(exports, "memo", ({ enumerable: true, get: function () { return memo_1.memo; } }));
const mixedCase_1 = __webpack_require__(/*! ./arbitrary/mixedCase */ "./node_modules/fast-check/lib/arbitrary/mixedCase.js");
Object.defineProperty(exports, "mixedCase", ({ enumerable: true, get: function () { return mixedCase_1.mixedCase; } }));
const ObjectArbitrary_1 = __webpack_require__(/*! ./check/arbitrary/ObjectArbitrary */ "./node_modules/fast-check/lib/check/arbitrary/ObjectArbitrary.js");
Object.defineProperty(exports, "anything", ({ enumerable: true, get: function () { return ObjectArbitrary_1.anything; } }));
Object.defineProperty(exports, "json", ({ enumerable: true, get: function () { return ObjectArbitrary_1.json; } }));
Object.defineProperty(exports, "jsonObject", ({ enumerable: true, get: function () { return ObjectArbitrary_1.jsonObject; } }));
Object.defineProperty(exports, "object", ({ enumerable: true, get: function () { return ObjectArbitrary_1.object; } }));
Object.defineProperty(exports, "unicodeJson", ({ enumerable: true, get: function () { return ObjectArbitrary_1.unicodeJson; } }));
Object.defineProperty(exports, "unicodeJsonObject", ({ enumerable: true, get: function () { return ObjectArbitrary_1.unicodeJsonObject; } }));
const oneof_1 = __webpack_require__(/*! ./arbitrary/oneof */ "./node_modules/fast-check/lib/arbitrary/oneof.js");
Object.defineProperty(exports, "oneof", ({ enumerable: true, get: function () { return oneof_1.oneof; } }));
const option_1 = __webpack_require__(/*! ./arbitrary/option */ "./node_modules/fast-check/lib/arbitrary/option.js");
Object.defineProperty(exports, "option", ({ enumerable: true, get: function () { return option_1.option; } }));
const record_1 = __webpack_require__(/*! ./arbitrary/record */ "./node_modules/fast-check/lib/arbitrary/record.js");
Object.defineProperty(exports, "record", ({ enumerable: true, get: function () { return record_1.record; } }));
const set_1 = __webpack_require__(/*! ./arbitrary/set */ "./node_modules/fast-check/lib/arbitrary/set.js");
Object.defineProperty(exports, "set", ({ enumerable: true, get: function () { return set_1.set; } }));
const infiniteStream_1 = __webpack_require__(/*! ./arbitrary/infiniteStream */ "./node_modules/fast-check/lib/arbitrary/infiniteStream.js");
Object.defineProperty(exports, "infiniteStream", ({ enumerable: true, get: function () { return infiniteStream_1.infiniteStream; } }));
const asciiString_1 = __webpack_require__(/*! ./arbitrary/asciiString */ "./node_modules/fast-check/lib/arbitrary/asciiString.js");
Object.defineProperty(exports, "asciiString", ({ enumerable: true, get: function () { return asciiString_1.asciiString; } }));
const base64String_1 = __webpack_require__(/*! ./arbitrary/base64String */ "./node_modules/fast-check/lib/arbitrary/base64String.js");
Object.defineProperty(exports, "base64String", ({ enumerable: true, get: function () { return base64String_1.base64String; } }));
const fullUnicodeString_1 = __webpack_require__(/*! ./arbitrary/fullUnicodeString */ "./node_modules/fast-check/lib/arbitrary/fullUnicodeString.js");
Object.defineProperty(exports, "fullUnicodeString", ({ enumerable: true, get: function () { return fullUnicodeString_1.fullUnicodeString; } }));
const hexaString_1 = __webpack_require__(/*! ./arbitrary/hexaString */ "./node_modules/fast-check/lib/arbitrary/hexaString.js");
Object.defineProperty(exports, "hexaString", ({ enumerable: true, get: function () { return hexaString_1.hexaString; } }));
const string_1 = __webpack_require__(/*! ./arbitrary/string */ "./node_modules/fast-check/lib/arbitrary/string.js");
Object.defineProperty(exports, "string", ({ enumerable: true, get: function () { return string_1.string; } }));
const string16bits_1 = __webpack_require__(/*! ./arbitrary/string16bits */ "./node_modules/fast-check/lib/arbitrary/string16bits.js");
Object.defineProperty(exports, "string16bits", ({ enumerable: true, get: function () { return string16bits_1.string16bits; } }));
const stringOf_1 = __webpack_require__(/*! ./arbitrary/stringOf */ "./node_modules/fast-check/lib/arbitrary/stringOf.js");
Object.defineProperty(exports, "stringOf", ({ enumerable: true, get: function () { return stringOf_1.stringOf; } }));
const unicodeString_1 = __webpack_require__(/*! ./arbitrary/unicodeString */ "./node_modules/fast-check/lib/arbitrary/unicodeString.js");
Object.defineProperty(exports, "unicodeString", ({ enumerable: true, get: function () { return unicodeString_1.unicodeString; } }));
const SubarrayArbitrary_1 = __webpack_require__(/*! ./check/arbitrary/SubarrayArbitrary */ "./node_modules/fast-check/lib/check/arbitrary/SubarrayArbitrary.js");
Object.defineProperty(exports, "shuffledSubarray", ({ enumerable: true, get: function () { return SubarrayArbitrary_1.shuffledSubarray; } }));
Object.defineProperty(exports, "subarray", ({ enumerable: true, get: function () { return SubarrayArbitrary_1.subarray; } }));
const genericTuple_1 = __webpack_require__(/*! ./arbitrary/genericTuple */ "./node_modules/fast-check/lib/arbitrary/genericTuple.js");
Object.defineProperty(exports, "genericTuple", ({ enumerable: true, get: function () { return genericTuple_1.genericTuple; } }));
const tuple_1 = __webpack_require__(/*! ./arbitrary/tuple */ "./node_modules/fast-check/lib/arbitrary/tuple.js");
Object.defineProperty(exports, "tuple", ({ enumerable: true, get: function () { return tuple_1.tuple; } }));
const UuidArbitrary_1 = __webpack_require__(/*! ./check/arbitrary/UuidArbitrary */ "./node_modules/fast-check/lib/check/arbitrary/UuidArbitrary.js");
Object.defineProperty(exports, "uuid", ({ enumerable: true, get: function () { return UuidArbitrary_1.uuid; } }));
Object.defineProperty(exports, "uuidV", ({ enumerable: true, get: function () { return UuidArbitrary_1.uuidV; } }));
const WebArbitrary_1 = __webpack_require__(/*! ./check/arbitrary/WebArbitrary */ "./node_modules/fast-check/lib/check/arbitrary/WebArbitrary.js");
Object.defineProperty(exports, "webAuthority", ({ enumerable: true, get: function () { return WebArbitrary_1.webAuthority; } }));
Object.defineProperty(exports, "webFragments", ({ enumerable: true, get: function () { return WebArbitrary_1.webFragments; } }));
Object.defineProperty(exports, "webQueryParameters", ({ enumerable: true, get: function () { return WebArbitrary_1.webQueryParameters; } }));
Object.defineProperty(exports, "webSegment", ({ enumerable: true, get: function () { return WebArbitrary_1.webSegment; } }));
Object.defineProperty(exports, "webUrl", ({ enumerable: true, get: function () { return WebArbitrary_1.webUrl; } }));
const CommandsArbitrary_1 = __webpack_require__(/*! ./check/model/commands/CommandsArbitrary */ "./node_modules/fast-check/lib/check/model/commands/CommandsArbitrary.js");
Object.defineProperty(exports, "commands", ({ enumerable: true, get: function () { return CommandsArbitrary_1.commands; } }));
const ModelRunner_1 = __webpack_require__(/*! ./check/model/ModelRunner */ "./node_modules/fast-check/lib/check/model/ModelRunner.js");
Object.defineProperty(exports, "asyncModelRun", ({ enumerable: true, get: function () { return ModelRunner_1.asyncModelRun; } }));
Object.defineProperty(exports, "modelRun", ({ enumerable: true, get: function () { return ModelRunner_1.modelRun; } }));
Object.defineProperty(exports, "scheduledModelRun", ({ enumerable: true, get: function () { return ModelRunner_1.scheduledModelRun; } }));
const Random_1 = __webpack_require__(/*! ./random/generator/Random */ "./node_modules/fast-check/lib/random/generator/Random.js");
Object.defineProperty(exports, "Random", ({ enumerable: true, get: function () { return Random_1.Random; } }));
const GlobalParameters_1 = __webpack_require__(/*! ./check/runner/configuration/GlobalParameters */ "./node_modules/fast-check/lib/check/runner/configuration/GlobalParameters.js");
Object.defineProperty(exports, "configureGlobal", ({ enumerable: true, get: function () { return GlobalParameters_1.configureGlobal; } }));
Object.defineProperty(exports, "readConfigureGlobal", ({ enumerable: true, get: function () { return GlobalParameters_1.readConfigureGlobal; } }));
Object.defineProperty(exports, "resetConfigureGlobal", ({ enumerable: true, get: function () { return GlobalParameters_1.resetConfigureGlobal; } }));
const VerbosityLevel_1 = __webpack_require__(/*! ./check/runner/configuration/VerbosityLevel */ "./node_modules/fast-check/lib/check/runner/configuration/VerbosityLevel.js");
Object.defineProperty(exports, "VerbosityLevel", ({ enumerable: true, get: function () { return VerbosityLevel_1.VerbosityLevel; } }));
const ExecutionStatus_1 = __webpack_require__(/*! ./check/runner/reporter/ExecutionStatus */ "./node_modules/fast-check/lib/check/runner/reporter/ExecutionStatus.js");
Object.defineProperty(exports, "ExecutionStatus", ({ enumerable: true, get: function () { return ExecutionStatus_1.ExecutionStatus; } }));
const symbols_1 = __webpack_require__(/*! ./check/symbols */ "./node_modules/fast-check/lib/check/symbols.js");
Object.defineProperty(exports, "cloneMethod", ({ enumerable: true, get: function () { return symbols_1.cloneMethod; } }));
Object.defineProperty(exports, "cloneIfNeeded", ({ enumerable: true, get: function () { return symbols_1.cloneIfNeeded; } }));
Object.defineProperty(exports, "hasCloneMethod", ({ enumerable: true, get: function () { return symbols_1.hasCloneMethod; } }));
const Stream_1 = __webpack_require__(/*! ./stream/Stream */ "./node_modules/fast-check/lib/stream/Stream.js");
Object.defineProperty(exports, "Stream", ({ enumerable: true, get: function () { return Stream_1.Stream; } }));
Object.defineProperty(exports, "stream", ({ enumerable: true, get: function () { return Stream_1.stream; } }));
const hash_1 = __webpack_require__(/*! ./utils/hash */ "./node_modules/fast-check/lib/utils/hash.js");
Object.defineProperty(exports, "hash", ({ enumerable: true, get: function () { return hash_1.hash; } }));
const stringify_1 = __webpack_require__(/*! ./utils/stringify */ "./node_modules/fast-check/lib/utils/stringify.js");
Object.defineProperty(exports, "stringify", ({ enumerable: true, get: function () { return stringify_1.stringify; } }));
Object.defineProperty(exports, "asyncStringify", ({ enumerable: true, get: function () { return stringify_1.asyncStringify; } }));
Object.defineProperty(exports, "toStringMethod", ({ enumerable: true, get: function () { return stringify_1.toStringMethod; } }));
Object.defineProperty(exports, "hasToStringMethod", ({ enumerable: true, get: function () { return stringify_1.hasToStringMethod; } }));
Object.defineProperty(exports, "asyncToStringMethod", ({ enumerable: true, get: function () { return stringify_1.asyncToStringMethod; } }));
Object.defineProperty(exports, "hasAsyncToStringMethod", ({ enumerable: true, get: function () { return stringify_1.hasAsyncToStringMethod; } }));
const scheduler_1 = __webpack_require__(/*! ./arbitrary/scheduler */ "./node_modules/fast-check/lib/arbitrary/scheduler.js");
Object.defineProperty(exports, "scheduler", ({ enumerable: true, get: function () { return scheduler_1.scheduler; } }));
Object.defineProperty(exports, "schedulerFor", ({ enumerable: true, get: function () { return scheduler_1.schedulerFor; } }));
const RunDetailsFormatter_1 = __webpack_require__(/*! ./check/runner/utils/RunDetailsFormatter */ "./node_modules/fast-check/lib/check/runner/utils/RunDetailsFormatter.js");
Object.defineProperty(exports, "defaultReportMessage", ({ enumerable: true, get: function () { return RunDetailsFormatter_1.defaultReportMessage; } }));
Object.defineProperty(exports, "asyncDefaultReportMessage", ({ enumerable: true, get: function () { return RunDetailsFormatter_1.asyncDefaultReportMessage; } }));
const ArbitraryWithShrink_1 = __webpack_require__(/*! ./check/arbitrary/definition/ArbitraryWithShrink */ "./node_modules/fast-check/lib/check/arbitrary/definition/ArbitraryWithShrink.js");
Object.defineProperty(exports, "ArbitraryWithShrink", ({ enumerable: true, get: function () { return ArbitraryWithShrink_1.ArbitraryWithShrink; } }));
const ArbitraryWithContextualShrink_1 = __webpack_require__(/*! ./check/arbitrary/definition/ArbitraryWithContextualShrink */ "./node_modules/fast-check/lib/check/arbitrary/definition/ArbitraryWithContextualShrink.js");
Object.defineProperty(exports, "ArbitraryWithContextualShrink", ({ enumerable: true, get: function () { return ArbitraryWithContextualShrink_1.ArbitraryWithContextualShrink; } }));
const PreconditionFailure_1 = __webpack_require__(/*! ./check/precondition/PreconditionFailure */ "./node_modules/fast-check/lib/check/precondition/PreconditionFailure.js");
Object.defineProperty(exports, "PreconditionFailure", ({ enumerable: true, get: function () { return PreconditionFailure_1.PreconditionFailure; } }));
const int8Array_1 = __webpack_require__(/*! ./arbitrary/int8Array */ "./node_modules/fast-check/lib/arbitrary/int8Array.js");
Object.defineProperty(exports, "int8Array", ({ enumerable: true, get: function () { return int8Array_1.int8Array; } }));
const int16Array_1 = __webpack_require__(/*! ./arbitrary/int16Array */ "./node_modules/fast-check/lib/arbitrary/int16Array.js");
Object.defineProperty(exports, "int16Array", ({ enumerable: true, get: function () { return int16Array_1.int16Array; } }));
const int32Array_1 = __webpack_require__(/*! ./arbitrary/int32Array */ "./node_modules/fast-check/lib/arbitrary/int32Array.js");
Object.defineProperty(exports, "int32Array", ({ enumerable: true, get: function () { return int32Array_1.int32Array; } }));
const uint8Array_1 = __webpack_require__(/*! ./arbitrary/uint8Array */ "./node_modules/fast-check/lib/arbitrary/uint8Array.js");
Object.defineProperty(exports, "uint8Array", ({ enumerable: true, get: function () { return uint8Array_1.uint8Array; } }));
const uint8ClampedArray_1 = __webpack_require__(/*! ./arbitrary/uint8ClampedArray */ "./node_modules/fast-check/lib/arbitrary/uint8ClampedArray.js");
Object.defineProperty(exports, "uint8ClampedArray", ({ enumerable: true, get: function () { return uint8ClampedArray_1.uint8ClampedArray; } }));
const uint16Array_1 = __webpack_require__(/*! ./arbitrary/uint16Array */ "./node_modules/fast-check/lib/arbitrary/uint16Array.js");
Object.defineProperty(exports, "uint16Array", ({ enumerable: true, get: function () { return uint16Array_1.uint16Array; } }));
const uint32Array_1 = __webpack_require__(/*! ./arbitrary/uint32Array */ "./node_modules/fast-check/lib/arbitrary/uint32Array.js");
Object.defineProperty(exports, "uint32Array", ({ enumerable: true, get: function () { return uint32Array_1.uint32Array; } }));
const float32Array_1 = __webpack_require__(/*! ./arbitrary/float32Array */ "./node_modules/fast-check/lib/arbitrary/float32Array.js");
Object.defineProperty(exports, "float32Array", ({ enumerable: true, get: function () { return float32Array_1.float32Array; } }));
const float64Array_1 = __webpack_require__(/*! ./arbitrary/float64Array */ "./node_modules/fast-check/lib/arbitrary/float64Array.js");
Object.defineProperty(exports, "float64Array", ({ enumerable: true, get: function () { return float64Array_1.float64Array; } }));
const SparseArrayArbitrary_1 = __webpack_require__(/*! ./check/arbitrary/SparseArrayArbitrary */ "./node_modules/fast-check/lib/check/arbitrary/SparseArrayArbitrary.js");
Object.defineProperty(exports, "sparseArray", ({ enumerable: true, get: function () { return SparseArrayArbitrary_1.sparseArray; } }));
const NextArbitrary_1 = __webpack_require__(/*! ./check/arbitrary/definition/NextArbitrary */ "./node_modules/fast-check/lib/check/arbitrary/definition/NextArbitrary.js");
Object.defineProperty(exports, "NextArbitrary", ({ enumerable: true, get: function () { return NextArbitrary_1.NextArbitrary; } }));
const NextValue_1 = __webpack_require__(/*! ./check/arbitrary/definition/NextValue */ "./node_modules/fast-check/lib/check/arbitrary/definition/NextValue.js");
Object.defineProperty(exports, "NextValue", ({ enumerable: true, get: function () { return NextValue_1.NextValue; } }));
const Converters_1 = __webpack_require__(/*! ./check/arbitrary/definition/Converters */ "./node_modules/fast-check/lib/check/arbitrary/definition/Converters.js");
Object.defineProperty(exports, "convertFromNext", ({ enumerable: true, get: function () { return Converters_1.convertFromNext; } }));
Object.defineProperty(exports, "convertFromNextWithShrunkOnce", ({ enumerable: true, get: function () { return Converters_1.convertFromNextWithShrunkOnce; } }));
Object.defineProperty(exports, "convertToNext", ({ enumerable: true, get: function () { return Converters_1.convertToNext; } }));
const __type = 'commonjs';
exports.__type = __type;
const __version = '2.17.0';
exports.__version = __version;
const __commitHash = 'b7064a21412eb9e68edb3aece74d45522c80bc77';
exports.__commitHash = __commitHash;


/***/ }),

/***/ "./node_modules/fast-check/lib/fast-check.js":
/*!***************************************************!*\
  !*** ./node_modules/fast-check/lib/fast-check.js ***!
  \***************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const fc = __webpack_require__(/*! ./fast-check-default */ "./node_modules/fast-check/lib/fast-check-default.js");
exports.default = fc;
__exportStar(__webpack_require__(/*! ./fast-check-default */ "./node_modules/fast-check/lib/fast-check-default.js"), exports);


/***/ }),

/***/ "./node_modules/fast-check/lib/random/generator/PureRandom.js":
/*!********************************************************************!*\
  !*** ./node_modules/fast-check/lib/random/generator/PureRandom.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.convertToRandomGenerator = void 0;
class ConvertedRandomGenerator {
    constructor(rng) {
        this.rng = rng;
        if (typeof this.rng.jump === 'function') {
            this.jump = function jump() {
                const out = this.jump();
                return new ConvertedRandomGenerator(out);
            };
            this.unsafeJump = function unsafeJump() {
                const out = this.jump();
                this.rng = out;
            };
        }
    }
    min() {
        return this.rng.min();
    }
    max() {
        return this.rng.max();
    }
    clone() {
        return new ConvertedRandomGenerator(this.rng);
    }
    next() {
        const out = this.rng.next();
        return [out[0], new ConvertedRandomGenerator(out[1])];
    }
    unsafeNext() {
        const out = this.rng.next();
        this.rng = out[1];
        return out[0];
    }
}
function convertToRandomGenerator(rng) {
    if ('clone' in rng && 'unsafeNext' in rng) {
        return rng;
    }
    return new ConvertedRandomGenerator(rng);
}
exports.convertToRandomGenerator = convertToRandomGenerator;


/***/ }),

/***/ "./node_modules/fast-check/lib/random/generator/Random.js":
/*!****************************************************************!*\
  !*** ./node_modules/fast-check/lib/random/generator/Random.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Random = void 0;
const pure_rand_1 = __webpack_require__(/*! pure-rand */ "./node_modules/pure-rand/lib/pure-rand.js");
const PureRandom_1 = __webpack_require__(/*! ./PureRandom */ "./node_modules/fast-check/lib/random/generator/PureRandom.js");
class Random {
    constructor(sourceRng) {
        this.internalRng = PureRandom_1.convertToRandomGenerator(sourceRng).clone();
    }
    clone() {
        return new Random(this.internalRng);
    }
    next(bits) {
        return pure_rand_1.unsafeUniformIntDistribution(0, (1 << bits) - 1, this.internalRng);
    }
    nextBoolean() {
        return pure_rand_1.unsafeUniformIntDistribution(0, 1, this.internalRng) == 1;
    }
    nextInt(min, max) {
        return pure_rand_1.unsafeUniformIntDistribution(min == null ? Random.MIN_INT : min, max == null ? Random.MAX_INT : max, this.internalRng);
    }
    nextBigInt(min, max) {
        return pure_rand_1.unsafeUniformBigIntDistribution(min, max, this.internalRng);
    }
    nextArrayInt(min, max) {
        return pure_rand_1.unsafeUniformArrayIntDistribution(min, max, this.internalRng);
    }
    nextDouble() {
        const a = this.next(26);
        const b = this.next(27);
        return (a * Random.DBL_FACTOR + b) * Random.DBL_DIVISOR;
    }
}
exports.Random = Random;
Random.MIN_INT = 0x80000000 | 0;
Random.MAX_INT = 0x7fffffff | 0;
Random.DBL_FACTOR = Math.pow(2, 27);
Random.DBL_DIVISOR = Math.pow(2, -53);


/***/ }),

/***/ "./node_modules/fast-check/lib/stream/LazyIterableIterator.js":
/*!********************************************************************!*\
  !*** ./node_modules/fast-check/lib/stream/LazyIterableIterator.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.makeLazy = void 0;
class LazyIterableIterator {
    constructor(producer) {
        this.producer = producer;
    }
    [Symbol.iterator]() {
        if (this.it === undefined) {
            this.it = this.producer();
        }
        return this.it;
    }
    next() {
        if (this.it === undefined) {
            this.it = this.producer();
        }
        return this.it.next();
    }
}
function makeLazy(producer) {
    return new LazyIterableIterator(producer);
}
exports.makeLazy = makeLazy;


/***/ }),

/***/ "./node_modules/fast-check/lib/stream/Stream.js":
/*!******************************************************!*\
  !*** ./node_modules/fast-check/lib/stream/Stream.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.stream = exports.Stream = void 0;
const StreamHelpers_1 = __webpack_require__(/*! ./StreamHelpers */ "./node_modules/fast-check/lib/stream/StreamHelpers.js");
class Stream {
    constructor(g) {
        this.g = g;
    }
    static nil() {
        return new Stream(StreamHelpers_1.nilHelper());
    }
    static of(...elements) {
        return new Stream(elements[Symbol.iterator]());
    }
    next() {
        return this.g.next();
    }
    [Symbol.iterator]() {
        return this.g;
    }
    map(f) {
        return new Stream(StreamHelpers_1.mapHelper(this.g, f));
    }
    flatMap(f) {
        return new Stream(StreamHelpers_1.flatMapHelper(this.g, f));
    }
    dropWhile(f) {
        let foundEligible = false;
        function* helper(v) {
            if (foundEligible || !f(v)) {
                foundEligible = true;
                yield v;
            }
        }
        return this.flatMap(helper);
    }
    drop(n) {
        let idx = 0;
        function helper() {
            return idx++ < n;
        }
        return this.dropWhile(helper);
    }
    takeWhile(f) {
        return new Stream(StreamHelpers_1.takeWhileHelper(this.g, f));
    }
    take(n) {
        return new Stream(StreamHelpers_1.takeNHelper(this.g, n));
    }
    filter(f) {
        return new Stream(StreamHelpers_1.filterHelper(this.g, f));
    }
    every(f) {
        for (const v of this.g) {
            if (!f(v)) {
                return false;
            }
        }
        return true;
    }
    has(f) {
        for (const v of this.g) {
            if (f(v)) {
                return [true, v];
            }
        }
        return [false, null];
    }
    join(...others) {
        return new Stream(StreamHelpers_1.joinHelper(this.g, others));
    }
    getNthOrLast(nth) {
        let remaining = nth;
        let last = null;
        for (const v of this.g) {
            if (remaining-- === 0)
                return v;
            last = v;
        }
        return last;
    }
}
exports.Stream = Stream;
function stream(g) {
    return new Stream(g);
}
exports.stream = stream;


/***/ }),

/***/ "./node_modules/fast-check/lib/stream/StreamHelpers.js":
/*!*************************************************************!*\
  !*** ./node_modules/fast-check/lib/stream/StreamHelpers.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.joinHelper = exports.takeWhileHelper = exports.takeNHelper = exports.filterHelper = exports.flatMapHelper = exports.mapHelper = exports.nilHelper = void 0;
class Nil {
    [Symbol.iterator]() {
        return this;
    }
    next(value) {
        return { value, done: true };
    }
}
Nil.nil = new Nil();
function nilHelper() {
    return Nil.nil;
}
exports.nilHelper = nilHelper;
function* mapHelper(g, f) {
    for (const v of g) {
        yield f(v);
    }
}
exports.mapHelper = mapHelper;
function* flatMapHelper(g, f) {
    for (const v of g) {
        yield* f(v);
    }
}
exports.flatMapHelper = flatMapHelper;
function* filterHelper(g, f) {
    for (const v of g) {
        if (f(v)) {
            yield v;
        }
    }
}
exports.filterHelper = filterHelper;
function* takeNHelper(g, n) {
    for (let i = 0; i < n; ++i) {
        const cur = g.next();
        if (cur.done) {
            break;
        }
        yield cur.value;
    }
}
exports.takeNHelper = takeNHelper;
function* takeWhileHelper(g, f) {
    let cur = g.next();
    while (!cur.done && f(cur.value)) {
        yield cur.value;
        cur = g.next();
    }
}
exports.takeWhileHelper = takeWhileHelper;
function* joinHelper(g, others) {
    for (let cur = g.next(); !cur.done; cur = g.next()) {
        yield cur.value;
    }
    for (const s of others) {
        for (let cur = s.next(); !cur.done; cur = s.next()) {
            yield cur.value;
        }
    }
}
exports.joinHelper = joinHelper;


/***/ }),

/***/ "./node_modules/fast-check/lib/utils/hash.js":
/*!***************************************************!*\
  !*** ./node_modules/fast-check/lib/utils/hash.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.hash = void 0;
const crc32Table = [
    0x00000000, 0x77073096, 0xee0e612c, 0x990951ba, 0x076dc419, 0x706af48f, 0xe963a535, 0x9e6495a3, 0x0edb8832,
    0x79dcb8a4, 0xe0d5e91e, 0x97d2d988, 0x09b64c2b, 0x7eb17cbd, 0xe7b82d07, 0x90bf1d91, 0x1db71064, 0x6ab020f2,
    0xf3b97148, 0x84be41de, 0x1adad47d, 0x6ddde4eb, 0xf4d4b551, 0x83d385c7, 0x136c9856, 0x646ba8c0, 0xfd62f97a,
    0x8a65c9ec, 0x14015c4f, 0x63066cd9, 0xfa0f3d63, 0x8d080df5, 0x3b6e20c8, 0x4c69105e, 0xd56041e4, 0xa2677172,
    0x3c03e4d1, 0x4b04d447, 0xd20d85fd, 0xa50ab56b, 0x35b5a8fa, 0x42b2986c, 0xdbbbc9d6, 0xacbcf940, 0x32d86ce3,
    0x45df5c75, 0xdcd60dcf, 0xabd13d59, 0x26d930ac, 0x51de003a, 0xc8d75180, 0xbfd06116, 0x21b4f4b5, 0x56b3c423,
    0xcfba9599, 0xb8bda50f, 0x2802b89e, 0x5f058808, 0xc60cd9b2, 0xb10be924, 0x2f6f7c87, 0x58684c11, 0xc1611dab,
    0xb6662d3d, 0x76dc4190, 0x01db7106, 0x98d220bc, 0xefd5102a, 0x71b18589, 0x06b6b51f, 0x9fbfe4a5, 0xe8b8d433,
    0x7807c9a2, 0x0f00f934, 0x9609a88e, 0xe10e9818, 0x7f6a0dbb, 0x086d3d2d, 0x91646c97, 0xe6635c01, 0x6b6b51f4,
    0x1c6c6162, 0x856530d8, 0xf262004e, 0x6c0695ed, 0x1b01a57b, 0x8208f4c1, 0xf50fc457, 0x65b0d9c6, 0x12b7e950,
    0x8bbeb8ea, 0xfcb9887c, 0x62dd1ddf, 0x15da2d49, 0x8cd37cf3, 0xfbd44c65, 0x4db26158, 0x3ab551ce, 0xa3bc0074,
    0xd4bb30e2, 0x4adfa541, 0x3dd895d7, 0xa4d1c46d, 0xd3d6f4fb, 0x4369e96a, 0x346ed9fc, 0xad678846, 0xda60b8d0,
    0x44042d73, 0x33031de5, 0xaa0a4c5f, 0xdd0d7cc9, 0x5005713c, 0x270241aa, 0xbe0b1010, 0xc90c2086, 0x5768b525,
    0x206f85b3, 0xb966d409, 0xce61e49f, 0x5edef90e, 0x29d9c998, 0xb0d09822, 0xc7d7a8b4, 0x59b33d17, 0x2eb40d81,
    0xb7bd5c3b, 0xc0ba6cad, 0xedb88320, 0x9abfb3b6, 0x03b6e20c, 0x74b1d29a, 0xead54739, 0x9dd277af, 0x04db2615,
    0x73dc1683, 0xe3630b12, 0x94643b84, 0x0d6d6a3e, 0x7a6a5aa8, 0xe40ecf0b, 0x9309ff9d, 0x0a00ae27, 0x7d079eb1,
    0xf00f9344, 0x8708a3d2, 0x1e01f268, 0x6906c2fe, 0xf762575d, 0x806567cb, 0x196c3671, 0x6e6b06e7, 0xfed41b76,
    0x89d32be0, 0x10da7a5a, 0x67dd4acc, 0xf9b9df6f, 0x8ebeeff9, 0x17b7be43, 0x60b08ed5, 0xd6d6a3e8, 0xa1d1937e,
    0x38d8c2c4, 0x4fdff252, 0xd1bb67f1, 0xa6bc5767, 0x3fb506dd, 0x48b2364b, 0xd80d2bda, 0xaf0a1b4c, 0x36034af6,
    0x41047a60, 0xdf60efc3, 0xa867df55, 0x316e8eef, 0x4669be79, 0xcb61b38c, 0xbc66831a, 0x256fd2a0, 0x5268e236,
    0xcc0c7795, 0xbb0b4703, 0x220216b9, 0x5505262f, 0xc5ba3bbe, 0xb2bd0b28, 0x2bb45a92, 0x5cb36a04, 0xc2d7ffa7,
    0xb5d0cf31, 0x2cd99e8b, 0x5bdeae1d, 0x9b64c2b0, 0xec63f226, 0x756aa39c, 0x026d930a, 0x9c0906a9, 0xeb0e363f,
    0x72076785, 0x05005713, 0x95bf4a82, 0xe2b87a14, 0x7bb12bae, 0x0cb61b38, 0x92d28e9b, 0xe5d5be0d, 0x7cdcefb7,
    0x0bdbdf21, 0x86d3d2d4, 0xf1d4e242, 0x68ddb3f8, 0x1fda836e, 0x81be16cd, 0xf6b9265b, 0x6fb077e1, 0x18b74777,
    0x88085ae6, 0xff0f6a70, 0x66063bca, 0x11010b5c, 0x8f659eff, 0xf862ae69, 0x616bffd3, 0x166ccf45, 0xa00ae278,
    0xd70dd2ee, 0x4e048354, 0x3903b3c2, 0xa7672661, 0xd06016f7, 0x4969474d, 0x3e6e77db, 0xaed16a4a, 0xd9d65adc,
    0x40df0b66, 0x37d83bf0, 0xa9bcae53, 0xdebb9ec5, 0x47b2cf7f, 0x30b5ffe9, 0xbdbdf21c, 0xcabac28a, 0x53b39330,
    0x24b4a3a6, 0xbad03605, 0xcdd70693, 0x54de5729, 0x23d967bf, 0xb3667a2e, 0xc4614ab8, 0x5d681b02, 0x2a6f2b94,
    0xb40bbe37, 0xc30c8ea1, 0x5a05df1b, 0x2d02ef8d,
];
function hash(repr) {
    let crc = 0xffffffff;
    for (let idx = 0; idx < repr.length; ++idx) {
        const c = repr.charCodeAt(idx);
        if (c < 0x80) {
            crc = crc32Table[(crc & 0xff) ^ c] ^ (crc >> 8);
        }
        else if (c < 0x800) {
            crc = crc32Table[(crc & 0xff) ^ (192 | ((c >> 6) & 31))] ^ (crc >> 8);
            crc = crc32Table[(crc & 0xff) ^ (128 | (c & 63))] ^ (crc >> 8);
        }
        else if (c >= 0xd800 && c < 0xe000) {
            const cNext = repr.charCodeAt(++idx);
            if (c >= 0xdc00 || cNext < 0xdc00 || cNext > 0xdfff || Number.isNaN(cNext)) {
                idx -= 1;
                crc = crc32Table[(crc & 0xff) ^ 0xef] ^ (crc >> 8);
                crc = crc32Table[(crc & 0xff) ^ 0xbf] ^ (crc >> 8);
                crc = crc32Table[(crc & 0xff) ^ 0xbd] ^ (crc >> 8);
            }
            else {
                const c1 = (c & 1023) + 64;
                const c2 = cNext & 1023;
                crc = crc32Table[(crc & 0xff) ^ (240 | ((c1 >> 8) & 7))] ^ (crc >> 8);
                crc = crc32Table[(crc & 0xff) ^ (128 | ((c1 >> 2) & 63))] ^ (crc >> 8);
                crc = crc32Table[(crc & 0xff) ^ (128 | ((c2 >> 6) & 15) | ((c1 & 3) << 4))] ^ (crc >> 8);
                crc = crc32Table[(crc & 0xff) ^ (128 | (c2 & 63))] ^ (crc >> 8);
            }
        }
        else {
            crc = crc32Table[(crc & 0xff) ^ (224 | ((c >> 12) & 15))] ^ (crc >> 8);
            crc = crc32Table[(crc & 0xff) ^ (128 | ((c >> 6) & 63))] ^ (crc >> 8);
            crc = crc32Table[(crc & 0xff) ^ (128 | (c & 63))] ^ (crc >> 8);
        }
    }
    return (crc | 0) + 0x80000000;
}
exports.hash = hash;


/***/ }),

/***/ "./node_modules/fast-check/lib/utils/stringify.js":
/*!********************************************************!*\
  !*** ./node_modules/fast-check/lib/utils/stringify.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.asyncStringify = exports.possiblyAsyncStringify = exports.stringify = exports.stringifyInternal = exports.hasAsyncToStringMethod = exports.asyncToStringMethod = exports.hasToStringMethod = exports.toStringMethod = void 0;
exports.toStringMethod = Symbol('fast-check/toStringMethod');
function hasToStringMethod(instance) {
    return (instance !== null &&
        (typeof instance === 'object' || typeof instance === 'function') &&
        exports.toStringMethod in instance &&
        typeof instance[exports.toStringMethod] === 'function');
}
exports.hasToStringMethod = hasToStringMethod;
exports.asyncToStringMethod = Symbol('fast-check/asyncToStringMethod');
function hasAsyncToStringMethod(instance) {
    return (instance !== null &&
        (typeof instance === 'object' || typeof instance === 'function') &&
        exports.asyncToStringMethod in instance &&
        typeof instance[exports.asyncToStringMethod] === 'function');
}
exports.hasAsyncToStringMethod = hasAsyncToStringMethod;
const findSymbolNameRegex = /^Symbol\((.*)\)$/;
function getSymbolDescription(s) {
    if (s.description !== undefined)
        return s.description;
    const m = findSymbolNameRegex.exec(String(s));
    return m && m[1].length ? m[1] : null;
}
function stringifyNumber(numValue) {
    switch (numValue) {
        case 0:
            return 1 / numValue === Number.NEGATIVE_INFINITY ? '-0' : '0';
        case Number.NEGATIVE_INFINITY:
            return 'Number.NEGATIVE_INFINITY';
        case Number.POSITIVE_INFINITY:
            return 'Number.POSITIVE_INFINITY';
        default:
            return numValue === numValue ? String(numValue) : 'Number.NaN';
    }
}
function isSparseArray(arr) {
    let previousNumberedIndex = -1;
    for (const index in arr) {
        const numberedIndex = Number(index);
        if (numberedIndex !== previousNumberedIndex + 1)
            return true;
        previousNumberedIndex = numberedIndex;
    }
    return previousNumberedIndex + 1 !== arr.length;
}
function stringifyInternal(value, previousValues, getAsyncContent) {
    const currentValues = previousValues.concat([value]);
    if (typeof value === 'object') {
        if (previousValues.indexOf(value) !== -1) {
            return '[cyclic]';
        }
    }
    if (hasAsyncToStringMethod(value)) {
        const content = getAsyncContent(value);
        if (content.state === 'fulfilled') {
            return content.value;
        }
    }
    if (hasToStringMethod(value)) {
        try {
            return value[exports.toStringMethod]();
        }
        catch (err) {
        }
    }
    switch (Object.prototype.toString.call(value)) {
        case '[object Array]': {
            const arr = value;
            if (arr.length >= 50 && isSparseArray(arr)) {
                const assignments = [];
                for (const index in arr) {
                    if (!Number.isNaN(Number(index)))
                        assignments.push(`${index}:${stringifyInternal(arr[index], currentValues, getAsyncContent)}`);
                }
                return assignments.length !== 0
                    ? `Object.assign(Array(${arr.length}),{${assignments.join(',')}})`
                    : `Array(${arr.length})`;
            }
            const stringifiedArray = arr.map((v) => stringifyInternal(v, currentValues, getAsyncContent)).join(',');
            return arr.length === 0 || arr.length - 1 in arr ? `[${stringifiedArray}]` : `[${stringifiedArray},]`;
        }
        case '[object BigInt]':
            return `${value}n`;
        case '[object Boolean]':
            return typeof value === 'boolean' ? JSON.stringify(value) : `new Boolean(${JSON.stringify(value)})`;
        case '[object Date]': {
            const d = value;
            return Number.isNaN(d.getTime()) ? `new Date(NaN)` : `new Date(${JSON.stringify(d.toISOString())})`;
        }
        case '[object Map]':
            return `new Map(${stringifyInternal(Array.from(value), currentValues, getAsyncContent)})`;
        case '[object Null]':
            return `null`;
        case '[object Number]':
            return typeof value === 'number' ? stringifyNumber(value) : `new Number(${stringifyNumber(Number(value))})`;
        case '[object Object]': {
            try {
                const toStringAccessor = value.toString;
                if (typeof toStringAccessor === 'function' && toStringAccessor !== Object.prototype.toString) {
                    return value.toString();
                }
            }
            catch (err) {
                return '[object Object]';
            }
            const mapper = (k) => `${k === '__proto__'
                ? '["__proto__"]'
                : typeof k === 'symbol'
                    ? `[${stringifyInternal(k, currentValues, getAsyncContent)}]`
                    : JSON.stringify(k)}:${stringifyInternal(value[k], currentValues, getAsyncContent)}`;
            const stringifiedProperties = [
                ...Object.keys(value).map(mapper),
                ...Object.getOwnPropertySymbols(value)
                    .filter((s) => {
                    const descriptor = Object.getOwnPropertyDescriptor(value, s);
                    return descriptor && descriptor.enumerable;
                })
                    .map(mapper),
            ];
            const rawRepr = '{' + stringifiedProperties.join(',') + '}';
            if (Object.getPrototypeOf(value) === null) {
                return rawRepr === '{}' ? 'Object.create(null)' : `Object.assign(Object.create(null),${rawRepr})`;
            }
            return rawRepr;
        }
        case '[object Set]':
            return `new Set(${stringifyInternal(Array.from(value), currentValues, getAsyncContent)})`;
        case '[object String]':
            return typeof value === 'string' ? JSON.stringify(value) : `new String(${JSON.stringify(value)})`;
        case '[object Symbol]': {
            const s = value;
            if (Symbol.keyFor(s) !== undefined) {
                return `Symbol.for(${JSON.stringify(Symbol.keyFor(s))})`;
            }
            const desc = getSymbolDescription(s);
            if (desc === null) {
                return 'Symbol()';
            }
            const knownSymbol = desc.startsWith('Symbol.') && Symbol[desc.substring(7)];
            return s === knownSymbol ? desc : `Symbol(${JSON.stringify(desc)})`;
        }
        case '[object Promise]': {
            const promiseContent = getAsyncContent(value);
            switch (promiseContent.state) {
                case 'fulfilled':
                    return `Promise.resolve(${stringifyInternal(promiseContent.value, currentValues, getAsyncContent)})`;
                case 'rejected':
                    return `Promise.reject(${stringifyInternal(promiseContent.value, currentValues, getAsyncContent)})`;
                case 'pending':
                    return `new Promise(() => {/*pending*/})`;
                case 'unknown':
                default:
                    return `new Promise(() => {/*unknown*/})`;
            }
        }
        case '[object Error]':
            if (value instanceof Error) {
                return `new Error(${stringifyInternal(value.message, currentValues, getAsyncContent)})`;
            }
            break;
        case '[object Undefined]':
            return `undefined`;
        case '[object Int8Array]':
        case '[object Uint8Array]':
        case '[object Uint8ClampedArray]':
        case '[object Int16Array]':
        case '[object Uint16Array]':
        case '[object Int32Array]':
        case '[object Uint32Array]':
        case '[object Float32Array]':
        case '[object Float64Array]':
        case '[object BigInt64Array]':
        case '[object BigUint64Array]': {
            if (typeof Buffer !== 'undefined' && typeof Buffer.isBuffer === 'function' && Buffer.isBuffer(value)) {
                return `Buffer.from(${stringifyInternal(Array.from(value.values()), currentValues, getAsyncContent)})`;
            }
            const valuePrototype = Object.getPrototypeOf(value);
            const className = valuePrototype && valuePrototype.constructor && valuePrototype.constructor.name;
            if (typeof className === 'string') {
                const typedArray = value;
                const valuesFromTypedArr = typedArray.values();
                return `${className}.from(${stringifyInternal(Array.from(valuesFromTypedArr), currentValues, getAsyncContent)})`;
            }
            break;
        }
    }
    try {
        return value.toString();
    }
    catch (_a) {
        return Object.prototype.toString.call(value);
    }
}
exports.stringifyInternal = stringifyInternal;
function stringify(value) {
    return stringifyInternal(value, [], () => ({ state: 'unknown', value: undefined }));
}
exports.stringify = stringify;
function possiblyAsyncStringify(value) {
    const stillPendingMarker = Symbol();
    const pendingPromisesForCache = [];
    const cache = new Map();
    function createDelay0() {
        let handleId = null;
        const cancel = () => {
            if (handleId !== null) {
                clearTimeout(handleId);
            }
        };
        const delay = new Promise((resolve) => {
            handleId = setTimeout(() => {
                handleId = null;
                resolve(stillPendingMarker);
            }, 0);
        });
        return { delay, cancel };
    }
    const unknownState = { state: 'unknown', value: undefined };
    const getAsyncContent = function getAsyncContent(data) {
        const cacheKey = data;
        if (cache.has(cacheKey)) {
            return cache.get(cacheKey);
        }
        const delay0 = createDelay0();
        const p = exports.asyncToStringMethod in data
            ? Promise.resolve().then(() => data[exports.asyncToStringMethod]())
            : data;
        p.catch(() => { });
        pendingPromisesForCache.push(Promise.race([p, delay0.delay]).then((successValue) => {
            if (successValue === stillPendingMarker)
                cache.set(cacheKey, { state: 'pending', value: undefined });
            else
                cache.set(cacheKey, { state: 'fulfilled', value: successValue });
            delay0.cancel();
        }, (errorValue) => {
            cache.set(cacheKey, { state: 'rejected', value: errorValue });
            delay0.cancel();
        }));
        cache.set(cacheKey, unknownState);
        return unknownState;
    };
    function loop() {
        const stringifiedValue = stringifyInternal(value, [], getAsyncContent);
        if (pendingPromisesForCache.length === 0) {
            return stringifiedValue;
        }
        return Promise.all(pendingPromisesForCache.splice(0)).then(loop);
    }
    return loop();
}
exports.possiblyAsyncStringify = possiblyAsyncStringify;
async function asyncStringify(value) {
    return Promise.resolve(possiblyAsyncStringify(value));
}
exports.asyncStringify = asyncStringify;


/***/ }),

/***/ "./node_modules/pure-rand/lib/distribution/UniformArrayIntDistribution.js":
/*!********************************************************************************!*\
  !*** ./node_modules/pure-rand/lib/distribution/UniformArrayIntDistribution.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

exports.__esModule = true;
exports.uniformArrayIntDistribution = void 0;
var UnsafeUniformArrayIntDistribution_1 = __webpack_require__(/*! ./UnsafeUniformArrayIntDistribution */ "./node_modules/pure-rand/lib/distribution/UnsafeUniformArrayIntDistribution.js");
function uniformArrayIntDistribution(from, to, rng) {
    if (rng != null) {
        var nextRng = rng.clone();
        return [UnsafeUniformArrayIntDistribution_1.unsafeUniformArrayIntDistribution(from, to, nextRng), nextRng];
    }
    return function (rng) {
        var nextRng = rng.clone();
        return [UnsafeUniformArrayIntDistribution_1.unsafeUniformArrayIntDistribution(from, to, nextRng), nextRng];
    };
}
exports.uniformArrayIntDistribution = uniformArrayIntDistribution;


/***/ }),

/***/ "./node_modules/pure-rand/lib/distribution/UniformBigIntDistribution.js":
/*!******************************************************************************!*\
  !*** ./node_modules/pure-rand/lib/distribution/UniformBigIntDistribution.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

exports.__esModule = true;
exports.uniformBigIntDistribution = void 0;
var UnsafeUniformBigIntDistribution_1 = __webpack_require__(/*! ./UnsafeUniformBigIntDistribution */ "./node_modules/pure-rand/lib/distribution/UnsafeUniformBigIntDistribution.js");
function uniformBigIntDistribution(from, to, rng) {
    if (rng != null) {
        var nextRng = rng.clone();
        return [UnsafeUniformBigIntDistribution_1.unsafeUniformBigIntDistribution(from, to, nextRng), nextRng];
    }
    return function (rng) {
        var nextRng = rng.clone();
        return [UnsafeUniformBigIntDistribution_1.unsafeUniformBigIntDistribution(from, to, nextRng), nextRng];
    };
}
exports.uniformBigIntDistribution = uniformBigIntDistribution;


/***/ }),

/***/ "./node_modules/pure-rand/lib/distribution/UniformIntDistribution.js":
/*!***************************************************************************!*\
  !*** ./node_modules/pure-rand/lib/distribution/UniformIntDistribution.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

exports.__esModule = true;
exports.uniformIntDistribution = void 0;
var UnsafeUniformIntDistribution_1 = __webpack_require__(/*! ./UnsafeUniformIntDistribution */ "./node_modules/pure-rand/lib/distribution/UnsafeUniformIntDistribution.js");
function uniformIntDistribution(from, to, rng) {
    if (rng != null) {
        var nextRng = rng.clone();
        return [UnsafeUniformIntDistribution_1.unsafeUniformIntDistribution(from, to, nextRng), nextRng];
    }
    return function (rng) {
        var nextRng = rng.clone();
        return [UnsafeUniformIntDistribution_1.unsafeUniformIntDistribution(from, to, nextRng), nextRng];
    };
}
exports.uniformIntDistribution = uniformIntDistribution;


/***/ }),

/***/ "./node_modules/pure-rand/lib/distribution/UnsafeUniformArrayIntDistribution.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/pure-rand/lib/distribution/UnsafeUniformArrayIntDistribution.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

exports.__esModule = true;
exports.unsafeUniformArrayIntDistribution = void 0;
var ArrayInt_1 = __webpack_require__(/*! ./internals/ArrayInt */ "./node_modules/pure-rand/lib/distribution/internals/ArrayInt.js");
var UnsafeUniformArrayIntDistributionInternal_1 = __webpack_require__(/*! ./internals/UnsafeUniformArrayIntDistributionInternal */ "./node_modules/pure-rand/lib/distribution/internals/UnsafeUniformArrayIntDistributionInternal.js");
function unsafeUniformArrayIntDistribution(from, to, rng) {
    var rangeSize = ArrayInt_1.trimArrayIntInplace(ArrayInt_1.addOneToPositiveArrayInt(ArrayInt_1.substractArrayIntToNew(to, from)));
    var emptyArrayIntData = rangeSize.data.slice(0);
    var g = UnsafeUniformArrayIntDistributionInternal_1.unsafeUniformArrayIntDistributionInternal(emptyArrayIntData, rangeSize.data, rng);
    return ArrayInt_1.trimArrayIntInplace(ArrayInt_1.addArrayIntToNew({ sign: 1, data: g }, from));
}
exports.unsafeUniformArrayIntDistribution = unsafeUniformArrayIntDistribution;


/***/ }),

/***/ "./node_modules/pure-rand/lib/distribution/UnsafeUniformBigIntDistribution.js":
/*!************************************************************************************!*\
  !*** ./node_modules/pure-rand/lib/distribution/UnsafeUniformBigIntDistribution.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

exports.__esModule = true;
exports.unsafeUniformBigIntDistribution = void 0;
function unsafeUniformBigIntDistribution(from, to, rng) {
    var diff = to - from + BigInt(1);
    var MinRng = BigInt(rng.min());
    var NumValues = BigInt(rng.max() - rng.min() + 1);
    var FinalNumValues = NumValues;
    var NumIterations = BigInt(1);
    while (FinalNumValues < diff) {
        FinalNumValues *= NumValues;
        ++NumIterations;
    }
    var MaxAcceptedRandom = FinalNumValues - (FinalNumValues % diff);
    while (true) {
        var value = BigInt(0);
        for (var num = BigInt(0); num !== NumIterations; ++num) {
            var out = rng.unsafeNext();
            value = NumValues * value + (BigInt(out) - MinRng);
        }
        if (value < MaxAcceptedRandom) {
            var inDiff = value % diff;
            return inDiff + from;
        }
    }
}
exports.unsafeUniformBigIntDistribution = unsafeUniformBigIntDistribution;


/***/ }),

/***/ "./node_modules/pure-rand/lib/distribution/UnsafeUniformIntDistribution.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/pure-rand/lib/distribution/UnsafeUniformIntDistribution.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

exports.__esModule = true;
exports.unsafeUniformIntDistribution = void 0;
var UnsafeUniformIntDistributionInternal_1 = __webpack_require__(/*! ./internals/UnsafeUniformIntDistributionInternal */ "./node_modules/pure-rand/lib/distribution/internals/UnsafeUniformIntDistributionInternal.js");
var ArrayInt_1 = __webpack_require__(/*! ./internals/ArrayInt */ "./node_modules/pure-rand/lib/distribution/internals/ArrayInt.js");
var UnsafeUniformArrayIntDistributionInternal_1 = __webpack_require__(/*! ./internals/UnsafeUniformArrayIntDistributionInternal */ "./node_modules/pure-rand/lib/distribution/internals/UnsafeUniformArrayIntDistributionInternal.js");
var sharedA = { sign: 1, data: [0, 0] };
var sharedB = { sign: 1, data: [0, 0] };
var sharedC = { sign: 1, data: [0, 0] };
var sharedData = [0, 0];
function uniformLargeIntInternal(from, to, rangeSize, rng) {
    var rangeSizeArrayIntValue = rangeSize <= Number.MAX_SAFE_INTEGER
        ? ArrayInt_1.fromNumberToArrayInt64(sharedC, rangeSize)
        : ArrayInt_1.substractArrayInt64(sharedC, ArrayInt_1.fromNumberToArrayInt64(sharedA, to), ArrayInt_1.fromNumberToArrayInt64(sharedB, from));
    if (rangeSizeArrayIntValue.data[1] === 0xffffffff) {
        rangeSizeArrayIntValue.data[0] += 1;
        rangeSizeArrayIntValue.data[1] = 0;
    }
    else {
        rangeSizeArrayIntValue.data[1] += 1;
    }
    UnsafeUniformArrayIntDistributionInternal_1.unsafeUniformArrayIntDistributionInternal(sharedData, rangeSizeArrayIntValue.data, rng);
    return sharedData[0] * 0x100000000 + sharedData[1] + from;
}
function unsafeUniformIntDistribution(from, to, rng) {
    var rangeSize = to - from;
    if (rangeSize <= 0xffffffff) {
        var g = UnsafeUniformIntDistributionInternal_1.unsafeUniformIntDistributionInternal(rangeSize + 1, rng);
        return g + from;
    }
    return uniformLargeIntInternal(from, to, rangeSize, rng);
}
exports.unsafeUniformIntDistribution = unsafeUniformIntDistribution;


/***/ }),

/***/ "./node_modules/pure-rand/lib/distribution/internals/ArrayInt.js":
/*!***********************************************************************!*\
  !*** ./node_modules/pure-rand/lib/distribution/internals/ArrayInt.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

exports.__esModule = true;
exports.substractArrayInt64 = exports.fromNumberToArrayInt64 = exports.trimArrayIntInplace = exports.substractArrayIntToNew = exports.addOneToPositiveArrayInt = exports.addArrayIntToNew = void 0;
function addArrayIntToNew(arrayIntA, arrayIntB) {
    if (arrayIntA.sign !== arrayIntB.sign) {
        return substractArrayIntToNew(arrayIntA, { sign: -arrayIntB.sign, data: arrayIntB.data });
    }
    var data = [];
    var reminder = 0;
    var dataA = arrayIntA.data;
    var dataB = arrayIntB.data;
    for (var indexA = dataA.length - 1, indexB = dataB.length - 1; indexA >= 0 || indexB >= 0; --indexA, --indexB) {
        var vA = indexA >= 0 ? dataA[indexA] : 0;
        var vB = indexB >= 0 ? dataB[indexB] : 0;
        var current = vA + vB + reminder;
        data.push(current >>> 0);
        reminder = ~~(current / 0x100000000);
    }
    if (reminder !== 0) {
        data.push(reminder);
    }
    return { sign: arrayIntA.sign, data: data.reverse() };
}
exports.addArrayIntToNew = addArrayIntToNew;
function addOneToPositiveArrayInt(arrayInt) {
    arrayInt.sign = 1;
    var data = arrayInt.data;
    for (var index = data.length - 1; index >= 0; --index) {
        if (data[index] === 0xffffffff) {
            data[index] = 0;
        }
        else {
            data[index] += 1;
            return arrayInt;
        }
    }
    data.unshift(1);
    return arrayInt;
}
exports.addOneToPositiveArrayInt = addOneToPositiveArrayInt;
function isStrictlySmaller(dataA, dataB) {
    var maxLength = Math.max(dataA.length, dataB.length);
    for (var index = 0; index < maxLength; ++index) {
        var indexA = index + dataA.length - maxLength;
        var indexB = index + dataB.length - maxLength;
        var vA = indexA >= 0 ? dataA[indexA] : 0;
        var vB = indexB >= 0 ? dataB[indexB] : 0;
        if (vA < vB)
            return true;
        if (vA > vB)
            return false;
    }
    return false;
}
function substractArrayIntToNew(arrayIntA, arrayIntB) {
    if (arrayIntA.sign !== arrayIntB.sign) {
        return addArrayIntToNew(arrayIntA, { sign: -arrayIntB.sign, data: arrayIntB.data });
    }
    var dataA = arrayIntA.data;
    var dataB = arrayIntB.data;
    if (isStrictlySmaller(dataA, dataB)) {
        var out = substractArrayIntToNew(arrayIntB, arrayIntA);
        out.sign = -out.sign;
        return out;
    }
    var data = [];
    var reminder = 0;
    for (var indexA = dataA.length - 1, indexB = dataB.length - 1; indexA >= 0 || indexB >= 0; --indexA, --indexB) {
        var vA = indexA >= 0 ? dataA[indexA] : 0;
        var vB = indexB >= 0 ? dataB[indexB] : 0;
        var current = vA - vB - reminder;
        data.push(current >>> 0);
        reminder = current < 0 ? 1 : 0;
    }
    return { sign: arrayIntA.sign, data: data.reverse() };
}
exports.substractArrayIntToNew = substractArrayIntToNew;
function trimArrayIntInplace(arrayInt) {
    var data = arrayInt.data;
    var firstNonZero = 0;
    for (; firstNonZero !== data.length && data[firstNonZero] === 0; ++firstNonZero) { }
    if (firstNonZero === data.length) {
        arrayInt.sign = 1;
        arrayInt.data = [0];
        return arrayInt;
    }
    data.splice(0, firstNonZero);
    return arrayInt;
}
exports.trimArrayIntInplace = trimArrayIntInplace;
function fromNumberToArrayInt64(out, n) {
    if (n < 0) {
        var posN = -n;
        out.sign = -1;
        out.data[0] = ~~(posN / 0x100000000);
        out.data[1] = posN >>> 0;
    }
    else {
        out.sign = 1;
        out.data[0] = ~~(n / 0x100000000);
        out.data[1] = n >>> 0;
    }
    return out;
}
exports.fromNumberToArrayInt64 = fromNumberToArrayInt64;
function substractArrayInt64(out, arrayIntA, arrayIntB) {
    var lowA = arrayIntA.data[1];
    var highA = arrayIntA.data[0];
    var signA = arrayIntA.sign;
    var lowB = arrayIntB.data[1];
    var highB = arrayIntB.data[0];
    var signB = arrayIntB.sign;
    out.sign = 1;
    if (signA === 1 && signB === -1) {
        var low_1 = lowA + lowB;
        var high = highA + highB + (low_1 > 0xffffffff ? 1 : 0);
        out.data[0] = high >>> 0;
        out.data[1] = low_1 >>> 0;
        return out;
    }
    var lowFirst = lowA;
    var highFirst = highA;
    var lowSecond = lowB;
    var highSecond = highB;
    if (signA === -1) {
        lowFirst = lowB;
        highFirst = highB;
        lowSecond = lowA;
        highSecond = highA;
    }
    var reminderLow = 0;
    var low = lowFirst - lowSecond;
    if (low < 0) {
        reminderLow = 1;
        low = low >>> 0;
    }
    out.data[0] = highFirst - highSecond - reminderLow;
    out.data[1] = low;
    return out;
}
exports.substractArrayInt64 = substractArrayInt64;


/***/ }),

/***/ "./node_modules/pure-rand/lib/distribution/internals/UnsafeUniformArrayIntDistributionInternal.js":
/*!********************************************************************************************************!*\
  !*** ./node_modules/pure-rand/lib/distribution/internals/UnsafeUniformArrayIntDistributionInternal.js ***!
  \********************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

exports.__esModule = true;
exports.unsafeUniformArrayIntDistributionInternal = void 0;
var UnsafeUniformIntDistributionInternal_1 = __webpack_require__(/*! ./UnsafeUniformIntDistributionInternal */ "./node_modules/pure-rand/lib/distribution/internals/UnsafeUniformIntDistributionInternal.js");
function unsafeUniformArrayIntDistributionInternal(out, rangeSize, rng) {
    var rangeLength = rangeSize.length;
    while (true) {
        for (var index = 0; index !== rangeLength; ++index) {
            var indexRangeSize = index === 0 ? rangeSize[0] + 1 : 0x100000000;
            var g = UnsafeUniformIntDistributionInternal_1.unsafeUniformIntDistributionInternal(indexRangeSize, rng);
            out[index] = g;
        }
        for (var index = 0; index !== rangeLength; ++index) {
            var current = out[index];
            var currentInRange = rangeSize[index];
            if (current < currentInRange) {
                return out;
            }
            else if (current > currentInRange) {
                break;
            }
        }
    }
}
exports.unsafeUniformArrayIntDistributionInternal = unsafeUniformArrayIntDistributionInternal;


/***/ }),

/***/ "./node_modules/pure-rand/lib/distribution/internals/UnsafeUniformIntDistributionInternal.js":
/*!***************************************************************************************************!*\
  !*** ./node_modules/pure-rand/lib/distribution/internals/UnsafeUniformIntDistributionInternal.js ***!
  \***************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

exports.__esModule = true;
exports.unsafeUniformIntDistributionInternal = void 0;
function unsafeUniformIntDistributionInternal(rangeSize, rng) {
    var MinRng = rng.min();
    var NumValues = rng.max() - rng.min() + 1;
    if (rangeSize <= NumValues) {
        var nrng_1 = rng;
        var MaxAllowed = NumValues - (NumValues % rangeSize);
        while (true) {
            var out = nrng_1.unsafeNext();
            var deltaV = out - MinRng;
            if (deltaV < MaxAllowed) {
                return deltaV % rangeSize;
            }
        }
    }
    var FinalNumValues = NumValues * NumValues;
    var NumIterations = 2;
    while (FinalNumValues < rangeSize) {
        FinalNumValues *= NumValues;
        ++NumIterations;
    }
    var MaxAcceptedRandom = rangeSize * Math.floor((1 * FinalNumValues) / rangeSize);
    var nrng = rng;
    while (true) {
        var value = 0;
        for (var num = 0; num !== NumIterations; ++num) {
            var out = nrng.unsafeNext();
            value = NumValues * value + (out - MinRng);
        }
        if (value < MaxAcceptedRandom) {
            var inDiff = value - rangeSize * Math.floor((1 * value) / rangeSize);
            return inDiff;
        }
    }
}
exports.unsafeUniformIntDistributionInternal = unsafeUniformIntDistributionInternal;


/***/ }),

/***/ "./node_modules/pure-rand/lib/generator/LinearCongruential.js":
/*!********************************************************************!*\
  !*** ./node_modules/pure-rand/lib/generator/LinearCongruential.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

exports.__esModule = true;
exports.congruential32 = exports.congruential = void 0;
var MULTIPLIER = 0x000343fd;
var INCREMENT = 0x00269ec3;
var MASK = 0xffffffff;
var MASK_2 = (1 << 31) - 1;
var computeNextSeed = function (seed) {
    return (seed * MULTIPLIER + INCREMENT) & MASK;
};
var computeValueFromNextSeed = function (nextseed) {
    return (nextseed & MASK_2) >> 16;
};
var LinearCongruential = (function () {
    function LinearCongruential(seed) {
        this.seed = seed;
    }
    LinearCongruential.prototype.min = function () {
        return LinearCongruential.min;
    };
    LinearCongruential.prototype.max = function () {
        return LinearCongruential.max;
    };
    LinearCongruential.prototype.clone = function () {
        return new LinearCongruential(this.seed);
    };
    LinearCongruential.prototype.next = function () {
        var nextRng = new LinearCongruential(this.seed);
        var out = nextRng.unsafeNext();
        return [out, nextRng];
    };
    LinearCongruential.prototype.unsafeNext = function () {
        this.seed = computeNextSeed(this.seed);
        return computeValueFromNextSeed(this.seed);
    };
    LinearCongruential.min = 0;
    LinearCongruential.max = Math.pow(2, 15) - 1;
    return LinearCongruential;
}());
var LinearCongruential32 = (function () {
    function LinearCongruential32(seed) {
        this.seed = seed;
    }
    LinearCongruential32.prototype.min = function () {
        return LinearCongruential32.min;
    };
    LinearCongruential32.prototype.max = function () {
        return LinearCongruential32.max;
    };
    LinearCongruential32.prototype.clone = function () {
        return new LinearCongruential32(this.seed);
    };
    LinearCongruential32.prototype.next = function () {
        var nextRng = new LinearCongruential32(this.seed);
        var out = nextRng.unsafeNext();
        return [out, nextRng];
    };
    LinearCongruential32.prototype.unsafeNext = function () {
        var s1 = computeNextSeed(this.seed);
        var v1 = computeValueFromNextSeed(s1);
        var s2 = computeNextSeed(s1);
        var v2 = computeValueFromNextSeed(s2);
        this.seed = computeNextSeed(s2);
        var v3 = computeValueFromNextSeed(this.seed);
        var vnext = v3 + ((v2 + (v1 << 15)) << 15);
        return ((vnext + 0x80000000) | 0) + 0x80000000;
    };
    LinearCongruential32.min = 0;
    LinearCongruential32.max = 0xffffffff;
    return LinearCongruential32;
}());
var congruential = function (seed) {
    return new LinearCongruential(seed);
};
exports.congruential = congruential;
var congruential32 = function (seed) {
    return new LinearCongruential32(seed);
};
exports.congruential32 = congruential32;


/***/ }),

/***/ "./node_modules/pure-rand/lib/generator/MersenneTwister.js":
/*!*****************************************************************!*\
  !*** ./node_modules/pure-rand/lib/generator/MersenneTwister.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

exports.__esModule = true;
var MersenneTwister = (function () {
    function MersenneTwister(states, index) {
        this.states = states;
        this.index = index;
    }
    MersenneTwister.twist = function (prev) {
        var mt = prev.slice();
        for (var idx = 0; idx !== MersenneTwister.N - MersenneTwister.M; ++idx) {
            var y_1 = (mt[idx] & MersenneTwister.MASK_UPPER) + (mt[idx + 1] & MersenneTwister.MASK_LOWER);
            mt[idx] = mt[idx + MersenneTwister.M] ^ (y_1 >>> 1) ^ (-(y_1 & 1) & MersenneTwister.A);
        }
        for (var idx = MersenneTwister.N - MersenneTwister.M; idx !== MersenneTwister.N - 1; ++idx) {
            var y_2 = (mt[idx] & MersenneTwister.MASK_UPPER) + (mt[idx + 1] & MersenneTwister.MASK_LOWER);
            mt[idx] = mt[idx + MersenneTwister.M - MersenneTwister.N] ^ (y_2 >>> 1) ^ (-(y_2 & 1) & MersenneTwister.A);
        }
        var y = (mt[MersenneTwister.N - 1] & MersenneTwister.MASK_UPPER) + (mt[0] & MersenneTwister.MASK_LOWER);
        mt[MersenneTwister.N - 1] = mt[MersenneTwister.M - 1] ^ (y >>> 1) ^ (-(y & 1) & MersenneTwister.A);
        return mt;
    };
    MersenneTwister.seeded = function (seed) {
        var out = Array(MersenneTwister.N);
        out[0] = seed;
        for (var idx = 1; idx !== MersenneTwister.N; ++idx) {
            var xored = out[idx - 1] ^ (out[idx - 1] >>> 30);
            out[idx] = (Math.imul(MersenneTwister.F, xored) + idx) | 0;
        }
        return out;
    };
    MersenneTwister.from = function (seed) {
        return new MersenneTwister(MersenneTwister.twist(MersenneTwister.seeded(seed)), 0);
    };
    MersenneTwister.prototype.min = function () {
        return MersenneTwister.min;
    };
    MersenneTwister.prototype.max = function () {
        return MersenneTwister.max;
    };
    MersenneTwister.prototype.clone = function () {
        return new MersenneTwister(this.states, this.index);
    };
    MersenneTwister.prototype.next = function () {
        var nextRng = new MersenneTwister(this.states, this.index);
        var out = nextRng.unsafeNext();
        return [out, nextRng];
    };
    MersenneTwister.prototype.unsafeNext = function () {
        var y = this.states[this.index];
        y ^= this.states[this.index] >>> MersenneTwister.U;
        y ^= (y << MersenneTwister.S) & MersenneTwister.B;
        y ^= (y << MersenneTwister.T) & MersenneTwister.C;
        y ^= y >>> MersenneTwister.L;
        if (++this.index >= MersenneTwister.N) {
            this.states = MersenneTwister.twist(this.states);
            this.index = 0;
        }
        return y >>> 0;
    };
    MersenneTwister.min = 0;
    MersenneTwister.max = 0xffffffff;
    MersenneTwister.N = 624;
    MersenneTwister.M = 397;
    MersenneTwister.R = 31;
    MersenneTwister.A = 0x9908b0df;
    MersenneTwister.F = 1812433253;
    MersenneTwister.U = 11;
    MersenneTwister.S = 7;
    MersenneTwister.B = 0x9d2c5680;
    MersenneTwister.T = 15;
    MersenneTwister.C = 0xefc60000;
    MersenneTwister.L = 18;
    MersenneTwister.MASK_LOWER = Math.pow(2, MersenneTwister.R) - 1;
    MersenneTwister.MASK_UPPER = Math.pow(2, MersenneTwister.R);
    return MersenneTwister;
}());
function default_1(seed) {
    return MersenneTwister.from(seed);
}
exports.default = default_1;


/***/ }),

/***/ "./node_modules/pure-rand/lib/generator/RandomGenerator.js":
/*!*****************************************************************!*\
  !*** ./node_modules/pure-rand/lib/generator/RandomGenerator.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

exports.__esModule = true;
exports.skipN = exports.unsafeSkipN = exports.generateN = exports.unsafeGenerateN = void 0;
function unsafeGenerateN(rng, num) {
    var out = [];
    for (var idx = 0; idx != num; ++idx) {
        out.push(rng.unsafeNext());
    }
    return out;
}
exports.unsafeGenerateN = unsafeGenerateN;
function generateN(rng, num) {
    var nextRng = rng.clone();
    var out = unsafeGenerateN(nextRng, num);
    return [out, nextRng];
}
exports.generateN = generateN;
function unsafeSkipN(rng, num) {
    for (var idx = 0; idx != num; ++idx) {
        rng.unsafeNext();
    }
}
exports.unsafeSkipN = unsafeSkipN;
function skipN(rng, num) {
    var nextRng = rng.clone();
    unsafeSkipN(nextRng, num);
    return nextRng;
}
exports.skipN = skipN;


/***/ }),

/***/ "./node_modules/pure-rand/lib/generator/XorShift.js":
/*!**********************************************************!*\
  !*** ./node_modules/pure-rand/lib/generator/XorShift.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

exports.__esModule = true;
exports.xorshift128plus = void 0;
var XorShift128Plus = (function () {
    function XorShift128Plus(s01, s00, s11, s10) {
        this.s01 = s01;
        this.s00 = s00;
        this.s11 = s11;
        this.s10 = s10;
    }
    XorShift128Plus.prototype.min = function () {
        return -0x80000000;
    };
    XorShift128Plus.prototype.max = function () {
        return 0x7fffffff;
    };
    XorShift128Plus.prototype.clone = function () {
        return new XorShift128Plus(this.s01, this.s00, this.s11, this.s10);
    };
    XorShift128Plus.prototype.next = function () {
        var nextRng = new XorShift128Plus(this.s01, this.s00, this.s11, this.s10);
        var out = nextRng.unsafeNext();
        return [out, nextRng];
    };
    XorShift128Plus.prototype.unsafeNext = function () {
        var a0 = this.s00 ^ (this.s00 << 23);
        var a1 = this.s01 ^ ((this.s01 << 23) | (this.s00 >>> 9));
        var b0 = a0 ^ this.s10 ^ ((a0 >>> 18) | (a1 << 14)) ^ ((this.s10 >>> 5) | (this.s11 << 27));
        var b1 = a1 ^ this.s11 ^ (a1 >>> 18) ^ (this.s11 >>> 5);
        var out = (this.s00 + this.s10) | 0;
        this.s01 = this.s11;
        this.s00 = this.s10;
        this.s11 = b1;
        this.s10 = b0;
        return out;
    };
    XorShift128Plus.prototype.jump = function () {
        var nextRng = new XorShift128Plus(this.s01, this.s00, this.s11, this.s10);
        nextRng.unsafeJump();
        return nextRng;
    };
    XorShift128Plus.prototype.unsafeJump = function () {
        var ns01 = 0;
        var ns00 = 0;
        var ns11 = 0;
        var ns10 = 0;
        var jump = [0x635d2dff, 0x8a5cd789, 0x5c472f96, 0x121fd215];
        for (var i = 0; i !== 4; ++i) {
            for (var mask = 1; mask; mask <<= 1) {
                if (jump[i] & mask) {
                    ns01 ^= this.s01;
                    ns00 ^= this.s00;
                    ns11 ^= this.s11;
                    ns10 ^= this.s10;
                }
                this.unsafeNext();
            }
        }
        this.s01 = ns01;
        this.s00 = ns00;
        this.s11 = ns11;
        this.s10 = ns10;
    };
    return XorShift128Plus;
}());
var xorshift128plus = function (seed) {
    return new XorShift128Plus(-1, ~seed, seed | 0, 0);
};
exports.xorshift128plus = xorshift128plus;


/***/ }),

/***/ "./node_modules/pure-rand/lib/generator/XoroShiro.js":
/*!***********************************************************!*\
  !*** ./node_modules/pure-rand/lib/generator/XoroShiro.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

exports.__esModule = true;
exports.xoroshiro128plus = void 0;
var XoroShiro128Plus = (function () {
    function XoroShiro128Plus(s01, s00, s11, s10) {
        this.s01 = s01;
        this.s00 = s00;
        this.s11 = s11;
        this.s10 = s10;
    }
    XoroShiro128Plus.prototype.min = function () {
        return -0x80000000;
    };
    XoroShiro128Plus.prototype.max = function () {
        return 0x7fffffff;
    };
    XoroShiro128Plus.prototype.clone = function () {
        return new XoroShiro128Plus(this.s01, this.s00, this.s11, this.s10);
    };
    XoroShiro128Plus.prototype.next = function () {
        var nextRng = new XoroShiro128Plus(this.s01, this.s00, this.s11, this.s10);
        var out = nextRng.unsafeNext();
        return [out, nextRng];
    };
    XoroShiro128Plus.prototype.unsafeNext = function () {
        var out = (this.s00 + this.s10) | 0;
        var a0 = this.s10 ^ this.s00;
        var a1 = this.s11 ^ this.s01;
        var s00 = this.s00;
        var s01 = this.s01;
        this.s00 = (s00 << 24) ^ (s01 >>> 8) ^ a0 ^ (a0 << 16);
        this.s01 = (s01 << 24) ^ (s00 >>> 8) ^ a1 ^ ((a1 << 16) | (a0 >>> 16));
        this.s10 = (a1 << 5) ^ (a0 >>> 27);
        this.s11 = (a0 << 5) ^ (a1 >>> 27);
        return out;
    };
    XoroShiro128Plus.prototype.jump = function () {
        var nextRng = new XoroShiro128Plus(this.s01, this.s00, this.s11, this.s10);
        nextRng.unsafeJump();
        return nextRng;
    };
    XoroShiro128Plus.prototype.unsafeJump = function () {
        var ns01 = 0;
        var ns00 = 0;
        var ns11 = 0;
        var ns10 = 0;
        var jump = [0xd8f554a5, 0xdf900294, 0x4b3201fc, 0x170865df];
        for (var i = 0; i !== 4; ++i) {
            for (var mask = 1; mask; mask <<= 1) {
                if (jump[i] & mask) {
                    ns01 ^= this.s01;
                    ns00 ^= this.s00;
                    ns11 ^= this.s11;
                    ns10 ^= this.s10;
                }
                this.unsafeNext();
            }
        }
        this.s01 = ns01;
        this.s00 = ns00;
        this.s11 = ns11;
        this.s10 = ns10;
    };
    return XoroShiro128Plus;
}());
var xoroshiro128plus = function (seed) {
    return new XoroShiro128Plus(-1, ~seed, seed | 0, 0);
};
exports.xoroshiro128plus = xoroshiro128plus;


/***/ }),

/***/ "./node_modules/pure-rand/lib/pure-rand-default.js":
/*!*********************************************************!*\
  !*** ./node_modules/pure-rand/lib/pure-rand-default.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

exports.__esModule = true;
exports.unsafeUniformIntDistribution = exports.unsafeUniformBigIntDistribution = exports.unsafeUniformArrayIntDistribution = exports.uniformIntDistribution = exports.uniformBigIntDistribution = exports.uniformArrayIntDistribution = exports.xoroshiro128plus = exports.xorshift128plus = exports.mersenne = exports.congruential32 = exports.congruential = exports.unsafeSkipN = exports.unsafeGenerateN = exports.skipN = exports.generateN = exports.__commitHash = exports.__version = exports.__type = void 0;
var RandomGenerator_1 = __webpack_require__(/*! ./generator/RandomGenerator */ "./node_modules/pure-rand/lib/generator/RandomGenerator.js");
exports.generateN = RandomGenerator_1.generateN;
exports.skipN = RandomGenerator_1.skipN;
exports.unsafeGenerateN = RandomGenerator_1.unsafeGenerateN;
exports.unsafeSkipN = RandomGenerator_1.unsafeSkipN;
var LinearCongruential_1 = __webpack_require__(/*! ./generator/LinearCongruential */ "./node_modules/pure-rand/lib/generator/LinearCongruential.js");
exports.congruential = LinearCongruential_1.congruential;
exports.congruential32 = LinearCongruential_1.congruential32;
var MersenneTwister_1 = __webpack_require__(/*! ./generator/MersenneTwister */ "./node_modules/pure-rand/lib/generator/MersenneTwister.js");
exports.mersenne = MersenneTwister_1["default"];
var XorShift_1 = __webpack_require__(/*! ./generator/XorShift */ "./node_modules/pure-rand/lib/generator/XorShift.js");
exports.xorshift128plus = XorShift_1.xorshift128plus;
var XoroShiro_1 = __webpack_require__(/*! ./generator/XoroShiro */ "./node_modules/pure-rand/lib/generator/XoroShiro.js");
exports.xoroshiro128plus = XoroShiro_1.xoroshiro128plus;
var UniformArrayIntDistribution_1 = __webpack_require__(/*! ./distribution/UniformArrayIntDistribution */ "./node_modules/pure-rand/lib/distribution/UniformArrayIntDistribution.js");
exports.uniformArrayIntDistribution = UniformArrayIntDistribution_1.uniformArrayIntDistribution;
var UniformBigIntDistribution_1 = __webpack_require__(/*! ./distribution/UniformBigIntDistribution */ "./node_modules/pure-rand/lib/distribution/UniformBigIntDistribution.js");
exports.uniformBigIntDistribution = UniformBigIntDistribution_1.uniformBigIntDistribution;
var UniformIntDistribution_1 = __webpack_require__(/*! ./distribution/UniformIntDistribution */ "./node_modules/pure-rand/lib/distribution/UniformIntDistribution.js");
exports.uniformIntDistribution = UniformIntDistribution_1.uniformIntDistribution;
var UnsafeUniformArrayIntDistribution_1 = __webpack_require__(/*! ./distribution/UnsafeUniformArrayIntDistribution */ "./node_modules/pure-rand/lib/distribution/UnsafeUniformArrayIntDistribution.js");
exports.unsafeUniformArrayIntDistribution = UnsafeUniformArrayIntDistribution_1.unsafeUniformArrayIntDistribution;
var UnsafeUniformBigIntDistribution_1 = __webpack_require__(/*! ./distribution/UnsafeUniformBigIntDistribution */ "./node_modules/pure-rand/lib/distribution/UnsafeUniformBigIntDistribution.js");
exports.unsafeUniformBigIntDistribution = UnsafeUniformBigIntDistribution_1.unsafeUniformBigIntDistribution;
var UnsafeUniformIntDistribution_1 = __webpack_require__(/*! ./distribution/UnsafeUniformIntDistribution */ "./node_modules/pure-rand/lib/distribution/UnsafeUniformIntDistribution.js");
exports.unsafeUniformIntDistribution = UnsafeUniformIntDistribution_1.unsafeUniformIntDistribution;
var __type = 'commonjs';
exports.__type = __type;
var __version = '5.0.0';
exports.__version = __version;
var __commitHash = '744555855a01e1551ab1cf67a6ea973d14964661';
exports.__commitHash = __commitHash;


/***/ }),

/***/ "./node_modules/pure-rand/lib/pure-rand.js":
/*!*************************************************!*\
  !*** ./node_modules/pure-rand/lib/pure-rand.js ***!
  \*************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
exports.__esModule = true;
var prand = __webpack_require__(/*! ./pure-rand-default */ "./node_modules/pure-rand/lib/pure-rand-default.js");
exports.default = prand;
__exportStar(__webpack_require__(/*! ./pure-rand-default */ "./node_modules/pure-rand/lib/pure-rand-default.js"), exports);


/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			loaded: false,
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/node module decorator */
/******/ 	(() => {
/******/ 		__webpack_require__.nmd = (module) => {
/******/ 			module.paths = [];
/******/ 			if (!module.children) module.children = [];
/******/ 			return module;
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be in strict mode.
(() => {
"use strict";
var exports = __webpack_exports__;
/*!*******************************************!*\
  !*** ./src/visualizers/run-json-tests.ts ***!
  \*******************************************/

Object.defineProperty(exports, "__esModule", ({ value: true }));
const vis = __webpack_require__(/*! litscript/lib/visualizer */ "./node_modules/litscript/lib/visualizer.js");
const le = __webpack_require__(/*! lits-extras */ "./node_modules/lits-extras/lib/index.js");
const pz = __webpack_require__(/*! .. */ "./src/index.ts");
const jp = __webpack_require__(/*! ../test/jsonparser */ "./src/test/jsonparser.ts");
__webpack_require__(/*! ../test/jsontests */ "./src/test/jsontests.ts");
__webpack_require__(/*! ./run-json-tests.less */ "./src/visualizers/run-json-tests.less");
vis.registerVisualizer("run-json-tests", le.runTests);
vis.registerVisualizer("json-parser", parseJson);
function parseJson(params, parent) {
    parent.classList.add("json-editor");
    let ta = document.createElement('textarea');
    ta.cols = 40;
    ta.rows = 10;
    let res = document.createElement('div');
    res.classList.add("result");
    parent.append(ta, res);
    ta.addEventListener("input", _ => {
        try {
            res.innerText = JSON.stringify(jp.parseJson(ta.value));
        }
        catch (e) {
            if (e instanceof pz.ParseError)
                res.innerText = e.message;
            else
                throw e;
        }
    });
}

})();

/******/ })()
;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHFDQUFxQyx5QkFBeUI7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCw0QkFBNEI7QUFDNUIsNEJBQTRCO0FBQzVCLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RDtBQUM3RCw2REFBNkQ7QUFDN0Q7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0Qix3QkFBd0I7QUFDcEQ7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFD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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztBQ3ZKYTs7QUFFYixRQUFRLG1CQUFPLENBQUMsdURBQVU7O0FBRTFCOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9FQUFvRSxXQUFXO0FBQy9FO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsY0FBYztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsc0JBQXNCO0FBQ2xFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsc0JBQXNCO0FBQ2xFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtQkFBbUI7QUFDbkI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlFQUFpRSxjQUFjLHVEQUF1RDtBQUN0STtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3RUFBd0UscURBQXFEO0FBQzdIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7Ozs7Ozs7Ozs7OztBQzNNaEI7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsaUJBQWlCO0FBQ2pCLGtCQUFrQixtQkFBTyxDQUFDLHFFQUFlO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELG9FQUFvRTtBQUN2SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjs7Ozs7Ozs7Ozs7O0FDNUJKO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGtCQUFrQjtBQUNsQixpQkFBaUIsbUJBQU8sQ0FBQyw4RUFBd0I7QUFDakQsa0JBQWtCLG1CQUFPLENBQUMscUVBQWU7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsb0VBQW9FO0FBQ3ZIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCOzs7Ozs7Ozs7Ozs7QUMvQ0w7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsaUJBQWlCLEdBQUcsZUFBZSxHQUFHLGFBQWEsR0FBRyxrQkFBa0IsR0FBRyxtQkFBbUIsR0FBRyxlQUFlLEdBQUcsMkJBQTJCLEdBQUcsaUJBQWlCLEdBQUcsNEJBQTRCLEdBQUcsNEJBQTRCLEdBQUcsZ0JBQWdCLEdBQUcsY0FBYyxHQUFHLGNBQWM7QUFDclIsY0FBYyxLQUFLO0FBQ25CLGNBQWMsS0FBSztBQUNuQjtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBLGFBQWE7QUFDYjtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjs7Ozs7Ozs7Ozs7O0FDbkdKO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGtCQUFrQjtBQUNsQixpQkFBaUIsbUJBQU8sQ0FBQyw4RUFBd0I7QUFDakQscUJBQXFCLG1CQUFPLENBQUMsd0dBQTBCO0FBQ3ZELHdCQUF3QixtQkFBTyxDQUFDLDhHQUE2QjtBQUM3RCxvQkFBb0IsbUJBQU8sQ0FBQyxzR0FBeUI7QUFDckQscUJBQXFCLG1CQUFPLENBQUMseUZBQWM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsa0NBQWtDO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyw4QkFBOEI7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQiwwQkFBMEI7QUFDNUMsa0JBQWtCLGdFQUFnRTtBQUNsRixrQkFBa0IsZ0VBQWdFO0FBQ2xGO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCOzs7Ozs7Ozs7Ozs7QUNoSUw7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsbUNBQW1DLEdBQUcsNEJBQTRCLEdBQUcsaUNBQWlDLEdBQUcsMEJBQTBCO0FBQ25JLHNCQUFzQixtQkFBTyxDQUFDLDhGQUFnQztBQUM5RCxvQkFBb0IsbUJBQU8sQ0FBQywwRkFBOEI7QUFDMUQsd0JBQXdCLG1CQUFPLENBQUMsa0dBQWtDO0FBQ2xFLDBCQUEwQjtBQUMxQiwwQkFBMEI7QUFDMUIsd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQSx5Q0FBeUMsNkJBQTZCO0FBQ3RFLENBQUM7QUFDRCx3RkFBd0YsNkNBQTZDO0FBQ3JJLDBCQUEwQjtBQUMxQiw4R0FBOEcsNkNBQTZDO0FBQzNKLGlDQUFpQztBQUNqQywwSEFBMEgsNkNBQTZDO0FBQ3ZLLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRCxtQ0FBbUM7Ozs7Ozs7Ozs7OztBQzFCdEI7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Qsa0NBQWtDLEdBQUcsK0JBQStCO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7Ozs7Ozs7Ozs7OztBQ1ZyQjtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCx5QkFBeUIsR0FBRyxxQkFBcUIsR0FBRyxnQkFBZ0I7QUFDcEUsMkJBQTJCLG1CQUFPLENBQUMsMkdBQTZCO0FBQ2hFO0FBQ0E7QUFDQSxnQkFBZ0IsY0FBYztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5Qjs7Ozs7Ozs7Ozs7O0FDakVaO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGdCQUFnQixHQUFHLGtCQUFrQjtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixzQkFBc0I7QUFDcEQ7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQix1QkFBdUI7QUFDakQ7QUFDQTtBQUNBLDhCQUE4QixlQUFlO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQix5QkFBeUI7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsMkJBQTJCO0FBQ3JEO0FBQ0EsNEJBQTRCLFNBQVM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLE9BQU87QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjs7Ozs7Ozs7Ozs7O0FDakZMO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHNCQUFzQjtBQUN0QixvQkFBb0IsbUJBQU8sQ0FBQyxrRkFBMEI7QUFDdEQsa0JBQWtCLG1CQUFPLENBQUMscUVBQWU7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCOzs7Ozs7Ozs7Ozs7QUN0Q1Q7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsZ0JBQWdCO0FBQ2hCLGlCQUFpQixtQkFBTyxDQUFDLDhFQUF3QjtBQUNqRCxvQkFBb0IsbUJBQU8sQ0FBQyxtSEFBc0M7QUFDbEUscUJBQXFCLG1CQUFPLENBQUMscUhBQXVDO0FBQ3BFLGNBQWMsbUJBQU8sQ0FBQyw4RUFBd0I7QUFDOUMsZ0JBQWdCLG1CQUFPLENBQUMsa0ZBQTBCO0FBQ2xELHFCQUFxQixtQkFBTyxDQUFDLDhFQUFlO0FBQzVDLDJCQUEyQixtQkFBTyxDQUFDLGtHQUFvQjtBQUN2RCx5QkFBeUIsbUJBQU8sQ0FBQyw4RkFBa0I7QUFDbkQsK0JBQStCLG1CQUFPLENBQUMsMEdBQXNDO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQsbUVBQW1FO0FBQzdIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLHFCQUFxQjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsNEJBQTRCO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsNkJBQTZCLHlCQUF5QjtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsc0NBQXNDLDJCQUEyQjtBQUM3RztBQUNBO0FBQ0EsZ0JBQWdCOzs7Ozs7Ozs7Ozs7QUNwR0g7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Qsd0JBQXdCO0FBQ3hCLGtCQUFrQixtQkFBTyxDQUFDLHFFQUFlO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsb0JBQW9CLElBQUksU0FBUztBQUMzRTtBQUNBO0FBQ0Esd0JBQXdCOzs7Ozs7Ozs7Ozs7QUN4Qlg7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Qsd0JBQXdCLEdBQUcsd0JBQXdCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLG9CQUFvQjtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixvQkFBb0I7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7Ozs7Ozs7Ozs7OztBQ3pEWDtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxXQUFXO0FBQ1gsOEJBQThCLG1CQUFPLENBQUMsc0dBQXVCO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXOzs7Ozs7Ozs7Ozs7QUNURTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7Ozs7Ozs7Ozs7OztBQ2RhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHFCQUFxQjtBQUNyQix1QkFBdUIsbUJBQU8sQ0FBQyw2RkFBOEI7QUFDN0QsZ0NBQWdDLG1CQUFPLENBQUMsc0dBQXlCO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCOzs7Ozs7Ozs7Ozs7QUNaUjtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxxQkFBcUI7QUFDckIsOEJBQThCLG1CQUFPLENBQUMsb0hBQXFDO0FBQzNFLHVCQUF1QixtQkFBTyxDQUFDLG9GQUFnQjtBQUMvQywyQkFBMkIsbUJBQU8sQ0FBQyw4SEFBMEM7QUFDN0UsNEJBQTRCLG1CQUFPLENBQUMsZ0lBQTJDO0FBQy9FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IseURBQXlEO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLElBQUksbUJBQW1CLFVBQVU7QUFDM0Qsc0JBQXNCLElBQUk7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7Ozs7Ozs7Ozs7OztBQ3pEYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxxQkFBcUI7QUFDckIsa0NBQWtDLG1CQUFPLENBQUMsMEdBQTJCO0FBQ3JFLGlEQUFnRCxFQUFFLHFDQUFxQyxtREFBbUQsRUFBQzs7Ozs7Ozs7Ozs7O0FDSjlIO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHdCQUF3QjtBQUN4QjtBQUNBLHdCQUF3Qjs7Ozs7Ozs7Ozs7O0FDSlg7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsaUNBQWlDO0FBQ2pDLG9CQUFvQixtQkFBTyxDQUFDLCtFQUF1QjtBQUNuRCw4QkFBOEIsbUJBQU8sQ0FBQyxvSEFBcUM7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDOzs7Ozs7Ozs7Ozs7QUN0Q3BCO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGdCQUFnQjtBQUNoQix1QkFBdUIsbUJBQU8sQ0FBQyw2RkFBOEI7QUFDN0QsMkJBQTJCLG1CQUFPLENBQUMsNEZBQW9CO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCOzs7Ozs7Ozs7Ozs7QUNaSDtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxnQkFBZ0I7QUFDaEIsOEJBQThCLG1CQUFPLENBQUMsb0hBQXFDO0FBQzNFLHVCQUF1QixtQkFBTyxDQUFDLG9GQUFnQjtBQUMvQywyQkFBMkIsbUJBQU8sQ0FBQyw4SEFBMEM7QUFDN0UsNEJBQTRCLG1CQUFPLENBQUMsZ0lBQTJDO0FBQy9FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isb0dBQW9HO0FBQ3BIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLElBQUksbUJBQW1CLFVBQVU7QUFDM0Qsc0JBQXNCLElBQUk7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7Ozs7Ozs7Ozs7OztBQ3pEYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxnQkFBZ0I7QUFDaEIsNkJBQTZCLG1CQUFPLENBQUMsZ0dBQXNCO0FBQzNELDRDQUEyQyxFQUFFLHFDQUFxQyx5Q0FBeUMsRUFBQzs7Ozs7Ozs7Ozs7O0FDSi9HO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHlCQUF5QjtBQUN6Qiw4QkFBOEIsbUJBQU8sQ0FBQyxvSEFBcUM7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7Ozs7Ozs7Ozs7OztBQzFCWjtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQsUUFBUTtBQUNuRSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qjs7Ozs7Ozs7Ozs7O0FDL0JWO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCOzs7Ozs7Ozs7Ozs7QUNYWDtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCx3QkFBd0I7QUFDeEIsNEJBQTRCLG1CQUFPLENBQUMsd0dBQStCO0FBQ25FLDBCQUEwQixtQkFBTyxDQUFDLG9HQUE2QjtBQUMvRCwyQkFBMkIsbUJBQU8sQ0FBQyxzR0FBOEI7QUFDakUsb0NBQW9DLG1CQUFPLENBQUMsd0hBQXVDO0FBQ25GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCOzs7Ozs7Ozs7Ozs7QUM3Qlg7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsY0FBYyxHQUFHLGFBQWE7QUFDOUIsaUJBQWlCLG1CQUFPLENBQUMsMkVBQXFCO0FBQzlDLHFCQUFxQixtQkFBTyxDQUFDLGtIQUFvQztBQUNqRSwyQkFBMkIsbUJBQU8sQ0FBQyxzSEFBa0M7QUFDckUsOEJBQThCLG1CQUFPLENBQUMsNEhBQXFDO0FBQzNFLDJCQUEyQixtQkFBTyxDQUFDLDBGQUFvQjtBQUN2RCx5QkFBeUIsbUJBQU8sQ0FBQyxzRkFBa0I7QUFDbkQsK0JBQStCLG1CQUFPLENBQUMsa0dBQXdCO0FBQy9ELGlCQUFpQixtQkFBTyxDQUFDLHNFQUFVO0FBQ25DLHFCQUFxQixtQkFBTyxDQUFDLDBGQUFvQjtBQUNqRCw4QkFBOEIsbUJBQU8sQ0FBQyw0R0FBNkI7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlHQUFpRztBQUNqRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYzs7Ozs7Ozs7Ozs7O0FDNUVEO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHNCQUFzQjtBQUN0Qix1QkFBdUIsbUJBQU8sQ0FBQyxvR0FBeUI7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjs7Ozs7Ozs7Ozs7O0FDM0NUO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGtCQUFrQixHQUFHLGNBQWM7QUFDbkMsaUJBQWlCLG1CQUFPLENBQUMsMkVBQXFCO0FBQzlDLDJCQUEyQixtQkFBTyxDQUFDLHNHQUE4QjtBQUNqRSwyQkFBMkIsbUJBQU8sQ0FBQyxzR0FBOEI7QUFDakUsMkJBQTJCLG1CQUFPLENBQUMsc0hBQWtDO0FBQ3JFLDhCQUE4QixtQkFBTyxDQUFDLDRIQUFxQztBQUMzRSxpQkFBaUIsbUJBQU8sQ0FBQyxzRUFBVTtBQUNuQyxxQkFBcUIsbUJBQU8sQ0FBQywwRkFBb0I7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QywrQ0FBK0MsaUJBQWlCLGtDQUFrQztBQUMxSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLHdDQUF3QywrQ0FBK0MsaUJBQWlCLGtDQUFrQztBQUMxSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLDhDQUE4QztBQUM1RTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsaUNBQWlDLElBQUksc0NBQXNDO0FBQ3JHO0FBQ0E7QUFDQSxrQkFBa0I7Ozs7Ozs7Ozs7OztBQ3JETDtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCOzs7Ozs7Ozs7Ozs7QUN6QmY7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsWUFBWTtBQUNaLG9CQUFvQixtQkFBTyxDQUFDLDREQUFXO0FBQ3ZDLGlCQUFpQixtQkFBTyxDQUFDLCtGQUErQjtBQUN4RCxxQkFBcUIsbUJBQU8sQ0FBQyxrSEFBb0M7QUFDakUscUJBQXFCLG1CQUFPLENBQUMsdUdBQW1DO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTs7Ozs7Ozs7Ozs7O0FDbkJDO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELDRCQUE0QixHQUFHLDJCQUEyQixHQUFHLHVCQUF1QjtBQUNwRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCOzs7Ozs7Ozs7Ozs7QUNmZjtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCwyQkFBMkI7QUFDM0Isb0JBQW9CLG1CQUFPLENBQUMsNERBQVc7QUFDdkMseUJBQXlCLG1CQUFPLENBQUMsb0dBQWtCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOERBQThELGFBQWE7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztBQ2pIYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsOENBQThDLHNCQUFzQixLQUFLOzs7Ozs7Ozs7Ozs7QUNSN0Q7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLGdEQUFnRCx1QkFBdUIsS0FBSzs7Ozs7Ozs7Ozs7O0FDUmhFO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELG9CQUFvQjtBQUNwQix5QkFBeUIsbUJBQU8sQ0FBQyxtSEFBaUM7QUFDbEUsMEJBQTBCLG1CQUFPLENBQUMsaUdBQW1CO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsR0FBRztBQUN2QztBQUNBLHNDQUFzQyxHQUFHO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0VBQWdFLE9BQU87QUFDdkU7Ozs7Ozs7Ozs7OztBQ2hIYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxnQkFBZ0I7QUFDaEIsaUJBQWlCLG1CQUFPLENBQUMsOEVBQXdCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RCxLQUFLO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRUFBZ0UsS0FBSztBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCOzs7Ozs7Ozs7Ozs7QUN0Qkg7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsaUNBQWlDLEdBQUcsNEJBQTRCLEdBQUcsNkJBQTZCLEdBQUcsd0JBQXdCO0FBQzNILG9CQUFvQixtQkFBTyxDQUFDLGtGQUEwQjtBQUN0RCx5QkFBeUIsbUJBQU8sQ0FBQyxtSEFBaUM7QUFDbEUsMEJBQTBCLG1CQUFPLENBQUMsMkdBQTZCO0FBQy9EO0FBQ0E7QUFDQSx3QkFBd0IsU0FBUztBQUNqQztBQUNBLDBDQUEwQyxRQUFRLEtBQUssRUFBRTtBQUN6RDtBQUNBO0FBQ0EsNENBQTRDLHdDQUF3QztBQUNwRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLGdCQUFnQjtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLFlBQVksRUFBRSxZQUFZLEVBQUUsZ0NBQWdDO0FBQ3pGO0FBQ0EsMENBQTBDLCtCQUErQjtBQUN6RTtBQUNBO0FBQ0Esa0NBQWtDLHdCQUF3QjtBQUMxRDtBQUNBO0FBQ0EsNEZBQTRGLFFBQVEsV0FBVyxVQUFVLGFBQWEsbUJBQW1CLGNBQWM7QUFDdks7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsNkNBQTZDLGFBQWEsU0FBUyxRQUFRLFNBQVMsV0FBVyx1QkFBdUIsdUJBQXVCLG9CQUFvQixpQ0FBaUMsV0FBVyxnQkFBZ0Isc0JBQXNCLFVBQVU7QUFDN1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0Esa0RBQWtELGFBQWEsU0FBUyxRQUFRLFdBQVc7QUFDM0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksMEJBQTBCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixRQUFRO0FBQ3ZDO0FBQ0EsK0JBQStCLG1CQUFtQjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2Qjs7Ozs7Ozs7Ozs7O0FDdkpoQjtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxxQkFBcUIsR0FBRyxzQkFBc0IsR0FBRyxtQkFBbUI7QUFDcEUsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7Ozs7Ozs7Ozs7OztBQ2RSO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHdCQUF3QixHQUFHLGFBQWEsR0FBRyxhQUFhLEdBQUcsaUJBQWlCLEdBQUcsYUFBYSxHQUFHLGNBQWMsR0FBRyxxQkFBcUIsR0FBRyxzQkFBc0IsR0FBRyxvQkFBb0IsR0FBRyxnQkFBZ0IsR0FBRyxhQUFhLEdBQUcsb0JBQW9CLEdBQUcsa0JBQWtCLEdBQUcseUJBQXlCLEdBQUcscUJBQXFCLEdBQUcsZ0JBQWdCLEdBQUcsb0JBQW9CLEdBQUcsbUJBQW1CLEdBQUcsY0FBYyxHQUFHLGlCQUFpQixHQUFHLGNBQWMsR0FBRyxZQUFZLEdBQUcsbUJBQW1CLEdBQUcsZUFBZSxHQUFHLGtCQUFrQixHQUFHLGFBQWEsR0FBRyxZQUFZLEdBQUcsZUFBZSxHQUFHLGNBQWMsR0FBRyxnQkFBZ0IsR0FBRyxlQUFlLEdBQUcsa0JBQWtCLEdBQUcsc0JBQXNCLEdBQUcsV0FBVyxHQUFHLGVBQWUsR0FBRyxjQUFjLEdBQUcsYUFBYSxHQUFHLGFBQWEsR0FBRyxlQUFlLEdBQUcscUJBQXFCLEdBQUcsZ0JBQWdCLEdBQUcsMkJBQTJCLEdBQUcsV0FBVyxHQUFHLGNBQWMsR0FBRyxhQUFhLEdBQUcsa0JBQWtCLEdBQUcsY0FBYyxHQUFHLG9CQUFvQixHQUFHLGlCQUFpQixHQUFHLGNBQWM7QUFDNThCLGlCQUFpQixHQUFHLG9CQUFvQixHQUFHLGlCQUFpQixHQUFHLGdCQUFnQixHQUFHLHlCQUF5QixHQUFHLGdCQUFnQixHQUFHLHFCQUFxQixHQUFHLG9CQUFvQixHQUFHLG9CQUFvQixHQUFHLG1CQUFtQixHQUFHLGtCQUFrQixHQUFHLG1CQUFtQixHQUFHLGtCQUFrQixHQUFHLHlCQUF5QixHQUFHLGtCQUFrQixHQUFHLGlCQUFpQixHQUFHLGFBQWEsR0FBRyxZQUFZLEdBQUcsb0JBQW9CLEdBQUcsY0FBYyxHQUFHLDBCQUEwQixHQUFHLG9CQUFvQixHQUFHLGtCQUFrQixHQUFHLG9CQUFvQixHQUFHLGNBQWMsR0FBRyxZQUFZLEdBQUcsb0JBQW9CLEdBQUcsWUFBWSxHQUFHLFlBQVksR0FBRyxlQUFlLEdBQUcsWUFBWSxHQUFHLG1CQUFtQixHQUFHLDBCQUEwQixHQUFHLFlBQVksR0FBRyxjQUFjLEdBQUcseUJBQXlCLEdBQUcsbUJBQW1CLEdBQUcsa0JBQWtCLEdBQUcsWUFBWSxHQUFHLGNBQWMsR0FBRyxnQkFBZ0IsR0FBRyxrQkFBa0IsR0FBRyxjQUFjLEdBQUcsb0JBQW9CLEdBQUcsYUFBYSxHQUFHLFdBQVcsR0FBRyxzQkFBc0IsR0FBRyxtQkFBbUIsR0FBRyxhQUFhLEdBQUcsZ0JBQWdCO0FBQ3QvQixjQUFjLEdBQUcsY0FBYyxHQUFHLGNBQWMsR0FBRyx1QkFBdUIsR0FBRyw0QkFBNEIsR0FBRywyQkFBMkIsR0FBRyx1QkFBdUIsR0FBRyxzQkFBc0IsR0FBRyxZQUFZLEdBQUcsaUNBQWlDLEdBQUcsNEJBQTRCLEdBQUcsc0JBQXNCLEdBQUcsaUJBQWlCLEdBQUcsOEJBQThCLEdBQUcsMkJBQTJCLEdBQUcseUJBQXlCLEdBQUcsc0JBQXNCLEdBQUcscUJBQXFCLEdBQUcscUNBQXFDLEdBQUcsdUJBQXVCLEdBQUcsc0JBQXNCLEdBQUcscUJBQXFCLEdBQUcsbUJBQW1CLEdBQUcsaUJBQWlCLEdBQUcsa0JBQWtCLEdBQUcscUNBQXFDLEdBQUcsMkJBQTJCLEdBQUcscUJBQXFCO0FBQ3J0QixjQUFjLG1CQUFPLENBQUMseUZBQTBCO0FBQ2hELHVDQUFzQyxFQUFFLHFDQUFxQyxxQkFBcUIsRUFBQztBQUNuRyx3QkFBd0IsbUJBQU8sQ0FBQyxxR0FBZ0M7QUFDaEUsaURBQWdELEVBQUUscUNBQXFDLHlDQUF5QyxFQUFDO0FBQ2pJLG1CQUFtQixtQkFBTyxDQUFDLDJGQUEyQjtBQUN0RCw0Q0FBMkMsRUFBRSxxQ0FBcUMsK0JBQStCLEVBQUM7QUFDbEgsaUJBQWlCLG1CQUFPLENBQUMsbUZBQXVCO0FBQ2hELDBDQUF5QyxFQUFFLHFDQUFxQywyQkFBMkIsRUFBQztBQUM1Ryx5Q0FBd0MsRUFBRSxxQ0FBcUMsMEJBQTBCLEVBQUM7QUFDMUcsa0JBQWtCLG1CQUFPLENBQUMscUZBQXdCO0FBQ2xELDBDQUF5QyxFQUFFLHFDQUFxQyw0QkFBNEIsRUFBQztBQUM3Ryw4Q0FBNkMsRUFBRSxxQ0FBcUMsZ0NBQWdDLEVBQUM7QUFDckgsZ0JBQWdCLG1CQUFPLENBQUMsMkVBQW1CO0FBQzNDLHlDQUF3QyxFQUFFLHFDQUFxQyx5QkFBeUIsRUFBQztBQUN6RyxpQkFBaUIsbUJBQU8sQ0FBQyw2RUFBb0I7QUFDN0MsMENBQXlDLEVBQUUscUNBQXFDLDJCQUEyQixFQUFDO0FBQzVHLGtCQUFrQixtQkFBTyxDQUFDLCtFQUFxQjtBQUMvQywyQ0FBMEMsRUFBRSxxQ0FBcUMsNkJBQTZCLEVBQUM7QUFDL0csa0JBQWtCLG1CQUFPLENBQUMsK0VBQXFCO0FBQy9DLDJDQUEwQyxFQUFFLHFDQUFxQyw2QkFBNkIsRUFBQztBQUMvRyxtQkFBbUIsbUJBQU8sQ0FBQyxpRkFBc0I7QUFDakQsNENBQTJDLEVBQUUscUNBQXFDLCtCQUErQixFQUFDO0FBQ2xILGtCQUFrQixtQkFBTyxDQUFDLCtFQUFxQjtBQUMvQywyQ0FBMEMsRUFBRSxxQ0FBcUMsNkJBQTZCLEVBQUM7QUFDL0csZ0JBQWdCLG1CQUFPLENBQUMsMkVBQW1CO0FBQzNDLHlDQUF3QyxFQUFFLHFDQUFxQyx5QkFBeUIsRUFBQztBQUN6RyxnQkFBZ0IsbUJBQU8sQ0FBQywyRUFBbUI7QUFDM0MseUNBQXdDLEVBQUUscUNBQXFDLHlCQUF5QixFQUFDO0FBQ3pHLGlCQUFpQixtQkFBTyxDQUFDLDZFQUFvQjtBQUM3QywwQ0FBeUMsRUFBRSxxQ0FBcUMsMkJBQTJCLEVBQUM7QUFDNUcsZUFBZSxtQkFBTyxDQUFDLHlFQUFrQjtBQUN6Qyx3Q0FBdUMsRUFBRSxxQ0FBcUMsdUJBQXVCLEVBQUM7QUFDdEcscUJBQXFCLG1CQUFPLENBQUMscUZBQXdCO0FBQ3JELDhDQUE2QyxFQUFFLHFDQUFxQyxtQ0FBbUMsRUFBQztBQUN4SCxzQkFBc0IsbUJBQU8sQ0FBQyx1RkFBeUI7QUFDdkQsK0NBQThDLEVBQUUscUNBQXFDLHFDQUFxQyxFQUFDO0FBQzNILGVBQWUsbUJBQU8sQ0FBQyx5RUFBa0I7QUFDekMsd0NBQXVDLEVBQUUscUNBQXFDLHVCQUF1QixFQUFDO0FBQ3RHLGtCQUFrQixtQkFBTyxDQUFDLCtFQUFxQjtBQUMvQywyQ0FBMEMsRUFBRSxxQ0FBcUMsNkJBQTZCLEVBQUM7QUFDL0cseUJBQXlCLG1CQUFPLENBQUMsNkZBQTRCO0FBQzdELGtEQUFpRCxFQUFFLHFDQUFxQywyQ0FBMkMsRUFBQztBQUNwSSxtQkFBbUIsbUJBQU8sQ0FBQyxpRkFBc0I7QUFDakQsNENBQTJDLEVBQUUscUNBQXFDLCtCQUErQixFQUFDO0FBQ2xILHVCQUF1QixtQkFBTyxDQUFDLHlGQUEwQjtBQUN6RCxnREFBK0MsRUFBRSxxQ0FBcUMsdUNBQXVDLEVBQUM7QUFDOUgsa0JBQWtCLG1CQUFPLENBQUMsK0VBQXFCO0FBQy9DLDJDQUEwQyxFQUFFLHFDQUFxQyw2QkFBNkIsRUFBQztBQUMvRyxlQUFlLG1CQUFPLENBQUMseUVBQWtCO0FBQ3pDLHdDQUF1QyxFQUFFLHFDQUFxQyx1QkFBdUIsRUFBQztBQUN0RyxnQkFBZ0IsbUJBQU8sQ0FBQywyRUFBbUI7QUFDM0MseUNBQXdDLEVBQUUscUNBQXFDLHlCQUF5QixFQUFDO0FBQ3pHLGdCQUFnQixtQkFBTyxDQUFDLDJFQUFtQjtBQUMzQyx5Q0FBd0MsRUFBRSxxQ0FBcUMseUJBQXlCLEVBQUM7QUFDekcsb0JBQW9CLG1CQUFPLENBQUMscUhBQXdDO0FBQ3BFLDZDQUE0QyxFQUFFLHFDQUFxQyxpQ0FBaUMsRUFBQztBQUNySCxxQkFBcUIsbUJBQU8sQ0FBQyx1SEFBeUM7QUFDdEUsOENBQTZDLEVBQUUscUNBQXFDLG1DQUFtQyxFQUFDO0FBQ3hILHFCQUFxQixtQkFBTyxDQUFDLHFGQUF3QjtBQUNyRCw4Q0FBNkMsRUFBRSxxQ0FBcUMsbUNBQW1DLEVBQUM7QUFDeEgseUJBQXlCLG1CQUFPLENBQUMseUdBQWtDO0FBQ25FLGdEQUErQyxFQUFFLHFDQUFxQyx5Q0FBeUMsRUFBQztBQUNoSSxpQ0FBaUMsbUJBQU8sQ0FBQyx5SEFBMEM7QUFDbkYsMENBQXlDLEVBQUUscUNBQXFDLDJDQUEyQyxFQUFDO0FBQzVILHlDQUF3QyxFQUFFLHFDQUFxQywwQ0FBMEMsRUFBQztBQUMxSCxvQkFBb0IsbUJBQU8sQ0FBQyxtRkFBdUI7QUFDbkQsNkNBQTRDLEVBQUUscUNBQXFDLGlDQUFpQyxFQUFDO0FBQ3JILDZCQUE2QixtQkFBTyxDQUFDLHFHQUFnQztBQUNyRSxzREFBcUQsRUFBRSxxQ0FBcUMsbURBQW1ELEVBQUM7QUFDaEosc0JBQXNCLG1CQUFPLENBQUMsdUZBQXlCO0FBQ3ZELCtDQUE4QyxFQUFFLHFDQUFxQyxxQ0FBcUMsRUFBQztBQUMzSCxlQUFlLG1CQUFPLENBQUMseUVBQWtCO0FBQ3pDLHdDQUF1QyxFQUFFLHFDQUFxQyx1QkFBdUIsRUFBQztBQUN0Ryx3QkFBd0IsbUJBQU8sQ0FBQyx1R0FBaUM7QUFDakUsMENBQXlDLEVBQUUscUNBQXFDLGtDQUFrQyxFQUFDO0FBQ25ILGtCQUFrQixtQkFBTyxDQUFDLCtFQUFxQjtBQUMvQywyQ0FBMEMsRUFBRSxxQ0FBcUMsNkJBQTZCLEVBQUM7QUFDL0cseUJBQXlCLG1CQUFPLENBQUMsNkZBQTRCO0FBQzdELGtEQUFpRCxFQUFFLHFDQUFxQywyQ0FBMkMsRUFBQztBQUNwSSxxQkFBcUIsbUJBQU8sQ0FBQyxxRkFBd0I7QUFDckQsOENBQTZDLEVBQUUscUNBQXFDLG1DQUFtQyxFQUFDO0FBQ3hILGNBQWMsbUJBQU8sQ0FBQyx1RUFBaUI7QUFDdkMsdUNBQXNDLEVBQUUscUNBQXFDLHFCQUFxQixFQUFDO0FBQ25HLGVBQWUsbUJBQU8sQ0FBQyx5RUFBa0I7QUFDekMsd0NBQXVDLEVBQUUscUNBQXFDLHVCQUF1QixFQUFDO0FBQ3RHLHVCQUF1QixtQkFBTyxDQUFDLHlGQUEwQjtBQUN6RCxnREFBK0MsRUFBRSxxQ0FBcUMsdUNBQXVDLEVBQUM7QUFDOUgsZUFBZSxtQkFBTyxDQUFDLHlFQUFrQjtBQUN6Qyx3Q0FBdUMsRUFBRSxxQ0FBcUMsdUJBQXVCLEVBQUM7QUFDdEcsaUJBQWlCLG1CQUFPLENBQUMsNkVBQW9CO0FBQzdDLDBDQUF5QyxFQUFFLHFDQUFxQywyQkFBMkIsRUFBQztBQUM1RyxnQkFBZ0IsbUJBQU8sQ0FBQywyRUFBbUI7QUFDM0MseUNBQXdDLEVBQUUscUNBQXFDLHlCQUF5QixFQUFDO0FBQ3pHLHdCQUF3QixtQkFBTyxDQUFDLDJGQUEyQjtBQUMzRCxpREFBZ0QsRUFBRSxxQ0FBcUMseUNBQXlDLEVBQUM7QUFDakksZUFBZSxtQkFBTyxDQUFDLHlFQUFrQjtBQUN6Qyx3Q0FBdUMsRUFBRSxxQ0FBcUMsdUJBQXVCLEVBQUM7QUFDdEcsb0JBQW9CLG1CQUFPLENBQUMsbUZBQXVCO0FBQ25ELDZDQUE0QyxFQUFFLHFDQUFxQyxpQ0FBaUMsRUFBQztBQUNySCwwQkFBMEIsbUJBQU8sQ0FBQywyR0FBbUM7QUFDckUsNENBQTJDLEVBQUUscUNBQXFDLHNDQUFzQyxFQUFDO0FBQ3pILHdDQUF1QyxFQUFFLHFDQUFxQyxrQ0FBa0MsRUFBQztBQUNqSCw4Q0FBNkMsRUFBRSxxQ0FBcUMsd0NBQXdDLEVBQUM7QUFDN0gsMENBQXlDLEVBQUUscUNBQXFDLG9DQUFvQyxFQUFDO0FBQ3JILCtDQUE4QyxFQUFFLHFDQUFxQyx5Q0FBeUMsRUFBQztBQUMvSCxxREFBb0QsRUFBRSxxQ0FBcUMsK0NBQStDLEVBQUM7QUFDM0ksZ0JBQWdCLG1CQUFPLENBQUMsMkVBQW1CO0FBQzNDLHlDQUF3QyxFQUFFLHFDQUFxQyx5QkFBeUIsRUFBQztBQUN6RyxpQkFBaUIsbUJBQU8sQ0FBQyw2RUFBb0I7QUFDN0MsMENBQXlDLEVBQUUscUNBQXFDLDJCQUEyQixFQUFDO0FBQzVHLGlCQUFpQixtQkFBTyxDQUFDLDZFQUFvQjtBQUM3QywwQ0FBeUMsRUFBRSxxQ0FBcUMsMkJBQTJCLEVBQUM7QUFDNUcsY0FBYyxtQkFBTyxDQUFDLHVFQUFpQjtBQUN2Qyx1Q0FBc0MsRUFBRSxxQ0FBcUMscUJBQXFCLEVBQUM7QUFDbkcseUJBQXlCLG1CQUFPLENBQUMsNkZBQTRCO0FBQzdELGtEQUFpRCxFQUFFLHFDQUFxQywyQ0FBMkMsRUFBQztBQUNwSSxzQkFBc0IsbUJBQU8sQ0FBQyx1RkFBeUI7QUFDdkQsK0NBQThDLEVBQUUscUNBQXFDLHFDQUFxQyxFQUFDO0FBQzNILHVCQUF1QixtQkFBTyxDQUFDLHlGQUEwQjtBQUN6RCxnREFBK0MsRUFBRSxxQ0FBcUMsdUNBQXVDLEVBQUM7QUFDOUgsNEJBQTRCLG1CQUFPLENBQUMsbUdBQStCO0FBQ25FLHFEQUFvRCxFQUFFLHFDQUFxQyxpREFBaUQsRUFBQztBQUM3SSxxQkFBcUIsbUJBQU8sQ0FBQyxxRkFBd0I7QUFDckQsOENBQTZDLEVBQUUscUNBQXFDLG1DQUFtQyxFQUFDO0FBQ3hILGlCQUFpQixtQkFBTyxDQUFDLDZFQUFvQjtBQUM3QywwQ0FBeUMsRUFBRSxxQ0FBcUMsMkJBQTJCLEVBQUM7QUFDNUcsdUJBQXVCLG1CQUFPLENBQUMseUZBQTBCO0FBQ3pELGdEQUErQyxFQUFFLHFDQUFxQyx1Q0FBdUMsRUFBQztBQUM5SCxtQkFBbUIsbUJBQU8sQ0FBQyxpRkFBc0I7QUFDakQsNENBQTJDLEVBQUUscUNBQXFDLCtCQUErQixFQUFDO0FBQ2xILHdCQUF3QixtQkFBTyxDQUFDLDJGQUEyQjtBQUMzRCxpREFBZ0QsRUFBRSxxQ0FBcUMseUNBQXlDLEVBQUM7QUFDakksNEJBQTRCLG1CQUFPLENBQUMsK0dBQXFDO0FBQ3pFLG9EQUFtRCxFQUFFLHFDQUFxQyxnREFBZ0QsRUFBQztBQUMzSSw0Q0FBMkMsRUFBRSxxQ0FBcUMsd0NBQXdDLEVBQUM7QUFDM0gsdUJBQXVCLG1CQUFPLENBQUMseUZBQTBCO0FBQ3pELGdEQUErQyxFQUFFLHFDQUFxQyx1Q0FBdUMsRUFBQztBQUM5SCxnQkFBZ0IsbUJBQU8sQ0FBQywyRUFBbUI7QUFDM0MseUNBQXdDLEVBQUUscUNBQXFDLHlCQUF5QixFQUFDO0FBQ3pHLHdCQUF3QixtQkFBTyxDQUFDLHVHQUFpQztBQUNqRSx3Q0FBdUMsRUFBRSxxQ0FBcUMsZ0NBQWdDLEVBQUM7QUFDL0cseUNBQXdDLEVBQUUscUNBQXFDLGlDQUFpQyxFQUFDO0FBQ2pILHVCQUF1QixtQkFBTyxDQUFDLHFHQUFnQztBQUMvRCxnREFBK0MsRUFBRSxxQ0FBcUMsdUNBQXVDLEVBQUM7QUFDOUgsZ0RBQStDLEVBQUUscUNBQXFDLHVDQUF1QyxFQUFDO0FBQzlILHNEQUFxRCxFQUFFLHFDQUFxQyw2Q0FBNkMsRUFBQztBQUMxSSw4Q0FBNkMsRUFBRSxxQ0FBcUMscUNBQXFDLEVBQUM7QUFDMUgsMENBQXlDLEVBQUUscUNBQXFDLGlDQUFpQyxFQUFDO0FBQ2xILDRCQUE0QixtQkFBTyxDQUFDLHlIQUEwQztBQUM5RSw0Q0FBMkMsRUFBRSxxQ0FBcUMsd0NBQXdDLEVBQUM7QUFDM0gsc0JBQXNCLG1CQUFPLENBQUMsMkZBQTJCO0FBQ3pELGlEQUFnRCxFQUFFLHFDQUFxQyx1Q0FBdUMsRUFBQztBQUMvSCw0Q0FBMkMsRUFBRSxxQ0FBcUMsa0NBQWtDLEVBQUM7QUFDckgscURBQW9ELEVBQUUscUNBQXFDLDJDQUEyQyxFQUFDO0FBQ3ZJLGlCQUFpQixtQkFBTyxDQUFDLDJGQUEyQjtBQUNwRCwwQ0FBeUMsRUFBRSxxQ0FBcUMsMkJBQTJCLEVBQUM7QUFDNUcsMkJBQTJCLG1CQUFPLENBQUMsbUlBQStDO0FBQ2xGLG1EQUFrRCxFQUFFLHFDQUFxQyw4Q0FBOEMsRUFBQztBQUN4SSx1REFBc0QsRUFBRSxxQ0FBcUMsa0RBQWtELEVBQUM7QUFDaEosd0RBQXVELEVBQUUscUNBQXFDLG1EQUFtRCxFQUFDO0FBQ2xKLHlCQUF5QixtQkFBTyxDQUFDLCtIQUE2QztBQUM5RSxrREFBaUQsRUFBRSxxQ0FBcUMsMkNBQTJDLEVBQUM7QUFDcEksMEJBQTBCLG1CQUFPLENBQUMsdUhBQXlDO0FBQzNFLG1EQUFrRCxFQUFFLHFDQUFxQyw2Q0FBNkMsRUFBQztBQUN2SSxrQkFBa0IsbUJBQU8sQ0FBQyx1RUFBaUI7QUFDM0MsK0NBQThDLEVBQUUscUNBQXFDLGlDQUFpQyxFQUFDO0FBQ3ZILGlEQUFnRCxFQUFFLHFDQUFxQyxtQ0FBbUMsRUFBQztBQUMzSCxrREFBaUQsRUFBRSxxQ0FBcUMsb0NBQW9DLEVBQUM7QUFDN0gsaUJBQWlCLG1CQUFPLENBQUMsdUVBQWlCO0FBQzFDLDBDQUF5QyxFQUFFLHFDQUFxQywyQkFBMkIsRUFBQztBQUM1RywwQ0FBeUMsRUFBRSxxQ0FBcUMsMkJBQTJCLEVBQUM7QUFDNUcsZUFBZSxtQkFBTyxDQUFDLGlFQUFjO0FBQ3JDLHdDQUF1QyxFQUFFLHFDQUFxQyx1QkFBdUIsRUFBQztBQUN0RyxvQkFBb0IsbUJBQU8sQ0FBQywyRUFBbUI7QUFDL0MsNkNBQTRDLEVBQUUscUNBQXFDLGlDQUFpQyxFQUFDO0FBQ3JILGtEQUFpRCxFQUFFLHFDQUFxQyxzQ0FBc0MsRUFBQztBQUMvSCxrREFBaUQsRUFBRSxxQ0FBcUMsc0NBQXNDLEVBQUM7QUFDL0gscURBQW9ELEVBQUUscUNBQXFDLHlDQUF5QyxFQUFDO0FBQ3JJLHVEQUFzRCxFQUFFLHFDQUFxQywyQ0FBMkMsRUFBQztBQUN6SSwwREFBeUQsRUFBRSxxQ0FBcUMsOENBQThDLEVBQUM7QUFDL0ksb0JBQW9CLG1CQUFPLENBQUMsbUZBQXVCO0FBQ25ELDZDQUE0QyxFQUFFLHFDQUFxQyxpQ0FBaUMsRUFBQztBQUNySCxnREFBK0MsRUFBRSxxQ0FBcUMsb0NBQW9DLEVBQUM7QUFDM0gsOEJBQThCLG1CQUFPLENBQUMseUhBQTBDO0FBQ2hGLHdEQUF1RCxFQUFFLHFDQUFxQyxzREFBc0QsRUFBQztBQUNySiw2REFBNEQsRUFBRSxxQ0FBcUMsMkRBQTJELEVBQUM7QUFDL0osOEJBQThCLG1CQUFPLENBQUMseUlBQWtEO0FBQ3hGLHVEQUFzRCxFQUFFLHFDQUFxQyxxREFBcUQsRUFBQztBQUNuSix3Q0FBd0MsbUJBQU8sQ0FBQyw2SkFBNEQ7QUFDNUcsaUVBQWdFLEVBQUUscUNBQXFDLHlFQUF5RSxFQUFDO0FBQ2pMLDhCQUE4QixtQkFBTyxDQUFDLHlIQUEwQztBQUNoRix1REFBc0QsRUFBRSxxQ0FBcUMscURBQXFELEVBQUM7QUFDbkosb0JBQW9CLG1CQUFPLENBQUMsbUZBQXVCO0FBQ25ELDZDQUE0QyxFQUFFLHFDQUFxQyxpQ0FBaUMsRUFBQztBQUNySCxxQkFBcUIsbUJBQU8sQ0FBQyxxRkFBd0I7QUFDckQsOENBQTZDLEVBQUUscUNBQXFDLG1DQUFtQyxFQUFDO0FBQ3hILHFCQUFxQixtQkFBTyxDQUFDLHFGQUF3QjtBQUNyRCw4Q0FBNkMsRUFBRSxxQ0FBcUMsbUNBQW1DLEVBQUM7QUFDeEgscUJBQXFCLG1CQUFPLENBQUMscUZBQXdCO0FBQ3JELDhDQUE2QyxFQUFFLHFDQUFxQyxtQ0FBbUMsRUFBQztBQUN4SCw0QkFBNEIsbUJBQU8sQ0FBQyxtR0FBK0I7QUFDbkUscURBQW9ELEVBQUUscUNBQXFDLGlEQUFpRCxFQUFDO0FBQzdJLHNCQUFzQixtQkFBTyxDQUFDLHVGQUF5QjtBQUN2RCwrQ0FBOEMsRUFBRSxxQ0FBcUMscUNBQXFDLEVBQUM7QUFDM0gsc0JBQXNCLG1CQUFPLENBQUMsdUZBQXlCO0FBQ3ZELCtDQUE4QyxFQUFFLHFDQUFxQyxxQ0FBcUMsRUFBQztBQUMzSCx1QkFBdUIsbUJBQU8sQ0FBQyx5RkFBMEI7QUFDekQsZ0RBQStDLEVBQUUscUNBQXFDLHVDQUF1QyxFQUFDO0FBQzlILHVCQUF1QixtQkFBTyxDQUFDLHlGQUEwQjtBQUN6RCxnREFBK0MsRUFBRSxxQ0FBcUMsdUNBQXVDLEVBQUM7QUFDOUgsK0JBQStCLG1CQUFPLENBQUMscUhBQXdDO0FBQy9FLCtDQUE4QyxFQUFFLHFDQUFxQyw4Q0FBOEMsRUFBQztBQUNwSSx3QkFBd0IsbUJBQU8sQ0FBQyw2SEFBNEM7QUFDNUUsaURBQWdELEVBQUUscUNBQXFDLHlDQUF5QyxFQUFDO0FBQ2pJLG9CQUFvQixtQkFBTyxDQUFDLHFIQUF3QztBQUNwRSw2Q0FBNEMsRUFBRSxxQ0FBcUMsaUNBQWlDLEVBQUM7QUFDckgscUJBQXFCLG1CQUFPLENBQUMsdUhBQXlDO0FBQ3RFLG1EQUFrRCxFQUFFLHFDQUFxQyx3Q0FBd0MsRUFBQztBQUNsSSxpRUFBZ0UsRUFBRSxxQ0FBcUMsc0RBQXNELEVBQUM7QUFDOUosaURBQWdELEVBQUUscUNBQXFDLHNDQUFzQyxFQUFDO0FBQzlIO0FBQ0EsY0FBYztBQUNkO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0Esb0JBQW9COzs7Ozs7Ozs7Ozs7QUN0T1A7QUFDYjtBQUNBO0FBQ0EsbUNBQW1DLG9DQUFvQyxnQkFBZ0I7QUFDdkYsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELFdBQVcsbUJBQU8sQ0FBQyxpRkFBc0I7QUFDekMsZUFBZTtBQUNmLGFBQWEsbUJBQU8sQ0FBQyxpRkFBc0I7Ozs7Ozs7Ozs7OztBQ2Q5QjtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDOzs7Ozs7Ozs7Ozs7QUMxQ25CO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGNBQWM7QUFDZCxvQkFBb0IsbUJBQU8sQ0FBQyw0REFBVztBQUN2QyxxQkFBcUIsbUJBQU8sQ0FBQyxrRkFBYztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O0FDckNhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCOzs7Ozs7Ozs7Ozs7QUN2Qkg7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsY0FBYyxHQUFHLGNBQWM7QUFDL0Isd0JBQXdCLG1CQUFPLENBQUMsOEVBQWlCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQSxjQUFjOzs7Ozs7Ozs7Ozs7QUN0RkQ7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Qsa0JBQWtCLEdBQUcsdUJBQXVCLEdBQUcsbUJBQW1CLEdBQUcsb0JBQW9CLEdBQUcscUJBQXFCLEdBQUcsaUJBQWlCLEdBQUcsaUJBQWlCO0FBQ3pKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBLG9CQUFvQixPQUFPO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0EsNkJBQTZCLFdBQVc7QUFDeEM7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLFdBQVc7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7Ozs7Ozs7Ozs7OztBQ2hFTDtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLG1CQUFtQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZOzs7Ozs7Ozs7Ozs7QUN0RUM7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Qsc0JBQXNCLEdBQUcsOEJBQThCLEdBQUcsaUJBQWlCLEdBQUcseUJBQXlCLEdBQUcsOEJBQThCLEdBQUcsMkJBQTJCLEdBQUcseUJBQXlCLEdBQUcsc0JBQXNCO0FBQzNOLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekIsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLE1BQU0sR0FBRyw4REFBOEQ7QUFDbkg7QUFDQTtBQUNBLDZDQUE2QyxXQUFXLEdBQUcsRUFBRSx1QkFBdUI7QUFDcEYsK0JBQStCLFdBQVc7QUFDMUM7QUFDQTtBQUNBLG1FQUFtRSxpQkFBaUIsU0FBUyxpQkFBaUI7QUFDOUc7QUFDQTtBQUNBLHNCQUFzQixNQUFNO0FBQzVCO0FBQ0EsdUZBQXVGLHNCQUFzQjtBQUM3RztBQUNBO0FBQ0EsNkVBQTZFLGdDQUFnQztBQUM3RztBQUNBO0FBQ0EsOEJBQThCLHFFQUFxRTtBQUNuRztBQUNBO0FBQ0E7QUFDQSxzRkFBc0YsK0JBQStCO0FBQ3JIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQSwwQkFBMEIscURBQXFEO0FBQy9FLHdDQUF3QyxHQUFHLDREQUE0RDtBQUN2RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLDhCQUE4Qix3Q0FBd0M7QUFDdEU7QUFDQSxzQ0FBc0MsaUVBQWlFLFFBQVE7QUFDL0c7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIscUVBQXFFO0FBQ25HO0FBQ0EscUZBQXFGLHNCQUFzQjtBQUMzRztBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsaUNBQWlDO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RCxxQkFBcUI7QUFDN0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4Qyx3RUFBd0U7QUFDdEg7QUFDQSw2Q0FBNkMsd0VBQXdFO0FBQ3JIO0FBQ0EsK0NBQStDLFlBQVk7QUFDM0Q7QUFDQTtBQUNBLCtDQUErQyxZQUFZO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLGlFQUFpRTtBQUNyRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyw4RUFBOEU7QUFDcEg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLFVBQVUsUUFBUSxrRkFBa0Y7QUFDOUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBLGlEQUFpRCxvQ0FBb0M7QUFDckY7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVCxpQkFBaUI7QUFDakI7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQSxzQ0FBc0Msb0NBQW9DO0FBQzFFO0FBQ0Esc0NBQXNDLHlDQUF5QztBQUMvRTtBQUNBLFNBQVM7QUFDVCxrQ0FBa0Msc0NBQXNDO0FBQ3hFO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7Ozs7Ozs7Ozs7OztBQ2pRVDtBQUNiLGtCQUFrQjtBQUNsQixtQ0FBbUM7QUFDbkMsMENBQTBDLG1CQUFPLENBQUMsMkhBQXFDO0FBQ3ZGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DOzs7Ozs7Ozs7Ozs7QUNkdEI7QUFDYixrQkFBa0I7QUFDbEIsaUNBQWlDO0FBQ2pDLHdDQUF3QyxtQkFBTyxDQUFDLHVIQUFtQztBQUNuRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQzs7Ozs7Ozs7Ozs7O0FDZHBCO0FBQ2Isa0JBQWtCO0FBQ2xCLDhCQUE4QjtBQUM5QixxQ0FBcUMsbUJBQU8sQ0FBQyxpSEFBZ0M7QUFDN0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7Ozs7Ozs7Ozs7OztBQ2RqQjtBQUNiLGtCQUFrQjtBQUNsQix5Q0FBeUM7QUFDekMsaUJBQWlCLG1CQUFPLENBQUMsNkZBQXNCO0FBQy9DLGtEQUFrRCxtQkFBTyxDQUFDLCtKQUF1RDtBQUNqSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdFQUF3RSxrQkFBa0I7QUFDMUY7QUFDQSx5Q0FBeUM7Ozs7Ozs7Ozs7OztBQ1g1QjtBQUNiLGtCQUFrQjtBQUNsQix1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsdUJBQXVCO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1Qzs7Ozs7Ozs7Ozs7O0FDMUIxQjtBQUNiLGtCQUFrQjtBQUNsQixvQ0FBb0M7QUFDcEMsNkNBQTZDLG1CQUFPLENBQUMscUpBQWtEO0FBQ3ZHLGlCQUFpQixtQkFBTyxDQUFDLDZGQUFzQjtBQUMvQyxrREFBa0QsbUJBQU8sQ0FBQywrSkFBdUQ7QUFDakgsZ0JBQWdCO0FBQ2hCLGdCQUFnQjtBQUNoQixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQzs7Ozs7Ozs7Ozs7O0FDaEN2QjtBQUNiLGtCQUFrQjtBQUNsQiwyQkFBMkIsR0FBRyw4QkFBOEIsR0FBRywyQkFBMkIsR0FBRyw4QkFBOEIsR0FBRyxnQ0FBZ0MsR0FBRyx3QkFBd0I7QUFDekw7QUFDQTtBQUNBLG1EQUFtRCw2Q0FBNkM7QUFDaEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1FQUFtRSw0QkFBNEI7QUFDL0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxZQUFZO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBLHdCQUF3QixtQkFBbUI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsNkNBQTZDO0FBQzFGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUVBQW1FLDRCQUE0QjtBQUMvRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0EsV0FBVywwREFBMEQ7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7Ozs7Ozs7Ozs7OztBQzVJZDtBQUNiLGtCQUFrQjtBQUNsQixpREFBaUQ7QUFDakQsNkNBQTZDLG1CQUFPLENBQUMsMklBQXdDO0FBQzdGO0FBQ0E7QUFDQTtBQUNBLDRCQUE0Qix1QkFBdUI7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsdUJBQXVCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQ7Ozs7Ozs7Ozs7OztBQ3hCcEM7QUFDYixrQkFBa0I7QUFDbEIsNENBQTRDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQix1QkFBdUI7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDOzs7Ozs7Ozs7Ozs7QUNyQy9CO0FBQ2Isa0JBQWtCO0FBQ2xCLHNCQUFzQixHQUFHLG9CQUFvQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7Ozs7Ozs7Ozs7OztBQzlFVDtBQUNiLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQiwrQ0FBK0M7QUFDekU7QUFDQTtBQUNBO0FBQ0EsOERBQThELCtCQUErQjtBQUM3RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQiwyQkFBMkI7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxlQUFrQjs7Ozs7Ozs7Ozs7O0FDL0VMO0FBQ2Isa0JBQWtCO0FBQ2xCLGFBQWEsR0FBRyxtQkFBbUIsR0FBRyxpQkFBaUIsR0FBRyx1QkFBdUI7QUFDakY7QUFDQTtBQUNBLHNCQUFzQixZQUFZO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxzQkFBc0IsWUFBWTtBQUNsQztBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7Ozs7Ozs7Ozs7OztBQzVCQTtBQUNiLGtCQUFrQjtBQUNsQix1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixTQUFTO0FBQ2pDLCtCQUErQixNQUFNO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7Ozs7Ozs7Ozs7OztBQ3BFVjtBQUNiLGtCQUFrQjtBQUNsQix3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixTQUFTO0FBQ2pDLCtCQUErQixNQUFNO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7Ozs7Ozs7Ozs7OztBQ3BFWDtBQUNiLGtCQUFrQjtBQUNsQixvQ0FBb0MsR0FBRyx1Q0FBdUMsR0FBRyx5Q0FBeUMsR0FBRyw4QkFBOEIsR0FBRyxpQ0FBaUMsR0FBRyxtQ0FBbUMsR0FBRyx3QkFBd0IsR0FBRyx1QkFBdUIsR0FBRyxnQkFBZ0IsR0FBRyxzQkFBc0IsR0FBRyxvQkFBb0IsR0FBRyxtQkFBbUIsR0FBRyx1QkFBdUIsR0FBRyxhQUFhLEdBQUcsaUJBQWlCLEdBQUcsb0JBQW9CLEdBQUcsaUJBQWlCLEdBQUcsY0FBYztBQUM3ZSx3QkFBd0IsbUJBQU8sQ0FBQyw4RkFBNkI7QUFDN0QsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYix1QkFBdUI7QUFDdkIsbUJBQW1CO0FBQ25CLDJCQUEyQixtQkFBTyxDQUFDLG9HQUFnQztBQUNuRSxvQkFBb0I7QUFDcEIsc0JBQXNCO0FBQ3RCLHdCQUF3QixtQkFBTyxDQUFDLDhGQUE2QjtBQUM3RCxnQkFBZ0I7QUFDaEIsaUJBQWlCLG1CQUFPLENBQUMsZ0ZBQXNCO0FBQy9DLHVCQUF1QjtBQUN2QixrQkFBa0IsbUJBQU8sQ0FBQyxrRkFBdUI7QUFDakQsd0JBQXdCO0FBQ3hCLG9DQUFvQyxtQkFBTyxDQUFDLDRIQUE0QztBQUN4RixtQ0FBbUM7QUFDbkMsa0NBQWtDLG1CQUFPLENBQUMsd0hBQTBDO0FBQ3BGLGlDQUFpQztBQUNqQywrQkFBK0IsbUJBQU8sQ0FBQyxrSEFBdUM7QUFDOUUsOEJBQThCO0FBQzlCLDBDQUEwQyxtQkFBTyxDQUFDLHdJQUFrRDtBQUNwRyx5Q0FBeUM7QUFDekMsd0NBQXdDLG1CQUFPLENBQUMsb0lBQWdEO0FBQ2hHLHVDQUF1QztBQUN2QyxxQ0FBcUMsbUJBQU8sQ0FBQyw4SEFBNkM7QUFDMUYsb0NBQW9DO0FBQ3BDO0FBQ0EsY0FBYztBQUNkO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0Esb0JBQW9COzs7Ozs7Ozs7Ozs7QUNsQ1A7QUFDYjtBQUNBO0FBQ0EsbUNBQW1DLG9DQUFvQyxnQkFBZ0I7QUFDdkYsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCLFlBQVksbUJBQU8sQ0FBQyw4RUFBcUI7QUFDekMsZUFBa0I7QUFDbEIsYUFBYSxtQkFBTyxDQUFDLDhFQUFxQjs7Ozs7OztVQ2QxQztVQUNBOztVQUVBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBOztVQUVBO1VBQ0E7O1VBRUE7VUFDQTs7VUFFQTtVQUNBO1VBQ0E7Ozs7O1dDekJBO1dBQ0E7V0FDQTtXQUNBO1dBQ0EsR0FBRztXQUNIO1dBQ0E7V0FDQSxDQUFDOzs7OztXQ1BEO1dBQ0E7V0FDQTtXQUNBLHVEQUF1RCxpQkFBaUI7V0FDeEU7V0FDQSxnREFBZ0QsYUFBYTtXQUM3RDs7Ozs7V0NOQTtXQUNBO1dBQ0E7V0FDQTtXQUNBOzs7Ozs7Ozs7Ozs7QUNKYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxZQUFZLG1CQUFPLENBQUMsNEVBQTBCO0FBQzlDLFdBQVcsbUJBQU8sQ0FBQyw0REFBYTtBQUNoQyxXQUFXLG1CQUFPLENBQUMsMEJBQUk7QUFDdkIsV0FBVyxtQkFBTyxDQUFDLG9EQUFvQjtBQUN2QyxtQkFBTyxDQUFDLGtEQUFtQjtBQUMzQixtQkFBTyxDQUFDLG9FQUF1QjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcGFyemVjLy4vbm9kZV9tb2R1bGVzL2RhZ3JlL2luZGV4LmpzIiwid2VicGFjazovL3BhcnplYy8uL25vZGVfbW9kdWxlcy9kYWdyZS9saWIvYWN5Y2xpYy5qcyIsIndlYnBhY2s6Ly9wYXJ6ZWMvLi9ub2RlX21vZHVsZXMvZGFncmUvbGliL2FkZC1ib3JkZXItc2VnbWVudHMuanMiLCJ3ZWJwYWNrOi8vcGFyemVjLy4vbm9kZV9tb2R1bGVzL2RhZ3JlL2xpYi9jb29yZGluYXRlLXN5c3RlbS5qcyIsIndlYnBhY2s6Ly9wYXJ6ZWMvLi9ub2RlX21vZHVsZXMvZGFncmUvbGliL2RhdGEvbGlzdC5qcyIsIndlYnBhY2s6Ly9wYXJ6ZWMvLi9ub2RlX21vZHVsZXMvZGFncmUvbGliL2RlYnVnLmpzIiwid2VicGFjazovL3BhcnplYy8uL25vZGVfbW9kdWxlcy9kYWdyZS9saWIvZ3JhcGhsaWIuanMiLCJ3ZWJwYWNrOi8vcGFyemVjLy4vbm9kZV9tb2R1bGVzL2RhZ3JlL2xpYi9ncmVlZHktZmFzLmpzIiwid2VicGFjazovL3BhcnplYy8uL25vZGVfbW9kdWxlcy9kYWdyZS9saWIvbGF5b3V0LmpzIiwid2VicGFjazovL3BhcnplYy8uL25vZGVfbW9kdWxlcy9kYWdyZS9saWIvbG9kYXNoLmpzIiwid2VicGFjazovL3BhcnplYy8uL25vZGVfbW9kdWxlcy9kYWdyZS9saWIvbmVzdGluZy1ncmFwaC5qcyIsIndlYnBhY2s6Ly9wYXJ6ZWMvLi9ub2RlX21vZHVsZXMvZGFncmUvbGliL25vcm1hbGl6ZS5qcyIsIndlYnBhY2s6Ly9wYXJ6ZWMvLi9ub2RlX21vZHVsZXMvZGFncmUvbGliL29yZGVyL2FkZC1zdWJncmFwaC1jb25zdHJhaW50cy5qcyIsIndlYnBhY2s6Ly9wYXJ6ZWMvLi9ub2RlX21vZHVsZXMvZGFncmUvbGliL29yZGVyL2JhcnljZW50ZXIuanMiLCJ3ZWJwYWNrOi8vcGFyemVjLy4vbm9kZV9tb2R1bGVzL2RhZ3JlL2xpYi9vcmRlci9idWlsZC1sYXllci1ncmFwaC5qcyIsIndlYnBhY2s6Ly9wYXJ6ZWMvLi9ub2RlX21vZHVsZXMvZGFncmUvbGliL29yZGVyL2Nyb3NzLWNvdW50LmpzIiwid2VicGFjazovL3BhcnplYy8uL25vZGVfbW9kdWxlcy9kYWdyZS9saWIvb3JkZXIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vcGFyemVjLy4vbm9kZV9tb2R1bGVzL2RhZ3JlL2xpYi9vcmRlci9pbml0LW9yZGVyLmpzIiwid2VicGFjazovL3BhcnplYy8uL25vZGVfbW9kdWxlcy9kYWdyZS9saWIvb3JkZXIvcmVzb2x2ZS1jb25mbGljdHMuanMiLCJ3ZWJwYWNrOi8vcGFyemVjLy4vbm9kZV9tb2R1bGVzL2RhZ3JlL2xpYi9vcmRlci9zb3J0LXN1YmdyYXBoLmpzIiwid2VicGFjazovL3BhcnplYy8uL25vZGVfbW9kdWxlcy9kYWdyZS9saWIvb3JkZXIvc29ydC5qcyIsIndlYnBhY2s6Ly9wYXJ6ZWMvLi9ub2RlX21vZHVsZXMvZGFncmUvbGliL3BhcmVudC1kdW1teS1jaGFpbnMuanMiLCJ3ZWJwYWNrOi8vcGFyemVjLy4vbm9kZV9tb2R1bGVzL2RhZ3JlL2xpYi9wb3NpdGlvbi9iay5qcyIsIndlYnBhY2s6Ly9wYXJ6ZWMvLi9ub2RlX21vZHVsZXMvZGFncmUvbGliL3Bvc2l0aW9uL2luZGV4LmpzIiwid2VicGFjazovL3BhcnplYy8uL25vZGVfbW9kdWxlcy9kYWdyZS9saWIvcmFuay9mZWFzaWJsZS10cmVlLmpzIiwid2VicGFjazovL3BhcnplYy8uL25vZGVfbW9kdWxlcy9kYWdyZS9saWIvcmFuay9pbmRleC5qcyIsIndlYnBhY2s6Ly9wYXJ6ZWMvLi9ub2RlX21vZHVsZXMvZGFncmUvbGliL3JhbmsvbmV0d29yay1zaW1wbGV4LmpzIiwid2VicGFjazovL3BhcnplYy8uL25vZGVfbW9kdWxlcy9kYWdyZS9saWIvcmFuay91dGlsLmpzIiwid2VicGFjazovL3BhcnplYy8uL25vZGVfbW9kdWxlcy9kYWdyZS9saWIvdXRpbC5qcyIsIndlYnBhY2s6Ly9wYXJ6ZWMvLi9ub2RlX21vZHVsZXMvZGFncmUvbGliL3ZlcnNpb24uanMiLCJ3ZWJwYWNrOi8vcGFyemVjLy4vbm9kZV9tb2R1bGVzL2dyYXBobGliL2luZGV4LmpzIiwid2VicGFjazovL3BhcnplYy8uL25vZGVfbW9kdWxlcy9ncmFwaGxpYi9saWIvYWxnL2NvbXBvbmVudHMuanMiLCJ3ZWJwYWNrOi8vcGFyemVjLy4vbm9kZV9tb2R1bGVzL2dyYXBobGliL2xpYi9hbGcvZGZzLmpzIiwid2VicGFjazovL3BhcnplYy8uL25vZGVfbW9kdWxlcy9ncmFwaGxpYi9saWIvYWxnL2RpamtzdHJhLWFsbC5qcyIsIndlYnBhY2s6Ly9wYXJ6ZWMvLi9ub2RlX21vZHVsZXMvZ3JhcGhsaWIvbGliL2FsZy9kaWprc3RyYS5qcyIsIndlYnBhY2s6Ly9wYXJ6ZWMvLi9ub2RlX21vZHVsZXMvZ3JhcGhsaWIvbGliL2FsZy9maW5kLWN5Y2xlcy5qcyIsIndlYnBhY2s6Ly9wYXJ6ZWMvLi9ub2RlX21vZHVsZXMvZ3JhcGhsaWIvbGliL2FsZy9mbG95ZC13YXJzaGFsbC5qcyIsIndlYnBhY2s6Ly9wYXJ6ZWMvLi9ub2RlX21vZHVsZXMvZ3JhcGhsaWIvbGliL2FsZy9pbmRleC5qcyIsIndlYnBhY2s6Ly9wYXJ6ZWMvLi9ub2RlX21vZHVsZXMvZ3JhcGhsaWIvbGliL2FsZy9pcy1hY3ljbGljLmpzIiwid2VicGFjazovL3BhcnplYy8uL25vZGVfbW9kdWxlcy9ncmFwaGxpYi9saWIvYWxnL3Bvc3RvcmRlci5qcyIsIndlYnBhY2s6Ly9wYXJ6ZWMvLi9ub2RlX21vZHVsZXMvZ3JhcGhsaWIvbGliL2FsZy9wcmVvcmRlci5qcyIsIndlYnBhY2s6Ly9wYXJ6ZWMvLi9ub2RlX21vZHVsZXMvZ3JhcGhsaWIvbGliL2FsZy9wcmltLmpzIiwid2VicGFjazovL3BhcnplYy8uL25vZGVfbW9kdWxlcy9ncmFwaGxpYi9saWIvYWxnL3Rhcmphbi5qcyIsIndlYnBhY2s6Ly9wYXJ6ZWMvLi9ub2RlX21vZHVsZXMvZ3JhcGhsaWIvbGliL2FsZy90b3Bzb3J0LmpzIiwid2VicGFjazovL3BhcnplYy8uL25vZGVfbW9kdWxlcy9ncmFwaGxpYi9saWIvZGF0YS9wcmlvcml0eS1xdWV1ZS5qcyIsIndlYnBhY2s6Ly9wYXJ6ZWMvLi9ub2RlX21vZHVsZXMvZ3JhcGhsaWIvbGliL2dyYXBoLmpzIiwid2VicGFjazovL3BhcnplYy8uL25vZGVfbW9kdWxlcy9ncmFwaGxpYi9saWIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vcGFyemVjLy4vbm9kZV9tb2R1bGVzL2dyYXBobGliL2xpYi9qc29uLmpzIiwid2VicGFjazovL3BhcnplYy8uL25vZGVfbW9kdWxlcy9ncmFwaGxpYi9saWIvbG9kYXNoLmpzIiwid2VicGFjazovL3BhcnplYy8uL25vZGVfbW9kdWxlcy9ncmFwaGxpYi9saWIvdmVyc2lvbi5qcyIsIndlYnBhY2s6Ly9wYXJ6ZWMvLi9ub2RlX21vZHVsZXMvbGl0cy1leHRyYXMvbGliL2RlcGVuZGVuY3ktZGlhZy5qcyIsIndlYnBhY2s6Ly9wYXJ6ZWMvLi9ub2RlX21vZHVsZXMvbGl0cy1leHRyYXMvbGliL2luZGV4LmpzIiwid2VicGFjazovL3BhcnplYy8uL25vZGVfbW9kdWxlcy9saXRzLWV4dHJhcy9saWIvdGVzdC1yZXBvcnRlci5qcyIsIndlYnBhY2s6Ly9wYXJ6ZWMvLi9ub2RlX21vZHVsZXMvbGl0cy1leHRyYXMvbGliL3Rlc3QtdmlzdWFsaXplci5qcyIsIndlYnBhY2s6Ly9wYXJ6ZWMvLi9ub2RlX21vZHVsZXMvbGl0cy1leHRyYXMvbGliL3Rlc3Rlci5qcyIsIndlYnBhY2s6Ly9wYXJ6ZWMvLi9ub2RlX21vZHVsZXMvbGl0c2NyaXB0L2xpYi92aXN1YWxpemVyLmpzIiwid2VicGFjazovL3BhcnplYy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX0RhdGFWaWV3LmpzIiwid2VicGFjazovL3BhcnplYy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX0hhc2guanMiLCJ3ZWJwYWNrOi8vcGFyemVjLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fTGlzdENhY2hlLmpzIiwid2VicGFjazovL3BhcnplYy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX01hcC5qcyIsIndlYnBhY2s6Ly9wYXJ6ZWMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19NYXBDYWNoZS5qcyIsIndlYnBhY2s6Ly9wYXJ6ZWMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19Qcm9taXNlLmpzIiwid2VicGFjazovL3BhcnplYy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX1NldC5qcyIsIndlYnBhY2s6Ly9wYXJ6ZWMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19TZXRDYWNoZS5qcyIsIndlYnBhY2s6Ly9wYXJ6ZWMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19TdGFjay5qcyIsIndlYnBhY2s6Ly9wYXJ6ZWMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19TeW1ib2wuanMiLCJ3ZWJwYWNrOi8vcGFyemVjLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fVWludDhBcnJheS5qcyIsIndlYnBhY2s6Ly9wYXJ6ZWMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19XZWFrTWFwLmpzIiwid2VicGFjazovL3BhcnplYy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2FwcGx5LmpzIiwid2VicGFjazovL3BhcnplYy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2FycmF5RWFjaC5qcyIsIndlYnBhY2s6Ly9wYXJ6ZWMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19hcnJheUZpbHRlci5qcyIsIndlYnBhY2s6Ly9wYXJ6ZWMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19hcnJheUluY2x1ZGVzLmpzIiwid2VicGFjazovL3BhcnplYy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2FycmF5SW5jbHVkZXNXaXRoLmpzIiwid2VicGFjazovL3BhcnplYy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2FycmF5TGlrZUtleXMuanMiLCJ3ZWJwYWNrOi8vcGFyemVjLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYXJyYXlNYXAuanMiLCJ3ZWJwYWNrOi8vcGFyemVjLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYXJyYXlQdXNoLmpzIiwid2VicGFjazovL3BhcnplYy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2FycmF5UmVkdWNlLmpzIiwid2VicGFjazovL3BhcnplYy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2FycmF5U29tZS5qcyIsIndlYnBhY2s6Ly9wYXJ6ZWMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19hc2NpaVNpemUuanMiLCJ3ZWJwYWNrOi8vcGFyemVjLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYXNzaWduTWVyZ2VWYWx1ZS5qcyIsIndlYnBhY2s6Ly9wYXJ6ZWMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19hc3NpZ25WYWx1ZS5qcyIsIndlYnBhY2s6Ly9wYXJ6ZWMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19hc3NvY0luZGV4T2YuanMiLCJ3ZWJwYWNrOi8vcGFyemVjLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUFzc2lnbi5qcyIsIndlYnBhY2s6Ly9wYXJ6ZWMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlQXNzaWduSW4uanMiLCJ3ZWJwYWNrOi8vcGFyemVjLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUFzc2lnblZhbHVlLmpzIiwid2VicGFjazovL3BhcnplYy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VDbG9uZS5qcyIsIndlYnBhY2s6Ly9wYXJ6ZWMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlQ3JlYXRlLmpzIiwid2VicGFjazovL3BhcnplYy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VFYWNoLmpzIiwid2VicGFjazovL3BhcnplYy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VFeHRyZW11bS5qcyIsIndlYnBhY2s6Ly9wYXJ6ZWMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlRmlsdGVyLmpzIiwid2VicGFjazovL3BhcnplYy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VGaW5kSW5kZXguanMiLCJ3ZWJwYWNrOi8vcGFyemVjLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUZsYXR0ZW4uanMiLCJ3ZWJwYWNrOi8vcGFyemVjLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUZvci5qcyIsIndlYnBhY2s6Ly9wYXJ6ZWMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlRm9yT3duLmpzIiwid2VicGFjazovL3BhcnplYy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VHZXQuanMiLCJ3ZWJwYWNrOi8vcGFyemVjLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUdldEFsbEtleXMuanMiLCJ3ZWJwYWNrOi8vcGFyemVjLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUdldFRhZy5qcyIsIndlYnBhY2s6Ly9wYXJ6ZWMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlR3QuanMiLCJ3ZWJwYWNrOi8vcGFyemVjLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUhhcy5qcyIsIndlYnBhY2s6Ly9wYXJ6ZWMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlSGFzSW4uanMiLCJ3ZWJwYWNrOi8vcGFyemVjLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUluZGV4T2YuanMiLCJ3ZWJwYWNrOi8vcGFyemVjLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUlzQXJndW1lbnRzLmpzIiwid2VicGFjazovL3BhcnplYy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VJc0VxdWFsLmpzIiwid2VicGFjazovL3BhcnplYy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VJc0VxdWFsRGVlcC5qcyIsIndlYnBhY2s6Ly9wYXJ6ZWMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlSXNNYXAuanMiLCJ3ZWJwYWNrOi8vcGFyemVjLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUlzTWF0Y2guanMiLCJ3ZWJwYWNrOi8vcGFyemVjLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUlzTmFOLmpzIiwid2VicGFjazovL3BhcnplYy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VJc05hdGl2ZS5qcyIsIndlYnBhY2s6Ly9wYXJ6ZWMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlSXNTZXQuanMiLCJ3ZWJwYWNrOi8vcGFyemVjLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUlzVHlwZWRBcnJheS5qcyIsIndlYnBhY2s6Ly9wYXJ6ZWMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlSXRlcmF0ZWUuanMiLCJ3ZWJwYWNrOi8vcGFyemVjLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUtleXMuanMiLCJ3ZWJwYWNrOi8vcGFyemVjLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUtleXNJbi5qcyIsIndlYnBhY2s6Ly9wYXJ6ZWMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlTHQuanMiLCJ3ZWJwYWNrOi8vcGFyemVjLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZU1hcC5qcyIsIndlYnBhY2s6Ly9wYXJ6ZWMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlTWF0Y2hlcy5qcyIsIndlYnBhY2s6Ly9wYXJ6ZWMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlTWF0Y2hlc1Byb3BlcnR5LmpzIiwid2VicGFjazovL3BhcnplYy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VNZXJnZS5qcyIsIndlYnBhY2s6Ly9wYXJ6ZWMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlTWVyZ2VEZWVwLmpzIiwid2VicGFjazovL3BhcnplYy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VPcmRlckJ5LmpzIiwid2VicGFjazovL3BhcnplYy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VQaWNrLmpzIiwid2VicGFjazovL3BhcnplYy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VQaWNrQnkuanMiLCJ3ZWJwYWNrOi8vcGFyemVjLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZVByb3BlcnR5LmpzIiwid2VicGFjazovL3BhcnplYy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VQcm9wZXJ0eURlZXAuanMiLCJ3ZWJwYWNrOi8vcGFyemVjLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZVJhbmdlLmpzIiwid2VicGFjazovL3BhcnplYy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VSZWR1Y2UuanMiLCJ3ZWJwYWNrOi8vcGFyemVjLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZVJlc3QuanMiLCJ3ZWJwYWNrOi8vcGFyemVjLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZVNldC5qcyIsIndlYnBhY2s6Ly9wYXJ6ZWMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlU2V0VG9TdHJpbmcuanMiLCJ3ZWJwYWNrOi8vcGFyemVjLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZVNvcnRCeS5qcyIsIndlYnBhY2s6Ly9wYXJ6ZWMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlVGltZXMuanMiLCJ3ZWJwYWNrOi8vcGFyemVjLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZVRvU3RyaW5nLmpzIiwid2VicGFjazovL3BhcnplYy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VUcmltLmpzIiwid2VicGFjazovL3BhcnplYy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VVbmFyeS5qcyIsIndlYnBhY2s6Ly9wYXJ6ZWMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlVW5pcS5qcyIsIndlYnBhY2s6Ly9wYXJ6ZWMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlVmFsdWVzLmpzIiwid2VicGFjazovL3BhcnplYy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VaaXBPYmplY3QuanMiLCJ3ZWJwYWNrOi8vcGFyemVjLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fY2FjaGVIYXMuanMiLCJ3ZWJwYWNrOi8vcGFyemVjLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fY2FzdEZ1bmN0aW9uLmpzIiwid2VicGFjazovL3BhcnplYy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Nhc3RQYXRoLmpzIiwid2VicGFjazovL3BhcnplYy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Nsb25lQXJyYXlCdWZmZXIuanMiLCJ3ZWJwYWNrOi8vcGFyemVjLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fY2xvbmVCdWZmZXIuanMiLCJ3ZWJwYWNrOi8vcGFyemVjLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fY2xvbmVEYXRhVmlldy5qcyIsIndlYnBhY2s6Ly9wYXJ6ZWMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19jbG9uZVJlZ0V4cC5qcyIsIndlYnBhY2s6Ly9wYXJ6ZWMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19jbG9uZVN5bWJvbC5qcyIsIndlYnBhY2s6Ly9wYXJ6ZWMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19jbG9uZVR5cGVkQXJyYXkuanMiLCJ3ZWJwYWNrOi8vcGFyemVjLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fY29tcGFyZUFzY2VuZGluZy5qcyIsIndlYnBhY2s6Ly9wYXJ6ZWMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19jb21wYXJlTXVsdGlwbGUuanMiLCJ3ZWJwYWNrOi8vcGFyemVjLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fY29weUFycmF5LmpzIiwid2VicGFjazovL3BhcnplYy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2NvcHlPYmplY3QuanMiLCJ3ZWJwYWNrOi8vcGFyemVjLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fY29weVN5bWJvbHMuanMiLCJ3ZWJwYWNrOi8vcGFyemVjLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fY29weVN5bWJvbHNJbi5qcyIsIndlYnBhY2s6Ly9wYXJ6ZWMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19jb3JlSnNEYXRhLmpzIiwid2VicGFjazovL3BhcnplYy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2NyZWF0ZUFzc2lnbmVyLmpzIiwid2VicGFjazovL3BhcnplYy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2NyZWF0ZUJhc2VFYWNoLmpzIiwid2VicGFjazovL3BhcnplYy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2NyZWF0ZUJhc2VGb3IuanMiLCJ3ZWJwYWNrOi8vcGFyemVjLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fY3JlYXRlRmluZC5qcyIsIndlYnBhY2s6Ly9wYXJ6ZWMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19jcmVhdGVSYW5nZS5qcyIsIndlYnBhY2s6Ly9wYXJ6ZWMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19jcmVhdGVTZXQuanMiLCJ3ZWJwYWNrOi8vcGFyemVjLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fZGVmaW5lUHJvcGVydHkuanMiLCJ3ZWJwYWNrOi8vcGFyemVjLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fZXF1YWxBcnJheXMuanMiLCJ3ZWJwYWNrOi8vcGFyemVjLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fZXF1YWxCeVRhZy5qcyIsIndlYnBhY2s6Ly9wYXJ6ZWMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19lcXVhbE9iamVjdHMuanMiLCJ3ZWJwYWNrOi8vcGFyemVjLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fZmxhdFJlc3QuanMiLCJ3ZWJwYWNrOi8vcGFyemVjLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fZnJlZUdsb2JhbC5qcyIsIndlYnBhY2s6Ly9wYXJ6ZWMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19nZXRBbGxLZXlzLmpzIiwid2VicGFjazovL3BhcnplYy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2dldEFsbEtleXNJbi5qcyIsIndlYnBhY2s6Ly9wYXJ6ZWMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19nZXRNYXBEYXRhLmpzIiwid2VicGFjazovL3BhcnplYy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2dldE1hdGNoRGF0YS5qcyIsIndlYnBhY2s6Ly9wYXJ6ZWMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19nZXROYXRpdmUuanMiLCJ3ZWJwYWNrOi8vcGFyemVjLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fZ2V0UHJvdG90eXBlLmpzIiwid2VicGFjazovL3BhcnplYy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2dldFJhd1RhZy5qcyIsIndlYnBhY2s6Ly9wYXJ6ZWMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19nZXRTeW1ib2xzLmpzIiwid2VicGFjazovL3BhcnplYy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2dldFN5bWJvbHNJbi5qcyIsIndlYnBhY2s6Ly9wYXJ6ZWMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19nZXRUYWcuanMiLCJ3ZWJwYWNrOi8vcGFyemVjLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fZ2V0VmFsdWUuanMiLCJ3ZWJwYWNrOi8vcGFyemVjLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9faGFzUGF0aC5qcyIsIndlYnBhY2s6Ly9wYXJ6ZWMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19oYXNVbmljb2RlLmpzIiwid2VicGFjazovL3BhcnplYy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2hhc2hDbGVhci5qcyIsIndlYnBhY2s6Ly9wYXJ6ZWMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19oYXNoRGVsZXRlLmpzIiwid2VicGFjazovL3BhcnplYy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2hhc2hHZXQuanMiLCJ3ZWJwYWNrOi8vcGFyemVjLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9faGFzaEhhcy5qcyIsIndlYnBhY2s6Ly9wYXJ6ZWMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19oYXNoU2V0LmpzIiwid2VicGFjazovL3BhcnplYy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2luaXRDbG9uZUFycmF5LmpzIiwid2VicGFjazovL3BhcnplYy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2luaXRDbG9uZUJ5VGFnLmpzIiwid2VicGFjazovL3BhcnplYy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2luaXRDbG9uZU9iamVjdC5qcyIsIndlYnBhY2s6Ly9wYXJ6ZWMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19pc0ZsYXR0ZW5hYmxlLmpzIiwid2VicGFjazovL3BhcnplYy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2lzSW5kZXguanMiLCJ3ZWJwYWNrOi8vcGFyemVjLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9faXNJdGVyYXRlZUNhbGwuanMiLCJ3ZWJwYWNrOi8vcGFyemVjLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9faXNLZXkuanMiLCJ3ZWJwYWNrOi8vcGFyemVjLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9faXNLZXlhYmxlLmpzIiwid2VicGFjazovL3BhcnplYy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2lzTWFza2VkLmpzIiwid2VicGFjazovL3BhcnplYy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2lzUHJvdG90eXBlLmpzIiwid2VicGFjazovL3BhcnplYy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2lzU3RyaWN0Q29tcGFyYWJsZS5qcyIsIndlYnBhY2s6Ly9wYXJ6ZWMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19saXN0Q2FjaGVDbGVhci5qcyIsIndlYnBhY2s6Ly9wYXJ6ZWMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19saXN0Q2FjaGVEZWxldGUuanMiLCJ3ZWJwYWNrOi8vcGFyemVjLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fbGlzdENhY2hlR2V0LmpzIiwid2VicGFjazovL3BhcnplYy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2xpc3RDYWNoZUhhcy5qcyIsIndlYnBhY2s6Ly9wYXJ6ZWMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19saXN0Q2FjaGVTZXQuanMiLCJ3ZWJwYWNrOi8vcGFyemVjLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fbWFwQ2FjaGVDbGVhci5qcyIsIndlYnBhY2s6Ly9wYXJ6ZWMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19tYXBDYWNoZURlbGV0ZS5qcyIsIndlYnBhY2s6Ly9wYXJ6ZWMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19tYXBDYWNoZUdldC5qcyIsIndlYnBhY2s6Ly9wYXJ6ZWMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19tYXBDYWNoZUhhcy5qcyIsIndlYnBhY2s6Ly9wYXJ6ZWMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19tYXBDYWNoZVNldC5qcyIsIndlYnBhY2s6Ly9wYXJ6ZWMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19tYXBUb0FycmF5LmpzIiwid2VicGFjazovL3BhcnplYy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX21hdGNoZXNTdHJpY3RDb21wYXJhYmxlLmpzIiwid2VicGFjazovL3BhcnplYy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX21lbW9pemVDYXBwZWQuanMiLCJ3ZWJwYWNrOi8vcGFyemVjLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fbmF0aXZlQ3JlYXRlLmpzIiwid2VicGFjazovL3BhcnplYy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX25hdGl2ZUtleXMuanMiLCJ3ZWJwYWNrOi8vcGFyemVjLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fbmF0aXZlS2V5c0luLmpzIiwid2VicGFjazovL3BhcnplYy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX25vZGVVdGlsLmpzIiwid2VicGFjazovL3BhcnplYy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX29iamVjdFRvU3RyaW5nLmpzIiwid2VicGFjazovL3BhcnplYy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX292ZXJBcmcuanMiLCJ3ZWJwYWNrOi8vcGFyemVjLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fb3ZlclJlc3QuanMiLCJ3ZWJwYWNrOi8vcGFyemVjLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fcm9vdC5qcyIsIndlYnBhY2s6Ly9wYXJ6ZWMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19zYWZlR2V0LmpzIiwid2VicGFjazovL3BhcnplYy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX3NldENhY2hlQWRkLmpzIiwid2VicGFjazovL3BhcnplYy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX3NldENhY2hlSGFzLmpzIiwid2VicGFjazovL3BhcnplYy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX3NldFRvQXJyYXkuanMiLCJ3ZWJwYWNrOi8vcGFyemVjLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fc2V0VG9TdHJpbmcuanMiLCJ3ZWJwYWNrOi8vcGFyemVjLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fc2hvcnRPdXQuanMiLCJ3ZWJwYWNrOi8vcGFyemVjLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fc3RhY2tDbGVhci5qcyIsIndlYnBhY2s6Ly9wYXJ6ZWMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19zdGFja0RlbGV0ZS5qcyIsIndlYnBhY2s6Ly9wYXJ6ZWMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19zdGFja0dldC5qcyIsIndlYnBhY2s6Ly9wYXJ6ZWMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19zdGFja0hhcy5qcyIsIndlYnBhY2s6Ly9wYXJ6ZWMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19zdGFja1NldC5qcyIsIndlYnBhY2s6Ly9wYXJ6ZWMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19zdHJpY3RJbmRleE9mLmpzIiwid2VicGFjazovL3BhcnplYy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX3N0cmluZ1NpemUuanMiLCJ3ZWJwYWNrOi8vcGFyemVjLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fc3RyaW5nVG9QYXRoLmpzIiwid2VicGFjazovL3BhcnplYy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX3RvS2V5LmpzIiwid2VicGFjazovL3BhcnplYy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX3RvU291cmNlLmpzIiwid2VicGFjazovL3BhcnplYy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX3RyaW1tZWRFbmRJbmRleC5qcyIsIndlYnBhY2s6Ly9wYXJ6ZWMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL191bmljb2RlU2l6ZS5qcyIsIndlYnBhY2s6Ly9wYXJ6ZWMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL2Nsb25lLmpzIiwid2VicGFjazovL3BhcnplYy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvY2xvbmVEZWVwLmpzIiwid2VicGFjazovL3BhcnplYy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvY29uc3RhbnQuanMiLCJ3ZWJwYWNrOi8vcGFyemVjLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9kZWZhdWx0cy5qcyIsIndlYnBhY2s6Ly9wYXJ6ZWMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL2VhY2guanMiLCJ3ZWJwYWNrOi8vcGFyemVjLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9lcS5qcyIsIndlYnBhY2s6Ly9wYXJ6ZWMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL2ZpbHRlci5qcyIsIndlYnBhY2s6Ly9wYXJ6ZWMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL2ZpbmQuanMiLCJ3ZWJwYWNrOi8vcGFyemVjLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9maW5kSW5kZXguanMiLCJ3ZWJwYWNrOi8vcGFyemVjLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9mbGF0dGVuLmpzIiwid2VicGFjazovL3BhcnplYy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvZm9yRWFjaC5qcyIsIndlYnBhY2s6Ly9wYXJ6ZWMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL2ZvckluLmpzIiwid2VicGFjazovL3BhcnplYy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvZ2V0LmpzIiwid2VicGFjazovL3BhcnplYy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvaGFzLmpzIiwid2VicGFjazovL3BhcnplYy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvaGFzSW4uanMiLCJ3ZWJwYWNrOi8vcGFyemVjLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9pZGVudGl0eS5qcyIsIndlYnBhY2s6Ly9wYXJ6ZWMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL2lzQXJndW1lbnRzLmpzIiwid2VicGFjazovL3BhcnplYy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvaXNBcnJheS5qcyIsIndlYnBhY2s6Ly9wYXJ6ZWMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL2lzQXJyYXlMaWtlLmpzIiwid2VicGFjazovL3BhcnplYy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvaXNBcnJheUxpa2VPYmplY3QuanMiLCJ3ZWJwYWNrOi8vcGFyemVjLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9pc0J1ZmZlci5qcyIsIndlYnBhY2s6Ly9wYXJ6ZWMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL2lzRW1wdHkuanMiLCJ3ZWJwYWNrOi8vcGFyemVjLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9pc0Z1bmN0aW9uLmpzIiwid2VicGFjazovL3BhcnplYy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvaXNMZW5ndGguanMiLCJ3ZWJwYWNrOi8vcGFyemVjLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9pc01hcC5qcyIsIndlYnBhY2s6Ly9wYXJ6ZWMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL2lzT2JqZWN0LmpzIiwid2VicGFjazovL3BhcnplYy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvaXNPYmplY3RMaWtlLmpzIiwid2VicGFjazovL3BhcnplYy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvaXNQbGFpbk9iamVjdC5qcyIsIndlYnBhY2s6Ly9wYXJ6ZWMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL2lzU2V0LmpzIiwid2VicGFjazovL3BhcnplYy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvaXNTdHJpbmcuanMiLCJ3ZWJwYWNrOi8vcGFyemVjLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9pc1N5bWJvbC5qcyIsIndlYnBhY2s6Ly9wYXJ6ZWMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL2lzVHlwZWRBcnJheS5qcyIsIndlYnBhY2s6Ly9wYXJ6ZWMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL2lzVW5kZWZpbmVkLmpzIiwid2VicGFjazovL3BhcnplYy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gva2V5cy5qcyIsIndlYnBhY2s6Ly9wYXJ6ZWMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL2tleXNJbi5qcyIsIndlYnBhY2s6Ly9wYXJ6ZWMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL2xhc3QuanMiLCJ3ZWJwYWNrOi8vcGFyemVjLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9tYXAuanMiLCJ3ZWJwYWNrOi8vcGFyemVjLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9tYXBWYWx1ZXMuanMiLCJ3ZWJwYWNrOi8vcGFyemVjLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9tYXguanMiLCJ3ZWJwYWNrOi8vcGFyemVjLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9tZW1vaXplLmpzIiwid2VicGFjazovL3BhcnplYy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvbWVyZ2UuanMiLCJ3ZWJwYWNrOi8vcGFyemVjLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9taW4uanMiLCJ3ZWJwYWNrOi8vcGFyemVjLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9taW5CeS5qcyIsIndlYnBhY2s6Ly9wYXJ6ZWMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL25vb3AuanMiLCJ3ZWJwYWNrOi8vcGFyemVjLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9ub3cuanMiLCJ3ZWJwYWNrOi8vcGFyemVjLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9waWNrLmpzIiwid2VicGFjazovL3BhcnplYy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvcHJvcGVydHkuanMiLCJ3ZWJwYWNrOi8vcGFyemVjLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9yYW5nZS5qcyIsIndlYnBhY2s6Ly9wYXJ6ZWMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL3JlZHVjZS5qcyIsIndlYnBhY2s6Ly9wYXJ6ZWMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL3NpemUuanMiLCJ3ZWJwYWNrOi8vcGFyemVjLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9zb3J0QnkuanMiLCJ3ZWJwYWNrOi8vcGFyemVjLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9zdHViQXJyYXkuanMiLCJ3ZWJwYWNrOi8vcGFyemVjLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9zdHViRmFsc2UuanMiLCJ3ZWJwYWNrOi8vcGFyemVjLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC90b0Zpbml0ZS5qcyIsIndlYnBhY2s6Ly9wYXJ6ZWMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL3RvSW50ZWdlci5qcyIsIndlYnBhY2s6Ly9wYXJ6ZWMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL3RvTnVtYmVyLmpzIiwid2VicGFjazovL3BhcnplYy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvdG9QbGFpbk9iamVjdC5qcyIsIndlYnBhY2s6Ly9wYXJ6ZWMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL3RvU3RyaW5nLmpzIiwid2VicGFjazovL3BhcnplYy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvdHJhbnNmb3JtLmpzIiwid2VicGFjazovL3BhcnplYy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvdW5pb24uanMiLCJ3ZWJwYWNrOi8vcGFyemVjLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC91bmlxdWVJZC5qcyIsIndlYnBhY2s6Ly9wYXJ6ZWMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL3ZhbHVlcy5qcyIsIndlYnBhY2s6Ly9wYXJ6ZWMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL3ppcE9iamVjdC5qcyIsIndlYnBhY2s6Ly9wYXJ6ZWMvLi9zcmMvdmlzdWFsaXplcnMvcnVuLWpzb24tdGVzdHMubGVzcz9hYjAzIiwid2VicGFjazovL3BhcnplYy8uL25vZGVfbW9kdWxlcy90YWl0dG8vbGliL2FuaW0vYW5pbS5qcyIsIndlYnBhY2s6Ly9wYXJ6ZWMvLi9ub2RlX21vZHVsZXMvdGFpdHRvL2xpYi9hbmltL2FuaW1hdGVkLXZpZXcuanMiLCJ3ZWJwYWNrOi8vcGFyemVjLy4vbm9kZV9tb2R1bGVzL3RhaXR0by9saWIvYW5pbS9hbmltYXRlZC5qcyIsIndlYnBhY2s6Ly9wYXJ6ZWMvLi9ub2RlX21vZHVsZXMvdGFpdHRvL2xpYi9hbmltL2N1c3RvbS1hbmltLmpzIiwid2VicGFjazovL3BhcnplYy8uL25vZGVfbW9kdWxlcy90YWl0dG8vbGliL2FuaW0vaW5kZXguanMiLCJ3ZWJwYWNrOi8vcGFyemVjLy4vbm9kZV9tb2R1bGVzL3RhaXR0by9saWIvYW5pbS9rZXlmcmFtZS1hbmltLmpzIiwid2VicGFjazovL3BhcnplYy8uL25vZGVfbW9kdWxlcy90YWl0dG8vbGliL2RpZ3JhcGguanMiLCJ3ZWJwYWNrOi8vcGFyemVjLy4vbm9kZV9tb2R1bGVzL3RhaXR0by9saWIvZmlsZS1kaWFncmFtLmpzIiwid2VicGFjazovL3BhcnplYy8uL25vZGVfbW9kdWxlcy90YWl0dG8vbGliL2luZGV4LmpzIiwid2VicGFjazovL3BhcnplYy8uL25vZGVfbW9kdWxlcy90YWl0dG8vbGliL3N2Zy9lbGVtLmpzIiwid2VicGFjazovL3BhcnplYy8uL25vZGVfbW9kdWxlcy90YWl0dG8vbGliL3N2Zy9maWx0ZXIuanMiLCJ3ZWJwYWNrOi8vcGFyemVjLy4vbm9kZV9tb2R1bGVzL3RhaXR0by9saWIvc3ZnL2luZGV4LmpzIiwid2VicGFjazovL3BhcnplYy8uL25vZGVfbW9kdWxlcy90YWl0dG8vbGliL3N2Zy9tYXJrZXIuanMiLCJ3ZWJwYWNrOi8vcGFyemVjLy4vbm9kZV9tb2R1bGVzL3RhaXR0by9saWIvc3ZnL3BhdGguanMiLCJ3ZWJwYWNrOi8vcGFyemVjLy4vbm9kZV9tb2R1bGVzL3RhaXR0by9saWIvc3ZnL3JlY3QuanMiLCJ3ZWJwYWNrOi8vcGFyemVjLy4vbm9kZV9tb2R1bGVzL3RhaXR0by9saWIvc3ZnL3RleHQuanMiLCJ3ZWJwYWNrOi8vcGFyemVjLy4vbm9kZV9tb2R1bGVzL3RhaXR0by9saWIvc3ZnL3ZlY3Rvci5qcyIsIndlYnBhY2s6Ly9wYXJ6ZWMvLi9zcmMvYXJyYXlwYXJzZXJzLnRzIiwid2VicGFjazovL3BhcnplYy8uL3NyYy9lcnJvci50cyIsIndlYnBhY2s6Ly9wYXJ6ZWMvLi9zcmMvaW5kZXgudHMiLCJ3ZWJwYWNrOi8vcGFyemVjLy4vc3JjL2lucHV0LnRzIiwid2VicGFjazovL3BhcnplYy8uL3NyYy9sZXhlci50cyIsIndlYnBhY2s6Ly9wYXJ6ZWMvLi9zcmMvcGFyc2VyLnRzIiwid2VicGFjazovL3BhcnplYy8uL3NyYy9yZWYudHMiLCJ3ZWJwYWNrOi8vcGFyemVjLy4vc3JjL3Jlc3VsdC50cyIsIndlYnBhY2s6Ly9wYXJ6ZWMvLi9zcmMvdGVzdC9qc29ucGFyc2VyLnRzIiwid2VicGFjazovL3BhcnplYy8uL3NyYy90ZXN0L2pzb250ZXN0cy50cyIsIndlYnBhY2s6Ly9wYXJ6ZWMvLi9zcmMvdXRpbHMudHMiLCJ3ZWJwYWNrOi8vcGFyemVjLy4vbm9kZV9tb2R1bGVzL3pvcmEvZGlzdC9idW5kbGUvaW5kZXguanMiLCJ3ZWJwYWNrOi8vcGFyemVjLy4vbm9kZV9tb2R1bGVzL2Zhc3QtY2hlY2svbGliL2FyYml0cmFyeS9faW50ZXJuYWxzL0FycmF5QXJiaXRyYXJ5LmpzIiwid2VicGFjazovL3BhcnplYy8uL25vZGVfbW9kdWxlcy9mYXN0LWNoZWNrL2xpYi9hcmJpdHJhcnkvX2ludGVybmFscy9CaWdJbnRBcmJpdHJhcnkuanMiLCJ3ZWJwYWNrOi8vcGFyemVjLy4vbm9kZV9tb2R1bGVzL2Zhc3QtY2hlY2svbGliL2FyYml0cmFyeS9faW50ZXJuYWxzL0Nsb25lQXJiaXRyYXJ5LmpzIiwid2VicGFjazovL3BhcnplYy8uL25vZGVfbW9kdWxlcy9mYXN0LWNoZWNrL2xpYi9hcmJpdHJhcnkvX2ludGVybmFscy9Db25zdGFudEFyYml0cmFyeS5qcyIsIndlYnBhY2s6Ly9wYXJ6ZWMvLi9ub2RlX21vZHVsZXMvZmFzdC1jaGVjay9saWIvYXJiaXRyYXJ5L19pbnRlcm5hbHMvRnJlcXVlbmN5QXJiaXRyYXJ5LmpzIiwid2VicGFjazovL3BhcnplYy8uL25vZGVfbW9kdWxlcy9mYXN0LWNoZWNrL2xpYi9hcmJpdHJhcnkvX2ludGVybmFscy9JbnRlZ2VyQXJiaXRyYXJ5LmpzIiwid2VicGFjazovL3BhcnplYy8uL25vZGVfbW9kdWxlcy9mYXN0LWNoZWNrL2xpYi9hcmJpdHJhcnkvX2ludGVybmFscy9MYXp5QXJiaXRyYXJ5LmpzIiwid2VicGFjazovL3BhcnplYy8uL25vZGVfbW9kdWxlcy9mYXN0LWNoZWNrL2xpYi9hcmJpdHJhcnkvX2ludGVybmFscy9NaXhlZENhc2VBcmJpdHJhcnkuanMiLCJ3ZWJwYWNrOi8vcGFyemVjLy4vbm9kZV9tb2R1bGVzL2Zhc3QtY2hlY2svbGliL2FyYml0cmFyeS9faW50ZXJuYWxzL1NjaGVkdWxlckFyYml0cmFyeS5qcyIsIndlYnBhY2s6Ly9wYXJ6ZWMvLi9ub2RlX21vZHVsZXMvZmFzdC1jaGVjay9saWIvYXJiaXRyYXJ5L19pbnRlcm5hbHMvU3RyZWFtQXJiaXRyYXJ5LmpzIiwid2VicGFjazovL3BhcnplYy8uL25vZGVfbW9kdWxlcy9mYXN0LWNoZWNrL2xpYi9hcmJpdHJhcnkvX2ludGVybmFscy9UdXBsZUFyYml0cmFyeS5qcyIsIndlYnBhY2s6Ly9wYXJ6ZWMvLi9ub2RlX21vZHVsZXMvZmFzdC1jaGVjay9saWIvYXJiaXRyYXJ5L19pbnRlcm5hbHMvYnVpbGRlcnMvQ2hhcmFjdGVyQXJiaXRyYXJ5QnVpbGRlci5qcyIsIndlYnBhY2s6Ly9wYXJ6ZWMvLi9ub2RlX21vZHVsZXMvZmFzdC1jaGVjay9saWIvYXJiaXRyYXJ5L19pbnRlcm5hbHMvYnVpbGRlcnMvQ29tcGFyZUZ1bmN0aW9uQXJiaXRyYXJ5QnVpbGRlci5qcyIsIndlYnBhY2s6Ly9wYXJ6ZWMvLi9ub2RlX21vZHVsZXMvZmFzdC1jaGVjay9saWIvYXJiaXRyYXJ5L19pbnRlcm5hbHMvYnVpbGRlcnMvUGFydGlhbFJlY29yZEFyYml0cmFyeUJ1aWxkZXIuanMiLCJ3ZWJwYWNrOi8vcGFyemVjLy4vbm9kZV9tb2R1bGVzL2Zhc3QtY2hlY2svbGliL2FyYml0cmFyeS9faW50ZXJuYWxzL2J1aWxkZXJzL1N0cmluZ2lmaWVkTmF0QXJiaXRyYXJ5QnVpbGRlci5qcyIsIndlYnBhY2s6Ly9wYXJ6ZWMvLi9ub2RlX21vZHVsZXMvZmFzdC1jaGVjay9saWIvYXJiaXRyYXJ5L19pbnRlcm5hbHMvYnVpbGRlcnMvVHlwZWRJbnRBcnJheUFyYml0cmFyeUJ1aWxkZXIuanMiLCJ3ZWJwYWNrOi8vcGFyemVjLy4vbm9kZV9tb2R1bGVzL2Zhc3QtY2hlY2svbGliL2FyYml0cmFyeS9faW50ZXJuYWxzL2hlbHBlcnMvQmlhc051bWVyaWNSYW5nZS5qcyIsIndlYnBhY2s6Ly9wYXJ6ZWMvLi9ub2RlX21vZHVsZXMvZmFzdC1jaGVjay9saWIvYXJiaXRyYXJ5L19pbnRlcm5hbHMvaGVscGVycy9CdWlsZENvbXBhcmVGaWx0ZXIuanMiLCJ3ZWJwYWNrOi8vcGFyemVjLy4vbm9kZV9tb2R1bGVzL2Zhc3QtY2hlY2svbGliL2FyYml0cmFyeS9faW50ZXJuYWxzL2hlbHBlcnMvQnVpbGRTY2hlZHVsZXJGb3IuanMiLCJ3ZWJwYWNrOi8vcGFyemVjLy4vbm9kZV9tb2R1bGVzL2Zhc3QtY2hlY2svbGliL2FyYml0cmFyeS9faW50ZXJuYWxzL2hlbHBlcnMvRGVwdGhDb250ZXh0LmpzIiwid2VicGFjazovL3BhcnplYy8uL25vZGVfbW9kdWxlcy9mYXN0LWNoZWNrL2xpYi9hcmJpdHJhcnkvX2ludGVybmFscy9oZWxwZXJzL0VudW1lcmFibGVLZXlzRXh0cmFjdG9yLmpzIiwid2VicGFjazovL3BhcnplYy8uL25vZGVfbW9kdWxlcy9mYXN0LWNoZWNrL2xpYi9hcmJpdHJhcnkvX2ludGVybmFscy9oZWxwZXJzL01heExlbmd0aEZyb21NaW5MZW5ndGguanMiLCJ3ZWJwYWNrOi8vcGFyemVjLy4vbm9kZV9tb2R1bGVzL2Zhc3QtY2hlY2svbGliL2FyYml0cmFyeS9faW50ZXJuYWxzL2hlbHBlcnMvU2hyaW5rQmlnSW50LmpzIiwid2VicGFjazovL3BhcnplYy8uL25vZGVfbW9kdWxlcy9mYXN0LWNoZWNrL2xpYi9hcmJpdHJhcnkvX2ludGVybmFscy9oZWxwZXJzL1Nocmlua0ludGVnZXIuanMiLCJ3ZWJwYWNrOi8vcGFyemVjLy4vbm9kZV9tb2R1bGVzL2Zhc3QtY2hlY2svbGliL2FyYml0cmFyeS9faW50ZXJuYWxzL2hlbHBlcnMvU3RyaW5nQ29uc3RyYWludHNFeHRyYWN0b3IuanMiLCJ3ZWJwYWNrOi8vcGFyemVjLy4vbm9kZV9tb2R1bGVzL2Zhc3QtY2hlY2svbGliL2FyYml0cmFyeS9faW50ZXJuYWxzL2ltcGxlbWVudGF0aW9ucy9TY2hlZHVsZXJJbXBsZW0uanMiLCJ3ZWJwYWNrOi8vcGFyemVjLy4vbm9kZV9tb2R1bGVzL2Zhc3QtY2hlY2svbGliL2FyYml0cmFyeS9faW50ZXJuYWxzL21hcHBlcnMvQ2hhcnNUb1N0cmluZy5qcyIsIndlYnBhY2s6Ly9wYXJ6ZWMvLi9ub2RlX21vZHVsZXMvZmFzdC1jaGVjay9saWIvYXJiaXRyYXJ5L19pbnRlcm5hbHMvbWFwcGVycy9Db2RlUG9pbnRzVG9TdHJpbmcuanMiLCJ3ZWJwYWNrOi8vcGFyemVjLy4vbm9kZV9tb2R1bGVzL2Zhc3QtY2hlY2svbGliL2FyYml0cmFyeS9faW50ZXJuYWxzL21hcHBlcnMvRW50aXRpZXNUb0lQdjYuanMiLCJ3ZWJwYWNrOi8vcGFyemVjLy4vbm9kZV9tb2R1bGVzL2Zhc3QtY2hlY2svbGliL2FyYml0cmFyeS9faW50ZXJuYWxzL21hcHBlcnMvSW5kZXhUb0NoYXJTdHJpbmcuanMiLCJ3ZWJwYWNrOi8vcGFyemVjLy4vbm9kZV9tb2R1bGVzL2Zhc3QtY2hlY2svbGliL2FyYml0cmFyeS9faW50ZXJuYWxzL21hcHBlcnMvSW5kZXhUb01hcHBlZENvbnN0YW50LmpzIiwid2VicGFjazovL3BhcnplYy8uL25vZGVfbW9kdWxlcy9mYXN0LWNoZWNrL2xpYi9hcmJpdHJhcnkvX2ludGVybmFscy9tYXBwZXJzL0luZGV4VG9QcmludGFibGVJbmRleC5qcyIsIndlYnBhY2s6Ly9wYXJ6ZWMvLi9ub2RlX21vZHVsZXMvZmFzdC1jaGVjay9saWIvYXJiaXRyYXJ5L19pbnRlcm5hbHMvbWFwcGVycy9LZXlWYWx1ZVBhaXJzVG9PYmplY3QuanMiLCJ3ZWJwYWNrOi8vcGFyemVjLy4vbm9kZV9tb2R1bGVzL2Zhc3QtY2hlY2svbGliL2FyYml0cmFyeS9faW50ZXJuYWxzL21hcHBlcnMvTmF0VG9TdHJpbmdpZmllZE5hdC5qcyIsIndlYnBhY2s6Ly9wYXJ6ZWMvLi9ub2RlX21vZHVsZXMvZmFzdC1jaGVjay9saWIvYXJiaXRyYXJ5L19pbnRlcm5hbHMvbWFwcGVycy9QYXR0ZXJuc1RvU3RyaW5nLmpzIiwid2VicGFjazovL3BhcnplYy8uL25vZGVfbW9kdWxlcy9mYXN0LWNoZWNrL2xpYi9hcmJpdHJhcnkvX2ludGVybmFscy9tYXBwZXJzL1N0cmluZ1RvQmFzZTY0LmpzIiwid2VicGFjazovL3BhcnplYy8uL25vZGVfbW9kdWxlcy9mYXN0LWNoZWNrL2xpYi9hcmJpdHJhcnkvX2ludGVybmFscy9tYXBwZXJzL1RpbWVUb0RhdGUuanMiLCJ3ZWJwYWNrOi8vcGFyemVjLy4vbm9kZV9tb2R1bGVzL2Zhc3QtY2hlY2svbGliL2FyYml0cmFyeS9faW50ZXJuYWxzL21hcHBlcnMvVmFsdWVzQW5kU2VwYXJhdGVLZXlzVG9PYmplY3QuanMiLCJ3ZWJwYWNrOi8vcGFyemVjLy4vbm9kZV9tb2R1bGVzL2Zhc3QtY2hlY2svbGliL2FyYml0cmFyeS9faW50ZXJuYWxzL21hcHBlcnMvV29yZHNUb0xvcmVtLmpzIiwid2VicGFjazovL3BhcnplYy8uL25vZGVfbW9kdWxlcy9mYXN0LWNoZWNrL2xpYi9hcmJpdHJhcnkvYXJyYXkuanMiLCJ3ZWJwYWNrOi8vcGFyemVjLy4vbm9kZV9tb2R1bGVzL2Zhc3QtY2hlY2svbGliL2FyYml0cmFyeS9hc2NpaS5qcyIsIndlYnBhY2s6Ly9wYXJ6ZWMvLi9ub2RlX21vZHVsZXMvZmFzdC1jaGVjay9saWIvYXJiaXRyYXJ5L2FzY2lpU3RyaW5nLmpzIiwid2VicGFjazovL3BhcnplYy8uL25vZGVfbW9kdWxlcy9mYXN0LWNoZWNrL2xpYi9hcmJpdHJhcnkvYmFzZTY0LmpzIiwid2VicGFjazovL3BhcnplYy8uL25vZGVfbW9kdWxlcy9mYXN0LWNoZWNrL2xpYi9hcmJpdHJhcnkvYmFzZTY0U3RyaW5nLmpzIiwid2VicGFjazovL3BhcnplYy8uL25vZGVfbW9kdWxlcy9mYXN0LWNoZWNrL2xpYi9hcmJpdHJhcnkvYmlnSW50LmpzIiwid2VicGFjazovL3BhcnplYy8uL25vZGVfbW9kdWxlcy9mYXN0LWNoZWNrL2xpYi9hcmJpdHJhcnkvYmlnSW50Ti5qcyIsIndlYnBhY2s6Ly9wYXJ6ZWMvLi9ub2RlX21vZHVsZXMvZmFzdC1jaGVjay9saWIvYXJiaXRyYXJ5L2JpZ1VpbnQuanMiLCJ3ZWJwYWNrOi8vcGFyemVjLy4vbm9kZV9tb2R1bGVzL2Zhc3QtY2hlY2svbGliL2FyYml0cmFyeS9iaWdVaW50Ti5qcyIsIndlYnBhY2s6Ly9wYXJ6ZWMvLi9ub2RlX21vZHVsZXMvZmFzdC1jaGVjay9saWIvYXJiaXRyYXJ5L2Jvb2xlYW4uanMiLCJ3ZWJwYWNrOi8vcGFyemVjLy4vbm9kZV9tb2R1bGVzL2Zhc3QtY2hlY2svbGliL2FyYml0cmFyeS9jaGFyLmpzIiwid2VicGFjazovL3BhcnplYy8uL25vZGVfbW9kdWxlcy9mYXN0LWNoZWNrL2xpYi9hcmJpdHJhcnkvY2hhcjE2Yml0cy5qcyIsIndlYnBhY2s6Ly9wYXJ6ZWMvLi9ub2RlX21vZHVsZXMvZmFzdC1jaGVjay9saWIvYXJiaXRyYXJ5L2Nsb25lLmpzIiwid2VicGFjazovL3BhcnplYy8uL25vZGVfbW9kdWxlcy9mYXN0LWNoZWNrL2xpYi9hcmJpdHJhcnkvY2xvbmVkQ29uc3RhbnQuanMiLCJ3ZWJwYWNrOi8vcGFyemVjLy4vbm9kZV9tb2R1bGVzL2Zhc3QtY2hlY2svbGliL2FyYml0cmFyeS9jb21wYXJlQm9vbGVhbkZ1bmMuanMiLCJ3ZWJwYWNrOi8vcGFyemVjLy4vbm9kZV9tb2R1bGVzL2Zhc3QtY2hlY2svbGliL2FyYml0cmFyeS9jb21wYXJlRnVuYy5qcyIsIndlYnBhY2s6Ly9wYXJ6ZWMvLi9ub2RlX21vZHVsZXMvZmFzdC1jaGVjay9saWIvYXJiaXRyYXJ5L2NvbnN0YW50LmpzIiwid2VicGFjazovL3BhcnplYy8uL25vZGVfbW9kdWxlcy9mYXN0LWNoZWNrL2xpYi9hcmJpdHJhcnkvY29uc3RhbnRGcm9tLmpzIiwid2VicGFjazovL3BhcnplYy8uL25vZGVfbW9kdWxlcy9mYXN0LWNoZWNrL2xpYi9hcmJpdHJhcnkvY29udGV4dC5qcyIsIndlYnBhY2s6Ly9wYXJ6ZWMvLi9ub2RlX21vZHVsZXMvZmFzdC1jaGVjay9saWIvYXJiaXRyYXJ5L2RhdGUuanMiLCJ3ZWJwYWNrOi8vcGFyemVjLy4vbm9kZV9tb2R1bGVzL2Zhc3QtY2hlY2svbGliL2FyYml0cmFyeS9kZWR1cC5qcyIsIndlYnBhY2s6Ly9wYXJ6ZWMvLi9ub2RlX21vZHVsZXMvZmFzdC1jaGVjay9saWIvYXJiaXRyYXJ5L2RpY3Rpb25hcnkuanMiLCJ3ZWJwYWNrOi8vcGFyemVjLy4vbm9kZV9tb2R1bGVzL2Zhc3QtY2hlY2svbGliL2FyYml0cmFyeS9mYWxzeS5qcyIsIndlYnBhY2s6Ly9wYXJ6ZWMvLi9ub2RlX21vZHVsZXMvZmFzdC1jaGVjay9saWIvYXJiaXRyYXJ5L2Zsb2F0MzJBcnJheS5qcyIsIndlYnBhY2s6Ly9wYXJ6ZWMvLi9ub2RlX21vZHVsZXMvZmFzdC1jaGVjay9saWIvYXJiaXRyYXJ5L2Zsb2F0NjRBcnJheS5qcyIsIndlYnBhY2s6Ly9wYXJ6ZWMvLi9ub2RlX21vZHVsZXMvZmFzdC1jaGVjay9saWIvYXJiaXRyYXJ5L2ZyZXF1ZW5jeS5qcyIsIndlYnBhY2s6Ly9wYXJ6ZWMvLi9ub2RlX21vZHVsZXMvZmFzdC1jaGVjay9saWIvYXJiaXRyYXJ5L2Z1bGxVbmljb2RlLmpzIiwid2VicGFjazovL3BhcnplYy8uL25vZGVfbW9kdWxlcy9mYXN0LWNoZWNrL2xpYi9hcmJpdHJhcnkvZnVsbFVuaWNvZGVTdHJpbmcuanMiLCJ3ZWJwYWNrOi8vcGFyemVjLy4vbm9kZV9tb2R1bGVzL2Zhc3QtY2hlY2svbGliL2FyYml0cmFyeS9mdW5jLmpzIiwid2VicGFjazovL3BhcnplYy8uL25vZGVfbW9kdWxlcy9mYXN0LWNoZWNrL2xpYi9hcmJpdHJhcnkvZ2VuZXJpY1R1cGxlLmpzIiwid2VicGFjazovL3BhcnplYy8uL25vZGVfbW9kdWxlcy9mYXN0LWNoZWNrL2xpYi9hcmJpdHJhcnkvaGV4YS5qcyIsIndlYnBhY2s6Ly9wYXJ6ZWMvLi9ub2RlX21vZHVsZXMvZmFzdC1jaGVjay9saWIvYXJiaXRyYXJ5L2hleGFTdHJpbmcuanMiLCJ3ZWJwYWNrOi8vcGFyemVjLy4vbm9kZV9tb2R1bGVzL2Zhc3QtY2hlY2svbGliL2FyYml0cmFyeS9pbmZpbml0ZVN0cmVhbS5qcyIsIndlYnBhY2s6Ly9wYXJ6ZWMvLi9ub2RlX21vZHVsZXMvZmFzdC1jaGVjay9saWIvYXJiaXRyYXJ5L2ludDE2QXJyYXkuanMiLCJ3ZWJwYWNrOi8vcGFyemVjLy4vbm9kZV9tb2R1bGVzL2Zhc3QtY2hlY2svbGliL2FyYml0cmFyeS9pbnQzMkFycmF5LmpzIiwid2VicGFjazovL3BhcnplYy8uL25vZGVfbW9kdWxlcy9mYXN0LWNoZWNrL2xpYi9hcmJpdHJhcnkvaW50OEFycmF5LmpzIiwid2VicGFjazovL3BhcnplYy8uL25vZGVfbW9kdWxlcy9mYXN0LWNoZWNrL2xpYi9hcmJpdHJhcnkvaW50ZWdlci5qcyIsIndlYnBhY2s6Ly9wYXJ6ZWMvLi9ub2RlX21vZHVsZXMvZmFzdC1jaGVjay9saWIvYXJiaXRyYXJ5L2lwVjQuanMiLCJ3ZWJwYWNrOi8vcGFyemVjLy4vbm9kZV9tb2R1bGVzL2Zhc3QtY2hlY2svbGliL2FyYml0cmFyeS9pcFY0RXh0ZW5kZWQuanMiLCJ3ZWJwYWNrOi8vcGFyemVjLy4vbm9kZV9tb2R1bGVzL2Zhc3QtY2hlY2svbGliL2FyYml0cmFyeS9pcFY2LmpzIiwid2VicGFjazovL3BhcnplYy8uL25vZGVfbW9kdWxlcy9mYXN0LWNoZWNrL2xpYi9hcmJpdHJhcnkvbGV0cmVjLmpzIiwid2VicGFjazovL3BhcnplYy8uL25vZGVfbW9kdWxlcy9mYXN0LWNoZWNrL2xpYi9hcmJpdHJhcnkvbG9yZW0uanMiLCJ3ZWJwYWNrOi8vcGFyemVjLy4vbm9kZV9tb2R1bGVzL2Zhc3QtY2hlY2svbGliL2FyYml0cmFyeS9tYXBUb0NvbnN0YW50LmpzIiwid2VicGFjazovL3BhcnplYy8uL25vZGVfbW9kdWxlcy9mYXN0LWNoZWNrL2xpYi9hcmJpdHJhcnkvbWF4U2FmZUludGVnZXIuanMiLCJ3ZWJwYWNrOi8vcGFyemVjLy4vbm9kZV9tb2R1bGVzL2Zhc3QtY2hlY2svbGliL2FyYml0cmFyeS9tYXhTYWZlTmF0LmpzIiwid2VicGFjazovL3BhcnplYy8uL25vZGVfbW9kdWxlcy9mYXN0LWNoZWNrL2xpYi9hcmJpdHJhcnkvbWVtby5qcyIsIndlYnBhY2s6Ly9wYXJ6ZWMvLi9ub2RlX21vZHVsZXMvZmFzdC1jaGVjay9saWIvYXJiaXRyYXJ5L21peGVkQ2FzZS5qcyIsIndlYnBhY2s6Ly9wYXJ6ZWMvLi9ub2RlX21vZHVsZXMvZmFzdC1jaGVjay9saWIvYXJiaXRyYXJ5L25hdC5qcyIsIndlYnBhY2s6Ly9wYXJ6ZWMvLi9ub2RlX21vZHVsZXMvZmFzdC1jaGVjay9saWIvYXJiaXRyYXJ5L29uZW9mLmpzIiwid2VicGFjazovL3BhcnplYy8uL25vZGVfbW9kdWxlcy9mYXN0LWNoZWNrL2xpYi9hcmJpdHJhcnkvb3B0aW9uLmpzIiwid2VicGFjazovL3BhcnplYy8uL25vZGVfbW9kdWxlcy9mYXN0LWNoZWNrL2xpYi9hcmJpdHJhcnkvcmVjb3JkLmpzIiwid2VicGFjazovL3BhcnplYy8uL25vZGVfbW9kdWxlcy9mYXN0LWNoZWNrL2xpYi9hcmJpdHJhcnkvc2NoZWR1bGVyLmpzIiwid2VicGFjazovL3BhcnplYy8uL25vZGVfbW9kdWxlcy9mYXN0LWNoZWNrL2xpYi9hcmJpdHJhcnkvc2V0LmpzIiwid2VicGFjazovL3BhcnplYy8uL25vZGVfbW9kdWxlcy9mYXN0LWNoZWNrL2xpYi9hcmJpdHJhcnkvc3RyaW5nLmpzIiwid2VicGFjazovL3BhcnplYy8uL25vZGVfbW9kdWxlcy9mYXN0LWNoZWNrL2xpYi9hcmJpdHJhcnkvc3RyaW5nMTZiaXRzLmpzIiwid2VicGFjazovL3BhcnplYy8uL25vZGVfbW9kdWxlcy9mYXN0LWNoZWNrL2xpYi9hcmJpdHJhcnkvc3RyaW5nT2YuanMiLCJ3ZWJwYWNrOi8vcGFyemVjLy4vbm9kZV9tb2R1bGVzL2Zhc3QtY2hlY2svbGliL2FyYml0cmFyeS90dXBsZS5qcyIsIndlYnBhY2s6Ly9wYXJ6ZWMvLi9ub2RlX21vZHVsZXMvZmFzdC1jaGVjay9saWIvYXJiaXRyYXJ5L3VpbnQxNkFycmF5LmpzIiwid2VicGFjazovL3BhcnplYy8uL25vZGVfbW9kdWxlcy9mYXN0LWNoZWNrL2xpYi9hcmJpdHJhcnkvdWludDMyQXJyYXkuanMiLCJ3ZWJwYWNrOi8vcGFyemVjLy4vbm9kZV9tb2R1bGVzL2Zhc3QtY2hlY2svbGliL2FyYml0cmFyeS91aW50OEFycmF5LmpzIiwid2VicGFjazovL3BhcnplYy8uL25vZGVfbW9kdWxlcy9mYXN0LWNoZWNrL2xpYi9hcmJpdHJhcnkvdWludDhDbGFtcGVkQXJyYXkuanMiLCJ3ZWJwYWNrOi8vcGFyemVjLy4vbm9kZV9tb2R1bGVzL2Zhc3QtY2hlY2svbGliL2FyYml0cmFyeS91bmljb2RlLmpzIiwid2VicGFjazovL3BhcnplYy8uL25vZGVfbW9kdWxlcy9mYXN0LWNoZWNrL2xpYi9hcmJpdHJhcnkvdW5pY29kZVN0cmluZy5qcyIsIndlYnBhY2s6Ly9wYXJ6ZWMvLi9ub2RlX21vZHVsZXMvZmFzdC1jaGVjay9saWIvY2hlY2svYXJiaXRyYXJ5L0RvdWJsZU5leHRBcmJpdHJhcnkuanMiLCJ3ZWJwYWNrOi8vcGFyemVjLy4vbm9kZV9tb2R1bGVzL2Zhc3QtY2hlY2svbGliL2NoZWNrL2FyYml0cmFyeS9FbWFpbEFyYml0cmFyeS5qcyIsIndlYnBhY2s6Ly9wYXJ6ZWMvLi9ub2RlX21vZHVsZXMvZmFzdC1jaGVjay9saWIvY2hlY2svYXJiaXRyYXJ5L0Zsb2F0TmV4dEFyYml0cmFyeS5qcyIsIndlYnBhY2s6Ly9wYXJ6ZWMvLi9ub2RlX21vZHVsZXMvZmFzdC1jaGVjay9saWIvY2hlY2svYXJiaXRyYXJ5L0Zsb2F0aW5nUG9pbnRBcmJpdHJhcnkuanMiLCJ3ZWJwYWNrOi8vcGFyemVjLy4vbm9kZV9tb2R1bGVzL2Zhc3QtY2hlY2svbGliL2NoZWNrL2FyYml0cmFyeS9Ib3N0QXJiaXRyYXJ5LmpzIiwid2VicGFjazovL3BhcnplYy8uL25vZGVfbW9kdWxlcy9mYXN0LWNoZWNrL2xpYi9jaGVjay9hcmJpdHJhcnkvT2JqZWN0QXJiaXRyYXJ5LmpzIiwid2VicGFjazovL3BhcnplYy8uL25vZGVfbW9kdWxlcy9mYXN0LWNoZWNrL2xpYi9jaGVjay9hcmJpdHJhcnkvU3BhcnNlQXJyYXlBcmJpdHJhcnkuanMiLCJ3ZWJwYWNrOi8vcGFyemVjLy4vbm9kZV9tb2R1bGVzL2Zhc3QtY2hlY2svbGliL2NoZWNrL2FyYml0cmFyeS9TdWJhcnJheUFyYml0cmFyeS5qcyIsIndlYnBhY2s6Ly9wYXJ6ZWMvLi9ub2RlX21vZHVsZXMvZmFzdC1jaGVjay9saWIvY2hlY2svYXJiaXRyYXJ5L1V1aWRBcmJpdHJhcnkuanMiLCJ3ZWJwYWNrOi8vcGFyemVjLy4vbm9kZV9tb2R1bGVzL2Zhc3QtY2hlY2svbGliL2NoZWNrL2FyYml0cmFyeS9XZWJBcmJpdHJhcnkuanMiLCJ3ZWJwYWNrOi8vcGFyemVjLy4vbm9kZV9tb2R1bGVzL2Zhc3QtY2hlY2svbGliL2NoZWNrL2FyYml0cmFyeS9kZWZpbml0aW9uL0FyYml0cmFyeS5qcyIsIndlYnBhY2s6Ly9wYXJ6ZWMvLi9ub2RlX21vZHVsZXMvZmFzdC1jaGVjay9saWIvY2hlY2svYXJiaXRyYXJ5L2RlZmluaXRpb24vQXJiaXRyYXJ5V2l0aENvbnRleHR1YWxTaHJpbmsuanMiLCJ3ZWJwYWNrOi8vcGFyemVjLy4vbm9kZV9tb2R1bGVzL2Zhc3QtY2hlY2svbGliL2NoZWNrL2FyYml0cmFyeS9kZWZpbml0aW9uL0FyYml0cmFyeVdpdGhTaHJpbmsuanMiLCJ3ZWJwYWNrOi8vcGFyemVjLy4vbm9kZV9tb2R1bGVzL2Zhc3QtY2hlY2svbGliL2NoZWNrL2FyYml0cmFyeS9kZWZpbml0aW9uL0JpYXNlZEFyYml0cmFyeVdyYXBwZXIuanMiLCJ3ZWJwYWNrOi8vcGFyemVjLy4vbm9kZV9tb2R1bGVzL2Zhc3QtY2hlY2svbGliL2NoZWNrL2FyYml0cmFyeS9kZWZpbml0aW9uL0NvbnZlcnRlckZyb21OZXh0LmpzIiwid2VicGFjazovL3BhcnplYy8uL25vZGVfbW9kdWxlcy9mYXN0LWNoZWNrL2xpYi9jaGVjay9hcmJpdHJhcnkvZGVmaW5pdGlvbi9Db252ZXJ0ZXJUb05leHQuanMiLCJ3ZWJwYWNrOi8vcGFyemVjLy4vbm9kZV9tb2R1bGVzL2Zhc3QtY2hlY2svbGliL2NoZWNrL2FyYml0cmFyeS9kZWZpbml0aW9uL0NvbnZlcnRlcnMuanMiLCJ3ZWJwYWNrOi8vcGFyemVjLy4vbm9kZV9tb2R1bGVzL2Zhc3QtY2hlY2svbGliL2NoZWNrL2FyYml0cmFyeS9kZWZpbml0aW9uL05leHRBcmJpdHJhcnkuanMiLCJ3ZWJwYWNrOi8vcGFyemVjLy4vbm9kZV9tb2R1bGVzL2Zhc3QtY2hlY2svbGliL2NoZWNrL2FyYml0cmFyeS9kZWZpbml0aW9uL05leHRWYWx1ZS5qcyIsIndlYnBhY2s6Ly9wYXJ6ZWMvLi9ub2RlX21vZHVsZXMvZmFzdC1jaGVjay9saWIvY2hlY2svYXJiaXRyYXJ5L2RlZmluaXRpb24vU2hyaW5rYWJsZS5qcyIsIndlYnBhY2s6Ly9wYXJ6ZWMvLi9ub2RlX21vZHVsZXMvZmFzdC1jaGVjay9saWIvY2hlY2svYXJiaXRyYXJ5L2hlbHBlcnMvQXJyYXlJbnQ2NC5qcyIsIndlYnBhY2s6Ly9wYXJ6ZWMvLi9ub2RlX21vZHVsZXMvZmFzdC1jaGVjay9saWIvY2hlY2svYXJiaXRyYXJ5L2hlbHBlcnMvQXJyYXlJbnQ2NEFyYml0cmFyeS5qcyIsIndlYnBhY2s6Ly9wYXJ6ZWMvLi9ub2RlX21vZHVsZXMvZmFzdC1jaGVjay9saWIvY2hlY2svYXJiaXRyYXJ5L2hlbHBlcnMvU3BlY2lmaWNDaGFyYWN0ZXJSYW5nZS5qcyIsIndlYnBhY2s6Ly9wYXJ6ZWMvLi9ub2RlX21vZHVsZXMvZmFzdC1jaGVjay9saWIvY2hlY2svYXJiaXRyYXJ5L2hlbHBlcnMvVGV4dEVzY2FwZXIuanMiLCJ3ZWJwYWNrOi8vcGFyemVjLy4vbm9kZV9tb2R1bGVzL2Zhc3QtY2hlY2svbGliL2NoZWNrL21vZGVsL01vZGVsUnVubmVyLmpzIiwid2VicGFjazovL3BhcnplYy8uL25vZGVfbW9kdWxlcy9mYXN0LWNoZWNrL2xpYi9jaGVjay9tb2RlbC9SZXBsYXlQYXRoLmpzIiwid2VicGFjazovL3BhcnplYy8uL25vZGVfbW9kdWxlcy9mYXN0LWNoZWNrL2xpYi9jaGVjay9tb2RlbC9jb21tYW5kcy9Db21tYW5kV3JhcHBlci5qcyIsIndlYnBhY2s6Ly9wYXJ6ZWMvLi9ub2RlX21vZHVsZXMvZmFzdC1jaGVjay9saWIvY2hlY2svbW9kZWwvY29tbWFuZHMvQ29tbWFuZHNBcmJpdHJhcnkuanMiLCJ3ZWJwYWNrOi8vcGFyemVjLy4vbm9kZV9tb2R1bGVzL2Zhc3QtY2hlY2svbGliL2NoZWNrL21vZGVsL2NvbW1hbmRzL0NvbW1hbmRzSXRlcmFibGUuanMiLCJ3ZWJwYWNrOi8vcGFyemVjLy4vbm9kZV9tb2R1bGVzL2Zhc3QtY2hlY2svbGliL2NoZWNrL21vZGVsL2NvbW1hbmRzL1NjaGVkdWxlZENvbW1hbmQuanMiLCJ3ZWJwYWNrOi8vcGFyemVjLy4vbm9kZV9tb2R1bGVzL2Zhc3QtY2hlY2svbGliL2NoZWNrL3ByZWNvbmRpdGlvbi9QcmUuanMiLCJ3ZWJwYWNrOi8vcGFyemVjLy4vbm9kZV9tb2R1bGVzL2Zhc3QtY2hlY2svbGliL2NoZWNrL3ByZWNvbmRpdGlvbi9QcmVjb25kaXRpb25GYWlsdXJlLmpzIiwid2VicGFjazovL3BhcnplYy8uL25vZGVfbW9kdWxlcy9mYXN0LWNoZWNrL2xpYi9jaGVjay9wcm9wZXJ0eS9Bc3luY1Byb3BlcnR5LmdlbmVyYXRlZC5qcyIsIndlYnBhY2s6Ly9wYXJ6ZWMvLi9ub2RlX21vZHVsZXMvZmFzdC1jaGVjay9saWIvY2hlY2svcHJvcGVydHkvQXN5bmNQcm9wZXJ0eS5nZW5lcmljLmpzIiwid2VicGFjazovL3BhcnplYy8uL25vZGVfbW9kdWxlcy9mYXN0LWNoZWNrL2xpYi9jaGVjay9wcm9wZXJ0eS9Bc3luY1Byb3BlcnR5LmpzIiwid2VicGFjazovL3BhcnplYy8uL25vZGVfbW9kdWxlcy9mYXN0LWNoZWNrL2xpYi9jaGVjay9wcm9wZXJ0eS9JUmF3UHJvcGVydHkuanMiLCJ3ZWJwYWNrOi8vcGFyemVjLy4vbm9kZV9tb2R1bGVzL2Zhc3QtY2hlY2svbGliL2NoZWNrL3Byb3BlcnR5L0lnbm9yZUVxdWFsVmFsdWVzUHJvcGVydHkuanMiLCJ3ZWJwYWNrOi8vcGFyemVjLy4vbm9kZV9tb2R1bGVzL2Zhc3QtY2hlY2svbGliL2NoZWNrL3Byb3BlcnR5L1Byb3BlcnR5LmdlbmVyYXRlZC5qcyIsIndlYnBhY2s6Ly9wYXJ6ZWMvLi9ub2RlX21vZHVsZXMvZmFzdC1jaGVjay9saWIvY2hlY2svcHJvcGVydHkvUHJvcGVydHkuZ2VuZXJpYy5qcyIsIndlYnBhY2s6Ly9wYXJ6ZWMvLi9ub2RlX21vZHVsZXMvZmFzdC1jaGVjay9saWIvY2hlY2svcHJvcGVydHkvUHJvcGVydHkuanMiLCJ3ZWJwYWNrOi8vcGFyemVjLy4vbm9kZV9tb2R1bGVzL2Zhc3QtY2hlY2svbGliL2NoZWNrL3Byb3BlcnR5L1NraXBBZnRlclByb3BlcnR5LmpzIiwid2VicGFjazovL3BhcnplYy8uL25vZGVfbW9kdWxlcy9mYXN0LWNoZWNrL2xpYi9jaGVjay9wcm9wZXJ0eS9UaW1lb3V0UHJvcGVydHkuanMiLCJ3ZWJwYWNrOi8vcGFyemVjLy4vbm9kZV9tb2R1bGVzL2Zhc3QtY2hlY2svbGliL2NoZWNrL3Byb3BlcnR5L1VuYmlhc2VkUHJvcGVydHkuanMiLCJ3ZWJwYWNrOi8vcGFyemVjLy4vbm9kZV9tb2R1bGVzL2Zhc3QtY2hlY2svbGliL2NoZWNrL3J1bm5lci9EZWNvcmF0ZVByb3BlcnR5LmpzIiwid2VicGFjazovL3BhcnplYy8uL25vZGVfbW9kdWxlcy9mYXN0LWNoZWNrL2xpYi9jaGVjay9ydW5uZXIvUnVubmVyLmpzIiwid2VicGFjazovL3BhcnplYy8uL25vZGVfbW9kdWxlcy9mYXN0LWNoZWNrL2xpYi9jaGVjay9ydW5uZXIvUnVubmVySXRlcmF0b3IuanMiLCJ3ZWJwYWNrOi8vcGFyemVjLy4vbm9kZV9tb2R1bGVzL2Zhc3QtY2hlY2svbGliL2NoZWNrL3J1bm5lci9TYW1wbGVyLmpzIiwid2VicGFjazovL3BhcnplYy8uL25vZGVfbW9kdWxlcy9mYXN0LWNoZWNrL2xpYi9jaGVjay9ydW5uZXIvU291cmNlVmFsdWVzSXRlcmF0b3IuanMiLCJ3ZWJwYWNrOi8vcGFyemVjLy4vbm9kZV9tb2R1bGVzL2Zhc3QtY2hlY2svbGliL2NoZWNrL3J1bm5lci9Ub3NzZXIuanMiLCJ3ZWJwYWNrOi8vcGFyemVjLy4vbm9kZV9tb2R1bGVzL2Zhc3QtY2hlY2svbGliL2NoZWNrL3J1bm5lci9jb25maWd1cmF0aW9uL0dsb2JhbFBhcmFtZXRlcnMuanMiLCJ3ZWJwYWNrOi8vcGFyemVjLy4vbm9kZV9tb2R1bGVzL2Zhc3QtY2hlY2svbGliL2NoZWNrL3J1bm5lci9jb25maWd1cmF0aW9uL1F1YWxpZmllZFBhcmFtZXRlcnMuanMiLCJ3ZWJwYWNrOi8vcGFyemVjLy4vbm9kZV9tb2R1bGVzL2Zhc3QtY2hlY2svbGliL2NoZWNrL3J1bm5lci9jb25maWd1cmF0aW9uL1ZlcmJvc2l0eUxldmVsLmpzIiwid2VicGFjazovL3BhcnplYy8uL25vZGVfbW9kdWxlcy9mYXN0LWNoZWNrL2xpYi9jaGVjay9ydW5uZXIvcmVwb3J0ZXIvRXhlY3V0aW9uU3RhdHVzLmpzIiwid2VicGFjazovL3BhcnplYy8uL25vZGVfbW9kdWxlcy9mYXN0LWNoZWNrL2xpYi9jaGVjay9ydW5uZXIvcmVwb3J0ZXIvUnVuRXhlY3V0aW9uLmpzIiwid2VicGFjazovL3BhcnplYy8uL25vZGVfbW9kdWxlcy9mYXN0LWNoZWNrL2xpYi9jaGVjay9ydW5uZXIvdXRpbHMvUGF0aFdhbGtlci5qcyIsIndlYnBhY2s6Ly9wYXJ6ZWMvLi9ub2RlX21vZHVsZXMvZmFzdC1jaGVjay9saWIvY2hlY2svcnVubmVyL3V0aWxzL1J1bkRldGFpbHNGb3JtYXR0ZXIuanMiLCJ3ZWJwYWNrOi8vcGFyemVjLy4vbm9kZV9tb2R1bGVzL2Zhc3QtY2hlY2svbGliL2NoZWNrL3N5bWJvbHMuanMiLCJ3ZWJwYWNrOi8vcGFyemVjLy4vbm9kZV9tb2R1bGVzL2Zhc3QtY2hlY2svbGliL2Zhc3QtY2hlY2stZGVmYXVsdC5qcyIsIndlYnBhY2s6Ly9wYXJ6ZWMvLi9ub2RlX21vZHVsZXMvZmFzdC1jaGVjay9saWIvZmFzdC1jaGVjay5qcyIsIndlYnBhY2s6Ly9wYXJ6ZWMvLi9ub2RlX21vZHVsZXMvZmFzdC1jaGVjay9saWIvcmFuZG9tL2dlbmVyYXRvci9QdXJlUmFuZG9tLmpzIiwid2VicGFjazovL3BhcnplYy8uL25vZGVfbW9kdWxlcy9mYXN0LWNoZWNrL2xpYi9yYW5kb20vZ2VuZXJhdG9yL1JhbmRvbS5qcyIsIndlYnBhY2s6Ly9wYXJ6ZWMvLi9ub2RlX21vZHVsZXMvZmFzdC1jaGVjay9saWIvc3RyZWFtL0xhenlJdGVyYWJsZUl0ZXJhdG9yLmpzIiwid2VicGFjazovL3BhcnplYy8uL25vZGVfbW9kdWxlcy9mYXN0LWNoZWNrL2xpYi9zdHJlYW0vU3RyZWFtLmpzIiwid2VicGFjazovL3BhcnplYy8uL25vZGVfbW9kdWxlcy9mYXN0LWNoZWNrL2xpYi9zdHJlYW0vU3RyZWFtSGVscGVycy5qcyIsIndlYnBhY2s6Ly9wYXJ6ZWMvLi9ub2RlX21vZHVsZXMvZmFzdC1jaGVjay9saWIvdXRpbHMvaGFzaC5qcyIsIndlYnBhY2s6Ly9wYXJ6ZWMvLi9ub2RlX21vZHVsZXMvZmFzdC1jaGVjay9saWIvdXRpbHMvc3RyaW5naWZ5LmpzIiwid2VicGFjazovL3BhcnplYy8uL25vZGVfbW9kdWxlcy9wdXJlLXJhbmQvbGliL2Rpc3RyaWJ1dGlvbi9Vbmlmb3JtQXJyYXlJbnREaXN0cmlidXRpb24uanMiLCJ3ZWJwYWNrOi8vcGFyemVjLy4vbm9kZV9tb2R1bGVzL3B1cmUtcmFuZC9saWIvZGlzdHJpYnV0aW9uL1VuaWZvcm1CaWdJbnREaXN0cmlidXRpb24uanMiLCJ3ZWJwYWNrOi8vcGFyemVjLy4vbm9kZV9tb2R1bGVzL3B1cmUtcmFuZC9saWIvZGlzdHJpYnV0aW9uL1VuaWZvcm1JbnREaXN0cmlidXRpb24uanMiLCJ3ZWJwYWNrOi8vcGFyemVjLy4vbm9kZV9tb2R1bGVzL3B1cmUtcmFuZC9saWIvZGlzdHJpYnV0aW9uL1Vuc2FmZVVuaWZvcm1BcnJheUludERpc3RyaWJ1dGlvbi5qcyIsIndlYnBhY2s6Ly9wYXJ6ZWMvLi9ub2RlX21vZHVsZXMvcHVyZS1yYW5kL2xpYi9kaXN0cmlidXRpb24vVW5zYWZlVW5pZm9ybUJpZ0ludERpc3RyaWJ1dGlvbi5qcyIsIndlYnBhY2s6Ly9wYXJ6ZWMvLi9ub2RlX21vZHVsZXMvcHVyZS1yYW5kL2xpYi9kaXN0cmlidXRpb24vVW5zYWZlVW5pZm9ybUludERpc3RyaWJ1dGlvbi5qcyIsIndlYnBhY2s6Ly9wYXJ6ZWMvLi9ub2RlX21vZHVsZXMvcHVyZS1yYW5kL2xpYi9kaXN0cmlidXRpb24vaW50ZXJuYWxzL0FycmF5SW50LmpzIiwid2VicGFjazovL3BhcnplYy8uL25vZGVfbW9kdWxlcy9wdXJlLXJhbmQvbGliL2Rpc3RyaWJ1dGlvbi9pbnRlcm5hbHMvVW5zYWZlVW5pZm9ybUFycmF5SW50RGlzdHJpYnV0aW9uSW50ZXJuYWwuanMiLCJ3ZWJwYWNrOi8vcGFyemVjLy4vbm9kZV9tb2R1bGVzL3B1cmUtcmFuZC9saWIvZGlzdHJpYnV0aW9uL2ludGVybmFscy9VbnNhZmVVbmlmb3JtSW50RGlzdHJpYnV0aW9uSW50ZXJuYWwuanMiLCJ3ZWJwYWNrOi8vcGFyemVjLy4vbm9kZV9tb2R1bGVzL3B1cmUtcmFuZC9saWIvZ2VuZXJhdG9yL0xpbmVhckNvbmdydWVudGlhbC5qcyIsIndlYnBhY2s6Ly9wYXJ6ZWMvLi9ub2RlX21vZHVsZXMvcHVyZS1yYW5kL2xpYi9nZW5lcmF0b3IvTWVyc2VubmVUd2lzdGVyLmpzIiwid2VicGFjazovL3BhcnplYy8uL25vZGVfbW9kdWxlcy9wdXJlLXJhbmQvbGliL2dlbmVyYXRvci9SYW5kb21HZW5lcmF0b3IuanMiLCJ3ZWJwYWNrOi8vcGFyemVjLy4vbm9kZV9tb2R1bGVzL3B1cmUtcmFuZC9saWIvZ2VuZXJhdG9yL1hvclNoaWZ0LmpzIiwid2VicGFjazovL3BhcnplYy8uL25vZGVfbW9kdWxlcy9wdXJlLXJhbmQvbGliL2dlbmVyYXRvci9Yb3JvU2hpcm8uanMiLCJ3ZWJwYWNrOi8vcGFyemVjLy4vbm9kZV9tb2R1bGVzL3B1cmUtcmFuZC9saWIvcHVyZS1yYW5kLWRlZmF1bHQuanMiLCJ3ZWJwYWNrOi8vcGFyemVjLy4vbm9kZV9tb2R1bGVzL3B1cmUtcmFuZC9saWIvcHVyZS1yYW5kLmpzIiwid2VicGFjazovL3BhcnplYy93ZWJwYWNrL2Jvb3RzdHJhcCIsIndlYnBhY2s6Ly9wYXJ6ZWMvd2VicGFjay9ydW50aW1lL2dsb2JhbCIsIndlYnBhY2s6Ly9wYXJ6ZWMvd2VicGFjay9ydW50aW1lL21ha2UgbmFtZXNwYWNlIG9iamVjdCIsIndlYnBhY2s6Ly9wYXJ6ZWMvd2VicGFjay9ydW50aW1lL25vZGUgbW9kdWxlIGRlY29yYXRvciIsIndlYnBhY2s6Ly9wYXJ6ZWMvLi9zcmMvdmlzdWFsaXplcnMvcnVuLWpzb24tdGVzdHMudHMiXSwic291cmNlc0NvbnRlbnQiOlsiLypcbkNvcHlyaWdodCAoYykgMjAxMi0yMDE0IENocmlzIFBldHRpdHRcblxuUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxub2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xudG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG5mdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuXG5UaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG5cblRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbklNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG5BVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG5MSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuVEhFIFNPRlRXQVJFLlxuKi9cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGdyYXBobGliOiByZXF1aXJlKFwiLi9saWIvZ3JhcGhsaWJcIiksXG5cbiAgbGF5b3V0OiByZXF1aXJlKFwiLi9saWIvbGF5b3V0XCIpLFxuICBkZWJ1ZzogcmVxdWlyZShcIi4vbGliL2RlYnVnXCIpLFxuICB1dGlsOiB7XG4gICAgdGltZTogcmVxdWlyZShcIi4vbGliL3V0aWxcIikudGltZSxcbiAgICBub3RpbWU6IHJlcXVpcmUoXCIuL2xpYi91dGlsXCIpLm5vdGltZVxuICB9LFxuICB2ZXJzaW9uOiByZXF1aXJlKFwiLi9saWIvdmVyc2lvblwiKVxufTtcbiIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgXyA9IHJlcXVpcmUoXCIuL2xvZGFzaFwiKTtcbnZhciBncmVlZHlGQVMgPSByZXF1aXJlKFwiLi9ncmVlZHktZmFzXCIpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgcnVuOiBydW4sXG4gIHVuZG86IHVuZG9cbn07XG5cbmZ1bmN0aW9uIHJ1bihnKSB7XG4gIHZhciBmYXMgPSAoZy5ncmFwaCgpLmFjeWNsaWNlciA9PT0gXCJncmVlZHlcIlxuICAgID8gZ3JlZWR5RkFTKGcsIHdlaWdodEZuKGcpKVxuICAgIDogZGZzRkFTKGcpKTtcbiAgXy5mb3JFYWNoKGZhcywgZnVuY3Rpb24oZSkge1xuICAgIHZhciBsYWJlbCA9IGcuZWRnZShlKTtcbiAgICBnLnJlbW92ZUVkZ2UoZSk7XG4gICAgbGFiZWwuZm9yd2FyZE5hbWUgPSBlLm5hbWU7XG4gICAgbGFiZWwucmV2ZXJzZWQgPSB0cnVlO1xuICAgIGcuc2V0RWRnZShlLncsIGUudiwgbGFiZWwsIF8udW5pcXVlSWQoXCJyZXZcIikpO1xuICB9KTtcblxuICBmdW5jdGlvbiB3ZWlnaHRGbihnKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKGUpIHtcbiAgICAgIHJldHVybiBnLmVkZ2UoZSkud2VpZ2h0O1xuICAgIH07XG4gIH1cbn1cblxuZnVuY3Rpb24gZGZzRkFTKGcpIHtcbiAgdmFyIGZhcyA9IFtdO1xuICB2YXIgc3RhY2sgPSB7fTtcbiAgdmFyIHZpc2l0ZWQgPSB7fTtcblxuICBmdW5jdGlvbiBkZnModikge1xuICAgIGlmIChfLmhhcyh2aXNpdGVkLCB2KSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2aXNpdGVkW3ZdID0gdHJ1ZTtcbiAgICBzdGFja1t2XSA9IHRydWU7XG4gICAgXy5mb3JFYWNoKGcub3V0RWRnZXModiksIGZ1bmN0aW9uKGUpIHtcbiAgICAgIGlmIChfLmhhcyhzdGFjaywgZS53KSkge1xuICAgICAgICBmYXMucHVzaChlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRmcyhlLncpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGRlbGV0ZSBzdGFja1t2XTtcbiAgfVxuXG4gIF8uZm9yRWFjaChnLm5vZGVzKCksIGRmcyk7XG4gIHJldHVybiBmYXM7XG59XG5cbmZ1bmN0aW9uIHVuZG8oZykge1xuICBfLmZvckVhY2goZy5lZGdlcygpLCBmdW5jdGlvbihlKSB7XG4gICAgdmFyIGxhYmVsID0gZy5lZGdlKGUpO1xuICAgIGlmIChsYWJlbC5yZXZlcnNlZCkge1xuICAgICAgZy5yZW1vdmVFZGdlKGUpO1xuXG4gICAgICB2YXIgZm9yd2FyZE5hbWUgPSBsYWJlbC5mb3J3YXJkTmFtZTtcbiAgICAgIGRlbGV0ZSBsYWJlbC5yZXZlcnNlZDtcbiAgICAgIGRlbGV0ZSBsYWJlbC5mb3J3YXJkTmFtZTtcbiAgICAgIGcuc2V0RWRnZShlLncsIGUudiwgbGFiZWwsIGZvcndhcmROYW1lKTtcbiAgICB9XG4gIH0pO1xufVxuIiwidmFyIF8gPSByZXF1aXJlKFwiLi9sb2Rhc2hcIik7XG52YXIgdXRpbCA9IHJlcXVpcmUoXCIuL3V0aWxcIik7XG5cbm1vZHVsZS5leHBvcnRzID0gYWRkQm9yZGVyU2VnbWVudHM7XG5cbmZ1bmN0aW9uIGFkZEJvcmRlclNlZ21lbnRzKGcpIHtcbiAgZnVuY3Rpb24gZGZzKHYpIHtcbiAgICB2YXIgY2hpbGRyZW4gPSBnLmNoaWxkcmVuKHYpO1xuICAgIHZhciBub2RlID0gZy5ub2RlKHYpO1xuICAgIGlmIChjaGlsZHJlbi5sZW5ndGgpIHtcbiAgICAgIF8uZm9yRWFjaChjaGlsZHJlbiwgZGZzKTtcbiAgICB9XG5cbiAgICBpZiAoXy5oYXMobm9kZSwgXCJtaW5SYW5rXCIpKSB7XG4gICAgICBub2RlLmJvcmRlckxlZnQgPSBbXTtcbiAgICAgIG5vZGUuYm9yZGVyUmlnaHQgPSBbXTtcbiAgICAgIGZvciAodmFyIHJhbmsgPSBub2RlLm1pblJhbmssIG1heFJhbmsgPSBub2RlLm1heFJhbmsgKyAxO1xuICAgICAgICByYW5rIDwgbWF4UmFuaztcbiAgICAgICAgKytyYW5rKSB7XG4gICAgICAgIGFkZEJvcmRlck5vZGUoZywgXCJib3JkZXJMZWZ0XCIsIFwiX2JsXCIsIHYsIG5vZGUsIHJhbmspO1xuICAgICAgICBhZGRCb3JkZXJOb2RlKGcsIFwiYm9yZGVyUmlnaHRcIiwgXCJfYnJcIiwgdiwgbm9kZSwgcmFuayk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgXy5mb3JFYWNoKGcuY2hpbGRyZW4oKSwgZGZzKTtcbn1cblxuZnVuY3Rpb24gYWRkQm9yZGVyTm9kZShnLCBwcm9wLCBwcmVmaXgsIHNnLCBzZ05vZGUsIHJhbmspIHtcbiAgdmFyIGxhYmVsID0geyB3aWR0aDogMCwgaGVpZ2h0OiAwLCByYW5rOiByYW5rLCBib3JkZXJUeXBlOiBwcm9wIH07XG4gIHZhciBwcmV2ID0gc2dOb2RlW3Byb3BdW3JhbmsgLSAxXTtcbiAgdmFyIGN1cnIgPSB1dGlsLmFkZER1bW15Tm9kZShnLCBcImJvcmRlclwiLCBsYWJlbCwgcHJlZml4KTtcbiAgc2dOb2RlW3Byb3BdW3JhbmtdID0gY3VycjtcbiAgZy5zZXRQYXJlbnQoY3Vyciwgc2cpO1xuICBpZiAocHJldikge1xuICAgIGcuc2V0RWRnZShwcmV2LCBjdXJyLCB7IHdlaWdodDogMSB9KTtcbiAgfVxufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfID0gcmVxdWlyZShcIi4vbG9kYXNoXCIpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgYWRqdXN0OiBhZGp1c3QsXG4gIHVuZG86IHVuZG9cbn07XG5cbmZ1bmN0aW9uIGFkanVzdChnKSB7XG4gIHZhciByYW5rRGlyID0gZy5ncmFwaCgpLnJhbmtkaXIudG9Mb3dlckNhc2UoKTtcbiAgaWYgKHJhbmtEaXIgPT09IFwibHJcIiB8fCByYW5rRGlyID09PSBcInJsXCIpIHtcbiAgICBzd2FwV2lkdGhIZWlnaHQoZyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gdW5kbyhnKSB7XG4gIHZhciByYW5rRGlyID0gZy5ncmFwaCgpLnJhbmtkaXIudG9Mb3dlckNhc2UoKTtcbiAgaWYgKHJhbmtEaXIgPT09IFwiYnRcIiB8fCByYW5rRGlyID09PSBcInJsXCIpIHtcbiAgICByZXZlcnNlWShnKTtcbiAgfVxuXG4gIGlmIChyYW5rRGlyID09PSBcImxyXCIgfHwgcmFua0RpciA9PT0gXCJybFwiKSB7XG4gICAgc3dhcFhZKGcpO1xuICAgIHN3YXBXaWR0aEhlaWdodChnKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzd2FwV2lkdGhIZWlnaHQoZykge1xuICBfLmZvckVhY2goZy5ub2RlcygpLCBmdW5jdGlvbih2KSB7IHN3YXBXaWR0aEhlaWdodE9uZShnLm5vZGUodikpOyB9KTtcbiAgXy5mb3JFYWNoKGcuZWRnZXMoKSwgZnVuY3Rpb24oZSkgeyBzd2FwV2lkdGhIZWlnaHRPbmUoZy5lZGdlKGUpKTsgfSk7XG59XG5cbmZ1bmN0aW9uIHN3YXBXaWR0aEhlaWdodE9uZShhdHRycykge1xuICB2YXIgdyA9IGF0dHJzLndpZHRoO1xuICBhdHRycy53aWR0aCA9IGF0dHJzLmhlaWdodDtcbiAgYXR0cnMuaGVpZ2h0ID0gdztcbn1cblxuZnVuY3Rpb24gcmV2ZXJzZVkoZykge1xuICBfLmZvckVhY2goZy5ub2RlcygpLCBmdW5jdGlvbih2KSB7IHJldmVyc2VZT25lKGcubm9kZSh2KSk7IH0pO1xuXG4gIF8uZm9yRWFjaChnLmVkZ2VzKCksIGZ1bmN0aW9uKGUpIHtcbiAgICB2YXIgZWRnZSA9IGcuZWRnZShlKTtcbiAgICBfLmZvckVhY2goZWRnZS5wb2ludHMsIHJldmVyc2VZT25lKTtcbiAgICBpZiAoXy5oYXMoZWRnZSwgXCJ5XCIpKSB7XG4gICAgICByZXZlcnNlWU9uZShlZGdlKTtcbiAgICB9XG4gIH0pO1xufVxuXG5mdW5jdGlvbiByZXZlcnNlWU9uZShhdHRycykge1xuICBhdHRycy55ID0gLWF0dHJzLnk7XG59XG5cbmZ1bmN0aW9uIHN3YXBYWShnKSB7XG4gIF8uZm9yRWFjaChnLm5vZGVzKCksIGZ1bmN0aW9uKHYpIHsgc3dhcFhZT25lKGcubm9kZSh2KSk7IH0pO1xuXG4gIF8uZm9yRWFjaChnLmVkZ2VzKCksIGZ1bmN0aW9uKGUpIHtcbiAgICB2YXIgZWRnZSA9IGcuZWRnZShlKTtcbiAgICBfLmZvckVhY2goZWRnZS5wb2ludHMsIHN3YXBYWU9uZSk7XG4gICAgaWYgKF8uaGFzKGVkZ2UsIFwieFwiKSkge1xuICAgICAgc3dhcFhZT25lKGVkZ2UpO1xuICAgIH1cbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHN3YXBYWU9uZShhdHRycykge1xuICB2YXIgeCA9IGF0dHJzLng7XG4gIGF0dHJzLnggPSBhdHRycy55O1xuICBhdHRycy55ID0geDtcbn1cbiIsIi8qXG4gKiBTaW1wbGUgZG91Ymx5IGxpbmtlZCBsaXN0IGltcGxlbWVudGF0aW9uIGRlcml2ZWQgZnJvbSBDb3JtZW4sIGV0IGFsLixcbiAqIFwiSW50cm9kdWN0aW9uIHRvIEFsZ29yaXRobXNcIi5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IExpc3Q7XG5cbmZ1bmN0aW9uIExpc3QoKSB7XG4gIHZhciBzZW50aW5lbCA9IHt9O1xuICBzZW50aW5lbC5fbmV4dCA9IHNlbnRpbmVsLl9wcmV2ID0gc2VudGluZWw7XG4gIHRoaXMuX3NlbnRpbmVsID0gc2VudGluZWw7XG59XG5cbkxpc3QucHJvdG90eXBlLmRlcXVldWUgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHNlbnRpbmVsID0gdGhpcy5fc2VudGluZWw7XG4gIHZhciBlbnRyeSA9IHNlbnRpbmVsLl9wcmV2O1xuICBpZiAoZW50cnkgIT09IHNlbnRpbmVsKSB7XG4gICAgdW5saW5rKGVudHJ5KTtcbiAgICByZXR1cm4gZW50cnk7XG4gIH1cbn07XG5cbkxpc3QucHJvdG90eXBlLmVucXVldWUgPSBmdW5jdGlvbihlbnRyeSkge1xuICB2YXIgc2VudGluZWwgPSB0aGlzLl9zZW50aW5lbDtcbiAgaWYgKGVudHJ5Ll9wcmV2ICYmIGVudHJ5Ll9uZXh0KSB7XG4gICAgdW5saW5rKGVudHJ5KTtcbiAgfVxuICBlbnRyeS5fbmV4dCA9IHNlbnRpbmVsLl9uZXh0O1xuICBzZW50aW5lbC5fbmV4dC5fcHJldiA9IGVudHJ5O1xuICBzZW50aW5lbC5fbmV4dCA9IGVudHJ5O1xuICBlbnRyeS5fcHJldiA9IHNlbnRpbmVsO1xufTtcblxuTGlzdC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHN0cnMgPSBbXTtcbiAgdmFyIHNlbnRpbmVsID0gdGhpcy5fc2VudGluZWw7XG4gIHZhciBjdXJyID0gc2VudGluZWwuX3ByZXY7XG4gIHdoaWxlIChjdXJyICE9PSBzZW50aW5lbCkge1xuICAgIHN0cnMucHVzaChKU09OLnN0cmluZ2lmeShjdXJyLCBmaWx0ZXJPdXRMaW5rcykpO1xuICAgIGN1cnIgPSBjdXJyLl9wcmV2O1xuICB9XG4gIHJldHVybiBcIltcIiArIHN0cnMuam9pbihcIiwgXCIpICsgXCJdXCI7XG59O1xuXG5mdW5jdGlvbiB1bmxpbmsoZW50cnkpIHtcbiAgZW50cnkuX3ByZXYuX25leHQgPSBlbnRyeS5fbmV4dDtcbiAgZW50cnkuX25leHQuX3ByZXYgPSBlbnRyeS5fcHJldjtcbiAgZGVsZXRlIGVudHJ5Ll9uZXh0O1xuICBkZWxldGUgZW50cnkuX3ByZXY7XG59XG5cbmZ1bmN0aW9uIGZpbHRlck91dExpbmtzKGssIHYpIHtcbiAgaWYgKGsgIT09IFwiX25leHRcIiAmJiBrICE9PSBcIl9wcmV2XCIpIHtcbiAgICByZXR1cm4gdjtcbiAgfVxufVxuIiwidmFyIF8gPSByZXF1aXJlKFwiLi9sb2Rhc2hcIik7XG52YXIgdXRpbCA9IHJlcXVpcmUoXCIuL3V0aWxcIik7XG52YXIgR3JhcGggPSByZXF1aXJlKFwiLi9ncmFwaGxpYlwiKS5HcmFwaDtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGRlYnVnT3JkZXJpbmc6IGRlYnVnT3JkZXJpbmdcbn07XG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5mdW5jdGlvbiBkZWJ1Z09yZGVyaW5nKGcpIHtcbiAgdmFyIGxheWVyTWF0cml4ID0gdXRpbC5idWlsZExheWVyTWF0cml4KGcpO1xuXG4gIHZhciBoID0gbmV3IEdyYXBoKHsgY29tcG91bmQ6IHRydWUsIG11bHRpZ3JhcGg6IHRydWUgfSkuc2V0R3JhcGgoe30pO1xuXG4gIF8uZm9yRWFjaChnLm5vZGVzKCksIGZ1bmN0aW9uKHYpIHtcbiAgICBoLnNldE5vZGUodiwgeyBsYWJlbDogdiB9KTtcbiAgICBoLnNldFBhcmVudCh2LCBcImxheWVyXCIgKyBnLm5vZGUodikucmFuayk7XG4gIH0pO1xuXG4gIF8uZm9yRWFjaChnLmVkZ2VzKCksIGZ1bmN0aW9uKGUpIHtcbiAgICBoLnNldEVkZ2UoZS52LCBlLncsIHt9LCBlLm5hbWUpO1xuICB9KTtcblxuICBfLmZvckVhY2gobGF5ZXJNYXRyaXgsIGZ1bmN0aW9uKGxheWVyLCBpKSB7XG4gICAgdmFyIGxheWVyViA9IFwibGF5ZXJcIiArIGk7XG4gICAgaC5zZXROb2RlKGxheWVyViwgeyByYW5rOiBcInNhbWVcIiB9KTtcbiAgICBfLnJlZHVjZShsYXllciwgZnVuY3Rpb24odSwgdikge1xuICAgICAgaC5zZXRFZGdlKHUsIHYsIHsgc3R5bGU6IFwiaW52aXNcIiB9KTtcbiAgICAgIHJldHVybiB2O1xuICAgIH0pO1xuICB9KTtcblxuICByZXR1cm4gaDtcbn1cbiIsIi8qIGdsb2JhbCB3aW5kb3cgKi9cblxudmFyIGdyYXBobGliO1xuXG5pZiAodHlwZW9mIHJlcXVpcmUgPT09IFwiZnVuY3Rpb25cIikge1xuICB0cnkge1xuICAgIGdyYXBobGliID0gcmVxdWlyZShcImdyYXBobGliXCIpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgLy8gY29udGludWUgcmVnYXJkbGVzcyBvZiBlcnJvclxuICB9XG59XG5cbmlmICghZ3JhcGhsaWIpIHtcbiAgZ3JhcGhsaWIgPSB3aW5kb3cuZ3JhcGhsaWI7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ3JhcGhsaWI7XG4iLCJ2YXIgXyA9IHJlcXVpcmUoXCIuL2xvZGFzaFwiKTtcbnZhciBHcmFwaCA9IHJlcXVpcmUoXCIuL2dyYXBobGliXCIpLkdyYXBoO1xudmFyIExpc3QgPSByZXF1aXJlKFwiLi9kYXRhL2xpc3RcIik7XG5cbi8qXG4gKiBBIGdyZWVkeSBoZXVyaXN0aWMgZm9yIGZpbmRpbmcgYSBmZWVkYmFjayBhcmMgc2V0IGZvciBhIGdyYXBoLiBBIGZlZWRiYWNrXG4gKiBhcmMgc2V0IGlzIGEgc2V0IG9mIGVkZ2VzIHRoYXQgY2FuIGJlIHJlbW92ZWQgdG8gbWFrZSBhIGdyYXBoIGFjeWNsaWMuXG4gKiBUaGUgYWxnb3JpdGhtIGNvbWVzIGZyb206IFAuIEVhZGVzLCBYLiBMaW4sIGFuZCBXLiBGLiBTbXl0aCwgXCJBIGZhc3QgYW5kXG4gKiBlZmZlY3RpdmUgaGV1cmlzdGljIGZvciB0aGUgZmVlZGJhY2sgYXJjIHNldCBwcm9ibGVtLlwiIFRoaXMgaW1wbGVtZW50YXRpb25cbiAqIGFkanVzdHMgdGhhdCBmcm9tIHRoZSBwYXBlciB0byBhbGxvdyBmb3Igd2VpZ2h0ZWQgZWRnZXMuXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZ3JlZWR5RkFTO1xuXG52YXIgREVGQVVMVF9XRUlHSFRfRk4gPSBfLmNvbnN0YW50KDEpO1xuXG5mdW5jdGlvbiBncmVlZHlGQVMoZywgd2VpZ2h0Rm4pIHtcbiAgaWYgKGcubm9kZUNvdW50KCkgPD0gMSkge1xuICAgIHJldHVybiBbXTtcbiAgfVxuICB2YXIgc3RhdGUgPSBidWlsZFN0YXRlKGcsIHdlaWdodEZuIHx8IERFRkFVTFRfV0VJR0hUX0ZOKTtcbiAgdmFyIHJlc3VsdHMgPSBkb0dyZWVkeUZBUyhzdGF0ZS5ncmFwaCwgc3RhdGUuYnVja2V0cywgc3RhdGUuemVyb0lkeCk7XG5cbiAgLy8gRXhwYW5kIG11bHRpLWVkZ2VzXG4gIHJldHVybiBfLmZsYXR0ZW4oXy5tYXAocmVzdWx0cywgZnVuY3Rpb24oZSkge1xuICAgIHJldHVybiBnLm91dEVkZ2VzKGUudiwgZS53KTtcbiAgfSksIHRydWUpO1xufVxuXG5mdW5jdGlvbiBkb0dyZWVkeUZBUyhnLCBidWNrZXRzLCB6ZXJvSWR4KSB7XG4gIHZhciByZXN1bHRzID0gW107XG4gIHZhciBzb3VyY2VzID0gYnVja2V0c1tidWNrZXRzLmxlbmd0aCAtIDFdO1xuICB2YXIgc2lua3MgPSBidWNrZXRzWzBdO1xuXG4gIHZhciBlbnRyeTtcbiAgd2hpbGUgKGcubm9kZUNvdW50KCkpIHtcbiAgICB3aGlsZSAoKGVudHJ5ID0gc2lua3MuZGVxdWV1ZSgpKSkgICB7IHJlbW92ZU5vZGUoZywgYnVja2V0cywgemVyb0lkeCwgZW50cnkpOyB9XG4gICAgd2hpbGUgKChlbnRyeSA9IHNvdXJjZXMuZGVxdWV1ZSgpKSkgeyByZW1vdmVOb2RlKGcsIGJ1Y2tldHMsIHplcm9JZHgsIGVudHJ5KTsgfVxuICAgIGlmIChnLm5vZGVDb3VudCgpKSB7XG4gICAgICBmb3IgKHZhciBpID0gYnVja2V0cy5sZW5ndGggLSAyOyBpID4gMDsgLS1pKSB7XG4gICAgICAgIGVudHJ5ID0gYnVja2V0c1tpXS5kZXF1ZXVlKCk7XG4gICAgICAgIGlmIChlbnRyeSkge1xuICAgICAgICAgIHJlc3VsdHMgPSByZXN1bHRzLmNvbmNhdChyZW1vdmVOb2RlKGcsIGJ1Y2tldHMsIHplcm9JZHgsIGVudHJ5LCB0cnVlKSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVzdWx0cztcbn1cblxuZnVuY3Rpb24gcmVtb3ZlTm9kZShnLCBidWNrZXRzLCB6ZXJvSWR4LCBlbnRyeSwgY29sbGVjdFByZWRlY2Vzc29ycykge1xuICB2YXIgcmVzdWx0cyA9IGNvbGxlY3RQcmVkZWNlc3NvcnMgPyBbXSA6IHVuZGVmaW5lZDtcblxuICBfLmZvckVhY2goZy5pbkVkZ2VzKGVudHJ5LnYpLCBmdW5jdGlvbihlZGdlKSB7XG4gICAgdmFyIHdlaWdodCA9IGcuZWRnZShlZGdlKTtcbiAgICB2YXIgdUVudHJ5ID0gZy5ub2RlKGVkZ2Uudik7XG5cbiAgICBpZiAoY29sbGVjdFByZWRlY2Vzc29ycykge1xuICAgICAgcmVzdWx0cy5wdXNoKHsgdjogZWRnZS52LCB3OiBlZGdlLncgfSk7XG4gICAgfVxuXG4gICAgdUVudHJ5Lm91dCAtPSB3ZWlnaHQ7XG4gICAgYXNzaWduQnVja2V0KGJ1Y2tldHMsIHplcm9JZHgsIHVFbnRyeSk7XG4gIH0pO1xuXG4gIF8uZm9yRWFjaChnLm91dEVkZ2VzKGVudHJ5LnYpLCBmdW5jdGlvbihlZGdlKSB7XG4gICAgdmFyIHdlaWdodCA9IGcuZWRnZShlZGdlKTtcbiAgICB2YXIgdyA9IGVkZ2UudztcbiAgICB2YXIgd0VudHJ5ID0gZy5ub2RlKHcpO1xuICAgIHdFbnRyeVtcImluXCJdIC09IHdlaWdodDtcbiAgICBhc3NpZ25CdWNrZXQoYnVja2V0cywgemVyb0lkeCwgd0VudHJ5KTtcbiAgfSk7XG5cbiAgZy5yZW1vdmVOb2RlKGVudHJ5LnYpO1xuXG4gIHJldHVybiByZXN1bHRzO1xufVxuXG5mdW5jdGlvbiBidWlsZFN0YXRlKGcsIHdlaWdodEZuKSB7XG4gIHZhciBmYXNHcmFwaCA9IG5ldyBHcmFwaCgpO1xuICB2YXIgbWF4SW4gPSAwO1xuICB2YXIgbWF4T3V0ID0gMDtcblxuICBfLmZvckVhY2goZy5ub2RlcygpLCBmdW5jdGlvbih2KSB7XG4gICAgZmFzR3JhcGguc2V0Tm9kZSh2LCB7IHY6IHYsIFwiaW5cIjogMCwgb3V0OiAwIH0pO1xuICB9KTtcblxuICAvLyBBZ2dyZWdhdGUgd2VpZ2h0cyBvbiBub2RlcywgYnV0IGFsc28gc3VtIHRoZSB3ZWlnaHRzIGFjcm9zcyBtdWx0aS1lZGdlc1xuICAvLyBpbnRvIGEgc2luZ2xlIGVkZ2UgZm9yIHRoZSBmYXNHcmFwaC5cbiAgXy5mb3JFYWNoKGcuZWRnZXMoKSwgZnVuY3Rpb24oZSkge1xuICAgIHZhciBwcmV2V2VpZ2h0ID0gZmFzR3JhcGguZWRnZShlLnYsIGUudykgfHwgMDtcbiAgICB2YXIgd2VpZ2h0ID0gd2VpZ2h0Rm4oZSk7XG4gICAgdmFyIGVkZ2VXZWlnaHQgPSBwcmV2V2VpZ2h0ICsgd2VpZ2h0O1xuICAgIGZhc0dyYXBoLnNldEVkZ2UoZS52LCBlLncsIGVkZ2VXZWlnaHQpO1xuICAgIG1heE91dCA9IE1hdGgubWF4KG1heE91dCwgZmFzR3JhcGgubm9kZShlLnYpLm91dCArPSB3ZWlnaHQpO1xuICAgIG1heEluICA9IE1hdGgubWF4KG1heEluLCAgZmFzR3JhcGgubm9kZShlLncpW1wiaW5cIl0gICs9IHdlaWdodCk7XG4gIH0pO1xuXG4gIHZhciBidWNrZXRzID0gXy5yYW5nZShtYXhPdXQgKyBtYXhJbiArIDMpLm1hcChmdW5jdGlvbigpIHsgcmV0dXJuIG5ldyBMaXN0KCk7IH0pO1xuICB2YXIgemVyb0lkeCA9IG1heEluICsgMTtcblxuICBfLmZvckVhY2goZmFzR3JhcGgubm9kZXMoKSwgZnVuY3Rpb24odikge1xuICAgIGFzc2lnbkJ1Y2tldChidWNrZXRzLCB6ZXJvSWR4LCBmYXNHcmFwaC5ub2RlKHYpKTtcbiAgfSk7XG5cbiAgcmV0dXJuIHsgZ3JhcGg6IGZhc0dyYXBoLCBidWNrZXRzOiBidWNrZXRzLCB6ZXJvSWR4OiB6ZXJvSWR4IH07XG59XG5cbmZ1bmN0aW9uIGFzc2lnbkJ1Y2tldChidWNrZXRzLCB6ZXJvSWR4LCBlbnRyeSkge1xuICBpZiAoIWVudHJ5Lm91dCkge1xuICAgIGJ1Y2tldHNbMF0uZW5xdWV1ZShlbnRyeSk7XG4gIH0gZWxzZSBpZiAoIWVudHJ5W1wiaW5cIl0pIHtcbiAgICBidWNrZXRzW2J1Y2tldHMubGVuZ3RoIC0gMV0uZW5xdWV1ZShlbnRyeSk7XG4gIH0gZWxzZSB7XG4gICAgYnVja2V0c1tlbnRyeS5vdXQgLSBlbnRyeVtcImluXCJdICsgemVyb0lkeF0uZW5xdWV1ZShlbnRyeSk7XG4gIH1cbn1cbiIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgXyA9IHJlcXVpcmUoXCIuL2xvZGFzaFwiKTtcbnZhciBhY3ljbGljID0gcmVxdWlyZShcIi4vYWN5Y2xpY1wiKTtcbnZhciBub3JtYWxpemUgPSByZXF1aXJlKFwiLi9ub3JtYWxpemVcIik7XG52YXIgcmFuayA9IHJlcXVpcmUoXCIuL3JhbmtcIik7XG52YXIgbm9ybWFsaXplUmFua3MgPSByZXF1aXJlKFwiLi91dGlsXCIpLm5vcm1hbGl6ZVJhbmtzO1xudmFyIHBhcmVudER1bW15Q2hhaW5zID0gcmVxdWlyZShcIi4vcGFyZW50LWR1bW15LWNoYWluc1wiKTtcbnZhciByZW1vdmVFbXB0eVJhbmtzID0gcmVxdWlyZShcIi4vdXRpbFwiKS5yZW1vdmVFbXB0eVJhbmtzO1xudmFyIG5lc3RpbmdHcmFwaCA9IHJlcXVpcmUoXCIuL25lc3RpbmctZ3JhcGhcIik7XG52YXIgYWRkQm9yZGVyU2VnbWVudHMgPSByZXF1aXJlKFwiLi9hZGQtYm9yZGVyLXNlZ21lbnRzXCIpO1xudmFyIGNvb3JkaW5hdGVTeXN0ZW0gPSByZXF1aXJlKFwiLi9jb29yZGluYXRlLXN5c3RlbVwiKTtcbnZhciBvcmRlciA9IHJlcXVpcmUoXCIuL29yZGVyXCIpO1xudmFyIHBvc2l0aW9uID0gcmVxdWlyZShcIi4vcG9zaXRpb25cIik7XG52YXIgdXRpbCA9IHJlcXVpcmUoXCIuL3V0aWxcIik7XG52YXIgR3JhcGggPSByZXF1aXJlKFwiLi9ncmFwaGxpYlwiKS5HcmFwaDtcblxubW9kdWxlLmV4cG9ydHMgPSBsYXlvdXQ7XG5cbmZ1bmN0aW9uIGxheW91dChnLCBvcHRzKSB7XG4gIHZhciB0aW1lID0gb3B0cyAmJiBvcHRzLmRlYnVnVGltaW5nID8gdXRpbC50aW1lIDogdXRpbC5ub3RpbWU7XG4gIHRpbWUoXCJsYXlvdXRcIiwgZnVuY3Rpb24oKSB7XG4gICAgdmFyIGxheW91dEdyYXBoID0gXG4gICAgICB0aW1lKFwiICBidWlsZExheW91dEdyYXBoXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gYnVpbGRMYXlvdXRHcmFwaChnKTsgfSk7XG4gICAgdGltZShcIiAgcnVuTGF5b3V0XCIsICAgICAgICBmdW5jdGlvbigpIHsgcnVuTGF5b3V0KGxheW91dEdyYXBoLCB0aW1lKTsgfSk7XG4gICAgdGltZShcIiAgdXBkYXRlSW5wdXRHcmFwaFwiLCBmdW5jdGlvbigpIHsgdXBkYXRlSW5wdXRHcmFwaChnLCBsYXlvdXRHcmFwaCk7IH0pO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gcnVuTGF5b3V0KGcsIHRpbWUpIHtcbiAgdGltZShcIiAgICBtYWtlU3BhY2VGb3JFZGdlTGFiZWxzXCIsIGZ1bmN0aW9uKCkgeyBtYWtlU3BhY2VGb3JFZGdlTGFiZWxzKGcpOyB9KTtcbiAgdGltZShcIiAgICByZW1vdmVTZWxmRWRnZXNcIiwgICAgICAgIGZ1bmN0aW9uKCkgeyByZW1vdmVTZWxmRWRnZXMoZyk7IH0pO1xuICB0aW1lKFwiICAgIGFjeWNsaWNcIiwgICAgICAgICAgICAgICAgZnVuY3Rpb24oKSB7IGFjeWNsaWMucnVuKGcpOyB9KTtcbiAgdGltZShcIiAgICBuZXN0aW5nR3JhcGgucnVuXCIsICAgICAgIGZ1bmN0aW9uKCkgeyBuZXN0aW5nR3JhcGgucnVuKGcpOyB9KTtcbiAgdGltZShcIiAgICByYW5rXCIsICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uKCkgeyByYW5rKHV0aWwuYXNOb25Db21wb3VuZEdyYXBoKGcpKTsgfSk7XG4gIHRpbWUoXCIgICAgaW5qZWN0RWRnZUxhYmVsUHJveGllc1wiLCBmdW5jdGlvbigpIHsgaW5qZWN0RWRnZUxhYmVsUHJveGllcyhnKTsgfSk7XG4gIHRpbWUoXCIgICAgcmVtb3ZlRW1wdHlSYW5rc1wiLCAgICAgICBmdW5jdGlvbigpIHsgcmVtb3ZlRW1wdHlSYW5rcyhnKTsgfSk7XG4gIHRpbWUoXCIgICAgbmVzdGluZ0dyYXBoLmNsZWFudXBcIiwgICBmdW5jdGlvbigpIHsgbmVzdGluZ0dyYXBoLmNsZWFudXAoZyk7IH0pO1xuICB0aW1lKFwiICAgIG5vcm1hbGl6ZVJhbmtzXCIsICAgICAgICAgZnVuY3Rpb24oKSB7IG5vcm1hbGl6ZVJhbmtzKGcpOyB9KTtcbiAgdGltZShcIiAgICBhc3NpZ25SYW5rTWluTWF4XCIsICAgICAgIGZ1bmN0aW9uKCkgeyBhc3NpZ25SYW5rTWluTWF4KGcpOyB9KTtcbiAgdGltZShcIiAgICByZW1vdmVFZGdlTGFiZWxQcm94aWVzXCIsIGZ1bmN0aW9uKCkgeyByZW1vdmVFZGdlTGFiZWxQcm94aWVzKGcpOyB9KTtcbiAgdGltZShcIiAgICBub3JtYWxpemUucnVuXCIsICAgICAgICAgIGZ1bmN0aW9uKCkgeyBub3JtYWxpemUucnVuKGcpOyB9KTtcbiAgdGltZShcIiAgICBwYXJlbnREdW1teUNoYWluc1wiLCAgICAgIGZ1bmN0aW9uKCkgeyBwYXJlbnREdW1teUNoYWlucyhnKTsgfSk7XG4gIHRpbWUoXCIgICAgYWRkQm9yZGVyU2VnbWVudHNcIiwgICAgICBmdW5jdGlvbigpIHsgYWRkQm9yZGVyU2VnbWVudHMoZyk7IH0pO1xuICB0aW1lKFwiICAgIG9yZGVyXCIsICAgICAgICAgICAgICAgICAgZnVuY3Rpb24oKSB7IG9yZGVyKGcpOyB9KTtcbiAgdGltZShcIiAgICBpbnNlcnRTZWxmRWRnZXNcIiwgICAgICAgIGZ1bmN0aW9uKCkgeyBpbnNlcnRTZWxmRWRnZXMoZyk7IH0pO1xuICB0aW1lKFwiICAgIGFkanVzdENvb3JkaW5hdGVTeXN0ZW1cIiwgZnVuY3Rpb24oKSB7IGNvb3JkaW5hdGVTeXN0ZW0uYWRqdXN0KGcpOyB9KTtcbiAgdGltZShcIiAgICBwb3NpdGlvblwiLCAgICAgICAgICAgICAgIGZ1bmN0aW9uKCkgeyBwb3NpdGlvbihnKTsgfSk7XG4gIHRpbWUoXCIgICAgcG9zaXRpb25TZWxmRWRnZXNcIiwgICAgICBmdW5jdGlvbigpIHsgcG9zaXRpb25TZWxmRWRnZXMoZyk7IH0pO1xuICB0aW1lKFwiICAgIHJlbW92ZUJvcmRlck5vZGVzXCIsICAgICAgZnVuY3Rpb24oKSB7IHJlbW92ZUJvcmRlck5vZGVzKGcpOyB9KTtcbiAgdGltZShcIiAgICBub3JtYWxpemUudW5kb1wiLCAgICAgICAgIGZ1bmN0aW9uKCkgeyBub3JtYWxpemUudW5kbyhnKTsgfSk7XG4gIHRpbWUoXCIgICAgZml4dXBFZGdlTGFiZWxDb29yZHNcIiwgICBmdW5jdGlvbigpIHsgZml4dXBFZGdlTGFiZWxDb29yZHMoZyk7IH0pO1xuICB0aW1lKFwiICAgIHVuZG9Db29yZGluYXRlU3lzdGVtXCIsICAgZnVuY3Rpb24oKSB7IGNvb3JkaW5hdGVTeXN0ZW0udW5kbyhnKTsgfSk7XG4gIHRpbWUoXCIgICAgdHJhbnNsYXRlR3JhcGhcIiwgICAgICAgICBmdW5jdGlvbigpIHsgdHJhbnNsYXRlR3JhcGgoZyk7IH0pO1xuICB0aW1lKFwiICAgIGFzc2lnbk5vZGVJbnRlcnNlY3RzXCIsICAgZnVuY3Rpb24oKSB7IGFzc2lnbk5vZGVJbnRlcnNlY3RzKGcpOyB9KTtcbiAgdGltZShcIiAgICByZXZlcnNlUG9pbnRzXCIsICAgICAgICAgIGZ1bmN0aW9uKCkgeyByZXZlcnNlUG9pbnRzRm9yUmV2ZXJzZWRFZGdlcyhnKTsgfSk7XG4gIHRpbWUoXCIgICAgYWN5Y2xpYy51bmRvXCIsICAgICAgICAgICBmdW5jdGlvbigpIHsgYWN5Y2xpYy51bmRvKGcpOyB9KTtcbn1cblxuLypcbiAqIENvcGllcyBmaW5hbCBsYXlvdXQgaW5mb3JtYXRpb24gZnJvbSB0aGUgbGF5b3V0IGdyYXBoIGJhY2sgdG8gdGhlIGlucHV0XG4gKiBncmFwaC4gVGhpcyBwcm9jZXNzIG9ubHkgY29waWVzIHdoaXRlbGlzdGVkIGF0dHJpYnV0ZXMgZnJvbSB0aGUgbGF5b3V0IGdyYXBoXG4gKiB0byB0aGUgaW5wdXQgZ3JhcGgsIHNvIGl0IHNlcnZlcyBhcyBhIGdvb2QgcGxhY2UgdG8gZGV0ZXJtaW5lIHdoYXRcbiAqIGF0dHJpYnV0ZXMgY2FuIGluZmx1ZW5jZSBsYXlvdXQuXG4gKi9cbmZ1bmN0aW9uIHVwZGF0ZUlucHV0R3JhcGgoaW5wdXRHcmFwaCwgbGF5b3V0R3JhcGgpIHtcbiAgXy5mb3JFYWNoKGlucHV0R3JhcGgubm9kZXMoKSwgZnVuY3Rpb24odikge1xuICAgIHZhciBpbnB1dExhYmVsID0gaW5wdXRHcmFwaC5ub2RlKHYpO1xuICAgIHZhciBsYXlvdXRMYWJlbCA9IGxheW91dEdyYXBoLm5vZGUodik7XG5cbiAgICBpZiAoaW5wdXRMYWJlbCkge1xuICAgICAgaW5wdXRMYWJlbC54ID0gbGF5b3V0TGFiZWwueDtcbiAgICAgIGlucHV0TGFiZWwueSA9IGxheW91dExhYmVsLnk7XG5cbiAgICAgIGlmIChsYXlvdXRHcmFwaC5jaGlsZHJlbih2KS5sZW5ndGgpIHtcbiAgICAgICAgaW5wdXRMYWJlbC53aWR0aCA9IGxheW91dExhYmVsLndpZHRoO1xuICAgICAgICBpbnB1dExhYmVsLmhlaWdodCA9IGxheW91dExhYmVsLmhlaWdodDtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuXG4gIF8uZm9yRWFjaChpbnB1dEdyYXBoLmVkZ2VzKCksIGZ1bmN0aW9uKGUpIHtcbiAgICB2YXIgaW5wdXRMYWJlbCA9IGlucHV0R3JhcGguZWRnZShlKTtcbiAgICB2YXIgbGF5b3V0TGFiZWwgPSBsYXlvdXRHcmFwaC5lZGdlKGUpO1xuXG4gICAgaW5wdXRMYWJlbC5wb2ludHMgPSBsYXlvdXRMYWJlbC5wb2ludHM7XG4gICAgaWYgKF8uaGFzKGxheW91dExhYmVsLCBcInhcIikpIHtcbiAgICAgIGlucHV0TGFiZWwueCA9IGxheW91dExhYmVsLng7XG4gICAgICBpbnB1dExhYmVsLnkgPSBsYXlvdXRMYWJlbC55O1xuICAgIH1cbiAgfSk7XG5cbiAgaW5wdXRHcmFwaC5ncmFwaCgpLndpZHRoID0gbGF5b3V0R3JhcGguZ3JhcGgoKS53aWR0aDtcbiAgaW5wdXRHcmFwaC5ncmFwaCgpLmhlaWdodCA9IGxheW91dEdyYXBoLmdyYXBoKCkuaGVpZ2h0O1xufVxuXG52YXIgZ3JhcGhOdW1BdHRycyA9IFtcIm5vZGVzZXBcIiwgXCJlZGdlc2VwXCIsIFwicmFua3NlcFwiLCBcIm1hcmdpbnhcIiwgXCJtYXJnaW55XCJdO1xudmFyIGdyYXBoRGVmYXVsdHMgPSB7IHJhbmtzZXA6IDUwLCBlZGdlc2VwOiAyMCwgbm9kZXNlcDogNTAsIHJhbmtkaXI6IFwidGJcIiB9O1xudmFyIGdyYXBoQXR0cnMgPSBbXCJhY3ljbGljZXJcIiwgXCJyYW5rZXJcIiwgXCJyYW5rZGlyXCIsIFwiYWxpZ25cIl07XG52YXIgbm9kZU51bUF0dHJzID0gW1wid2lkdGhcIiwgXCJoZWlnaHRcIl07XG52YXIgbm9kZURlZmF1bHRzID0geyB3aWR0aDogMCwgaGVpZ2h0OiAwIH07XG52YXIgZWRnZU51bUF0dHJzID0gW1wibWlubGVuXCIsIFwid2VpZ2h0XCIsIFwid2lkdGhcIiwgXCJoZWlnaHRcIiwgXCJsYWJlbG9mZnNldFwiXTtcbnZhciBlZGdlRGVmYXVsdHMgPSB7XG4gIG1pbmxlbjogMSwgd2VpZ2h0OiAxLCB3aWR0aDogMCwgaGVpZ2h0OiAwLFxuICBsYWJlbG9mZnNldDogMTAsIGxhYmVscG9zOiBcInJcIlxufTtcbnZhciBlZGdlQXR0cnMgPSBbXCJsYWJlbHBvc1wiXTtcblxuLypcbiAqIENvbnN0cnVjdHMgYSBuZXcgZ3JhcGggZnJvbSB0aGUgaW5wdXQgZ3JhcGgsIHdoaWNoIGNhbiBiZSB1c2VkIGZvciBsYXlvdXQuXG4gKiBUaGlzIHByb2Nlc3MgY29waWVzIG9ubHkgd2hpdGVsaXN0ZWQgYXR0cmlidXRlcyBmcm9tIHRoZSBpbnB1dCBncmFwaCB0byB0aGVcbiAqIGxheW91dCBncmFwaC4gVGh1cyB0aGlzIGZ1bmN0aW9uIHNlcnZlcyBhcyBhIGdvb2QgcGxhY2UgdG8gZGV0ZXJtaW5lIHdoYXRcbiAqIGF0dHJpYnV0ZXMgY2FuIGluZmx1ZW5jZSBsYXlvdXQuXG4gKi9cbmZ1bmN0aW9uIGJ1aWxkTGF5b3V0R3JhcGgoaW5wdXRHcmFwaCkge1xuICB2YXIgZyA9IG5ldyBHcmFwaCh7IG11bHRpZ3JhcGg6IHRydWUsIGNvbXBvdW5kOiB0cnVlIH0pO1xuICB2YXIgZ3JhcGggPSBjYW5vbmljYWxpemUoaW5wdXRHcmFwaC5ncmFwaCgpKTtcblxuICBnLnNldEdyYXBoKF8ubWVyZ2Uoe30sXG4gICAgZ3JhcGhEZWZhdWx0cyxcbiAgICBzZWxlY3ROdW1iZXJBdHRycyhncmFwaCwgZ3JhcGhOdW1BdHRycyksXG4gICAgXy5waWNrKGdyYXBoLCBncmFwaEF0dHJzKSkpO1xuXG4gIF8uZm9yRWFjaChpbnB1dEdyYXBoLm5vZGVzKCksIGZ1bmN0aW9uKHYpIHtcbiAgICB2YXIgbm9kZSA9IGNhbm9uaWNhbGl6ZShpbnB1dEdyYXBoLm5vZGUodikpO1xuICAgIGcuc2V0Tm9kZSh2LCBfLmRlZmF1bHRzKHNlbGVjdE51bWJlckF0dHJzKG5vZGUsIG5vZGVOdW1BdHRycyksIG5vZGVEZWZhdWx0cykpO1xuICAgIGcuc2V0UGFyZW50KHYsIGlucHV0R3JhcGgucGFyZW50KHYpKTtcbiAgfSk7XG5cbiAgXy5mb3JFYWNoKGlucHV0R3JhcGguZWRnZXMoKSwgZnVuY3Rpb24oZSkge1xuICAgIHZhciBlZGdlID0gY2Fub25pY2FsaXplKGlucHV0R3JhcGguZWRnZShlKSk7XG4gICAgZy5zZXRFZGdlKGUsIF8ubWVyZ2Uoe30sXG4gICAgICBlZGdlRGVmYXVsdHMsXG4gICAgICBzZWxlY3ROdW1iZXJBdHRycyhlZGdlLCBlZGdlTnVtQXR0cnMpLFxuICAgICAgXy5waWNrKGVkZ2UsIGVkZ2VBdHRycykpKTtcbiAgfSk7XG5cbiAgcmV0dXJuIGc7XG59XG5cbi8qXG4gKiBUaGlzIGlkZWEgY29tZXMgZnJvbSB0aGUgR2Fuc25lciBwYXBlcjogdG8gYWNjb3VudCBmb3IgZWRnZSBsYWJlbHMgaW4gb3VyXG4gKiBsYXlvdXQgd2Ugc3BsaXQgZWFjaCByYW5rIGluIGhhbGYgYnkgZG91YmxpbmcgbWlubGVuIGFuZCBoYWx2aW5nIHJhbmtzZXAuXG4gKiBUaGVuIHdlIGNhbiBwbGFjZSBsYWJlbHMgYXQgdGhlc2UgbWlkLXBvaW50cyBiZXR3ZWVuIG5vZGVzLlxuICpcbiAqIFdlIGFsc28gYWRkIHNvbWUgbWluaW1hbCBwYWRkaW5nIHRvIHRoZSB3aWR0aCB0byBwdXNoIHRoZSBsYWJlbCBmb3IgdGhlIGVkZ2VcbiAqIGF3YXkgZnJvbSB0aGUgZWRnZSBpdHNlbGYgYSBiaXQuXG4gKi9cbmZ1bmN0aW9uIG1ha2VTcGFjZUZvckVkZ2VMYWJlbHMoZykge1xuICB2YXIgZ3JhcGggPSBnLmdyYXBoKCk7XG4gIGdyYXBoLnJhbmtzZXAgLz0gMjtcbiAgXy5mb3JFYWNoKGcuZWRnZXMoKSwgZnVuY3Rpb24oZSkge1xuICAgIHZhciBlZGdlID0gZy5lZGdlKGUpO1xuICAgIGVkZ2UubWlubGVuICo9IDI7XG4gICAgaWYgKGVkZ2UubGFiZWxwb3MudG9Mb3dlckNhc2UoKSAhPT0gXCJjXCIpIHtcbiAgICAgIGlmIChncmFwaC5yYW5rZGlyID09PSBcIlRCXCIgfHwgZ3JhcGgucmFua2RpciA9PT0gXCJCVFwiKSB7XG4gICAgICAgIGVkZ2Uud2lkdGggKz0gZWRnZS5sYWJlbG9mZnNldDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVkZ2UuaGVpZ2h0ICs9IGVkZ2UubGFiZWxvZmZzZXQ7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbn1cblxuLypcbiAqIENyZWF0ZXMgdGVtcG9yYXJ5IGR1bW15IG5vZGVzIHRoYXQgY2FwdHVyZSB0aGUgcmFuayBpbiB3aGljaCBlYWNoIGVkZ2Unc1xuICogbGFiZWwgaXMgZ29pbmcgdG8sIGlmIGl0IGhhcyBvbmUgb2Ygbm9uLXplcm8gd2lkdGggYW5kIGhlaWdodC4gV2UgZG8gdGhpc1xuICogc28gdGhhdCB3ZSBjYW4gc2FmZWx5IHJlbW92ZSBlbXB0eSByYW5rcyB3aGlsZSBwcmVzZXJ2aW5nIGJhbGFuY2UgZm9yIHRoZVxuICogbGFiZWwncyBwb3NpdGlvbi5cbiAqL1xuZnVuY3Rpb24gaW5qZWN0RWRnZUxhYmVsUHJveGllcyhnKSB7XG4gIF8uZm9yRWFjaChnLmVkZ2VzKCksIGZ1bmN0aW9uKGUpIHtcbiAgICB2YXIgZWRnZSA9IGcuZWRnZShlKTtcbiAgICBpZiAoZWRnZS53aWR0aCAmJiBlZGdlLmhlaWdodCkge1xuICAgICAgdmFyIHYgPSBnLm5vZGUoZS52KTtcbiAgICAgIHZhciB3ID0gZy5ub2RlKGUudyk7XG4gICAgICB2YXIgbGFiZWwgPSB7IHJhbms6ICh3LnJhbmsgLSB2LnJhbmspIC8gMiArIHYucmFuaywgZTogZSB9O1xuICAgICAgdXRpbC5hZGREdW1teU5vZGUoZywgXCJlZGdlLXByb3h5XCIsIGxhYmVsLCBcIl9lcFwiKTtcbiAgICB9XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBhc3NpZ25SYW5rTWluTWF4KGcpIHtcbiAgdmFyIG1heFJhbmsgPSAwO1xuICBfLmZvckVhY2goZy5ub2RlcygpLCBmdW5jdGlvbih2KSB7XG4gICAgdmFyIG5vZGUgPSBnLm5vZGUodik7XG4gICAgaWYgKG5vZGUuYm9yZGVyVG9wKSB7XG4gICAgICBub2RlLm1pblJhbmsgPSBnLm5vZGUobm9kZS5ib3JkZXJUb3ApLnJhbms7XG4gICAgICBub2RlLm1heFJhbmsgPSBnLm5vZGUobm9kZS5ib3JkZXJCb3R0b20pLnJhbms7XG4gICAgICBtYXhSYW5rID0gXy5tYXgobWF4UmFuaywgbm9kZS5tYXhSYW5rKTtcbiAgICB9XG4gIH0pO1xuICBnLmdyYXBoKCkubWF4UmFuayA9IG1heFJhbms7XG59XG5cbmZ1bmN0aW9uIHJlbW92ZUVkZ2VMYWJlbFByb3hpZXMoZykge1xuICBfLmZvckVhY2goZy5ub2RlcygpLCBmdW5jdGlvbih2KSB7XG4gICAgdmFyIG5vZGUgPSBnLm5vZGUodik7XG4gICAgaWYgKG5vZGUuZHVtbXkgPT09IFwiZWRnZS1wcm94eVwiKSB7XG4gICAgICBnLmVkZ2Uobm9kZS5lKS5sYWJlbFJhbmsgPSBub2RlLnJhbms7XG4gICAgICBnLnJlbW92ZU5vZGUodik7XG4gICAgfVxuICB9KTtcbn1cblxuZnVuY3Rpb24gdHJhbnNsYXRlR3JhcGgoZykge1xuICB2YXIgbWluWCA9IE51bWJlci5QT1NJVElWRV9JTkZJTklUWTtcbiAgdmFyIG1heFggPSAwO1xuICB2YXIgbWluWSA9IE51bWJlci5QT1NJVElWRV9JTkZJTklUWTtcbiAgdmFyIG1heFkgPSAwO1xuICB2YXIgZ3JhcGhMYWJlbCA9IGcuZ3JhcGgoKTtcbiAgdmFyIG1hcmdpblggPSBncmFwaExhYmVsLm1hcmdpbnggfHwgMDtcbiAgdmFyIG1hcmdpblkgPSBncmFwaExhYmVsLm1hcmdpbnkgfHwgMDtcblxuICBmdW5jdGlvbiBnZXRFeHRyZW1lcyhhdHRycykge1xuICAgIHZhciB4ID0gYXR0cnMueDtcbiAgICB2YXIgeSA9IGF0dHJzLnk7XG4gICAgdmFyIHcgPSBhdHRycy53aWR0aDtcbiAgICB2YXIgaCA9IGF0dHJzLmhlaWdodDtcbiAgICBtaW5YID0gTWF0aC5taW4obWluWCwgeCAtIHcgLyAyKTtcbiAgICBtYXhYID0gTWF0aC5tYXgobWF4WCwgeCArIHcgLyAyKTtcbiAgICBtaW5ZID0gTWF0aC5taW4obWluWSwgeSAtIGggLyAyKTtcbiAgICBtYXhZID0gTWF0aC5tYXgobWF4WSwgeSArIGggLyAyKTtcbiAgfVxuXG4gIF8uZm9yRWFjaChnLm5vZGVzKCksIGZ1bmN0aW9uKHYpIHsgZ2V0RXh0cmVtZXMoZy5ub2RlKHYpKTsgfSk7XG4gIF8uZm9yRWFjaChnLmVkZ2VzKCksIGZ1bmN0aW9uKGUpIHtcbiAgICB2YXIgZWRnZSA9IGcuZWRnZShlKTtcbiAgICBpZiAoXy5oYXMoZWRnZSwgXCJ4XCIpKSB7XG4gICAgICBnZXRFeHRyZW1lcyhlZGdlKTtcbiAgICB9XG4gIH0pO1xuXG4gIG1pblggLT0gbWFyZ2luWDtcbiAgbWluWSAtPSBtYXJnaW5ZO1xuXG4gIF8uZm9yRWFjaChnLm5vZGVzKCksIGZ1bmN0aW9uKHYpIHtcbiAgICB2YXIgbm9kZSA9IGcubm9kZSh2KTtcbiAgICBub2RlLnggLT0gbWluWDtcbiAgICBub2RlLnkgLT0gbWluWTtcbiAgfSk7XG5cbiAgXy5mb3JFYWNoKGcuZWRnZXMoKSwgZnVuY3Rpb24oZSkge1xuICAgIHZhciBlZGdlID0gZy5lZGdlKGUpO1xuICAgIF8uZm9yRWFjaChlZGdlLnBvaW50cywgZnVuY3Rpb24ocCkge1xuICAgICAgcC54IC09IG1pblg7XG4gICAgICBwLnkgLT0gbWluWTtcbiAgICB9KTtcbiAgICBpZiAoXy5oYXMoZWRnZSwgXCJ4XCIpKSB7IGVkZ2UueCAtPSBtaW5YOyB9XG4gICAgaWYgKF8uaGFzKGVkZ2UsIFwieVwiKSkgeyBlZGdlLnkgLT0gbWluWTsgfVxuICB9KTtcblxuICBncmFwaExhYmVsLndpZHRoID0gbWF4WCAtIG1pblggKyBtYXJnaW5YO1xuICBncmFwaExhYmVsLmhlaWdodCA9IG1heFkgLSBtaW5ZICsgbWFyZ2luWTtcbn1cblxuZnVuY3Rpb24gYXNzaWduTm9kZUludGVyc2VjdHMoZykge1xuICBfLmZvckVhY2goZy5lZGdlcygpLCBmdW5jdGlvbihlKSB7XG4gICAgdmFyIGVkZ2UgPSBnLmVkZ2UoZSk7XG4gICAgdmFyIG5vZGVWID0gZy5ub2RlKGUudik7XG4gICAgdmFyIG5vZGVXID0gZy5ub2RlKGUudyk7XG4gICAgdmFyIHAxLCBwMjtcbiAgICBpZiAoIWVkZ2UucG9pbnRzKSB7XG4gICAgICBlZGdlLnBvaW50cyA9IFtdO1xuICAgICAgcDEgPSBub2RlVztcbiAgICAgIHAyID0gbm9kZVY7XG4gICAgfSBlbHNlIHtcbiAgICAgIHAxID0gZWRnZS5wb2ludHNbMF07XG4gICAgICBwMiA9IGVkZ2UucG9pbnRzW2VkZ2UucG9pbnRzLmxlbmd0aCAtIDFdO1xuICAgIH1cbiAgICBlZGdlLnBvaW50cy51bnNoaWZ0KHV0aWwuaW50ZXJzZWN0UmVjdChub2RlViwgcDEpKTtcbiAgICBlZGdlLnBvaW50cy5wdXNoKHV0aWwuaW50ZXJzZWN0UmVjdChub2RlVywgcDIpKTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGZpeHVwRWRnZUxhYmVsQ29vcmRzKGcpIHtcbiAgXy5mb3JFYWNoKGcuZWRnZXMoKSwgZnVuY3Rpb24oZSkge1xuICAgIHZhciBlZGdlID0gZy5lZGdlKGUpO1xuICAgIGlmIChfLmhhcyhlZGdlLCBcInhcIikpIHtcbiAgICAgIGlmIChlZGdlLmxhYmVscG9zID09PSBcImxcIiB8fCBlZGdlLmxhYmVscG9zID09PSBcInJcIikge1xuICAgICAgICBlZGdlLndpZHRoIC09IGVkZ2UubGFiZWxvZmZzZXQ7XG4gICAgICB9XG4gICAgICBzd2l0Y2ggKGVkZ2UubGFiZWxwb3MpIHtcbiAgICAgIGNhc2UgXCJsXCI6IGVkZ2UueCAtPSBlZGdlLndpZHRoIC8gMiArIGVkZ2UubGFiZWxvZmZzZXQ7IGJyZWFrO1xuICAgICAgY2FzZSBcInJcIjogZWRnZS54ICs9IGVkZ2Uud2lkdGggLyAyICsgZWRnZS5sYWJlbG9mZnNldDsgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbn1cblxuZnVuY3Rpb24gcmV2ZXJzZVBvaW50c0ZvclJldmVyc2VkRWRnZXMoZykge1xuICBfLmZvckVhY2goZy5lZGdlcygpLCBmdW5jdGlvbihlKSB7XG4gICAgdmFyIGVkZ2UgPSBnLmVkZ2UoZSk7XG4gICAgaWYgKGVkZ2UucmV2ZXJzZWQpIHtcbiAgICAgIGVkZ2UucG9pbnRzLnJldmVyc2UoKTtcbiAgICB9XG4gIH0pO1xufVxuXG5mdW5jdGlvbiByZW1vdmVCb3JkZXJOb2RlcyhnKSB7XG4gIF8uZm9yRWFjaChnLm5vZGVzKCksIGZ1bmN0aW9uKHYpIHtcbiAgICBpZiAoZy5jaGlsZHJlbih2KS5sZW5ndGgpIHtcbiAgICAgIHZhciBub2RlID0gZy5ub2RlKHYpO1xuICAgICAgdmFyIHQgPSBnLm5vZGUobm9kZS5ib3JkZXJUb3ApO1xuICAgICAgdmFyIGIgPSBnLm5vZGUobm9kZS5ib3JkZXJCb3R0b20pO1xuICAgICAgdmFyIGwgPSBnLm5vZGUoXy5sYXN0KG5vZGUuYm9yZGVyTGVmdCkpO1xuICAgICAgdmFyIHIgPSBnLm5vZGUoXy5sYXN0KG5vZGUuYm9yZGVyUmlnaHQpKTtcblxuICAgICAgbm9kZS53aWR0aCA9IE1hdGguYWJzKHIueCAtIGwueCk7XG4gICAgICBub2RlLmhlaWdodCA9IE1hdGguYWJzKGIueSAtIHQueSk7XG4gICAgICBub2RlLnggPSBsLnggKyBub2RlLndpZHRoIC8gMjtcbiAgICAgIG5vZGUueSA9IHQueSArIG5vZGUuaGVpZ2h0IC8gMjtcbiAgICB9XG4gIH0pO1xuXG4gIF8uZm9yRWFjaChnLm5vZGVzKCksIGZ1bmN0aW9uKHYpIHtcbiAgICBpZiAoZy5ub2RlKHYpLmR1bW15ID09PSBcImJvcmRlclwiKSB7XG4gICAgICBnLnJlbW92ZU5vZGUodik7XG4gICAgfVxuICB9KTtcbn1cblxuZnVuY3Rpb24gcmVtb3ZlU2VsZkVkZ2VzKGcpIHtcbiAgXy5mb3JFYWNoKGcuZWRnZXMoKSwgZnVuY3Rpb24oZSkge1xuICAgIGlmIChlLnYgPT09IGUudykge1xuICAgICAgdmFyIG5vZGUgPSBnLm5vZGUoZS52KTtcbiAgICAgIGlmICghbm9kZS5zZWxmRWRnZXMpIHtcbiAgICAgICAgbm9kZS5zZWxmRWRnZXMgPSBbXTtcbiAgICAgIH1cbiAgICAgIG5vZGUuc2VsZkVkZ2VzLnB1c2goeyBlOiBlLCBsYWJlbDogZy5lZGdlKGUpIH0pO1xuICAgICAgZy5yZW1vdmVFZGdlKGUpO1xuICAgIH1cbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGluc2VydFNlbGZFZGdlcyhnKSB7XG4gIHZhciBsYXllcnMgPSB1dGlsLmJ1aWxkTGF5ZXJNYXRyaXgoZyk7XG4gIF8uZm9yRWFjaChsYXllcnMsIGZ1bmN0aW9uKGxheWVyKSB7XG4gICAgdmFyIG9yZGVyU2hpZnQgPSAwO1xuICAgIF8uZm9yRWFjaChsYXllciwgZnVuY3Rpb24odiwgaSkge1xuICAgICAgdmFyIG5vZGUgPSBnLm5vZGUodik7XG4gICAgICBub2RlLm9yZGVyID0gaSArIG9yZGVyU2hpZnQ7XG4gICAgICBfLmZvckVhY2gobm9kZS5zZWxmRWRnZXMsIGZ1bmN0aW9uKHNlbGZFZGdlKSB7XG4gICAgICAgIHV0aWwuYWRkRHVtbXlOb2RlKGcsIFwic2VsZmVkZ2VcIiwge1xuICAgICAgICAgIHdpZHRoOiBzZWxmRWRnZS5sYWJlbC53aWR0aCxcbiAgICAgICAgICBoZWlnaHQ6IHNlbGZFZGdlLmxhYmVsLmhlaWdodCxcbiAgICAgICAgICByYW5rOiBub2RlLnJhbmssXG4gICAgICAgICAgb3JkZXI6IGkgKyAoKytvcmRlclNoaWZ0KSxcbiAgICAgICAgICBlOiBzZWxmRWRnZS5lLFxuICAgICAgICAgIGxhYmVsOiBzZWxmRWRnZS5sYWJlbFxuICAgICAgICB9LCBcIl9zZVwiKTtcbiAgICAgIH0pO1xuICAgICAgZGVsZXRlIG5vZGUuc2VsZkVkZ2VzO1xuICAgIH0pO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gcG9zaXRpb25TZWxmRWRnZXMoZykge1xuICBfLmZvckVhY2goZy5ub2RlcygpLCBmdW5jdGlvbih2KSB7XG4gICAgdmFyIG5vZGUgPSBnLm5vZGUodik7XG4gICAgaWYgKG5vZGUuZHVtbXkgPT09IFwic2VsZmVkZ2VcIikge1xuICAgICAgdmFyIHNlbGZOb2RlID0gZy5ub2RlKG5vZGUuZS52KTtcbiAgICAgIHZhciB4ID0gc2VsZk5vZGUueCArIHNlbGZOb2RlLndpZHRoIC8gMjtcbiAgICAgIHZhciB5ID0gc2VsZk5vZGUueTtcbiAgICAgIHZhciBkeCA9IG5vZGUueCAtIHg7XG4gICAgICB2YXIgZHkgPSBzZWxmTm9kZS5oZWlnaHQgLyAyO1xuICAgICAgZy5zZXRFZGdlKG5vZGUuZSwgbm9kZS5sYWJlbCk7XG4gICAgICBnLnJlbW92ZU5vZGUodik7XG4gICAgICBub2RlLmxhYmVsLnBvaW50cyA9IFtcbiAgICAgICAgeyB4OiB4ICsgMiAqIGR4IC8gMywgeTogeSAtIGR5IH0sXG4gICAgICAgIHsgeDogeCArIDUgKiBkeCAvIDYsIHk6IHkgLSBkeSB9LFxuICAgICAgICB7IHg6IHggKyAgICAgZHggICAgLCB5OiB5IH0sXG4gICAgICAgIHsgeDogeCArIDUgKiBkeCAvIDYsIHk6IHkgKyBkeSB9LFxuICAgICAgICB7IHg6IHggKyAyICogZHggLyAzLCB5OiB5ICsgZHkgfVxuICAgICAgXTtcbiAgICAgIG5vZGUubGFiZWwueCA9IG5vZGUueDtcbiAgICAgIG5vZGUubGFiZWwueSA9IG5vZGUueTtcbiAgICB9XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBzZWxlY3ROdW1iZXJBdHRycyhvYmosIGF0dHJzKSB7XG4gIHJldHVybiBfLm1hcFZhbHVlcyhfLnBpY2sob2JqLCBhdHRycyksIE51bWJlcik7XG59XG5cbmZ1bmN0aW9uIGNhbm9uaWNhbGl6ZShhdHRycykge1xuICB2YXIgbmV3QXR0cnMgPSB7fTtcbiAgXy5mb3JFYWNoKGF0dHJzLCBmdW5jdGlvbih2LCBrKSB7XG4gICAgbmV3QXR0cnNbay50b0xvd2VyQ2FzZSgpXSA9IHY7XG4gIH0pO1xuICByZXR1cm4gbmV3QXR0cnM7XG59XG4iLCIvKiBnbG9iYWwgd2luZG93ICovXG5cbnZhciBsb2Rhc2g7XG5cbmlmICh0eXBlb2YgcmVxdWlyZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gIHRyeSB7XG4gICAgbG9kYXNoID0ge1xuICAgICAgY2xvbmVEZWVwOiByZXF1aXJlKFwibG9kYXNoL2Nsb25lRGVlcFwiKSxcbiAgICAgIGNvbnN0YW50OiByZXF1aXJlKFwibG9kYXNoL2NvbnN0YW50XCIpLFxuICAgICAgZGVmYXVsdHM6IHJlcXVpcmUoXCJsb2Rhc2gvZGVmYXVsdHNcIiksXG4gICAgICBlYWNoOiByZXF1aXJlKFwibG9kYXNoL2VhY2hcIiksXG4gICAgICBmaWx0ZXI6IHJlcXVpcmUoXCJsb2Rhc2gvZmlsdGVyXCIpLFxuICAgICAgZmluZDogcmVxdWlyZShcImxvZGFzaC9maW5kXCIpLFxuICAgICAgZmxhdHRlbjogcmVxdWlyZShcImxvZGFzaC9mbGF0dGVuXCIpLFxuICAgICAgZm9yRWFjaDogcmVxdWlyZShcImxvZGFzaC9mb3JFYWNoXCIpLFxuICAgICAgZm9ySW46IHJlcXVpcmUoXCJsb2Rhc2gvZm9ySW5cIiksXG4gICAgICBoYXM6ICByZXF1aXJlKFwibG9kYXNoL2hhc1wiKSxcbiAgICAgIGlzVW5kZWZpbmVkOiByZXF1aXJlKFwibG9kYXNoL2lzVW5kZWZpbmVkXCIpLFxuICAgICAgbGFzdDogcmVxdWlyZShcImxvZGFzaC9sYXN0XCIpLFxuICAgICAgbWFwOiByZXF1aXJlKFwibG9kYXNoL21hcFwiKSxcbiAgICAgIG1hcFZhbHVlczogcmVxdWlyZShcImxvZGFzaC9tYXBWYWx1ZXNcIiksXG4gICAgICBtYXg6IHJlcXVpcmUoXCJsb2Rhc2gvbWF4XCIpLFxuICAgICAgbWVyZ2U6IHJlcXVpcmUoXCJsb2Rhc2gvbWVyZ2VcIiksXG4gICAgICBtaW46IHJlcXVpcmUoXCJsb2Rhc2gvbWluXCIpLFxuICAgICAgbWluQnk6IHJlcXVpcmUoXCJsb2Rhc2gvbWluQnlcIiksXG4gICAgICBub3c6IHJlcXVpcmUoXCJsb2Rhc2gvbm93XCIpLFxuICAgICAgcGljazogcmVxdWlyZShcImxvZGFzaC9waWNrXCIpLFxuICAgICAgcmFuZ2U6IHJlcXVpcmUoXCJsb2Rhc2gvcmFuZ2VcIiksXG4gICAgICByZWR1Y2U6IHJlcXVpcmUoXCJsb2Rhc2gvcmVkdWNlXCIpLFxuICAgICAgc29ydEJ5OiByZXF1aXJlKFwibG9kYXNoL3NvcnRCeVwiKSxcbiAgICAgIHVuaXF1ZUlkOiByZXF1aXJlKFwibG9kYXNoL3VuaXF1ZUlkXCIpLFxuICAgICAgdmFsdWVzOiByZXF1aXJlKFwibG9kYXNoL3ZhbHVlc1wiKSxcbiAgICAgIHppcE9iamVjdDogcmVxdWlyZShcImxvZGFzaC96aXBPYmplY3RcIiksXG4gICAgfTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIC8vIGNvbnRpbnVlIHJlZ2FyZGxlc3Mgb2YgZXJyb3JcbiAgfVxufVxuXG5pZiAoIWxvZGFzaCkge1xuICBsb2Rhc2ggPSB3aW5kb3cuXztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBsb2Rhc2g7XG4iLCJ2YXIgXyA9IHJlcXVpcmUoXCIuL2xvZGFzaFwiKTtcbnZhciB1dGlsID0gcmVxdWlyZShcIi4vdXRpbFwiKTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIHJ1bjogcnVuLFxuICBjbGVhbnVwOiBjbGVhbnVwXG59O1xuXG4vKlxuICogQSBuZXN0aW5nIGdyYXBoIGNyZWF0ZXMgZHVtbXkgbm9kZXMgZm9yIHRoZSB0b3BzIGFuZCBib3R0b21zIG9mIHN1YmdyYXBocyxcbiAqIGFkZHMgYXBwcm9wcmlhdGUgZWRnZXMgdG8gZW5zdXJlIHRoYXQgYWxsIGNsdXN0ZXIgbm9kZXMgYXJlIHBsYWNlZCBiZXR3ZWVuXG4gKiB0aGVzZSBib3VuZHJpZXMsIGFuZCBlbnN1cmVzIHRoYXQgdGhlIGdyYXBoIGlzIGNvbm5lY3RlZC5cbiAqXG4gKiBJbiBhZGRpdGlvbiB3ZSBlbnN1cmUsIHRocm91Z2ggdGhlIHVzZSBvZiB0aGUgbWlubGVuIHByb3BlcnR5LCB0aGF0IG5vZGVzXG4gKiBhbmQgc3ViZ3JhcGggYm9yZGVyIG5vZGVzIHRvIG5vdCBlbmQgdXAgb24gdGhlIHNhbWUgcmFuay5cbiAqXG4gKiBQcmVjb25kaXRpb25zOlxuICpcbiAqICAgIDEuIElucHV0IGdyYXBoIGlzIGEgREFHXG4gKiAgICAyLiBOb2RlcyBpbiB0aGUgaW5wdXQgZ3JhcGggaGFzIGEgbWlubGVuIGF0dHJpYnV0ZVxuICpcbiAqIFBvc3Rjb25kaXRpb25zOlxuICpcbiAqICAgIDEuIElucHV0IGdyYXBoIGlzIGNvbm5lY3RlZC5cbiAqICAgIDIuIER1bW15IG5vZGVzIGFyZSBhZGRlZCBmb3IgdGhlIHRvcHMgYW5kIGJvdHRvbXMgb2Ygc3ViZ3JhcGhzLlxuICogICAgMy4gVGhlIG1pbmxlbiBhdHRyaWJ1dGUgZm9yIG5vZGVzIGlzIGFkanVzdGVkIHRvIGVuc3VyZSBub2RlcyBkbyBub3RcbiAqICAgICAgIGdldCBwbGFjZWQgb24gdGhlIHNhbWUgcmFuayBhcyBzdWJncmFwaCBib3JkZXIgbm9kZXMuXG4gKlxuICogVGhlIG5lc3RpbmcgZ3JhcGggaWRlYSBjb21lcyBmcm9tIFNhbmRlciwgXCJMYXlvdXQgb2YgQ29tcG91bmQgRGlyZWN0ZWRcbiAqIEdyYXBocy5cIlxuICovXG5mdW5jdGlvbiBydW4oZykge1xuICB2YXIgcm9vdCA9IHV0aWwuYWRkRHVtbXlOb2RlKGcsIFwicm9vdFwiLCB7fSwgXCJfcm9vdFwiKTtcbiAgdmFyIGRlcHRocyA9IHRyZWVEZXB0aHMoZyk7XG4gIHZhciBoZWlnaHQgPSBfLm1heChfLnZhbHVlcyhkZXB0aHMpKSAtIDE7IC8vIE5vdGU6IGRlcHRocyBpcyBhbiBPYmplY3Qgbm90IGFuIGFycmF5XG4gIHZhciBub2RlU2VwID0gMiAqIGhlaWdodCArIDE7XG5cbiAgZy5ncmFwaCgpLm5lc3RpbmdSb290ID0gcm9vdDtcblxuICAvLyBNdWx0aXBseSBtaW5sZW4gYnkgbm9kZVNlcCB0byBhbGlnbiBub2RlcyBvbiBub24tYm9yZGVyIHJhbmtzLlxuICBfLmZvckVhY2goZy5lZGdlcygpLCBmdW5jdGlvbihlKSB7IGcuZWRnZShlKS5taW5sZW4gKj0gbm9kZVNlcDsgfSk7XG5cbiAgLy8gQ2FsY3VsYXRlIGEgd2VpZ2h0IHRoYXQgaXMgc3VmZmljaWVudCB0byBrZWVwIHN1YmdyYXBocyB2ZXJ0aWNhbGx5IGNvbXBhY3RcbiAgdmFyIHdlaWdodCA9IHN1bVdlaWdodHMoZykgKyAxO1xuXG4gIC8vIENyZWF0ZSBib3JkZXIgbm9kZXMgYW5kIGxpbmsgdGhlbSB1cFxuICBfLmZvckVhY2goZy5jaGlsZHJlbigpLCBmdW5jdGlvbihjaGlsZCkge1xuICAgIGRmcyhnLCByb290LCBub2RlU2VwLCB3ZWlnaHQsIGhlaWdodCwgZGVwdGhzLCBjaGlsZCk7XG4gIH0pO1xuXG4gIC8vIFNhdmUgdGhlIG11bHRpcGxpZXIgZm9yIG5vZGUgbGF5ZXJzIGZvciBsYXRlciByZW1vdmFsIG9mIGVtcHR5IGJvcmRlclxuICAvLyBsYXllcnMuXG4gIGcuZ3JhcGgoKS5ub2RlUmFua0ZhY3RvciA9IG5vZGVTZXA7XG59XG5cbmZ1bmN0aW9uIGRmcyhnLCByb290LCBub2RlU2VwLCB3ZWlnaHQsIGhlaWdodCwgZGVwdGhzLCB2KSB7XG4gIHZhciBjaGlsZHJlbiA9IGcuY2hpbGRyZW4odik7XG4gIGlmICghY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgaWYgKHYgIT09IHJvb3QpIHtcbiAgICAgIGcuc2V0RWRnZShyb290LCB2LCB7IHdlaWdodDogMCwgbWlubGVuOiBub2RlU2VwIH0pO1xuICAgIH1cbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgdG9wID0gdXRpbC5hZGRCb3JkZXJOb2RlKGcsIFwiX2J0XCIpO1xuICB2YXIgYm90dG9tID0gdXRpbC5hZGRCb3JkZXJOb2RlKGcsIFwiX2JiXCIpO1xuICB2YXIgbGFiZWwgPSBnLm5vZGUodik7XG5cbiAgZy5zZXRQYXJlbnQodG9wLCB2KTtcbiAgbGFiZWwuYm9yZGVyVG9wID0gdG9wO1xuICBnLnNldFBhcmVudChib3R0b20sIHYpO1xuICBsYWJlbC5ib3JkZXJCb3R0b20gPSBib3R0b207XG5cbiAgXy5mb3JFYWNoKGNoaWxkcmVuLCBmdW5jdGlvbihjaGlsZCkge1xuICAgIGRmcyhnLCByb290LCBub2RlU2VwLCB3ZWlnaHQsIGhlaWdodCwgZGVwdGhzLCBjaGlsZCk7XG5cbiAgICB2YXIgY2hpbGROb2RlID0gZy5ub2RlKGNoaWxkKTtcbiAgICB2YXIgY2hpbGRUb3AgPSBjaGlsZE5vZGUuYm9yZGVyVG9wID8gY2hpbGROb2RlLmJvcmRlclRvcCA6IGNoaWxkO1xuICAgIHZhciBjaGlsZEJvdHRvbSA9IGNoaWxkTm9kZS5ib3JkZXJCb3R0b20gPyBjaGlsZE5vZGUuYm9yZGVyQm90dG9tIDogY2hpbGQ7XG4gICAgdmFyIHRoaXNXZWlnaHQgPSBjaGlsZE5vZGUuYm9yZGVyVG9wID8gd2VpZ2h0IDogMiAqIHdlaWdodDtcbiAgICB2YXIgbWlubGVuID0gY2hpbGRUb3AgIT09IGNoaWxkQm90dG9tID8gMSA6IGhlaWdodCAtIGRlcHRoc1t2XSArIDE7XG5cbiAgICBnLnNldEVkZ2UodG9wLCBjaGlsZFRvcCwge1xuICAgICAgd2VpZ2h0OiB0aGlzV2VpZ2h0LFxuICAgICAgbWlubGVuOiBtaW5sZW4sXG4gICAgICBuZXN0aW5nRWRnZTogdHJ1ZVxuICAgIH0pO1xuXG4gICAgZy5zZXRFZGdlKGNoaWxkQm90dG9tLCBib3R0b20sIHtcbiAgICAgIHdlaWdodDogdGhpc1dlaWdodCxcbiAgICAgIG1pbmxlbjogbWlubGVuLFxuICAgICAgbmVzdGluZ0VkZ2U6IHRydWVcbiAgICB9KTtcbiAgfSk7XG5cbiAgaWYgKCFnLnBhcmVudCh2KSkge1xuICAgIGcuc2V0RWRnZShyb290LCB0b3AsIHsgd2VpZ2h0OiAwLCBtaW5sZW46IGhlaWdodCArIGRlcHRoc1t2XSB9KTtcbiAgfVxufVxuXG5mdW5jdGlvbiB0cmVlRGVwdGhzKGcpIHtcbiAgdmFyIGRlcHRocyA9IHt9O1xuICBmdW5jdGlvbiBkZnModiwgZGVwdGgpIHtcbiAgICB2YXIgY2hpbGRyZW4gPSBnLmNoaWxkcmVuKHYpO1xuICAgIGlmIChjaGlsZHJlbiAmJiBjaGlsZHJlbi5sZW5ndGgpIHtcbiAgICAgIF8uZm9yRWFjaChjaGlsZHJlbiwgZnVuY3Rpb24oY2hpbGQpIHtcbiAgICAgICAgZGZzKGNoaWxkLCBkZXB0aCArIDEpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIGRlcHRoc1t2XSA9IGRlcHRoO1xuICB9XG4gIF8uZm9yRWFjaChnLmNoaWxkcmVuKCksIGZ1bmN0aW9uKHYpIHsgZGZzKHYsIDEpOyB9KTtcbiAgcmV0dXJuIGRlcHRocztcbn1cblxuZnVuY3Rpb24gc3VtV2VpZ2h0cyhnKSB7XG4gIHJldHVybiBfLnJlZHVjZShnLmVkZ2VzKCksIGZ1bmN0aW9uKGFjYywgZSkge1xuICAgIHJldHVybiBhY2MgKyBnLmVkZ2UoZSkud2VpZ2h0O1xuICB9LCAwKTtcbn1cblxuZnVuY3Rpb24gY2xlYW51cChnKSB7XG4gIHZhciBncmFwaExhYmVsID0gZy5ncmFwaCgpO1xuICBnLnJlbW92ZU5vZGUoZ3JhcGhMYWJlbC5uZXN0aW5nUm9vdCk7XG4gIGRlbGV0ZSBncmFwaExhYmVsLm5lc3RpbmdSb290O1xuICBfLmZvckVhY2goZy5lZGdlcygpLCBmdW5jdGlvbihlKSB7XG4gICAgdmFyIGVkZ2UgPSBnLmVkZ2UoZSk7XG4gICAgaWYgKGVkZ2UubmVzdGluZ0VkZ2UpIHtcbiAgICAgIGcucmVtb3ZlRWRnZShlKTtcbiAgICB9XG4gIH0pO1xufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfID0gcmVxdWlyZShcIi4vbG9kYXNoXCIpO1xudmFyIHV0aWwgPSByZXF1aXJlKFwiLi91dGlsXCIpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgcnVuOiBydW4sXG4gIHVuZG86IHVuZG9cbn07XG5cbi8qXG4gKiBCcmVha3MgYW55IGxvbmcgZWRnZXMgaW4gdGhlIGdyYXBoIGludG8gc2hvcnQgc2VnbWVudHMgdGhhdCBzcGFuIDEgbGF5ZXJcbiAqIGVhY2guIFRoaXMgb3BlcmF0aW9uIGlzIHVuZG9hYmxlIHdpdGggdGhlIGRlbm9ybWFsaXplIGZ1bmN0aW9uLlxuICpcbiAqIFByZS1jb25kaXRpb25zOlxuICpcbiAqICAgIDEuIFRoZSBpbnB1dCBncmFwaCBpcyBhIERBRy5cbiAqICAgIDIuIEVhY2ggbm9kZSBpbiB0aGUgZ3JhcGggaGFzIGEgXCJyYW5rXCIgcHJvcGVydHkuXG4gKlxuICogUG9zdC1jb25kaXRpb246XG4gKlxuICogICAgMS4gQWxsIGVkZ2VzIGluIHRoZSBncmFwaCBoYXZlIGEgbGVuZ3RoIG9mIDEuXG4gKiAgICAyLiBEdW1teSBub2RlcyBhcmUgYWRkZWQgd2hlcmUgZWRnZXMgaGF2ZSBiZWVuIHNwbGl0IGludG8gc2VnbWVudHMuXG4gKiAgICAzLiBUaGUgZ3JhcGggaXMgYXVnbWVudGVkIHdpdGggYSBcImR1bW15Q2hhaW5zXCIgYXR0cmlidXRlIHdoaWNoIGNvbnRhaW5zXG4gKiAgICAgICB0aGUgZmlyc3QgZHVtbXkgaW4gZWFjaCBjaGFpbiBvZiBkdW1teSBub2RlcyBwcm9kdWNlZC5cbiAqL1xuZnVuY3Rpb24gcnVuKGcpIHtcbiAgZy5ncmFwaCgpLmR1bW15Q2hhaW5zID0gW107XG4gIF8uZm9yRWFjaChnLmVkZ2VzKCksIGZ1bmN0aW9uKGVkZ2UpIHsgbm9ybWFsaXplRWRnZShnLCBlZGdlKTsgfSk7XG59XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZUVkZ2UoZywgZSkge1xuICB2YXIgdiA9IGUudjtcbiAgdmFyIHZSYW5rID0gZy5ub2RlKHYpLnJhbms7XG4gIHZhciB3ID0gZS53O1xuICB2YXIgd1JhbmsgPSBnLm5vZGUodykucmFuaztcbiAgdmFyIG5hbWUgPSBlLm5hbWU7XG4gIHZhciBlZGdlTGFiZWwgPSBnLmVkZ2UoZSk7XG4gIHZhciBsYWJlbFJhbmsgPSBlZGdlTGFiZWwubGFiZWxSYW5rO1xuXG4gIGlmICh3UmFuayA9PT0gdlJhbmsgKyAxKSByZXR1cm47XG5cbiAgZy5yZW1vdmVFZGdlKGUpO1xuXG4gIHZhciBkdW1teSwgYXR0cnMsIGk7XG4gIGZvciAoaSA9IDAsICsrdlJhbms7IHZSYW5rIDwgd1Jhbms7ICsraSwgKyt2UmFuaykge1xuICAgIGVkZ2VMYWJlbC5wb2ludHMgPSBbXTtcbiAgICBhdHRycyA9IHtcbiAgICAgIHdpZHRoOiAwLCBoZWlnaHQ6IDAsXG4gICAgICBlZGdlTGFiZWw6IGVkZ2VMYWJlbCwgZWRnZU9iajogZSxcbiAgICAgIHJhbms6IHZSYW5rXG4gICAgfTtcbiAgICBkdW1teSA9IHV0aWwuYWRkRHVtbXlOb2RlKGcsIFwiZWRnZVwiLCBhdHRycywgXCJfZFwiKTtcbiAgICBpZiAodlJhbmsgPT09IGxhYmVsUmFuaykge1xuICAgICAgYXR0cnMud2lkdGggPSBlZGdlTGFiZWwud2lkdGg7XG4gICAgICBhdHRycy5oZWlnaHQgPSBlZGdlTGFiZWwuaGVpZ2h0O1xuICAgICAgYXR0cnMuZHVtbXkgPSBcImVkZ2UtbGFiZWxcIjtcbiAgICAgIGF0dHJzLmxhYmVscG9zID0gZWRnZUxhYmVsLmxhYmVscG9zO1xuICAgIH1cbiAgICBnLnNldEVkZ2UodiwgZHVtbXksIHsgd2VpZ2h0OiBlZGdlTGFiZWwud2VpZ2h0IH0sIG5hbWUpO1xuICAgIGlmIChpID09PSAwKSB7XG4gICAgICBnLmdyYXBoKCkuZHVtbXlDaGFpbnMucHVzaChkdW1teSk7XG4gICAgfVxuICAgIHYgPSBkdW1teTtcbiAgfVxuXG4gIGcuc2V0RWRnZSh2LCB3LCB7IHdlaWdodDogZWRnZUxhYmVsLndlaWdodCB9LCBuYW1lKTtcbn1cblxuZnVuY3Rpb24gdW5kbyhnKSB7XG4gIF8uZm9yRWFjaChnLmdyYXBoKCkuZHVtbXlDaGFpbnMsIGZ1bmN0aW9uKHYpIHtcbiAgICB2YXIgbm9kZSA9IGcubm9kZSh2KTtcbiAgICB2YXIgb3JpZ0xhYmVsID0gbm9kZS5lZGdlTGFiZWw7XG4gICAgdmFyIHc7XG4gICAgZy5zZXRFZGdlKG5vZGUuZWRnZU9iaiwgb3JpZ0xhYmVsKTtcbiAgICB3aGlsZSAobm9kZS5kdW1teSkge1xuICAgICAgdyA9IGcuc3VjY2Vzc29ycyh2KVswXTtcbiAgICAgIGcucmVtb3ZlTm9kZSh2KTtcbiAgICAgIG9yaWdMYWJlbC5wb2ludHMucHVzaCh7IHg6IG5vZGUueCwgeTogbm9kZS55IH0pO1xuICAgICAgaWYgKG5vZGUuZHVtbXkgPT09IFwiZWRnZS1sYWJlbFwiKSB7XG4gICAgICAgIG9yaWdMYWJlbC54ID0gbm9kZS54O1xuICAgICAgICBvcmlnTGFiZWwueSA9IG5vZGUueTtcbiAgICAgICAgb3JpZ0xhYmVsLndpZHRoID0gbm9kZS53aWR0aDtcbiAgICAgICAgb3JpZ0xhYmVsLmhlaWdodCA9IG5vZGUuaGVpZ2h0O1xuICAgICAgfVxuICAgICAgdiA9IHc7XG4gICAgICBub2RlID0gZy5ub2RlKHYpO1xuICAgIH1cbiAgfSk7XG59XG4iLCJ2YXIgXyA9IHJlcXVpcmUoXCIuLi9sb2Rhc2hcIik7XG5cbm1vZHVsZS5leHBvcnRzID0gYWRkU3ViZ3JhcGhDb25zdHJhaW50cztcblxuZnVuY3Rpb24gYWRkU3ViZ3JhcGhDb25zdHJhaW50cyhnLCBjZywgdnMpIHtcbiAgdmFyIHByZXYgPSB7fSxcbiAgICByb290UHJldjtcblxuICBfLmZvckVhY2godnMsIGZ1bmN0aW9uKHYpIHtcbiAgICB2YXIgY2hpbGQgPSBnLnBhcmVudCh2KSxcbiAgICAgIHBhcmVudCxcbiAgICAgIHByZXZDaGlsZDtcbiAgICB3aGlsZSAoY2hpbGQpIHtcbiAgICAgIHBhcmVudCA9IGcucGFyZW50KGNoaWxkKTtcbiAgICAgIGlmIChwYXJlbnQpIHtcbiAgICAgICAgcHJldkNoaWxkID0gcHJldltwYXJlbnRdO1xuICAgICAgICBwcmV2W3BhcmVudF0gPSBjaGlsZDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHByZXZDaGlsZCA9IHJvb3RQcmV2O1xuICAgICAgICByb290UHJldiA9IGNoaWxkO1xuICAgICAgfVxuICAgICAgaWYgKHByZXZDaGlsZCAmJiBwcmV2Q2hpbGQgIT09IGNoaWxkKSB7XG4gICAgICAgIGNnLnNldEVkZ2UocHJldkNoaWxkLCBjaGlsZCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNoaWxkID0gcGFyZW50O1xuICAgIH1cbiAgfSk7XG5cbiAgLypcbiAgZnVuY3Rpb24gZGZzKHYpIHtcbiAgICB2YXIgY2hpbGRyZW4gPSB2ID8gZy5jaGlsZHJlbih2KSA6IGcuY2hpbGRyZW4oKTtcbiAgICBpZiAoY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICB2YXIgbWluID0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZLFxuICAgICAgICAgIHN1YmdyYXBocyA9IFtdO1xuICAgICAgXy5lYWNoKGNoaWxkcmVuLCBmdW5jdGlvbihjaGlsZCkge1xuICAgICAgICB2YXIgY2hpbGRNaW4gPSBkZnMoY2hpbGQpO1xuICAgICAgICBpZiAoZy5jaGlsZHJlbihjaGlsZCkubGVuZ3RoKSB7XG4gICAgICAgICAgc3ViZ3JhcGhzLnB1c2goeyB2OiBjaGlsZCwgb3JkZXI6IGNoaWxkTWluIH0pO1xuICAgICAgICB9XG4gICAgICAgIG1pbiA9IE1hdGgubWluKG1pbiwgY2hpbGRNaW4pO1xuICAgICAgfSk7XG4gICAgICBfLnJlZHVjZShfLnNvcnRCeShzdWJncmFwaHMsIFwib3JkZXJcIiksIGZ1bmN0aW9uKHByZXYsIGN1cnIpIHtcbiAgICAgICAgY2cuc2V0RWRnZShwcmV2LnYsIGN1cnIudik7XG4gICAgICAgIHJldHVybiBjdXJyO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gbWluO1xuICAgIH1cbiAgICByZXR1cm4gZy5ub2RlKHYpLm9yZGVyO1xuICB9XG4gIGRmcyh1bmRlZmluZWQpO1xuICAqL1xufVxuIiwidmFyIF8gPSByZXF1aXJlKFwiLi4vbG9kYXNoXCIpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGJhcnljZW50ZXI7XG5cbmZ1bmN0aW9uIGJhcnljZW50ZXIoZywgbW92YWJsZSkge1xuICByZXR1cm4gXy5tYXAobW92YWJsZSwgZnVuY3Rpb24odikge1xuICAgIHZhciBpblYgPSBnLmluRWRnZXModik7XG4gICAgaWYgKCFpblYubGVuZ3RoKSB7XG4gICAgICByZXR1cm4geyB2OiB2IH07XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciByZXN1bHQgPSBfLnJlZHVjZShpblYsIGZ1bmN0aW9uKGFjYywgZSkge1xuICAgICAgICB2YXIgZWRnZSA9IGcuZWRnZShlKSxcbiAgICAgICAgICBub2RlVSA9IGcubm9kZShlLnYpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHN1bTogYWNjLnN1bSArIChlZGdlLndlaWdodCAqIG5vZGVVLm9yZGVyKSxcbiAgICAgICAgICB3ZWlnaHQ6IGFjYy53ZWlnaHQgKyBlZGdlLndlaWdodFxuICAgICAgICB9O1xuICAgICAgfSwgeyBzdW06IDAsIHdlaWdodDogMCB9KTtcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdjogdixcbiAgICAgICAgYmFyeWNlbnRlcjogcmVzdWx0LnN1bSAvIHJlc3VsdC53ZWlnaHQsXG4gICAgICAgIHdlaWdodDogcmVzdWx0LndlaWdodFxuICAgICAgfTtcbiAgICB9XG4gIH0pO1xufVxuXG4iLCJ2YXIgXyA9IHJlcXVpcmUoXCIuLi9sb2Rhc2hcIik7XG52YXIgR3JhcGggPSByZXF1aXJlKFwiLi4vZ3JhcGhsaWJcIikuR3JhcGg7XG5cbm1vZHVsZS5leHBvcnRzID0gYnVpbGRMYXllckdyYXBoO1xuXG4vKlxuICogQ29uc3RydWN0cyBhIGdyYXBoIHRoYXQgY2FuIGJlIHVzZWQgdG8gc29ydCBhIGxheWVyIG9mIG5vZGVzLiBUaGUgZ3JhcGggd2lsbFxuICogY29udGFpbiBhbGwgYmFzZSBhbmQgc3ViZ3JhcGggbm9kZXMgZnJvbSB0aGUgcmVxdWVzdCBsYXllciBpbiB0aGVpciBvcmlnaW5hbFxuICogaGllcmFyY2h5IGFuZCBhbnkgZWRnZXMgdGhhdCBhcmUgaW5jaWRlbnQgb24gdGhlc2Ugbm9kZXMgYW5kIGFyZSBvZiB0aGUgdHlwZVxuICogcmVxdWVzdGVkIGJ5IHRoZSBcInJlbGF0aW9uc2hpcFwiIHBhcmFtZXRlci5cbiAqXG4gKiBOb2RlcyBmcm9tIHRoZSByZXF1ZXN0ZWQgcmFuayB0aGF0IGRvIG5vdCBoYXZlIHBhcmVudHMgYXJlIGFzc2lnbmVkIGEgcm9vdFxuICogbm9kZSBpbiB0aGUgb3V0cHV0IGdyYXBoLCB3aGljaCBpcyBzZXQgaW4gdGhlIHJvb3QgZ3JhcGggYXR0cmlidXRlLiBUaGlzXG4gKiBtYWtlcyBpdCBlYXN5IHRvIHdhbGsgdGhlIGhpZXJhcmNoeSBvZiBtb3ZhYmxlIG5vZGVzIGR1cmluZyBvcmRlcmluZy5cbiAqXG4gKiBQcmUtY29uZGl0aW9uczpcbiAqXG4gKiAgICAxLiBJbnB1dCBncmFwaCBpcyBhIERBR1xuICogICAgMi4gQmFzZSBub2RlcyBpbiB0aGUgaW5wdXQgZ3JhcGggaGF2ZSBhIHJhbmsgYXR0cmlidXRlXG4gKiAgICAzLiBTdWJncmFwaCBub2RlcyBpbiB0aGUgaW5wdXQgZ3JhcGggaGFzIG1pblJhbmsgYW5kIG1heFJhbmsgYXR0cmlidXRlc1xuICogICAgNC4gRWRnZXMgaGF2ZSBhbiBhc3NpZ25lZCB3ZWlnaHRcbiAqXG4gKiBQb3N0LWNvbmRpdGlvbnM6XG4gKlxuICogICAgMS4gT3V0cHV0IGdyYXBoIGhhcyBhbGwgbm9kZXMgaW4gdGhlIG1vdmFibGUgcmFuayB3aXRoIHByZXNlcnZlZFxuICogICAgICAgaGllcmFyY2h5LlxuICogICAgMi4gUm9vdCBub2RlcyBpbiB0aGUgbW92YWJsZSBsYXllciBhcmUgbWFkZSBjaGlsZHJlbiBvZiB0aGUgbm9kZVxuICogICAgICAgaW5kaWNhdGVkIGJ5IHRoZSByb290IGF0dHJpYnV0ZSBvZiB0aGUgZ3JhcGguXG4gKiAgICAzLiBOb24tbW92YWJsZSBub2RlcyBpbmNpZGVudCBvbiBtb3ZhYmxlIG5vZGVzLCBzZWxlY3RlZCBieSB0aGVcbiAqICAgICAgIHJlbGF0aW9uc2hpcCBwYXJhbWV0ZXIsIGFyZSBpbmNsdWRlZCBpbiB0aGUgZ3JhcGggKHdpdGhvdXQgaGllcmFyY2h5KS5cbiAqICAgIDQuIEVkZ2VzIGluY2lkZW50IG9uIG1vdmFibGUgbm9kZXMsIHNlbGVjdGVkIGJ5IHRoZSByZWxhdGlvbnNoaXBcbiAqICAgICAgIHBhcmFtZXRlciwgYXJlIGFkZGVkIHRvIHRoZSBvdXRwdXQgZ3JhcGguXG4gKiAgICA1LiBUaGUgd2VpZ2h0cyBmb3IgY29waWVkIGVkZ2VzIGFyZSBhZ2dyZWdhdGVkIGFzIG5lZWQsIHNpbmNlIHRoZSBvdXRwdXRcbiAqICAgICAgIGdyYXBoIGlzIG5vdCBhIG11bHRpLWdyYXBoLlxuICovXG5mdW5jdGlvbiBidWlsZExheWVyR3JhcGgoZywgcmFuaywgcmVsYXRpb25zaGlwKSB7XG4gIHZhciByb290ID0gY3JlYXRlUm9vdE5vZGUoZyksXG4gICAgcmVzdWx0ID0gbmV3IEdyYXBoKHsgY29tcG91bmQ6IHRydWUgfSkuc2V0R3JhcGgoeyByb290OiByb290IH0pXG4gICAgICAuc2V0RGVmYXVsdE5vZGVMYWJlbChmdW5jdGlvbih2KSB7IHJldHVybiBnLm5vZGUodik7IH0pO1xuXG4gIF8uZm9yRWFjaChnLm5vZGVzKCksIGZ1bmN0aW9uKHYpIHtcbiAgICB2YXIgbm9kZSA9IGcubm9kZSh2KSxcbiAgICAgIHBhcmVudCA9IGcucGFyZW50KHYpO1xuXG4gICAgaWYgKG5vZGUucmFuayA9PT0gcmFuayB8fCBub2RlLm1pblJhbmsgPD0gcmFuayAmJiByYW5rIDw9IG5vZGUubWF4UmFuaykge1xuICAgICAgcmVzdWx0LnNldE5vZGUodik7XG4gICAgICByZXN1bHQuc2V0UGFyZW50KHYsIHBhcmVudCB8fCByb290KTtcblxuICAgICAgLy8gVGhpcyBhc3N1bWVzIHdlIGhhdmUgb25seSBzaG9ydCBlZGdlcyFcbiAgICAgIF8uZm9yRWFjaChnW3JlbGF0aW9uc2hpcF0odiksIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgdmFyIHUgPSBlLnYgPT09IHYgPyBlLncgOiBlLnYsXG4gICAgICAgICAgZWRnZSA9IHJlc3VsdC5lZGdlKHUsIHYpLFxuICAgICAgICAgIHdlaWdodCA9ICFfLmlzVW5kZWZpbmVkKGVkZ2UpID8gZWRnZS53ZWlnaHQgOiAwO1xuICAgICAgICByZXN1bHQuc2V0RWRnZSh1LCB2LCB7IHdlaWdodDogZy5lZGdlKGUpLndlaWdodCArIHdlaWdodCB9KTtcbiAgICAgIH0pO1xuXG4gICAgICBpZiAoXy5oYXMobm9kZSwgXCJtaW5SYW5rXCIpKSB7XG4gICAgICAgIHJlc3VsdC5zZXROb2RlKHYsIHtcbiAgICAgICAgICBib3JkZXJMZWZ0OiBub2RlLmJvcmRlckxlZnRbcmFua10sXG4gICAgICAgICAgYm9yZGVyUmlnaHQ6IG5vZGUuYm9yZGVyUmlnaHRbcmFua11cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiBjcmVhdGVSb290Tm9kZShnKSB7XG4gIHZhciB2O1xuICB3aGlsZSAoZy5oYXNOb2RlKCh2ID0gXy51bmlxdWVJZChcIl9yb290XCIpKSkpO1xuICByZXR1cm4gdjtcbn1cbiIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgXyA9IHJlcXVpcmUoXCIuLi9sb2Rhc2hcIik7XG5cbm1vZHVsZS5leHBvcnRzID0gY3Jvc3NDb3VudDtcblxuLypcbiAqIEEgZnVuY3Rpb24gdGhhdCB0YWtlcyBhIGxheWVyaW5nIChhbiBhcnJheSBvZiBsYXllcnMsIGVhY2ggd2l0aCBhbiBhcnJheSBvZlxuICogb3JkZXJlcmQgbm9kZXMpIGFuZCBhIGdyYXBoIGFuZCByZXR1cm5zIGEgd2VpZ2h0ZWQgY3Jvc3NpbmcgY291bnQuXG4gKlxuICogUHJlLWNvbmRpdGlvbnM6XG4gKlxuICogICAgMS4gSW5wdXQgZ3JhcGggbXVzdCBiZSBzaW1wbGUgKG5vdCBhIG11bHRpZ3JhcGgpLCBkaXJlY3RlZCwgYW5kIGluY2x1ZGVcbiAqICAgICAgIG9ubHkgc2ltcGxlIGVkZ2VzLlxuICogICAgMi4gRWRnZXMgaW4gdGhlIGlucHV0IGdyYXBoIG11c3QgaGF2ZSBhc3NpZ25lZCB3ZWlnaHRzLlxuICpcbiAqIFBvc3QtY29uZGl0aW9uczpcbiAqXG4gKiAgICAxLiBUaGUgZ3JhcGggYW5kIGxheWVyaW5nIG1hdHJpeCBhcmUgbGVmdCB1bmNoYW5nZWQuXG4gKlxuICogVGhpcyBhbGdvcml0aG0gaXMgZGVyaXZlZCBmcm9tIEJhcnRoLCBldCBhbC4sIFwiQmlsYXllciBDcm9zcyBDb3VudGluZy5cIlxuICovXG5mdW5jdGlvbiBjcm9zc0NvdW50KGcsIGxheWVyaW5nKSB7XG4gIHZhciBjYyA9IDA7XG4gIGZvciAodmFyIGkgPSAxOyBpIDwgbGF5ZXJpbmcubGVuZ3RoOyArK2kpIHtcbiAgICBjYyArPSB0d29MYXllckNyb3NzQ291bnQoZywgbGF5ZXJpbmdbaS0xXSwgbGF5ZXJpbmdbaV0pO1xuICB9XG4gIHJldHVybiBjYztcbn1cblxuZnVuY3Rpb24gdHdvTGF5ZXJDcm9zc0NvdW50KGcsIG5vcnRoTGF5ZXIsIHNvdXRoTGF5ZXIpIHtcbiAgLy8gU29ydCBhbGwgb2YgdGhlIGVkZ2VzIGJldHdlZW4gdGhlIG5vcnRoIGFuZCBzb3V0aCBsYXllcnMgYnkgdGhlaXIgcG9zaXRpb25cbiAgLy8gaW4gdGhlIG5vcnRoIGxheWVyIGFuZCB0aGVuIHRoZSBzb3V0aC4gTWFwIHRoZXNlIGVkZ2VzIHRvIHRoZSBwb3NpdGlvbiBvZlxuICAvLyB0aGVpciBoZWFkIGluIHRoZSBzb3V0aCBsYXllci5cbiAgdmFyIHNvdXRoUG9zID0gXy56aXBPYmplY3Qoc291dGhMYXllcixcbiAgICBfLm1hcChzb3V0aExheWVyLCBmdW5jdGlvbiAodiwgaSkgeyByZXR1cm4gaTsgfSkpO1xuICB2YXIgc291dGhFbnRyaWVzID0gXy5mbGF0dGVuKF8ubWFwKG5vcnRoTGF5ZXIsIGZ1bmN0aW9uKHYpIHtcbiAgICByZXR1cm4gXy5zb3J0QnkoXy5tYXAoZy5vdXRFZGdlcyh2KSwgZnVuY3Rpb24oZSkge1xuICAgICAgcmV0dXJuIHsgcG9zOiBzb3V0aFBvc1tlLnddLCB3ZWlnaHQ6IGcuZWRnZShlKS53ZWlnaHQgfTtcbiAgICB9KSwgXCJwb3NcIik7XG4gIH0pLCB0cnVlKTtcblxuICAvLyBCdWlsZCB0aGUgYWNjdW11bGF0b3IgdHJlZVxuICB2YXIgZmlyc3RJbmRleCA9IDE7XG4gIHdoaWxlIChmaXJzdEluZGV4IDwgc291dGhMYXllci5sZW5ndGgpIGZpcnN0SW5kZXggPDw9IDE7XG4gIHZhciB0cmVlU2l6ZSA9IDIgKiBmaXJzdEluZGV4IC0gMTtcbiAgZmlyc3RJbmRleCAtPSAxO1xuICB2YXIgdHJlZSA9IF8ubWFwKG5ldyBBcnJheSh0cmVlU2l6ZSksIGZ1bmN0aW9uKCkgeyByZXR1cm4gMDsgfSk7XG5cbiAgLy8gQ2FsY3VsYXRlIHRoZSB3ZWlnaHRlZCBjcm9zc2luZ3NcbiAgdmFyIGNjID0gMDtcbiAgXy5mb3JFYWNoKHNvdXRoRW50cmllcy5mb3JFYWNoKGZ1bmN0aW9uKGVudHJ5KSB7XG4gICAgdmFyIGluZGV4ID0gZW50cnkucG9zICsgZmlyc3RJbmRleDtcbiAgICB0cmVlW2luZGV4XSArPSBlbnRyeS53ZWlnaHQ7XG4gICAgdmFyIHdlaWdodFN1bSA9IDA7XG4gICAgd2hpbGUgKGluZGV4ID4gMCkge1xuICAgICAgaWYgKGluZGV4ICUgMikge1xuICAgICAgICB3ZWlnaHRTdW0gKz0gdHJlZVtpbmRleCArIDFdO1xuICAgICAgfVxuICAgICAgaW5kZXggPSAoaW5kZXggLSAxKSA+PiAxO1xuICAgICAgdHJlZVtpbmRleF0gKz0gZW50cnkud2VpZ2h0O1xuICAgIH1cbiAgICBjYyArPSBlbnRyeS53ZWlnaHQgKiB3ZWlnaHRTdW07XG4gIH0pKTtcblxuICByZXR1cm4gY2M7XG59XG4iLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIF8gPSByZXF1aXJlKFwiLi4vbG9kYXNoXCIpO1xudmFyIGluaXRPcmRlciA9IHJlcXVpcmUoXCIuL2luaXQtb3JkZXJcIik7XG52YXIgY3Jvc3NDb3VudCA9IHJlcXVpcmUoXCIuL2Nyb3NzLWNvdW50XCIpO1xudmFyIHNvcnRTdWJncmFwaCA9IHJlcXVpcmUoXCIuL3NvcnQtc3ViZ3JhcGhcIik7XG52YXIgYnVpbGRMYXllckdyYXBoID0gcmVxdWlyZShcIi4vYnVpbGQtbGF5ZXItZ3JhcGhcIik7XG52YXIgYWRkU3ViZ3JhcGhDb25zdHJhaW50cyA9IHJlcXVpcmUoXCIuL2FkZC1zdWJncmFwaC1jb25zdHJhaW50c1wiKTtcbnZhciBHcmFwaCA9IHJlcXVpcmUoXCIuLi9ncmFwaGxpYlwiKS5HcmFwaDtcbnZhciB1dGlsID0gcmVxdWlyZShcIi4uL3V0aWxcIik7XG5cbm1vZHVsZS5leHBvcnRzID0gb3JkZXI7XG5cbi8qXG4gKiBBcHBsaWVzIGhldXJpc3RpY3MgdG8gbWluaW1pemUgZWRnZSBjcm9zc2luZ3MgaW4gdGhlIGdyYXBoIGFuZCBzZXRzIHRoZSBiZXN0XG4gKiBvcmRlciBzb2x1dGlvbiBhcyBhbiBvcmRlciBhdHRyaWJ1dGUgb24gZWFjaCBub2RlLlxuICpcbiAqIFByZS1jb25kaXRpb25zOlxuICpcbiAqICAgIDEuIEdyYXBoIG11c3QgYmUgREFHXG4gKiAgICAyLiBHcmFwaCBub2RlcyBtdXN0IGJlIG9iamVjdHMgd2l0aCBhIFwicmFua1wiIGF0dHJpYnV0ZVxuICogICAgMy4gR3JhcGggZWRnZXMgbXVzdCBoYXZlIHRoZSBcIndlaWdodFwiIGF0dHJpYnV0ZVxuICpcbiAqIFBvc3QtY29uZGl0aW9uczpcbiAqXG4gKiAgICAxLiBHcmFwaCBub2RlcyB3aWxsIGhhdmUgYW4gXCJvcmRlclwiIGF0dHJpYnV0ZSBiYXNlZCBvbiB0aGUgcmVzdWx0cyBvZiB0aGVcbiAqICAgICAgIGFsZ29yaXRobS5cbiAqL1xuZnVuY3Rpb24gb3JkZXIoZykge1xuICB2YXIgbWF4UmFuayA9IHV0aWwubWF4UmFuayhnKSxcbiAgICBkb3duTGF5ZXJHcmFwaHMgPSBidWlsZExheWVyR3JhcGhzKGcsIF8ucmFuZ2UoMSwgbWF4UmFuayArIDEpLCBcImluRWRnZXNcIiksXG4gICAgdXBMYXllckdyYXBocyA9IGJ1aWxkTGF5ZXJHcmFwaHMoZywgXy5yYW5nZShtYXhSYW5rIC0gMSwgLTEsIC0xKSwgXCJvdXRFZGdlc1wiKTtcblxuICB2YXIgbGF5ZXJpbmcgPSBpbml0T3JkZXIoZyk7XG4gIGFzc2lnbk9yZGVyKGcsIGxheWVyaW5nKTtcblxuICB2YXIgYmVzdENDID0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZLFxuICAgIGJlc3Q7XG5cbiAgZm9yICh2YXIgaSA9IDAsIGxhc3RCZXN0ID0gMDsgbGFzdEJlc3QgPCA0OyArK2ksICsrbGFzdEJlc3QpIHtcbiAgICBzd2VlcExheWVyR3JhcGhzKGkgJSAyID8gZG93bkxheWVyR3JhcGhzIDogdXBMYXllckdyYXBocywgaSAlIDQgPj0gMik7XG5cbiAgICBsYXllcmluZyA9IHV0aWwuYnVpbGRMYXllck1hdHJpeChnKTtcbiAgICB2YXIgY2MgPSBjcm9zc0NvdW50KGcsIGxheWVyaW5nKTtcbiAgICBpZiAoY2MgPCBiZXN0Q0MpIHtcbiAgICAgIGxhc3RCZXN0ID0gMDtcbiAgICAgIGJlc3QgPSBfLmNsb25lRGVlcChsYXllcmluZyk7XG4gICAgICBiZXN0Q0MgPSBjYztcbiAgICB9XG4gIH1cblxuICBhc3NpZ25PcmRlcihnLCBiZXN0KTtcbn1cblxuZnVuY3Rpb24gYnVpbGRMYXllckdyYXBocyhnLCByYW5rcywgcmVsYXRpb25zaGlwKSB7XG4gIHJldHVybiBfLm1hcChyYW5rcywgZnVuY3Rpb24ocmFuaykge1xuICAgIHJldHVybiBidWlsZExheWVyR3JhcGgoZywgcmFuaywgcmVsYXRpb25zaGlwKTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHN3ZWVwTGF5ZXJHcmFwaHMobGF5ZXJHcmFwaHMsIGJpYXNSaWdodCkge1xuICB2YXIgY2cgPSBuZXcgR3JhcGgoKTtcbiAgXy5mb3JFYWNoKGxheWVyR3JhcGhzLCBmdW5jdGlvbihsZykge1xuICAgIHZhciByb290ID0gbGcuZ3JhcGgoKS5yb290O1xuICAgIHZhciBzb3J0ZWQgPSBzb3J0U3ViZ3JhcGgobGcsIHJvb3QsIGNnLCBiaWFzUmlnaHQpO1xuICAgIF8uZm9yRWFjaChzb3J0ZWQudnMsIGZ1bmN0aW9uKHYsIGkpIHtcbiAgICAgIGxnLm5vZGUodikub3JkZXIgPSBpO1xuICAgIH0pO1xuICAgIGFkZFN1YmdyYXBoQ29uc3RyYWludHMobGcsIGNnLCBzb3J0ZWQudnMpO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gYXNzaWduT3JkZXIoZywgbGF5ZXJpbmcpIHtcbiAgXy5mb3JFYWNoKGxheWVyaW5nLCBmdW5jdGlvbihsYXllcikge1xuICAgIF8uZm9yRWFjaChsYXllciwgZnVuY3Rpb24odiwgaSkge1xuICAgICAgZy5ub2RlKHYpLm9yZGVyID0gaTtcbiAgICB9KTtcbiAgfSk7XG59XG4iLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIF8gPSByZXF1aXJlKFwiLi4vbG9kYXNoXCIpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGluaXRPcmRlcjtcblxuLypcbiAqIEFzc2lnbnMgYW4gaW5pdGlhbCBvcmRlciB2YWx1ZSBmb3IgZWFjaCBub2RlIGJ5IHBlcmZvcm1pbmcgYSBERlMgc2VhcmNoXG4gKiBzdGFydGluZyBmcm9tIG5vZGVzIGluIHRoZSBmaXJzdCByYW5rLiBOb2RlcyBhcmUgYXNzaWduZWQgYW4gb3JkZXIgaW4gdGhlaXJcbiAqIHJhbmsgYXMgdGhleSBhcmUgZmlyc3QgdmlzaXRlZC5cbiAqXG4gKiBUaGlzIGFwcHJvYWNoIGNvbWVzIGZyb20gR2Fuc25lciwgZXQgYWwuLCBcIkEgVGVjaG5pcXVlIGZvciBEcmF3aW5nIERpcmVjdGVkXG4gKiBHcmFwaHMuXCJcbiAqXG4gKiBSZXR1cm5zIGEgbGF5ZXJpbmcgbWF0cml4IHdpdGggYW4gYXJyYXkgcGVyIGxheWVyIGFuZCBlYWNoIGxheWVyIHNvcnRlZCBieVxuICogdGhlIG9yZGVyIG9mIGl0cyBub2Rlcy5cbiAqL1xuZnVuY3Rpb24gaW5pdE9yZGVyKGcpIHtcbiAgdmFyIHZpc2l0ZWQgPSB7fTtcbiAgdmFyIHNpbXBsZU5vZGVzID0gXy5maWx0ZXIoZy5ub2RlcygpLCBmdW5jdGlvbih2KSB7XG4gICAgcmV0dXJuICFnLmNoaWxkcmVuKHYpLmxlbmd0aDtcbiAgfSk7XG4gIHZhciBtYXhSYW5rID0gXy5tYXgoXy5tYXAoc2ltcGxlTm9kZXMsIGZ1bmN0aW9uKHYpIHsgcmV0dXJuIGcubm9kZSh2KS5yYW5rOyB9KSk7XG4gIHZhciBsYXllcnMgPSBfLm1hcChfLnJhbmdlKG1heFJhbmsgKyAxKSwgZnVuY3Rpb24oKSB7IHJldHVybiBbXTsgfSk7XG5cbiAgZnVuY3Rpb24gZGZzKHYpIHtcbiAgICBpZiAoXy5oYXModmlzaXRlZCwgdikpIHJldHVybjtcbiAgICB2aXNpdGVkW3ZdID0gdHJ1ZTtcbiAgICB2YXIgbm9kZSA9IGcubm9kZSh2KTtcbiAgICBsYXllcnNbbm9kZS5yYW5rXS5wdXNoKHYpO1xuICAgIF8uZm9yRWFjaChnLnN1Y2Nlc3NvcnModiksIGRmcyk7XG4gIH1cblxuICB2YXIgb3JkZXJlZFZzID0gXy5zb3J0Qnkoc2ltcGxlTm9kZXMsIGZ1bmN0aW9uKHYpIHsgcmV0dXJuIGcubm9kZSh2KS5yYW5rOyB9KTtcbiAgXy5mb3JFYWNoKG9yZGVyZWRWcywgZGZzKTtcblxuICByZXR1cm4gbGF5ZXJzO1xufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfID0gcmVxdWlyZShcIi4uL2xvZGFzaFwiKTtcblxubW9kdWxlLmV4cG9ydHMgPSByZXNvbHZlQ29uZmxpY3RzO1xuXG4vKlxuICogR2l2ZW4gYSBsaXN0IG9mIGVudHJpZXMgb2YgdGhlIGZvcm0ge3YsIGJhcnljZW50ZXIsIHdlaWdodH0gYW5kIGFcbiAqIGNvbnN0cmFpbnQgZ3JhcGggdGhpcyBmdW5jdGlvbiB3aWxsIHJlc29sdmUgYW55IGNvbmZsaWN0cyBiZXR3ZWVuIHRoZVxuICogY29uc3RyYWludCBncmFwaCBhbmQgdGhlIGJhcnljZW50ZXJzIGZvciB0aGUgZW50cmllcy4gSWYgdGhlIGJhcnljZW50ZXJzIGZvclxuICogYW4gZW50cnkgd291bGQgdmlvbGF0ZSBhIGNvbnN0cmFpbnQgaW4gdGhlIGNvbnN0cmFpbnQgZ3JhcGggdGhlbiB3ZSBjb2FsZXNjZVxuICogdGhlIG5vZGVzIGluIHRoZSBjb25mbGljdCBpbnRvIGEgbmV3IG5vZGUgdGhhdCByZXNwZWN0cyB0aGUgY29udHJhaW50IGFuZFxuICogYWdncmVnYXRlcyBiYXJ5Y2VudGVyIGFuZCB3ZWlnaHQgaW5mb3JtYXRpb24uXG4gKlxuICogVGhpcyBpbXBsZW1lbnRhdGlvbiBpcyBiYXNlZCBvbiB0aGUgZGVzY3JpcHRpb24gaW4gRm9yc3RlciwgXCJBIEZhc3QgYW5kXG4gKiBTaW1wbGUgSHVlcmlzdGljIGZvciBDb25zdHJhaW5lZCBUd28tTGV2ZWwgQ3Jvc3NpbmcgUmVkdWN0aW9uLFwiIHRob3VnaHQgaXRcbiAqIGRpZmZlcnMgaW4gc29tZSBzcGVjaWZpYyBkZXRhaWxzLlxuICpcbiAqIFByZS1jb25kaXRpb25zOlxuICpcbiAqICAgIDEuIEVhY2ggZW50cnkgaGFzIHRoZSBmb3JtIHt2LCBiYXJ5Y2VudGVyLCB3ZWlnaHR9LCBvciBpZiB0aGUgbm9kZSBoYXNcbiAqICAgICAgIG5vIGJhcnljZW50ZXIsIHRoZW4ge3Z9LlxuICpcbiAqIFJldHVybnM6XG4gKlxuICogICAgQSBuZXcgbGlzdCBvZiBlbnRyaWVzIG9mIHRoZSBmb3JtIHt2cywgaSwgYmFyeWNlbnRlciwgd2VpZ2h0fS4gVGhlIGxpc3RcbiAqICAgIGB2c2AgbWF5IGVpdGhlciBiZSBhIHNpbmdsZXRvbiBvciBpdCBtYXkgYmUgYW4gYWdncmVnYXRpb24gb2Ygbm9kZXNcbiAqICAgIG9yZGVyZWQgc3VjaCB0aGF0IHRoZXkgZG8gbm90IHZpb2xhdGUgY29uc3RyYWludHMgZnJvbSB0aGUgY29uc3RyYWludFxuICogICAgZ3JhcGguIFRoZSBwcm9wZXJ0eSBgaWAgaXMgdGhlIGxvd2VzdCBvcmlnaW5hbCBpbmRleCBvZiBhbnkgb2YgdGhlXG4gKiAgICBlbGVtZW50cyBpbiBgdnNgLlxuICovXG5mdW5jdGlvbiByZXNvbHZlQ29uZmxpY3RzKGVudHJpZXMsIGNnKSB7XG4gIHZhciBtYXBwZWRFbnRyaWVzID0ge307XG4gIF8uZm9yRWFjaChlbnRyaWVzLCBmdW5jdGlvbihlbnRyeSwgaSkge1xuICAgIHZhciB0bXAgPSBtYXBwZWRFbnRyaWVzW2VudHJ5LnZdID0ge1xuICAgICAgaW5kZWdyZWU6IDAsXG4gICAgICBcImluXCI6IFtdLFxuICAgICAgb3V0OiBbXSxcbiAgICAgIHZzOiBbZW50cnkudl0sXG4gICAgICBpOiBpXG4gICAgfTtcbiAgICBpZiAoIV8uaXNVbmRlZmluZWQoZW50cnkuYmFyeWNlbnRlcikpIHtcbiAgICAgIHRtcC5iYXJ5Y2VudGVyID0gZW50cnkuYmFyeWNlbnRlcjtcbiAgICAgIHRtcC53ZWlnaHQgPSBlbnRyeS53ZWlnaHQ7XG4gICAgfVxuICB9KTtcblxuICBfLmZvckVhY2goY2cuZWRnZXMoKSwgZnVuY3Rpb24oZSkge1xuICAgIHZhciBlbnRyeVYgPSBtYXBwZWRFbnRyaWVzW2Uudl07XG4gICAgdmFyIGVudHJ5VyA9IG1hcHBlZEVudHJpZXNbZS53XTtcbiAgICBpZiAoIV8uaXNVbmRlZmluZWQoZW50cnlWKSAmJiAhXy5pc1VuZGVmaW5lZChlbnRyeVcpKSB7XG4gICAgICBlbnRyeVcuaW5kZWdyZWUrKztcbiAgICAgIGVudHJ5Vi5vdXQucHVzaChtYXBwZWRFbnRyaWVzW2Uud10pO1xuICAgIH1cbiAgfSk7XG5cbiAgdmFyIHNvdXJjZVNldCA9IF8uZmlsdGVyKG1hcHBlZEVudHJpZXMsIGZ1bmN0aW9uKGVudHJ5KSB7XG4gICAgcmV0dXJuICFlbnRyeS5pbmRlZ3JlZTtcbiAgfSk7XG5cbiAgcmV0dXJuIGRvUmVzb2x2ZUNvbmZsaWN0cyhzb3VyY2VTZXQpO1xufVxuXG5mdW5jdGlvbiBkb1Jlc29sdmVDb25mbGljdHMoc291cmNlU2V0KSB7XG4gIHZhciBlbnRyaWVzID0gW107XG5cbiAgZnVuY3Rpb24gaGFuZGxlSW4odkVudHJ5KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHVFbnRyeSkge1xuICAgICAgaWYgKHVFbnRyeS5tZXJnZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKF8uaXNVbmRlZmluZWQodUVudHJ5LmJhcnljZW50ZXIpIHx8XG4gICAgICAgICAgXy5pc1VuZGVmaW5lZCh2RW50cnkuYmFyeWNlbnRlcikgfHxcbiAgICAgICAgICB1RW50cnkuYmFyeWNlbnRlciA+PSB2RW50cnkuYmFyeWNlbnRlcikge1xuICAgICAgICBtZXJnZUVudHJpZXModkVudHJ5LCB1RW50cnkpO1xuICAgICAgfVxuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBoYW5kbGVPdXQodkVudHJ5KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHdFbnRyeSkge1xuICAgICAgd0VudHJ5W1wiaW5cIl0ucHVzaCh2RW50cnkpO1xuICAgICAgaWYgKC0td0VudHJ5LmluZGVncmVlID09PSAwKSB7XG4gICAgICAgIHNvdXJjZVNldC5wdXNoKHdFbnRyeSk7XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIHdoaWxlIChzb3VyY2VTZXQubGVuZ3RoKSB7XG4gICAgdmFyIGVudHJ5ID0gc291cmNlU2V0LnBvcCgpO1xuICAgIGVudHJpZXMucHVzaChlbnRyeSk7XG4gICAgXy5mb3JFYWNoKGVudHJ5W1wiaW5cIl0ucmV2ZXJzZSgpLCBoYW5kbGVJbihlbnRyeSkpO1xuICAgIF8uZm9yRWFjaChlbnRyeS5vdXQsIGhhbmRsZU91dChlbnRyeSkpO1xuICB9XG5cbiAgcmV0dXJuIF8ubWFwKF8uZmlsdGVyKGVudHJpZXMsIGZ1bmN0aW9uKGVudHJ5KSB7IHJldHVybiAhZW50cnkubWVyZ2VkOyB9KSxcbiAgICBmdW5jdGlvbihlbnRyeSkge1xuICAgICAgcmV0dXJuIF8ucGljayhlbnRyeSwgW1widnNcIiwgXCJpXCIsIFwiYmFyeWNlbnRlclwiLCBcIndlaWdodFwiXSk7XG4gICAgfSk7XG5cbn1cblxuZnVuY3Rpb24gbWVyZ2VFbnRyaWVzKHRhcmdldCwgc291cmNlKSB7XG4gIHZhciBzdW0gPSAwO1xuICB2YXIgd2VpZ2h0ID0gMDtcblxuICBpZiAodGFyZ2V0LndlaWdodCkge1xuICAgIHN1bSArPSB0YXJnZXQuYmFyeWNlbnRlciAqIHRhcmdldC53ZWlnaHQ7XG4gICAgd2VpZ2h0ICs9IHRhcmdldC53ZWlnaHQ7XG4gIH1cblxuICBpZiAoc291cmNlLndlaWdodCkge1xuICAgIHN1bSArPSBzb3VyY2UuYmFyeWNlbnRlciAqIHNvdXJjZS53ZWlnaHQ7XG4gICAgd2VpZ2h0ICs9IHNvdXJjZS53ZWlnaHQ7XG4gIH1cblxuICB0YXJnZXQudnMgPSBzb3VyY2UudnMuY29uY2F0KHRhcmdldC52cyk7XG4gIHRhcmdldC5iYXJ5Y2VudGVyID0gc3VtIC8gd2VpZ2h0O1xuICB0YXJnZXQud2VpZ2h0ID0gd2VpZ2h0O1xuICB0YXJnZXQuaSA9IE1hdGgubWluKHNvdXJjZS5pLCB0YXJnZXQuaSk7XG4gIHNvdXJjZS5tZXJnZWQgPSB0cnVlO1xufVxuIiwidmFyIF8gPSByZXF1aXJlKFwiLi4vbG9kYXNoXCIpO1xudmFyIGJhcnljZW50ZXIgPSByZXF1aXJlKFwiLi9iYXJ5Y2VudGVyXCIpO1xudmFyIHJlc29sdmVDb25mbGljdHMgPSByZXF1aXJlKFwiLi9yZXNvbHZlLWNvbmZsaWN0c1wiKTtcbnZhciBzb3J0ID0gcmVxdWlyZShcIi4vc29ydFwiKTtcblxubW9kdWxlLmV4cG9ydHMgPSBzb3J0U3ViZ3JhcGg7XG5cbmZ1bmN0aW9uIHNvcnRTdWJncmFwaChnLCB2LCBjZywgYmlhc1JpZ2h0KSB7XG4gIHZhciBtb3ZhYmxlID0gZy5jaGlsZHJlbih2KTtcbiAgdmFyIG5vZGUgPSBnLm5vZGUodik7XG4gIHZhciBibCA9IG5vZGUgPyBub2RlLmJvcmRlckxlZnQgOiB1bmRlZmluZWQ7XG4gIHZhciBiciA9IG5vZGUgPyBub2RlLmJvcmRlclJpZ2h0OiB1bmRlZmluZWQ7XG4gIHZhciBzdWJncmFwaHMgPSB7fTtcblxuICBpZiAoYmwpIHtcbiAgICBtb3ZhYmxlID0gXy5maWx0ZXIobW92YWJsZSwgZnVuY3Rpb24odykge1xuICAgICAgcmV0dXJuIHcgIT09IGJsICYmIHcgIT09IGJyO1xuICAgIH0pO1xuICB9XG5cbiAgdmFyIGJhcnljZW50ZXJzID0gYmFyeWNlbnRlcihnLCBtb3ZhYmxlKTtcbiAgXy5mb3JFYWNoKGJhcnljZW50ZXJzLCBmdW5jdGlvbihlbnRyeSkge1xuICAgIGlmIChnLmNoaWxkcmVuKGVudHJ5LnYpLmxlbmd0aCkge1xuICAgICAgdmFyIHN1YmdyYXBoUmVzdWx0ID0gc29ydFN1YmdyYXBoKGcsIGVudHJ5LnYsIGNnLCBiaWFzUmlnaHQpO1xuICAgICAgc3ViZ3JhcGhzW2VudHJ5LnZdID0gc3ViZ3JhcGhSZXN1bHQ7XG4gICAgICBpZiAoXy5oYXMoc3ViZ3JhcGhSZXN1bHQsIFwiYmFyeWNlbnRlclwiKSkge1xuICAgICAgICBtZXJnZUJhcnljZW50ZXJzKGVudHJ5LCBzdWJncmFwaFJlc3VsdCk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcblxuICB2YXIgZW50cmllcyA9IHJlc29sdmVDb25mbGljdHMoYmFyeWNlbnRlcnMsIGNnKTtcbiAgZXhwYW5kU3ViZ3JhcGhzKGVudHJpZXMsIHN1YmdyYXBocyk7XG5cbiAgdmFyIHJlc3VsdCA9IHNvcnQoZW50cmllcywgYmlhc1JpZ2h0KTtcblxuICBpZiAoYmwpIHtcbiAgICByZXN1bHQudnMgPSBfLmZsYXR0ZW4oW2JsLCByZXN1bHQudnMsIGJyXSwgdHJ1ZSk7XG4gICAgaWYgKGcucHJlZGVjZXNzb3JzKGJsKS5sZW5ndGgpIHtcbiAgICAgIHZhciBibFByZWQgPSBnLm5vZGUoZy5wcmVkZWNlc3NvcnMoYmwpWzBdKSxcbiAgICAgICAgYnJQcmVkID0gZy5ub2RlKGcucHJlZGVjZXNzb3JzKGJyKVswXSk7XG4gICAgICBpZiAoIV8uaGFzKHJlc3VsdCwgXCJiYXJ5Y2VudGVyXCIpKSB7XG4gICAgICAgIHJlc3VsdC5iYXJ5Y2VudGVyID0gMDtcbiAgICAgICAgcmVzdWx0LndlaWdodCA9IDA7XG4gICAgICB9XG4gICAgICByZXN1bHQuYmFyeWNlbnRlciA9IChyZXN1bHQuYmFyeWNlbnRlciAqIHJlc3VsdC53ZWlnaHQgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgYmxQcmVkLm9yZGVyICsgYnJQcmVkLm9yZGVyKSAvIChyZXN1bHQud2VpZ2h0ICsgMik7XG4gICAgICByZXN1bHQud2VpZ2h0ICs9IDI7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gZXhwYW5kU3ViZ3JhcGhzKGVudHJpZXMsIHN1YmdyYXBocykge1xuICBfLmZvckVhY2goZW50cmllcywgZnVuY3Rpb24oZW50cnkpIHtcbiAgICBlbnRyeS52cyA9IF8uZmxhdHRlbihlbnRyeS52cy5tYXAoZnVuY3Rpb24odikge1xuICAgICAgaWYgKHN1YmdyYXBoc1t2XSkge1xuICAgICAgICByZXR1cm4gc3ViZ3JhcGhzW3ZdLnZzO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHY7XG4gICAgfSksIHRydWUpO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gbWVyZ2VCYXJ5Y2VudGVycyh0YXJnZXQsIG90aGVyKSB7XG4gIGlmICghXy5pc1VuZGVmaW5lZCh0YXJnZXQuYmFyeWNlbnRlcikpIHtcbiAgICB0YXJnZXQuYmFyeWNlbnRlciA9ICh0YXJnZXQuYmFyeWNlbnRlciAqIHRhcmdldC53ZWlnaHQgK1xuICAgICAgICAgICAgICAgICAgICAgICAgIG90aGVyLmJhcnljZW50ZXIgKiBvdGhlci53ZWlnaHQpIC9cbiAgICAgICAgICAgICAgICAgICAgICAgICh0YXJnZXQud2VpZ2h0ICsgb3RoZXIud2VpZ2h0KTtcbiAgICB0YXJnZXQud2VpZ2h0ICs9IG90aGVyLndlaWdodDtcbiAgfSBlbHNlIHtcbiAgICB0YXJnZXQuYmFyeWNlbnRlciA9IG90aGVyLmJhcnljZW50ZXI7XG4gICAgdGFyZ2V0LndlaWdodCA9IG90aGVyLndlaWdodDtcbiAgfVxufVxuIiwidmFyIF8gPSByZXF1aXJlKFwiLi4vbG9kYXNoXCIpO1xudmFyIHV0aWwgPSByZXF1aXJlKFwiLi4vdXRpbFwiKTtcblxubW9kdWxlLmV4cG9ydHMgPSBzb3J0O1xuXG5mdW5jdGlvbiBzb3J0KGVudHJpZXMsIGJpYXNSaWdodCkge1xuICB2YXIgcGFydHMgPSB1dGlsLnBhcnRpdGlvbihlbnRyaWVzLCBmdW5jdGlvbihlbnRyeSkge1xuICAgIHJldHVybiBfLmhhcyhlbnRyeSwgXCJiYXJ5Y2VudGVyXCIpO1xuICB9KTtcbiAgdmFyIHNvcnRhYmxlID0gcGFydHMubGhzLFxuICAgIHVuc29ydGFibGUgPSBfLnNvcnRCeShwYXJ0cy5yaHMsIGZ1bmN0aW9uKGVudHJ5KSB7IHJldHVybiAtZW50cnkuaTsgfSksXG4gICAgdnMgPSBbXSxcbiAgICBzdW0gPSAwLFxuICAgIHdlaWdodCA9IDAsXG4gICAgdnNJbmRleCA9IDA7XG5cbiAgc29ydGFibGUuc29ydChjb21wYXJlV2l0aEJpYXMoISFiaWFzUmlnaHQpKTtcblxuICB2c0luZGV4ID0gY29uc3VtZVVuc29ydGFibGUodnMsIHVuc29ydGFibGUsIHZzSW5kZXgpO1xuXG4gIF8uZm9yRWFjaChzb3J0YWJsZSwgZnVuY3Rpb24gKGVudHJ5KSB7XG4gICAgdnNJbmRleCArPSBlbnRyeS52cy5sZW5ndGg7XG4gICAgdnMucHVzaChlbnRyeS52cyk7XG4gICAgc3VtICs9IGVudHJ5LmJhcnljZW50ZXIgKiBlbnRyeS53ZWlnaHQ7XG4gICAgd2VpZ2h0ICs9IGVudHJ5LndlaWdodDtcbiAgICB2c0luZGV4ID0gY29uc3VtZVVuc29ydGFibGUodnMsIHVuc29ydGFibGUsIHZzSW5kZXgpO1xuICB9KTtcblxuICB2YXIgcmVzdWx0ID0geyB2czogXy5mbGF0dGVuKHZzLCB0cnVlKSB9O1xuICBpZiAod2VpZ2h0KSB7XG4gICAgcmVzdWx0LmJhcnljZW50ZXIgPSBzdW0gLyB3ZWlnaHQ7XG4gICAgcmVzdWx0LndlaWdodCA9IHdlaWdodDtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiBjb25zdW1lVW5zb3J0YWJsZSh2cywgdW5zb3J0YWJsZSwgaW5kZXgpIHtcbiAgdmFyIGxhc3Q7XG4gIHdoaWxlICh1bnNvcnRhYmxlLmxlbmd0aCAmJiAobGFzdCA9IF8ubGFzdCh1bnNvcnRhYmxlKSkuaSA8PSBpbmRleCkge1xuICAgIHVuc29ydGFibGUucG9wKCk7XG4gICAgdnMucHVzaChsYXN0LnZzKTtcbiAgICBpbmRleCsrO1xuICB9XG4gIHJldHVybiBpbmRleDtcbn1cblxuZnVuY3Rpb24gY29tcGFyZVdpdGhCaWFzKGJpYXMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKGVudHJ5ViwgZW50cnlXKSB7XG4gICAgaWYgKGVudHJ5Vi5iYXJ5Y2VudGVyIDwgZW50cnlXLmJhcnljZW50ZXIpIHtcbiAgICAgIHJldHVybiAtMTtcbiAgICB9IGVsc2UgaWYgKGVudHJ5Vi5iYXJ5Y2VudGVyID4gZW50cnlXLmJhcnljZW50ZXIpIHtcbiAgICAgIHJldHVybiAxO1xuICAgIH1cblxuICAgIHJldHVybiAhYmlhcyA/IGVudHJ5Vi5pIC0gZW50cnlXLmkgOiBlbnRyeVcuaSAtIGVudHJ5Vi5pO1xuICB9O1xufVxuIiwidmFyIF8gPSByZXF1aXJlKFwiLi9sb2Rhc2hcIik7XG5cbm1vZHVsZS5leHBvcnRzID0gcGFyZW50RHVtbXlDaGFpbnM7XG5cbmZ1bmN0aW9uIHBhcmVudER1bW15Q2hhaW5zKGcpIHtcbiAgdmFyIHBvc3RvcmRlck51bXMgPSBwb3N0b3JkZXIoZyk7XG5cbiAgXy5mb3JFYWNoKGcuZ3JhcGgoKS5kdW1teUNoYWlucywgZnVuY3Rpb24odikge1xuICAgIHZhciBub2RlID0gZy5ub2RlKHYpO1xuICAgIHZhciBlZGdlT2JqID0gbm9kZS5lZGdlT2JqO1xuICAgIHZhciBwYXRoRGF0YSA9IGZpbmRQYXRoKGcsIHBvc3RvcmRlck51bXMsIGVkZ2VPYmoudiwgZWRnZU9iai53KTtcbiAgICB2YXIgcGF0aCA9IHBhdGhEYXRhLnBhdGg7XG4gICAgdmFyIGxjYSA9IHBhdGhEYXRhLmxjYTtcbiAgICB2YXIgcGF0aElkeCA9IDA7XG4gICAgdmFyIHBhdGhWID0gcGF0aFtwYXRoSWR4XTtcbiAgICB2YXIgYXNjZW5kaW5nID0gdHJ1ZTtcblxuICAgIHdoaWxlICh2ICE9PSBlZGdlT2JqLncpIHtcbiAgICAgIG5vZGUgPSBnLm5vZGUodik7XG5cbiAgICAgIGlmIChhc2NlbmRpbmcpIHtcbiAgICAgICAgd2hpbGUgKChwYXRoViA9IHBhdGhbcGF0aElkeF0pICE9PSBsY2EgJiZcbiAgICAgICAgICAgICAgIGcubm9kZShwYXRoVikubWF4UmFuayA8IG5vZGUucmFuaykge1xuICAgICAgICAgIHBhdGhJZHgrKztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwYXRoViA9PT0gbGNhKSB7XG4gICAgICAgICAgYXNjZW5kaW5nID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKCFhc2NlbmRpbmcpIHtcbiAgICAgICAgd2hpbGUgKHBhdGhJZHggPCBwYXRoLmxlbmd0aCAtIDEgJiZcbiAgICAgICAgICAgICAgIGcubm9kZShwYXRoViA9IHBhdGhbcGF0aElkeCArIDFdKS5taW5SYW5rIDw9IG5vZGUucmFuaykge1xuICAgICAgICAgIHBhdGhJZHgrKztcbiAgICAgICAgfVxuICAgICAgICBwYXRoViA9IHBhdGhbcGF0aElkeF07XG4gICAgICB9XG5cbiAgICAgIGcuc2V0UGFyZW50KHYsIHBhdGhWKTtcbiAgICAgIHYgPSBnLnN1Y2Nlc3NvcnModilbMF07XG4gICAgfVxuICB9KTtcbn1cblxuLy8gRmluZCBhIHBhdGggZnJvbSB2IHRvIHcgdGhyb3VnaCB0aGUgbG93ZXN0IGNvbW1vbiBhbmNlc3RvciAoTENBKS4gUmV0dXJuIHRoZVxuLy8gZnVsbCBwYXRoIGFuZCB0aGUgTENBLlxuZnVuY3Rpb24gZmluZFBhdGgoZywgcG9zdG9yZGVyTnVtcywgdiwgdykge1xuICB2YXIgdlBhdGggPSBbXTtcbiAgdmFyIHdQYXRoID0gW107XG4gIHZhciBsb3cgPSBNYXRoLm1pbihwb3N0b3JkZXJOdW1zW3ZdLmxvdywgcG9zdG9yZGVyTnVtc1t3XS5sb3cpO1xuICB2YXIgbGltID0gTWF0aC5tYXgocG9zdG9yZGVyTnVtc1t2XS5saW0sIHBvc3RvcmRlck51bXNbd10ubGltKTtcbiAgdmFyIHBhcmVudDtcbiAgdmFyIGxjYTtcblxuICAvLyBUcmF2ZXJzZSB1cCBmcm9tIHYgdG8gZmluZCB0aGUgTENBXG4gIHBhcmVudCA9IHY7XG4gIGRvIHtcbiAgICBwYXJlbnQgPSBnLnBhcmVudChwYXJlbnQpO1xuICAgIHZQYXRoLnB1c2gocGFyZW50KTtcbiAgfSB3aGlsZSAocGFyZW50ICYmXG4gICAgICAgICAgIChwb3N0b3JkZXJOdW1zW3BhcmVudF0ubG93ID4gbG93IHx8IGxpbSA+IHBvc3RvcmRlck51bXNbcGFyZW50XS5saW0pKTtcbiAgbGNhID0gcGFyZW50O1xuXG4gIC8vIFRyYXZlcnNlIGZyb20gdyB0byBMQ0FcbiAgcGFyZW50ID0gdztcbiAgd2hpbGUgKChwYXJlbnQgPSBnLnBhcmVudChwYXJlbnQpKSAhPT0gbGNhKSB7XG4gICAgd1BhdGgucHVzaChwYXJlbnQpO1xuICB9XG5cbiAgcmV0dXJuIHsgcGF0aDogdlBhdGguY29uY2F0KHdQYXRoLnJldmVyc2UoKSksIGxjYTogbGNhIH07XG59XG5cbmZ1bmN0aW9uIHBvc3RvcmRlcihnKSB7XG4gIHZhciByZXN1bHQgPSB7fTtcbiAgdmFyIGxpbSA9IDA7XG5cbiAgZnVuY3Rpb24gZGZzKHYpIHtcbiAgICB2YXIgbG93ID0gbGltO1xuICAgIF8uZm9yRWFjaChnLmNoaWxkcmVuKHYpLCBkZnMpO1xuICAgIHJlc3VsdFt2XSA9IHsgbG93OiBsb3csIGxpbTogbGltKysgfTtcbiAgfVxuICBfLmZvckVhY2goZy5jaGlsZHJlbigpLCBkZnMpO1xuXG4gIHJldHVybiByZXN1bHQ7XG59XG4iLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIF8gPSByZXF1aXJlKFwiLi4vbG9kYXNoXCIpO1xudmFyIEdyYXBoID0gcmVxdWlyZShcIi4uL2dyYXBobGliXCIpLkdyYXBoO1xudmFyIHV0aWwgPSByZXF1aXJlKFwiLi4vdXRpbFwiKTtcblxuLypcbiAqIFRoaXMgbW9kdWxlIHByb3ZpZGVzIGNvb3JkaW5hdGUgYXNzaWdubWVudCBiYXNlZCBvbiBCcmFuZGVzIGFuZCBLw7ZwZiwgXCJGYXN0XG4gKiBhbmQgU2ltcGxlIEhvcml6b250YWwgQ29vcmRpbmF0ZSBBc3NpZ25tZW50LlwiXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIHBvc2l0aW9uWDogcG9zaXRpb25YLFxuICBmaW5kVHlwZTFDb25mbGljdHM6IGZpbmRUeXBlMUNvbmZsaWN0cyxcbiAgZmluZFR5cGUyQ29uZmxpY3RzOiBmaW5kVHlwZTJDb25mbGljdHMsXG4gIGFkZENvbmZsaWN0OiBhZGRDb25mbGljdCxcbiAgaGFzQ29uZmxpY3Q6IGhhc0NvbmZsaWN0LFxuICB2ZXJ0aWNhbEFsaWdubWVudDogdmVydGljYWxBbGlnbm1lbnQsXG4gIGhvcml6b250YWxDb21wYWN0aW9uOiBob3Jpem9udGFsQ29tcGFjdGlvbixcbiAgYWxpZ25Db29yZGluYXRlczogYWxpZ25Db29yZGluYXRlcyxcbiAgZmluZFNtYWxsZXN0V2lkdGhBbGlnbm1lbnQ6IGZpbmRTbWFsbGVzdFdpZHRoQWxpZ25tZW50LFxuICBiYWxhbmNlOiBiYWxhbmNlXG59O1xuXG4vKlxuICogTWFya3MgYWxsIGVkZ2VzIGluIHRoZSBncmFwaCB3aXRoIGEgdHlwZS0xIGNvbmZsaWN0IHdpdGggdGhlIFwidHlwZTFDb25mbGljdFwiXG4gKiBwcm9wZXJ0eS4gQSB0eXBlLTEgY29uZmxpY3QgaXMgb25lIHdoZXJlIGEgbm9uLWlubmVyIHNlZ21lbnQgY3Jvc3NlcyBhblxuICogaW5uZXIgc2VnbWVudC4gQW4gaW5uZXIgc2VnbWVudCBpcyBhbiBlZGdlIHdpdGggYm90aCBpbmNpZGVudCBub2RlcyBtYXJrZWRcbiAqIHdpdGggdGhlIFwiZHVtbXlcIiBwcm9wZXJ0eS5cbiAqXG4gKiBUaGlzIGFsZ29yaXRobSBzY2FucyBsYXllciBieSBsYXllciwgc3RhcnRpbmcgd2l0aCB0aGUgc2Vjb25kLCBmb3IgdHlwZS0xXG4gKiBjb25mbGljdHMgYmV0d2VlbiB0aGUgY3VycmVudCBsYXllciBhbmQgdGhlIHByZXZpb3VzIGxheWVyLiBGb3IgZWFjaCBsYXllclxuICogaXQgc2NhbnMgdGhlIG5vZGVzIGZyb20gbGVmdCB0byByaWdodCB1bnRpbCBpdCByZWFjaGVzIG9uZSB0aGF0IGlzIGluY2lkZW50XG4gKiBvbiBhbiBpbm5lciBzZWdtZW50LiBJdCB0aGVuIHNjYW5zIHByZWRlY2Vzc29ycyB0byBkZXRlcm1pbmUgaWYgdGhleSBoYXZlXG4gKiBlZGdlcyB0aGF0IGNyb3NzIHRoYXQgaW5uZXIgc2VnbWVudC4gQXQgdGhlIGVuZCBhIGZpbmFsIHNjYW4gaXMgZG9uZSBmb3IgYWxsXG4gKiBub2RlcyBvbiB0aGUgY3VycmVudCByYW5rIHRvIHNlZSBpZiB0aGV5IGNyb3NzIHRoZSBsYXN0IHZpc2l0ZWQgaW5uZXJcbiAqIHNlZ21lbnQuXG4gKlxuICogVGhpcyBhbGdvcml0aG0gKHNhZmVseSkgYXNzdW1lcyB0aGF0IGEgZHVtbXkgbm9kZSB3aWxsIG9ubHkgYmUgaW5jaWRlbnQgb24gYVxuICogc2luZ2xlIG5vZGUgaW4gdGhlIGxheWVycyBiZWluZyBzY2FubmVkLlxuICovXG5mdW5jdGlvbiBmaW5kVHlwZTFDb25mbGljdHMoZywgbGF5ZXJpbmcpIHtcbiAgdmFyIGNvbmZsaWN0cyA9IHt9O1xuXG4gIGZ1bmN0aW9uIHZpc2l0TGF5ZXIocHJldkxheWVyLCBsYXllcikge1xuICAgIHZhclxuICAgICAgLy8gbGFzdCB2aXNpdGVkIG5vZGUgaW4gdGhlIHByZXZpb3VzIGxheWVyIHRoYXQgaXMgaW5jaWRlbnQgb24gYW4gaW5uZXJcbiAgICAgIC8vIHNlZ21lbnQuXG4gICAgICBrMCA9IDAsXG4gICAgICAvLyBUcmFja3MgdGhlIGxhc3Qgbm9kZSBpbiB0aGlzIGxheWVyIHNjYW5uZWQgZm9yIGNyb3NzaW5ncyB3aXRoIGEgdHlwZS0xXG4gICAgICAvLyBzZWdtZW50LlxuICAgICAgc2NhblBvcyA9IDAsXG4gICAgICBwcmV2TGF5ZXJMZW5ndGggPSBwcmV2TGF5ZXIubGVuZ3RoLFxuICAgICAgbGFzdE5vZGUgPSBfLmxhc3QobGF5ZXIpO1xuXG4gICAgXy5mb3JFYWNoKGxheWVyLCBmdW5jdGlvbih2LCBpKSB7XG4gICAgICB2YXIgdyA9IGZpbmRPdGhlcklubmVyU2VnbWVudE5vZGUoZywgdiksXG4gICAgICAgIGsxID0gdyA/IGcubm9kZSh3KS5vcmRlciA6IHByZXZMYXllckxlbmd0aDtcblxuICAgICAgaWYgKHcgfHwgdiA9PT0gbGFzdE5vZGUpIHtcbiAgICAgICAgXy5mb3JFYWNoKGxheWVyLnNsaWNlKHNjYW5Qb3MsIGkgKzEpLCBmdW5jdGlvbihzY2FuTm9kZSkge1xuICAgICAgICAgIF8uZm9yRWFjaChnLnByZWRlY2Vzc29ycyhzY2FuTm9kZSksIGZ1bmN0aW9uKHUpIHtcbiAgICAgICAgICAgIHZhciB1TGFiZWwgPSBnLm5vZGUodSksXG4gICAgICAgICAgICAgIHVQb3MgPSB1TGFiZWwub3JkZXI7XG4gICAgICAgICAgICBpZiAoKHVQb3MgPCBrMCB8fCBrMSA8IHVQb3MpICYmXG4gICAgICAgICAgICAgICAgISh1TGFiZWwuZHVtbXkgJiYgZy5ub2RlKHNjYW5Ob2RlKS5kdW1teSkpIHtcbiAgICAgICAgICAgICAgYWRkQ29uZmxpY3QoY29uZmxpY3RzLCB1LCBzY2FuTm9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICBzY2FuUG9zID0gaSArIDE7XG4gICAgICAgIGswID0gazE7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gbGF5ZXI7XG4gIH1cblxuICBfLnJlZHVjZShsYXllcmluZywgdmlzaXRMYXllcik7XG4gIHJldHVybiBjb25mbGljdHM7XG59XG5cbmZ1bmN0aW9uIGZpbmRUeXBlMkNvbmZsaWN0cyhnLCBsYXllcmluZykge1xuICB2YXIgY29uZmxpY3RzID0ge307XG5cbiAgZnVuY3Rpb24gc2Nhbihzb3V0aCwgc291dGhQb3MsIHNvdXRoRW5kLCBwcmV2Tm9ydGhCb3JkZXIsIG5leHROb3J0aEJvcmRlcikge1xuICAgIHZhciB2O1xuICAgIF8uZm9yRWFjaChfLnJhbmdlKHNvdXRoUG9zLCBzb3V0aEVuZCksIGZ1bmN0aW9uKGkpIHtcbiAgICAgIHYgPSBzb3V0aFtpXTtcbiAgICAgIGlmIChnLm5vZGUodikuZHVtbXkpIHtcbiAgICAgICAgXy5mb3JFYWNoKGcucHJlZGVjZXNzb3JzKHYpLCBmdW5jdGlvbih1KSB7XG4gICAgICAgICAgdmFyIHVOb2RlID0gZy5ub2RlKHUpO1xuICAgICAgICAgIGlmICh1Tm9kZS5kdW1teSAmJlxuICAgICAgICAgICAgICAodU5vZGUub3JkZXIgPCBwcmV2Tm9ydGhCb3JkZXIgfHwgdU5vZGUub3JkZXIgPiBuZXh0Tm9ydGhCb3JkZXIpKSB7XG4gICAgICAgICAgICBhZGRDb25mbGljdChjb25mbGljdHMsIHUsIHYpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuXG4gIGZ1bmN0aW9uIHZpc2l0TGF5ZXIobm9ydGgsIHNvdXRoKSB7XG4gICAgdmFyIHByZXZOb3J0aFBvcyA9IC0xLFxuICAgICAgbmV4dE5vcnRoUG9zLFxuICAgICAgc291dGhQb3MgPSAwO1xuXG4gICAgXy5mb3JFYWNoKHNvdXRoLCBmdW5jdGlvbih2LCBzb3V0aExvb2thaGVhZCkge1xuICAgICAgaWYgKGcubm9kZSh2KS5kdW1teSA9PT0gXCJib3JkZXJcIikge1xuICAgICAgICB2YXIgcHJlZGVjZXNzb3JzID0gZy5wcmVkZWNlc3NvcnModik7XG4gICAgICAgIGlmIChwcmVkZWNlc3NvcnMubGVuZ3RoKSB7XG4gICAgICAgICAgbmV4dE5vcnRoUG9zID0gZy5ub2RlKHByZWRlY2Vzc29yc1swXSkub3JkZXI7XG4gICAgICAgICAgc2Nhbihzb3V0aCwgc291dGhQb3MsIHNvdXRoTG9va2FoZWFkLCBwcmV2Tm9ydGhQb3MsIG5leHROb3J0aFBvcyk7XG4gICAgICAgICAgc291dGhQb3MgPSBzb3V0aExvb2thaGVhZDtcbiAgICAgICAgICBwcmV2Tm9ydGhQb3MgPSBuZXh0Tm9ydGhQb3M7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHNjYW4oc291dGgsIHNvdXRoUG9zLCBzb3V0aC5sZW5ndGgsIG5leHROb3J0aFBvcywgbm9ydGgubGVuZ3RoKTtcbiAgICB9KTtcblxuICAgIHJldHVybiBzb3V0aDtcbiAgfVxuXG4gIF8ucmVkdWNlKGxheWVyaW5nLCB2aXNpdExheWVyKTtcbiAgcmV0dXJuIGNvbmZsaWN0cztcbn1cblxuZnVuY3Rpb24gZmluZE90aGVySW5uZXJTZWdtZW50Tm9kZShnLCB2KSB7XG4gIGlmIChnLm5vZGUodikuZHVtbXkpIHtcbiAgICByZXR1cm4gXy5maW5kKGcucHJlZGVjZXNzb3JzKHYpLCBmdW5jdGlvbih1KSB7XG4gICAgICByZXR1cm4gZy5ub2RlKHUpLmR1bW15O1xuICAgIH0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIGFkZENvbmZsaWN0KGNvbmZsaWN0cywgdiwgdykge1xuICBpZiAodiA+IHcpIHtcbiAgICB2YXIgdG1wID0gdjtcbiAgICB2ID0gdztcbiAgICB3ID0gdG1wO1xuICB9XG5cbiAgdmFyIGNvbmZsaWN0c1YgPSBjb25mbGljdHNbdl07XG4gIGlmICghY29uZmxpY3RzVikge1xuICAgIGNvbmZsaWN0c1t2XSA9IGNvbmZsaWN0c1YgPSB7fTtcbiAgfVxuICBjb25mbGljdHNWW3ddID0gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gaGFzQ29uZmxpY3QoY29uZmxpY3RzLCB2LCB3KSB7XG4gIGlmICh2ID4gdykge1xuICAgIHZhciB0bXAgPSB2O1xuICAgIHYgPSB3O1xuICAgIHcgPSB0bXA7XG4gIH1cbiAgcmV0dXJuIF8uaGFzKGNvbmZsaWN0c1t2XSwgdyk7XG59XG5cbi8qXG4gKiBUcnkgdG8gYWxpZ24gbm9kZXMgaW50byB2ZXJ0aWNhbCBcImJsb2Nrc1wiIHdoZXJlIHBvc3NpYmxlLiBUaGlzIGFsZ29yaXRobVxuICogYXR0ZW1wdHMgdG8gYWxpZ24gYSBub2RlIHdpdGggb25lIG9mIGl0cyBtZWRpYW4gbmVpZ2hib3JzLiBJZiB0aGUgZWRnZVxuICogY29ubmVjdGluZyBhIG5laWdoYm9yIGlzIGEgdHlwZS0xIGNvbmZsaWN0IHRoZW4gd2UgaWdub3JlIHRoYXQgcG9zc2liaWxpdHkuXG4gKiBJZiBhIHByZXZpb3VzIG5vZGUgaGFzIGFscmVhZHkgZm9ybWVkIGEgYmxvY2sgd2l0aCBhIG5vZGUgYWZ0ZXIgdGhlIG5vZGVcbiAqIHdlJ3JlIHRyeWluZyB0byBmb3JtIGEgYmxvY2sgd2l0aCwgd2UgYWxzbyBpZ25vcmUgdGhhdCBwb3NzaWJpbGl0eSAtIG91clxuICogYmxvY2tzIHdvdWxkIGJlIHNwbGl0IGluIHRoYXQgc2NlbmFyaW8uXG4gKi9cbmZ1bmN0aW9uIHZlcnRpY2FsQWxpZ25tZW50KGcsIGxheWVyaW5nLCBjb25mbGljdHMsIG5laWdoYm9yRm4pIHtcbiAgdmFyIHJvb3QgPSB7fSxcbiAgICBhbGlnbiA9IHt9LFxuICAgIHBvcyA9IHt9O1xuXG4gIC8vIFdlIGNhY2hlIHRoZSBwb3NpdGlvbiBoZXJlIGJhc2VkIG9uIHRoZSBsYXllcmluZyBiZWNhdXNlIHRoZSBncmFwaCBhbmRcbiAgLy8gbGF5ZXJpbmcgbWF5IGJlIG91dCBvZiBzeW5jLiBUaGUgbGF5ZXJpbmcgbWF0cml4IGlzIG1hbmlwdWxhdGVkIHRvXG4gIC8vIGdlbmVyYXRlIGRpZmZlcmVudCBleHRyZW1lIGFsaWdubWVudHMuXG4gIF8uZm9yRWFjaChsYXllcmluZywgZnVuY3Rpb24obGF5ZXIpIHtcbiAgICBfLmZvckVhY2gobGF5ZXIsIGZ1bmN0aW9uKHYsIG9yZGVyKSB7XG4gICAgICByb290W3ZdID0gdjtcbiAgICAgIGFsaWduW3ZdID0gdjtcbiAgICAgIHBvc1t2XSA9IG9yZGVyO1xuICAgIH0pO1xuICB9KTtcblxuICBfLmZvckVhY2gobGF5ZXJpbmcsIGZ1bmN0aW9uKGxheWVyKSB7XG4gICAgdmFyIHByZXZJZHggPSAtMTtcbiAgICBfLmZvckVhY2gobGF5ZXIsIGZ1bmN0aW9uKHYpIHtcbiAgICAgIHZhciB3cyA9IG5laWdoYm9yRm4odik7XG4gICAgICBpZiAod3MubGVuZ3RoKSB7XG4gICAgICAgIHdzID0gXy5zb3J0Qnkod3MsIGZ1bmN0aW9uKHcpIHsgcmV0dXJuIHBvc1t3XTsgfSk7XG4gICAgICAgIHZhciBtcCA9ICh3cy5sZW5ndGggLSAxKSAvIDI7XG4gICAgICAgIGZvciAodmFyIGkgPSBNYXRoLmZsb29yKG1wKSwgaWwgPSBNYXRoLmNlaWwobXApOyBpIDw9IGlsOyArK2kpIHtcbiAgICAgICAgICB2YXIgdyA9IHdzW2ldO1xuICAgICAgICAgIGlmIChhbGlnblt2XSA9PT0gdiAmJlxuICAgICAgICAgICAgICBwcmV2SWR4IDwgcG9zW3ddICYmXG4gICAgICAgICAgICAgICFoYXNDb25mbGljdChjb25mbGljdHMsIHYsIHcpKSB7XG4gICAgICAgICAgICBhbGlnblt3XSA9IHY7XG4gICAgICAgICAgICBhbGlnblt2XSA9IHJvb3Rbdl0gPSByb290W3ddO1xuICAgICAgICAgICAgcHJldklkeCA9IHBvc1t3XTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG5cbiAgcmV0dXJuIHsgcm9vdDogcm9vdCwgYWxpZ246IGFsaWduIH07XG59XG5cbmZ1bmN0aW9uIGhvcml6b250YWxDb21wYWN0aW9uKGcsIGxheWVyaW5nLCByb290LCBhbGlnbiwgcmV2ZXJzZVNlcCkge1xuICAvLyBUaGlzIHBvcnRpb24gb2YgdGhlIGFsZ29yaXRobSBkaWZmZXJzIGZyb20gQksgZHVlIHRvIGEgbnVtYmVyIG9mIHByb2JsZW1zLlxuICAvLyBJbnN0ZWFkIG9mIHRoZWlyIGFsZ29yaXRobSB3ZSBjb25zdHJ1Y3QgYSBuZXcgYmxvY2sgZ3JhcGggYW5kIGRvIHR3b1xuICAvLyBzd2VlcHMuIFRoZSBmaXJzdCBzd2VlcCBwbGFjZXMgYmxvY2tzIHdpdGggdGhlIHNtYWxsZXN0IHBvc3NpYmxlXG4gIC8vIGNvb3JkaW5hdGVzLiBUaGUgc2Vjb25kIHN3ZWVwIHJlbW92ZXMgdW51c2VkIHNwYWNlIGJ5IG1vdmluZyBibG9ja3MgdG8gdGhlXG4gIC8vIGdyZWF0ZXN0IGNvb3JkaW5hdGVzIHdpdGhvdXQgdmlvbGF0aW5nIHNlcGFyYXRpb24uXG4gIHZhciB4cyA9IHt9LFxuICAgIGJsb2NrRyA9IGJ1aWxkQmxvY2tHcmFwaChnLCBsYXllcmluZywgcm9vdCwgcmV2ZXJzZVNlcCksXG4gICAgYm9yZGVyVHlwZSA9IHJldmVyc2VTZXAgPyBcImJvcmRlckxlZnRcIiA6IFwiYm9yZGVyUmlnaHRcIjtcblxuICBmdW5jdGlvbiBpdGVyYXRlKHNldFhzRnVuYywgbmV4dE5vZGVzRnVuYykge1xuICAgIHZhciBzdGFjayA9IGJsb2NrRy5ub2RlcygpO1xuICAgIHZhciBlbGVtID0gc3RhY2sucG9wKCk7XG4gICAgdmFyIHZpc2l0ZWQgPSB7fTtcbiAgICB3aGlsZSAoZWxlbSkge1xuICAgICAgaWYgKHZpc2l0ZWRbZWxlbV0pIHtcbiAgICAgICAgc2V0WHNGdW5jKGVsZW0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmlzaXRlZFtlbGVtXSA9IHRydWU7XG4gICAgICAgIHN0YWNrLnB1c2goZWxlbSk7XG4gICAgICAgIHN0YWNrID0gc3RhY2suY29uY2F0KG5leHROb2Rlc0Z1bmMoZWxlbSkpO1xuICAgICAgfVxuXG4gICAgICBlbGVtID0gc3RhY2sucG9wKCk7XG4gICAgfVxuICB9XG5cbiAgLy8gRmlyc3QgcGFzcywgYXNzaWduIHNtYWxsZXN0IGNvb3JkaW5hdGVzXG4gIGZ1bmN0aW9uIHBhc3MxKGVsZW0pIHtcbiAgICB4c1tlbGVtXSA9IGJsb2NrRy5pbkVkZ2VzKGVsZW0pLnJlZHVjZShmdW5jdGlvbihhY2MsIGUpIHtcbiAgICAgIHJldHVybiBNYXRoLm1heChhY2MsIHhzW2Uudl0gKyBibG9ja0cuZWRnZShlKSk7XG4gICAgfSwgMCk7XG4gIH1cblxuICAvLyBTZWNvbmQgcGFzcywgYXNzaWduIGdyZWF0ZXN0IGNvb3JkaW5hdGVzXG4gIGZ1bmN0aW9uIHBhc3MyKGVsZW0pIHtcbiAgICB2YXIgbWluID0gYmxvY2tHLm91dEVkZ2VzKGVsZW0pLnJlZHVjZShmdW5jdGlvbihhY2MsIGUpIHtcbiAgICAgIHJldHVybiBNYXRoLm1pbihhY2MsIHhzW2Uud10gLSBibG9ja0cuZWRnZShlKSk7XG4gICAgfSwgTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZKTtcblxuICAgIHZhciBub2RlID0gZy5ub2RlKGVsZW0pO1xuICAgIGlmIChtaW4gIT09IE51bWJlci5QT1NJVElWRV9JTkZJTklUWSAmJiBub2RlLmJvcmRlclR5cGUgIT09IGJvcmRlclR5cGUpIHtcbiAgICAgIHhzW2VsZW1dID0gTWF0aC5tYXgoeHNbZWxlbV0sIG1pbik7XG4gICAgfVxuICB9XG5cbiAgaXRlcmF0ZShwYXNzMSwgYmxvY2tHLnByZWRlY2Vzc29ycy5iaW5kKGJsb2NrRykpO1xuICBpdGVyYXRlKHBhc3MyLCBibG9ja0cuc3VjY2Vzc29ycy5iaW5kKGJsb2NrRykpO1xuXG4gIC8vIEFzc2lnbiB4IGNvb3JkaW5hdGVzIHRvIGFsbCBub2Rlc1xuICBfLmZvckVhY2goYWxpZ24sIGZ1bmN0aW9uKHYpIHtcbiAgICB4c1t2XSA9IHhzW3Jvb3Rbdl1dO1xuICB9KTtcblxuICByZXR1cm4geHM7XG59XG5cblxuZnVuY3Rpb24gYnVpbGRCbG9ja0dyYXBoKGcsIGxheWVyaW5nLCByb290LCByZXZlcnNlU2VwKSB7XG4gIHZhciBibG9ja0dyYXBoID0gbmV3IEdyYXBoKCksXG4gICAgZ3JhcGhMYWJlbCA9IGcuZ3JhcGgoKSxcbiAgICBzZXBGbiA9IHNlcChncmFwaExhYmVsLm5vZGVzZXAsIGdyYXBoTGFiZWwuZWRnZXNlcCwgcmV2ZXJzZVNlcCk7XG5cbiAgXy5mb3JFYWNoKGxheWVyaW5nLCBmdW5jdGlvbihsYXllcikge1xuICAgIHZhciB1O1xuICAgIF8uZm9yRWFjaChsYXllciwgZnVuY3Rpb24odikge1xuICAgICAgdmFyIHZSb290ID0gcm9vdFt2XTtcbiAgICAgIGJsb2NrR3JhcGguc2V0Tm9kZSh2Um9vdCk7XG4gICAgICBpZiAodSkge1xuICAgICAgICB2YXIgdVJvb3QgPSByb290W3VdLFxuICAgICAgICAgIHByZXZNYXggPSBibG9ja0dyYXBoLmVkZ2UodVJvb3QsIHZSb290KTtcbiAgICAgICAgYmxvY2tHcmFwaC5zZXRFZGdlKHVSb290LCB2Um9vdCwgTWF0aC5tYXgoc2VwRm4oZywgdiwgdSksIHByZXZNYXggfHwgMCkpO1xuICAgICAgfVxuICAgICAgdSA9IHY7XG4gICAgfSk7XG4gIH0pO1xuXG4gIHJldHVybiBibG9ja0dyYXBoO1xufVxuXG4vKlxuICogUmV0dXJucyB0aGUgYWxpZ25tZW50IHRoYXQgaGFzIHRoZSBzbWFsbGVzdCB3aWR0aCBvZiB0aGUgZ2l2ZW4gYWxpZ25tZW50cy5cbiAqL1xuZnVuY3Rpb24gZmluZFNtYWxsZXN0V2lkdGhBbGlnbm1lbnQoZywgeHNzKSB7XG4gIHJldHVybiBfLm1pbkJ5KF8udmFsdWVzKHhzcyksIGZ1bmN0aW9uICh4cykge1xuICAgIHZhciBtYXggPSBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFk7XG4gICAgdmFyIG1pbiA9IE51bWJlci5QT1NJVElWRV9JTkZJTklUWTtcblxuICAgIF8uZm9ySW4oeHMsIGZ1bmN0aW9uICh4LCB2KSB7XG4gICAgICB2YXIgaGFsZldpZHRoID0gd2lkdGgoZywgdikgLyAyO1xuXG4gICAgICBtYXggPSBNYXRoLm1heCh4ICsgaGFsZldpZHRoLCBtYXgpO1xuICAgICAgbWluID0gTWF0aC5taW4oeCAtIGhhbGZXaWR0aCwgbWluKTtcbiAgICB9KTtcblxuICAgIHJldHVybiBtYXggLSBtaW47XG4gIH0pO1xufVxuXG4vKlxuICogQWxpZ24gdGhlIGNvb3JkaW5hdGVzIG9mIGVhY2ggb2YgdGhlIGxheW91dCBhbGlnbm1lbnRzIHN1Y2ggdGhhdFxuICogbGVmdC1iaWFzZWQgYWxpZ25tZW50cyBoYXZlIHRoZWlyIG1pbmltdW0gY29vcmRpbmF0ZSBhdCB0aGUgc2FtZSBwb2ludCBhc1xuICogdGhlIG1pbmltdW0gY29vcmRpbmF0ZSBvZiB0aGUgc21hbGxlc3Qgd2lkdGggYWxpZ25tZW50IGFuZCByaWdodC1iaWFzZWRcbiAqIGFsaWdubWVudHMgaGF2ZSB0aGVpciBtYXhpbXVtIGNvb3JkaW5hdGUgYXQgdGhlIHNhbWUgcG9pbnQgYXMgdGhlIG1heGltdW1cbiAqIGNvb3JkaW5hdGUgb2YgdGhlIHNtYWxsZXN0IHdpZHRoIGFsaWdubWVudC5cbiAqL1xuZnVuY3Rpb24gYWxpZ25Db29yZGluYXRlcyh4c3MsIGFsaWduVG8pIHtcbiAgdmFyIGFsaWduVG9WYWxzID0gXy52YWx1ZXMoYWxpZ25UbyksXG4gICAgYWxpZ25Ub01pbiA9IF8ubWluKGFsaWduVG9WYWxzKSxcbiAgICBhbGlnblRvTWF4ID0gXy5tYXgoYWxpZ25Ub1ZhbHMpO1xuXG4gIF8uZm9yRWFjaChbXCJ1XCIsIFwiZFwiXSwgZnVuY3Rpb24odmVydCkge1xuICAgIF8uZm9yRWFjaChbXCJsXCIsIFwiclwiXSwgZnVuY3Rpb24oaG9yaXopIHtcbiAgICAgIHZhciBhbGlnbm1lbnQgPSB2ZXJ0ICsgaG9yaXosXG4gICAgICAgIHhzID0geHNzW2FsaWdubWVudF0sXG4gICAgICAgIGRlbHRhO1xuICAgICAgaWYgKHhzID09PSBhbGlnblRvKSByZXR1cm47XG5cbiAgICAgIHZhciB4c1ZhbHMgPSBfLnZhbHVlcyh4cyk7XG4gICAgICBkZWx0YSA9IGhvcml6ID09PSBcImxcIiA/IGFsaWduVG9NaW4gLSBfLm1pbih4c1ZhbHMpIDogYWxpZ25Ub01heCAtIF8ubWF4KHhzVmFscyk7XG5cbiAgICAgIGlmIChkZWx0YSkge1xuICAgICAgICB4c3NbYWxpZ25tZW50XSA9IF8ubWFwVmFsdWVzKHhzLCBmdW5jdGlvbih4KSB7IHJldHVybiB4ICsgZGVsdGE7IH0pO1xuICAgICAgfVxuICAgIH0pO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gYmFsYW5jZSh4c3MsIGFsaWduKSB7XG4gIHJldHVybiBfLm1hcFZhbHVlcyh4c3MudWwsIGZ1bmN0aW9uKGlnbm9yZSwgdikge1xuICAgIGlmIChhbGlnbikge1xuICAgICAgcmV0dXJuIHhzc1thbGlnbi50b0xvd2VyQ2FzZSgpXVt2XTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHhzID0gXy5zb3J0QnkoXy5tYXAoeHNzLCB2KSk7XG4gICAgICByZXR1cm4gKHhzWzFdICsgeHNbMl0pIC8gMjtcbiAgICB9XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBwb3NpdGlvblgoZykge1xuICB2YXIgbGF5ZXJpbmcgPSB1dGlsLmJ1aWxkTGF5ZXJNYXRyaXgoZyk7XG4gIHZhciBjb25mbGljdHMgPSBfLm1lcmdlKFxuICAgIGZpbmRUeXBlMUNvbmZsaWN0cyhnLCBsYXllcmluZyksXG4gICAgZmluZFR5cGUyQ29uZmxpY3RzKGcsIGxheWVyaW5nKSk7XG5cbiAgdmFyIHhzcyA9IHt9O1xuICB2YXIgYWRqdXN0ZWRMYXllcmluZztcbiAgXy5mb3JFYWNoKFtcInVcIiwgXCJkXCJdLCBmdW5jdGlvbih2ZXJ0KSB7XG4gICAgYWRqdXN0ZWRMYXllcmluZyA9IHZlcnQgPT09IFwidVwiID8gbGF5ZXJpbmcgOiBfLnZhbHVlcyhsYXllcmluZykucmV2ZXJzZSgpO1xuICAgIF8uZm9yRWFjaChbXCJsXCIsIFwiclwiXSwgZnVuY3Rpb24oaG9yaXopIHtcbiAgICAgIGlmIChob3JpeiA9PT0gXCJyXCIpIHtcbiAgICAgICAgYWRqdXN0ZWRMYXllcmluZyA9IF8ubWFwKGFkanVzdGVkTGF5ZXJpbmcsIGZ1bmN0aW9uKGlubmVyKSB7XG4gICAgICAgICAgcmV0dXJuIF8udmFsdWVzKGlubmVyKS5yZXZlcnNlKCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICB2YXIgbmVpZ2hib3JGbiA9ICh2ZXJ0ID09PSBcInVcIiA/IGcucHJlZGVjZXNzb3JzIDogZy5zdWNjZXNzb3JzKS5iaW5kKGcpO1xuICAgICAgdmFyIGFsaWduID0gdmVydGljYWxBbGlnbm1lbnQoZywgYWRqdXN0ZWRMYXllcmluZywgY29uZmxpY3RzLCBuZWlnaGJvckZuKTtcbiAgICAgIHZhciB4cyA9IGhvcml6b250YWxDb21wYWN0aW9uKGcsIGFkanVzdGVkTGF5ZXJpbmcsXG4gICAgICAgIGFsaWduLnJvb3QsIGFsaWduLmFsaWduLCBob3JpeiA9PT0gXCJyXCIpO1xuICAgICAgaWYgKGhvcml6ID09PSBcInJcIikge1xuICAgICAgICB4cyA9IF8ubWFwVmFsdWVzKHhzLCBmdW5jdGlvbih4KSB7IHJldHVybiAteDsgfSk7XG4gICAgICB9XG4gICAgICB4c3NbdmVydCArIGhvcml6XSA9IHhzO1xuICAgIH0pO1xuICB9KTtcblxuICB2YXIgc21hbGxlc3RXaWR0aCA9IGZpbmRTbWFsbGVzdFdpZHRoQWxpZ25tZW50KGcsIHhzcyk7XG4gIGFsaWduQ29vcmRpbmF0ZXMoeHNzLCBzbWFsbGVzdFdpZHRoKTtcbiAgcmV0dXJuIGJhbGFuY2UoeHNzLCBnLmdyYXBoKCkuYWxpZ24pO1xufVxuXG5mdW5jdGlvbiBzZXAobm9kZVNlcCwgZWRnZVNlcCwgcmV2ZXJzZVNlcCkge1xuICByZXR1cm4gZnVuY3Rpb24oZywgdiwgdykge1xuICAgIHZhciB2TGFiZWwgPSBnLm5vZGUodik7XG4gICAgdmFyIHdMYWJlbCA9IGcubm9kZSh3KTtcbiAgICB2YXIgc3VtID0gMDtcbiAgICB2YXIgZGVsdGE7XG5cbiAgICBzdW0gKz0gdkxhYmVsLndpZHRoIC8gMjtcbiAgICBpZiAoXy5oYXModkxhYmVsLCBcImxhYmVscG9zXCIpKSB7XG4gICAgICBzd2l0Y2ggKHZMYWJlbC5sYWJlbHBvcy50b0xvd2VyQ2FzZSgpKSB7XG4gICAgICBjYXNlIFwibFwiOiBkZWx0YSA9IC12TGFiZWwud2lkdGggLyAyOyBicmVhaztcbiAgICAgIGNhc2UgXCJyXCI6IGRlbHRhID0gdkxhYmVsLndpZHRoIC8gMjsgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChkZWx0YSkge1xuICAgICAgc3VtICs9IHJldmVyc2VTZXAgPyBkZWx0YSA6IC1kZWx0YTtcbiAgICB9XG4gICAgZGVsdGEgPSAwO1xuXG4gICAgc3VtICs9ICh2TGFiZWwuZHVtbXkgPyBlZGdlU2VwIDogbm9kZVNlcCkgLyAyO1xuICAgIHN1bSArPSAod0xhYmVsLmR1bW15ID8gZWRnZVNlcCA6IG5vZGVTZXApIC8gMjtcblxuICAgIHN1bSArPSB3TGFiZWwud2lkdGggLyAyO1xuICAgIGlmIChfLmhhcyh3TGFiZWwsIFwibGFiZWxwb3NcIikpIHtcbiAgICAgIHN3aXRjaCAod0xhYmVsLmxhYmVscG9zLnRvTG93ZXJDYXNlKCkpIHtcbiAgICAgIGNhc2UgXCJsXCI6IGRlbHRhID0gd0xhYmVsLndpZHRoIC8gMjsgYnJlYWs7XG4gICAgICBjYXNlIFwiclwiOiBkZWx0YSA9IC13TGFiZWwud2lkdGggLyAyOyBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGRlbHRhKSB7XG4gICAgICBzdW0gKz0gcmV2ZXJzZVNlcCA/IGRlbHRhIDogLWRlbHRhO1xuICAgIH1cbiAgICBkZWx0YSA9IDA7XG5cbiAgICByZXR1cm4gc3VtO1xuICB9O1xufVxuXG5mdW5jdGlvbiB3aWR0aChnLCB2KSB7XG4gIHJldHVybiBnLm5vZGUodikud2lkdGg7XG59XG4iLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIF8gPSByZXF1aXJlKFwiLi4vbG9kYXNoXCIpO1xudmFyIHV0aWwgPSByZXF1aXJlKFwiLi4vdXRpbFwiKTtcbnZhciBwb3NpdGlvblggPSByZXF1aXJlKFwiLi9ia1wiKS5wb3NpdGlvblg7XG5cbm1vZHVsZS5leHBvcnRzID0gcG9zaXRpb247XG5cbmZ1bmN0aW9uIHBvc2l0aW9uKGcpIHtcbiAgZyA9IHV0aWwuYXNOb25Db21wb3VuZEdyYXBoKGcpO1xuXG4gIHBvc2l0aW9uWShnKTtcbiAgXy5mb3JFYWNoKHBvc2l0aW9uWChnKSwgZnVuY3Rpb24oeCwgdikge1xuICAgIGcubm9kZSh2KS54ID0geDtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHBvc2l0aW9uWShnKSB7XG4gIHZhciBsYXllcmluZyA9IHV0aWwuYnVpbGRMYXllck1hdHJpeChnKTtcbiAgdmFyIHJhbmtTZXAgPSBnLmdyYXBoKCkucmFua3NlcDtcbiAgdmFyIHByZXZZID0gMDtcbiAgXy5mb3JFYWNoKGxheWVyaW5nLCBmdW5jdGlvbihsYXllcikge1xuICAgIHZhciBtYXhIZWlnaHQgPSBfLm1heChfLm1hcChsYXllciwgZnVuY3Rpb24odikgeyByZXR1cm4gZy5ub2RlKHYpLmhlaWdodDsgfSkpO1xuICAgIF8uZm9yRWFjaChsYXllciwgZnVuY3Rpb24odikge1xuICAgICAgZy5ub2RlKHYpLnkgPSBwcmV2WSArIG1heEhlaWdodCAvIDI7XG4gICAgfSk7XG4gICAgcHJldlkgKz0gbWF4SGVpZ2h0ICsgcmFua1NlcDtcbiAgfSk7XG59XG5cbiIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgXyA9IHJlcXVpcmUoXCIuLi9sb2Rhc2hcIik7XG52YXIgR3JhcGggPSByZXF1aXJlKFwiLi4vZ3JhcGhsaWJcIikuR3JhcGg7XG52YXIgc2xhY2sgPSByZXF1aXJlKFwiLi91dGlsXCIpLnNsYWNrO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZlYXNpYmxlVHJlZTtcblxuLypcbiAqIENvbnN0cnVjdHMgYSBzcGFubmluZyB0cmVlIHdpdGggdGlnaHQgZWRnZXMgYW5kIGFkanVzdGVkIHRoZSBpbnB1dCBub2RlJ3NcbiAqIHJhbmtzIHRvIGFjaGlldmUgdGhpcy4gQSB0aWdodCBlZGdlIGlzIG9uZSB0aGF0IGlzIGhhcyBhIGxlbmd0aCB0aGF0IG1hdGNoZXNcbiAqIGl0cyBcIm1pbmxlblwiIGF0dHJpYnV0ZS5cbiAqXG4gKiBUaGUgYmFzaWMgc3RydWN0dXJlIGZvciB0aGlzIGZ1bmN0aW9uIGlzIGRlcml2ZWQgZnJvbSBHYW5zbmVyLCBldCBhbC4sIFwiQVxuICogVGVjaG5pcXVlIGZvciBEcmF3aW5nIERpcmVjdGVkIEdyYXBocy5cIlxuICpcbiAqIFByZS1jb25kaXRpb25zOlxuICpcbiAqICAgIDEuIEdyYXBoIG11c3QgYmUgYSBEQUcuXG4gKiAgICAyLiBHcmFwaCBtdXN0IGJlIGNvbm5lY3RlZC5cbiAqICAgIDMuIEdyYXBoIG11c3QgaGF2ZSBhdCBsZWFzdCBvbmUgbm9kZS5cbiAqICAgIDUuIEdyYXBoIG5vZGVzIG11c3QgaGF2ZSBiZWVuIHByZXZpb3VzbHkgYXNzaWduZWQgYSBcInJhbmtcIiBwcm9wZXJ0eSB0aGF0XG4gKiAgICAgICByZXNwZWN0cyB0aGUgXCJtaW5sZW5cIiBwcm9wZXJ0eSBvZiBpbmNpZGVudCBlZGdlcy5cbiAqICAgIDYuIEdyYXBoIGVkZ2VzIG11c3QgaGF2ZSBhIFwibWlubGVuXCIgcHJvcGVydHkuXG4gKlxuICogUG9zdC1jb25kaXRpb25zOlxuICpcbiAqICAgIC0gR3JhcGggbm9kZXMgd2lsbCBoYXZlIHRoZWlyIHJhbmsgYWRqdXN0ZWQgdG8gZW5zdXJlIHRoYXQgYWxsIGVkZ2VzIGFyZVxuICogICAgICB0aWdodC5cbiAqXG4gKiBSZXR1cm5zIGEgdHJlZSAodW5kaXJlY3RlZCBncmFwaCkgdGhhdCBpcyBjb25zdHJ1Y3RlZCB1c2luZyBvbmx5IFwidGlnaHRcIlxuICogZWRnZXMuXG4gKi9cbmZ1bmN0aW9uIGZlYXNpYmxlVHJlZShnKSB7XG4gIHZhciB0ID0gbmV3IEdyYXBoKHsgZGlyZWN0ZWQ6IGZhbHNlIH0pO1xuXG4gIC8vIENob29zZSBhcmJpdHJhcnkgbm9kZSBmcm9tIHdoaWNoIHRvIHN0YXJ0IG91ciB0cmVlXG4gIHZhciBzdGFydCA9IGcubm9kZXMoKVswXTtcbiAgdmFyIHNpemUgPSBnLm5vZGVDb3VudCgpO1xuICB0LnNldE5vZGUoc3RhcnQsIHt9KTtcblxuICB2YXIgZWRnZSwgZGVsdGE7XG4gIHdoaWxlICh0aWdodFRyZWUodCwgZykgPCBzaXplKSB7XG4gICAgZWRnZSA9IGZpbmRNaW5TbGFja0VkZ2UodCwgZyk7XG4gICAgZGVsdGEgPSB0Lmhhc05vZGUoZWRnZS52KSA/IHNsYWNrKGcsIGVkZ2UpIDogLXNsYWNrKGcsIGVkZ2UpO1xuICAgIHNoaWZ0UmFua3ModCwgZywgZGVsdGEpO1xuICB9XG5cbiAgcmV0dXJuIHQ7XG59XG5cbi8qXG4gKiBGaW5kcyBhIG1heGltYWwgdHJlZSBvZiB0aWdodCBlZGdlcyBhbmQgcmV0dXJucyB0aGUgbnVtYmVyIG9mIG5vZGVzIGluIHRoZVxuICogdHJlZS5cbiAqL1xuZnVuY3Rpb24gdGlnaHRUcmVlKHQsIGcpIHtcbiAgZnVuY3Rpb24gZGZzKHYpIHtcbiAgICBfLmZvckVhY2goZy5ub2RlRWRnZXModiksIGZ1bmN0aW9uKGUpIHtcbiAgICAgIHZhciBlZGdlViA9IGUudixcbiAgICAgICAgdyA9ICh2ID09PSBlZGdlVikgPyBlLncgOiBlZGdlVjtcbiAgICAgIGlmICghdC5oYXNOb2RlKHcpICYmICFzbGFjayhnLCBlKSkge1xuICAgICAgICB0LnNldE5vZGUodywge30pO1xuICAgICAgICB0LnNldEVkZ2Uodiwgdywge30pO1xuICAgICAgICBkZnModyk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBfLmZvckVhY2godC5ub2RlcygpLCBkZnMpO1xuICByZXR1cm4gdC5ub2RlQ291bnQoKTtcbn1cblxuLypcbiAqIEZpbmRzIHRoZSBlZGdlIHdpdGggdGhlIHNtYWxsZXN0IHNsYWNrIHRoYXQgaXMgaW5jaWRlbnQgb24gdHJlZSBhbmQgcmV0dXJuc1xuICogaXQuXG4gKi9cbmZ1bmN0aW9uIGZpbmRNaW5TbGFja0VkZ2UodCwgZykge1xuICByZXR1cm4gXy5taW5CeShnLmVkZ2VzKCksIGZ1bmN0aW9uKGUpIHtcbiAgICBpZiAodC5oYXNOb2RlKGUudikgIT09IHQuaGFzTm9kZShlLncpKSB7XG4gICAgICByZXR1cm4gc2xhY2soZywgZSk7XG4gICAgfVxuICB9KTtcbn1cblxuZnVuY3Rpb24gc2hpZnRSYW5rcyh0LCBnLCBkZWx0YSkge1xuICBfLmZvckVhY2godC5ub2RlcygpLCBmdW5jdGlvbih2KSB7XG4gICAgZy5ub2RlKHYpLnJhbmsgKz0gZGVsdGE7XG4gIH0pO1xufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciByYW5rVXRpbCA9IHJlcXVpcmUoXCIuL3V0aWxcIik7XG52YXIgbG9uZ2VzdFBhdGggPSByYW5rVXRpbC5sb25nZXN0UGF0aDtcbnZhciBmZWFzaWJsZVRyZWUgPSByZXF1aXJlKFwiLi9mZWFzaWJsZS10cmVlXCIpO1xudmFyIG5ldHdvcmtTaW1wbGV4ID0gcmVxdWlyZShcIi4vbmV0d29yay1zaW1wbGV4XCIpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJhbms7XG5cbi8qXG4gKiBBc3NpZ25zIGEgcmFuayB0byBlYWNoIG5vZGUgaW4gdGhlIGlucHV0IGdyYXBoIHRoYXQgcmVzcGVjdHMgdGhlIFwibWlubGVuXCJcbiAqIGNvbnN0cmFpbnQgc3BlY2lmaWVkIG9uIGVkZ2VzIGJldHdlZW4gbm9kZXMuXG4gKlxuICogVGhpcyBiYXNpYyBzdHJ1Y3R1cmUgaXMgZGVyaXZlZCBmcm9tIEdhbnNuZXIsIGV0IGFsLiwgXCJBIFRlY2huaXF1ZSBmb3JcbiAqIERyYXdpbmcgRGlyZWN0ZWQgR3JhcGhzLlwiXG4gKlxuICogUHJlLWNvbmRpdGlvbnM6XG4gKlxuICogICAgMS4gR3JhcGggbXVzdCBiZSBhIGNvbm5lY3RlZCBEQUdcbiAqICAgIDIuIEdyYXBoIG5vZGVzIG11c3QgYmUgb2JqZWN0c1xuICogICAgMy4gR3JhcGggZWRnZXMgbXVzdCBoYXZlIFwid2VpZ2h0XCIgYW5kIFwibWlubGVuXCIgYXR0cmlidXRlc1xuICpcbiAqIFBvc3QtY29uZGl0aW9uczpcbiAqXG4gKiAgICAxLiBHcmFwaCBub2RlcyB3aWxsIGhhdmUgYSBcInJhbmtcIiBhdHRyaWJ1dGUgYmFzZWQgb24gdGhlIHJlc3VsdHMgb2YgdGhlXG4gKiAgICAgICBhbGdvcml0aG0uIFJhbmtzIGNhbiBzdGFydCBhdCBhbnkgaW5kZXggKGluY2x1ZGluZyBuZWdhdGl2ZSksIHdlJ2xsXG4gKiAgICAgICBmaXggdGhlbSB1cCBsYXRlci5cbiAqL1xuZnVuY3Rpb24gcmFuayhnKSB7XG4gIHN3aXRjaChnLmdyYXBoKCkucmFua2VyKSB7XG4gIGNhc2UgXCJuZXR3b3JrLXNpbXBsZXhcIjogbmV0d29ya1NpbXBsZXhSYW5rZXIoZyk7IGJyZWFrO1xuICBjYXNlIFwidGlnaHQtdHJlZVwiOiB0aWdodFRyZWVSYW5rZXIoZyk7IGJyZWFrO1xuICBjYXNlIFwibG9uZ2VzdC1wYXRoXCI6IGxvbmdlc3RQYXRoUmFua2VyKGcpOyBicmVhaztcbiAgZGVmYXVsdDogbmV0d29ya1NpbXBsZXhSYW5rZXIoZyk7XG4gIH1cbn1cblxuLy8gQSBmYXN0IGFuZCBzaW1wbGUgcmFua2VyLCBidXQgcmVzdWx0cyBhcmUgZmFyIGZyb20gb3B0aW1hbC5cbnZhciBsb25nZXN0UGF0aFJhbmtlciA9IGxvbmdlc3RQYXRoO1xuXG5mdW5jdGlvbiB0aWdodFRyZWVSYW5rZXIoZykge1xuICBsb25nZXN0UGF0aChnKTtcbiAgZmVhc2libGVUcmVlKGcpO1xufVxuXG5mdW5jdGlvbiBuZXR3b3JrU2ltcGxleFJhbmtlcihnKSB7XG4gIG5ldHdvcmtTaW1wbGV4KGcpO1xufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfID0gcmVxdWlyZShcIi4uL2xvZGFzaFwiKTtcbnZhciBmZWFzaWJsZVRyZWUgPSByZXF1aXJlKFwiLi9mZWFzaWJsZS10cmVlXCIpO1xudmFyIHNsYWNrID0gcmVxdWlyZShcIi4vdXRpbFwiKS5zbGFjaztcbnZhciBpbml0UmFuayA9IHJlcXVpcmUoXCIuL3V0aWxcIikubG9uZ2VzdFBhdGg7XG52YXIgcHJlb3JkZXIgPSByZXF1aXJlKFwiLi4vZ3JhcGhsaWJcIikuYWxnLnByZW9yZGVyO1xudmFyIHBvc3RvcmRlciA9IHJlcXVpcmUoXCIuLi9ncmFwaGxpYlwiKS5hbGcucG9zdG9yZGVyO1xudmFyIHNpbXBsaWZ5ID0gcmVxdWlyZShcIi4uL3V0aWxcIikuc2ltcGxpZnk7XG5cbm1vZHVsZS5leHBvcnRzID0gbmV0d29ya1NpbXBsZXg7XG5cbi8vIEV4cG9zZSBzb21lIGludGVybmFscyBmb3IgdGVzdGluZyBwdXJwb3Nlc1xubmV0d29ya1NpbXBsZXguaW5pdExvd0xpbVZhbHVlcyA9IGluaXRMb3dMaW1WYWx1ZXM7XG5uZXR3b3JrU2ltcGxleC5pbml0Q3V0VmFsdWVzID0gaW5pdEN1dFZhbHVlcztcbm5ldHdvcmtTaW1wbGV4LmNhbGNDdXRWYWx1ZSA9IGNhbGNDdXRWYWx1ZTtcbm5ldHdvcmtTaW1wbGV4LmxlYXZlRWRnZSA9IGxlYXZlRWRnZTtcbm5ldHdvcmtTaW1wbGV4LmVudGVyRWRnZSA9IGVudGVyRWRnZTtcbm5ldHdvcmtTaW1wbGV4LmV4Y2hhbmdlRWRnZXMgPSBleGNoYW5nZUVkZ2VzO1xuXG4vKlxuICogVGhlIG5ldHdvcmsgc2ltcGxleCBhbGdvcml0aG0gYXNzaWducyByYW5rcyB0byBlYWNoIG5vZGUgaW4gdGhlIGlucHV0IGdyYXBoXG4gKiBhbmQgaXRlcmF0aXZlbHkgaW1wcm92ZXMgdGhlIHJhbmtpbmcgdG8gcmVkdWNlIHRoZSBsZW5ndGggb2YgZWRnZXMuXG4gKlxuICogUHJlY29uZGl0aW9uczpcbiAqXG4gKiAgICAxLiBUaGUgaW5wdXQgZ3JhcGggbXVzdCBiZSBhIERBRy5cbiAqICAgIDIuIEFsbCBub2RlcyBpbiB0aGUgZ3JhcGggbXVzdCBoYXZlIGFuIG9iamVjdCB2YWx1ZS5cbiAqICAgIDMuIEFsbCBlZGdlcyBpbiB0aGUgZ3JhcGggbXVzdCBoYXZlIFwibWlubGVuXCIgYW5kIFwid2VpZ2h0XCIgYXR0cmlidXRlcy5cbiAqXG4gKiBQb3N0Y29uZGl0aW9uczpcbiAqXG4gKiAgICAxLiBBbGwgbm9kZXMgaW4gdGhlIGdyYXBoIHdpbGwgaGF2ZSBhbiBhc3NpZ25lZCBcInJhbmtcIiBhdHRyaWJ1dGUgdGhhdCBoYXNcbiAqICAgICAgIGJlZW4gb3B0aW1pemVkIGJ5IHRoZSBuZXR3b3JrIHNpbXBsZXggYWxnb3JpdGhtLiBSYW5rcyBzdGFydCBhdCAwLlxuICpcbiAqXG4gKiBBIHJvdWdoIHNrZXRjaCBvZiB0aGUgYWxnb3JpdGhtIGlzIGFzIGZvbGxvd3M6XG4gKlxuICogICAgMS4gQXNzaWduIGluaXRpYWwgcmFua3MgdG8gZWFjaCBub2RlLiBXZSB1c2UgdGhlIGxvbmdlc3QgcGF0aCBhbGdvcml0aG0sXG4gKiAgICAgICB3aGljaCBhc3NpZ25zIHJhbmtzIHRvIHRoZSBsb3dlc3QgcG9zaXRpb24gcG9zc2libGUuIEluIGdlbmVyYWwgdGhpc1xuICogICAgICAgbGVhZHMgdG8gdmVyeSB3aWRlIGJvdHRvbSByYW5rcyBhbmQgdW5uZWNlc3NhcmlseSBsb25nIGVkZ2VzLlxuICogICAgMi4gQ29uc3RydWN0IGEgZmVhc2libGUgdGlnaHQgdHJlZS4gQSB0aWdodCB0cmVlIGlzIG9uZSBzdWNoIHRoYXQgYWxsXG4gKiAgICAgICBlZGdlcyBpbiB0aGUgdHJlZSBoYXZlIG5vIHNsYWNrIChkaWZmZXJlbmNlIGJldHdlZW4gbGVuZ3RoIG9mIGVkZ2VcbiAqICAgICAgIGFuZCBtaW5sZW4gZm9yIHRoZSBlZGdlKS4gVGhpcyBieSBpdHNlbGYgZ3JlYXRseSBpbXByb3ZlcyB0aGUgYXNzaWduZWRcbiAqICAgICAgIHJhbmtpbmdzIGJ5IHNob3J0aW5nIGVkZ2VzLlxuICogICAgMy4gSXRlcmF0aXZlbHkgZmluZCBlZGdlcyB0aGF0IGhhdmUgbmVnYXRpdmUgY3V0IHZhbHVlcy4gR2VuZXJhbGx5IGFcbiAqICAgICAgIG5lZ2F0aXZlIGN1dCB2YWx1ZSBpbmRpY2F0ZXMgdGhhdCB0aGUgZWRnZSBjb3VsZCBiZSByZW1vdmVkIGFuZCBhIG5ld1xuICogICAgICAgdHJlZSBlZGdlIGNvdWxkIGJlIGFkZGVkIHRvIHByb2R1Y2UgYSBtb3JlIGNvbXBhY3QgZ3JhcGguXG4gKlxuICogTXVjaCBvZiB0aGUgYWxnb3JpdGhtcyBoZXJlIGFyZSBkZXJpdmVkIGZyb20gR2Fuc25lciwgZXQgYWwuLCBcIkEgVGVjaG5pcXVlXG4gKiBmb3IgRHJhd2luZyBEaXJlY3RlZCBHcmFwaHMuXCIgVGhlIHN0cnVjdHVyZSBvZiB0aGUgZmlsZSByb3VnaGx5IGZvbGxvd3MgdGhlXG4gKiBzdHJ1Y3R1cmUgb2YgdGhlIG92ZXJhbGwgYWxnb3JpdGhtLlxuICovXG5mdW5jdGlvbiBuZXR3b3JrU2ltcGxleChnKSB7XG4gIGcgPSBzaW1wbGlmeShnKTtcbiAgaW5pdFJhbmsoZyk7XG4gIHZhciB0ID0gZmVhc2libGVUcmVlKGcpO1xuICBpbml0TG93TGltVmFsdWVzKHQpO1xuICBpbml0Q3V0VmFsdWVzKHQsIGcpO1xuXG4gIHZhciBlLCBmO1xuICB3aGlsZSAoKGUgPSBsZWF2ZUVkZ2UodCkpKSB7XG4gICAgZiA9IGVudGVyRWRnZSh0LCBnLCBlKTtcbiAgICBleGNoYW5nZUVkZ2VzKHQsIGcsIGUsIGYpO1xuICB9XG59XG5cbi8qXG4gKiBJbml0aWFsaXplcyBjdXQgdmFsdWVzIGZvciBhbGwgZWRnZXMgaW4gdGhlIHRyZWUuXG4gKi9cbmZ1bmN0aW9uIGluaXRDdXRWYWx1ZXModCwgZykge1xuICB2YXIgdnMgPSBwb3N0b3JkZXIodCwgdC5ub2RlcygpKTtcbiAgdnMgPSB2cy5zbGljZSgwLCB2cy5sZW5ndGggLSAxKTtcbiAgXy5mb3JFYWNoKHZzLCBmdW5jdGlvbih2KSB7XG4gICAgYXNzaWduQ3V0VmFsdWUodCwgZywgdik7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBhc3NpZ25DdXRWYWx1ZSh0LCBnLCBjaGlsZCkge1xuICB2YXIgY2hpbGRMYWIgPSB0Lm5vZGUoY2hpbGQpO1xuICB2YXIgcGFyZW50ID0gY2hpbGRMYWIucGFyZW50O1xuICB0LmVkZ2UoY2hpbGQsIHBhcmVudCkuY3V0dmFsdWUgPSBjYWxjQ3V0VmFsdWUodCwgZywgY2hpbGQpO1xufVxuXG4vKlxuICogR2l2ZW4gdGhlIHRpZ2h0IHRyZWUsIGl0cyBncmFwaCwgYW5kIGEgY2hpbGQgaW4gdGhlIGdyYXBoIGNhbGN1bGF0ZSBhbmRcbiAqIHJldHVybiB0aGUgY3V0IHZhbHVlIGZvciB0aGUgZWRnZSBiZXR3ZWVuIHRoZSBjaGlsZCBhbmQgaXRzIHBhcmVudC5cbiAqL1xuZnVuY3Rpb24gY2FsY0N1dFZhbHVlKHQsIGcsIGNoaWxkKSB7XG4gIHZhciBjaGlsZExhYiA9IHQubm9kZShjaGlsZCk7XG4gIHZhciBwYXJlbnQgPSBjaGlsZExhYi5wYXJlbnQ7XG4gIC8vIFRydWUgaWYgdGhlIGNoaWxkIGlzIG9uIHRoZSB0YWlsIGVuZCBvZiB0aGUgZWRnZSBpbiB0aGUgZGlyZWN0ZWQgZ3JhcGhcbiAgdmFyIGNoaWxkSXNUYWlsID0gdHJ1ZTtcbiAgLy8gVGhlIGdyYXBoJ3MgdmlldyBvZiB0aGUgdHJlZSBlZGdlIHdlJ3JlIGluc3BlY3RpbmdcbiAgdmFyIGdyYXBoRWRnZSA9IGcuZWRnZShjaGlsZCwgcGFyZW50KTtcbiAgLy8gVGhlIGFjY3VtdWxhdGVkIGN1dCB2YWx1ZSBmb3IgdGhlIGVkZ2UgYmV0d2VlbiB0aGlzIG5vZGUgYW5kIGl0cyBwYXJlbnRcbiAgdmFyIGN1dFZhbHVlID0gMDtcblxuICBpZiAoIWdyYXBoRWRnZSkge1xuICAgIGNoaWxkSXNUYWlsID0gZmFsc2U7XG4gICAgZ3JhcGhFZGdlID0gZy5lZGdlKHBhcmVudCwgY2hpbGQpO1xuICB9XG5cbiAgY3V0VmFsdWUgPSBncmFwaEVkZ2Uud2VpZ2h0O1xuXG4gIF8uZm9yRWFjaChnLm5vZGVFZGdlcyhjaGlsZCksIGZ1bmN0aW9uKGUpIHtcbiAgICB2YXIgaXNPdXRFZGdlID0gZS52ID09PSBjaGlsZCxcbiAgICAgIG90aGVyID0gaXNPdXRFZGdlID8gZS53IDogZS52O1xuXG4gICAgaWYgKG90aGVyICE9PSBwYXJlbnQpIHtcbiAgICAgIHZhciBwb2ludHNUb0hlYWQgPSBpc091dEVkZ2UgPT09IGNoaWxkSXNUYWlsLFxuICAgICAgICBvdGhlcldlaWdodCA9IGcuZWRnZShlKS53ZWlnaHQ7XG5cbiAgICAgIGN1dFZhbHVlICs9IHBvaW50c1RvSGVhZCA/IG90aGVyV2VpZ2h0IDogLW90aGVyV2VpZ2h0O1xuICAgICAgaWYgKGlzVHJlZUVkZ2UodCwgY2hpbGQsIG90aGVyKSkge1xuICAgICAgICB2YXIgb3RoZXJDdXRWYWx1ZSA9IHQuZWRnZShjaGlsZCwgb3RoZXIpLmN1dHZhbHVlO1xuICAgICAgICBjdXRWYWx1ZSArPSBwb2ludHNUb0hlYWQgPyAtb3RoZXJDdXRWYWx1ZSA6IG90aGVyQ3V0VmFsdWU7XG4gICAgICB9XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gY3V0VmFsdWU7XG59XG5cbmZ1bmN0aW9uIGluaXRMb3dMaW1WYWx1ZXModHJlZSwgcm9vdCkge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDIpIHtcbiAgICByb290ID0gdHJlZS5ub2RlcygpWzBdO1xuICB9XG4gIGRmc0Fzc2lnbkxvd0xpbSh0cmVlLCB7fSwgMSwgcm9vdCk7XG59XG5cbmZ1bmN0aW9uIGRmc0Fzc2lnbkxvd0xpbSh0cmVlLCB2aXNpdGVkLCBuZXh0TGltLCB2LCBwYXJlbnQpIHtcbiAgdmFyIGxvdyA9IG5leHRMaW07XG4gIHZhciBsYWJlbCA9IHRyZWUubm9kZSh2KTtcblxuICB2aXNpdGVkW3ZdID0gdHJ1ZTtcbiAgXy5mb3JFYWNoKHRyZWUubmVpZ2hib3JzKHYpLCBmdW5jdGlvbih3KSB7XG4gICAgaWYgKCFfLmhhcyh2aXNpdGVkLCB3KSkge1xuICAgICAgbmV4dExpbSA9IGRmc0Fzc2lnbkxvd0xpbSh0cmVlLCB2aXNpdGVkLCBuZXh0TGltLCB3LCB2KTtcbiAgICB9XG4gIH0pO1xuXG4gIGxhYmVsLmxvdyA9IGxvdztcbiAgbGFiZWwubGltID0gbmV4dExpbSsrO1xuICBpZiAocGFyZW50KSB7XG4gICAgbGFiZWwucGFyZW50ID0gcGFyZW50O1xuICB9IGVsc2Uge1xuICAgIC8vIFRPRE8gc2hvdWxkIGJlIGFibGUgdG8gcmVtb3ZlIHRoaXMgd2hlbiB3ZSBpbmNyZW1lbnRhbGx5IHVwZGF0ZSBsb3cgbGltXG4gICAgZGVsZXRlIGxhYmVsLnBhcmVudDtcbiAgfVxuXG4gIHJldHVybiBuZXh0TGltO1xufVxuXG5mdW5jdGlvbiBsZWF2ZUVkZ2UodHJlZSkge1xuICByZXR1cm4gXy5maW5kKHRyZWUuZWRnZXMoKSwgZnVuY3Rpb24oZSkge1xuICAgIHJldHVybiB0cmVlLmVkZ2UoZSkuY3V0dmFsdWUgPCAwO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gZW50ZXJFZGdlKHQsIGcsIGVkZ2UpIHtcbiAgdmFyIHYgPSBlZGdlLnY7XG4gIHZhciB3ID0gZWRnZS53O1xuXG4gIC8vIEZvciB0aGUgcmVzdCBvZiB0aGlzIGZ1bmN0aW9uIHdlIGFzc3VtZSB0aGF0IHYgaXMgdGhlIHRhaWwgYW5kIHcgaXMgdGhlXG4gIC8vIGhlYWQsIHNvIGlmIHdlIGRvbid0IGhhdmUgdGhpcyBlZGdlIGluIHRoZSBncmFwaCB3ZSBzaG91bGQgZmxpcCBpdCB0b1xuICAvLyBtYXRjaCB0aGUgY29ycmVjdCBvcmllbnRhdGlvbi5cbiAgaWYgKCFnLmhhc0VkZ2UodiwgdykpIHtcbiAgICB2ID0gZWRnZS53O1xuICAgIHcgPSBlZGdlLnY7XG4gIH1cblxuICB2YXIgdkxhYmVsID0gdC5ub2RlKHYpO1xuICB2YXIgd0xhYmVsID0gdC5ub2RlKHcpO1xuICB2YXIgdGFpbExhYmVsID0gdkxhYmVsO1xuICB2YXIgZmxpcCA9IGZhbHNlO1xuXG4gIC8vIElmIHRoZSByb290IGlzIGluIHRoZSB0YWlsIG9mIHRoZSBlZGdlIHRoZW4gd2UgbmVlZCB0byBmbGlwIHRoZSBsb2dpYyB0aGF0XG4gIC8vIGNoZWNrcyBmb3IgdGhlIGhlYWQgYW5kIHRhaWwgbm9kZXMgaW4gdGhlIGNhbmRpZGF0ZXMgZnVuY3Rpb24gYmVsb3cuXG4gIGlmICh2TGFiZWwubGltID4gd0xhYmVsLmxpbSkge1xuICAgIHRhaWxMYWJlbCA9IHdMYWJlbDtcbiAgICBmbGlwID0gdHJ1ZTtcbiAgfVxuXG4gIHZhciBjYW5kaWRhdGVzID0gXy5maWx0ZXIoZy5lZGdlcygpLCBmdW5jdGlvbihlZGdlKSB7XG4gICAgcmV0dXJuIGZsaXAgPT09IGlzRGVzY2VuZGFudCh0LCB0Lm5vZGUoZWRnZS52KSwgdGFpbExhYmVsKSAmJlxuICAgICAgICAgICBmbGlwICE9PSBpc0Rlc2NlbmRhbnQodCwgdC5ub2RlKGVkZ2UudyksIHRhaWxMYWJlbCk7XG4gIH0pO1xuXG4gIHJldHVybiBfLm1pbkJ5KGNhbmRpZGF0ZXMsIGZ1bmN0aW9uKGVkZ2UpIHsgcmV0dXJuIHNsYWNrKGcsIGVkZ2UpOyB9KTtcbn1cblxuZnVuY3Rpb24gZXhjaGFuZ2VFZGdlcyh0LCBnLCBlLCBmKSB7XG4gIHZhciB2ID0gZS52O1xuICB2YXIgdyA9IGUudztcbiAgdC5yZW1vdmVFZGdlKHYsIHcpO1xuICB0LnNldEVkZ2UoZi52LCBmLncsIHt9KTtcbiAgaW5pdExvd0xpbVZhbHVlcyh0KTtcbiAgaW5pdEN1dFZhbHVlcyh0LCBnKTtcbiAgdXBkYXRlUmFua3ModCwgZyk7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZVJhbmtzKHQsIGcpIHtcbiAgdmFyIHJvb3QgPSBfLmZpbmQodC5ub2RlcygpLCBmdW5jdGlvbih2KSB7IHJldHVybiAhZy5ub2RlKHYpLnBhcmVudDsgfSk7XG4gIHZhciB2cyA9IHByZW9yZGVyKHQsIHJvb3QpO1xuICB2cyA9IHZzLnNsaWNlKDEpO1xuICBfLmZvckVhY2godnMsIGZ1bmN0aW9uKHYpIHtcbiAgICB2YXIgcGFyZW50ID0gdC5ub2RlKHYpLnBhcmVudCxcbiAgICAgIGVkZ2UgPSBnLmVkZ2UodiwgcGFyZW50KSxcbiAgICAgIGZsaXBwZWQgPSBmYWxzZTtcblxuICAgIGlmICghZWRnZSkge1xuICAgICAgZWRnZSA9IGcuZWRnZShwYXJlbnQsIHYpO1xuICAgICAgZmxpcHBlZCA9IHRydWU7XG4gICAgfVxuXG4gICAgZy5ub2RlKHYpLnJhbmsgPSBnLm5vZGUocGFyZW50KS5yYW5rICsgKGZsaXBwZWQgPyBlZGdlLm1pbmxlbiA6IC1lZGdlLm1pbmxlbik7XG4gIH0pO1xufVxuXG4vKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSBlZGdlIGlzIGluIHRoZSB0cmVlLlxuICovXG5mdW5jdGlvbiBpc1RyZWVFZGdlKHRyZWUsIHUsIHYpIHtcbiAgcmV0dXJuIHRyZWUuaGFzRWRnZSh1LCB2KTtcbn1cblxuLypcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgc3BlY2lmaWVkIG5vZGUgaXMgZGVzY2VuZGFudCBvZiB0aGUgcm9vdCBub2RlIHBlciB0aGVcbiAqIGFzc2lnbmVkIGxvdyBhbmQgbGltIGF0dHJpYnV0ZXMgaW4gdGhlIHRyZWUuXG4gKi9cbmZ1bmN0aW9uIGlzRGVzY2VuZGFudCh0cmVlLCB2TGFiZWwsIHJvb3RMYWJlbCkge1xuICByZXR1cm4gcm9vdExhYmVsLmxvdyA8PSB2TGFiZWwubGltICYmIHZMYWJlbC5saW0gPD0gcm9vdExhYmVsLmxpbTtcbn1cbiIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgXyA9IHJlcXVpcmUoXCIuLi9sb2Rhc2hcIik7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBsb25nZXN0UGF0aDogbG9uZ2VzdFBhdGgsXG4gIHNsYWNrOiBzbGFja1xufTtcblxuLypcbiAqIEluaXRpYWxpemVzIHJhbmtzIGZvciB0aGUgaW5wdXQgZ3JhcGggdXNpbmcgdGhlIGxvbmdlc3QgcGF0aCBhbGdvcml0aG0uIFRoaXNcbiAqIGFsZ29yaXRobSBzY2FsZXMgd2VsbCBhbmQgaXMgZmFzdCBpbiBwcmFjdGljZSwgaXQgeWllbGRzIHJhdGhlciBwb29yXG4gKiBzb2x1dGlvbnMuIE5vZGVzIGFyZSBwdXNoZWQgdG8gdGhlIGxvd2VzdCBsYXllciBwb3NzaWJsZSwgbGVhdmluZyB0aGUgYm90dG9tXG4gKiByYW5rcyB3aWRlIGFuZCBsZWF2aW5nIGVkZ2VzIGxvbmdlciB0aGFuIG5lY2Vzc2FyeS4gSG93ZXZlciwgZHVlIHRvIGl0c1xuICogc3BlZWQsIHRoaXMgYWxnb3JpdGhtIGlzIGdvb2QgZm9yIGdldHRpbmcgYW4gaW5pdGlhbCByYW5raW5nIHRoYXQgY2FuIGJlIGZlZFxuICogaW50byBvdGhlciBhbGdvcml0aG1zLlxuICpcbiAqIFRoaXMgYWxnb3JpdGhtIGRvZXMgbm90IG5vcm1hbGl6ZSBsYXllcnMgYmVjYXVzZSBpdCB3aWxsIGJlIHVzZWQgYnkgb3RoZXJcbiAqIGFsZ29yaXRobXMgaW4gbW9zdCBjYXNlcy4gSWYgdXNpbmcgdGhpcyBhbGdvcml0aG0gZGlyZWN0bHksIGJlIHN1cmUgdG9cbiAqIHJ1biBub3JtYWxpemUgYXQgdGhlIGVuZC5cbiAqXG4gKiBQcmUtY29uZGl0aW9uczpcbiAqXG4gKiAgICAxLiBJbnB1dCBncmFwaCBpcyBhIERBRy5cbiAqICAgIDIuIElucHV0IGdyYXBoIG5vZGUgbGFiZWxzIGNhbiBiZSBhc3NpZ25lZCBwcm9wZXJ0aWVzLlxuICpcbiAqIFBvc3QtY29uZGl0aW9uczpcbiAqXG4gKiAgICAxLiBFYWNoIG5vZGUgd2lsbCBiZSBhc3NpZ24gYW4gKHVubm9ybWFsaXplZCkgXCJyYW5rXCIgcHJvcGVydHkuXG4gKi9cbmZ1bmN0aW9uIGxvbmdlc3RQYXRoKGcpIHtcbiAgdmFyIHZpc2l0ZWQgPSB7fTtcblxuICBmdW5jdGlvbiBkZnModikge1xuICAgIHZhciBsYWJlbCA9IGcubm9kZSh2KTtcbiAgICBpZiAoXy5oYXModmlzaXRlZCwgdikpIHtcbiAgICAgIHJldHVybiBsYWJlbC5yYW5rO1xuICAgIH1cbiAgICB2aXNpdGVkW3ZdID0gdHJ1ZTtcblxuICAgIHZhciByYW5rID0gXy5taW4oXy5tYXAoZy5vdXRFZGdlcyh2KSwgZnVuY3Rpb24oZSkge1xuICAgICAgcmV0dXJuIGRmcyhlLncpIC0gZy5lZGdlKGUpLm1pbmxlbjtcbiAgICB9KSk7XG5cbiAgICBpZiAocmFuayA9PT0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZIHx8IC8vIHJldHVybiB2YWx1ZSBvZiBfLm1hcChbXSkgZm9yIExvZGFzaCAzXG4gICAgICAgIHJhbmsgPT09IHVuZGVmaW5lZCB8fCAvLyByZXR1cm4gdmFsdWUgb2YgXy5tYXAoW10pIGZvciBMb2Rhc2ggNFxuICAgICAgICByYW5rID09PSBudWxsKSB7IC8vIHJldHVybiB2YWx1ZSBvZiBfLm1hcChbbnVsbF0pXG4gICAgICByYW5rID0gMDtcbiAgICB9XG5cbiAgICByZXR1cm4gKGxhYmVsLnJhbmsgPSByYW5rKTtcbiAgfVxuXG4gIF8uZm9yRWFjaChnLnNvdXJjZXMoKSwgZGZzKTtcbn1cblxuLypcbiAqIFJldHVybnMgdGhlIGFtb3VudCBvZiBzbGFjayBmb3IgdGhlIGdpdmVuIGVkZ2UuIFRoZSBzbGFjayBpcyBkZWZpbmVkIGFzIHRoZVxuICogZGlmZmVyZW5jZSBiZXR3ZWVuIHRoZSBsZW5ndGggb2YgdGhlIGVkZ2UgYW5kIGl0cyBtaW5pbXVtIGxlbmd0aC5cbiAqL1xuZnVuY3Rpb24gc2xhY2soZywgZSkge1xuICByZXR1cm4gZy5ub2RlKGUudykucmFuayAtIGcubm9kZShlLnYpLnJhbmsgLSBnLmVkZ2UoZSkubWlubGVuO1xufVxuIiwiLyogZXNsaW50IFwibm8tY29uc29sZVwiOiBvZmYgKi9cblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfID0gcmVxdWlyZShcIi4vbG9kYXNoXCIpO1xudmFyIEdyYXBoID0gcmVxdWlyZShcIi4vZ3JhcGhsaWJcIikuR3JhcGg7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBhZGREdW1teU5vZGU6IGFkZER1bW15Tm9kZSxcbiAgc2ltcGxpZnk6IHNpbXBsaWZ5LFxuICBhc05vbkNvbXBvdW5kR3JhcGg6IGFzTm9uQ29tcG91bmRHcmFwaCxcbiAgc3VjY2Vzc29yV2VpZ2h0czogc3VjY2Vzc29yV2VpZ2h0cyxcbiAgcHJlZGVjZXNzb3JXZWlnaHRzOiBwcmVkZWNlc3NvcldlaWdodHMsXG4gIGludGVyc2VjdFJlY3Q6IGludGVyc2VjdFJlY3QsXG4gIGJ1aWxkTGF5ZXJNYXRyaXg6IGJ1aWxkTGF5ZXJNYXRyaXgsXG4gIG5vcm1hbGl6ZVJhbmtzOiBub3JtYWxpemVSYW5rcyxcbiAgcmVtb3ZlRW1wdHlSYW5rczogcmVtb3ZlRW1wdHlSYW5rcyxcbiAgYWRkQm9yZGVyTm9kZTogYWRkQm9yZGVyTm9kZSxcbiAgbWF4UmFuazogbWF4UmFuayxcbiAgcGFydGl0aW9uOiBwYXJ0aXRpb24sXG4gIHRpbWU6IHRpbWUsXG4gIG5vdGltZTogbm90aW1lXG59O1xuXG4vKlxuICogQWRkcyBhIGR1bW15IG5vZGUgdG8gdGhlIGdyYXBoIGFuZCByZXR1cm4gdi5cbiAqL1xuZnVuY3Rpb24gYWRkRHVtbXlOb2RlKGcsIHR5cGUsIGF0dHJzLCBuYW1lKSB7XG4gIHZhciB2O1xuICBkbyB7XG4gICAgdiA9IF8udW5pcXVlSWQobmFtZSk7XG4gIH0gd2hpbGUgKGcuaGFzTm9kZSh2KSk7XG5cbiAgYXR0cnMuZHVtbXkgPSB0eXBlO1xuICBnLnNldE5vZGUodiwgYXR0cnMpO1xuICByZXR1cm4gdjtcbn1cblxuLypcbiAqIFJldHVybnMgYSBuZXcgZ3JhcGggd2l0aCBvbmx5IHNpbXBsZSBlZGdlcy4gSGFuZGxlcyBhZ2dyZWdhdGlvbiBvZiBkYXRhXG4gKiBhc3NvY2lhdGVkIHdpdGggbXVsdGktZWRnZXMuXG4gKi9cbmZ1bmN0aW9uIHNpbXBsaWZ5KGcpIHtcbiAgdmFyIHNpbXBsaWZpZWQgPSBuZXcgR3JhcGgoKS5zZXRHcmFwaChnLmdyYXBoKCkpO1xuICBfLmZvckVhY2goZy5ub2RlcygpLCBmdW5jdGlvbih2KSB7IHNpbXBsaWZpZWQuc2V0Tm9kZSh2LCBnLm5vZGUodikpOyB9KTtcbiAgXy5mb3JFYWNoKGcuZWRnZXMoKSwgZnVuY3Rpb24oZSkge1xuICAgIHZhciBzaW1wbGVMYWJlbCA9IHNpbXBsaWZpZWQuZWRnZShlLnYsIGUudykgfHwgeyB3ZWlnaHQ6IDAsIG1pbmxlbjogMSB9O1xuICAgIHZhciBsYWJlbCA9IGcuZWRnZShlKTtcbiAgICBzaW1wbGlmaWVkLnNldEVkZ2UoZS52LCBlLncsIHtcbiAgICAgIHdlaWdodDogc2ltcGxlTGFiZWwud2VpZ2h0ICsgbGFiZWwud2VpZ2h0LFxuICAgICAgbWlubGVuOiBNYXRoLm1heChzaW1wbGVMYWJlbC5taW5sZW4sIGxhYmVsLm1pbmxlbilcbiAgICB9KTtcbiAgfSk7XG4gIHJldHVybiBzaW1wbGlmaWVkO1xufVxuXG5mdW5jdGlvbiBhc05vbkNvbXBvdW5kR3JhcGgoZykge1xuICB2YXIgc2ltcGxpZmllZCA9IG5ldyBHcmFwaCh7IG11bHRpZ3JhcGg6IGcuaXNNdWx0aWdyYXBoKCkgfSkuc2V0R3JhcGgoZy5ncmFwaCgpKTtcbiAgXy5mb3JFYWNoKGcubm9kZXMoKSwgZnVuY3Rpb24odikge1xuICAgIGlmICghZy5jaGlsZHJlbih2KS5sZW5ndGgpIHtcbiAgICAgIHNpbXBsaWZpZWQuc2V0Tm9kZSh2LCBnLm5vZGUodikpO1xuICAgIH1cbiAgfSk7XG4gIF8uZm9yRWFjaChnLmVkZ2VzKCksIGZ1bmN0aW9uKGUpIHtcbiAgICBzaW1wbGlmaWVkLnNldEVkZ2UoZSwgZy5lZGdlKGUpKTtcbiAgfSk7XG4gIHJldHVybiBzaW1wbGlmaWVkO1xufVxuXG5mdW5jdGlvbiBzdWNjZXNzb3JXZWlnaHRzKGcpIHtcbiAgdmFyIHdlaWdodE1hcCA9IF8ubWFwKGcubm9kZXMoKSwgZnVuY3Rpb24odikge1xuICAgIHZhciBzdWNzID0ge307XG4gICAgXy5mb3JFYWNoKGcub3V0RWRnZXModiksIGZ1bmN0aW9uKGUpIHtcbiAgICAgIHN1Y3NbZS53XSA9IChzdWNzW2Uud10gfHwgMCkgKyBnLmVkZ2UoZSkud2VpZ2h0O1xuICAgIH0pO1xuICAgIHJldHVybiBzdWNzO1xuICB9KTtcbiAgcmV0dXJuIF8uemlwT2JqZWN0KGcubm9kZXMoKSwgd2VpZ2h0TWFwKTtcbn1cblxuZnVuY3Rpb24gcHJlZGVjZXNzb3JXZWlnaHRzKGcpIHtcbiAgdmFyIHdlaWdodE1hcCA9IF8ubWFwKGcubm9kZXMoKSwgZnVuY3Rpb24odikge1xuICAgIHZhciBwcmVkcyA9IHt9O1xuICAgIF8uZm9yRWFjaChnLmluRWRnZXModiksIGZ1bmN0aW9uKGUpIHtcbiAgICAgIHByZWRzW2Uudl0gPSAocHJlZHNbZS52XSB8fCAwKSArIGcuZWRnZShlKS53ZWlnaHQ7XG4gICAgfSk7XG4gICAgcmV0dXJuIHByZWRzO1xuICB9KTtcbiAgcmV0dXJuIF8uemlwT2JqZWN0KGcubm9kZXMoKSwgd2VpZ2h0TWFwKTtcbn1cblxuLypcbiAqIEZpbmRzIHdoZXJlIGEgbGluZSBzdGFydGluZyBhdCBwb2ludCAoe3gsIHl9KSB3b3VsZCBpbnRlcnNlY3QgYSByZWN0YW5nbGVcbiAqICh7eCwgeSwgd2lkdGgsIGhlaWdodH0pIGlmIGl0IHdlcmUgcG9pbnRpbmcgYXQgdGhlIHJlY3RhbmdsZSdzIGNlbnRlci5cbiAqL1xuZnVuY3Rpb24gaW50ZXJzZWN0UmVjdChyZWN0LCBwb2ludCkge1xuICB2YXIgeCA9IHJlY3QueDtcbiAgdmFyIHkgPSByZWN0Lnk7XG5cbiAgLy8gUmVjdGFuZ2xlIGludGVyc2VjdGlvbiBhbGdvcml0aG0gZnJvbTpcbiAgLy8gaHR0cDovL21hdGguc3RhY2tleGNoYW5nZS5jb20vcXVlc3Rpb25zLzEwODExMy9maW5kLWVkZ2UtYmV0d2Vlbi10d28tYm94ZXNcbiAgdmFyIGR4ID0gcG9pbnQueCAtIHg7XG4gIHZhciBkeSA9IHBvaW50LnkgLSB5O1xuICB2YXIgdyA9IHJlY3Qud2lkdGggLyAyO1xuICB2YXIgaCA9IHJlY3QuaGVpZ2h0IC8gMjtcblxuICBpZiAoIWR4ICYmICFkeSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIk5vdCBwb3NzaWJsZSB0byBmaW5kIGludGVyc2VjdGlvbiBpbnNpZGUgb2YgdGhlIHJlY3RhbmdsZVwiKTtcbiAgfVxuXG4gIHZhciBzeCwgc3k7XG4gIGlmIChNYXRoLmFicyhkeSkgKiB3ID4gTWF0aC5hYnMoZHgpICogaCkge1xuICAgIC8vIEludGVyc2VjdGlvbiBpcyB0b3Agb3IgYm90dG9tIG9mIHJlY3QuXG4gICAgaWYgKGR5IDwgMCkge1xuICAgICAgaCA9IC1oO1xuICAgIH1cbiAgICBzeCA9IGggKiBkeCAvIGR5O1xuICAgIHN5ID0gaDtcbiAgfSBlbHNlIHtcbiAgICAvLyBJbnRlcnNlY3Rpb24gaXMgbGVmdCBvciByaWdodCBvZiByZWN0LlxuICAgIGlmIChkeCA8IDApIHtcbiAgICAgIHcgPSAtdztcbiAgICB9XG4gICAgc3ggPSB3O1xuICAgIHN5ID0gdyAqIGR5IC8gZHg7XG4gIH1cblxuICByZXR1cm4geyB4OiB4ICsgc3gsIHk6IHkgKyBzeSB9O1xufVxuXG4vKlxuICogR2l2ZW4gYSBEQUcgd2l0aCBlYWNoIG5vZGUgYXNzaWduZWQgXCJyYW5rXCIgYW5kIFwib3JkZXJcIiBwcm9wZXJ0aWVzLCB0aGlzXG4gKiBmdW5jdGlvbiB3aWxsIHByb2R1Y2UgYSBtYXRyaXggd2l0aCB0aGUgaWRzIG9mIGVhY2ggbm9kZS5cbiAqL1xuZnVuY3Rpb24gYnVpbGRMYXllck1hdHJpeChnKSB7XG4gIHZhciBsYXllcmluZyA9IF8ubWFwKF8ucmFuZ2UobWF4UmFuayhnKSArIDEpLCBmdW5jdGlvbigpIHsgcmV0dXJuIFtdOyB9KTtcbiAgXy5mb3JFYWNoKGcubm9kZXMoKSwgZnVuY3Rpb24odikge1xuICAgIHZhciBub2RlID0gZy5ub2RlKHYpO1xuICAgIHZhciByYW5rID0gbm9kZS5yYW5rO1xuICAgIGlmICghXy5pc1VuZGVmaW5lZChyYW5rKSkge1xuICAgICAgbGF5ZXJpbmdbcmFua11bbm9kZS5vcmRlcl0gPSB2O1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBsYXllcmluZztcbn1cblxuLypcbiAqIEFkanVzdHMgdGhlIHJhbmtzIGZvciBhbGwgbm9kZXMgaW4gdGhlIGdyYXBoIHN1Y2ggdGhhdCBhbGwgbm9kZXMgdiBoYXZlXG4gKiByYW5rKHYpID49IDAgYW5kIGF0IGxlYXN0IG9uZSBub2RlIHcgaGFzIHJhbmsodykgPSAwLlxuICovXG5mdW5jdGlvbiBub3JtYWxpemVSYW5rcyhnKSB7XG4gIHZhciBtaW4gPSBfLm1pbihfLm1hcChnLm5vZGVzKCksIGZ1bmN0aW9uKHYpIHsgcmV0dXJuIGcubm9kZSh2KS5yYW5rOyB9KSk7XG4gIF8uZm9yRWFjaChnLm5vZGVzKCksIGZ1bmN0aW9uKHYpIHtcbiAgICB2YXIgbm9kZSA9IGcubm9kZSh2KTtcbiAgICBpZiAoXy5oYXMobm9kZSwgXCJyYW5rXCIpKSB7XG4gICAgICBub2RlLnJhbmsgLT0gbWluO1xuICAgIH1cbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHJlbW92ZUVtcHR5UmFua3MoZykge1xuICAvLyBSYW5rcyBtYXkgbm90IHN0YXJ0IGF0IDAsIHNvIHdlIG5lZWQgdG8gb2Zmc2V0IHRoZW1cbiAgdmFyIG9mZnNldCA9IF8ubWluKF8ubWFwKGcubm9kZXMoKSwgZnVuY3Rpb24odikgeyByZXR1cm4gZy5ub2RlKHYpLnJhbms7IH0pKTtcblxuICB2YXIgbGF5ZXJzID0gW107XG4gIF8uZm9yRWFjaChnLm5vZGVzKCksIGZ1bmN0aW9uKHYpIHtcbiAgICB2YXIgcmFuayA9IGcubm9kZSh2KS5yYW5rIC0gb2Zmc2V0O1xuICAgIGlmICghbGF5ZXJzW3JhbmtdKSB7XG4gICAgICBsYXllcnNbcmFua10gPSBbXTtcbiAgICB9XG4gICAgbGF5ZXJzW3JhbmtdLnB1c2godik7XG4gIH0pO1xuXG4gIHZhciBkZWx0YSA9IDA7XG4gIHZhciBub2RlUmFua0ZhY3RvciA9IGcuZ3JhcGgoKS5ub2RlUmFua0ZhY3RvcjtcbiAgXy5mb3JFYWNoKGxheWVycywgZnVuY3Rpb24odnMsIGkpIHtcbiAgICBpZiAoXy5pc1VuZGVmaW5lZCh2cykgJiYgaSAlIG5vZGVSYW5rRmFjdG9yICE9PSAwKSB7XG4gICAgICAtLWRlbHRhO1xuICAgIH0gZWxzZSBpZiAoZGVsdGEpIHtcbiAgICAgIF8uZm9yRWFjaCh2cywgZnVuY3Rpb24odikgeyBnLm5vZGUodikucmFuayArPSBkZWx0YTsgfSk7XG4gICAgfVxuICB9KTtcbn1cblxuZnVuY3Rpb24gYWRkQm9yZGVyTm9kZShnLCBwcmVmaXgsIHJhbmssIG9yZGVyKSB7XG4gIHZhciBub2RlID0ge1xuICAgIHdpZHRoOiAwLFxuICAgIGhlaWdodDogMFxuICB9O1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+PSA0KSB7XG4gICAgbm9kZS5yYW5rID0gcmFuaztcbiAgICBub2RlLm9yZGVyID0gb3JkZXI7XG4gIH1cbiAgcmV0dXJuIGFkZER1bW15Tm9kZShnLCBcImJvcmRlclwiLCBub2RlLCBwcmVmaXgpO1xufVxuXG5mdW5jdGlvbiBtYXhSYW5rKGcpIHtcbiAgcmV0dXJuIF8ubWF4KF8ubWFwKGcubm9kZXMoKSwgZnVuY3Rpb24odikge1xuICAgIHZhciByYW5rID0gZy5ub2RlKHYpLnJhbms7XG4gICAgaWYgKCFfLmlzVW5kZWZpbmVkKHJhbmspKSB7XG4gICAgICByZXR1cm4gcmFuaztcbiAgICB9XG4gIH0pKTtcbn1cblxuLypcbiAqIFBhcnRpdGlvbiBhIGNvbGxlY3Rpb24gaW50byB0d28gZ3JvdXBzOiBgbGhzYCBhbmQgYHJoc2AuIElmIHRoZSBzdXBwbGllZFxuICogZnVuY3Rpb24gcmV0dXJucyB0cnVlIGZvciBhbiBlbnRyeSBpdCBnb2VzIGludG8gYGxoc2AuIE90aGVyd2lzZSBpdCBnb2VzXG4gKiBpbnRvIGByaHMuXG4gKi9cbmZ1bmN0aW9uIHBhcnRpdGlvbihjb2xsZWN0aW9uLCBmbikge1xuICB2YXIgcmVzdWx0ID0geyBsaHM6IFtdLCByaHM6IFtdIH07XG4gIF8uZm9yRWFjaChjb2xsZWN0aW9uLCBmdW5jdGlvbih2YWx1ZSkge1xuICAgIGlmIChmbih2YWx1ZSkpIHtcbiAgICAgIHJlc3VsdC5saHMucHVzaCh2YWx1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdC5yaHMucHVzaCh2YWx1ZSk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLypcbiAqIFJldHVybnMgYSBuZXcgZnVuY3Rpb24gdGhhdCB3cmFwcyBgZm5gIHdpdGggYSB0aW1lci4gVGhlIHdyYXBwZXIgbG9ncyB0aGVcbiAqIHRpbWUgaXQgdGFrZXMgdG8gZXhlY3V0ZSB0aGUgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIHRpbWUobmFtZSwgZm4pIHtcbiAgdmFyIHN0YXJ0ID0gXy5ub3coKTtcbiAgdHJ5IHtcbiAgICByZXR1cm4gZm4oKTtcbiAgfSBmaW5hbGx5IHtcbiAgICBjb25zb2xlLmxvZyhuYW1lICsgXCIgdGltZTogXCIgKyAoXy5ub3coKSAtIHN0YXJ0KSArIFwibXNcIik7XG4gIH1cbn1cblxuZnVuY3Rpb24gbm90aW1lKG5hbWUsIGZuKSB7XG4gIHJldHVybiBmbigpO1xufVxuIiwibW9kdWxlLmV4cG9ydHMgPSBcIjAuOC41XCI7XG4iLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxNCwgQ2hyaXMgUGV0dGl0dFxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRoIG9yIHdpdGhvdXRcbiAqIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgY29uZGl0aW9ucyBhcmUgbWV0OlxuICpcbiAqIDEuIFJlZGlzdHJpYnV0aW9ucyBvZiBzb3VyY2UgY29kZSBtdXN0IHJldGFpbiB0aGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSwgdGhpc1xuICogbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIuXG4gKlxuICogMi4gUmVkaXN0cmlidXRpb25zIGluIGJpbmFyeSBmb3JtIG11c3QgcmVwcm9kdWNlIHRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlLFxuICogdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lciBpbiB0aGUgZG9jdW1lbnRhdGlvblxuICogYW5kL29yIG90aGVyIG1hdGVyaWFscyBwcm92aWRlZCB3aXRoIHRoZSBkaXN0cmlidXRpb24uXG4gKlxuICogMy4gTmVpdGhlciB0aGUgbmFtZSBvZiB0aGUgY29weXJpZ2h0IGhvbGRlciBub3IgdGhlIG5hbWVzIG9mIGl0cyBjb250cmlidXRvcnNcbiAqIG1heSBiZSB1c2VkIHRvIGVuZG9yc2Ugb3IgcHJvbW90ZSBwcm9kdWN0cyBkZXJpdmVkIGZyb20gdGhpcyBzb2Z0d2FyZSB3aXRob3V0XG4gKiBzcGVjaWZpYyBwcmlvciB3cml0dGVuIHBlcm1pc3Npb24uXG4gKlxuICogVEhJUyBTT0ZUV0FSRSBJUyBQUk9WSURFRCBCWSBUSEUgQ09QWVJJR0hUIEhPTERFUlMgQU5EIENPTlRSSUJVVE9SUyBcIkFTIElTXCIgQU5EXG4gKiBBTlkgRVhQUkVTUyBPUiBJTVBMSUVEIFdBUlJBTlRJRVMsIElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBUSEUgSU1QTElFRFxuICogV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFSRVxuICogRElTQ0xBSU1FRC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIENPUFlSSUdIVCBIT0xERVIgT1IgQ09OVFJJQlVUT1JTIEJFIExJQUJMRVxuICogRk9SIEFOWSBESVJFQ1QsIElORElSRUNULCBJTkNJREVOVEFMLCBTUEVDSUFMLCBFWEVNUExBUlksIE9SIENPTlNFUVVFTlRJQUxcbiAqIERBTUFHRVMgKElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBQUk9DVVJFTUVOVCBPRiBTVUJTVElUVVRFIEdPT0RTIE9SXG4gKiBTRVJWSUNFUzsgTE9TUyBPRiBVU0UsIERBVEEsIE9SIFBST0ZJVFM7IE9SIEJVU0lORVNTIElOVEVSUlVQVElPTikgSE9XRVZFUlxuICogQ0FVU0VEIEFORCBPTiBBTlkgVEhFT1JZIE9GIExJQUJJTElUWSwgV0hFVEhFUiBJTiBDT05UUkFDVCwgU1RSSUNUIExJQUJJTElUWSxcbiAqIE9SIFRPUlQgKElOQ0xVRElORyBORUdMSUdFTkNFIE9SIE9USEVSV0lTRSkgQVJJU0lORyBJTiBBTlkgV0FZIE9VVCBPRiBUSEUgVVNFXG4gKiBPRiBUSElTIFNPRlRXQVJFLCBFVkVOIElGIEFEVklTRUQgT0YgVEhFIFBPU1NJQklMSVRZIE9GIFNVQ0ggREFNQUdFLlxuICovXG5cbnZhciBsaWIgPSByZXF1aXJlKFwiLi9saWJcIik7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBHcmFwaDogbGliLkdyYXBoLFxuICBqc29uOiByZXF1aXJlKFwiLi9saWIvanNvblwiKSxcbiAgYWxnOiByZXF1aXJlKFwiLi9saWIvYWxnXCIpLFxuICB2ZXJzaW9uOiBsaWIudmVyc2lvblxufTtcbiIsInZhciBfID0gcmVxdWlyZShcIi4uL2xvZGFzaFwiKTtcblxubW9kdWxlLmV4cG9ydHMgPSBjb21wb25lbnRzO1xuXG5mdW5jdGlvbiBjb21wb25lbnRzKGcpIHtcbiAgdmFyIHZpc2l0ZWQgPSB7fTtcbiAgdmFyIGNtcHRzID0gW107XG4gIHZhciBjbXB0O1xuXG4gIGZ1bmN0aW9uIGRmcyh2KSB7XG4gICAgaWYgKF8uaGFzKHZpc2l0ZWQsIHYpKSByZXR1cm47XG4gICAgdmlzaXRlZFt2XSA9IHRydWU7XG4gICAgY21wdC5wdXNoKHYpO1xuICAgIF8uZWFjaChnLnN1Y2Nlc3NvcnModiksIGRmcyk7XG4gICAgXy5lYWNoKGcucHJlZGVjZXNzb3JzKHYpLCBkZnMpO1xuICB9XG5cbiAgXy5lYWNoKGcubm9kZXMoKSwgZnVuY3Rpb24odikge1xuICAgIGNtcHQgPSBbXTtcbiAgICBkZnModik7XG4gICAgaWYgKGNtcHQubGVuZ3RoKSB7XG4gICAgICBjbXB0cy5wdXNoKGNtcHQpO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIGNtcHRzO1xufVxuIiwidmFyIF8gPSByZXF1aXJlKFwiLi4vbG9kYXNoXCIpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGRmcztcblxuLypcbiAqIEEgaGVscGVyIHRoYXQgcHJlZm9ybXMgYSBwcmUtIG9yIHBvc3Qtb3JkZXIgdHJhdmVyc2FsIG9uIHRoZSBpbnB1dCBncmFwaFxuICogYW5kIHJldHVybnMgdGhlIG5vZGVzIGluIHRoZSBvcmRlciB0aGV5IHdlcmUgdmlzaXRlZC4gSWYgdGhlIGdyYXBoIGlzXG4gKiB1bmRpcmVjdGVkIHRoZW4gdGhpcyBhbGdvcml0aG0gd2lsbCBuYXZpZ2F0ZSB1c2luZyBuZWlnaGJvcnMuIElmIHRoZSBncmFwaFxuICogaXMgZGlyZWN0ZWQgdGhlbiB0aGlzIGFsZ29yaXRobSB3aWxsIG5hdmlnYXRlIHVzaW5nIHN1Y2Nlc3NvcnMuXG4gKlxuICogT3JkZXIgbXVzdCBiZSBvbmUgb2YgXCJwcmVcIiBvciBcInBvc3RcIi5cbiAqL1xuZnVuY3Rpb24gZGZzKGcsIHZzLCBvcmRlcikge1xuICBpZiAoIV8uaXNBcnJheSh2cykpIHtcbiAgICB2cyA9IFt2c107XG4gIH1cblxuICB2YXIgbmF2aWdhdGlvbiA9IChnLmlzRGlyZWN0ZWQoKSA/IGcuc3VjY2Vzc29ycyA6IGcubmVpZ2hib3JzKS5iaW5kKGcpO1xuXG4gIHZhciBhY2MgPSBbXTtcbiAgdmFyIHZpc2l0ZWQgPSB7fTtcbiAgXy5lYWNoKHZzLCBmdW5jdGlvbih2KSB7XG4gICAgaWYgKCFnLmhhc05vZGUodikpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkdyYXBoIGRvZXMgbm90IGhhdmUgbm9kZTogXCIgKyB2KTtcbiAgICB9XG5cbiAgICBkb0RmcyhnLCB2LCBvcmRlciA9PT0gXCJwb3N0XCIsIHZpc2l0ZWQsIG5hdmlnYXRpb24sIGFjYyk7XG4gIH0pO1xuICByZXR1cm4gYWNjO1xufVxuXG5mdW5jdGlvbiBkb0RmcyhnLCB2LCBwb3N0b3JkZXIsIHZpc2l0ZWQsIG5hdmlnYXRpb24sIGFjYykge1xuICBpZiAoIV8uaGFzKHZpc2l0ZWQsIHYpKSB7XG4gICAgdmlzaXRlZFt2XSA9IHRydWU7XG5cbiAgICBpZiAoIXBvc3RvcmRlcikgeyBhY2MucHVzaCh2KTsgfVxuICAgIF8uZWFjaChuYXZpZ2F0aW9uKHYpLCBmdW5jdGlvbih3KSB7XG4gICAgICBkb0RmcyhnLCB3LCBwb3N0b3JkZXIsIHZpc2l0ZWQsIG5hdmlnYXRpb24sIGFjYyk7XG4gICAgfSk7XG4gICAgaWYgKHBvc3RvcmRlcikgeyBhY2MucHVzaCh2KTsgfVxuICB9XG59XG4iLCJ2YXIgZGlqa3N0cmEgPSByZXF1aXJlKFwiLi9kaWprc3RyYVwiKTtcbnZhciBfID0gcmVxdWlyZShcIi4uL2xvZGFzaFwiKTtcblxubW9kdWxlLmV4cG9ydHMgPSBkaWprc3RyYUFsbDtcblxuZnVuY3Rpb24gZGlqa3N0cmFBbGwoZywgd2VpZ2h0RnVuYywgZWRnZUZ1bmMpIHtcbiAgcmV0dXJuIF8udHJhbnNmb3JtKGcubm9kZXMoKSwgZnVuY3Rpb24oYWNjLCB2KSB7XG4gICAgYWNjW3ZdID0gZGlqa3N0cmEoZywgdiwgd2VpZ2h0RnVuYywgZWRnZUZ1bmMpO1xuICB9LCB7fSk7XG59XG4iLCJ2YXIgXyA9IHJlcXVpcmUoXCIuLi9sb2Rhc2hcIik7XG52YXIgUHJpb3JpdHlRdWV1ZSA9IHJlcXVpcmUoXCIuLi9kYXRhL3ByaW9yaXR5LXF1ZXVlXCIpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGRpamtzdHJhO1xuXG52YXIgREVGQVVMVF9XRUlHSFRfRlVOQyA9IF8uY29uc3RhbnQoMSk7XG5cbmZ1bmN0aW9uIGRpamtzdHJhKGcsIHNvdXJjZSwgd2VpZ2h0Rm4sIGVkZ2VGbikge1xuICByZXR1cm4gcnVuRGlqa3N0cmEoZywgU3RyaW5nKHNvdXJjZSksXG4gICAgd2VpZ2h0Rm4gfHwgREVGQVVMVF9XRUlHSFRfRlVOQyxcbiAgICBlZGdlRm4gfHwgZnVuY3Rpb24odikgeyByZXR1cm4gZy5vdXRFZGdlcyh2KTsgfSk7XG59XG5cbmZ1bmN0aW9uIHJ1bkRpamtzdHJhKGcsIHNvdXJjZSwgd2VpZ2h0Rm4sIGVkZ2VGbikge1xuICB2YXIgcmVzdWx0cyA9IHt9O1xuICB2YXIgcHEgPSBuZXcgUHJpb3JpdHlRdWV1ZSgpO1xuICB2YXIgdiwgdkVudHJ5O1xuXG4gIHZhciB1cGRhdGVOZWlnaGJvcnMgPSBmdW5jdGlvbihlZGdlKSB7XG4gICAgdmFyIHcgPSBlZGdlLnYgIT09IHYgPyBlZGdlLnYgOiBlZGdlLnc7XG4gICAgdmFyIHdFbnRyeSA9IHJlc3VsdHNbd107XG4gICAgdmFyIHdlaWdodCA9IHdlaWdodEZuKGVkZ2UpO1xuICAgIHZhciBkaXN0YW5jZSA9IHZFbnRyeS5kaXN0YW5jZSArIHdlaWdodDtcblxuICAgIGlmICh3ZWlnaHQgPCAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJkaWprc3RyYSBkb2VzIG5vdCBhbGxvdyBuZWdhdGl2ZSBlZGdlIHdlaWdodHMuIFwiICtcbiAgICAgICAgICAgICAgICAgICAgICBcIkJhZCBlZGdlOiBcIiArIGVkZ2UgKyBcIiBXZWlnaHQ6IFwiICsgd2VpZ2h0KTtcbiAgICB9XG5cbiAgICBpZiAoZGlzdGFuY2UgPCB3RW50cnkuZGlzdGFuY2UpIHtcbiAgICAgIHdFbnRyeS5kaXN0YW5jZSA9IGRpc3RhbmNlO1xuICAgICAgd0VudHJ5LnByZWRlY2Vzc29yID0gdjtcbiAgICAgIHBxLmRlY3JlYXNlKHcsIGRpc3RhbmNlKTtcbiAgICB9XG4gIH07XG5cbiAgZy5ub2RlcygpLmZvckVhY2goZnVuY3Rpb24odikge1xuICAgIHZhciBkaXN0YW5jZSA9IHYgPT09IHNvdXJjZSA/IDAgOiBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7XG4gICAgcmVzdWx0c1t2XSA9IHsgZGlzdGFuY2U6IGRpc3RhbmNlIH07XG4gICAgcHEuYWRkKHYsIGRpc3RhbmNlKTtcbiAgfSk7XG5cbiAgd2hpbGUgKHBxLnNpemUoKSA+IDApIHtcbiAgICB2ID0gcHEucmVtb3ZlTWluKCk7XG4gICAgdkVudHJ5ID0gcmVzdWx0c1t2XTtcbiAgICBpZiAodkVudHJ5LmRpc3RhbmNlID09PSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFkpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIGVkZ2VGbih2KS5mb3JFYWNoKHVwZGF0ZU5laWdoYm9ycyk7XG4gIH1cblxuICByZXR1cm4gcmVzdWx0cztcbn1cbiIsInZhciBfID0gcmVxdWlyZShcIi4uL2xvZGFzaFwiKTtcbnZhciB0YXJqYW4gPSByZXF1aXJlKFwiLi90YXJqYW5cIik7XG5cbm1vZHVsZS5leHBvcnRzID0gZmluZEN5Y2xlcztcblxuZnVuY3Rpb24gZmluZEN5Y2xlcyhnKSB7XG4gIHJldHVybiBfLmZpbHRlcih0YXJqYW4oZyksIGZ1bmN0aW9uKGNtcHQpIHtcbiAgICByZXR1cm4gY21wdC5sZW5ndGggPiAxIHx8IChjbXB0Lmxlbmd0aCA9PT0gMSAmJiBnLmhhc0VkZ2UoY21wdFswXSwgY21wdFswXSkpO1xuICB9KTtcbn1cbiIsInZhciBfID0gcmVxdWlyZShcIi4uL2xvZGFzaFwiKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmbG95ZFdhcnNoYWxsO1xuXG52YXIgREVGQVVMVF9XRUlHSFRfRlVOQyA9IF8uY29uc3RhbnQoMSk7XG5cbmZ1bmN0aW9uIGZsb3lkV2Fyc2hhbGwoZywgd2VpZ2h0Rm4sIGVkZ2VGbikge1xuICByZXR1cm4gcnVuRmxveWRXYXJzaGFsbChnLFxuICAgIHdlaWdodEZuIHx8IERFRkFVTFRfV0VJR0hUX0ZVTkMsXG4gICAgZWRnZUZuIHx8IGZ1bmN0aW9uKHYpIHsgcmV0dXJuIGcub3V0RWRnZXModik7IH0pO1xufVxuXG5mdW5jdGlvbiBydW5GbG95ZFdhcnNoYWxsKGcsIHdlaWdodEZuLCBlZGdlRm4pIHtcbiAgdmFyIHJlc3VsdHMgPSB7fTtcbiAgdmFyIG5vZGVzID0gZy5ub2RlcygpO1xuXG4gIG5vZGVzLmZvckVhY2goZnVuY3Rpb24odikge1xuICAgIHJlc3VsdHNbdl0gPSB7fTtcbiAgICByZXN1bHRzW3ZdW3ZdID0geyBkaXN0YW5jZTogMCB9O1xuICAgIG5vZGVzLmZvckVhY2goZnVuY3Rpb24odykge1xuICAgICAgaWYgKHYgIT09IHcpIHtcbiAgICAgICAgcmVzdWx0c1t2XVt3XSA9IHsgZGlzdGFuY2U6IE51bWJlci5QT1NJVElWRV9JTkZJTklUWSB9O1xuICAgICAgfVxuICAgIH0pO1xuICAgIGVkZ2VGbih2KS5mb3JFYWNoKGZ1bmN0aW9uKGVkZ2UpIHtcbiAgICAgIHZhciB3ID0gZWRnZS52ID09PSB2ID8gZWRnZS53IDogZWRnZS52O1xuICAgICAgdmFyIGQgPSB3ZWlnaHRGbihlZGdlKTtcbiAgICAgIHJlc3VsdHNbdl1bd10gPSB7IGRpc3RhbmNlOiBkLCBwcmVkZWNlc3NvcjogdiB9O1xuICAgIH0pO1xuICB9KTtcblxuICBub2Rlcy5mb3JFYWNoKGZ1bmN0aW9uKGspIHtcbiAgICB2YXIgcm93SyA9IHJlc3VsdHNba107XG4gICAgbm9kZXMuZm9yRWFjaChmdW5jdGlvbihpKSB7XG4gICAgICB2YXIgcm93SSA9IHJlc3VsdHNbaV07XG4gICAgICBub2Rlcy5mb3JFYWNoKGZ1bmN0aW9uKGopIHtcbiAgICAgICAgdmFyIGlrID0gcm93SVtrXTtcbiAgICAgICAgdmFyIGtqID0gcm93S1tqXTtcbiAgICAgICAgdmFyIGlqID0gcm93SVtqXTtcbiAgICAgICAgdmFyIGFsdERpc3RhbmNlID0gaWsuZGlzdGFuY2UgKyBrai5kaXN0YW5jZTtcbiAgICAgICAgaWYgKGFsdERpc3RhbmNlIDwgaWouZGlzdGFuY2UpIHtcbiAgICAgICAgICBpai5kaXN0YW5jZSA9IGFsdERpc3RhbmNlO1xuICAgICAgICAgIGlqLnByZWRlY2Vzc29yID0ga2oucHJlZGVjZXNzb3I7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuICB9KTtcblxuICByZXR1cm4gcmVzdWx0cztcbn1cbiIsIm1vZHVsZS5leHBvcnRzID0ge1xuICBjb21wb25lbnRzOiByZXF1aXJlKFwiLi9jb21wb25lbnRzXCIpLFxuICBkaWprc3RyYTogcmVxdWlyZShcIi4vZGlqa3N0cmFcIiksXG4gIGRpamtzdHJhQWxsOiByZXF1aXJlKFwiLi9kaWprc3RyYS1hbGxcIiksXG4gIGZpbmRDeWNsZXM6IHJlcXVpcmUoXCIuL2ZpbmQtY3ljbGVzXCIpLFxuICBmbG95ZFdhcnNoYWxsOiByZXF1aXJlKFwiLi9mbG95ZC13YXJzaGFsbFwiKSxcbiAgaXNBY3ljbGljOiByZXF1aXJlKFwiLi9pcy1hY3ljbGljXCIpLFxuICBwb3N0b3JkZXI6IHJlcXVpcmUoXCIuL3Bvc3RvcmRlclwiKSxcbiAgcHJlb3JkZXI6IHJlcXVpcmUoXCIuL3ByZW9yZGVyXCIpLFxuICBwcmltOiByZXF1aXJlKFwiLi9wcmltXCIpLFxuICB0YXJqYW46IHJlcXVpcmUoXCIuL3RhcmphblwiKSxcbiAgdG9wc29ydDogcmVxdWlyZShcIi4vdG9wc29ydFwiKVxufTtcbiIsInZhciB0b3Bzb3J0ID0gcmVxdWlyZShcIi4vdG9wc29ydFwiKTtcblxubW9kdWxlLmV4cG9ydHMgPSBpc0FjeWNsaWM7XG5cbmZ1bmN0aW9uIGlzQWN5Y2xpYyhnKSB7XG4gIHRyeSB7XG4gICAgdG9wc29ydChnKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIGlmIChlIGluc3RhbmNlb2YgdG9wc29ydC5DeWNsZUV4Y2VwdGlvbikge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB0aHJvdyBlO1xuICB9XG4gIHJldHVybiB0cnVlO1xufVxuIiwidmFyIGRmcyA9IHJlcXVpcmUoXCIuL2Rmc1wiKTtcblxubW9kdWxlLmV4cG9ydHMgPSBwb3N0b3JkZXI7XG5cbmZ1bmN0aW9uIHBvc3RvcmRlcihnLCB2cykge1xuICByZXR1cm4gZGZzKGcsIHZzLCBcInBvc3RcIik7XG59XG4iLCJ2YXIgZGZzID0gcmVxdWlyZShcIi4vZGZzXCIpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHByZW9yZGVyO1xuXG5mdW5jdGlvbiBwcmVvcmRlcihnLCB2cykge1xuICByZXR1cm4gZGZzKGcsIHZzLCBcInByZVwiKTtcbn1cbiIsInZhciBfID0gcmVxdWlyZShcIi4uL2xvZGFzaFwiKTtcbnZhciBHcmFwaCA9IHJlcXVpcmUoXCIuLi9ncmFwaFwiKTtcbnZhciBQcmlvcml0eVF1ZXVlID0gcmVxdWlyZShcIi4uL2RhdGEvcHJpb3JpdHktcXVldWVcIik7XG5cbm1vZHVsZS5leHBvcnRzID0gcHJpbTtcblxuZnVuY3Rpb24gcHJpbShnLCB3ZWlnaHRGdW5jKSB7XG4gIHZhciByZXN1bHQgPSBuZXcgR3JhcGgoKTtcbiAgdmFyIHBhcmVudHMgPSB7fTtcbiAgdmFyIHBxID0gbmV3IFByaW9yaXR5UXVldWUoKTtcbiAgdmFyIHY7XG5cbiAgZnVuY3Rpb24gdXBkYXRlTmVpZ2hib3JzKGVkZ2UpIHtcbiAgICB2YXIgdyA9IGVkZ2UudiA9PT0gdiA/IGVkZ2UudyA6IGVkZ2UudjtcbiAgICB2YXIgcHJpID0gcHEucHJpb3JpdHkodyk7XG4gICAgaWYgKHByaSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB2YXIgZWRnZVdlaWdodCA9IHdlaWdodEZ1bmMoZWRnZSk7XG4gICAgICBpZiAoZWRnZVdlaWdodCA8IHByaSkge1xuICAgICAgICBwYXJlbnRzW3ddID0gdjtcbiAgICAgICAgcHEuZGVjcmVhc2UodywgZWRnZVdlaWdodCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKGcubm9kZUNvdW50KCkgPT09IDApIHtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgXy5lYWNoKGcubm9kZXMoKSwgZnVuY3Rpb24odikge1xuICAgIHBxLmFkZCh2LCBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFkpO1xuICAgIHJlc3VsdC5zZXROb2RlKHYpO1xuICB9KTtcblxuICAvLyBTdGFydCBmcm9tIGFuIGFyYml0cmFyeSBub2RlXG4gIHBxLmRlY3JlYXNlKGcubm9kZXMoKVswXSwgMCk7XG5cbiAgdmFyIGluaXQgPSBmYWxzZTtcbiAgd2hpbGUgKHBxLnNpemUoKSA+IDApIHtcbiAgICB2ID0gcHEucmVtb3ZlTWluKCk7XG4gICAgaWYgKF8uaGFzKHBhcmVudHMsIHYpKSB7XG4gICAgICByZXN1bHQuc2V0RWRnZSh2LCBwYXJlbnRzW3ZdKTtcbiAgICB9IGVsc2UgaWYgKGluaXQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIklucHV0IGdyYXBoIGlzIG5vdCBjb25uZWN0ZWQ6IFwiICsgZyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGluaXQgPSB0cnVlO1xuICAgIH1cblxuICAgIGcubm9kZUVkZ2VzKHYpLmZvckVhY2godXBkYXRlTmVpZ2hib3JzKTtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59XG4iLCJ2YXIgXyA9IHJlcXVpcmUoXCIuLi9sb2Rhc2hcIik7XG5cbm1vZHVsZS5leHBvcnRzID0gdGFyamFuO1xuXG5mdW5jdGlvbiB0YXJqYW4oZykge1xuICB2YXIgaW5kZXggPSAwO1xuICB2YXIgc3RhY2sgPSBbXTtcbiAgdmFyIHZpc2l0ZWQgPSB7fTsgLy8gbm9kZSBpZCAtPiB7IG9uU3RhY2ssIGxvd2xpbmssIGluZGV4IH1cbiAgdmFyIHJlc3VsdHMgPSBbXTtcblxuICBmdW5jdGlvbiBkZnModikge1xuICAgIHZhciBlbnRyeSA9IHZpc2l0ZWRbdl0gPSB7XG4gICAgICBvblN0YWNrOiB0cnVlLFxuICAgICAgbG93bGluazogaW5kZXgsXG4gICAgICBpbmRleDogaW5kZXgrK1xuICAgIH07XG4gICAgc3RhY2sucHVzaCh2KTtcblxuICAgIGcuc3VjY2Vzc29ycyh2KS5mb3JFYWNoKGZ1bmN0aW9uKHcpIHtcbiAgICAgIGlmICghXy5oYXModmlzaXRlZCwgdykpIHtcbiAgICAgICAgZGZzKHcpO1xuICAgICAgICBlbnRyeS5sb3dsaW5rID0gTWF0aC5taW4oZW50cnkubG93bGluaywgdmlzaXRlZFt3XS5sb3dsaW5rKTtcbiAgICAgIH0gZWxzZSBpZiAodmlzaXRlZFt3XS5vblN0YWNrKSB7XG4gICAgICAgIGVudHJ5Lmxvd2xpbmsgPSBNYXRoLm1pbihlbnRyeS5sb3dsaW5rLCB2aXNpdGVkW3ddLmluZGV4KTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGlmIChlbnRyeS5sb3dsaW5rID09PSBlbnRyeS5pbmRleCkge1xuICAgICAgdmFyIGNtcHQgPSBbXTtcbiAgICAgIHZhciB3O1xuICAgICAgZG8ge1xuICAgICAgICB3ID0gc3RhY2sucG9wKCk7XG4gICAgICAgIHZpc2l0ZWRbd10ub25TdGFjayA9IGZhbHNlO1xuICAgICAgICBjbXB0LnB1c2godyk7XG4gICAgICB9IHdoaWxlICh2ICE9PSB3KTtcbiAgICAgIHJlc3VsdHMucHVzaChjbXB0KTtcbiAgICB9XG4gIH1cblxuICBnLm5vZGVzKCkuZm9yRWFjaChmdW5jdGlvbih2KSB7XG4gICAgaWYgKCFfLmhhcyh2aXNpdGVkLCB2KSkge1xuICAgICAgZGZzKHYpO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIHJlc3VsdHM7XG59XG4iLCJ2YXIgXyA9IHJlcXVpcmUoXCIuLi9sb2Rhc2hcIik7XG5cbm1vZHVsZS5leHBvcnRzID0gdG9wc29ydDtcbnRvcHNvcnQuQ3ljbGVFeGNlcHRpb24gPSBDeWNsZUV4Y2VwdGlvbjtcblxuZnVuY3Rpb24gdG9wc29ydChnKSB7XG4gIHZhciB2aXNpdGVkID0ge307XG4gIHZhciBzdGFjayA9IHt9O1xuICB2YXIgcmVzdWx0cyA9IFtdO1xuXG4gIGZ1bmN0aW9uIHZpc2l0KG5vZGUpIHtcbiAgICBpZiAoXy5oYXMoc3RhY2ssIG5vZGUpKSB7XG4gICAgICB0aHJvdyBuZXcgQ3ljbGVFeGNlcHRpb24oKTtcbiAgICB9XG5cbiAgICBpZiAoIV8uaGFzKHZpc2l0ZWQsIG5vZGUpKSB7XG4gICAgICBzdGFja1tub2RlXSA9IHRydWU7XG4gICAgICB2aXNpdGVkW25vZGVdID0gdHJ1ZTtcbiAgICAgIF8uZWFjaChnLnByZWRlY2Vzc29ycyhub2RlKSwgdmlzaXQpO1xuICAgICAgZGVsZXRlIHN0YWNrW25vZGVdO1xuICAgICAgcmVzdWx0cy5wdXNoKG5vZGUpO1xuICAgIH1cbiAgfVxuXG4gIF8uZWFjaChnLnNpbmtzKCksIHZpc2l0KTtcblxuICBpZiAoXy5zaXplKHZpc2l0ZWQpICE9PSBnLm5vZGVDb3VudCgpKSB7XG4gICAgdGhyb3cgbmV3IEN5Y2xlRXhjZXB0aW9uKCk7XG4gIH1cblxuICByZXR1cm4gcmVzdWx0cztcbn1cblxuZnVuY3Rpb24gQ3ljbGVFeGNlcHRpb24oKSB7fVxuQ3ljbGVFeGNlcHRpb24ucHJvdG90eXBlID0gbmV3IEVycm9yKCk7IC8vIG11c3QgYmUgYW4gaW5zdGFuY2Ugb2YgRXJyb3IgdG8gcGFzcyB0ZXN0aW5nIiwidmFyIF8gPSByZXF1aXJlKFwiLi4vbG9kYXNoXCIpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFByaW9yaXR5UXVldWU7XG5cbi8qKlxuICogQSBtaW4tcHJpb3JpdHkgcXVldWUgZGF0YSBzdHJ1Y3R1cmUuIFRoaXMgYWxnb3JpdGhtIGlzIGRlcml2ZWQgZnJvbSBDb3JtZW4sXG4gKiBldCBhbC4sIFwiSW50cm9kdWN0aW9uIHRvIEFsZ29yaXRobXNcIi4gVGhlIGJhc2ljIGlkZWEgb2YgYSBtaW4tcHJpb3JpdHlcbiAqIHF1ZXVlIGlzIHRoYXQgeW91IGNhbiBlZmZpY2llbnRseSAoaW4gTygxKSB0aW1lKSBnZXQgdGhlIHNtYWxsZXN0IGtleSBpblxuICogdGhlIHF1ZXVlLiBBZGRpbmcgYW5kIHJlbW92aW5nIGVsZW1lbnRzIHRha2VzIE8obG9nIG4pIHRpbWUuIEEga2V5IGNhblxuICogaGF2ZSBpdHMgcHJpb3JpdHkgZGVjcmVhc2VkIGluIE8obG9nIG4pIHRpbWUuXG4gKi9cbmZ1bmN0aW9uIFByaW9yaXR5UXVldWUoKSB7XG4gIHRoaXMuX2FyciA9IFtdO1xuICB0aGlzLl9rZXlJbmRpY2VzID0ge307XG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgbnVtYmVyIG9mIGVsZW1lbnRzIGluIHRoZSBxdWV1ZS4gVGFrZXMgYE8oMSlgIHRpbWUuXG4gKi9cblByaW9yaXR5UXVldWUucHJvdG90eXBlLnNpemUgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuX2Fyci5sZW5ndGg7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIGtleXMgdGhhdCBhcmUgaW4gdGhlIHF1ZXVlLiBUYWtlcyBgTyhuKWAgdGltZS5cbiAqL1xuUHJpb3JpdHlRdWV1ZS5wcm90b3R5cGUua2V5cyA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5fYXJyLm1hcChmdW5jdGlvbih4KSB7IHJldHVybiB4LmtleTsgfSk7XG59O1xuXG4vKipcbiAqIFJldHVybnMgYHRydWVgIGlmICoqa2V5KiogaXMgaW4gdGhlIHF1ZXVlIGFuZCBgZmFsc2VgIGlmIG5vdC5cbiAqL1xuUHJpb3JpdHlRdWV1ZS5wcm90b3R5cGUuaGFzID0gZnVuY3Rpb24oa2V5KSB7XG4gIHJldHVybiBfLmhhcyh0aGlzLl9rZXlJbmRpY2VzLCBrZXkpO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBwcmlvcml0eSBmb3IgKiprZXkqKi4gSWYgKiprZXkqKiBpcyBub3QgcHJlc2VudCBpbiB0aGUgcXVldWVcbiAqIHRoZW4gdGhpcyBmdW5jdGlvbiByZXR1cm5zIGB1bmRlZmluZWRgLiBUYWtlcyBgTygxKWAgdGltZS5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0ga2V5XG4gKi9cblByaW9yaXR5UXVldWUucHJvdG90eXBlLnByaW9yaXR5ID0gZnVuY3Rpb24oa2V5KSB7XG4gIHZhciBpbmRleCA9IHRoaXMuX2tleUluZGljZXNba2V5XTtcbiAgaWYgKGluZGV4ICE9PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gdGhpcy5fYXJyW2luZGV4XS5wcmlvcml0eTtcbiAgfVxufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBrZXkgZm9yIHRoZSBtaW5pbXVtIGVsZW1lbnQgaW4gdGhpcyBxdWV1ZS4gSWYgdGhlIHF1ZXVlIGlzXG4gKiBlbXB0eSB0aGlzIGZ1bmN0aW9uIHRocm93cyBhbiBFcnJvci4gVGFrZXMgYE8oMSlgIHRpbWUuXG4gKi9cblByaW9yaXR5UXVldWUucHJvdG90eXBlLm1pbiA9IGZ1bmN0aW9uKCkge1xuICBpZiAodGhpcy5zaXplKCkgPT09IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJRdWV1ZSB1bmRlcmZsb3dcIik7XG4gIH1cbiAgcmV0dXJuIHRoaXMuX2FyclswXS5rZXk7XG59O1xuXG4vKipcbiAqIEluc2VydHMgYSBuZXcga2V5IGludG8gdGhlIHByaW9yaXR5IHF1ZXVlLiBJZiB0aGUga2V5IGFscmVhZHkgZXhpc3RzIGluXG4gKiB0aGUgcXVldWUgdGhpcyBmdW5jdGlvbiByZXR1cm5zIGBmYWxzZWA7IG90aGVyd2lzZSBpdCB3aWxsIHJldHVybiBgdHJ1ZWAuXG4gKiBUYWtlcyBgTyhuKWAgdGltZS5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0ga2V5IHRoZSBrZXkgdG8gYWRkXG4gKiBAcGFyYW0ge051bWJlcn0gcHJpb3JpdHkgdGhlIGluaXRpYWwgcHJpb3JpdHkgZm9yIHRoZSBrZXlcbiAqL1xuUHJpb3JpdHlRdWV1ZS5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24oa2V5LCBwcmlvcml0eSkge1xuICB2YXIga2V5SW5kaWNlcyA9IHRoaXMuX2tleUluZGljZXM7XG4gIGtleSA9IFN0cmluZyhrZXkpO1xuICBpZiAoIV8uaGFzKGtleUluZGljZXMsIGtleSkpIHtcbiAgICB2YXIgYXJyID0gdGhpcy5fYXJyO1xuICAgIHZhciBpbmRleCA9IGFyci5sZW5ndGg7XG4gICAga2V5SW5kaWNlc1trZXldID0gaW5kZXg7XG4gICAgYXJyLnB1c2goe2tleToga2V5LCBwcmlvcml0eTogcHJpb3JpdHl9KTtcbiAgICB0aGlzLl9kZWNyZWFzZShpbmRleCk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufTtcblxuLyoqXG4gKiBSZW1vdmVzIGFuZCByZXR1cm5zIHRoZSBzbWFsbGVzdCBrZXkgaW4gdGhlIHF1ZXVlLiBUYWtlcyBgTyhsb2cgbilgIHRpbWUuXG4gKi9cblByaW9yaXR5UXVldWUucHJvdG90eXBlLnJlbW92ZU1pbiA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLl9zd2FwKDAsIHRoaXMuX2Fyci5sZW5ndGggLSAxKTtcbiAgdmFyIG1pbiA9IHRoaXMuX2Fyci5wb3AoKTtcbiAgZGVsZXRlIHRoaXMuX2tleUluZGljZXNbbWluLmtleV07XG4gIHRoaXMuX2hlYXBpZnkoMCk7XG4gIHJldHVybiBtaW4ua2V5O1xufTtcblxuLyoqXG4gKiBEZWNyZWFzZXMgdGhlIHByaW9yaXR5IGZvciAqKmtleSoqIHRvICoqcHJpb3JpdHkqKi4gSWYgdGhlIG5ldyBwcmlvcml0eSBpc1xuICogZ3JlYXRlciB0aGFuIHRoZSBwcmV2aW91cyBwcmlvcml0eSwgdGhpcyBmdW5jdGlvbiB3aWxsIHRocm93IGFuIEVycm9yLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBrZXkgdGhlIGtleSBmb3Igd2hpY2ggdG8gcmFpc2UgcHJpb3JpdHlcbiAqIEBwYXJhbSB7TnVtYmVyfSBwcmlvcml0eSB0aGUgbmV3IHByaW9yaXR5IGZvciB0aGUga2V5XG4gKi9cblByaW9yaXR5UXVldWUucHJvdG90eXBlLmRlY3JlYXNlID0gZnVuY3Rpb24oa2V5LCBwcmlvcml0eSkge1xuICB2YXIgaW5kZXggPSB0aGlzLl9rZXlJbmRpY2VzW2tleV07XG4gIGlmIChwcmlvcml0eSA+IHRoaXMuX2FycltpbmRleF0ucHJpb3JpdHkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJOZXcgcHJpb3JpdHkgaXMgZ3JlYXRlciB0aGFuIGN1cnJlbnQgcHJpb3JpdHkuIFwiICtcbiAgICAgICAgXCJLZXk6IFwiICsga2V5ICsgXCIgT2xkOiBcIiArIHRoaXMuX2FycltpbmRleF0ucHJpb3JpdHkgKyBcIiBOZXc6IFwiICsgcHJpb3JpdHkpO1xuICB9XG4gIHRoaXMuX2FycltpbmRleF0ucHJpb3JpdHkgPSBwcmlvcml0eTtcbiAgdGhpcy5fZGVjcmVhc2UoaW5kZXgpO1xufTtcblxuUHJpb3JpdHlRdWV1ZS5wcm90b3R5cGUuX2hlYXBpZnkgPSBmdW5jdGlvbihpKSB7XG4gIHZhciBhcnIgPSB0aGlzLl9hcnI7XG4gIHZhciBsID0gMiAqIGk7XG4gIHZhciByID0gbCArIDE7XG4gIHZhciBsYXJnZXN0ID0gaTtcbiAgaWYgKGwgPCBhcnIubGVuZ3RoKSB7XG4gICAgbGFyZ2VzdCA9IGFycltsXS5wcmlvcml0eSA8IGFycltsYXJnZXN0XS5wcmlvcml0eSA/IGwgOiBsYXJnZXN0O1xuICAgIGlmIChyIDwgYXJyLmxlbmd0aCkge1xuICAgICAgbGFyZ2VzdCA9IGFycltyXS5wcmlvcml0eSA8IGFycltsYXJnZXN0XS5wcmlvcml0eSA/IHIgOiBsYXJnZXN0O1xuICAgIH1cbiAgICBpZiAobGFyZ2VzdCAhPT0gaSkge1xuICAgICAgdGhpcy5fc3dhcChpLCBsYXJnZXN0KTtcbiAgICAgIHRoaXMuX2hlYXBpZnkobGFyZ2VzdCk7XG4gICAgfVxuICB9XG59O1xuXG5Qcmlvcml0eVF1ZXVlLnByb3RvdHlwZS5fZGVjcmVhc2UgPSBmdW5jdGlvbihpbmRleCkge1xuICB2YXIgYXJyID0gdGhpcy5fYXJyO1xuICB2YXIgcHJpb3JpdHkgPSBhcnJbaW5kZXhdLnByaW9yaXR5O1xuICB2YXIgcGFyZW50O1xuICB3aGlsZSAoaW5kZXggIT09IDApIHtcbiAgICBwYXJlbnQgPSBpbmRleCA+PiAxO1xuICAgIGlmIChhcnJbcGFyZW50XS5wcmlvcml0eSA8IHByaW9yaXR5KSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgdGhpcy5fc3dhcChpbmRleCwgcGFyZW50KTtcbiAgICBpbmRleCA9IHBhcmVudDtcbiAgfVxufTtcblxuUHJpb3JpdHlRdWV1ZS5wcm90b3R5cGUuX3N3YXAgPSBmdW5jdGlvbihpLCBqKSB7XG4gIHZhciBhcnIgPSB0aGlzLl9hcnI7XG4gIHZhciBrZXlJbmRpY2VzID0gdGhpcy5fa2V5SW5kaWNlcztcbiAgdmFyIG9yaWdBcnJJID0gYXJyW2ldO1xuICB2YXIgb3JpZ0FyckogPSBhcnJbal07XG4gIGFycltpXSA9IG9yaWdBcnJKO1xuICBhcnJbal0gPSBvcmlnQXJySTtcbiAga2V5SW5kaWNlc1tvcmlnQXJySi5rZXldID0gaTtcbiAga2V5SW5kaWNlc1tvcmlnQXJySS5rZXldID0gajtcbn07XG4iLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIF8gPSByZXF1aXJlKFwiLi9sb2Rhc2hcIik7XG5cbm1vZHVsZS5leHBvcnRzID0gR3JhcGg7XG5cbnZhciBERUZBVUxUX0VER0VfTkFNRSA9IFwiXFx4MDBcIjtcbnZhciBHUkFQSF9OT0RFID0gXCJcXHgwMFwiO1xudmFyIEVER0VfS0VZX0RFTElNID0gXCJcXHgwMVwiO1xuXG4vLyBJbXBsZW1lbnRhdGlvbiBub3Rlczpcbi8vXG4vLyAgKiBOb2RlIGlkIHF1ZXJ5IGZ1bmN0aW9ucyBzaG91bGQgcmV0dXJuIHN0cmluZyBpZHMgZm9yIHRoZSBub2Rlc1xuLy8gICogRWRnZSBpZCBxdWVyeSBmdW5jdGlvbnMgc2hvdWxkIHJldHVybiBhbiBcImVkZ2VPYmpcIiwgZWRnZSBvYmplY3QsIHRoYXQgaXNcbi8vICAgIGNvbXBvc2VkIG9mIGVub3VnaCBpbmZvcm1hdGlvbiB0byB1bmlxdWVseSBpZGVudGlmeSBhbiBlZGdlOiB7diwgdywgbmFtZX0uXG4vLyAgKiBJbnRlcm5hbGx5IHdlIHVzZSBhbiBcImVkZ2VJZFwiLCBhIHN0cmluZ2lmaWVkIGZvcm0gb2YgdGhlIGVkZ2VPYmosIHRvXG4vLyAgICByZWZlcmVuY2UgZWRnZXMuIFRoaXMgaXMgYmVjYXVzZSB3ZSBuZWVkIGEgcGVyZm9ybWFudCB3YXkgdG8gbG9vayB0aGVzZVxuLy8gICAgZWRnZXMgdXAgYW5kLCBvYmplY3QgcHJvcGVydGllcywgd2hpY2ggaGF2ZSBzdHJpbmcga2V5cywgYXJlIHRoZSBjbG9zZXN0XG4vLyAgICB3ZSdyZSBnb2luZyB0byBnZXQgdG8gYSBwZXJmb3JtYW50IGhhc2h0YWJsZSBpbiBKYXZhU2NyaXB0LlxuXG5mdW5jdGlvbiBHcmFwaChvcHRzKSB7XG4gIHRoaXMuX2lzRGlyZWN0ZWQgPSBfLmhhcyhvcHRzLCBcImRpcmVjdGVkXCIpID8gb3B0cy5kaXJlY3RlZCA6IHRydWU7XG4gIHRoaXMuX2lzTXVsdGlncmFwaCA9IF8uaGFzKG9wdHMsIFwibXVsdGlncmFwaFwiKSA/IG9wdHMubXVsdGlncmFwaCA6IGZhbHNlO1xuICB0aGlzLl9pc0NvbXBvdW5kID0gXy5oYXMob3B0cywgXCJjb21wb3VuZFwiKSA/IG9wdHMuY29tcG91bmQgOiBmYWxzZTtcblxuICAvLyBMYWJlbCBmb3IgdGhlIGdyYXBoIGl0c2VsZlxuICB0aGlzLl9sYWJlbCA9IHVuZGVmaW5lZDtcblxuICAvLyBEZWZhdWx0cyB0byBiZSBzZXQgd2hlbiBjcmVhdGluZyBhIG5ldyBub2RlXG4gIHRoaXMuX2RlZmF1bHROb2RlTGFiZWxGbiA9IF8uY29uc3RhbnQodW5kZWZpbmVkKTtcblxuICAvLyBEZWZhdWx0cyB0byBiZSBzZXQgd2hlbiBjcmVhdGluZyBhIG5ldyBlZGdlXG4gIHRoaXMuX2RlZmF1bHRFZGdlTGFiZWxGbiA9IF8uY29uc3RhbnQodW5kZWZpbmVkKTtcblxuICAvLyB2IC0+IGxhYmVsXG4gIHRoaXMuX25vZGVzID0ge307XG5cbiAgaWYgKHRoaXMuX2lzQ29tcG91bmQpIHtcbiAgICAvLyB2IC0+IHBhcmVudFxuICAgIHRoaXMuX3BhcmVudCA9IHt9O1xuXG4gICAgLy8gdiAtPiBjaGlsZHJlblxuICAgIHRoaXMuX2NoaWxkcmVuID0ge307XG4gICAgdGhpcy5fY2hpbGRyZW5bR1JBUEhfTk9ERV0gPSB7fTtcbiAgfVxuXG4gIC8vIHYgLT4gZWRnZU9ialxuICB0aGlzLl9pbiA9IHt9O1xuXG4gIC8vIHUgLT4gdiAtPiBOdW1iZXJcbiAgdGhpcy5fcHJlZHMgPSB7fTtcblxuICAvLyB2IC0+IGVkZ2VPYmpcbiAgdGhpcy5fb3V0ID0ge307XG5cbiAgLy8gdiAtPiB3IC0+IE51bWJlclxuICB0aGlzLl9zdWNzID0ge307XG5cbiAgLy8gZSAtPiBlZGdlT2JqXG4gIHRoaXMuX2VkZ2VPYmpzID0ge307XG5cbiAgLy8gZSAtPiBsYWJlbFxuICB0aGlzLl9lZGdlTGFiZWxzID0ge307XG59XG5cbi8qIE51bWJlciBvZiBub2RlcyBpbiB0aGUgZ3JhcGguIFNob3VsZCBvbmx5IGJlIGNoYW5nZWQgYnkgdGhlIGltcGxlbWVudGF0aW9uLiAqL1xuR3JhcGgucHJvdG90eXBlLl9ub2RlQ291bnQgPSAwO1xuXG4vKiBOdW1iZXIgb2YgZWRnZXMgaW4gdGhlIGdyYXBoLiBTaG91bGQgb25seSBiZSBjaGFuZ2VkIGJ5IHRoZSBpbXBsZW1lbnRhdGlvbi4gKi9cbkdyYXBoLnByb3RvdHlwZS5fZWRnZUNvdW50ID0gMDtcblxuXG4vKiA9PT0gR3JhcGggZnVuY3Rpb25zID09PT09PT09PSAqL1xuXG5HcmFwaC5wcm90b3R5cGUuaXNEaXJlY3RlZCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5faXNEaXJlY3RlZDtcbn07XG5cbkdyYXBoLnByb3RvdHlwZS5pc011bHRpZ3JhcGggPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuX2lzTXVsdGlncmFwaDtcbn07XG5cbkdyYXBoLnByb3RvdHlwZS5pc0NvbXBvdW5kID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLl9pc0NvbXBvdW5kO1xufTtcblxuR3JhcGgucHJvdG90eXBlLnNldEdyYXBoID0gZnVuY3Rpb24obGFiZWwpIHtcbiAgdGhpcy5fbGFiZWwgPSBsYWJlbDtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5HcmFwaC5wcm90b3R5cGUuZ3JhcGggPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuX2xhYmVsO1xufTtcblxuXG4vKiA9PT0gTm9kZSBmdW5jdGlvbnMgPT09PT09PT09PSAqL1xuXG5HcmFwaC5wcm90b3R5cGUuc2V0RGVmYXVsdE5vZGVMYWJlbCA9IGZ1bmN0aW9uKG5ld0RlZmF1bHQpIHtcbiAgaWYgKCFfLmlzRnVuY3Rpb24obmV3RGVmYXVsdCkpIHtcbiAgICBuZXdEZWZhdWx0ID0gXy5jb25zdGFudChuZXdEZWZhdWx0KTtcbiAgfVxuICB0aGlzLl9kZWZhdWx0Tm9kZUxhYmVsRm4gPSBuZXdEZWZhdWx0O1xuICByZXR1cm4gdGhpcztcbn07XG5cbkdyYXBoLnByb3RvdHlwZS5ub2RlQ291bnQgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuX25vZGVDb3VudDtcbn07XG5cbkdyYXBoLnByb3RvdHlwZS5ub2RlcyA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gXy5rZXlzKHRoaXMuX25vZGVzKTtcbn07XG5cbkdyYXBoLnByb3RvdHlwZS5zb3VyY2VzID0gZnVuY3Rpb24oKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgcmV0dXJuIF8uZmlsdGVyKHRoaXMubm9kZXMoKSwgZnVuY3Rpb24odikge1xuICAgIHJldHVybiBfLmlzRW1wdHkoc2VsZi5faW5bdl0pO1xuICB9KTtcbn07XG5cbkdyYXBoLnByb3RvdHlwZS5zaW5rcyA9IGZ1bmN0aW9uKCkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHJldHVybiBfLmZpbHRlcih0aGlzLm5vZGVzKCksIGZ1bmN0aW9uKHYpIHtcbiAgICByZXR1cm4gXy5pc0VtcHR5KHNlbGYuX291dFt2XSk7XG4gIH0pO1xufTtcblxuR3JhcGgucHJvdG90eXBlLnNldE5vZGVzID0gZnVuY3Rpb24odnMsIHZhbHVlKSB7XG4gIHZhciBhcmdzID0gYXJndW1lbnRzO1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIF8uZWFjaCh2cywgZnVuY3Rpb24odikge1xuICAgIGlmIChhcmdzLmxlbmd0aCA+IDEpIHtcbiAgICAgIHNlbGYuc2V0Tm9kZSh2LCB2YWx1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNlbGYuc2V0Tm9kZSh2KTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gdGhpcztcbn07XG5cbkdyYXBoLnByb3RvdHlwZS5zZXROb2RlID0gZnVuY3Rpb24odiwgdmFsdWUpIHtcbiAgaWYgKF8uaGFzKHRoaXMuX25vZGVzLCB2KSkge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgdGhpcy5fbm9kZXNbdl0gPSB2YWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICB0aGlzLl9ub2Rlc1t2XSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxID8gdmFsdWUgOiB0aGlzLl9kZWZhdWx0Tm9kZUxhYmVsRm4odik7XG4gIGlmICh0aGlzLl9pc0NvbXBvdW5kKSB7XG4gICAgdGhpcy5fcGFyZW50W3ZdID0gR1JBUEhfTk9ERTtcbiAgICB0aGlzLl9jaGlsZHJlblt2XSA9IHt9O1xuICAgIHRoaXMuX2NoaWxkcmVuW0dSQVBIX05PREVdW3ZdID0gdHJ1ZTtcbiAgfVxuICB0aGlzLl9pblt2XSA9IHt9O1xuICB0aGlzLl9wcmVkc1t2XSA9IHt9O1xuICB0aGlzLl9vdXRbdl0gPSB7fTtcbiAgdGhpcy5fc3Vjc1t2XSA9IHt9O1xuICArK3RoaXMuX25vZGVDb3VudDtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5HcmFwaC5wcm90b3R5cGUubm9kZSA9IGZ1bmN0aW9uKHYpIHtcbiAgcmV0dXJuIHRoaXMuX25vZGVzW3ZdO1xufTtcblxuR3JhcGgucHJvdG90eXBlLmhhc05vZGUgPSBmdW5jdGlvbih2KSB7XG4gIHJldHVybiBfLmhhcyh0aGlzLl9ub2Rlcywgdik7XG59O1xuXG5HcmFwaC5wcm90b3R5cGUucmVtb3ZlTm9kZSA9ICBmdW5jdGlvbih2KSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgaWYgKF8uaGFzKHRoaXMuX25vZGVzLCB2KSkge1xuICAgIHZhciByZW1vdmVFZGdlID0gZnVuY3Rpb24oZSkgeyBzZWxmLnJlbW92ZUVkZ2Uoc2VsZi5fZWRnZU9ianNbZV0pOyB9O1xuICAgIGRlbGV0ZSB0aGlzLl9ub2Rlc1t2XTtcbiAgICBpZiAodGhpcy5faXNDb21wb3VuZCkge1xuICAgICAgdGhpcy5fcmVtb3ZlRnJvbVBhcmVudHNDaGlsZExpc3Qodik7XG4gICAgICBkZWxldGUgdGhpcy5fcGFyZW50W3ZdO1xuICAgICAgXy5lYWNoKHRoaXMuY2hpbGRyZW4odiksIGZ1bmN0aW9uKGNoaWxkKSB7XG4gICAgICAgIHNlbGYuc2V0UGFyZW50KGNoaWxkKTtcbiAgICAgIH0pO1xuICAgICAgZGVsZXRlIHRoaXMuX2NoaWxkcmVuW3ZdO1xuICAgIH1cbiAgICBfLmVhY2goXy5rZXlzKHRoaXMuX2luW3ZdKSwgcmVtb3ZlRWRnZSk7XG4gICAgZGVsZXRlIHRoaXMuX2luW3ZdO1xuICAgIGRlbGV0ZSB0aGlzLl9wcmVkc1t2XTtcbiAgICBfLmVhY2goXy5rZXlzKHRoaXMuX291dFt2XSksIHJlbW92ZUVkZ2UpO1xuICAgIGRlbGV0ZSB0aGlzLl9vdXRbdl07XG4gICAgZGVsZXRlIHRoaXMuX3N1Y3Nbdl07XG4gICAgLS10aGlzLl9ub2RlQ291bnQ7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5HcmFwaC5wcm90b3R5cGUuc2V0UGFyZW50ID0gZnVuY3Rpb24odiwgcGFyZW50KSB7XG4gIGlmICghdGhpcy5faXNDb21wb3VuZCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBzZXQgcGFyZW50IGluIGEgbm9uLWNvbXBvdW5kIGdyYXBoXCIpO1xuICB9XG5cbiAgaWYgKF8uaXNVbmRlZmluZWQocGFyZW50KSkge1xuICAgIHBhcmVudCA9IEdSQVBIX05PREU7XG4gIH0gZWxzZSB7XG4gICAgLy8gQ29lcmNlIHBhcmVudCB0byBzdHJpbmdcbiAgICBwYXJlbnQgKz0gXCJcIjtcbiAgICBmb3IgKHZhciBhbmNlc3RvciA9IHBhcmVudDtcbiAgICAgICFfLmlzVW5kZWZpbmVkKGFuY2VzdG9yKTtcbiAgICAgIGFuY2VzdG9yID0gdGhpcy5wYXJlbnQoYW5jZXN0b3IpKSB7XG4gICAgICBpZiAoYW5jZXN0b3IgPT09IHYpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiU2V0dGluZyBcIiArIHBhcmVudCsgXCIgYXMgcGFyZW50IG9mIFwiICsgdiArXG4gICAgICAgICAgICAgICAgICAgICAgICBcIiB3b3VsZCBjcmVhdGUgYSBjeWNsZVwiKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLnNldE5vZGUocGFyZW50KTtcbiAgfVxuXG4gIHRoaXMuc2V0Tm9kZSh2KTtcbiAgdGhpcy5fcmVtb3ZlRnJvbVBhcmVudHNDaGlsZExpc3Qodik7XG4gIHRoaXMuX3BhcmVudFt2XSA9IHBhcmVudDtcbiAgdGhpcy5fY2hpbGRyZW5bcGFyZW50XVt2XSA9IHRydWU7XG4gIHJldHVybiB0aGlzO1xufTtcblxuR3JhcGgucHJvdG90eXBlLl9yZW1vdmVGcm9tUGFyZW50c0NoaWxkTGlzdCA9IGZ1bmN0aW9uKHYpIHtcbiAgZGVsZXRlIHRoaXMuX2NoaWxkcmVuW3RoaXMuX3BhcmVudFt2XV1bdl07XG59O1xuXG5HcmFwaC5wcm90b3R5cGUucGFyZW50ID0gZnVuY3Rpb24odikge1xuICBpZiAodGhpcy5faXNDb21wb3VuZCkge1xuICAgIHZhciBwYXJlbnQgPSB0aGlzLl9wYXJlbnRbdl07XG4gICAgaWYgKHBhcmVudCAhPT0gR1JBUEhfTk9ERSkge1xuICAgICAgcmV0dXJuIHBhcmVudDtcbiAgICB9XG4gIH1cbn07XG5cbkdyYXBoLnByb3RvdHlwZS5jaGlsZHJlbiA9IGZ1bmN0aW9uKHYpIHtcbiAgaWYgKF8uaXNVbmRlZmluZWQodikpIHtcbiAgICB2ID0gR1JBUEhfTk9ERTtcbiAgfVxuXG4gIGlmICh0aGlzLl9pc0NvbXBvdW5kKSB7XG4gICAgdmFyIGNoaWxkcmVuID0gdGhpcy5fY2hpbGRyZW5bdl07XG4gICAgaWYgKGNoaWxkcmVuKSB7XG4gICAgICByZXR1cm4gXy5rZXlzKGNoaWxkcmVuKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAodiA9PT0gR1JBUEhfTk9ERSkge1xuICAgIHJldHVybiB0aGlzLm5vZGVzKCk7XG4gIH0gZWxzZSBpZiAodGhpcy5oYXNOb2RlKHYpKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG59O1xuXG5HcmFwaC5wcm90b3R5cGUucHJlZGVjZXNzb3JzID0gZnVuY3Rpb24odikge1xuICB2YXIgcHJlZHNWID0gdGhpcy5fcHJlZHNbdl07XG4gIGlmIChwcmVkc1YpIHtcbiAgICByZXR1cm4gXy5rZXlzKHByZWRzVik7XG4gIH1cbn07XG5cbkdyYXBoLnByb3RvdHlwZS5zdWNjZXNzb3JzID0gZnVuY3Rpb24odikge1xuICB2YXIgc3Vjc1YgPSB0aGlzLl9zdWNzW3ZdO1xuICBpZiAoc3Vjc1YpIHtcbiAgICByZXR1cm4gXy5rZXlzKHN1Y3NWKTtcbiAgfVxufTtcblxuR3JhcGgucHJvdG90eXBlLm5laWdoYm9ycyA9IGZ1bmN0aW9uKHYpIHtcbiAgdmFyIHByZWRzID0gdGhpcy5wcmVkZWNlc3NvcnModik7XG4gIGlmIChwcmVkcykge1xuICAgIHJldHVybiBfLnVuaW9uKHByZWRzLCB0aGlzLnN1Y2Nlc3NvcnModikpO1xuICB9XG59O1xuXG5HcmFwaC5wcm90b3R5cGUuaXNMZWFmID0gZnVuY3Rpb24gKHYpIHtcbiAgdmFyIG5laWdoYm9ycztcbiAgaWYgKHRoaXMuaXNEaXJlY3RlZCgpKSB7XG4gICAgbmVpZ2hib3JzID0gdGhpcy5zdWNjZXNzb3JzKHYpO1xuICB9IGVsc2Uge1xuICAgIG5laWdoYm9ycyA9IHRoaXMubmVpZ2hib3JzKHYpO1xuICB9XG4gIHJldHVybiBuZWlnaGJvcnMubGVuZ3RoID09PSAwO1xufTtcblxuR3JhcGgucHJvdG90eXBlLmZpbHRlck5vZGVzID0gZnVuY3Rpb24oZmlsdGVyKSB7XG4gIHZhciBjb3B5ID0gbmV3IHRoaXMuY29uc3RydWN0b3Ioe1xuICAgIGRpcmVjdGVkOiB0aGlzLl9pc0RpcmVjdGVkLFxuICAgIG11bHRpZ3JhcGg6IHRoaXMuX2lzTXVsdGlncmFwaCxcbiAgICBjb21wb3VuZDogdGhpcy5faXNDb21wb3VuZFxuICB9KTtcblxuICBjb3B5LnNldEdyYXBoKHRoaXMuZ3JhcGgoKSk7XG5cbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBfLmVhY2godGhpcy5fbm9kZXMsIGZ1bmN0aW9uKHZhbHVlLCB2KSB7XG4gICAgaWYgKGZpbHRlcih2KSkge1xuICAgICAgY29weS5zZXROb2RlKHYsIHZhbHVlKTtcbiAgICB9XG4gIH0pO1xuXG4gIF8uZWFjaCh0aGlzLl9lZGdlT2JqcywgZnVuY3Rpb24oZSkge1xuICAgIGlmIChjb3B5Lmhhc05vZGUoZS52KSAmJiBjb3B5Lmhhc05vZGUoZS53KSkge1xuICAgICAgY29weS5zZXRFZGdlKGUsIHNlbGYuZWRnZShlKSk7XG4gICAgfVxuICB9KTtcblxuICB2YXIgcGFyZW50cyA9IHt9O1xuICBmdW5jdGlvbiBmaW5kUGFyZW50KHYpIHtcbiAgICB2YXIgcGFyZW50ID0gc2VsZi5wYXJlbnQodik7XG4gICAgaWYgKHBhcmVudCA9PT0gdW5kZWZpbmVkIHx8IGNvcHkuaGFzTm9kZShwYXJlbnQpKSB7XG4gICAgICBwYXJlbnRzW3ZdID0gcGFyZW50O1xuICAgICAgcmV0dXJuIHBhcmVudDtcbiAgICB9IGVsc2UgaWYgKHBhcmVudCBpbiBwYXJlbnRzKSB7XG4gICAgICByZXR1cm4gcGFyZW50c1twYXJlbnRdO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gZmluZFBhcmVudChwYXJlbnQpO1xuICAgIH1cbiAgfVxuXG4gIGlmICh0aGlzLl9pc0NvbXBvdW5kKSB7XG4gICAgXy5lYWNoKGNvcHkubm9kZXMoKSwgZnVuY3Rpb24odikge1xuICAgICAgY29weS5zZXRQYXJlbnQodiwgZmluZFBhcmVudCh2KSk7XG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gY29weTtcbn07XG5cbi8qID09PSBFZGdlIGZ1bmN0aW9ucyA9PT09PT09PT09ICovXG5cbkdyYXBoLnByb3RvdHlwZS5zZXREZWZhdWx0RWRnZUxhYmVsID0gZnVuY3Rpb24obmV3RGVmYXVsdCkge1xuICBpZiAoIV8uaXNGdW5jdGlvbihuZXdEZWZhdWx0KSkge1xuICAgIG5ld0RlZmF1bHQgPSBfLmNvbnN0YW50KG5ld0RlZmF1bHQpO1xuICB9XG4gIHRoaXMuX2RlZmF1bHRFZGdlTGFiZWxGbiA9IG5ld0RlZmF1bHQ7XG4gIHJldHVybiB0aGlzO1xufTtcblxuR3JhcGgucHJvdG90eXBlLmVkZ2VDb3VudCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5fZWRnZUNvdW50O1xufTtcblxuR3JhcGgucHJvdG90eXBlLmVkZ2VzID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBfLnZhbHVlcyh0aGlzLl9lZGdlT2Jqcyk7XG59O1xuXG5HcmFwaC5wcm90b3R5cGUuc2V0UGF0aCA9IGZ1bmN0aW9uKHZzLCB2YWx1ZSkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciBhcmdzID0gYXJndW1lbnRzO1xuICBfLnJlZHVjZSh2cywgZnVuY3Rpb24odiwgdykge1xuICAgIGlmIChhcmdzLmxlbmd0aCA+IDEpIHtcbiAgICAgIHNlbGYuc2V0RWRnZSh2LCB3LCB2YWx1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNlbGYuc2V0RWRnZSh2LCB3KTtcbiAgICB9XG4gICAgcmV0dXJuIHc7XG4gIH0pO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qXG4gKiBzZXRFZGdlKHYsIHcsIFt2YWx1ZSwgW25hbWVdXSlcbiAqIHNldEVkZ2UoeyB2LCB3LCBbbmFtZV0gfSwgW3ZhbHVlXSlcbiAqL1xuR3JhcGgucHJvdG90eXBlLnNldEVkZ2UgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHYsIHcsIG5hbWUsIHZhbHVlO1xuICB2YXIgdmFsdWVTcGVjaWZpZWQgPSBmYWxzZTtcbiAgdmFyIGFyZzAgPSBhcmd1bWVudHNbMF07XG5cbiAgaWYgKHR5cGVvZiBhcmcwID09PSBcIm9iamVjdFwiICYmIGFyZzAgIT09IG51bGwgJiYgXCJ2XCIgaW4gYXJnMCkge1xuICAgIHYgPSBhcmcwLnY7XG4gICAgdyA9IGFyZzAudztcbiAgICBuYW1lID0gYXJnMC5uYW1lO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAyKSB7XG4gICAgICB2YWx1ZSA9IGFyZ3VtZW50c1sxXTtcbiAgICAgIHZhbHVlU3BlY2lmaWVkID0gdHJ1ZTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdiA9IGFyZzA7XG4gICAgdyA9IGFyZ3VtZW50c1sxXTtcbiAgICBuYW1lID0gYXJndW1lbnRzWzNdO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMikge1xuICAgICAgdmFsdWUgPSBhcmd1bWVudHNbMl07XG4gICAgICB2YWx1ZVNwZWNpZmllZCA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgdiA9IFwiXCIgKyB2O1xuICB3ID0gXCJcIiArIHc7XG4gIGlmICghXy5pc1VuZGVmaW5lZChuYW1lKSkge1xuICAgIG5hbWUgPSBcIlwiICsgbmFtZTtcbiAgfVxuXG4gIHZhciBlID0gZWRnZUFyZ3NUb0lkKHRoaXMuX2lzRGlyZWN0ZWQsIHYsIHcsIG5hbWUpO1xuICBpZiAoXy5oYXModGhpcy5fZWRnZUxhYmVscywgZSkpIHtcbiAgICBpZiAodmFsdWVTcGVjaWZpZWQpIHtcbiAgICAgIHRoaXMuX2VkZ2VMYWJlbHNbZV0gPSB2YWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBpZiAoIV8uaXNVbmRlZmluZWQobmFtZSkgJiYgIXRoaXMuX2lzTXVsdGlncmFwaCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBzZXQgYSBuYW1lZCBlZGdlIHdoZW4gaXNNdWx0aWdyYXBoID0gZmFsc2VcIik7XG4gIH1cblxuICAvLyBJdCBkaWRuJ3QgZXhpc3QsIHNvIHdlIG5lZWQgdG8gY3JlYXRlIGl0LlxuICAvLyBGaXJzdCBlbnN1cmUgdGhlIG5vZGVzIGV4aXN0LlxuICB0aGlzLnNldE5vZGUodik7XG4gIHRoaXMuc2V0Tm9kZSh3KTtcblxuICB0aGlzLl9lZGdlTGFiZWxzW2VdID0gdmFsdWVTcGVjaWZpZWQgPyB2YWx1ZSA6IHRoaXMuX2RlZmF1bHRFZGdlTGFiZWxGbih2LCB3LCBuYW1lKTtcblxuICB2YXIgZWRnZU9iaiA9IGVkZ2VBcmdzVG9PYmoodGhpcy5faXNEaXJlY3RlZCwgdiwgdywgbmFtZSk7XG4gIC8vIEVuc3VyZSB3ZSBhZGQgdW5kaXJlY3RlZCBlZGdlcyBpbiBhIGNvbnNpc3RlbnQgd2F5LlxuICB2ID0gZWRnZU9iai52O1xuICB3ID0gZWRnZU9iai53O1xuXG4gIE9iamVjdC5mcmVlemUoZWRnZU9iaik7XG4gIHRoaXMuX2VkZ2VPYmpzW2VdID0gZWRnZU9iajtcbiAgaW5jcmVtZW50T3JJbml0RW50cnkodGhpcy5fcHJlZHNbd10sIHYpO1xuICBpbmNyZW1lbnRPckluaXRFbnRyeSh0aGlzLl9zdWNzW3ZdLCB3KTtcbiAgdGhpcy5faW5bd11bZV0gPSBlZGdlT2JqO1xuICB0aGlzLl9vdXRbdl1bZV0gPSBlZGdlT2JqO1xuICB0aGlzLl9lZGdlQ291bnQrKztcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5HcmFwaC5wcm90b3R5cGUuZWRnZSA9IGZ1bmN0aW9uKHYsIHcsIG5hbWUpIHtcbiAgdmFyIGUgPSAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMVxuICAgID8gZWRnZU9ialRvSWQodGhpcy5faXNEaXJlY3RlZCwgYXJndW1lbnRzWzBdKVxuICAgIDogZWRnZUFyZ3NUb0lkKHRoaXMuX2lzRGlyZWN0ZWQsIHYsIHcsIG5hbWUpKTtcbiAgcmV0dXJuIHRoaXMuX2VkZ2VMYWJlbHNbZV07XG59O1xuXG5HcmFwaC5wcm90b3R5cGUuaGFzRWRnZSA9IGZ1bmN0aW9uKHYsIHcsIG5hbWUpIHtcbiAgdmFyIGUgPSAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMVxuICAgID8gZWRnZU9ialRvSWQodGhpcy5faXNEaXJlY3RlZCwgYXJndW1lbnRzWzBdKVxuICAgIDogZWRnZUFyZ3NUb0lkKHRoaXMuX2lzRGlyZWN0ZWQsIHYsIHcsIG5hbWUpKTtcbiAgcmV0dXJuIF8uaGFzKHRoaXMuX2VkZ2VMYWJlbHMsIGUpO1xufTtcblxuR3JhcGgucHJvdG90eXBlLnJlbW92ZUVkZ2UgPSBmdW5jdGlvbih2LCB3LCBuYW1lKSB7XG4gIHZhciBlID0gKGFyZ3VtZW50cy5sZW5ndGggPT09IDFcbiAgICA/IGVkZ2VPYmpUb0lkKHRoaXMuX2lzRGlyZWN0ZWQsIGFyZ3VtZW50c1swXSlcbiAgICA6IGVkZ2VBcmdzVG9JZCh0aGlzLl9pc0RpcmVjdGVkLCB2LCB3LCBuYW1lKSk7XG4gIHZhciBlZGdlID0gdGhpcy5fZWRnZU9ianNbZV07XG4gIGlmIChlZGdlKSB7XG4gICAgdiA9IGVkZ2UudjtcbiAgICB3ID0gZWRnZS53O1xuICAgIGRlbGV0ZSB0aGlzLl9lZGdlTGFiZWxzW2VdO1xuICAgIGRlbGV0ZSB0aGlzLl9lZGdlT2Jqc1tlXTtcbiAgICBkZWNyZW1lbnRPclJlbW92ZUVudHJ5KHRoaXMuX3ByZWRzW3ddLCB2KTtcbiAgICBkZWNyZW1lbnRPclJlbW92ZUVudHJ5KHRoaXMuX3N1Y3Nbdl0sIHcpO1xuICAgIGRlbGV0ZSB0aGlzLl9pblt3XVtlXTtcbiAgICBkZWxldGUgdGhpcy5fb3V0W3ZdW2VdO1xuICAgIHRoaXMuX2VkZ2VDb3VudC0tO1xuICB9XG4gIHJldHVybiB0aGlzO1xufTtcblxuR3JhcGgucHJvdG90eXBlLmluRWRnZXMgPSBmdW5jdGlvbih2LCB1KSB7XG4gIHZhciBpblYgPSB0aGlzLl9pblt2XTtcbiAgaWYgKGluVikge1xuICAgIHZhciBlZGdlcyA9IF8udmFsdWVzKGluVik7XG4gICAgaWYgKCF1KSB7XG4gICAgICByZXR1cm4gZWRnZXM7XG4gICAgfVxuICAgIHJldHVybiBfLmZpbHRlcihlZGdlcywgZnVuY3Rpb24oZWRnZSkgeyByZXR1cm4gZWRnZS52ID09PSB1OyB9KTtcbiAgfVxufTtcblxuR3JhcGgucHJvdG90eXBlLm91dEVkZ2VzID0gZnVuY3Rpb24odiwgdykge1xuICB2YXIgb3V0ViA9IHRoaXMuX291dFt2XTtcbiAgaWYgKG91dFYpIHtcbiAgICB2YXIgZWRnZXMgPSBfLnZhbHVlcyhvdXRWKTtcbiAgICBpZiAoIXcpIHtcbiAgICAgIHJldHVybiBlZGdlcztcbiAgICB9XG4gICAgcmV0dXJuIF8uZmlsdGVyKGVkZ2VzLCBmdW5jdGlvbihlZGdlKSB7IHJldHVybiBlZGdlLncgPT09IHc7IH0pO1xuICB9XG59O1xuXG5HcmFwaC5wcm90b3R5cGUubm9kZUVkZ2VzID0gZnVuY3Rpb24odiwgdykge1xuICB2YXIgaW5FZGdlcyA9IHRoaXMuaW5FZGdlcyh2LCB3KTtcbiAgaWYgKGluRWRnZXMpIHtcbiAgICByZXR1cm4gaW5FZGdlcy5jb25jYXQodGhpcy5vdXRFZGdlcyh2LCB3KSk7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIGluY3JlbWVudE9ySW5pdEVudHJ5KG1hcCwgaykge1xuICBpZiAobWFwW2tdKSB7XG4gICAgbWFwW2tdKys7XG4gIH0gZWxzZSB7XG4gICAgbWFwW2tdID0gMTtcbiAgfVxufVxuXG5mdW5jdGlvbiBkZWNyZW1lbnRPclJlbW92ZUVudHJ5KG1hcCwgaykge1xuICBpZiAoIS0tbWFwW2tdKSB7IGRlbGV0ZSBtYXBba107IH1cbn1cblxuZnVuY3Rpb24gZWRnZUFyZ3NUb0lkKGlzRGlyZWN0ZWQsIHZfLCB3XywgbmFtZSkge1xuICB2YXIgdiA9IFwiXCIgKyB2XztcbiAgdmFyIHcgPSBcIlwiICsgd187XG4gIGlmICghaXNEaXJlY3RlZCAmJiB2ID4gdykge1xuICAgIHZhciB0bXAgPSB2O1xuICAgIHYgPSB3O1xuICAgIHcgPSB0bXA7XG4gIH1cbiAgcmV0dXJuIHYgKyBFREdFX0tFWV9ERUxJTSArIHcgKyBFREdFX0tFWV9ERUxJTSArXG4gICAgICAgICAgICAgKF8uaXNVbmRlZmluZWQobmFtZSkgPyBERUZBVUxUX0VER0VfTkFNRSA6IG5hbWUpO1xufVxuXG5mdW5jdGlvbiBlZGdlQXJnc1RvT2JqKGlzRGlyZWN0ZWQsIHZfLCB3XywgbmFtZSkge1xuICB2YXIgdiA9IFwiXCIgKyB2XztcbiAgdmFyIHcgPSBcIlwiICsgd187XG4gIGlmICghaXNEaXJlY3RlZCAmJiB2ID4gdykge1xuICAgIHZhciB0bXAgPSB2O1xuICAgIHYgPSB3O1xuICAgIHcgPSB0bXA7XG4gIH1cbiAgdmFyIGVkZ2VPYmogPSAgeyB2OiB2LCB3OiB3IH07XG4gIGlmIChuYW1lKSB7XG4gICAgZWRnZU9iai5uYW1lID0gbmFtZTtcbiAgfVxuICByZXR1cm4gZWRnZU9iajtcbn1cblxuZnVuY3Rpb24gZWRnZU9ialRvSWQoaXNEaXJlY3RlZCwgZWRnZU9iaikge1xuICByZXR1cm4gZWRnZUFyZ3NUb0lkKGlzRGlyZWN0ZWQsIGVkZ2VPYmoudiwgZWRnZU9iai53LCBlZGdlT2JqLm5hbWUpO1xufVxuIiwiLy8gSW5jbHVkZXMgb25seSB0aGUgXCJjb3JlXCIgb2YgZ3JhcGhsaWJcbm1vZHVsZS5leHBvcnRzID0ge1xuICBHcmFwaDogcmVxdWlyZShcIi4vZ3JhcGhcIiksXG4gIHZlcnNpb246IHJlcXVpcmUoXCIuL3ZlcnNpb25cIilcbn07XG4iLCJ2YXIgXyA9IHJlcXVpcmUoXCIuL2xvZGFzaFwiKTtcbnZhciBHcmFwaCA9IHJlcXVpcmUoXCIuL2dyYXBoXCIpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgd3JpdGU6IHdyaXRlLFxuICByZWFkOiByZWFkXG59O1xuXG5mdW5jdGlvbiB3cml0ZShnKSB7XG4gIHZhciBqc29uID0ge1xuICAgIG9wdGlvbnM6IHtcbiAgICAgIGRpcmVjdGVkOiBnLmlzRGlyZWN0ZWQoKSxcbiAgICAgIG11bHRpZ3JhcGg6IGcuaXNNdWx0aWdyYXBoKCksXG4gICAgICBjb21wb3VuZDogZy5pc0NvbXBvdW5kKClcbiAgICB9LFxuICAgIG5vZGVzOiB3cml0ZU5vZGVzKGcpLFxuICAgIGVkZ2VzOiB3cml0ZUVkZ2VzKGcpXG4gIH07XG4gIGlmICghXy5pc1VuZGVmaW5lZChnLmdyYXBoKCkpKSB7XG4gICAganNvbi52YWx1ZSA9IF8uY2xvbmUoZy5ncmFwaCgpKTtcbiAgfVxuICByZXR1cm4ganNvbjtcbn1cblxuZnVuY3Rpb24gd3JpdGVOb2RlcyhnKSB7XG4gIHJldHVybiBfLm1hcChnLm5vZGVzKCksIGZ1bmN0aW9uKHYpIHtcbiAgICB2YXIgbm9kZVZhbHVlID0gZy5ub2RlKHYpO1xuICAgIHZhciBwYXJlbnQgPSBnLnBhcmVudCh2KTtcbiAgICB2YXIgbm9kZSA9IHsgdjogdiB9O1xuICAgIGlmICghXy5pc1VuZGVmaW5lZChub2RlVmFsdWUpKSB7XG4gICAgICBub2RlLnZhbHVlID0gbm9kZVZhbHVlO1xuICAgIH1cbiAgICBpZiAoIV8uaXNVbmRlZmluZWQocGFyZW50KSkge1xuICAgICAgbm9kZS5wYXJlbnQgPSBwYXJlbnQ7XG4gICAgfVxuICAgIHJldHVybiBub2RlO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gd3JpdGVFZGdlcyhnKSB7XG4gIHJldHVybiBfLm1hcChnLmVkZ2VzKCksIGZ1bmN0aW9uKGUpIHtcbiAgICB2YXIgZWRnZVZhbHVlID0gZy5lZGdlKGUpO1xuICAgIHZhciBlZGdlID0geyB2OiBlLnYsIHc6IGUudyB9O1xuICAgIGlmICghXy5pc1VuZGVmaW5lZChlLm5hbWUpKSB7XG4gICAgICBlZGdlLm5hbWUgPSBlLm5hbWU7XG4gICAgfVxuICAgIGlmICghXy5pc1VuZGVmaW5lZChlZGdlVmFsdWUpKSB7XG4gICAgICBlZGdlLnZhbHVlID0gZWRnZVZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gZWRnZTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHJlYWQoanNvbikge1xuICB2YXIgZyA9IG5ldyBHcmFwaChqc29uLm9wdGlvbnMpLnNldEdyYXBoKGpzb24udmFsdWUpO1xuICBfLmVhY2goanNvbi5ub2RlcywgZnVuY3Rpb24oZW50cnkpIHtcbiAgICBnLnNldE5vZGUoZW50cnkudiwgZW50cnkudmFsdWUpO1xuICAgIGlmIChlbnRyeS5wYXJlbnQpIHtcbiAgICAgIGcuc2V0UGFyZW50KGVudHJ5LnYsIGVudHJ5LnBhcmVudCk7XG4gICAgfVxuICB9KTtcbiAgXy5lYWNoKGpzb24uZWRnZXMsIGZ1bmN0aW9uKGVudHJ5KSB7XG4gICAgZy5zZXRFZGdlKHsgdjogZW50cnkudiwgdzogZW50cnkudywgbmFtZTogZW50cnkubmFtZSB9LCBlbnRyeS52YWx1ZSk7XG4gIH0pO1xuICByZXR1cm4gZztcbn1cbiIsIi8qIGdsb2JhbCB3aW5kb3cgKi9cblxudmFyIGxvZGFzaDtcblxuaWYgKHR5cGVvZiByZXF1aXJlID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgdHJ5IHtcbiAgICBsb2Rhc2ggPSB7XG4gICAgICBjbG9uZTogcmVxdWlyZShcImxvZGFzaC9jbG9uZVwiKSxcbiAgICAgIGNvbnN0YW50OiByZXF1aXJlKFwibG9kYXNoL2NvbnN0YW50XCIpLFxuICAgICAgZWFjaDogcmVxdWlyZShcImxvZGFzaC9lYWNoXCIpLFxuICAgICAgZmlsdGVyOiByZXF1aXJlKFwibG9kYXNoL2ZpbHRlclwiKSxcbiAgICAgIGhhczogIHJlcXVpcmUoXCJsb2Rhc2gvaGFzXCIpLFxuICAgICAgaXNBcnJheTogcmVxdWlyZShcImxvZGFzaC9pc0FycmF5XCIpLFxuICAgICAgaXNFbXB0eTogcmVxdWlyZShcImxvZGFzaC9pc0VtcHR5XCIpLFxuICAgICAgaXNGdW5jdGlvbjogcmVxdWlyZShcImxvZGFzaC9pc0Z1bmN0aW9uXCIpLFxuICAgICAgaXNVbmRlZmluZWQ6IHJlcXVpcmUoXCJsb2Rhc2gvaXNVbmRlZmluZWRcIiksXG4gICAgICBrZXlzOiByZXF1aXJlKFwibG9kYXNoL2tleXNcIiksXG4gICAgICBtYXA6IHJlcXVpcmUoXCJsb2Rhc2gvbWFwXCIpLFxuICAgICAgcmVkdWNlOiByZXF1aXJlKFwibG9kYXNoL3JlZHVjZVwiKSxcbiAgICAgIHNpemU6IHJlcXVpcmUoXCJsb2Rhc2gvc2l6ZVwiKSxcbiAgICAgIHRyYW5zZm9ybTogcmVxdWlyZShcImxvZGFzaC90cmFuc2Zvcm1cIiksXG4gICAgICB1bmlvbjogcmVxdWlyZShcImxvZGFzaC91bmlvblwiKSxcbiAgICAgIHZhbHVlczogcmVxdWlyZShcImxvZGFzaC92YWx1ZXNcIilcbiAgICB9O1xuICB9IGNhdGNoIChlKSB7XG4gICAgLy8gY29udGludWUgcmVnYXJkbGVzcyBvZiBlcnJvclxuICB9XG59XG5cbmlmICghbG9kYXNoKSB7XG4gIGxvZGFzaCA9IHdpbmRvdy5fO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGxvZGFzaDtcbiIsIm1vZHVsZS5leHBvcnRzID0gJzIuMS44JztcbiIsIlwidXNlIHN0cmljdFwiO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmV4cG9ydHMuY3JlYXRlRGVwZW5kZW5jeURpYWdyYW0gPSB2b2lkIDA7XHJcbmNvbnN0IHR0ID0gcmVxdWlyZShcInRhaXR0b1wiKTtcclxubGV0IHN2ZyA9IHR0LnN2ZztcclxubGV0IGFycm93ID0ge1xyXG4gICAgY2xvc2VkOiBmYWxzZSxcclxuICAgIGNsYXNzTmFtZTogXCJhcnJvd1wiLFxyXG4gICAgcG9zaXRpb25zOiBbdHQuQXJyb3dQb3MuRGVzdGluYXRpb25dLFxyXG4gICAgd2lkdGg6IDUsXHJcbiAgICBsZW5ndGg6IDVcclxufTtcclxuYXN5bmMgZnVuY3Rpb24gbG9hZERlcGVuZGVuY2llcyh1cmwpIHtcclxuICAgIGxldCByZXNwID0gYXdhaXQgZmV0Y2godXJsKTtcclxuICAgIHJldHVybiByZXNwLm9rID8gSlNPTi5wYXJzZShhd2FpdCByZXNwLnRleHQoKSkgOiBudWxsO1xyXG59XHJcbmFzeW5jIGZ1bmN0aW9uIGNyZWF0ZURlcGVuZGVuY3lEaWFncmFtKHBhcmFtcywgcGFyZW50KSB7XHJcbiAgICBsZXQgcGFycyA9IHBhcmFtcy5zcGxpdCgvXFxzKy8pO1xyXG4gICAgbGV0IHVybCA9IHBhcnNbMF07XHJcbiAgICBsZXQgZmlsdGVyID0gcGFyc1sxXSAmJiBuZXcgUmVnRXhwKHBhcnNbMV0pO1xyXG4gICAgbGV0IHJlZGlyID0gdXJsLnN1YnN0cigwLCB1cmwubGFzdEluZGV4T2YoXCIvXCIpKTtcclxuICAgIGxldCBkZ3JhcGggPSBhd2FpdCBsb2FkRGVwZW5kZW5jaWVzKHVybCk7XHJcbiAgICBpZiAoIWRncmFwaClcclxuICAgICAgICB0aHJvdyBFcnJvcihgQ291bGQgbm90IGxvYWQgZGVwZW5kZW5jeSBncmFwaCBmcm9tIFwiJHt1cmx9XCJgKTtcclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGxldCBtb2R1bGVzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoZGdyYXBoKVxyXG4gICAgICAgICAgICAuZmlsdGVyKG4gPT4gIWZpbHRlciB8fCBuLm1hdGNoKGZpbHRlcikpO1xyXG4gICAgICAgIGxldCBub2RlcyA9IG1vZHVsZXMubWFwKG5hbWUgPT4ge1xyXG4gICAgICAgICAgICBsZXQgbW9kdWxlID0gZGdyYXBoW25hbWVdO1xyXG4gICAgICAgICAgICBsZXQgbm9kZSA9IHtcclxuICAgICAgICAgICAgICAgIG5hbWUsXHJcbiAgICAgICAgICAgICAgICBsYWJlbDogbmFtZSxcclxuICAgICAgICAgICAgICAgIGxpbms6IG1vZHVsZS51cmwgPyByZWRpciArIFwiL1wiICsgbW9kdWxlLnVybCA6IHVuZGVmaW5lZCxcclxuICAgICAgICAgICAgICAgIHNoYXBlOiAocCwgeCwgeSwgdywgaCkgPT4gc3ZnLnJlY3QocCwgeCwgeSwgdywgaCwgOCwgOClcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgbW9kdWxlLm5vZGUgPSBub2RlO1xyXG4gICAgICAgICAgICByZXR1cm4gbm9kZTtcclxuICAgICAgICB9KTtcclxuICAgICAgICBsZXQgZWRnZXMgPSB0dC5lZGdlcyhtb2R1bGVzLm1hcChuYW1lID0+IGRncmFwaFtuYW1lXS5kZXBlbmRlbmNpZXMuZmlsdGVyKGRlcCA9PiBkZ3JhcGhbZGVwXS5ub2RlKVxyXG4gICAgICAgICAgICAubWFwKGRlcCA9PiBbZGdyYXBoW25hbWVdLm5vZGUsIGRncmFwaFtkZXBdLm5vZGVdKSlcclxuICAgICAgICAgICAgLnJlZHVjZSgoYSwgYikgPT4gYS5jb25jYXQoYikpLCBhcnJvdyk7XHJcbiAgICAgICAgdHQuZGlncmFwaCh7XHJcbiAgICAgICAgICAgIG5vZGVzLFxyXG4gICAgICAgICAgICBlZGdlcyxcclxuICAgICAgICAgICAgZGlyZWN0aW9uOiAnTFInLFxyXG4gICAgICAgICAgICBjdXJ2ZWRFZGdlczogdHJ1ZSxcclxuICAgICAgICAgICAgcmFua3NlcDogMTYsXHJcbiAgICAgICAgICAgIG5vZGVzZXA6IDMyXHJcbiAgICAgICAgfSwgcGFyZW50KTtcclxuICAgIH1cclxufVxyXG5leHBvcnRzLmNyZWF0ZURlcGVuZGVuY3lEaWFncmFtID0gY3JlYXRlRGVwZW5kZW5jeURpYWdyYW07XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRlcGVuZGVuY3ktZGlhZy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcclxudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xyXG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9KTtcclxufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcclxuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XHJcbiAgICBvW2syXSA9IG1ba107XHJcbn0pKTtcclxudmFyIF9fZXhwb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19leHBvcnRTdGFyKSB8fCBmdW5jdGlvbihtLCBleHBvcnRzKSB7XHJcbiAgICBmb3IgKHZhciBwIGluIG0pIGlmIChwICE9PSBcImRlZmF1bHRcIiAmJiAhT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGV4cG9ydHMsIHApKSBfX2NyZWF0ZUJpbmRpbmcoZXhwb3J0cywgbSwgcCk7XHJcbn07XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2RlcGVuZGVuY3ktZGlhZ1wiKSwgZXhwb3J0cyk7XHJcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi90ZXN0LXZpc3VhbGl6ZXJcIiksIGV4cG9ydHMpO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5leHBvcnRzLmNyZWF0ZVJlcG9ydGVyID0gdm9pZCAwO1xyXG5mdW5jdGlvbiBjcmVhdGVUZXN0KG5hbWUpIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgbmFtZSxcclxuICAgICAgICBwYXNzZXM6IDAsXHJcbiAgICAgICAgZmFpbHM6IDAsXHJcbiAgICAgICAgZHVyYXRpb246IDAsXHJcbiAgICAgICAgdGVzdHM6IFtdLFxyXG4gICAgICAgIGFzc2VydGlvbnM6IFtdXHJcbiAgICB9O1xyXG59XHJcbmZ1bmN0aW9uIGNyZWF0ZVJlcG9ydGVyKG5hbWUsIHJlbmRlcikge1xyXG4gICAgbGV0IHJvb3RUZXN0ID0gY3JlYXRlVGVzdChuYW1lKTtcclxuICAgIGxldCB0ZXN0c3RhY2sgPSBbcm9vdFRlc3RdO1xyXG4gICAgcmV0dXJuIGFzeW5jIChzdHJlYW0pID0+IHtcclxuICAgICAgICBmb3IgYXdhaXQgKGxldCBtZXNzYWdlIG9mIHN0cmVhbSkge1xyXG4gICAgICAgICAgICBzd2l0Y2ggKG1lc3NhZ2UudHlwZSkge1xyXG4gICAgICAgICAgICAgICAgY2FzZSBcIlRFU1RfU1RBUlRcIiAvKiBURVNUX1NUQVJUICovOlxyXG4gICAgICAgICAgICAgICAgICAgIGxldCBuZXd0ZXN0ID0gY3JlYXRlVGVzdChtZXNzYWdlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5kYXRhLmRlc2NyaXB0aW9uKTtcclxuICAgICAgICAgICAgICAgICAgICB0ZXN0c3RhY2tbdGVzdHN0YWNrLmxlbmd0aCAtIDFdLnRlc3RzLnB1c2gobmV3dGVzdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGVzdHN0YWNrLnB1c2gobmV3dGVzdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIFwiVEVTVF9FTkRcIiAvKiBURVNUX0VORCAqLzpcclxuICAgICAgICAgICAgICAgICAgICBsZXQgenRlc3QgPSBtZXNzYWdlLmRhdGE7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IHRlc3QgPSB0ZXN0c3RhY2sucG9wKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGVzdC5wYXNzID0genRlc3QucGFzcztcclxuICAgICAgICAgICAgICAgICAgICB0ZXN0LnBhc3NlcyA9IHp0ZXN0LnN1Y2Nlc3NDb3VudDtcclxuICAgICAgICAgICAgICAgICAgICB0ZXN0LmZhaWxzID0genRlc3QuZmFpbHVyZUNvdW50O1xyXG4gICAgICAgICAgICAgICAgICAgIHRlc3QuZXJyb3IgPSB6dGVzdC5lcnJvcjtcclxuICAgICAgICAgICAgICAgICAgICB0ZXN0LmR1cmF0aW9uID0genRlc3QuZXhlY3V0aW9uVGltZTtcclxuICAgICAgICAgICAgICAgICAgICByZW5kZXIocm9vdFRlc3QpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBcIkFTU0VSVElPTlwiIC8qIEFTU0VSVElPTiAqLzpcclxuICAgICAgICAgICAgICAgICAgICBsZXQgemFzcyA9IG1lc3NhZ2UuZGF0YTtcclxuICAgICAgICAgICAgICAgICAgICB0ZXN0c3RhY2tbdGVzdHN0YWNrLmxlbmd0aCAtIDFdLmFzc2VydGlvbnMucHVzaCh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IHphc3MuZGVzY3JpcHRpb24sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhc3M6IHphc3MucGFzc1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBcIkJBSUxfT1VUXCIgLyogQkFJTF9PVVQgKi86XHJcbiAgICAgICAgICAgICAgICAgICAgdGVzdHN0YWNrW3Rlc3RzdGFjay5sZW5ndGggLSAxXS5lcnJvciA9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuZGF0YTtcclxuICAgICAgICAgICAgICAgICAgICByZW5kZXIocm9vdFRlc3QpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxufVxyXG5leHBvcnRzLmNyZWF0ZVJlcG9ydGVyID0gY3JlYXRlUmVwb3J0ZXI7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRlc3QtcmVwb3J0ZXIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuZXhwb3J0cy5ydW5UZXN0cyA9IHZvaWQgMDtcclxuY29uc3QgdHIgPSByZXF1aXJlKFwiLi90ZXN0LXJlcG9ydGVyXCIpO1xyXG5jb25zdCB0ZXN0ZXIgPSByZXF1aXJlKFwiLi90ZXN0ZXJcIik7XHJcbmZ1bmN0aW9uIHJ1blRlc3RzKHBhcmFtcywgcGFyZW50KSB7XHJcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignbG9hZCcsICgpID0+IHRlc3Rlci5nZXRIYXJuZXNzKCkucmVwb3J0KHRyLmNyZWF0ZVJlcG9ydGVyKHBhcmFtcywgc3RhdHVzID0+IHtcclxuICAgICAgICB3aGlsZSAocGFyZW50LmZpcnN0Q2hpbGQpXHJcbiAgICAgICAgICAgIHBhcmVudC5maXJzdENoaWxkLnJlbW92ZSgpO1xyXG4gICAgICAgIHBhcmVudC5hcHBlbmRDaGlsZCh0ZXN0U3RhdHVzKHN0YXR1cykpO1xyXG4gICAgfSkpKTtcclxufVxyXG5leHBvcnRzLnJ1blRlc3RzID0gcnVuVGVzdHM7XHJcbmZ1bmN0aW9uIGVsZW0odGFnTmFtZSwgY2xzLCB0ZXh0KSB7XHJcbiAgICBsZXQgcmVzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0YWdOYW1lKTtcclxuICAgIGlmIChjbHMpXHJcbiAgICAgICAgcmVzLmNsYXNzTGlzdC5hZGQoY2xzKTtcclxuICAgIGlmICh0ZXh0KVxyXG4gICAgICAgIHJlcy5pbm5lclRleHQgPSB0ZXh0O1xyXG4gICAgcmV0dXJuIHJlcztcclxufVxyXG5mdW5jdGlvbiBzdGF0dXNJY29uKGFzc2VydGlvbikge1xyXG4gICAgcmV0dXJuIGFzc2VydGlvbi5wYXNzID8gXCLinIVcIiA6IFwi4p2MXCI7XHJcbn1cclxuZnVuY3Rpb24gdGVzdFN0eWxlKHRlc3QpIHtcclxuICAgIHJldHVybiB0ZXN0LnBhc3MgPyAnI2Y4ZmZmOCcgOiAnI2ZmZjhmOCc7XHJcbn1cclxuZnVuY3Rpb24gdGVzdFN0YXR1cyhyb290VGVzdCkge1xyXG4gICAgbGV0IHZpcyA9IGVsZW0oXCJkaXZcIiwgXCJ0ZXN0LXZpc3VhbGl6ZXJcIik7XHJcbiAgICB2aXMuc3R5bGUuYmFja2dyb3VuZENvbG9yID0gdGVzdFN0eWxlKHJvb3RUZXN0KTtcclxuICAgIGxldCBzdW0gPSBlbGVtKFwiZGl2XCIsIFwic3VtbWFyeVwiLCBgJHtzdGF0dXNJY29uKHJvb3RUZXN0KX0gJHtyb290VGVzdC5uYW1lfWApO1xyXG4gICAgc3VtLmFwcGVuZENoaWxkKGVsZW0oXCJzcGFuXCIsIFwiY291bnRcIiwgYFBhc3M6ICR7cm9vdFRlc3QucGFzc2VzfWApKTtcclxuICAgIHN1bS5hcHBlbmRDaGlsZChlbGVtKFwic3BhblwiLCBcImNvdW50XCIsIGBGYWlsOiAke3Jvb3RUZXN0LmZhaWxzfWApKTtcclxuICAgIHZpcy5hcHBlbmRDaGlsZChzdW0pO1xyXG4gICAgdmlzLmFwcGVuZENoaWxkKHRlc3RMaXN0KHJvb3RUZXN0LnRlc3RzKSk7XHJcbiAgICByZXR1cm4gdmlzO1xyXG59XHJcbmZ1bmN0aW9uIHRlc3RMaXN0KHRlc3RzKSB7XHJcbiAgICBsZXQgbHN0ID0gZWxlbShcIm9sXCIsIFwidGVzdC1saXN0XCIpO1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0ZXN0cy5sZW5ndGg7IGkrKylcclxuICAgICAgICBsc3QuYXBwZW5kQ2hpbGQodGVzdCh0ZXN0c1tpXSkpO1xyXG4gICAgcmV0dXJuIGxzdDtcclxufVxyXG5mdW5jdGlvbiBhc3NlcnRpb24oYXNzZXJ0aW9uKSB7XHJcbiAgICByZXR1cm4gZWxlbShcImxpXCIsIHVuZGVmaW5lZCwgYCR7c3RhdHVzSWNvbihhc3NlcnRpb24pfSAke2Fzc2VydGlvbi5uYW1lfWApO1xyXG59XHJcbmZ1bmN0aW9uIGFzc2VydGlvbnMoYXNzZXJ0aW9ucykge1xyXG4gICAgbGV0IGRldCA9IGVsZW0oXCJkZXRhaWxzXCIpO1xyXG4gICAgZGV0LmFwcGVuZENoaWxkKGVsZW0oXCJzdW1tYXJ5XCIsIHVuZGVmaW5lZCwgYCR7YXNzZXJ0aW9ucy5sZW5ndGh9IGFzc2VydGlvbnNgKSk7XHJcbiAgICBsZXQgb2wgPSBlbGVtKFwib2xcIik7XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFzc2VydGlvbnMubGVuZ3RoOyBpKyspXHJcbiAgICAgICAgb2wuYXBwZW5kQ2hpbGQoYXNzZXJ0aW9uKGFzc2VydGlvbnNbaV0pKTtcclxuICAgIGRldC5hcHBlbmRDaGlsZChvbCk7XHJcbiAgICByZXR1cm4gZGV0O1xyXG59XHJcbmZ1bmN0aW9uIHRlc3QodGVzdCkge1xyXG4gICAgaWYgKHRlc3QuZXJyb3IpXHJcbiAgICAgICAgcmV0dXJuIGJhaWxlZE91dFRlc3QodGVzdCk7XHJcbiAgICBsZXQgbGkgPSBlbGVtKFwibGlcIiwgdW5kZWZpbmVkLCBgJHtzdGF0dXNJY29uKHRlc3QpfSAke3Rlc3QubmFtZX0gaW4gJHt0ZXN0LmR1cmF0aW9ufW1zYCk7XHJcbiAgICBpZiAodGVzdC5hc3NlcnRpb25zKVxyXG4gICAgICAgIGxpLmFwcGVuZENoaWxkKGFzc2VydGlvbnModGVzdC5hc3NlcnRpb25zKSk7XHJcbiAgICBpZiAodGVzdC50ZXN0cylcclxuICAgICAgICBsaS5hcHBlbmRDaGlsZCh0ZXN0TGlzdCh0ZXN0LnRlc3RzKSk7XHJcbiAgICByZXR1cm4gbGk7XHJcbn1cclxuZnVuY3Rpb24gYmFpbGVkT3V0VGVzdCh0ZXN0KSB7XHJcbiAgICBsZXQgcmVzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImxpXCIpO1xyXG4gICAgcmVzLmlubmVySFRNTCA9XHJcbiAgICAgICAgYCR7c3RhdHVzSWNvbih0ZXN0KX0gJHt0ZXN0Lm5hbWV9IHRocmV3IDxiPiR7dGVzdC5lcnJvci5uYW1lfTwvYj4gZXhjZXB0aW9uOlxyXG4gICAgICAgIDxici8+PGI+JHt0ZXN0LmVycm9yLm1lc3NhZ2V9PC9iPlxyXG4gICAgICAgIDxwcmU+JHt0ZXN0LmVycm9yLnN0YWNrfTwvcHJlPmA7XHJcbiAgICByZXR1cm4gcmVzO1xyXG59XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRlc3QtdmlzdWFsaXplci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5leHBvcnRzLnRlc3QgPSBleHBvcnRzLmdldEhhcm5lc3MgPSB2b2lkIDA7XHJcbmNvbnN0IHpvcmEgPSByZXF1aXJlKFwiem9yYVwiKTtcclxubGV0IGhhcm5lc3MgPSB6b3JhLmNyZWF0ZUhhcm5lc3MoKTtcclxuaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKVxyXG4gICAgc2V0VGltZW91dChydW5UZXN0cywgMCk7XHJcbmZ1bmN0aW9uIGdldEhhcm5lc3MoKSB7XHJcbiAgICByZXR1cm4gaGFybmVzcztcclxufVxyXG5leHBvcnRzLmdldEhhcm5lc3MgPSBnZXRIYXJuZXNzO1xyXG5hc3luYyBmdW5jdGlvbiBydW5UZXN0cygpIHtcclxuICAgIHRyeSB7XHJcbiAgICAgICAgYXdhaXQgaGFybmVzcy5yZXBvcnQoem9yYS5tb2NoYVRhcExpa2UpO1xyXG4gICAgfVxyXG4gICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICBoYXJuZXNzLnBhc3MgPSBmYWxzZTtcclxuICAgICAgICBpZiAoZSBpbnN0YW5jZW9mIEVycm9yKSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZS5uYW1lICsgXCIgZXhjZXB0aW9uIHRocm93bjogXCIgKyBlLm1lc3NhZ2UpO1xyXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGUuc3RhY2spO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGlmIChoYXJuZXNzLnBhc3MpXHJcbiAgICAgICAgY29uc29sZS5sb2coJ1Rlc3RzIFBBU1NFRCcpO1xyXG4gICAgZWxzZVxyXG4gICAgICAgIGNvbnNvbGUubG9nKCdUZXN0cyBGQUlMRUQnKTtcclxuICAgIHByb2Nlc3MuZXhpdChoYXJuZXNzLnBhc3MgPyAwIDogMSk7XHJcbn1cclxuZnVuY3Rpb24gdGVzdChkZXNjcmlwdGlvbiwgc3BlYywgb3B0aW9ucykge1xyXG4gICAgcmV0dXJuIGhhcm5lc3MudGVzdChkZXNjcmlwdGlvbiwgc3BlYywgb3B0aW9ucyk7XHJcbn1cclxuZXhwb3J0cy50ZXN0ID0gdGVzdDtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dGVzdGVyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmV4cG9ydHMuZXJyb3IgPSBleHBvcnRzLmNvbnNvbGUgPSBleHBvcnRzLmh0bWwgPSBleHBvcnRzLnJlZ2lzdGVyVmlzdWFsaXplciA9IHZvaWQgMDtcclxuY29uc3QgdmlzdWFsaXplcnMgPSB7fTtcclxuLyoqXHJcbiAqICMjIFJlZ2lzdGVyaW5nIFZpc3VhbGl6ZXJzXHJcbiAqXHJcbiAqIEJlZm9yZSB5b3UgY2FuIHVzZSBhIHZpc3VhbGl6ZXIgeW91IG5lZWQgdG8gcmVnaXN0ZXIgaXQgdXNpbmcgdGhlIGZ1bmN0aW9uXHJcbiAqIGJlbG93LiBBbm90aGVyIHN0ZXAgdGhhdCBpcyByZXF1aXJlZCBpcyB0byBzcGVjaWZ5IHRoZSBmaWxlIHdoZXJlIHRoZVxyXG4gKiB2aXN1YWxpemVyIHJlc2lkZXMgaW4gdGhlIGBjb2RlRmlsZWAgc2V0dGluZyBvZiB0aGUgZnJvbnQgbWF0dGVyLiBUaGUgY29kZVxyXG4gKiBmaWxlIGNhbiBpbXBvcnQgb3RoZXIgbW9kdWxlcyBhbmQgaXQgbWlnaHQgYmUgd3JpdHRlbiBpbiBKYXZhU2NyaXB0IG9yXHJcbiAqIFR5cGVTY3JpcHQuIFRoZSBidW5kbGVyIHRyYW5zcGlsZXMgVFMgbW9kdWxlcyB0byBKUyBhbmQgcGFja3MgdGhlbSB0byBhXHJcbiAqIHNpbmdsZSBmaWxlLlxyXG4gKi9cclxuZnVuY3Rpb24gcmVnaXN0ZXJWaXN1YWxpemVyKG5hbWUsIHZpc3VhbCkge1xyXG4gICAgaWYgKG5hbWUubWF0Y2goL1xccy8pKVxyXG4gICAgICAgIHRocm93IFN5bnRheEVycm9yKGBWaXN1YWxpemVyIG5hbWUgXCIke25hbWV9XCIgY29udGFpbnMgd2hpdGVzcGFjZS5gKTtcclxuICAgIHZpc3VhbGl6ZXJzW25hbWVdID0gdmlzdWFsO1xyXG59XHJcbmV4cG9ydHMucmVnaXN0ZXJWaXN1YWxpemVyID0gcmVnaXN0ZXJWaXN1YWxpemVyO1xyXG4vKipcclxuICogIyMgQ3JlYXRpbmcgVmlzdWFsaXplcnNcclxuICpcclxuICogSXQgaXMgcG9zc2libGUgdG8gY3JlYXRlIHlvdXIgdmlzdWFsaXplcnMgZnJvbSBzY3JhdGNoIGJ5IGRlZmluaW5nIGFcclxuICogZnVuY3Rpb24gdGhhdCBpbXBsZW1lbnRzIHRoZSBzaWduYXR1cmUgZGVmaW5lZCBhYm92ZS4gSG93ZXZlciwgdXN1YWxseVxyXG4gKiBpdCBpcyBlYXNpZXIgdG8gdXNlIHNvbWUgb2YgdGhlIGhlbHBlciBmdW5jdGlvbnMgZGVmaW5lZCBiZWxvdy5cclxuICpcclxuICogVGhlIGZpcnN0IGhlbHBlciBjcmVhdGVzIGEgbmV3IEhUTUwgZWxlbWVuZW50IGFuZCBwbGFjZXMgaXQgdW5kZXIgdGhlXHJcbiAqIHBhcmVudCBlbGVtZW50LiBZb3UgY2FuIHNwZWNpZnkgdGhlIHR5cGUgb2YgdGhlIGVsZW1lbnQsIGl0cyBhdHRyaWJ1dGVzLFxyXG4gKiBhbmQgYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgdGhlIGNvbnRlbnQgaW5zaWRlIHRoZSBlbGVtZW50LiBUaGUgY29udGVudFxyXG4gKiBpcyBhc3N1bWVkIHRvIGNvbnRhaW4gYSB2YWxpZCBIVE1MIHN0cmluZy5cclxuICovXHJcbmZ1bmN0aW9uIGh0bWwocmVuZGVyLCB0YWcsIGF0dHJzKSB7XHJcbiAgICByZXR1cm4gKGlucHV0LCBwYXJlbnQpID0+IHtcclxuICAgICAgICBsZXQgcmVzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0YWcpO1xyXG4gICAgICAgIGZvciAobGV0IGF0dHIgaW4gYXR0cnMpXHJcbiAgICAgICAgICAgIGlmIChhdHRycy5oYXNPd25Qcm9wZXJ0eShhdHRyKSlcclxuICAgICAgICAgICAgICAgIHJlcy5zZXRBdHRyaWJ1dGUoYXR0ciwgYXR0cnNbYXR0cl0pO1xyXG4gICAgICAgIHJlcy5pbm5lckhUTUwgPSByZW5kZXIoaW5wdXQpO1xyXG4gICAgICAgIHBhcmVudC5hcHBlbmRDaGlsZChyZXMpO1xyXG4gICAgfTtcclxufVxyXG5leHBvcnRzLmh0bWwgPSBodG1sO1xyXG4vKipcclxuICogQXJtZWQgd2l0aCB0aGUgYGh0bWxgIGZ1bmN0aW9uIHdlIGNhbiBkZWZpbmUgbW9yZSBoZWxwZXJzIHRoYXQgb3V0cHV0XHJcbiAqIHRoZSByZXN1bHQgb2YgYSBmdW5jdGlvbiBpbiBhIHNwZWNpZmljIGVsZW1lbnQgd2l0aCBhIHNwZWNpZmljIHN0eWxlLlxyXG4gKiBUaGUgZmlyc3Qgb25lIHNob3dzIHRoZSByZXN1bHQgaW5zaWRlIGEgYDxwcmU+YCB0YWcgd2hpY2ggaXMgc3R5bGVkXHJcbiAqIGFzIGNvbnNvbGUgb3VwdXQuXHJcbiAqL1xyXG5mdW5jdGlvbiBjb25zb2xlKG91dHB1dCkge1xyXG4gICAgcmV0dXJuIGh0bWwob3V0cHV0LCAncHJlJywgeyBjbGFzczogXCJjb25zb2xlXCIgfSk7XHJcbn1cclxuZXhwb3J0cy5jb25zb2xlID0gY29uc29sZTtcclxuLyoqXHJcbiAqIFRoZSBzZWNvbmQgZnVuY3Rpb24gc2hvd3MgYSBzdHlsZWQgZXJyb3IgbWVzc2FnZS4gVGhlIHN0eWxlIHVzZWQgaGVyZVxyXG4gKiBpcyBkZWZpbmVkIGluIHRoZSBkZWZhdWx0IHRlbXBsYXRlLiBJdCBpcyBwb3NzaWJsZSBhbHNvIHRvIGltcG9ydCB5b3VyXHJcbiAqIG93biBzdHlsZSBzaGVldHMgKExlc3Mgb3IgQ1NTKSBpbiB0aGUgY29kZSBmaWxlcyB5b3UgaW5jbHVkZS4gVGhleSBhcmVcclxuICogc2VwYXJhdGVkLCBjb21waWxlZCBhbmQgcGFja2VkIGJ5IHRoZSBidW5kbGVyLlxyXG4gKi9cclxuZnVuY3Rpb24gZXJyb3IobWVzc2FnZSkge1xyXG4gICAgcmV0dXJuIGh0bWwoXyA9PiBtZXNzYWdlLCAnZGl2JywgeyBjbGFzczogXCJlcnJvclwiIH0pO1xyXG59XHJcbmV4cG9ydHMuZXJyb3IgPSBlcnJvcjtcclxuLyoqXHJcbiAqICMjIFJ1bm5pbmcgVmlzdWFsaXplcnNcclxuICpcclxuICogVGhlIGBydW5WaXN1YWxpemVyYCBmdW5jdGlvbiBpcyBleHBvcnRlZCBhcyBhIHByb3BlcnR5IG9mIHRoZSBgd2luZG93YFxyXG4gKiBvYmplY3QuIEl0IHJ1bnMgdGhlIG5hbWVkIHZpc3VhbGl6ZXIgd2l0aCB0aGUgZ2l2ZW4gcGFyYW1ldGVycy4gTGlUU2NyaXB0XHJcbiAqIGdlbmVyYXRlcyBjb2RlIHRoYXQgY2FsbHMgdGhpcyBmdW5jdGlvbiBmcm9tIGEgSFRNTCBwYWdlLlxyXG4gKi9cclxuYXN5bmMgZnVuY3Rpb24gcnVuVmlzdWFsaXplcihuYW1lLCBwYXJhbXMsIHBhcmVudElkKSB7XHJcbiAgICBsZXQgcGFyZW50ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQocGFyZW50SWQpO1xyXG4gICAgaWYgKCFwYXJlbnQpXHJcbiAgICAgICAgdGhyb3cgRXJyb3IoYFZpc3VhbGl6ZXIgcGFyZW50IGlkIFwiJHtwYXJlbnRJZH1cIiBub3QgZm91bmQuYCk7XHJcbiAgICBsZXQgdmlzdWFsaXplID0gdmlzdWFsaXplcnNbbmFtZV0gfHxcclxuICAgICAgICBlcnJvcihgVmlzdWFsaXplciBcIiR7bmFtZX1cIiBpcyBub3QgcmVnaXN0ZXJlZC5gKTtcclxuICAgIHRyeSB7XHJcbiAgICAgICAgYXdhaXQgdmlzdWFsaXplKHBhcmFtcywgcGFyZW50KTtcclxuICAgIH1cclxuICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgZXJyb3IoYEV4Y2VwdGlvbiB0aHJvd24gYnkgdmlzdWFsaXplciBcIiR7bmFtZX1cIi48QlIvPlxyXG4gICAgICAgICR7ZS50b1N0cmluZygpfWApKFwiXCIsIHBhcmVudCk7XHJcbiAgICB9XHJcbn1cclxuaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKVxyXG4gICAgd2luZG93W1wicnVuVmlzdWFsaXplclwiXSA9IHJ1blZpc3VhbGl6ZXI7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXZpc3VhbGl6ZXIuanMubWFwIiwidmFyIGdldE5hdGl2ZSA9IHJlcXVpcmUoJy4vX2dldE5hdGl2ZScpLFxuICAgIHJvb3QgPSByZXF1aXJlKCcuL19yb290Jyk7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIHRoYXQgYXJlIHZlcmlmaWVkIHRvIGJlIG5hdGl2ZS4gKi9cbnZhciBEYXRhVmlldyA9IGdldE5hdGl2ZShyb290LCAnRGF0YVZpZXcnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBEYXRhVmlldztcbiIsInZhciBoYXNoQ2xlYXIgPSByZXF1aXJlKCcuL19oYXNoQ2xlYXInKSxcbiAgICBoYXNoRGVsZXRlID0gcmVxdWlyZSgnLi9faGFzaERlbGV0ZScpLFxuICAgIGhhc2hHZXQgPSByZXF1aXJlKCcuL19oYXNoR2V0JyksXG4gICAgaGFzaEhhcyA9IHJlcXVpcmUoJy4vX2hhc2hIYXMnKSxcbiAgICBoYXNoU2V0ID0gcmVxdWlyZSgnLi9faGFzaFNldCcpO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBoYXNoIG9iamVjdC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0FycmF5fSBbZW50cmllc10gVGhlIGtleS12YWx1ZSBwYWlycyB0byBjYWNoZS5cbiAqL1xuZnVuY3Rpb24gSGFzaChlbnRyaWVzKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gZW50cmllcyA9PSBudWxsID8gMCA6IGVudHJpZXMubGVuZ3RoO1xuXG4gIHRoaXMuY2xlYXIoKTtcbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIgZW50cnkgPSBlbnRyaWVzW2luZGV4XTtcbiAgICB0aGlzLnNldChlbnRyeVswXSwgZW50cnlbMV0pO1xuICB9XG59XG5cbi8vIEFkZCBtZXRob2RzIHRvIGBIYXNoYC5cbkhhc2gucHJvdG90eXBlLmNsZWFyID0gaGFzaENsZWFyO1xuSGFzaC5wcm90b3R5cGVbJ2RlbGV0ZSddID0gaGFzaERlbGV0ZTtcbkhhc2gucHJvdG90eXBlLmdldCA9IGhhc2hHZXQ7XG5IYXNoLnByb3RvdHlwZS5oYXMgPSBoYXNoSGFzO1xuSGFzaC5wcm90b3R5cGUuc2V0ID0gaGFzaFNldDtcblxubW9kdWxlLmV4cG9ydHMgPSBIYXNoO1xuIiwidmFyIGxpc3RDYWNoZUNsZWFyID0gcmVxdWlyZSgnLi9fbGlzdENhY2hlQ2xlYXInKSxcbiAgICBsaXN0Q2FjaGVEZWxldGUgPSByZXF1aXJlKCcuL19saXN0Q2FjaGVEZWxldGUnKSxcbiAgICBsaXN0Q2FjaGVHZXQgPSByZXF1aXJlKCcuL19saXN0Q2FjaGVHZXQnKSxcbiAgICBsaXN0Q2FjaGVIYXMgPSByZXF1aXJlKCcuL19saXN0Q2FjaGVIYXMnKSxcbiAgICBsaXN0Q2FjaGVTZXQgPSByZXF1aXJlKCcuL19saXN0Q2FjaGVTZXQnKTtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGxpc3QgY2FjaGUgb2JqZWN0LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7QXJyYXl9IFtlbnRyaWVzXSBUaGUga2V5LXZhbHVlIHBhaXJzIHRvIGNhY2hlLlxuICovXG5mdW5jdGlvbiBMaXN0Q2FjaGUoZW50cmllcykge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGVudHJpZXMgPT0gbnVsbCA/IDAgOiBlbnRyaWVzLmxlbmd0aDtcblxuICB0aGlzLmNsZWFyKCk7XG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIGVudHJ5ID0gZW50cmllc1tpbmRleF07XG4gICAgdGhpcy5zZXQoZW50cnlbMF0sIGVudHJ5WzFdKTtcbiAgfVxufVxuXG4vLyBBZGQgbWV0aG9kcyB0byBgTGlzdENhY2hlYC5cbkxpc3RDYWNoZS5wcm90b3R5cGUuY2xlYXIgPSBsaXN0Q2FjaGVDbGVhcjtcbkxpc3RDYWNoZS5wcm90b3R5cGVbJ2RlbGV0ZSddID0gbGlzdENhY2hlRGVsZXRlO1xuTGlzdENhY2hlLnByb3RvdHlwZS5nZXQgPSBsaXN0Q2FjaGVHZXQ7XG5MaXN0Q2FjaGUucHJvdG90eXBlLmhhcyA9IGxpc3RDYWNoZUhhcztcbkxpc3RDYWNoZS5wcm90b3R5cGUuc2V0ID0gbGlzdENhY2hlU2V0O1xuXG5tb2R1bGUuZXhwb3J0cyA9IExpc3RDYWNoZTtcbiIsInZhciBnZXROYXRpdmUgPSByZXF1aXJlKCcuL19nZXROYXRpdmUnKSxcbiAgICByb290ID0gcmVxdWlyZSgnLi9fcm9vdCcpO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyB0aGF0IGFyZSB2ZXJpZmllZCB0byBiZSBuYXRpdmUuICovXG52YXIgTWFwID0gZ2V0TmF0aXZlKHJvb3QsICdNYXAnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBNYXA7XG4iLCJ2YXIgbWFwQ2FjaGVDbGVhciA9IHJlcXVpcmUoJy4vX21hcENhY2hlQ2xlYXInKSxcbiAgICBtYXBDYWNoZURlbGV0ZSA9IHJlcXVpcmUoJy4vX21hcENhY2hlRGVsZXRlJyksXG4gICAgbWFwQ2FjaGVHZXQgPSByZXF1aXJlKCcuL19tYXBDYWNoZUdldCcpLFxuICAgIG1hcENhY2hlSGFzID0gcmVxdWlyZSgnLi9fbWFwQ2FjaGVIYXMnKSxcbiAgICBtYXBDYWNoZVNldCA9IHJlcXVpcmUoJy4vX21hcENhY2hlU2V0Jyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhIG1hcCBjYWNoZSBvYmplY3QgdG8gc3RvcmUga2V5LXZhbHVlIHBhaXJzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7QXJyYXl9IFtlbnRyaWVzXSBUaGUga2V5LXZhbHVlIHBhaXJzIHRvIGNhY2hlLlxuICovXG5mdW5jdGlvbiBNYXBDYWNoZShlbnRyaWVzKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gZW50cmllcyA9PSBudWxsID8gMCA6IGVudHJpZXMubGVuZ3RoO1xuXG4gIHRoaXMuY2xlYXIoKTtcbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIgZW50cnkgPSBlbnRyaWVzW2luZGV4XTtcbiAgICB0aGlzLnNldChlbnRyeVswXSwgZW50cnlbMV0pO1xuICB9XG59XG5cbi8vIEFkZCBtZXRob2RzIHRvIGBNYXBDYWNoZWAuXG5NYXBDYWNoZS5wcm90b3R5cGUuY2xlYXIgPSBtYXBDYWNoZUNsZWFyO1xuTWFwQ2FjaGUucHJvdG90eXBlWydkZWxldGUnXSA9IG1hcENhY2hlRGVsZXRlO1xuTWFwQ2FjaGUucHJvdG90eXBlLmdldCA9IG1hcENhY2hlR2V0O1xuTWFwQ2FjaGUucHJvdG90eXBlLmhhcyA9IG1hcENhY2hlSGFzO1xuTWFwQ2FjaGUucHJvdG90eXBlLnNldCA9IG1hcENhY2hlU2V0O1xuXG5tb2R1bGUuZXhwb3J0cyA9IE1hcENhY2hlO1xuIiwidmFyIGdldE5hdGl2ZSA9IHJlcXVpcmUoJy4vX2dldE5hdGl2ZScpLFxuICAgIHJvb3QgPSByZXF1aXJlKCcuL19yb290Jyk7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIHRoYXQgYXJlIHZlcmlmaWVkIHRvIGJlIG5hdGl2ZS4gKi9cbnZhciBQcm9taXNlID0gZ2V0TmF0aXZlKHJvb3QsICdQcm9taXNlJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gUHJvbWlzZTtcbiIsInZhciBnZXROYXRpdmUgPSByZXF1aXJlKCcuL19nZXROYXRpdmUnKSxcbiAgICByb290ID0gcmVxdWlyZSgnLi9fcm9vdCcpO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyB0aGF0IGFyZSB2ZXJpZmllZCB0byBiZSBuYXRpdmUuICovXG52YXIgU2V0ID0gZ2V0TmF0aXZlKHJvb3QsICdTZXQnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBTZXQ7XG4iLCJ2YXIgTWFwQ2FjaGUgPSByZXF1aXJlKCcuL19NYXBDYWNoZScpLFxuICAgIHNldENhY2hlQWRkID0gcmVxdWlyZSgnLi9fc2V0Q2FjaGVBZGQnKSxcbiAgICBzZXRDYWNoZUhhcyA9IHJlcXVpcmUoJy4vX3NldENhY2hlSGFzJyk7XG5cbi8qKlxuICpcbiAqIENyZWF0ZXMgYW4gYXJyYXkgY2FjaGUgb2JqZWN0IHRvIHN0b3JlIHVuaXF1ZSB2YWx1ZXMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtBcnJheX0gW3ZhbHVlc10gVGhlIHZhbHVlcyB0byBjYWNoZS5cbiAqL1xuZnVuY3Rpb24gU2V0Q2FjaGUodmFsdWVzKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gdmFsdWVzID09IG51bGwgPyAwIDogdmFsdWVzLmxlbmd0aDtcblxuICB0aGlzLl9fZGF0YV9fID0gbmV3IE1hcENhY2hlO1xuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHRoaXMuYWRkKHZhbHVlc1tpbmRleF0pO1xuICB9XG59XG5cbi8vIEFkZCBtZXRob2RzIHRvIGBTZXRDYWNoZWAuXG5TZXRDYWNoZS5wcm90b3R5cGUuYWRkID0gU2V0Q2FjaGUucHJvdG90eXBlLnB1c2ggPSBzZXRDYWNoZUFkZDtcblNldENhY2hlLnByb3RvdHlwZS5oYXMgPSBzZXRDYWNoZUhhcztcblxubW9kdWxlLmV4cG9ydHMgPSBTZXRDYWNoZTtcbiIsInZhciBMaXN0Q2FjaGUgPSByZXF1aXJlKCcuL19MaXN0Q2FjaGUnKSxcbiAgICBzdGFja0NsZWFyID0gcmVxdWlyZSgnLi9fc3RhY2tDbGVhcicpLFxuICAgIHN0YWNrRGVsZXRlID0gcmVxdWlyZSgnLi9fc3RhY2tEZWxldGUnKSxcbiAgICBzdGFja0dldCA9IHJlcXVpcmUoJy4vX3N0YWNrR2V0JyksXG4gICAgc3RhY2tIYXMgPSByZXF1aXJlKCcuL19zdGFja0hhcycpLFxuICAgIHN0YWNrU2V0ID0gcmVxdWlyZSgnLi9fc3RhY2tTZXQnKTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgc3RhY2sgY2FjaGUgb2JqZWN0IHRvIHN0b3JlIGtleS12YWx1ZSBwYWlycy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0FycmF5fSBbZW50cmllc10gVGhlIGtleS12YWx1ZSBwYWlycyB0byBjYWNoZS5cbiAqL1xuZnVuY3Rpb24gU3RhY2soZW50cmllcykge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18gPSBuZXcgTGlzdENhY2hlKGVudHJpZXMpO1xuICB0aGlzLnNpemUgPSBkYXRhLnNpemU7XG59XG5cbi8vIEFkZCBtZXRob2RzIHRvIGBTdGFja2AuXG5TdGFjay5wcm90b3R5cGUuY2xlYXIgPSBzdGFja0NsZWFyO1xuU3RhY2sucHJvdG90eXBlWydkZWxldGUnXSA9IHN0YWNrRGVsZXRlO1xuU3RhY2sucHJvdG90eXBlLmdldCA9IHN0YWNrR2V0O1xuU3RhY2sucHJvdG90eXBlLmhhcyA9IHN0YWNrSGFzO1xuU3RhY2sucHJvdG90eXBlLnNldCA9IHN0YWNrU2V0O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFN0YWNrO1xuIiwidmFyIHJvb3QgPSByZXF1aXJlKCcuL19yb290Jyk7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIFN5bWJvbCA9IHJvb3QuU3ltYm9sO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFN5bWJvbDtcbiIsInZhciByb290ID0gcmVxdWlyZSgnLi9fcm9vdCcpO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBVaW50OEFycmF5ID0gcm9vdC5VaW50OEFycmF5O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFVpbnQ4QXJyYXk7XG4iLCJ2YXIgZ2V0TmF0aXZlID0gcmVxdWlyZSgnLi9fZ2V0TmF0aXZlJyksXG4gICAgcm9vdCA9IHJlcXVpcmUoJy4vX3Jvb3QnKTtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgdGhhdCBhcmUgdmVyaWZpZWQgdG8gYmUgbmF0aXZlLiAqL1xudmFyIFdlYWtNYXAgPSBnZXROYXRpdmUocm9vdCwgJ1dlYWtNYXAnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBXZWFrTWFwO1xuIiwiLyoqXG4gKiBBIGZhc3RlciBhbHRlcm5hdGl2ZSB0byBgRnVuY3Rpb24jYXBwbHlgLCB0aGlzIGZ1bmN0aW9uIGludm9rZXMgYGZ1bmNgXG4gKiB3aXRoIHRoZSBgdGhpc2AgYmluZGluZyBvZiBgdGhpc0FyZ2AgYW5kIHRoZSBhcmd1bWVudHMgb2YgYGFyZ3NgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBpbnZva2UuXG4gKiBAcGFyYW0geyp9IHRoaXNBcmcgVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBmdW5jYC5cbiAqIEBwYXJhbSB7QXJyYXl9IGFyZ3MgVGhlIGFyZ3VtZW50cyB0byBpbnZva2UgYGZ1bmNgIHdpdGguXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcmVzdWx0IG9mIGBmdW5jYC5cbiAqL1xuZnVuY3Rpb24gYXBwbHkoZnVuYywgdGhpc0FyZywgYXJncykge1xuICBzd2l0Y2ggKGFyZ3MubGVuZ3RoKSB7XG4gICAgY2FzZSAwOiByZXR1cm4gZnVuYy5jYWxsKHRoaXNBcmcpO1xuICAgIGNhc2UgMTogcmV0dXJuIGZ1bmMuY2FsbCh0aGlzQXJnLCBhcmdzWzBdKTtcbiAgICBjYXNlIDI6IHJldHVybiBmdW5jLmNhbGwodGhpc0FyZywgYXJnc1swXSwgYXJnc1sxXSk7XG4gICAgY2FzZSAzOiByZXR1cm4gZnVuYy5jYWxsKHRoaXNBcmcsIGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0pO1xuICB9XG4gIHJldHVybiBmdW5jLmFwcGx5KHRoaXNBcmcsIGFyZ3MpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGFwcGx5O1xuIiwiLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8uZm9yRWFjaGAgZm9yIGFycmF5cyB3aXRob3V0IHN1cHBvcnQgZm9yXG4gKiBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBbYXJyYXldIFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBhcnJheWAuXG4gKi9cbmZ1bmN0aW9uIGFycmF5RWFjaChhcnJheSwgaXRlcmF0ZWUpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIGlmIChpdGVyYXRlZShhcnJheVtpbmRleF0sIGluZGV4LCBhcnJheSkgPT09IGZhbHNlKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGFycmF5O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGFycmF5RWFjaDtcbiIsIi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLmZpbHRlcmAgZm9yIGFycmF5cyB3aXRob3V0IHN1cHBvcnQgZm9yXG4gKiBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBbYXJyYXldIFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkaWNhdGUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGZpbHRlcmVkIGFycmF5LlxuICovXG5mdW5jdGlvbiBhcnJheUZpbHRlcihhcnJheSwgcHJlZGljYXRlKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGgsXG4gICAgICByZXNJbmRleCA9IDAsXG4gICAgICByZXN1bHQgPSBbXTtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciB2YWx1ZSA9IGFycmF5W2luZGV4XTtcbiAgICBpZiAocHJlZGljYXRlKHZhbHVlLCBpbmRleCwgYXJyYXkpKSB7XG4gICAgICByZXN1bHRbcmVzSW5kZXgrK10gPSB2YWx1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBhcnJheUZpbHRlcjtcbiIsInZhciBiYXNlSW5kZXhPZiA9IHJlcXVpcmUoJy4vX2Jhc2VJbmRleE9mJyk7XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLmluY2x1ZGVzYCBmb3IgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydCBmb3JcbiAqIHNwZWNpZnlpbmcgYW4gaW5kZXggdG8gc2VhcmNoIGZyb20uXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IFthcnJheV0gVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gKiBAcGFyYW0geyp9IHRhcmdldCBUaGUgdmFsdWUgdG8gc2VhcmNoIGZvci5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdGFyZ2V0YCBpcyBmb3VuZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBhcnJheUluY2x1ZGVzKGFycmF5LCB2YWx1ZSkge1xuICB2YXIgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG4gIHJldHVybiAhIWxlbmd0aCAmJiBiYXNlSW5kZXhPZihhcnJheSwgdmFsdWUsIDApID4gLTE7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYXJyYXlJbmNsdWRlcztcbiIsIi8qKlxuICogVGhpcyBmdW5jdGlvbiBpcyBsaWtlIGBhcnJheUluY2x1ZGVzYCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIGEgY29tcGFyYXRvci5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gW2FycmF5XSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAqIEBwYXJhbSB7Kn0gdGFyZ2V0IFRoZSB2YWx1ZSB0byBzZWFyY2ggZm9yLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY29tcGFyYXRvciBUaGUgY29tcGFyYXRvciBpbnZva2VkIHBlciBlbGVtZW50LlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB0YXJnZXRgIGlzIGZvdW5kLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGFycmF5SW5jbHVkZXNXaXRoKGFycmF5LCB2YWx1ZSwgY29tcGFyYXRvcikge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgaWYgKGNvbXBhcmF0b3IodmFsdWUsIGFycmF5W2luZGV4XSkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYXJyYXlJbmNsdWRlc1dpdGg7XG4iLCJ2YXIgYmFzZVRpbWVzID0gcmVxdWlyZSgnLi9fYmFzZVRpbWVzJyksXG4gICAgaXNBcmd1bWVudHMgPSByZXF1aXJlKCcuL2lzQXJndW1lbnRzJyksXG4gICAgaXNBcnJheSA9IHJlcXVpcmUoJy4vaXNBcnJheScpLFxuICAgIGlzQnVmZmVyID0gcmVxdWlyZSgnLi9pc0J1ZmZlcicpLFxuICAgIGlzSW5kZXggPSByZXF1aXJlKCcuL19pc0luZGV4JyksXG4gICAgaXNUeXBlZEFycmF5ID0gcmVxdWlyZSgnLi9pc1R5cGVkQXJyYXknKTtcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIG9mIHRoZSBhcnJheS1saWtlIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtib29sZWFufSBpbmhlcml0ZWQgU3BlY2lmeSByZXR1cm5pbmcgaW5oZXJpdGVkIHByb3BlcnR5IG5hbWVzLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAqL1xuZnVuY3Rpb24gYXJyYXlMaWtlS2V5cyh2YWx1ZSwgaW5oZXJpdGVkKSB7XG4gIHZhciBpc0FyciA9IGlzQXJyYXkodmFsdWUpLFxuICAgICAgaXNBcmcgPSAhaXNBcnIgJiYgaXNBcmd1bWVudHModmFsdWUpLFxuICAgICAgaXNCdWZmID0gIWlzQXJyICYmICFpc0FyZyAmJiBpc0J1ZmZlcih2YWx1ZSksXG4gICAgICBpc1R5cGUgPSAhaXNBcnIgJiYgIWlzQXJnICYmICFpc0J1ZmYgJiYgaXNUeXBlZEFycmF5KHZhbHVlKSxcbiAgICAgIHNraXBJbmRleGVzID0gaXNBcnIgfHwgaXNBcmcgfHwgaXNCdWZmIHx8IGlzVHlwZSxcbiAgICAgIHJlc3VsdCA9IHNraXBJbmRleGVzID8gYmFzZVRpbWVzKHZhbHVlLmxlbmd0aCwgU3RyaW5nKSA6IFtdLFxuICAgICAgbGVuZ3RoID0gcmVzdWx0Lmxlbmd0aDtcblxuICBmb3IgKHZhciBrZXkgaW4gdmFsdWUpIHtcbiAgICBpZiAoKGluaGVyaXRlZCB8fCBoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCBrZXkpKSAmJlxuICAgICAgICAhKHNraXBJbmRleGVzICYmIChcbiAgICAgICAgICAgLy8gU2FmYXJpIDkgaGFzIGVudW1lcmFibGUgYGFyZ3VtZW50cy5sZW5ndGhgIGluIHN0cmljdCBtb2RlLlxuICAgICAgICAgICBrZXkgPT0gJ2xlbmd0aCcgfHxcbiAgICAgICAgICAgLy8gTm9kZS5qcyAwLjEwIGhhcyBlbnVtZXJhYmxlIG5vbi1pbmRleCBwcm9wZXJ0aWVzIG9uIGJ1ZmZlcnMuXG4gICAgICAgICAgIChpc0J1ZmYgJiYgKGtleSA9PSAnb2Zmc2V0JyB8fCBrZXkgPT0gJ3BhcmVudCcpKSB8fFxuICAgICAgICAgICAvLyBQaGFudG9tSlMgMiBoYXMgZW51bWVyYWJsZSBub24taW5kZXggcHJvcGVydGllcyBvbiB0eXBlZCBhcnJheXMuXG4gICAgICAgICAgIChpc1R5cGUgJiYgKGtleSA9PSAnYnVmZmVyJyB8fCBrZXkgPT0gJ2J5dGVMZW5ndGgnIHx8IGtleSA9PSAnYnl0ZU9mZnNldCcpKSB8fFxuICAgICAgICAgICAvLyBTa2lwIGluZGV4IHByb3BlcnRpZXMuXG4gICAgICAgICAgIGlzSW5kZXgoa2V5LCBsZW5ndGgpXG4gICAgICAgICkpKSB7XG4gICAgICByZXN1bHQucHVzaChrZXkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGFycmF5TGlrZUtleXM7XG4iLCIvKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5tYXBgIGZvciBhcnJheXMgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZVxuICogc2hvcnRoYW5kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gW2FycmF5XSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IG1hcHBlZCBhcnJheS5cbiAqL1xuZnVuY3Rpb24gYXJyYXlNYXAoYXJyYXksIGl0ZXJhdGVlKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGgsXG4gICAgICByZXN1bHQgPSBBcnJheShsZW5ndGgpO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgcmVzdWx0W2luZGV4XSA9IGl0ZXJhdGVlKGFycmF5W2luZGV4XSwgaW5kZXgsIGFycmF5KTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGFycmF5TWFwO1xuIiwiLyoqXG4gKiBBcHBlbmRzIHRoZSBlbGVtZW50cyBvZiBgdmFsdWVzYCB0byBgYXJyYXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gbW9kaWZ5LlxuICogQHBhcmFtIHtBcnJheX0gdmFsdWVzIFRoZSB2YWx1ZXMgdG8gYXBwZW5kLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBhcnJheWAuXG4gKi9cbmZ1bmN0aW9uIGFycmF5UHVzaChhcnJheSwgdmFsdWVzKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gdmFsdWVzLmxlbmd0aCxcbiAgICAgIG9mZnNldCA9IGFycmF5Lmxlbmd0aDtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIGFycmF5W29mZnNldCArIGluZGV4XSA9IHZhbHVlc1tpbmRleF07XG4gIH1cbiAgcmV0dXJuIGFycmF5O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGFycmF5UHVzaDtcbiIsIi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLnJlZHVjZWAgZm9yIGFycmF5cyB3aXRob3V0IHN1cHBvcnQgZm9yXG4gKiBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBbYXJyYXldIFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHBhcmFtIHsqfSBbYWNjdW11bGF0b3JdIFRoZSBpbml0aWFsIHZhbHVlLlxuICogQHBhcmFtIHtib29sZWFufSBbaW5pdEFjY3VtXSBTcGVjaWZ5IHVzaW5nIHRoZSBmaXJzdCBlbGVtZW50IG9mIGBhcnJheWAgYXNcbiAqICB0aGUgaW5pdGlhbCB2YWx1ZS5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBhY2N1bXVsYXRlZCB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gYXJyYXlSZWR1Y2UoYXJyYXksIGl0ZXJhdGVlLCBhY2N1bXVsYXRvciwgaW5pdEFjY3VtKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG5cbiAgaWYgKGluaXRBY2N1bSAmJiBsZW5ndGgpIHtcbiAgICBhY2N1bXVsYXRvciA9IGFycmF5WysraW5kZXhdO1xuICB9XG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgYWNjdW11bGF0b3IgPSBpdGVyYXRlZShhY2N1bXVsYXRvciwgYXJyYXlbaW5kZXhdLCBpbmRleCwgYXJyYXkpO1xuICB9XG4gIHJldHVybiBhY2N1bXVsYXRvcjtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBhcnJheVJlZHVjZTtcbiIsIi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLnNvbWVgIGZvciBhcnJheXMgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZVxuICogc2hvcnRoYW5kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gW2FycmF5XSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gcHJlZGljYXRlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW55IGVsZW1lbnQgcGFzc2VzIHRoZSBwcmVkaWNhdGUgY2hlY2ssXG4gKiAgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBhcnJheVNvbWUoYXJyYXksIHByZWRpY2F0ZSkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgaWYgKHByZWRpY2F0ZShhcnJheVtpbmRleF0sIGluZGV4LCBhcnJheSkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYXJyYXlTb21lO1xuIiwidmFyIGJhc2VQcm9wZXJ0eSA9IHJlcXVpcmUoJy4vX2Jhc2VQcm9wZXJ0eScpO1xuXG4vKipcbiAqIEdldHMgdGhlIHNpemUgb2YgYW4gQVNDSUkgYHN0cmluZ2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgVGhlIHN0cmluZyBpbnNwZWN0LlxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgc3RyaW5nIHNpemUuXG4gKi9cbnZhciBhc2NpaVNpemUgPSBiYXNlUHJvcGVydHkoJ2xlbmd0aCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGFzY2lpU2l6ZTtcbiIsInZhciBiYXNlQXNzaWduVmFsdWUgPSByZXF1aXJlKCcuL19iYXNlQXNzaWduVmFsdWUnKSxcbiAgICBlcSA9IHJlcXVpcmUoJy4vZXEnKTtcblxuLyoqXG4gKiBUaGlzIGZ1bmN0aW9uIGlzIGxpa2UgYGFzc2lnblZhbHVlYCBleGNlcHQgdGhhdCBpdCBkb2Vzbid0IGFzc2lnblxuICogYHVuZGVmaW5lZGAgdmFsdWVzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gbW9kaWZ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBhc3NpZ24uXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBhc3NpZ24uXG4gKi9cbmZ1bmN0aW9uIGFzc2lnbk1lcmdlVmFsdWUob2JqZWN0LCBrZXksIHZhbHVlKSB7XG4gIGlmICgodmFsdWUgIT09IHVuZGVmaW5lZCAmJiAhZXEob2JqZWN0W2tleV0sIHZhbHVlKSkgfHxcbiAgICAgICh2YWx1ZSA9PT0gdW5kZWZpbmVkICYmICEoa2V5IGluIG9iamVjdCkpKSB7XG4gICAgYmFzZUFzc2lnblZhbHVlKG9iamVjdCwga2V5LCB2YWx1ZSk7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBhc3NpZ25NZXJnZVZhbHVlO1xuIiwidmFyIGJhc2VBc3NpZ25WYWx1ZSA9IHJlcXVpcmUoJy4vX2Jhc2VBc3NpZ25WYWx1ZScpLFxuICAgIGVxID0gcmVxdWlyZSgnLi9lcScpO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIEFzc2lnbnMgYHZhbHVlYCB0byBga2V5YCBvZiBgb2JqZWN0YCBpZiB0aGUgZXhpc3RpbmcgdmFsdWUgaXMgbm90IGVxdWl2YWxlbnRcbiAqIHVzaW5nIFtgU2FtZVZhbHVlWmVyb2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXNhbWV2YWx1ZXplcm8pXG4gKiBmb3IgZXF1YWxpdHkgY29tcGFyaXNvbnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBtb2RpZnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGFzc2lnbi5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGFzc2lnbi5cbiAqL1xuZnVuY3Rpb24gYXNzaWduVmFsdWUob2JqZWN0LCBrZXksIHZhbHVlKSB7XG4gIHZhciBvYmpWYWx1ZSA9IG9iamVjdFtrZXldO1xuICBpZiAoIShoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwga2V5KSAmJiBlcShvYmpWYWx1ZSwgdmFsdWUpKSB8fFxuICAgICAgKHZhbHVlID09PSB1bmRlZmluZWQgJiYgIShrZXkgaW4gb2JqZWN0KSkpIHtcbiAgICBiYXNlQXNzaWduVmFsdWUob2JqZWN0LCBrZXksIHZhbHVlKTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGFzc2lnblZhbHVlO1xuIiwidmFyIGVxID0gcmVxdWlyZSgnLi9lcScpO1xuXG4vKipcbiAqIEdldHMgdGhlIGluZGV4IGF0IHdoaWNoIHRoZSBga2V5YCBpcyBmb3VuZCBpbiBgYXJyYXlgIG9mIGtleS12YWx1ZSBwYWlycy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gKiBAcGFyYW0geyp9IGtleSBUaGUga2V5IHRvIHNlYXJjaCBmb3IuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgbWF0Y2hlZCB2YWx1ZSwgZWxzZSBgLTFgLlxuICovXG5mdW5jdGlvbiBhc3NvY0luZGV4T2YoYXJyYXksIGtleSkge1xuICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICBpZiAoZXEoYXJyYXlbbGVuZ3RoXVswXSwga2V5KSkge1xuICAgICAgcmV0dXJuIGxlbmd0aDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIC0xO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGFzc29jSW5kZXhPZjtcbiIsInZhciBjb3B5T2JqZWN0ID0gcmVxdWlyZSgnLi9fY29weU9iamVjdCcpLFxuICAgIGtleXMgPSByZXF1aXJlKCcuL2tleXMnKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5hc3NpZ25gIHdpdGhvdXQgc3VwcG9ydCBmb3IgbXVsdGlwbGUgc291cmNlc1xuICogb3IgYGN1c3RvbWl6ZXJgIGZ1bmN0aW9ucy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgc291cmNlIG9iamVjdC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VBc3NpZ24ob2JqZWN0LCBzb3VyY2UpIHtcbiAgcmV0dXJuIG9iamVjdCAmJiBjb3B5T2JqZWN0KHNvdXJjZSwga2V5cyhzb3VyY2UpLCBvYmplY3QpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VBc3NpZ247XG4iLCJ2YXIgY29weU9iamVjdCA9IHJlcXVpcmUoJy4vX2NvcHlPYmplY3QnKSxcbiAgICBrZXlzSW4gPSByZXF1aXJlKCcuL2tleXNJbicpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmFzc2lnbkluYCB3aXRob3V0IHN1cHBvcnQgZm9yIG11bHRpcGxlIHNvdXJjZXNcbiAqIG9yIGBjdXN0b21pemVyYCBmdW5jdGlvbnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIHNvdXJjZSBvYmplY3QuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICovXG5mdW5jdGlvbiBiYXNlQXNzaWduSW4ob2JqZWN0LCBzb3VyY2UpIHtcbiAgcmV0dXJuIG9iamVjdCAmJiBjb3B5T2JqZWN0KHNvdXJjZSwga2V5c0luKHNvdXJjZSksIG9iamVjdCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUFzc2lnbkluO1xuIiwidmFyIGRlZmluZVByb3BlcnR5ID0gcmVxdWlyZSgnLi9fZGVmaW5lUHJvcGVydHknKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgYXNzaWduVmFsdWVgIGFuZCBgYXNzaWduTWVyZ2VWYWx1ZWAgd2l0aG91dFxuICogdmFsdWUgY2hlY2tzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gbW9kaWZ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBhc3NpZ24uXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBhc3NpZ24uXG4gKi9cbmZ1bmN0aW9uIGJhc2VBc3NpZ25WYWx1ZShvYmplY3QsIGtleSwgdmFsdWUpIHtcbiAgaWYgKGtleSA9PSAnX19wcm90b19fJyAmJiBkZWZpbmVQcm9wZXJ0eSkge1xuICAgIGRlZmluZVByb3BlcnR5KG9iamVjdCwga2V5LCB7XG4gICAgICAnY29uZmlndXJhYmxlJzogdHJ1ZSxcbiAgICAgICdlbnVtZXJhYmxlJzogdHJ1ZSxcbiAgICAgICd2YWx1ZSc6IHZhbHVlLFxuICAgICAgJ3dyaXRhYmxlJzogdHJ1ZVxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIG9iamVjdFtrZXldID0gdmFsdWU7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlQXNzaWduVmFsdWU7XG4iLCJ2YXIgU3RhY2sgPSByZXF1aXJlKCcuL19TdGFjaycpLFxuICAgIGFycmF5RWFjaCA9IHJlcXVpcmUoJy4vX2FycmF5RWFjaCcpLFxuICAgIGFzc2lnblZhbHVlID0gcmVxdWlyZSgnLi9fYXNzaWduVmFsdWUnKSxcbiAgICBiYXNlQXNzaWduID0gcmVxdWlyZSgnLi9fYmFzZUFzc2lnbicpLFxuICAgIGJhc2VBc3NpZ25JbiA9IHJlcXVpcmUoJy4vX2Jhc2VBc3NpZ25JbicpLFxuICAgIGNsb25lQnVmZmVyID0gcmVxdWlyZSgnLi9fY2xvbmVCdWZmZXInKSxcbiAgICBjb3B5QXJyYXkgPSByZXF1aXJlKCcuL19jb3B5QXJyYXknKSxcbiAgICBjb3B5U3ltYm9scyA9IHJlcXVpcmUoJy4vX2NvcHlTeW1ib2xzJyksXG4gICAgY29weVN5bWJvbHNJbiA9IHJlcXVpcmUoJy4vX2NvcHlTeW1ib2xzSW4nKSxcbiAgICBnZXRBbGxLZXlzID0gcmVxdWlyZSgnLi9fZ2V0QWxsS2V5cycpLFxuICAgIGdldEFsbEtleXNJbiA9IHJlcXVpcmUoJy4vX2dldEFsbEtleXNJbicpLFxuICAgIGdldFRhZyA9IHJlcXVpcmUoJy4vX2dldFRhZycpLFxuICAgIGluaXRDbG9uZUFycmF5ID0gcmVxdWlyZSgnLi9faW5pdENsb25lQXJyYXknKSxcbiAgICBpbml0Q2xvbmVCeVRhZyA9IHJlcXVpcmUoJy4vX2luaXRDbG9uZUJ5VGFnJyksXG4gICAgaW5pdENsb25lT2JqZWN0ID0gcmVxdWlyZSgnLi9faW5pdENsb25lT2JqZWN0JyksXG4gICAgaXNBcnJheSA9IHJlcXVpcmUoJy4vaXNBcnJheScpLFxuICAgIGlzQnVmZmVyID0gcmVxdWlyZSgnLi9pc0J1ZmZlcicpLFxuICAgIGlzTWFwID0gcmVxdWlyZSgnLi9pc01hcCcpLFxuICAgIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9pc09iamVjdCcpLFxuICAgIGlzU2V0ID0gcmVxdWlyZSgnLi9pc1NldCcpLFxuICAgIGtleXMgPSByZXF1aXJlKCcuL2tleXMnKSxcbiAgICBrZXlzSW4gPSByZXF1aXJlKCcuL2tleXNJbicpO1xuXG4vKiogVXNlZCB0byBjb21wb3NlIGJpdG1hc2tzIGZvciBjbG9uaW5nLiAqL1xudmFyIENMT05FX0RFRVBfRkxBRyA9IDEsXG4gICAgQ0xPTkVfRkxBVF9GTEFHID0gMixcbiAgICBDTE9ORV9TWU1CT0xTX0ZMQUcgPSA0O1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgYXJnc1RhZyA9ICdbb2JqZWN0IEFyZ3VtZW50c10nLFxuICAgIGFycmF5VGFnID0gJ1tvYmplY3QgQXJyYXldJyxcbiAgICBib29sVGFnID0gJ1tvYmplY3QgQm9vbGVhbl0nLFxuICAgIGRhdGVUYWcgPSAnW29iamVjdCBEYXRlXScsXG4gICAgZXJyb3JUYWcgPSAnW29iamVjdCBFcnJvcl0nLFxuICAgIGZ1bmNUYWcgPSAnW29iamVjdCBGdW5jdGlvbl0nLFxuICAgIGdlblRhZyA9ICdbb2JqZWN0IEdlbmVyYXRvckZ1bmN0aW9uXScsXG4gICAgbWFwVGFnID0gJ1tvYmplY3QgTWFwXScsXG4gICAgbnVtYmVyVGFnID0gJ1tvYmplY3QgTnVtYmVyXScsXG4gICAgb2JqZWN0VGFnID0gJ1tvYmplY3QgT2JqZWN0XScsXG4gICAgcmVnZXhwVGFnID0gJ1tvYmplY3QgUmVnRXhwXScsXG4gICAgc2V0VGFnID0gJ1tvYmplY3QgU2V0XScsXG4gICAgc3RyaW5nVGFnID0gJ1tvYmplY3QgU3RyaW5nXScsXG4gICAgc3ltYm9sVGFnID0gJ1tvYmplY3QgU3ltYm9sXScsXG4gICAgd2Vha01hcFRhZyA9ICdbb2JqZWN0IFdlYWtNYXBdJztcblxudmFyIGFycmF5QnVmZmVyVGFnID0gJ1tvYmplY3QgQXJyYXlCdWZmZXJdJyxcbiAgICBkYXRhVmlld1RhZyA9ICdbb2JqZWN0IERhdGFWaWV3XScsXG4gICAgZmxvYXQzMlRhZyA9ICdbb2JqZWN0IEZsb2F0MzJBcnJheV0nLFxuICAgIGZsb2F0NjRUYWcgPSAnW29iamVjdCBGbG9hdDY0QXJyYXldJyxcbiAgICBpbnQ4VGFnID0gJ1tvYmplY3QgSW50OEFycmF5XScsXG4gICAgaW50MTZUYWcgPSAnW29iamVjdCBJbnQxNkFycmF5XScsXG4gICAgaW50MzJUYWcgPSAnW29iamVjdCBJbnQzMkFycmF5XScsXG4gICAgdWludDhUYWcgPSAnW29iamVjdCBVaW50OEFycmF5XScsXG4gICAgdWludDhDbGFtcGVkVGFnID0gJ1tvYmplY3QgVWludDhDbGFtcGVkQXJyYXldJyxcbiAgICB1aW50MTZUYWcgPSAnW29iamVjdCBVaW50MTZBcnJheV0nLFxuICAgIHVpbnQzMlRhZyA9ICdbb2JqZWN0IFVpbnQzMkFycmF5XSc7XG5cbi8qKiBVc2VkIHRvIGlkZW50aWZ5IGB0b1N0cmluZ1RhZ2AgdmFsdWVzIHN1cHBvcnRlZCBieSBgXy5jbG9uZWAuICovXG52YXIgY2xvbmVhYmxlVGFncyA9IHt9O1xuY2xvbmVhYmxlVGFnc1thcmdzVGFnXSA9IGNsb25lYWJsZVRhZ3NbYXJyYXlUYWddID1cbmNsb25lYWJsZVRhZ3NbYXJyYXlCdWZmZXJUYWddID0gY2xvbmVhYmxlVGFnc1tkYXRhVmlld1RhZ10gPVxuY2xvbmVhYmxlVGFnc1tib29sVGFnXSA9IGNsb25lYWJsZVRhZ3NbZGF0ZVRhZ10gPVxuY2xvbmVhYmxlVGFnc1tmbG9hdDMyVGFnXSA9IGNsb25lYWJsZVRhZ3NbZmxvYXQ2NFRhZ10gPVxuY2xvbmVhYmxlVGFnc1tpbnQ4VGFnXSA9IGNsb25lYWJsZVRhZ3NbaW50MTZUYWddID1cbmNsb25lYWJsZVRhZ3NbaW50MzJUYWddID0gY2xvbmVhYmxlVGFnc1ttYXBUYWddID1cbmNsb25lYWJsZVRhZ3NbbnVtYmVyVGFnXSA9IGNsb25lYWJsZVRhZ3Nbb2JqZWN0VGFnXSA9XG5jbG9uZWFibGVUYWdzW3JlZ2V4cFRhZ10gPSBjbG9uZWFibGVUYWdzW3NldFRhZ10gPVxuY2xvbmVhYmxlVGFnc1tzdHJpbmdUYWddID0gY2xvbmVhYmxlVGFnc1tzeW1ib2xUYWddID1cbmNsb25lYWJsZVRhZ3NbdWludDhUYWddID0gY2xvbmVhYmxlVGFnc1t1aW50OENsYW1wZWRUYWddID1cbmNsb25lYWJsZVRhZ3NbdWludDE2VGFnXSA9IGNsb25lYWJsZVRhZ3NbdWludDMyVGFnXSA9IHRydWU7XG5jbG9uZWFibGVUYWdzW2Vycm9yVGFnXSA9IGNsb25lYWJsZVRhZ3NbZnVuY1RhZ10gPVxuY2xvbmVhYmxlVGFnc1t3ZWFrTWFwVGFnXSA9IGZhbHNlO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmNsb25lYCBhbmQgYF8uY2xvbmVEZWVwYCB3aGljaCB0cmFja3NcbiAqIHRyYXZlcnNlZCBvYmplY3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjbG9uZS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy5cbiAqICAxIC0gRGVlcCBjbG9uZVxuICogIDIgLSBGbGF0dGVuIGluaGVyaXRlZCBwcm9wZXJ0aWVzXG4gKiAgNCAtIENsb25lIHN5bWJvbHNcbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNsb25pbmcuXG4gKiBAcGFyYW0ge3N0cmluZ30gW2tleV0gVGhlIGtleSBvZiBgdmFsdWVgLlxuICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3RdIFRoZSBwYXJlbnQgb2JqZWN0IG9mIGB2YWx1ZWAuXG4gKiBAcGFyYW0ge09iamVjdH0gW3N0YWNrXSBUcmFja3MgdHJhdmVyc2VkIG9iamVjdHMgYW5kIHRoZWlyIGNsb25lIGNvdW50ZXJwYXJ0cy5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBjbG9uZWQgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGJhc2VDbG9uZSh2YWx1ZSwgYml0bWFzaywgY3VzdG9taXplciwga2V5LCBvYmplY3QsIHN0YWNrKSB7XG4gIHZhciByZXN1bHQsXG4gICAgICBpc0RlZXAgPSBiaXRtYXNrICYgQ0xPTkVfREVFUF9GTEFHLFxuICAgICAgaXNGbGF0ID0gYml0bWFzayAmIENMT05FX0ZMQVRfRkxBRyxcbiAgICAgIGlzRnVsbCA9IGJpdG1hc2sgJiBDTE9ORV9TWU1CT0xTX0ZMQUc7XG5cbiAgaWYgKGN1c3RvbWl6ZXIpIHtcbiAgICByZXN1bHQgPSBvYmplY3QgPyBjdXN0b21pemVyKHZhbHVlLCBrZXksIG9iamVjdCwgc3RhY2spIDogY3VzdG9taXplcih2YWx1ZSk7XG4gIH1cbiAgaWYgKHJlc3VsdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBpZiAoIWlzT2JqZWN0KHZhbHVlKSkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICB2YXIgaXNBcnIgPSBpc0FycmF5KHZhbHVlKTtcbiAgaWYgKGlzQXJyKSB7XG4gICAgcmVzdWx0ID0gaW5pdENsb25lQXJyYXkodmFsdWUpO1xuICAgIGlmICghaXNEZWVwKSB7XG4gICAgICByZXR1cm4gY29weUFycmF5KHZhbHVlLCByZXN1bHQpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YXIgdGFnID0gZ2V0VGFnKHZhbHVlKSxcbiAgICAgICAgaXNGdW5jID0gdGFnID09IGZ1bmNUYWcgfHwgdGFnID09IGdlblRhZztcblxuICAgIGlmIChpc0J1ZmZlcih2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBjbG9uZUJ1ZmZlcih2YWx1ZSwgaXNEZWVwKTtcbiAgICB9XG4gICAgaWYgKHRhZyA9PSBvYmplY3RUYWcgfHwgdGFnID09IGFyZ3NUYWcgfHwgKGlzRnVuYyAmJiAhb2JqZWN0KSkge1xuICAgICAgcmVzdWx0ID0gKGlzRmxhdCB8fCBpc0Z1bmMpID8ge30gOiBpbml0Q2xvbmVPYmplY3QodmFsdWUpO1xuICAgICAgaWYgKCFpc0RlZXApIHtcbiAgICAgICAgcmV0dXJuIGlzRmxhdFxuICAgICAgICAgID8gY29weVN5bWJvbHNJbih2YWx1ZSwgYmFzZUFzc2lnbkluKHJlc3VsdCwgdmFsdWUpKVxuICAgICAgICAgIDogY29weVN5bWJvbHModmFsdWUsIGJhc2VBc3NpZ24ocmVzdWx0LCB2YWx1ZSkpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoIWNsb25lYWJsZVRhZ3NbdGFnXSkge1xuICAgICAgICByZXR1cm4gb2JqZWN0ID8gdmFsdWUgOiB7fTtcbiAgICAgIH1cbiAgICAgIHJlc3VsdCA9IGluaXRDbG9uZUJ5VGFnKHZhbHVlLCB0YWcsIGlzRGVlcCk7XG4gICAgfVxuICB9XG4gIC8vIENoZWNrIGZvciBjaXJjdWxhciByZWZlcmVuY2VzIGFuZCByZXR1cm4gaXRzIGNvcnJlc3BvbmRpbmcgY2xvbmUuXG4gIHN0YWNrIHx8IChzdGFjayA9IG5ldyBTdGFjayk7XG4gIHZhciBzdGFja2VkID0gc3RhY2suZ2V0KHZhbHVlKTtcbiAgaWYgKHN0YWNrZWQpIHtcbiAgICByZXR1cm4gc3RhY2tlZDtcbiAgfVxuICBzdGFjay5zZXQodmFsdWUsIHJlc3VsdCk7XG5cbiAgaWYgKGlzU2V0KHZhbHVlKSkge1xuICAgIHZhbHVlLmZvckVhY2goZnVuY3Rpb24oc3ViVmFsdWUpIHtcbiAgICAgIHJlc3VsdC5hZGQoYmFzZUNsb25lKHN1YlZhbHVlLCBiaXRtYXNrLCBjdXN0b21pemVyLCBzdWJWYWx1ZSwgdmFsdWUsIHN0YWNrKSk7XG4gICAgfSk7XG4gIH0gZWxzZSBpZiAoaXNNYXAodmFsdWUpKSB7XG4gICAgdmFsdWUuZm9yRWFjaChmdW5jdGlvbihzdWJWYWx1ZSwga2V5KSB7XG4gICAgICByZXN1bHQuc2V0KGtleSwgYmFzZUNsb25lKHN1YlZhbHVlLCBiaXRtYXNrLCBjdXN0b21pemVyLCBrZXksIHZhbHVlLCBzdGFjaykpO1xuICAgIH0pO1xuICB9XG5cbiAgdmFyIGtleXNGdW5jID0gaXNGdWxsXG4gICAgPyAoaXNGbGF0ID8gZ2V0QWxsS2V5c0luIDogZ2V0QWxsS2V5cylcbiAgICA6IChpc0ZsYXQgPyBrZXlzSW4gOiBrZXlzKTtcblxuICB2YXIgcHJvcHMgPSBpc0FyciA/IHVuZGVmaW5lZCA6IGtleXNGdW5jKHZhbHVlKTtcbiAgYXJyYXlFYWNoKHByb3BzIHx8IHZhbHVlLCBmdW5jdGlvbihzdWJWYWx1ZSwga2V5KSB7XG4gICAgaWYgKHByb3BzKSB7XG4gICAgICBrZXkgPSBzdWJWYWx1ZTtcbiAgICAgIHN1YlZhbHVlID0gdmFsdWVba2V5XTtcbiAgICB9XG4gICAgLy8gUmVjdXJzaXZlbHkgcG9wdWxhdGUgY2xvbmUgKHN1c2NlcHRpYmxlIHRvIGNhbGwgc3RhY2sgbGltaXRzKS5cbiAgICBhc3NpZ25WYWx1ZShyZXN1bHQsIGtleSwgYmFzZUNsb25lKHN1YlZhbHVlLCBiaXRtYXNrLCBjdXN0b21pemVyLCBrZXksIHZhbHVlLCBzdGFjaykpO1xuICB9KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlQ2xvbmU7XG4iLCJ2YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL2lzT2JqZWN0Jyk7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdENyZWF0ZSA9IE9iamVjdC5jcmVhdGU7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uY3JlYXRlYCB3aXRob3V0IHN1cHBvcnQgZm9yIGFzc2lnbmluZ1xuICogcHJvcGVydGllcyB0byB0aGUgY3JlYXRlZCBvYmplY3QuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBwcm90byBUaGUgb2JqZWN0IHRvIGluaGVyaXQgZnJvbS5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBvYmplY3QuXG4gKi9cbnZhciBiYXNlQ3JlYXRlID0gKGZ1bmN0aW9uKCkge1xuICBmdW5jdGlvbiBvYmplY3QoKSB7fVxuICByZXR1cm4gZnVuY3Rpb24ocHJvdG8pIHtcbiAgICBpZiAoIWlzT2JqZWN0KHByb3RvKSkge1xuICAgICAgcmV0dXJuIHt9O1xuICAgIH1cbiAgICBpZiAob2JqZWN0Q3JlYXRlKSB7XG4gICAgICByZXR1cm4gb2JqZWN0Q3JlYXRlKHByb3RvKTtcbiAgICB9XG4gICAgb2JqZWN0LnByb3RvdHlwZSA9IHByb3RvO1xuICAgIHZhciByZXN1bHQgPSBuZXcgb2JqZWN0O1xuICAgIG9iamVjdC5wcm90b3R5cGUgPSB1bmRlZmluZWQ7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcbn0oKSk7XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUNyZWF0ZTtcbiIsInZhciBiYXNlRm9yT3duID0gcmVxdWlyZSgnLi9fYmFzZUZvck93bicpLFxuICAgIGNyZWF0ZUJhc2VFYWNoID0gcmVxdWlyZSgnLi9fY3JlYXRlQmFzZUVhY2gnKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5mb3JFYWNoYCB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcmV0dXJucyB7QXJyYXl8T2JqZWN0fSBSZXR1cm5zIGBjb2xsZWN0aW9uYC5cbiAqL1xudmFyIGJhc2VFYWNoID0gY3JlYXRlQmFzZUVhY2goYmFzZUZvck93bik7XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUVhY2g7XG4iLCJ2YXIgaXNTeW1ib2wgPSByZXF1aXJlKCcuL2lzU3ltYm9sJyk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgbWV0aG9kcyBsaWtlIGBfLm1heGAgYW5kIGBfLm1pbmAgd2hpY2ggYWNjZXB0cyBhXG4gKiBgY29tcGFyYXRvcmAgdG8gZGV0ZXJtaW5lIHRoZSBleHRyZW11bSB2YWx1ZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBpdGVyYXRlZSBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjb21wYXJhdG9yIFRoZSBjb21wYXJhdG9yIHVzZWQgdG8gY29tcGFyZSB2YWx1ZXMuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZXh0cmVtdW0gdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGJhc2VFeHRyZW11bShhcnJheSwgaXRlcmF0ZWUsIGNvbXBhcmF0b3IpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIgdmFsdWUgPSBhcnJheVtpbmRleF0sXG4gICAgICAgIGN1cnJlbnQgPSBpdGVyYXRlZSh2YWx1ZSk7XG5cbiAgICBpZiAoY3VycmVudCAhPSBudWxsICYmIChjb21wdXRlZCA9PT0gdW5kZWZpbmVkXG4gICAgICAgICAgPyAoY3VycmVudCA9PT0gY3VycmVudCAmJiAhaXNTeW1ib2woY3VycmVudCkpXG4gICAgICAgICAgOiBjb21wYXJhdG9yKGN1cnJlbnQsIGNvbXB1dGVkKVxuICAgICAgICApKSB7XG4gICAgICB2YXIgY29tcHV0ZWQgPSBjdXJyZW50LFxuICAgICAgICAgIHJlc3VsdCA9IHZhbHVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VFeHRyZW11bTtcbiIsInZhciBiYXNlRWFjaCA9IHJlcXVpcmUoJy4vX2Jhc2VFYWNoJyk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZmlsdGVyYCB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWRpY2F0ZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZmlsdGVyZWQgYXJyYXkuXG4gKi9cbmZ1bmN0aW9uIGJhc2VGaWx0ZXIoY29sbGVjdGlvbiwgcHJlZGljYXRlKSB7XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgYmFzZUVhY2goY29sbGVjdGlvbiwgZnVuY3Rpb24odmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKSB7XG4gICAgaWYgKHByZWRpY2F0ZSh2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pKSB7XG4gICAgICByZXN1bHQucHVzaCh2YWx1ZSk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlRmlsdGVyO1xuIiwiLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5maW5kSW5kZXhgIGFuZCBgXy5maW5kTGFzdEluZGV4YCB3aXRob3V0XG4gKiBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWRpY2F0ZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHBhcmFtIHtudW1iZXJ9IGZyb21JbmRleCBUaGUgaW5kZXggdG8gc2VhcmNoIGZyb20uXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtmcm9tUmlnaHRdIFNwZWNpZnkgaXRlcmF0aW5nIGZyb20gcmlnaHQgdG8gbGVmdC5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBtYXRjaGVkIHZhbHVlLCBlbHNlIGAtMWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VGaW5kSW5kZXgoYXJyYXksIHByZWRpY2F0ZSwgZnJvbUluZGV4LCBmcm9tUmlnaHQpIHtcbiAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aCxcbiAgICAgIGluZGV4ID0gZnJvbUluZGV4ICsgKGZyb21SaWdodCA/IDEgOiAtMSk7XG5cbiAgd2hpbGUgKChmcm9tUmlnaHQgPyBpbmRleC0tIDogKytpbmRleCA8IGxlbmd0aCkpIHtcbiAgICBpZiAocHJlZGljYXRlKGFycmF5W2luZGV4XSwgaW5kZXgsIGFycmF5KSkge1xuICAgICAgcmV0dXJuIGluZGV4O1xuICAgIH1cbiAgfVxuICByZXR1cm4gLTE7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUZpbmRJbmRleDtcbiIsInZhciBhcnJheVB1c2ggPSByZXF1aXJlKCcuL19hcnJheVB1c2gnKSxcbiAgICBpc0ZsYXR0ZW5hYmxlID0gcmVxdWlyZSgnLi9faXNGbGF0dGVuYWJsZScpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmZsYXR0ZW5gIHdpdGggc3VwcG9ydCBmb3IgcmVzdHJpY3RpbmcgZmxhdHRlbmluZy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGZsYXR0ZW4uXG4gKiBAcGFyYW0ge251bWJlcn0gZGVwdGggVGhlIG1heGltdW0gcmVjdXJzaW9uIGRlcHRoLlxuICogQHBhcmFtIHtib29sZWFufSBbcHJlZGljYXRlPWlzRmxhdHRlbmFibGVdIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtpc1N0cmljdF0gUmVzdHJpY3QgdG8gdmFsdWVzIHRoYXQgcGFzcyBgcHJlZGljYXRlYCBjaGVja3MuXG4gKiBAcGFyYW0ge0FycmF5fSBbcmVzdWx0PVtdXSBUaGUgaW5pdGlhbCByZXN1bHQgdmFsdWUuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBmbGF0dGVuZWQgYXJyYXkuXG4gKi9cbmZ1bmN0aW9uIGJhc2VGbGF0dGVuKGFycmF5LCBkZXB0aCwgcHJlZGljYXRlLCBpc1N0cmljdCwgcmVzdWx0KSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuXG4gIHByZWRpY2F0ZSB8fCAocHJlZGljYXRlID0gaXNGbGF0dGVuYWJsZSk7XG4gIHJlc3VsdCB8fCAocmVzdWx0ID0gW10pO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIHZhbHVlID0gYXJyYXlbaW5kZXhdO1xuICAgIGlmIChkZXB0aCA+IDAgJiYgcHJlZGljYXRlKHZhbHVlKSkge1xuICAgICAgaWYgKGRlcHRoID4gMSkge1xuICAgICAgICAvLyBSZWN1cnNpdmVseSBmbGF0dGVuIGFycmF5cyAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpLlxuICAgICAgICBiYXNlRmxhdHRlbih2YWx1ZSwgZGVwdGggLSAxLCBwcmVkaWNhdGUsIGlzU3RyaWN0LCByZXN1bHQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYXJyYXlQdXNoKHJlc3VsdCwgdmFsdWUpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoIWlzU3RyaWN0KSB7XG4gICAgICByZXN1bHRbcmVzdWx0Lmxlbmd0aF0gPSB2YWx1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlRmxhdHRlbjtcbiIsInZhciBjcmVhdGVCYXNlRm9yID0gcmVxdWlyZSgnLi9fY3JlYXRlQmFzZUZvcicpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBiYXNlRm9yT3duYCB3aGljaCBpdGVyYXRlcyBvdmVyIGBvYmplY3RgXG4gKiBwcm9wZXJ0aWVzIHJldHVybmVkIGJ5IGBrZXlzRnVuY2AgYW5kIGludm9rZXMgYGl0ZXJhdGVlYCBmb3IgZWFjaCBwcm9wZXJ0eS5cbiAqIEl0ZXJhdGVlIGZ1bmN0aW9ucyBtYXkgZXhpdCBpdGVyYXRpb24gZWFybHkgYnkgZXhwbGljaXRseSByZXR1cm5pbmcgYGZhbHNlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBrZXlzRnVuYyBUaGUgZnVuY3Rpb24gdG8gZ2V0IHRoZSBrZXlzIG9mIGBvYmplY3RgLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAqL1xudmFyIGJhc2VGb3IgPSBjcmVhdGVCYXNlRm9yKCk7XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUZvcjtcbiIsInZhciBiYXNlRm9yID0gcmVxdWlyZSgnLi9fYmFzZUZvcicpLFxuICAgIGtleXMgPSByZXF1aXJlKCcuL2tleXMnKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5mb3JPd25gIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICovXG5mdW5jdGlvbiBiYXNlRm9yT3duKG9iamVjdCwgaXRlcmF0ZWUpIHtcbiAgcmV0dXJuIG9iamVjdCAmJiBiYXNlRm9yKG9iamVjdCwgaXRlcmF0ZWUsIGtleXMpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VGb3JPd247XG4iLCJ2YXIgY2FzdFBhdGggPSByZXF1aXJlKCcuL19jYXN0UGF0aCcpLFxuICAgIHRvS2V5ID0gcmVxdWlyZSgnLi9fdG9LZXknKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5nZXRgIHdpdGhvdXQgc3VwcG9ydCBmb3IgZGVmYXVsdCB2YWx1ZXMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcmVzb2x2ZWQgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGJhc2VHZXQob2JqZWN0LCBwYXRoKSB7XG4gIHBhdGggPSBjYXN0UGF0aChwYXRoLCBvYmplY3QpO1xuXG4gIHZhciBpbmRleCA9IDAsXG4gICAgICBsZW5ndGggPSBwYXRoLmxlbmd0aDtcblxuICB3aGlsZSAob2JqZWN0ICE9IG51bGwgJiYgaW5kZXggPCBsZW5ndGgpIHtcbiAgICBvYmplY3QgPSBvYmplY3RbdG9LZXkocGF0aFtpbmRleCsrXSldO1xuICB9XG4gIHJldHVybiAoaW5kZXggJiYgaW5kZXggPT0gbGVuZ3RoKSA/IG9iamVjdCA6IHVuZGVmaW5lZDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlR2V0O1xuIiwidmFyIGFycmF5UHVzaCA9IHJlcXVpcmUoJy4vX2FycmF5UHVzaCcpLFxuICAgIGlzQXJyYXkgPSByZXF1aXJlKCcuL2lzQXJyYXknKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgZ2V0QWxsS2V5c2AgYW5kIGBnZXRBbGxLZXlzSW5gIHdoaWNoIHVzZXNcbiAqIGBrZXlzRnVuY2AgYW5kIGBzeW1ib2xzRnVuY2AgdG8gZ2V0IHRoZSBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIGFuZFxuICogc3ltYm9scyBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtGdW5jdGlvbn0ga2V5c0Z1bmMgVGhlIGZ1bmN0aW9uIHRvIGdldCB0aGUga2V5cyBvZiBgb2JqZWN0YC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHN5bWJvbHNGdW5jIFRoZSBmdW5jdGlvbiB0byBnZXQgdGhlIHN5bWJvbHMgb2YgYG9iamVjdGAuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzIGFuZCBzeW1ib2xzLlxuICovXG5mdW5jdGlvbiBiYXNlR2V0QWxsS2V5cyhvYmplY3QsIGtleXNGdW5jLCBzeW1ib2xzRnVuYykge1xuICB2YXIgcmVzdWx0ID0ga2V5c0Z1bmMob2JqZWN0KTtcbiAgcmV0dXJuIGlzQXJyYXkob2JqZWN0KSA/IHJlc3VsdCA6IGFycmF5UHVzaChyZXN1bHQsIHN5bWJvbHNGdW5jKG9iamVjdCkpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VHZXRBbGxLZXlzO1xuIiwidmFyIFN5bWJvbCA9IHJlcXVpcmUoJy4vX1N5bWJvbCcpLFxuICAgIGdldFJhd1RhZyA9IHJlcXVpcmUoJy4vX2dldFJhd1RhZycpLFxuICAgIG9iamVjdFRvU3RyaW5nID0gcmVxdWlyZSgnLi9fb2JqZWN0VG9TdHJpbmcnKTtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIG51bGxUYWcgPSAnW29iamVjdCBOdWxsXScsXG4gICAgdW5kZWZpbmVkVGFnID0gJ1tvYmplY3QgVW5kZWZpbmVkXSc7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIHN5bVRvU3RyaW5nVGFnID0gU3ltYm9sID8gU3ltYm9sLnRvU3RyaW5nVGFnIDogdW5kZWZpbmVkO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBnZXRUYWdgIHdpdGhvdXQgZmFsbGJhY2tzIGZvciBidWdneSBlbnZpcm9ubWVudHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHF1ZXJ5LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgYHRvU3RyaW5nVGFnYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUdldFRhZyh2YWx1ZSkge1xuICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgIHJldHVybiB2YWx1ZSA9PT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkVGFnIDogbnVsbFRhZztcbiAgfVxuICByZXR1cm4gKHN5bVRvU3RyaW5nVGFnICYmIHN5bVRvU3RyaW5nVGFnIGluIE9iamVjdCh2YWx1ZSkpXG4gICAgPyBnZXRSYXdUYWcodmFsdWUpXG4gICAgOiBvYmplY3RUb1N0cmluZyh2YWx1ZSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUdldFRhZztcbiIsIi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZ3RgIHdoaWNoIGRvZXNuJ3QgY29lcmNlIGFyZ3VtZW50cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7Kn0gb3RoZXIgVGhlIG90aGVyIHZhbHVlIHRvIGNvbXBhcmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBncmVhdGVyIHRoYW4gYG90aGVyYCxcbiAqICBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VHdCh2YWx1ZSwgb3RoZXIpIHtcbiAgcmV0dXJuIHZhbHVlID4gb3RoZXI7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUd0O1xuIiwiLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5oYXNgIHdpdGhvdXQgc3VwcG9ydCBmb3IgZGVlcCBwYXRocy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3RdIFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge0FycmF5fHN0cmluZ30ga2V5IFRoZSBrZXkgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VIYXMob2JqZWN0LCBrZXkpIHtcbiAgcmV0dXJuIG9iamVjdCAhPSBudWxsICYmIGhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBrZXkpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VIYXM7XG4iLCIvKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmhhc0luYCB3aXRob3V0IHN1cHBvcnQgZm9yIGRlZXAgcGF0aHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0XSBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IGtleSBUaGUga2V5IHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBiYXNlSGFzSW4ob2JqZWN0LCBrZXkpIHtcbiAgcmV0dXJuIG9iamVjdCAhPSBudWxsICYmIGtleSBpbiBPYmplY3Qob2JqZWN0KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlSGFzSW47XG4iLCJ2YXIgYmFzZUZpbmRJbmRleCA9IHJlcXVpcmUoJy4vX2Jhc2VGaW5kSW5kZXgnKSxcbiAgICBiYXNlSXNOYU4gPSByZXF1aXJlKCcuL19iYXNlSXNOYU4nKSxcbiAgICBzdHJpY3RJbmRleE9mID0gcmVxdWlyZSgnLi9fc3RyaWN0SW5kZXhPZicpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmluZGV4T2ZgIHdpdGhvdXQgYGZyb21JbmRleGAgYm91bmRzIGNoZWNrcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZWFyY2ggZm9yLlxuICogQHBhcmFtIHtudW1iZXJ9IGZyb21JbmRleCBUaGUgaW5kZXggdG8gc2VhcmNoIGZyb20uXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgbWF0Y2hlZCB2YWx1ZSwgZWxzZSBgLTFgLlxuICovXG5mdW5jdGlvbiBiYXNlSW5kZXhPZihhcnJheSwgdmFsdWUsIGZyb21JbmRleCkge1xuICByZXR1cm4gdmFsdWUgPT09IHZhbHVlXG4gICAgPyBzdHJpY3RJbmRleE9mKGFycmF5LCB2YWx1ZSwgZnJvbUluZGV4KVxuICAgIDogYmFzZUZpbmRJbmRleChhcnJheSwgYmFzZUlzTmFOLCBmcm9tSW5kZXgpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VJbmRleE9mO1xuIiwidmFyIGJhc2VHZXRUYWcgPSByZXF1aXJlKCcuL19iYXNlR2V0VGFnJyksXG4gICAgaXNPYmplY3RMaWtlID0gcmVxdWlyZSgnLi9pc09iamVjdExpa2UnKTtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIGFyZ3NUYWcgPSAnW29iamVjdCBBcmd1bWVudHNdJztcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc0FyZ3VtZW50c2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gYGFyZ3VtZW50c2Agb2JqZWN0LFxuICovXG5mdW5jdGlvbiBiYXNlSXNBcmd1bWVudHModmFsdWUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgYmFzZUdldFRhZyh2YWx1ZSkgPT0gYXJnc1RhZztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlSXNBcmd1bWVudHM7XG4iLCJ2YXIgYmFzZUlzRXF1YWxEZWVwID0gcmVxdWlyZSgnLi9fYmFzZUlzRXF1YWxEZWVwJyksXG4gICAgaXNPYmplY3RMaWtlID0gcmVxdWlyZSgnLi9pc09iamVjdExpa2UnKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc0VxdWFsYCB3aGljaCBzdXBwb3J0cyBwYXJ0aWFsIGNvbXBhcmlzb25zXG4gKiBhbmQgdHJhY2tzIHRyYXZlcnNlZCBvYmplY3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb21wYXJlLlxuICogQHBhcmFtIHsqfSBvdGhlciBUaGUgb3RoZXIgdmFsdWUgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy5cbiAqICAxIC0gVW5vcmRlcmVkIGNvbXBhcmlzb25cbiAqICAyIC0gUGFydGlhbCBjb21wYXJpc29uXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb21wYXJpc29ucy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbc3RhY2tdIFRyYWNrcyB0cmF2ZXJzZWQgYHZhbHVlYCBhbmQgYG90aGVyYCBvYmplY3RzLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSB2YWx1ZXMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUlzRXF1YWwodmFsdWUsIG90aGVyLCBiaXRtYXNrLCBjdXN0b21pemVyLCBzdGFjaykge1xuICBpZiAodmFsdWUgPT09IG90aGVyKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKHZhbHVlID09IG51bGwgfHwgb3RoZXIgPT0gbnVsbCB8fCAoIWlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgIWlzT2JqZWN0TGlrZShvdGhlcikpKSB7XG4gICAgcmV0dXJuIHZhbHVlICE9PSB2YWx1ZSAmJiBvdGhlciAhPT0gb3RoZXI7XG4gIH1cbiAgcmV0dXJuIGJhc2VJc0VxdWFsRGVlcCh2YWx1ZSwgb3RoZXIsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGJhc2VJc0VxdWFsLCBzdGFjayk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUlzRXF1YWw7XG4iLCJ2YXIgU3RhY2sgPSByZXF1aXJlKCcuL19TdGFjaycpLFxuICAgIGVxdWFsQXJyYXlzID0gcmVxdWlyZSgnLi9fZXF1YWxBcnJheXMnKSxcbiAgICBlcXVhbEJ5VGFnID0gcmVxdWlyZSgnLi9fZXF1YWxCeVRhZycpLFxuICAgIGVxdWFsT2JqZWN0cyA9IHJlcXVpcmUoJy4vX2VxdWFsT2JqZWN0cycpLFxuICAgIGdldFRhZyA9IHJlcXVpcmUoJy4vX2dldFRhZycpLFxuICAgIGlzQXJyYXkgPSByZXF1aXJlKCcuL2lzQXJyYXknKSxcbiAgICBpc0J1ZmZlciA9IHJlcXVpcmUoJy4vaXNCdWZmZXInKSxcbiAgICBpc1R5cGVkQXJyYXkgPSByZXF1aXJlKCcuL2lzVHlwZWRBcnJheScpO1xuXG4vKiogVXNlZCB0byBjb21wb3NlIGJpdG1hc2tzIGZvciB2YWx1ZSBjb21wYXJpc29ucy4gKi9cbnZhciBDT01QQVJFX1BBUlRJQUxfRkxBRyA9IDE7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBhcmdzVGFnID0gJ1tvYmplY3QgQXJndW1lbnRzXScsXG4gICAgYXJyYXlUYWcgPSAnW29iamVjdCBBcnJheV0nLFxuICAgIG9iamVjdFRhZyA9ICdbb2JqZWN0IE9iamVjdF0nO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZUlzRXF1YWxgIGZvciBhcnJheXMgYW5kIG9iamVjdHMgd2hpY2ggcGVyZm9ybXNcbiAqIGRlZXAgY29tcGFyaXNvbnMgYW5kIHRyYWNrcyB0cmF2ZXJzZWQgb2JqZWN0cyBlbmFibGluZyBvYmplY3RzIHdpdGggY2lyY3VsYXJcbiAqIHJlZmVyZW5jZXMgdG8gYmUgY29tcGFyZWQuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBjb21wYXJlLlxuICogQHBhcmFtIHtPYmplY3R9IG90aGVyIFRoZSBvdGhlciBvYmplY3QgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBiaXRtYXNrIFRoZSBiaXRtYXNrIGZsYWdzLiBTZWUgYGJhc2VJc0VxdWFsYCBmb3IgbW9yZSBkZXRhaWxzLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY3VzdG9taXplciBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmlzb25zLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZXF1YWxGdW5jIFRoZSBmdW5jdGlvbiB0byBkZXRlcm1pbmUgZXF1aXZhbGVudHMgb2YgdmFsdWVzLlxuICogQHBhcmFtIHtPYmplY3R9IFtzdGFja10gVHJhY2tzIHRyYXZlcnNlZCBgb2JqZWN0YCBhbmQgYG90aGVyYCBvYmplY3RzLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBvYmplY3RzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VJc0VxdWFsRGVlcChvYmplY3QsIG90aGVyLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKSB7XG4gIHZhciBvYmpJc0FyciA9IGlzQXJyYXkob2JqZWN0KSxcbiAgICAgIG90aElzQXJyID0gaXNBcnJheShvdGhlciksXG4gICAgICBvYmpUYWcgPSBvYmpJc0FyciA/IGFycmF5VGFnIDogZ2V0VGFnKG9iamVjdCksXG4gICAgICBvdGhUYWcgPSBvdGhJc0FyciA/IGFycmF5VGFnIDogZ2V0VGFnKG90aGVyKTtcblxuICBvYmpUYWcgPSBvYmpUYWcgPT0gYXJnc1RhZyA/IG9iamVjdFRhZyA6IG9ialRhZztcbiAgb3RoVGFnID0gb3RoVGFnID09IGFyZ3NUYWcgPyBvYmplY3RUYWcgOiBvdGhUYWc7XG5cbiAgdmFyIG9iaklzT2JqID0gb2JqVGFnID09IG9iamVjdFRhZyxcbiAgICAgIG90aElzT2JqID0gb3RoVGFnID09IG9iamVjdFRhZyxcbiAgICAgIGlzU2FtZVRhZyA9IG9ialRhZyA9PSBvdGhUYWc7XG5cbiAgaWYgKGlzU2FtZVRhZyAmJiBpc0J1ZmZlcihvYmplY3QpKSB7XG4gICAgaWYgKCFpc0J1ZmZlcihvdGhlcikpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgb2JqSXNBcnIgPSB0cnVlO1xuICAgIG9iaklzT2JqID0gZmFsc2U7XG4gIH1cbiAgaWYgKGlzU2FtZVRhZyAmJiAhb2JqSXNPYmopIHtcbiAgICBzdGFjayB8fCAoc3RhY2sgPSBuZXcgU3RhY2spO1xuICAgIHJldHVybiAob2JqSXNBcnIgfHwgaXNUeXBlZEFycmF5KG9iamVjdCkpXG4gICAgICA/IGVxdWFsQXJyYXlzKG9iamVjdCwgb3RoZXIsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGVxdWFsRnVuYywgc3RhY2spXG4gICAgICA6IGVxdWFsQnlUYWcob2JqZWN0LCBvdGhlciwgb2JqVGFnLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKTtcbiAgfVxuICBpZiAoIShiaXRtYXNrICYgQ09NUEFSRV9QQVJUSUFMX0ZMQUcpKSB7XG4gICAgdmFyIG9iaklzV3JhcHBlZCA9IG9iaklzT2JqICYmIGhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCAnX193cmFwcGVkX18nKSxcbiAgICAgICAgb3RoSXNXcmFwcGVkID0gb3RoSXNPYmogJiYgaGFzT3duUHJvcGVydHkuY2FsbChvdGhlciwgJ19fd3JhcHBlZF9fJyk7XG5cbiAgICBpZiAob2JqSXNXcmFwcGVkIHx8IG90aElzV3JhcHBlZCkge1xuICAgICAgdmFyIG9ialVud3JhcHBlZCA9IG9iaklzV3JhcHBlZCA/IG9iamVjdC52YWx1ZSgpIDogb2JqZWN0LFxuICAgICAgICAgIG90aFVud3JhcHBlZCA9IG90aElzV3JhcHBlZCA/IG90aGVyLnZhbHVlKCkgOiBvdGhlcjtcblxuICAgICAgc3RhY2sgfHwgKHN0YWNrID0gbmV3IFN0YWNrKTtcbiAgICAgIHJldHVybiBlcXVhbEZ1bmMob2JqVW53cmFwcGVkLCBvdGhVbndyYXBwZWQsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIHN0YWNrKTtcbiAgICB9XG4gIH1cbiAgaWYgKCFpc1NhbWVUYWcpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgc3RhY2sgfHwgKHN0YWNrID0gbmV3IFN0YWNrKTtcbiAgcmV0dXJuIGVxdWFsT2JqZWN0cyhvYmplY3QsIG90aGVyLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlSXNFcXVhbERlZXA7XG4iLCJ2YXIgZ2V0VGFnID0gcmVxdWlyZSgnLi9fZ2V0VGFnJyksXG4gICAgaXNPYmplY3RMaWtlID0gcmVxdWlyZSgnLi9pc09iamVjdExpa2UnKTtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIG1hcFRhZyA9ICdbb2JqZWN0IE1hcF0nO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzTWFwYCB3aXRob3V0IE5vZGUuanMgb3B0aW1pemF0aW9ucy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIG1hcCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBiYXNlSXNNYXAodmFsdWUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgZ2V0VGFnKHZhbHVlKSA9PSBtYXBUYWc7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUlzTWFwO1xuIiwidmFyIFN0YWNrID0gcmVxdWlyZSgnLi9fU3RhY2snKSxcbiAgICBiYXNlSXNFcXVhbCA9IHJlcXVpcmUoJy4vX2Jhc2VJc0VxdWFsJyk7XG5cbi8qKiBVc2VkIHRvIGNvbXBvc2UgYml0bWFza3MgZm9yIHZhbHVlIGNvbXBhcmlzb25zLiAqL1xudmFyIENPTVBBUkVfUEFSVElBTF9GTEFHID0gMSxcbiAgICBDT01QQVJFX1VOT1JERVJFRF9GTEFHID0gMjtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc01hdGNoYCB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpbnNwZWN0LlxuICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgb2JqZWN0IG9mIHByb3BlcnR5IHZhbHVlcyB0byBtYXRjaC5cbiAqIEBwYXJhbSB7QXJyYXl9IG1hdGNoRGF0YSBUaGUgcHJvcGVydHkgbmFtZXMsIHZhbHVlcywgYW5kIGNvbXBhcmUgZmxhZ3MgdG8gbWF0Y2guXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb21wYXJpc29ucy5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgb2JqZWN0YCBpcyBhIG1hdGNoLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VJc01hdGNoKG9iamVjdCwgc291cmNlLCBtYXRjaERhdGEsIGN1c3RvbWl6ZXIpIHtcbiAgdmFyIGluZGV4ID0gbWF0Y2hEYXRhLmxlbmd0aCxcbiAgICAgIGxlbmd0aCA9IGluZGV4LFxuICAgICAgbm9DdXN0b21pemVyID0gIWN1c3RvbWl6ZXI7XG5cbiAgaWYgKG9iamVjdCA9PSBudWxsKSB7XG4gICAgcmV0dXJuICFsZW5ndGg7XG4gIH1cbiAgb2JqZWN0ID0gT2JqZWN0KG9iamVjdCk7XG4gIHdoaWxlIChpbmRleC0tKSB7XG4gICAgdmFyIGRhdGEgPSBtYXRjaERhdGFbaW5kZXhdO1xuICAgIGlmICgobm9DdXN0b21pemVyICYmIGRhdGFbMl0pXG4gICAgICAgICAgPyBkYXRhWzFdICE9PSBvYmplY3RbZGF0YVswXV1cbiAgICAgICAgICA6ICEoZGF0YVswXSBpbiBvYmplY3QpXG4gICAgICAgICkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIGRhdGEgPSBtYXRjaERhdGFbaW5kZXhdO1xuICAgIHZhciBrZXkgPSBkYXRhWzBdLFxuICAgICAgICBvYmpWYWx1ZSA9IG9iamVjdFtrZXldLFxuICAgICAgICBzcmNWYWx1ZSA9IGRhdGFbMV07XG5cbiAgICBpZiAobm9DdXN0b21pemVyICYmIGRhdGFbMl0pIHtcbiAgICAgIGlmIChvYmpWYWx1ZSA9PT0gdW5kZWZpbmVkICYmICEoa2V5IGluIG9iamVjdCkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgc3RhY2sgPSBuZXcgU3RhY2s7XG4gICAgICBpZiAoY3VzdG9taXplcikge1xuICAgICAgICB2YXIgcmVzdWx0ID0gY3VzdG9taXplcihvYmpWYWx1ZSwgc3JjVmFsdWUsIGtleSwgb2JqZWN0LCBzb3VyY2UsIHN0YWNrKTtcbiAgICAgIH1cbiAgICAgIGlmICghKHJlc3VsdCA9PT0gdW5kZWZpbmVkXG4gICAgICAgICAgICA/IGJhc2VJc0VxdWFsKHNyY1ZhbHVlLCBvYmpWYWx1ZSwgQ09NUEFSRV9QQVJUSUFMX0ZMQUcgfCBDT01QQVJFX1VOT1JERVJFRF9GTEFHLCBjdXN0b21pemVyLCBzdGFjaylcbiAgICAgICAgICAgIDogcmVzdWx0XG4gICAgICAgICAgKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VJc01hdGNoO1xuIiwiLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc05hTmAgd2l0aG91dCBzdXBwb3J0IGZvciBudW1iZXIgb2JqZWN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBgTmFOYCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBiYXNlSXNOYU4odmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlICE9PSB2YWx1ZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlSXNOYU47XG4iLCJ2YXIgaXNGdW5jdGlvbiA9IHJlcXVpcmUoJy4vaXNGdW5jdGlvbicpLFxuICAgIGlzTWFza2VkID0gcmVxdWlyZSgnLi9faXNNYXNrZWQnKSxcbiAgICBpc09iamVjdCA9IHJlcXVpcmUoJy4vaXNPYmplY3QnKSxcbiAgICB0b1NvdXJjZSA9IHJlcXVpcmUoJy4vX3RvU291cmNlJyk7XG5cbi8qKlxuICogVXNlZCB0byBtYXRjaCBgUmVnRXhwYFxuICogW3N5bnRheCBjaGFyYWN0ZXJzXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1wYXR0ZXJucykuXG4gKi9cbnZhciByZVJlZ0V4cENoYXIgPSAvW1xcXFxeJC4qKz8oKVtcXF17fXxdL2c7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBob3N0IGNvbnN0cnVjdG9ycyAoU2FmYXJpKS4gKi9cbnZhciByZUlzSG9zdEN0b3IgPSAvXlxcW29iamVjdCAuKz9Db25zdHJ1Y3RvclxcXSQvO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgZnVuY1Byb3RvID0gRnVuY3Rpb24ucHJvdG90eXBlLFxuICAgIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gcmVzb2x2ZSB0aGUgZGVjb21waWxlZCBzb3VyY2Ugb2YgZnVuY3Rpb25zLiAqL1xudmFyIGZ1bmNUb1N0cmluZyA9IGZ1bmNQcm90by50b1N0cmluZztcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IGlmIGEgbWV0aG9kIGlzIG5hdGl2ZS4gKi9cbnZhciByZUlzTmF0aXZlID0gUmVnRXhwKCdeJyArXG4gIGZ1bmNUb1N0cmluZy5jYWxsKGhhc093blByb3BlcnR5KS5yZXBsYWNlKHJlUmVnRXhwQ2hhciwgJ1xcXFwkJicpXG4gIC5yZXBsYWNlKC9oYXNPd25Qcm9wZXJ0eXwoZnVuY3Rpb24pLio/KD89XFxcXFxcKCl8IGZvciAuKz8oPz1cXFxcXFxdKS9nLCAnJDEuKj8nKSArICckJ1xuKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc05hdGl2ZWAgd2l0aG91dCBiYWQgc2hpbSBjaGVja3MuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBuYXRpdmUgZnVuY3Rpb24sXG4gKiAgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBiYXNlSXNOYXRpdmUodmFsdWUpIHtcbiAgaWYgKCFpc09iamVjdCh2YWx1ZSkgfHwgaXNNYXNrZWQodmFsdWUpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciBwYXR0ZXJuID0gaXNGdW5jdGlvbih2YWx1ZSkgPyByZUlzTmF0aXZlIDogcmVJc0hvc3RDdG9yO1xuICByZXR1cm4gcGF0dGVybi50ZXN0KHRvU291cmNlKHZhbHVlKSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUlzTmF0aXZlO1xuIiwidmFyIGdldFRhZyA9IHJlcXVpcmUoJy4vX2dldFRhZycpLFxuICAgIGlzT2JqZWN0TGlrZSA9IHJlcXVpcmUoJy4vaXNPYmplY3RMaWtlJyk7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBzZXRUYWcgPSAnW29iamVjdCBTZXRdJztcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc1NldGAgd2l0aG91dCBOb2RlLmpzIG9wdGltaXphdGlvbnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBzZXQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUlzU2V0KHZhbHVlKSB7XG4gIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmIGdldFRhZyh2YWx1ZSkgPT0gc2V0VGFnO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VJc1NldDtcbiIsInZhciBiYXNlR2V0VGFnID0gcmVxdWlyZSgnLi9fYmFzZUdldFRhZycpLFxuICAgIGlzTGVuZ3RoID0gcmVxdWlyZSgnLi9pc0xlbmd0aCcpLFxuICAgIGlzT2JqZWN0TGlrZSA9IHJlcXVpcmUoJy4vaXNPYmplY3RMaWtlJyk7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBhcmdzVGFnID0gJ1tvYmplY3QgQXJndW1lbnRzXScsXG4gICAgYXJyYXlUYWcgPSAnW29iamVjdCBBcnJheV0nLFxuICAgIGJvb2xUYWcgPSAnW29iamVjdCBCb29sZWFuXScsXG4gICAgZGF0ZVRhZyA9ICdbb2JqZWN0IERhdGVdJyxcbiAgICBlcnJvclRhZyA9ICdbb2JqZWN0IEVycm9yXScsXG4gICAgZnVuY1RhZyA9ICdbb2JqZWN0IEZ1bmN0aW9uXScsXG4gICAgbWFwVGFnID0gJ1tvYmplY3QgTWFwXScsXG4gICAgbnVtYmVyVGFnID0gJ1tvYmplY3QgTnVtYmVyXScsXG4gICAgb2JqZWN0VGFnID0gJ1tvYmplY3QgT2JqZWN0XScsXG4gICAgcmVnZXhwVGFnID0gJ1tvYmplY3QgUmVnRXhwXScsXG4gICAgc2V0VGFnID0gJ1tvYmplY3QgU2V0XScsXG4gICAgc3RyaW5nVGFnID0gJ1tvYmplY3QgU3RyaW5nXScsXG4gICAgd2Vha01hcFRhZyA9ICdbb2JqZWN0IFdlYWtNYXBdJztcblxudmFyIGFycmF5QnVmZmVyVGFnID0gJ1tvYmplY3QgQXJyYXlCdWZmZXJdJyxcbiAgICBkYXRhVmlld1RhZyA9ICdbb2JqZWN0IERhdGFWaWV3XScsXG4gICAgZmxvYXQzMlRhZyA9ICdbb2JqZWN0IEZsb2F0MzJBcnJheV0nLFxuICAgIGZsb2F0NjRUYWcgPSAnW29iamVjdCBGbG9hdDY0QXJyYXldJyxcbiAgICBpbnQ4VGFnID0gJ1tvYmplY3QgSW50OEFycmF5XScsXG4gICAgaW50MTZUYWcgPSAnW29iamVjdCBJbnQxNkFycmF5XScsXG4gICAgaW50MzJUYWcgPSAnW29iamVjdCBJbnQzMkFycmF5XScsXG4gICAgdWludDhUYWcgPSAnW29iamVjdCBVaW50OEFycmF5XScsXG4gICAgdWludDhDbGFtcGVkVGFnID0gJ1tvYmplY3QgVWludDhDbGFtcGVkQXJyYXldJyxcbiAgICB1aW50MTZUYWcgPSAnW29iamVjdCBVaW50MTZBcnJheV0nLFxuICAgIHVpbnQzMlRhZyA9ICdbb2JqZWN0IFVpbnQzMkFycmF5XSc7XG5cbi8qKiBVc2VkIHRvIGlkZW50aWZ5IGB0b1N0cmluZ1RhZ2AgdmFsdWVzIG9mIHR5cGVkIGFycmF5cy4gKi9cbnZhciB0eXBlZEFycmF5VGFncyA9IHt9O1xudHlwZWRBcnJheVRhZ3NbZmxvYXQzMlRhZ10gPSB0eXBlZEFycmF5VGFnc1tmbG9hdDY0VGFnXSA9XG50eXBlZEFycmF5VGFnc1tpbnQ4VGFnXSA9IHR5cGVkQXJyYXlUYWdzW2ludDE2VGFnXSA9XG50eXBlZEFycmF5VGFnc1tpbnQzMlRhZ10gPSB0eXBlZEFycmF5VGFnc1t1aW50OFRhZ10gPVxudHlwZWRBcnJheVRhZ3NbdWludDhDbGFtcGVkVGFnXSA9IHR5cGVkQXJyYXlUYWdzW3VpbnQxNlRhZ10gPVxudHlwZWRBcnJheVRhZ3NbdWludDMyVGFnXSA9IHRydWU7XG50eXBlZEFycmF5VGFnc1thcmdzVGFnXSA9IHR5cGVkQXJyYXlUYWdzW2FycmF5VGFnXSA9XG50eXBlZEFycmF5VGFnc1thcnJheUJ1ZmZlclRhZ10gPSB0eXBlZEFycmF5VGFnc1tib29sVGFnXSA9XG50eXBlZEFycmF5VGFnc1tkYXRhVmlld1RhZ10gPSB0eXBlZEFycmF5VGFnc1tkYXRlVGFnXSA9XG50eXBlZEFycmF5VGFnc1tlcnJvclRhZ10gPSB0eXBlZEFycmF5VGFnc1tmdW5jVGFnXSA9XG50eXBlZEFycmF5VGFnc1ttYXBUYWddID0gdHlwZWRBcnJheVRhZ3NbbnVtYmVyVGFnXSA9XG50eXBlZEFycmF5VGFnc1tvYmplY3RUYWddID0gdHlwZWRBcnJheVRhZ3NbcmVnZXhwVGFnXSA9XG50eXBlZEFycmF5VGFnc1tzZXRUYWddID0gdHlwZWRBcnJheVRhZ3Nbc3RyaW5nVGFnXSA9XG50eXBlZEFycmF5VGFnc1t3ZWFrTWFwVGFnXSA9IGZhbHNlO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzVHlwZWRBcnJheWAgd2l0aG91dCBOb2RlLmpzIG9wdGltaXphdGlvbnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB0eXBlZCBhcnJheSwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBiYXNlSXNUeXBlZEFycmF5KHZhbHVlKSB7XG4gIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmXG4gICAgaXNMZW5ndGgodmFsdWUubGVuZ3RoKSAmJiAhIXR5cGVkQXJyYXlUYWdzW2Jhc2VHZXRUYWcodmFsdWUpXTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlSXNUeXBlZEFycmF5O1xuIiwidmFyIGJhc2VNYXRjaGVzID0gcmVxdWlyZSgnLi9fYmFzZU1hdGNoZXMnKSxcbiAgICBiYXNlTWF0Y2hlc1Byb3BlcnR5ID0gcmVxdWlyZSgnLi9fYmFzZU1hdGNoZXNQcm9wZXJ0eScpLFxuICAgIGlkZW50aXR5ID0gcmVxdWlyZSgnLi9pZGVudGl0eScpLFxuICAgIGlzQXJyYXkgPSByZXF1aXJlKCcuL2lzQXJyYXknKSxcbiAgICBwcm9wZXJ0eSA9IHJlcXVpcmUoJy4vcHJvcGVydHknKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pdGVyYXRlZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gW3ZhbHVlPV8uaWRlbnRpdHldIFRoZSB2YWx1ZSB0byBjb252ZXJ0IHRvIGFuIGl0ZXJhdGVlLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBpdGVyYXRlZS5cbiAqL1xuZnVuY3Rpb24gYmFzZUl0ZXJhdGVlKHZhbHVlKSB7XG4gIC8vIERvbid0IHN0b3JlIHRoZSBgdHlwZW9mYCByZXN1bHQgaW4gYSB2YXJpYWJsZSB0byBhdm9pZCBhIEpJVCBidWcgaW4gU2FmYXJpIDkuXG4gIC8vIFNlZSBodHRwczovL2J1Z3Mud2Via2l0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTU2MDM0IGZvciBtb3JlIGRldGFpbHMuXG4gIGlmICh0eXBlb2YgdmFsdWUgPT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgIHJldHVybiBpZGVudGl0eTtcbiAgfVxuICBpZiAodHlwZW9mIHZhbHVlID09ICdvYmplY3QnKSB7XG4gICAgcmV0dXJuIGlzQXJyYXkodmFsdWUpXG4gICAgICA/IGJhc2VNYXRjaGVzUHJvcGVydHkodmFsdWVbMF0sIHZhbHVlWzFdKVxuICAgICAgOiBiYXNlTWF0Y2hlcyh2YWx1ZSk7XG4gIH1cbiAgcmV0dXJuIHByb3BlcnR5KHZhbHVlKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlSXRlcmF0ZWU7XG4iLCJ2YXIgaXNQcm90b3R5cGUgPSByZXF1aXJlKCcuL19pc1Byb3RvdHlwZScpLFxuICAgIG5hdGl2ZUtleXMgPSByZXF1aXJlKCcuL19uYXRpdmVLZXlzJyk7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ua2V5c2Agd2hpY2ggZG9lc24ndCB0cmVhdCBzcGFyc2UgYXJyYXlzIGFzIGRlbnNlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICovXG5mdW5jdGlvbiBiYXNlS2V5cyhvYmplY3QpIHtcbiAgaWYgKCFpc1Byb3RvdHlwZShvYmplY3QpKSB7XG4gICAgcmV0dXJuIG5hdGl2ZUtleXMob2JqZWN0KTtcbiAgfVxuICB2YXIgcmVzdWx0ID0gW107XG4gIGZvciAodmFyIGtleSBpbiBPYmplY3Qob2JqZWN0KSkge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwga2V5KSAmJiBrZXkgIT0gJ2NvbnN0cnVjdG9yJykge1xuICAgICAgcmVzdWx0LnB1c2goa2V5KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlS2V5cztcbiIsInZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vaXNPYmplY3QnKSxcbiAgICBpc1Byb3RvdHlwZSA9IHJlcXVpcmUoJy4vX2lzUHJvdG90eXBlJyksXG4gICAgbmF0aXZlS2V5c0luID0gcmVxdWlyZSgnLi9fbmF0aXZlS2V5c0luJyk7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ua2V5c0luYCB3aGljaCBkb2Vzbid0IHRyZWF0IHNwYXJzZSBhcnJheXMgYXMgZGVuc2UuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gKi9cbmZ1bmN0aW9uIGJhc2VLZXlzSW4ob2JqZWN0KSB7XG4gIGlmICghaXNPYmplY3Qob2JqZWN0KSkge1xuICAgIHJldHVybiBuYXRpdmVLZXlzSW4ob2JqZWN0KTtcbiAgfVxuICB2YXIgaXNQcm90byA9IGlzUHJvdG90eXBlKG9iamVjdCksXG4gICAgICByZXN1bHQgPSBbXTtcblxuICBmb3IgKHZhciBrZXkgaW4gb2JqZWN0KSB7XG4gICAgaWYgKCEoa2V5ID09ICdjb25zdHJ1Y3RvcicgJiYgKGlzUHJvdG8gfHwgIWhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBrZXkpKSkpIHtcbiAgICAgIHJlc3VsdC5wdXNoKGtleSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUtleXNJbjtcbiIsIi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ubHRgIHdoaWNoIGRvZXNuJ3QgY29lcmNlIGFyZ3VtZW50cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7Kn0gb3RoZXIgVGhlIG90aGVyIHZhbHVlIHRvIGNvbXBhcmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBsZXNzIHRoYW4gYG90aGVyYCxcbiAqICBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VMdCh2YWx1ZSwgb3RoZXIpIHtcbiAgcmV0dXJuIHZhbHVlIDwgb3RoZXI7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUx0O1xuIiwidmFyIGJhc2VFYWNoID0gcmVxdWlyZSgnLi9fYmFzZUVhY2gnKSxcbiAgICBpc0FycmF5TGlrZSA9IHJlcXVpcmUoJy4vaXNBcnJheUxpa2UnKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5tYXBgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IG1hcHBlZCBhcnJheS5cbiAqL1xuZnVuY3Rpb24gYmFzZU1hcChjb2xsZWN0aW9uLCBpdGVyYXRlZSkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIHJlc3VsdCA9IGlzQXJyYXlMaWtlKGNvbGxlY3Rpb24pID8gQXJyYXkoY29sbGVjdGlvbi5sZW5ndGgpIDogW107XG5cbiAgYmFzZUVhY2goY29sbGVjdGlvbiwgZnVuY3Rpb24odmFsdWUsIGtleSwgY29sbGVjdGlvbikge1xuICAgIHJlc3VsdFsrK2luZGV4XSA9IGl0ZXJhdGVlKHZhbHVlLCBrZXksIGNvbGxlY3Rpb24pO1xuICB9KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlTWFwO1xuIiwidmFyIGJhc2VJc01hdGNoID0gcmVxdWlyZSgnLi9fYmFzZUlzTWF0Y2gnKSxcbiAgICBnZXRNYXRjaERhdGEgPSByZXF1aXJlKCcuL19nZXRNYXRjaERhdGEnKSxcbiAgICBtYXRjaGVzU3RyaWN0Q29tcGFyYWJsZSA9IHJlcXVpcmUoJy4vX21hdGNoZXNTdHJpY3RDb21wYXJhYmxlJyk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ubWF0Y2hlc2Agd2hpY2ggZG9lc24ndCBjbG9uZSBgc291cmNlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgb2JqZWN0IG9mIHByb3BlcnR5IHZhbHVlcyB0byBtYXRjaC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHNwZWMgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGJhc2VNYXRjaGVzKHNvdXJjZSkge1xuICB2YXIgbWF0Y2hEYXRhID0gZ2V0TWF0Y2hEYXRhKHNvdXJjZSk7XG4gIGlmIChtYXRjaERhdGEubGVuZ3RoID09IDEgJiYgbWF0Y2hEYXRhWzBdWzJdKSB7XG4gICAgcmV0dXJuIG1hdGNoZXNTdHJpY3RDb21wYXJhYmxlKG1hdGNoRGF0YVswXVswXSwgbWF0Y2hEYXRhWzBdWzFdKTtcbiAgfVxuICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgcmV0dXJuIG9iamVjdCA9PT0gc291cmNlIHx8IGJhc2VJc01hdGNoKG9iamVjdCwgc291cmNlLCBtYXRjaERhdGEpO1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VNYXRjaGVzO1xuIiwidmFyIGJhc2VJc0VxdWFsID0gcmVxdWlyZSgnLi9fYmFzZUlzRXF1YWwnKSxcbiAgICBnZXQgPSByZXF1aXJlKCcuL2dldCcpLFxuICAgIGhhc0luID0gcmVxdWlyZSgnLi9oYXNJbicpLFxuICAgIGlzS2V5ID0gcmVxdWlyZSgnLi9faXNLZXknKSxcbiAgICBpc1N0cmljdENvbXBhcmFibGUgPSByZXF1aXJlKCcuL19pc1N0cmljdENvbXBhcmFibGUnKSxcbiAgICBtYXRjaGVzU3RyaWN0Q29tcGFyYWJsZSA9IHJlcXVpcmUoJy4vX21hdGNoZXNTdHJpY3RDb21wYXJhYmxlJyksXG4gICAgdG9LZXkgPSByZXF1aXJlKCcuL190b0tleScpO1xuXG4vKiogVXNlZCB0byBjb21wb3NlIGJpdG1hc2tzIGZvciB2YWx1ZSBjb21wYXJpc29ucy4gKi9cbnZhciBDT01QQVJFX1BBUlRJQUxfRkxBRyA9IDEsXG4gICAgQ09NUEFSRV9VTk9SREVSRURfRkxBRyA9IDI7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ubWF0Y2hlc1Byb3BlcnR5YCB3aGljaCBkb2Vzbid0IGNsb25lIGBzcmNWYWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gKiBAcGFyYW0geyp9IHNyY1ZhbHVlIFRoZSB2YWx1ZSB0byBtYXRjaC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHNwZWMgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGJhc2VNYXRjaGVzUHJvcGVydHkocGF0aCwgc3JjVmFsdWUpIHtcbiAgaWYgKGlzS2V5KHBhdGgpICYmIGlzU3RyaWN0Q29tcGFyYWJsZShzcmNWYWx1ZSkpIHtcbiAgICByZXR1cm4gbWF0Y2hlc1N0cmljdENvbXBhcmFibGUodG9LZXkocGF0aCksIHNyY1ZhbHVlKTtcbiAgfVxuICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgdmFyIG9ialZhbHVlID0gZ2V0KG9iamVjdCwgcGF0aCk7XG4gICAgcmV0dXJuIChvYmpWYWx1ZSA9PT0gdW5kZWZpbmVkICYmIG9ialZhbHVlID09PSBzcmNWYWx1ZSlcbiAgICAgID8gaGFzSW4ob2JqZWN0LCBwYXRoKVxuICAgICAgOiBiYXNlSXNFcXVhbChzcmNWYWx1ZSwgb2JqVmFsdWUsIENPTVBBUkVfUEFSVElBTF9GTEFHIHwgQ09NUEFSRV9VTk9SREVSRURfRkxBRyk7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZU1hdGNoZXNQcm9wZXJ0eTtcbiIsInZhciBTdGFjayA9IHJlcXVpcmUoJy4vX1N0YWNrJyksXG4gICAgYXNzaWduTWVyZ2VWYWx1ZSA9IHJlcXVpcmUoJy4vX2Fzc2lnbk1lcmdlVmFsdWUnKSxcbiAgICBiYXNlRm9yID0gcmVxdWlyZSgnLi9fYmFzZUZvcicpLFxuICAgIGJhc2VNZXJnZURlZXAgPSByZXF1aXJlKCcuL19iYXNlTWVyZ2VEZWVwJyksXG4gICAgaXNPYmplY3QgPSByZXF1aXJlKCcuL2lzT2JqZWN0JyksXG4gICAga2V5c0luID0gcmVxdWlyZSgnLi9rZXlzSW4nKSxcbiAgICBzYWZlR2V0ID0gcmVxdWlyZSgnLi9fc2FmZUdldCcpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLm1lcmdlYCB3aXRob3V0IHN1cHBvcnQgZm9yIG11bHRpcGxlIHNvdXJjZXMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIHNvdXJjZSBvYmplY3QuXG4gKiBAcGFyYW0ge251bWJlcn0gc3JjSW5kZXggVGhlIGluZGV4IG9mIGBzb3VyY2VgLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgbWVyZ2VkIHZhbHVlcy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbc3RhY2tdIFRyYWNrcyB0cmF2ZXJzZWQgc291cmNlIHZhbHVlcyBhbmQgdGhlaXIgbWVyZ2VkXG4gKiAgY291bnRlcnBhcnRzLlxuICovXG5mdW5jdGlvbiBiYXNlTWVyZ2Uob2JqZWN0LCBzb3VyY2UsIHNyY0luZGV4LCBjdXN0b21pemVyLCBzdGFjaykge1xuICBpZiAob2JqZWN0ID09PSBzb3VyY2UpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgYmFzZUZvcihzb3VyY2UsIGZ1bmN0aW9uKHNyY1ZhbHVlLCBrZXkpIHtcbiAgICBzdGFjayB8fCAoc3RhY2sgPSBuZXcgU3RhY2spO1xuICAgIGlmIChpc09iamVjdChzcmNWYWx1ZSkpIHtcbiAgICAgIGJhc2VNZXJnZURlZXAob2JqZWN0LCBzb3VyY2UsIGtleSwgc3JjSW5kZXgsIGJhc2VNZXJnZSwgY3VzdG9taXplciwgc3RhY2spO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHZhciBuZXdWYWx1ZSA9IGN1c3RvbWl6ZXJcbiAgICAgICAgPyBjdXN0b21pemVyKHNhZmVHZXQob2JqZWN0LCBrZXkpLCBzcmNWYWx1ZSwgKGtleSArICcnKSwgb2JqZWN0LCBzb3VyY2UsIHN0YWNrKVxuICAgICAgICA6IHVuZGVmaW5lZDtcblxuICAgICAgaWYgKG5ld1ZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgbmV3VmFsdWUgPSBzcmNWYWx1ZTtcbiAgICAgIH1cbiAgICAgIGFzc2lnbk1lcmdlVmFsdWUob2JqZWN0LCBrZXksIG5ld1ZhbHVlKTtcbiAgICB9XG4gIH0sIGtleXNJbik7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZU1lcmdlO1xuIiwidmFyIGFzc2lnbk1lcmdlVmFsdWUgPSByZXF1aXJlKCcuL19hc3NpZ25NZXJnZVZhbHVlJyksXG4gICAgY2xvbmVCdWZmZXIgPSByZXF1aXJlKCcuL19jbG9uZUJ1ZmZlcicpLFxuICAgIGNsb25lVHlwZWRBcnJheSA9IHJlcXVpcmUoJy4vX2Nsb25lVHlwZWRBcnJheScpLFxuICAgIGNvcHlBcnJheSA9IHJlcXVpcmUoJy4vX2NvcHlBcnJheScpLFxuICAgIGluaXRDbG9uZU9iamVjdCA9IHJlcXVpcmUoJy4vX2luaXRDbG9uZU9iamVjdCcpLFxuICAgIGlzQXJndW1lbnRzID0gcmVxdWlyZSgnLi9pc0FyZ3VtZW50cycpLFxuICAgIGlzQXJyYXkgPSByZXF1aXJlKCcuL2lzQXJyYXknKSxcbiAgICBpc0FycmF5TGlrZU9iamVjdCA9IHJlcXVpcmUoJy4vaXNBcnJheUxpa2VPYmplY3QnKSxcbiAgICBpc0J1ZmZlciA9IHJlcXVpcmUoJy4vaXNCdWZmZXInKSxcbiAgICBpc0Z1bmN0aW9uID0gcmVxdWlyZSgnLi9pc0Z1bmN0aW9uJyksXG4gICAgaXNPYmplY3QgPSByZXF1aXJlKCcuL2lzT2JqZWN0JyksXG4gICAgaXNQbGFpbk9iamVjdCA9IHJlcXVpcmUoJy4vaXNQbGFpbk9iamVjdCcpLFxuICAgIGlzVHlwZWRBcnJheSA9IHJlcXVpcmUoJy4vaXNUeXBlZEFycmF5JyksXG4gICAgc2FmZUdldCA9IHJlcXVpcmUoJy4vX3NhZmVHZXQnKSxcbiAgICB0b1BsYWluT2JqZWN0ID0gcmVxdWlyZSgnLi90b1BsYWluT2JqZWN0Jyk7XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlTWVyZ2VgIGZvciBhcnJheXMgYW5kIG9iamVjdHMgd2hpY2ggcGVyZm9ybXNcbiAqIGRlZXAgbWVyZ2VzIGFuZCB0cmFja3MgdHJhdmVyc2VkIG9iamVjdHMgZW5hYmxpbmcgb2JqZWN0cyB3aXRoIGNpcmN1bGFyXG4gKiByZWZlcmVuY2VzIHRvIGJlIG1lcmdlZC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgc291cmNlIG9iamVjdC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gbWVyZ2UuXG4gKiBAcGFyYW0ge251bWJlcn0gc3JjSW5kZXggVGhlIGluZGV4IG9mIGBzb3VyY2VgLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gbWVyZ2VGdW5jIFRoZSBmdW5jdGlvbiB0byBtZXJnZSB2YWx1ZXMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBhc3NpZ25lZCB2YWx1ZXMuXG4gKiBAcGFyYW0ge09iamVjdH0gW3N0YWNrXSBUcmFja3MgdHJhdmVyc2VkIHNvdXJjZSB2YWx1ZXMgYW5kIHRoZWlyIG1lcmdlZFxuICogIGNvdW50ZXJwYXJ0cy5cbiAqL1xuZnVuY3Rpb24gYmFzZU1lcmdlRGVlcChvYmplY3QsIHNvdXJjZSwga2V5LCBzcmNJbmRleCwgbWVyZ2VGdW5jLCBjdXN0b21pemVyLCBzdGFjaykge1xuICB2YXIgb2JqVmFsdWUgPSBzYWZlR2V0KG9iamVjdCwga2V5KSxcbiAgICAgIHNyY1ZhbHVlID0gc2FmZUdldChzb3VyY2UsIGtleSksXG4gICAgICBzdGFja2VkID0gc3RhY2suZ2V0KHNyY1ZhbHVlKTtcblxuICBpZiAoc3RhY2tlZCkge1xuICAgIGFzc2lnbk1lcmdlVmFsdWUob2JqZWN0LCBrZXksIHN0YWNrZWQpO1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgbmV3VmFsdWUgPSBjdXN0b21pemVyXG4gICAgPyBjdXN0b21pemVyKG9ialZhbHVlLCBzcmNWYWx1ZSwgKGtleSArICcnKSwgb2JqZWN0LCBzb3VyY2UsIHN0YWNrKVxuICAgIDogdW5kZWZpbmVkO1xuXG4gIHZhciBpc0NvbW1vbiA9IG5ld1ZhbHVlID09PSB1bmRlZmluZWQ7XG5cbiAgaWYgKGlzQ29tbW9uKSB7XG4gICAgdmFyIGlzQXJyID0gaXNBcnJheShzcmNWYWx1ZSksXG4gICAgICAgIGlzQnVmZiA9ICFpc0FyciAmJiBpc0J1ZmZlcihzcmNWYWx1ZSksXG4gICAgICAgIGlzVHlwZWQgPSAhaXNBcnIgJiYgIWlzQnVmZiAmJiBpc1R5cGVkQXJyYXkoc3JjVmFsdWUpO1xuXG4gICAgbmV3VmFsdWUgPSBzcmNWYWx1ZTtcbiAgICBpZiAoaXNBcnIgfHwgaXNCdWZmIHx8IGlzVHlwZWQpIHtcbiAgICAgIGlmIChpc0FycmF5KG9ialZhbHVlKSkge1xuICAgICAgICBuZXdWYWx1ZSA9IG9ialZhbHVlO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoaXNBcnJheUxpa2VPYmplY3Qob2JqVmFsdWUpKSB7XG4gICAgICAgIG5ld1ZhbHVlID0gY29weUFycmF5KG9ialZhbHVlKTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKGlzQnVmZikge1xuICAgICAgICBpc0NvbW1vbiA9IGZhbHNlO1xuICAgICAgICBuZXdWYWx1ZSA9IGNsb25lQnVmZmVyKHNyY1ZhbHVlLCB0cnVlKTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKGlzVHlwZWQpIHtcbiAgICAgICAgaXNDb21tb24gPSBmYWxzZTtcbiAgICAgICAgbmV3VmFsdWUgPSBjbG9uZVR5cGVkQXJyYXkoc3JjVmFsdWUsIHRydWUpO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIG5ld1ZhbHVlID0gW107XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKGlzUGxhaW5PYmplY3Qoc3JjVmFsdWUpIHx8IGlzQXJndW1lbnRzKHNyY1ZhbHVlKSkge1xuICAgICAgbmV3VmFsdWUgPSBvYmpWYWx1ZTtcbiAgICAgIGlmIChpc0FyZ3VtZW50cyhvYmpWYWx1ZSkpIHtcbiAgICAgICAgbmV3VmFsdWUgPSB0b1BsYWluT2JqZWN0KG9ialZhbHVlKTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKCFpc09iamVjdChvYmpWYWx1ZSkgfHwgaXNGdW5jdGlvbihvYmpWYWx1ZSkpIHtcbiAgICAgICAgbmV3VmFsdWUgPSBpbml0Q2xvbmVPYmplY3Qoc3JjVmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGlzQ29tbW9uID0gZmFsc2U7XG4gICAgfVxuICB9XG4gIGlmIChpc0NvbW1vbikge1xuICAgIC8vIFJlY3Vyc2l2ZWx5IG1lcmdlIG9iamVjdHMgYW5kIGFycmF5cyAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpLlxuICAgIHN0YWNrLnNldChzcmNWYWx1ZSwgbmV3VmFsdWUpO1xuICAgIG1lcmdlRnVuYyhuZXdWYWx1ZSwgc3JjVmFsdWUsIHNyY0luZGV4LCBjdXN0b21pemVyLCBzdGFjayk7XG4gICAgc3RhY2tbJ2RlbGV0ZSddKHNyY1ZhbHVlKTtcbiAgfVxuICBhc3NpZ25NZXJnZVZhbHVlKG9iamVjdCwga2V5LCBuZXdWYWx1ZSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZU1lcmdlRGVlcDtcbiIsInZhciBhcnJheU1hcCA9IHJlcXVpcmUoJy4vX2FycmF5TWFwJyksXG4gICAgYmFzZUdldCA9IHJlcXVpcmUoJy4vX2Jhc2VHZXQnKSxcbiAgICBiYXNlSXRlcmF0ZWUgPSByZXF1aXJlKCcuL19iYXNlSXRlcmF0ZWUnKSxcbiAgICBiYXNlTWFwID0gcmVxdWlyZSgnLi9fYmFzZU1hcCcpLFxuICAgIGJhc2VTb3J0QnkgPSByZXF1aXJlKCcuL19iYXNlU29ydEJ5JyksXG4gICAgYmFzZVVuYXJ5ID0gcmVxdWlyZSgnLi9fYmFzZVVuYXJ5JyksXG4gICAgY29tcGFyZU11bHRpcGxlID0gcmVxdWlyZSgnLi9fY29tcGFyZU11bHRpcGxlJyksXG4gICAgaWRlbnRpdHkgPSByZXF1aXJlKCcuL2lkZW50aXR5JyksXG4gICAgaXNBcnJheSA9IHJlcXVpcmUoJy4vaXNBcnJheScpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLm9yZGVyQnlgIHdpdGhvdXQgcGFyYW0gZ3VhcmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9uW118T2JqZWN0W118c3RyaW5nW119IGl0ZXJhdGVlcyBUaGUgaXRlcmF0ZWVzIHRvIHNvcnQgYnkuXG4gKiBAcGFyYW0ge3N0cmluZ1tdfSBvcmRlcnMgVGhlIHNvcnQgb3JkZXJzIG9mIGBpdGVyYXRlZXNgLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgc29ydGVkIGFycmF5LlxuICovXG5mdW5jdGlvbiBiYXNlT3JkZXJCeShjb2xsZWN0aW9uLCBpdGVyYXRlZXMsIG9yZGVycykge1xuICBpZiAoaXRlcmF0ZWVzLmxlbmd0aCkge1xuICAgIGl0ZXJhdGVlcyA9IGFycmF5TWFwKGl0ZXJhdGVlcywgZnVuY3Rpb24oaXRlcmF0ZWUpIHtcbiAgICAgIGlmIChpc0FycmF5KGl0ZXJhdGVlKSkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICByZXR1cm4gYmFzZUdldCh2YWx1ZSwgaXRlcmF0ZWUubGVuZ3RoID09PSAxID8gaXRlcmF0ZWVbMF0gOiBpdGVyYXRlZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBpdGVyYXRlZTtcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBpdGVyYXRlZXMgPSBbaWRlbnRpdHldO1xuICB9XG5cbiAgdmFyIGluZGV4ID0gLTE7XG4gIGl0ZXJhdGVlcyA9IGFycmF5TWFwKGl0ZXJhdGVlcywgYmFzZVVuYXJ5KGJhc2VJdGVyYXRlZSkpO1xuXG4gIHZhciByZXN1bHQgPSBiYXNlTWFwKGNvbGxlY3Rpb24sIGZ1bmN0aW9uKHZhbHVlLCBrZXksIGNvbGxlY3Rpb24pIHtcbiAgICB2YXIgY3JpdGVyaWEgPSBhcnJheU1hcChpdGVyYXRlZXMsIGZ1bmN0aW9uKGl0ZXJhdGVlKSB7XG4gICAgICByZXR1cm4gaXRlcmF0ZWUodmFsdWUpO1xuICAgIH0pO1xuICAgIHJldHVybiB7ICdjcml0ZXJpYSc6IGNyaXRlcmlhLCAnaW5kZXgnOiArK2luZGV4LCAndmFsdWUnOiB2YWx1ZSB9O1xuICB9KTtcblxuICByZXR1cm4gYmFzZVNvcnRCeShyZXN1bHQsIGZ1bmN0aW9uKG9iamVjdCwgb3RoZXIpIHtcbiAgICByZXR1cm4gY29tcGFyZU11bHRpcGxlKG9iamVjdCwgb3RoZXIsIG9yZGVycyk7XG4gIH0pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VPcmRlckJ5O1xuIiwidmFyIGJhc2VQaWNrQnkgPSByZXF1aXJlKCcuL19iYXNlUGlja0J5JyksXG4gICAgaGFzSW4gPSByZXF1aXJlKCcuL2hhc0luJyk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ucGlja2Agd2l0aG91dCBzdXBwb3J0IGZvciBpbmRpdmlkdWFsXG4gKiBwcm9wZXJ0eSBpZGVudGlmaWVycy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgc291cmNlIG9iamVjdC5cbiAqIEBwYXJhbSB7c3RyaW5nW119IHBhdGhzIFRoZSBwcm9wZXJ0eSBwYXRocyB0byBwaWNrLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IG9iamVjdC5cbiAqL1xuZnVuY3Rpb24gYmFzZVBpY2sob2JqZWN0LCBwYXRocykge1xuICByZXR1cm4gYmFzZVBpY2tCeShvYmplY3QsIHBhdGhzLCBmdW5jdGlvbih2YWx1ZSwgcGF0aCkge1xuICAgIHJldHVybiBoYXNJbihvYmplY3QsIHBhdGgpO1xuICB9KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlUGljaztcbiIsInZhciBiYXNlR2V0ID0gcmVxdWlyZSgnLi9fYmFzZUdldCcpLFxuICAgIGJhc2VTZXQgPSByZXF1aXJlKCcuL19iYXNlU2V0JyksXG4gICAgY2FzdFBhdGggPSByZXF1aXJlKCcuL19jYXN0UGF0aCcpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mICBgXy5waWNrQnlgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgc291cmNlIG9iamVjdC5cbiAqIEBwYXJhbSB7c3RyaW5nW119IHBhdGhzIFRoZSBwcm9wZXJ0eSBwYXRocyB0byBwaWNrLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gcHJlZGljYXRlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBwcm9wZXJ0eS5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBvYmplY3QuXG4gKi9cbmZ1bmN0aW9uIGJhc2VQaWNrQnkob2JqZWN0LCBwYXRocywgcHJlZGljYXRlKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gcGF0aHMubGVuZ3RoLFxuICAgICAgcmVzdWx0ID0ge307XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIgcGF0aCA9IHBhdGhzW2luZGV4XSxcbiAgICAgICAgdmFsdWUgPSBiYXNlR2V0KG9iamVjdCwgcGF0aCk7XG5cbiAgICBpZiAocHJlZGljYXRlKHZhbHVlLCBwYXRoKSkge1xuICAgICAgYmFzZVNldChyZXN1bHQsIGNhc3RQYXRoKHBhdGgsIG9iamVjdCksIHZhbHVlKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlUGlja0J5O1xuIiwiLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5wcm9wZXJ0eWAgd2l0aG91dCBzdXBwb3J0IGZvciBkZWVwIHBhdGhzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGFjY2Vzc29yIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBiYXNlUHJvcGVydHkoa2V5KSB7XG4gIHJldHVybiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICByZXR1cm4gb2JqZWN0ID09IG51bGwgPyB1bmRlZmluZWQgOiBvYmplY3Rba2V5XTtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlUHJvcGVydHk7XG4iLCJ2YXIgYmFzZUdldCA9IHJlcXVpcmUoJy4vX2Jhc2VHZXQnKTtcblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VQcm9wZXJ0eWAgd2hpY2ggc3VwcG9ydHMgZGVlcCBwYXRocy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGFjY2Vzc29yIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBiYXNlUHJvcGVydHlEZWVwKHBhdGgpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCkge1xuICAgIHJldHVybiBiYXNlR2V0KG9iamVjdCwgcGF0aCk7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZVByb3BlcnR5RGVlcDtcbiIsIi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIGZvciB0aG9zZSB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgb3RoZXIgYGxvZGFzaGAgbWV0aG9kcy4gKi9cbnZhciBuYXRpdmVDZWlsID0gTWF0aC5jZWlsLFxuICAgIG5hdGl2ZU1heCA9IE1hdGgubWF4O1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnJhbmdlYCBhbmQgYF8ucmFuZ2VSaWdodGAgd2hpY2ggZG9lc24ndFxuICogY29lcmNlIGFyZ3VtZW50cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0IFRoZSBzdGFydCBvZiB0aGUgcmFuZ2UuXG4gKiBAcGFyYW0ge251bWJlcn0gZW5kIFRoZSBlbmQgb2YgdGhlIHJhbmdlLlxuICogQHBhcmFtIHtudW1iZXJ9IHN0ZXAgVGhlIHZhbHVlIHRvIGluY3JlbWVudCBvciBkZWNyZW1lbnQgYnkuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtmcm9tUmlnaHRdIFNwZWNpZnkgaXRlcmF0aW5nIGZyb20gcmlnaHQgdG8gbGVmdC5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgcmFuZ2Ugb2YgbnVtYmVycy5cbiAqL1xuZnVuY3Rpb24gYmFzZVJhbmdlKHN0YXJ0LCBlbmQsIHN0ZXAsIGZyb21SaWdodCkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IG5hdGl2ZU1heChuYXRpdmVDZWlsKChlbmQgLSBzdGFydCkgLyAoc3RlcCB8fCAxKSksIDApLFxuICAgICAgcmVzdWx0ID0gQXJyYXkobGVuZ3RoKTtcblxuICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICByZXN1bHRbZnJvbVJpZ2h0ID8gbGVuZ3RoIDogKytpbmRleF0gPSBzdGFydDtcbiAgICBzdGFydCArPSBzdGVwO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZVJhbmdlO1xuIiwiLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5yZWR1Y2VgIGFuZCBgXy5yZWR1Y2VSaWdodGAsIHdpdGhvdXQgc3VwcG9ydFxuICogZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHMsIHdoaWNoIGl0ZXJhdGVzIG92ZXIgYGNvbGxlY3Rpb25gIHVzaW5nIGBlYWNoRnVuY2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcGFyYW0geyp9IGFjY3VtdWxhdG9yIFRoZSBpbml0aWFsIHZhbHVlLlxuICogQHBhcmFtIHtib29sZWFufSBpbml0QWNjdW0gU3BlY2lmeSB1c2luZyB0aGUgZmlyc3Qgb3IgbGFzdCBlbGVtZW50IG9mXG4gKiAgYGNvbGxlY3Rpb25gIGFzIHRoZSBpbml0aWFsIHZhbHVlLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZWFjaEZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGl0ZXJhdGUgb3ZlciBgY29sbGVjdGlvbmAuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgYWNjdW11bGF0ZWQgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGJhc2VSZWR1Y2UoY29sbGVjdGlvbiwgaXRlcmF0ZWUsIGFjY3VtdWxhdG9yLCBpbml0QWNjdW0sIGVhY2hGdW5jKSB7XG4gIGVhY2hGdW5jKGNvbGxlY3Rpb24sIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbikge1xuICAgIGFjY3VtdWxhdG9yID0gaW5pdEFjY3VtXG4gICAgICA/IChpbml0QWNjdW0gPSBmYWxzZSwgdmFsdWUpXG4gICAgICA6IGl0ZXJhdGVlKGFjY3VtdWxhdG9yLCB2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pO1xuICB9KTtcbiAgcmV0dXJuIGFjY3VtdWxhdG9yO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VSZWR1Y2U7XG4iLCJ2YXIgaWRlbnRpdHkgPSByZXF1aXJlKCcuL2lkZW50aXR5JyksXG4gICAgb3ZlclJlc3QgPSByZXF1aXJlKCcuL19vdmVyUmVzdCcpLFxuICAgIHNldFRvU3RyaW5nID0gcmVxdWlyZSgnLi9fc2V0VG9TdHJpbmcnKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5yZXN0YCB3aGljaCBkb2Vzbid0IHZhbGlkYXRlIG9yIGNvZXJjZSBhcmd1bWVudHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGFwcGx5IGEgcmVzdCBwYXJhbWV0ZXIgdG8uXG4gKiBAcGFyYW0ge251bWJlcn0gW3N0YXJ0PWZ1bmMubGVuZ3RoLTFdIFRoZSBzdGFydCBwb3NpdGlvbiBvZiB0aGUgcmVzdCBwYXJhbWV0ZXIuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gYmFzZVJlc3QoZnVuYywgc3RhcnQpIHtcbiAgcmV0dXJuIHNldFRvU3RyaW5nKG92ZXJSZXN0KGZ1bmMsIHN0YXJ0LCBpZGVudGl0eSksIGZ1bmMgKyAnJyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZVJlc3Q7XG4iLCJ2YXIgYXNzaWduVmFsdWUgPSByZXF1aXJlKCcuL19hc3NpZ25WYWx1ZScpLFxuICAgIGNhc3RQYXRoID0gcmVxdWlyZSgnLi9fY2FzdFBhdGgnKSxcbiAgICBpc0luZGV4ID0gcmVxdWlyZSgnLi9faXNJbmRleCcpLFxuICAgIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9pc09iamVjdCcpLFxuICAgIHRvS2V5ID0gcmVxdWlyZSgnLi9fdG9LZXknKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5zZXRgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gbW9kaWZ5LlxuICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIHNldC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIHBhdGggY3JlYXRpb24uXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICovXG5mdW5jdGlvbiBiYXNlU2V0KG9iamVjdCwgcGF0aCwgdmFsdWUsIGN1c3RvbWl6ZXIpIHtcbiAgaWYgKCFpc09iamVjdChvYmplY3QpKSB7XG4gICAgcmV0dXJuIG9iamVjdDtcbiAgfVxuICBwYXRoID0gY2FzdFBhdGgocGF0aCwgb2JqZWN0KTtcblxuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IHBhdGgubGVuZ3RoLFxuICAgICAgbGFzdEluZGV4ID0gbGVuZ3RoIC0gMSxcbiAgICAgIG5lc3RlZCA9IG9iamVjdDtcblxuICB3aGlsZSAobmVzdGVkICE9IG51bGwgJiYgKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciBrZXkgPSB0b0tleShwYXRoW2luZGV4XSksXG4gICAgICAgIG5ld1ZhbHVlID0gdmFsdWU7XG5cbiAgICBpZiAoa2V5ID09PSAnX19wcm90b19fJyB8fCBrZXkgPT09ICdjb25zdHJ1Y3RvcicgfHwga2V5ID09PSAncHJvdG90eXBlJykge1xuICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICB9XG5cbiAgICBpZiAoaW5kZXggIT0gbGFzdEluZGV4KSB7XG4gICAgICB2YXIgb2JqVmFsdWUgPSBuZXN0ZWRba2V5XTtcbiAgICAgIG5ld1ZhbHVlID0gY3VzdG9taXplciA/IGN1c3RvbWl6ZXIob2JqVmFsdWUsIGtleSwgbmVzdGVkKSA6IHVuZGVmaW5lZDtcbiAgICAgIGlmIChuZXdWYWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIG5ld1ZhbHVlID0gaXNPYmplY3Qob2JqVmFsdWUpXG4gICAgICAgICAgPyBvYmpWYWx1ZVxuICAgICAgICAgIDogKGlzSW5kZXgocGF0aFtpbmRleCArIDFdKSA/IFtdIDoge30pO1xuICAgICAgfVxuICAgIH1cbiAgICBhc3NpZ25WYWx1ZShuZXN0ZWQsIGtleSwgbmV3VmFsdWUpO1xuICAgIG5lc3RlZCA9IG5lc3RlZFtrZXldO1xuICB9XG4gIHJldHVybiBvYmplY3Q7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZVNldDtcbiIsInZhciBjb25zdGFudCA9IHJlcXVpcmUoJy4vY29uc3RhbnQnKSxcbiAgICBkZWZpbmVQcm9wZXJ0eSA9IHJlcXVpcmUoJy4vX2RlZmluZVByb3BlcnR5JyksXG4gICAgaWRlbnRpdHkgPSByZXF1aXJlKCcuL2lkZW50aXR5Jyk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYHNldFRvU3RyaW5nYCB3aXRob3V0IHN1cHBvcnQgZm9yIGhvdCBsb29wIHNob3J0aW5nLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBtb2RpZnkuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBzdHJpbmcgVGhlIGB0b1N0cmluZ2AgcmVzdWx0LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIGBmdW5jYC5cbiAqL1xudmFyIGJhc2VTZXRUb1N0cmluZyA9ICFkZWZpbmVQcm9wZXJ0eSA/IGlkZW50aXR5IDogZnVuY3Rpb24oZnVuYywgc3RyaW5nKSB7XG4gIHJldHVybiBkZWZpbmVQcm9wZXJ0eShmdW5jLCAndG9TdHJpbmcnLCB7XG4gICAgJ2NvbmZpZ3VyYWJsZSc6IHRydWUsXG4gICAgJ2VudW1lcmFibGUnOiBmYWxzZSxcbiAgICAndmFsdWUnOiBjb25zdGFudChzdHJpbmcpLFxuICAgICd3cml0YWJsZSc6IHRydWVcbiAgfSk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VTZXRUb1N0cmluZztcbiIsIi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uc29ydEJ5YCB3aGljaCB1c2VzIGBjb21wYXJlcmAgdG8gZGVmaW5lIHRoZVxuICogc29ydCBvcmRlciBvZiBgYXJyYXlgIGFuZCByZXBsYWNlcyBjcml0ZXJpYSBvYmplY3RzIHdpdGggdGhlaXIgY29ycmVzcG9uZGluZ1xuICogdmFsdWVzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gc29ydC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNvbXBhcmVyIFRoZSBmdW5jdGlvbiB0byBkZWZpbmUgc29ydCBvcmRlci5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgYXJyYXlgLlxuICovXG5mdW5jdGlvbiBiYXNlU29ydEJ5KGFycmF5LCBjb21wYXJlcikge1xuICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuXG4gIGFycmF5LnNvcnQoY29tcGFyZXIpO1xuICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICBhcnJheVtsZW5ndGhdID0gYXJyYXlbbGVuZ3RoXS52YWx1ZTtcbiAgfVxuICByZXR1cm4gYXJyYXk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZVNvcnRCeTtcbiIsIi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8udGltZXNgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kc1xuICogb3IgbWF4IGFycmF5IGxlbmd0aCBjaGVja3MuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7bnVtYmVyfSBuIFRoZSBudW1iZXIgb2YgdGltZXMgdG8gaW52b2tlIGBpdGVyYXRlZWAuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiByZXN1bHRzLlxuICovXG5mdW5jdGlvbiBiYXNlVGltZXMobiwgaXRlcmF0ZWUpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICByZXN1bHQgPSBBcnJheShuKTtcblxuICB3aGlsZSAoKytpbmRleCA8IG4pIHtcbiAgICByZXN1bHRbaW5kZXhdID0gaXRlcmF0ZWUoaW5kZXgpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZVRpbWVzO1xuIiwidmFyIFN5bWJvbCA9IHJlcXVpcmUoJy4vX1N5bWJvbCcpLFxuICAgIGFycmF5TWFwID0gcmVxdWlyZSgnLi9fYXJyYXlNYXAnKSxcbiAgICBpc0FycmF5ID0gcmVxdWlyZSgnLi9pc0FycmF5JyksXG4gICAgaXNTeW1ib2wgPSByZXF1aXJlKCcuL2lzU3ltYm9sJyk7XG5cbi8qKiBVc2VkIGFzIHJlZmVyZW5jZXMgZm9yIHZhcmlvdXMgYE51bWJlcmAgY29uc3RhbnRzLiAqL1xudmFyIElORklOSVRZID0gMSAvIDA7XG5cbi8qKiBVc2VkIHRvIGNvbnZlcnQgc3ltYm9scyB0byBwcmltaXRpdmVzIGFuZCBzdHJpbmdzLiAqL1xudmFyIHN5bWJvbFByb3RvID0gU3ltYm9sID8gU3ltYm9sLnByb3RvdHlwZSA6IHVuZGVmaW5lZCxcbiAgICBzeW1ib2xUb1N0cmluZyA9IHN5bWJvbFByb3RvID8gc3ltYm9sUHJvdG8udG9TdHJpbmcgOiB1bmRlZmluZWQ7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8udG9TdHJpbmdgIHdoaWNoIGRvZXNuJ3QgY29udmVydCBudWxsaXNoXG4gKiB2YWx1ZXMgdG8gZW1wdHkgc3RyaW5ncy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcHJvY2Vzcy5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHN0cmluZy5cbiAqL1xuZnVuY3Rpb24gYmFzZVRvU3RyaW5nKHZhbHVlKSB7XG4gIC8vIEV4aXQgZWFybHkgZm9yIHN0cmluZ3MgdG8gYXZvaWQgYSBwZXJmb3JtYW5jZSBoaXQgaW4gc29tZSBlbnZpcm9ubWVudHMuXG4gIGlmICh0eXBlb2YgdmFsdWUgPT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgLy8gUmVjdXJzaXZlbHkgY29udmVydCB2YWx1ZXMgKHN1c2NlcHRpYmxlIHRvIGNhbGwgc3RhY2sgbGltaXRzKS5cbiAgICByZXR1cm4gYXJyYXlNYXAodmFsdWUsIGJhc2VUb1N0cmluZykgKyAnJztcbiAgfVxuICBpZiAoaXNTeW1ib2wodmFsdWUpKSB7XG4gICAgcmV0dXJuIHN5bWJvbFRvU3RyaW5nID8gc3ltYm9sVG9TdHJpbmcuY2FsbCh2YWx1ZSkgOiAnJztcbiAgfVxuICB2YXIgcmVzdWx0ID0gKHZhbHVlICsgJycpO1xuICByZXR1cm4gKHJlc3VsdCA9PSAnMCcgJiYgKDEgLyB2YWx1ZSkgPT0gLUlORklOSVRZKSA/ICctMCcgOiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZVRvU3RyaW5nO1xuIiwidmFyIHRyaW1tZWRFbmRJbmRleCA9IHJlcXVpcmUoJy4vX3RyaW1tZWRFbmRJbmRleCcpO1xuXG4vKiogVXNlZCB0byBtYXRjaCBsZWFkaW5nIHdoaXRlc3BhY2UuICovXG52YXIgcmVUcmltU3RhcnQgPSAvXlxccysvO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnRyaW1gLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIFRoZSBzdHJpbmcgdG8gdHJpbS5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHRyaW1tZWQgc3RyaW5nLlxuICovXG5mdW5jdGlvbiBiYXNlVHJpbShzdHJpbmcpIHtcbiAgcmV0dXJuIHN0cmluZ1xuICAgID8gc3RyaW5nLnNsaWNlKDAsIHRyaW1tZWRFbmRJbmRleChzdHJpbmcpICsgMSkucmVwbGFjZShyZVRyaW1TdGFydCwgJycpXG4gICAgOiBzdHJpbmc7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZVRyaW07XG4iLCIvKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnVuYXJ5YCB3aXRob3V0IHN1cHBvcnQgZm9yIHN0b3JpbmcgbWV0YWRhdGEuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGNhcCBhcmd1bWVudHMgZm9yLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgY2FwcGVkIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBiYXNlVW5hcnkoZnVuYykge1xuICByZXR1cm4gZnVuY3Rpb24odmFsdWUpIHtcbiAgICByZXR1cm4gZnVuYyh2YWx1ZSk7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZVVuYXJ5O1xuIiwidmFyIFNldENhY2hlID0gcmVxdWlyZSgnLi9fU2V0Q2FjaGUnKSxcbiAgICBhcnJheUluY2x1ZGVzID0gcmVxdWlyZSgnLi9fYXJyYXlJbmNsdWRlcycpLFxuICAgIGFycmF5SW5jbHVkZXNXaXRoID0gcmVxdWlyZSgnLi9fYXJyYXlJbmNsdWRlc1dpdGgnKSxcbiAgICBjYWNoZUhhcyA9IHJlcXVpcmUoJy4vX2NhY2hlSGFzJyksXG4gICAgY3JlYXRlU2V0ID0gcmVxdWlyZSgnLi9fY3JlYXRlU2V0JyksXG4gICAgc2V0VG9BcnJheSA9IHJlcXVpcmUoJy4vX3NldFRvQXJyYXknKTtcblxuLyoqIFVzZWQgYXMgdGhlIHNpemUgdG8gZW5hYmxlIGxhcmdlIGFycmF5IG9wdGltaXphdGlvbnMuICovXG52YXIgTEFSR0VfQVJSQVlfU0laRSA9IDIwMDtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy51bmlxQnlgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWVdIFRoZSBpdGVyYXRlZSBpbnZva2VkIHBlciBlbGVtZW50LlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NvbXBhcmF0b3JdIFRoZSBjb21wYXJhdG9yIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBkdXBsaWNhdGUgZnJlZSBhcnJheS5cbiAqL1xuZnVuY3Rpb24gYmFzZVVuaXEoYXJyYXksIGl0ZXJhdGVlLCBjb21wYXJhdG9yKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgaW5jbHVkZXMgPSBhcnJheUluY2x1ZGVzLFxuICAgICAgbGVuZ3RoID0gYXJyYXkubGVuZ3RoLFxuICAgICAgaXNDb21tb24gPSB0cnVlLFxuICAgICAgcmVzdWx0ID0gW10sXG4gICAgICBzZWVuID0gcmVzdWx0O1xuXG4gIGlmIChjb21wYXJhdG9yKSB7XG4gICAgaXNDb21tb24gPSBmYWxzZTtcbiAgICBpbmNsdWRlcyA9IGFycmF5SW5jbHVkZXNXaXRoO1xuICB9XG4gIGVsc2UgaWYgKGxlbmd0aCA+PSBMQVJHRV9BUlJBWV9TSVpFKSB7XG4gICAgdmFyIHNldCA9IGl0ZXJhdGVlID8gbnVsbCA6IGNyZWF0ZVNldChhcnJheSk7XG4gICAgaWYgKHNldCkge1xuICAgICAgcmV0dXJuIHNldFRvQXJyYXkoc2V0KTtcbiAgICB9XG4gICAgaXNDb21tb24gPSBmYWxzZTtcbiAgICBpbmNsdWRlcyA9IGNhY2hlSGFzO1xuICAgIHNlZW4gPSBuZXcgU2V0Q2FjaGU7XG4gIH1cbiAgZWxzZSB7XG4gICAgc2VlbiA9IGl0ZXJhdGVlID8gW10gOiByZXN1bHQ7XG4gIH1cbiAgb3V0ZXI6XG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIHZhbHVlID0gYXJyYXlbaW5kZXhdLFxuICAgICAgICBjb21wdXRlZCA9IGl0ZXJhdGVlID8gaXRlcmF0ZWUodmFsdWUpIDogdmFsdWU7XG5cbiAgICB2YWx1ZSA9IChjb21wYXJhdG9yIHx8IHZhbHVlICE9PSAwKSA/IHZhbHVlIDogMDtcbiAgICBpZiAoaXNDb21tb24gJiYgY29tcHV0ZWQgPT09IGNvbXB1dGVkKSB7XG4gICAgICB2YXIgc2VlbkluZGV4ID0gc2Vlbi5sZW5ndGg7XG4gICAgICB3aGlsZSAoc2VlbkluZGV4LS0pIHtcbiAgICAgICAgaWYgKHNlZW5bc2VlbkluZGV4XSA9PT0gY29tcHV0ZWQpIHtcbiAgICAgICAgICBjb250aW51ZSBvdXRlcjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGl0ZXJhdGVlKSB7XG4gICAgICAgIHNlZW4ucHVzaChjb21wdXRlZCk7XG4gICAgICB9XG4gICAgICByZXN1bHQucHVzaCh2YWx1ZSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKCFpbmNsdWRlcyhzZWVuLCBjb21wdXRlZCwgY29tcGFyYXRvcikpIHtcbiAgICAgIGlmIChzZWVuICE9PSByZXN1bHQpIHtcbiAgICAgICAgc2Vlbi5wdXNoKGNvbXB1dGVkKTtcbiAgICAgIH1cbiAgICAgIHJlc3VsdC5wdXNoKHZhbHVlKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlVW5pcTtcbiIsInZhciBhcnJheU1hcCA9IHJlcXVpcmUoJy4vX2FycmF5TWFwJyk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8udmFsdWVzYCBhbmQgYF8udmFsdWVzSW5gIHdoaWNoIGNyZWF0ZXMgYW5cbiAqIGFycmF5IG9mIGBvYmplY3RgIHByb3BlcnR5IHZhbHVlcyBjb3JyZXNwb25kaW5nIHRvIHRoZSBwcm9wZXJ0eSBuYW1lc1xuICogb2YgYHByb3BzYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtBcnJheX0gcHJvcHMgVGhlIHByb3BlcnR5IG5hbWVzIHRvIGdldCB2YWx1ZXMgZm9yLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgdmFsdWVzLlxuICovXG5mdW5jdGlvbiBiYXNlVmFsdWVzKG9iamVjdCwgcHJvcHMpIHtcbiAgcmV0dXJuIGFycmF5TWFwKHByb3BzLCBmdW5jdGlvbihrZXkpIHtcbiAgICByZXR1cm4gb2JqZWN0W2tleV07XG4gIH0pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VWYWx1ZXM7XG4iLCIvKipcbiAqIFRoaXMgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy56aXBPYmplY3RgIHdoaWNoIGFzc2lnbnMgdmFsdWVzIHVzaW5nIGBhc3NpZ25GdW5jYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gcHJvcHMgVGhlIHByb3BlcnR5IGlkZW50aWZpZXJzLlxuICogQHBhcmFtIHtBcnJheX0gdmFsdWVzIFRoZSBwcm9wZXJ0eSB2YWx1ZXMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBhc3NpZ25GdW5jIFRoZSBmdW5jdGlvbiB0byBhc3NpZ24gdmFsdWVzLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IG9iamVjdC5cbiAqL1xuZnVuY3Rpb24gYmFzZVppcE9iamVjdChwcm9wcywgdmFsdWVzLCBhc3NpZ25GdW5jKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gcHJvcHMubGVuZ3RoLFxuICAgICAgdmFsc0xlbmd0aCA9IHZhbHVlcy5sZW5ndGgsXG4gICAgICByZXN1bHQgPSB7fTtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciB2YWx1ZSA9IGluZGV4IDwgdmFsc0xlbmd0aCA/IHZhbHVlc1tpbmRleF0gOiB1bmRlZmluZWQ7XG4gICAgYXNzaWduRnVuYyhyZXN1bHQsIHByb3BzW2luZGV4XSwgdmFsdWUpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZVppcE9iamVjdDtcbiIsIi8qKlxuICogQ2hlY2tzIGlmIGEgYGNhY2hlYCB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gY2FjaGUgVGhlIGNhY2hlIHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlbnRyeSBmb3IgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGNhY2hlSGFzKGNhY2hlLCBrZXkpIHtcbiAgcmV0dXJuIGNhY2hlLmhhcyhrZXkpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNhY2hlSGFzO1xuIiwidmFyIGlkZW50aXR5ID0gcmVxdWlyZSgnLi9pZGVudGl0eScpO1xuXG4vKipcbiAqIENhc3RzIGB2YWx1ZWAgdG8gYGlkZW50aXR5YCBpZiBpdCdzIG5vdCBhIGZ1bmN0aW9uLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBpbnNwZWN0LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIGNhc3QgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGNhc3RGdW5jdGlvbih2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09ICdmdW5jdGlvbicgPyB2YWx1ZSA6IGlkZW50aXR5O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNhc3RGdW5jdGlvbjtcbiIsInZhciBpc0FycmF5ID0gcmVxdWlyZSgnLi9pc0FycmF5JyksXG4gICAgaXNLZXkgPSByZXF1aXJlKCcuL19pc0tleScpLFxuICAgIHN0cmluZ1RvUGF0aCA9IHJlcXVpcmUoJy4vX3N0cmluZ1RvUGF0aCcpLFxuICAgIHRvU3RyaW5nID0gcmVxdWlyZSgnLi90b1N0cmluZycpO1xuXG4vKipcbiAqIENhc3RzIGB2YWx1ZWAgdG8gYSBwYXRoIGFycmF5IGlmIGl0J3Mgbm90IG9uZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gaW5zcGVjdC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0XSBUaGUgb2JqZWN0IHRvIHF1ZXJ5IGtleXMgb24uXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGNhc3QgcHJvcGVydHkgcGF0aCBhcnJheS5cbiAqL1xuZnVuY3Rpb24gY2FzdFBhdGgodmFsdWUsIG9iamVjdCkge1xuICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgcmV0dXJuIGlzS2V5KHZhbHVlLCBvYmplY3QpID8gW3ZhbHVlXSA6IHN0cmluZ1RvUGF0aCh0b1N0cmluZyh2YWx1ZSkpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNhc3RQYXRoO1xuIiwidmFyIFVpbnQ4QXJyYXkgPSByZXF1aXJlKCcuL19VaW50OEFycmF5Jyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGNsb25lIG9mIGBhcnJheUJ1ZmZlcmAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXlCdWZmZXJ9IGFycmF5QnVmZmVyIFRoZSBhcnJheSBidWZmZXIgdG8gY2xvbmUuXG4gKiBAcmV0dXJucyB7QXJyYXlCdWZmZXJ9IFJldHVybnMgdGhlIGNsb25lZCBhcnJheSBidWZmZXIuXG4gKi9cbmZ1bmN0aW9uIGNsb25lQXJyYXlCdWZmZXIoYXJyYXlCdWZmZXIpIHtcbiAgdmFyIHJlc3VsdCA9IG5ldyBhcnJheUJ1ZmZlci5jb25zdHJ1Y3RvcihhcnJheUJ1ZmZlci5ieXRlTGVuZ3RoKTtcbiAgbmV3IFVpbnQ4QXJyYXkocmVzdWx0KS5zZXQobmV3IFVpbnQ4QXJyYXkoYXJyYXlCdWZmZXIpKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjbG9uZUFycmF5QnVmZmVyO1xuIiwidmFyIHJvb3QgPSByZXF1aXJlKCcuL19yb290Jyk7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgZXhwb3J0c2AuICovXG52YXIgZnJlZUV4cG9ydHMgPSB0eXBlb2YgZXhwb3J0cyA9PSAnb2JqZWN0JyAmJiBleHBvcnRzICYmICFleHBvcnRzLm5vZGVUeXBlICYmIGV4cG9ydHM7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgbW9kdWxlYC4gKi9cbnZhciBmcmVlTW9kdWxlID0gZnJlZUV4cG9ydHMgJiYgdHlwZW9mIG1vZHVsZSA9PSAnb2JqZWN0JyAmJiBtb2R1bGUgJiYgIW1vZHVsZS5ub2RlVHlwZSAmJiBtb2R1bGU7XG5cbi8qKiBEZXRlY3QgdGhlIHBvcHVsYXIgQ29tbW9uSlMgZXh0ZW5zaW9uIGBtb2R1bGUuZXhwb3J0c2AuICovXG52YXIgbW9kdWxlRXhwb3J0cyA9IGZyZWVNb2R1bGUgJiYgZnJlZU1vZHVsZS5leHBvcnRzID09PSBmcmVlRXhwb3J0cztcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgQnVmZmVyID0gbW9kdWxlRXhwb3J0cyA/IHJvb3QuQnVmZmVyIDogdW5kZWZpbmVkLFxuICAgIGFsbG9jVW5zYWZlID0gQnVmZmVyID8gQnVmZmVyLmFsbG9jVW5zYWZlIDogdW5kZWZpbmVkO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBjbG9uZSBvZiAgYGJ1ZmZlcmAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QnVmZmVyfSBidWZmZXIgVGhlIGJ1ZmZlciB0byBjbG9uZS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzRGVlcF0gU3BlY2lmeSBhIGRlZXAgY2xvbmUuXG4gKiBAcmV0dXJucyB7QnVmZmVyfSBSZXR1cm5zIHRoZSBjbG9uZWQgYnVmZmVyLlxuICovXG5mdW5jdGlvbiBjbG9uZUJ1ZmZlcihidWZmZXIsIGlzRGVlcCkge1xuICBpZiAoaXNEZWVwKSB7XG4gICAgcmV0dXJuIGJ1ZmZlci5zbGljZSgpO1xuICB9XG4gIHZhciBsZW5ndGggPSBidWZmZXIubGVuZ3RoLFxuICAgICAgcmVzdWx0ID0gYWxsb2NVbnNhZmUgPyBhbGxvY1Vuc2FmZShsZW5ndGgpIDogbmV3IGJ1ZmZlci5jb25zdHJ1Y3RvcihsZW5ndGgpO1xuXG4gIGJ1ZmZlci5jb3B5KHJlc3VsdCk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY2xvbmVCdWZmZXI7XG4iLCJ2YXIgY2xvbmVBcnJheUJ1ZmZlciA9IHJlcXVpcmUoJy4vX2Nsb25lQXJyYXlCdWZmZXInKTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgY2xvbmUgb2YgYGRhdGFWaWV3YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IGRhdGFWaWV3IFRoZSBkYXRhIHZpZXcgdG8gY2xvbmUuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtpc0RlZXBdIFNwZWNpZnkgYSBkZWVwIGNsb25lLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY2xvbmVkIGRhdGEgdmlldy5cbiAqL1xuZnVuY3Rpb24gY2xvbmVEYXRhVmlldyhkYXRhVmlldywgaXNEZWVwKSB7XG4gIHZhciBidWZmZXIgPSBpc0RlZXAgPyBjbG9uZUFycmF5QnVmZmVyKGRhdGFWaWV3LmJ1ZmZlcikgOiBkYXRhVmlldy5idWZmZXI7XG4gIHJldHVybiBuZXcgZGF0YVZpZXcuY29uc3RydWN0b3IoYnVmZmVyLCBkYXRhVmlldy5ieXRlT2Zmc2V0LCBkYXRhVmlldy5ieXRlTGVuZ3RoKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjbG9uZURhdGFWaWV3O1xuIiwiLyoqIFVzZWQgdG8gbWF0Y2ggYFJlZ0V4cGAgZmxhZ3MgZnJvbSB0aGVpciBjb2VyY2VkIHN0cmluZyB2YWx1ZXMuICovXG52YXIgcmVGbGFncyA9IC9cXHcqJC87XG5cbi8qKlxuICogQ3JlYXRlcyBhIGNsb25lIG9mIGByZWdleHBgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gcmVnZXhwIFRoZSByZWdleHAgdG8gY2xvbmUuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjbG9uZWQgcmVnZXhwLlxuICovXG5mdW5jdGlvbiBjbG9uZVJlZ0V4cChyZWdleHApIHtcbiAgdmFyIHJlc3VsdCA9IG5ldyByZWdleHAuY29uc3RydWN0b3IocmVnZXhwLnNvdXJjZSwgcmVGbGFncy5leGVjKHJlZ2V4cCkpO1xuICByZXN1bHQubGFzdEluZGV4ID0gcmVnZXhwLmxhc3RJbmRleDtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjbG9uZVJlZ0V4cDtcbiIsInZhciBTeW1ib2wgPSByZXF1aXJlKCcuL19TeW1ib2wnKTtcblxuLyoqIFVzZWQgdG8gY29udmVydCBzeW1ib2xzIHRvIHByaW1pdGl2ZXMgYW5kIHN0cmluZ3MuICovXG52YXIgc3ltYm9sUHJvdG8gPSBTeW1ib2wgPyBTeW1ib2wucHJvdG90eXBlIDogdW5kZWZpbmVkLFxuICAgIHN5bWJvbFZhbHVlT2YgPSBzeW1ib2xQcm90byA/IHN5bWJvbFByb3RvLnZhbHVlT2YgOiB1bmRlZmluZWQ7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGNsb25lIG9mIHRoZSBgc3ltYm9sYCBvYmplY3QuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBzeW1ib2wgVGhlIHN5bWJvbCBvYmplY3QgdG8gY2xvbmUuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjbG9uZWQgc3ltYm9sIG9iamVjdC5cbiAqL1xuZnVuY3Rpb24gY2xvbmVTeW1ib2woc3ltYm9sKSB7XG4gIHJldHVybiBzeW1ib2xWYWx1ZU9mID8gT2JqZWN0KHN5bWJvbFZhbHVlT2YuY2FsbChzeW1ib2wpKSA6IHt9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNsb25lU3ltYm9sO1xuIiwidmFyIGNsb25lQXJyYXlCdWZmZXIgPSByZXF1aXJlKCcuL19jbG9uZUFycmF5QnVmZmVyJyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGNsb25lIG9mIGB0eXBlZEFycmF5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IHR5cGVkQXJyYXkgVGhlIHR5cGVkIGFycmF5IHRvIGNsb25lLlxuICogQHBhcmFtIHtib29sZWFufSBbaXNEZWVwXSBTcGVjaWZ5IGEgZGVlcCBjbG9uZS5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGNsb25lZCB0eXBlZCBhcnJheS5cbiAqL1xuZnVuY3Rpb24gY2xvbmVUeXBlZEFycmF5KHR5cGVkQXJyYXksIGlzRGVlcCkge1xuICB2YXIgYnVmZmVyID0gaXNEZWVwID8gY2xvbmVBcnJheUJ1ZmZlcih0eXBlZEFycmF5LmJ1ZmZlcikgOiB0eXBlZEFycmF5LmJ1ZmZlcjtcbiAgcmV0dXJuIG5ldyB0eXBlZEFycmF5LmNvbnN0cnVjdG9yKGJ1ZmZlciwgdHlwZWRBcnJheS5ieXRlT2Zmc2V0LCB0eXBlZEFycmF5Lmxlbmd0aCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY2xvbmVUeXBlZEFycmF5O1xuIiwidmFyIGlzU3ltYm9sID0gcmVxdWlyZSgnLi9pc1N5bWJvbCcpO1xuXG4vKipcbiAqIENvbXBhcmVzIHZhbHVlcyB0byBzb3J0IHRoZW0gaW4gYXNjZW5kaW5nIG9yZGVyLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb21wYXJlLlxuICogQHBhcmFtIHsqfSBvdGhlciBUaGUgb3RoZXIgdmFsdWUgdG8gY29tcGFyZS5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIHNvcnQgb3JkZXIgaW5kaWNhdG9yIGZvciBgdmFsdWVgLlxuICovXG5mdW5jdGlvbiBjb21wYXJlQXNjZW5kaW5nKHZhbHVlLCBvdGhlcikge1xuICBpZiAodmFsdWUgIT09IG90aGVyKSB7XG4gICAgdmFyIHZhbElzRGVmaW5lZCA9IHZhbHVlICE9PSB1bmRlZmluZWQsXG4gICAgICAgIHZhbElzTnVsbCA9IHZhbHVlID09PSBudWxsLFxuICAgICAgICB2YWxJc1JlZmxleGl2ZSA9IHZhbHVlID09PSB2YWx1ZSxcbiAgICAgICAgdmFsSXNTeW1ib2wgPSBpc1N5bWJvbCh2YWx1ZSk7XG5cbiAgICB2YXIgb3RoSXNEZWZpbmVkID0gb3RoZXIgIT09IHVuZGVmaW5lZCxcbiAgICAgICAgb3RoSXNOdWxsID0gb3RoZXIgPT09IG51bGwsXG4gICAgICAgIG90aElzUmVmbGV4aXZlID0gb3RoZXIgPT09IG90aGVyLFxuICAgICAgICBvdGhJc1N5bWJvbCA9IGlzU3ltYm9sKG90aGVyKTtcblxuICAgIGlmICgoIW90aElzTnVsbCAmJiAhb3RoSXNTeW1ib2wgJiYgIXZhbElzU3ltYm9sICYmIHZhbHVlID4gb3RoZXIpIHx8XG4gICAgICAgICh2YWxJc1N5bWJvbCAmJiBvdGhJc0RlZmluZWQgJiYgb3RoSXNSZWZsZXhpdmUgJiYgIW90aElzTnVsbCAmJiAhb3RoSXNTeW1ib2wpIHx8XG4gICAgICAgICh2YWxJc051bGwgJiYgb3RoSXNEZWZpbmVkICYmIG90aElzUmVmbGV4aXZlKSB8fFxuICAgICAgICAoIXZhbElzRGVmaW5lZCAmJiBvdGhJc1JlZmxleGl2ZSkgfHxcbiAgICAgICAgIXZhbElzUmVmbGV4aXZlKSB7XG4gICAgICByZXR1cm4gMTtcbiAgICB9XG4gICAgaWYgKCghdmFsSXNOdWxsICYmICF2YWxJc1N5bWJvbCAmJiAhb3RoSXNTeW1ib2wgJiYgdmFsdWUgPCBvdGhlcikgfHxcbiAgICAgICAgKG90aElzU3ltYm9sICYmIHZhbElzRGVmaW5lZCAmJiB2YWxJc1JlZmxleGl2ZSAmJiAhdmFsSXNOdWxsICYmICF2YWxJc1N5bWJvbCkgfHxcbiAgICAgICAgKG90aElzTnVsbCAmJiB2YWxJc0RlZmluZWQgJiYgdmFsSXNSZWZsZXhpdmUpIHx8XG4gICAgICAgICghb3RoSXNEZWZpbmVkICYmIHZhbElzUmVmbGV4aXZlKSB8fFxuICAgICAgICAhb3RoSXNSZWZsZXhpdmUpIHtcbiAgICAgIHJldHVybiAtMTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIDA7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY29tcGFyZUFzY2VuZGluZztcbiIsInZhciBjb21wYXJlQXNjZW5kaW5nID0gcmVxdWlyZSgnLi9fY29tcGFyZUFzY2VuZGluZycpO1xuXG4vKipcbiAqIFVzZWQgYnkgYF8ub3JkZXJCeWAgdG8gY29tcGFyZSBtdWx0aXBsZSBwcm9wZXJ0aWVzIG9mIGEgdmFsdWUgdG8gYW5vdGhlclxuICogYW5kIHN0YWJsZSBzb3J0IHRoZW0uXG4gKlxuICogSWYgYG9yZGVyc2AgaXMgdW5zcGVjaWZpZWQsIGFsbCB2YWx1ZXMgYXJlIHNvcnRlZCBpbiBhc2NlbmRpbmcgb3JkZXIuIE90aGVyd2lzZSxcbiAqIHNwZWNpZnkgYW4gb3JkZXIgb2YgXCJkZXNjXCIgZm9yIGRlc2NlbmRpbmcgb3IgXCJhc2NcIiBmb3IgYXNjZW5kaW5nIHNvcnQgb3JkZXJcbiAqIG9mIGNvcnJlc3BvbmRpbmcgdmFsdWVzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvdGhlciBUaGUgb3RoZXIgb2JqZWN0IHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge2Jvb2xlYW5bXXxzdHJpbmdbXX0gb3JkZXJzIFRoZSBvcmRlciB0byBzb3J0IGJ5IGZvciBlYWNoIHByb3BlcnR5LlxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgc29ydCBvcmRlciBpbmRpY2F0b3IgZm9yIGBvYmplY3RgLlxuICovXG5mdW5jdGlvbiBjb21wYXJlTXVsdGlwbGUob2JqZWN0LCBvdGhlciwgb3JkZXJzKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgb2JqQ3JpdGVyaWEgPSBvYmplY3QuY3JpdGVyaWEsXG4gICAgICBvdGhDcml0ZXJpYSA9IG90aGVyLmNyaXRlcmlhLFxuICAgICAgbGVuZ3RoID0gb2JqQ3JpdGVyaWEubGVuZ3RoLFxuICAgICAgb3JkZXJzTGVuZ3RoID0gb3JkZXJzLmxlbmd0aDtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciByZXN1bHQgPSBjb21wYXJlQXNjZW5kaW5nKG9iakNyaXRlcmlhW2luZGV4XSwgb3RoQ3JpdGVyaWFbaW5kZXhdKTtcbiAgICBpZiAocmVzdWx0KSB7XG4gICAgICBpZiAoaW5kZXggPj0gb3JkZXJzTGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG4gICAgICB2YXIgb3JkZXIgPSBvcmRlcnNbaW5kZXhdO1xuICAgICAgcmV0dXJuIHJlc3VsdCAqIChvcmRlciA9PSAnZGVzYycgPyAtMSA6IDEpO1xuICAgIH1cbiAgfVxuICAvLyBGaXhlcyBhbiBgQXJyYXkjc29ydGAgYnVnIGluIHRoZSBKUyBlbmdpbmUgZW1iZWRkZWQgaW4gQWRvYmUgYXBwbGljYXRpb25zXG4gIC8vIHRoYXQgY2F1c2VzIGl0LCB1bmRlciBjZXJ0YWluIGNpcmN1bXN0YW5jZXMsIHRvIHByb3ZpZGUgdGhlIHNhbWUgdmFsdWUgZm9yXG4gIC8vIGBvYmplY3RgIGFuZCBgb3RoZXJgLiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2phc2hrZW5hcy91bmRlcnNjb3JlL3B1bGwvMTI0N1xuICAvLyBmb3IgbW9yZSBkZXRhaWxzLlxuICAvL1xuICAvLyBUaGlzIGFsc28gZW5zdXJlcyBhIHN0YWJsZSBzb3J0IGluIFY4IGFuZCBvdGhlciBlbmdpbmVzLlxuICAvLyBTZWUgaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9OTAgZm9yIG1vcmUgZGV0YWlscy5cbiAgcmV0dXJuIG9iamVjdC5pbmRleCAtIG90aGVyLmluZGV4O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNvbXBhcmVNdWx0aXBsZTtcbiIsIi8qKlxuICogQ29waWVzIHRoZSB2YWx1ZXMgb2YgYHNvdXJjZWAgdG8gYGFycmF5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gc291cmNlIFRoZSBhcnJheSB0byBjb3B5IHZhbHVlcyBmcm9tLlxuICogQHBhcmFtIHtBcnJheX0gW2FycmF5PVtdXSBUaGUgYXJyYXkgdG8gY29weSB2YWx1ZXMgdG8uXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC5cbiAqL1xuZnVuY3Rpb24gY29weUFycmF5KHNvdXJjZSwgYXJyYXkpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBzb3VyY2UubGVuZ3RoO1xuXG4gIGFycmF5IHx8IChhcnJheSA9IEFycmF5KGxlbmd0aCkpO1xuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIGFycmF5W2luZGV4XSA9IHNvdXJjZVtpbmRleF07XG4gIH1cbiAgcmV0dXJuIGFycmF5O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNvcHlBcnJheTtcbiIsInZhciBhc3NpZ25WYWx1ZSA9IHJlcXVpcmUoJy4vX2Fzc2lnblZhbHVlJyksXG4gICAgYmFzZUFzc2lnblZhbHVlID0gcmVxdWlyZSgnLi9fYmFzZUFzc2lnblZhbHVlJyk7XG5cbi8qKlxuICogQ29waWVzIHByb3BlcnRpZXMgb2YgYHNvdXJjZWAgdG8gYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIG9iamVjdCB0byBjb3B5IHByb3BlcnRpZXMgZnJvbS5cbiAqIEBwYXJhbSB7QXJyYXl9IHByb3BzIFRoZSBwcm9wZXJ0eSBpZGVudGlmaWVycyB0byBjb3B5LlxuICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3Q9e31dIFRoZSBvYmplY3QgdG8gY29weSBwcm9wZXJ0aWVzIHRvLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29waWVkIHZhbHVlcy5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gKi9cbmZ1bmN0aW9uIGNvcHlPYmplY3Qoc291cmNlLCBwcm9wcywgb2JqZWN0LCBjdXN0b21pemVyKSB7XG4gIHZhciBpc05ldyA9ICFvYmplY3Q7XG4gIG9iamVjdCB8fCAob2JqZWN0ID0ge30pO1xuXG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gcHJvcHMubGVuZ3RoO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIGtleSA9IHByb3BzW2luZGV4XTtcblxuICAgIHZhciBuZXdWYWx1ZSA9IGN1c3RvbWl6ZXJcbiAgICAgID8gY3VzdG9taXplcihvYmplY3Rba2V5XSwgc291cmNlW2tleV0sIGtleSwgb2JqZWN0LCBzb3VyY2UpXG4gICAgICA6IHVuZGVmaW5lZDtcblxuICAgIGlmIChuZXdWYWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBuZXdWYWx1ZSA9IHNvdXJjZVtrZXldO1xuICAgIH1cbiAgICBpZiAoaXNOZXcpIHtcbiAgICAgIGJhc2VBc3NpZ25WYWx1ZShvYmplY3QsIGtleSwgbmV3VmFsdWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBhc3NpZ25WYWx1ZShvYmplY3QsIGtleSwgbmV3VmFsdWUpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gb2JqZWN0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNvcHlPYmplY3Q7XG4iLCJ2YXIgY29weU9iamVjdCA9IHJlcXVpcmUoJy4vX2NvcHlPYmplY3QnKSxcbiAgICBnZXRTeW1ib2xzID0gcmVxdWlyZSgnLi9fZ2V0U3ltYm9scycpO1xuXG4vKipcbiAqIENvcGllcyBvd24gc3ltYm9scyBvZiBgc291cmNlYCB0byBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgb2JqZWN0IHRvIGNvcHkgc3ltYm9scyBmcm9tLlxuICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3Q9e31dIFRoZSBvYmplY3QgdG8gY29weSBzeW1ib2xzIHRvLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAqL1xuZnVuY3Rpb24gY29weVN5bWJvbHMoc291cmNlLCBvYmplY3QpIHtcbiAgcmV0dXJuIGNvcHlPYmplY3Qoc291cmNlLCBnZXRTeW1ib2xzKHNvdXJjZSksIG9iamVjdCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY29weVN5bWJvbHM7XG4iLCJ2YXIgY29weU9iamVjdCA9IHJlcXVpcmUoJy4vX2NvcHlPYmplY3QnKSxcbiAgICBnZXRTeW1ib2xzSW4gPSByZXF1aXJlKCcuL19nZXRTeW1ib2xzSW4nKTtcblxuLyoqXG4gKiBDb3BpZXMgb3duIGFuZCBpbmhlcml0ZWQgc3ltYm9scyBvZiBgc291cmNlYCB0byBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgb2JqZWN0IHRvIGNvcHkgc3ltYm9scyBmcm9tLlxuICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3Q9e31dIFRoZSBvYmplY3QgdG8gY29weSBzeW1ib2xzIHRvLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAqL1xuZnVuY3Rpb24gY29weVN5bWJvbHNJbihzb3VyY2UsIG9iamVjdCkge1xuICByZXR1cm4gY29weU9iamVjdChzb3VyY2UsIGdldFN5bWJvbHNJbihzb3VyY2UpLCBvYmplY3QpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNvcHlTeW1ib2xzSW47XG4iLCJ2YXIgcm9vdCA9IHJlcXVpcmUoJy4vX3Jvb3QnKTtcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IG92ZXJyZWFjaGluZyBjb3JlLWpzIHNoaW1zLiAqL1xudmFyIGNvcmVKc0RhdGEgPSByb290WydfX2NvcmUtanNfc2hhcmVkX18nXTtcblxubW9kdWxlLmV4cG9ydHMgPSBjb3JlSnNEYXRhO1xuIiwidmFyIGJhc2VSZXN0ID0gcmVxdWlyZSgnLi9fYmFzZVJlc3QnKSxcbiAgICBpc0l0ZXJhdGVlQ2FsbCA9IHJlcXVpcmUoJy4vX2lzSXRlcmF0ZWVDYWxsJyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGZ1bmN0aW9uIGxpa2UgYF8uYXNzaWduYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gYXNzaWduZXIgVGhlIGZ1bmN0aW9uIHRvIGFzc2lnbiB2YWx1ZXMuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBhc3NpZ25lciBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlQXNzaWduZXIoYXNzaWduZXIpIHtcbiAgcmV0dXJuIGJhc2VSZXN0KGZ1bmN0aW9uKG9iamVjdCwgc291cmNlcykge1xuICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICBsZW5ndGggPSBzb3VyY2VzLmxlbmd0aCxcbiAgICAgICAgY3VzdG9taXplciA9IGxlbmd0aCA+IDEgPyBzb3VyY2VzW2xlbmd0aCAtIDFdIDogdW5kZWZpbmVkLFxuICAgICAgICBndWFyZCA9IGxlbmd0aCA+IDIgPyBzb3VyY2VzWzJdIDogdW5kZWZpbmVkO1xuXG4gICAgY3VzdG9taXplciA9IChhc3NpZ25lci5sZW5ndGggPiAzICYmIHR5cGVvZiBjdXN0b21pemVyID09ICdmdW5jdGlvbicpXG4gICAgICA/IChsZW5ndGgtLSwgY3VzdG9taXplcilcbiAgICAgIDogdW5kZWZpbmVkO1xuXG4gICAgaWYgKGd1YXJkICYmIGlzSXRlcmF0ZWVDYWxsKHNvdXJjZXNbMF0sIHNvdXJjZXNbMV0sIGd1YXJkKSkge1xuICAgICAgY3VzdG9taXplciA9IGxlbmd0aCA8IDMgPyB1bmRlZmluZWQgOiBjdXN0b21pemVyO1xuICAgICAgbGVuZ3RoID0gMTtcbiAgICB9XG4gICAgb2JqZWN0ID0gT2JqZWN0KG9iamVjdCk7XG4gICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgIHZhciBzb3VyY2UgPSBzb3VyY2VzW2luZGV4XTtcbiAgICAgIGlmIChzb3VyY2UpIHtcbiAgICAgICAgYXNzaWduZXIob2JqZWN0LCBzb3VyY2UsIGluZGV4LCBjdXN0b21pemVyKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG9iamVjdDtcbiAgfSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY3JlYXRlQXNzaWduZXI7XG4iLCJ2YXIgaXNBcnJheUxpa2UgPSByZXF1aXJlKCcuL2lzQXJyYXlMaWtlJyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGBiYXNlRWFjaGAgb3IgYGJhc2VFYWNoUmlnaHRgIGZ1bmN0aW9uLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBlYWNoRnVuYyBUaGUgZnVuY3Rpb24gdG8gaXRlcmF0ZSBvdmVyIGEgY29sbGVjdGlvbi5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2Zyb21SaWdodF0gU3BlY2lmeSBpdGVyYXRpbmcgZnJvbSByaWdodCB0byBsZWZ0LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYmFzZSBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlQmFzZUVhY2goZWFjaEZ1bmMsIGZyb21SaWdodCkge1xuICByZXR1cm4gZnVuY3Rpb24oY29sbGVjdGlvbiwgaXRlcmF0ZWUpIHtcbiAgICBpZiAoY29sbGVjdGlvbiA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gY29sbGVjdGlvbjtcbiAgICB9XG4gICAgaWYgKCFpc0FycmF5TGlrZShjb2xsZWN0aW9uKSkge1xuICAgICAgcmV0dXJuIGVhY2hGdW5jKGNvbGxlY3Rpb24sIGl0ZXJhdGVlKTtcbiAgICB9XG4gICAgdmFyIGxlbmd0aCA9IGNvbGxlY3Rpb24ubGVuZ3RoLFxuICAgICAgICBpbmRleCA9IGZyb21SaWdodCA/IGxlbmd0aCA6IC0xLFxuICAgICAgICBpdGVyYWJsZSA9IE9iamVjdChjb2xsZWN0aW9uKTtcblxuICAgIHdoaWxlICgoZnJvbVJpZ2h0ID8gaW5kZXgtLSA6ICsraW5kZXggPCBsZW5ndGgpKSB7XG4gICAgICBpZiAoaXRlcmF0ZWUoaXRlcmFibGVbaW5kZXhdLCBpbmRleCwgaXRlcmFibGUpID09PSBmYWxzZSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGNvbGxlY3Rpb247XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY3JlYXRlQmFzZUVhY2g7XG4iLCIvKipcbiAqIENyZWF0ZXMgYSBiYXNlIGZ1bmN0aW9uIGZvciBtZXRob2RzIGxpa2UgYF8uZm9ySW5gIGFuZCBgXy5mb3JPd25gLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtmcm9tUmlnaHRdIFNwZWNpZnkgaXRlcmF0aW5nIGZyb20gcmlnaHQgdG8gbGVmdC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGJhc2UgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUJhc2VGb3IoZnJvbVJpZ2h0KSB7XG4gIHJldHVybiBmdW5jdGlvbihvYmplY3QsIGl0ZXJhdGVlLCBrZXlzRnVuYykge1xuICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICBpdGVyYWJsZSA9IE9iamVjdChvYmplY3QpLFxuICAgICAgICBwcm9wcyA9IGtleXNGdW5jKG9iamVjdCksXG4gICAgICAgIGxlbmd0aCA9IHByb3BzLmxlbmd0aDtcblxuICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgdmFyIGtleSA9IHByb3BzW2Zyb21SaWdodCA/IGxlbmd0aCA6ICsraW5kZXhdO1xuICAgICAgaWYgKGl0ZXJhdGVlKGl0ZXJhYmxlW2tleV0sIGtleSwgaXRlcmFibGUpID09PSBmYWxzZSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG9iamVjdDtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjcmVhdGVCYXNlRm9yO1xuIiwidmFyIGJhc2VJdGVyYXRlZSA9IHJlcXVpcmUoJy4vX2Jhc2VJdGVyYXRlZScpLFxuICAgIGlzQXJyYXlMaWtlID0gcmVxdWlyZSgnLi9pc0FycmF5TGlrZScpLFxuICAgIGtleXMgPSByZXF1aXJlKCcuL2tleXMnKTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgYF8uZmluZGAgb3IgYF8uZmluZExhc3RgIGZ1bmN0aW9uLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmaW5kSW5kZXhGdW5jIFRoZSBmdW5jdGlvbiB0byBmaW5kIHRoZSBjb2xsZWN0aW9uIGluZGV4LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZmluZCBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlRmluZChmaW5kSW5kZXhGdW5jKSB7XG4gIHJldHVybiBmdW5jdGlvbihjb2xsZWN0aW9uLCBwcmVkaWNhdGUsIGZyb21JbmRleCkge1xuICAgIHZhciBpdGVyYWJsZSA9IE9iamVjdChjb2xsZWN0aW9uKTtcbiAgICBpZiAoIWlzQXJyYXlMaWtlKGNvbGxlY3Rpb24pKSB7XG4gICAgICB2YXIgaXRlcmF0ZWUgPSBiYXNlSXRlcmF0ZWUocHJlZGljYXRlLCAzKTtcbiAgICAgIGNvbGxlY3Rpb24gPSBrZXlzKGNvbGxlY3Rpb24pO1xuICAgICAgcHJlZGljYXRlID0gZnVuY3Rpb24oa2V5KSB7IHJldHVybiBpdGVyYXRlZShpdGVyYWJsZVtrZXldLCBrZXksIGl0ZXJhYmxlKTsgfTtcbiAgICB9XG4gICAgdmFyIGluZGV4ID0gZmluZEluZGV4RnVuYyhjb2xsZWN0aW9uLCBwcmVkaWNhdGUsIGZyb21JbmRleCk7XG4gICAgcmV0dXJuIGluZGV4ID4gLTEgPyBpdGVyYWJsZVtpdGVyYXRlZSA/IGNvbGxlY3Rpb25baW5kZXhdIDogaW5kZXhdIDogdW5kZWZpbmVkO1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNyZWF0ZUZpbmQ7XG4iLCJ2YXIgYmFzZVJhbmdlID0gcmVxdWlyZSgnLi9fYmFzZVJhbmdlJyksXG4gICAgaXNJdGVyYXRlZUNhbGwgPSByZXF1aXJlKCcuL19pc0l0ZXJhdGVlQ2FsbCcpLFxuICAgIHRvRmluaXRlID0gcmVxdWlyZSgnLi90b0Zpbml0ZScpO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBgXy5yYW5nZWAgb3IgYF8ucmFuZ2VSaWdodGAgZnVuY3Rpb24uXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2Zyb21SaWdodF0gU3BlY2lmeSBpdGVyYXRpbmcgZnJvbSByaWdodCB0byBsZWZ0LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgcmFuZ2UgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVJhbmdlKGZyb21SaWdodCkge1xuICByZXR1cm4gZnVuY3Rpb24oc3RhcnQsIGVuZCwgc3RlcCkge1xuICAgIGlmIChzdGVwICYmIHR5cGVvZiBzdGVwICE9ICdudW1iZXInICYmIGlzSXRlcmF0ZWVDYWxsKHN0YXJ0LCBlbmQsIHN0ZXApKSB7XG4gICAgICBlbmQgPSBzdGVwID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICAvLyBFbnN1cmUgdGhlIHNpZ24gb2YgYC0wYCBpcyBwcmVzZXJ2ZWQuXG4gICAgc3RhcnQgPSB0b0Zpbml0ZShzdGFydCk7XG4gICAgaWYgKGVuZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBlbmQgPSBzdGFydDtcbiAgICAgIHN0YXJ0ID0gMDtcbiAgICB9IGVsc2Uge1xuICAgICAgZW5kID0gdG9GaW5pdGUoZW5kKTtcbiAgICB9XG4gICAgc3RlcCA9IHN0ZXAgPT09IHVuZGVmaW5lZCA/IChzdGFydCA8IGVuZCA/IDEgOiAtMSkgOiB0b0Zpbml0ZShzdGVwKTtcbiAgICByZXR1cm4gYmFzZVJhbmdlKHN0YXJ0LCBlbmQsIHN0ZXAsIGZyb21SaWdodCk7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY3JlYXRlUmFuZ2U7XG4iLCJ2YXIgU2V0ID0gcmVxdWlyZSgnLi9fU2V0JyksXG4gICAgbm9vcCA9IHJlcXVpcmUoJy4vbm9vcCcpLFxuICAgIHNldFRvQXJyYXkgPSByZXF1aXJlKCcuL19zZXRUb0FycmF5Jyk7XG5cbi8qKiBVc2VkIGFzIHJlZmVyZW5jZXMgZm9yIHZhcmlvdXMgYE51bWJlcmAgY29uc3RhbnRzLiAqL1xudmFyIElORklOSVRZID0gMSAvIDA7XG5cbi8qKlxuICogQ3JlYXRlcyBhIHNldCBvYmplY3Qgb2YgYHZhbHVlc2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IHZhbHVlcyBUaGUgdmFsdWVzIHRvIGFkZCB0byB0aGUgc2V0LlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IHNldC5cbiAqL1xudmFyIGNyZWF0ZVNldCA9ICEoU2V0ICYmICgxIC8gc2V0VG9BcnJheShuZXcgU2V0KFssLTBdKSlbMV0pID09IElORklOSVRZKSA/IG5vb3AgOiBmdW5jdGlvbih2YWx1ZXMpIHtcbiAgcmV0dXJuIG5ldyBTZXQodmFsdWVzKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gY3JlYXRlU2V0O1xuIiwidmFyIGdldE5hdGl2ZSA9IHJlcXVpcmUoJy4vX2dldE5hdGl2ZScpO1xuXG52YXIgZGVmaW5lUHJvcGVydHkgPSAoZnVuY3Rpb24oKSB7XG4gIHRyeSB7XG4gICAgdmFyIGZ1bmMgPSBnZXROYXRpdmUoT2JqZWN0LCAnZGVmaW5lUHJvcGVydHknKTtcbiAgICBmdW5jKHt9LCAnJywge30pO1xuICAgIHJldHVybiBmdW5jO1xuICB9IGNhdGNoIChlKSB7fVxufSgpKTtcblxubW9kdWxlLmV4cG9ydHMgPSBkZWZpbmVQcm9wZXJ0eTtcbiIsInZhciBTZXRDYWNoZSA9IHJlcXVpcmUoJy4vX1NldENhY2hlJyksXG4gICAgYXJyYXlTb21lID0gcmVxdWlyZSgnLi9fYXJyYXlTb21lJyksXG4gICAgY2FjaGVIYXMgPSByZXF1aXJlKCcuL19jYWNoZUhhcycpO1xuXG4vKiogVXNlZCB0byBjb21wb3NlIGJpdG1hc2tzIGZvciB2YWx1ZSBjb21wYXJpc29ucy4gKi9cbnZhciBDT01QQVJFX1BBUlRJQUxfRkxBRyA9IDEsXG4gICAgQ09NUEFSRV9VTk9SREVSRURfRkxBRyA9IDI7XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlSXNFcXVhbERlZXBgIGZvciBhcnJheXMgd2l0aCBzdXBwb3J0IGZvclxuICogcGFydGlhbCBkZWVwIGNvbXBhcmlzb25zLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7QXJyYXl9IG90aGVyIFRoZSBvdGhlciBhcnJheSB0byBjb21wYXJlLlxuICogQHBhcmFtIHtudW1iZXJ9IGJpdG1hc2sgVGhlIGJpdG1hc2sgZmxhZ3MuIFNlZSBgYmFzZUlzRXF1YWxgIGZvciBtb3JlIGRldGFpbHMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjdXN0b21pemVyIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29tcGFyaXNvbnMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBlcXVhbEZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGRldGVybWluZSBlcXVpdmFsZW50cyBvZiB2YWx1ZXMuXG4gKiBAcGFyYW0ge09iamVjdH0gc3RhY2sgVHJhY2tzIHRyYXZlcnNlZCBgYXJyYXlgIGFuZCBgb3RoZXJgIG9iamVjdHMuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGFycmF5cyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBlcXVhbEFycmF5cyhhcnJheSwgb3RoZXIsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGVxdWFsRnVuYywgc3RhY2spIHtcbiAgdmFyIGlzUGFydGlhbCA9IGJpdG1hc2sgJiBDT01QQVJFX1BBUlRJQUxfRkxBRyxcbiAgICAgIGFyckxlbmd0aCA9IGFycmF5Lmxlbmd0aCxcbiAgICAgIG90aExlbmd0aCA9IG90aGVyLmxlbmd0aDtcblxuICBpZiAoYXJyTGVuZ3RoICE9IG90aExlbmd0aCAmJiAhKGlzUGFydGlhbCAmJiBvdGhMZW5ndGggPiBhcnJMZW5ndGgpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIC8vIENoZWNrIHRoYXQgY3ljbGljIHZhbHVlcyBhcmUgZXF1YWwuXG4gIHZhciBhcnJTdGFja2VkID0gc3RhY2suZ2V0KGFycmF5KTtcbiAgdmFyIG90aFN0YWNrZWQgPSBzdGFjay5nZXQob3RoZXIpO1xuICBpZiAoYXJyU3RhY2tlZCAmJiBvdGhTdGFja2VkKSB7XG4gICAgcmV0dXJuIGFyclN0YWNrZWQgPT0gb3RoZXIgJiYgb3RoU3RhY2tlZCA9PSBhcnJheTtcbiAgfVxuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIHJlc3VsdCA9IHRydWUsXG4gICAgICBzZWVuID0gKGJpdG1hc2sgJiBDT01QQVJFX1VOT1JERVJFRF9GTEFHKSA/IG5ldyBTZXRDYWNoZSA6IHVuZGVmaW5lZDtcblxuICBzdGFjay5zZXQoYXJyYXksIG90aGVyKTtcbiAgc3RhY2suc2V0KG90aGVyLCBhcnJheSk7XG5cbiAgLy8gSWdub3JlIG5vbi1pbmRleCBwcm9wZXJ0aWVzLlxuICB3aGlsZSAoKytpbmRleCA8IGFyckxlbmd0aCkge1xuICAgIHZhciBhcnJWYWx1ZSA9IGFycmF5W2luZGV4XSxcbiAgICAgICAgb3RoVmFsdWUgPSBvdGhlcltpbmRleF07XG5cbiAgICBpZiAoY3VzdG9taXplcikge1xuICAgICAgdmFyIGNvbXBhcmVkID0gaXNQYXJ0aWFsXG4gICAgICAgID8gY3VzdG9taXplcihvdGhWYWx1ZSwgYXJyVmFsdWUsIGluZGV4LCBvdGhlciwgYXJyYXksIHN0YWNrKVxuICAgICAgICA6IGN1c3RvbWl6ZXIoYXJyVmFsdWUsIG90aFZhbHVlLCBpbmRleCwgYXJyYXksIG90aGVyLCBzdGFjayk7XG4gICAgfVxuICAgIGlmIChjb21wYXJlZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBpZiAoY29tcGFyZWQpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICByZXN1bHQgPSBmYWxzZTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICAvLyBSZWN1cnNpdmVseSBjb21wYXJlIGFycmF5cyAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpLlxuICAgIGlmIChzZWVuKSB7XG4gICAgICBpZiAoIWFycmF5U29tZShvdGhlciwgZnVuY3Rpb24ob3RoVmFsdWUsIG90aEluZGV4KSB7XG4gICAgICAgICAgICBpZiAoIWNhY2hlSGFzKHNlZW4sIG90aEluZGV4KSAmJlxuICAgICAgICAgICAgICAgIChhcnJWYWx1ZSA9PT0gb3RoVmFsdWUgfHwgZXF1YWxGdW5jKGFyclZhbHVlLCBvdGhWYWx1ZSwgYml0bWFzaywgY3VzdG9taXplciwgc3RhY2spKSkge1xuICAgICAgICAgICAgICByZXR1cm4gc2Vlbi5wdXNoKG90aEluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KSkge1xuICAgICAgICByZXN1bHQgPSBmYWxzZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICghKFxuICAgICAgICAgIGFyclZhbHVlID09PSBvdGhWYWx1ZSB8fFxuICAgICAgICAgICAgZXF1YWxGdW5jKGFyclZhbHVlLCBvdGhWYWx1ZSwgYml0bWFzaywgY3VzdG9taXplciwgc3RhY2spXG4gICAgICAgICkpIHtcbiAgICAgIHJlc3VsdCA9IGZhbHNlO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHN0YWNrWydkZWxldGUnXShhcnJheSk7XG4gIHN0YWNrWydkZWxldGUnXShvdGhlcik7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZXF1YWxBcnJheXM7XG4iLCJ2YXIgU3ltYm9sID0gcmVxdWlyZSgnLi9fU3ltYm9sJyksXG4gICAgVWludDhBcnJheSA9IHJlcXVpcmUoJy4vX1VpbnQ4QXJyYXknKSxcbiAgICBlcSA9IHJlcXVpcmUoJy4vZXEnKSxcbiAgICBlcXVhbEFycmF5cyA9IHJlcXVpcmUoJy4vX2VxdWFsQXJyYXlzJyksXG4gICAgbWFwVG9BcnJheSA9IHJlcXVpcmUoJy4vX21hcFRvQXJyYXknKSxcbiAgICBzZXRUb0FycmF5ID0gcmVxdWlyZSgnLi9fc2V0VG9BcnJheScpO1xuXG4vKiogVXNlZCB0byBjb21wb3NlIGJpdG1hc2tzIGZvciB2YWx1ZSBjb21wYXJpc29ucy4gKi9cbnZhciBDT01QQVJFX1BBUlRJQUxfRkxBRyA9IDEsXG4gICAgQ09NUEFSRV9VTk9SREVSRURfRkxBRyA9IDI7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBib29sVGFnID0gJ1tvYmplY3QgQm9vbGVhbl0nLFxuICAgIGRhdGVUYWcgPSAnW29iamVjdCBEYXRlXScsXG4gICAgZXJyb3JUYWcgPSAnW29iamVjdCBFcnJvcl0nLFxuICAgIG1hcFRhZyA9ICdbb2JqZWN0IE1hcF0nLFxuICAgIG51bWJlclRhZyA9ICdbb2JqZWN0IE51bWJlcl0nLFxuICAgIHJlZ2V4cFRhZyA9ICdbb2JqZWN0IFJlZ0V4cF0nLFxuICAgIHNldFRhZyA9ICdbb2JqZWN0IFNldF0nLFxuICAgIHN0cmluZ1RhZyA9ICdbb2JqZWN0IFN0cmluZ10nLFxuICAgIHN5bWJvbFRhZyA9ICdbb2JqZWN0IFN5bWJvbF0nO1xuXG52YXIgYXJyYXlCdWZmZXJUYWcgPSAnW29iamVjdCBBcnJheUJ1ZmZlcl0nLFxuICAgIGRhdGFWaWV3VGFnID0gJ1tvYmplY3QgRGF0YVZpZXddJztcblxuLyoqIFVzZWQgdG8gY29udmVydCBzeW1ib2xzIHRvIHByaW1pdGl2ZXMgYW5kIHN0cmluZ3MuICovXG52YXIgc3ltYm9sUHJvdG8gPSBTeW1ib2wgPyBTeW1ib2wucHJvdG90eXBlIDogdW5kZWZpbmVkLFxuICAgIHN5bWJvbFZhbHVlT2YgPSBzeW1ib2xQcm90byA/IHN5bWJvbFByb3RvLnZhbHVlT2YgOiB1bmRlZmluZWQ7XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlSXNFcXVhbERlZXBgIGZvciBjb21wYXJpbmcgb2JqZWN0cyBvZlxuICogdGhlIHNhbWUgYHRvU3RyaW5nVGFnYC5cbiAqXG4gKiAqKk5vdGU6KiogVGhpcyBmdW5jdGlvbiBvbmx5IHN1cHBvcnRzIGNvbXBhcmluZyB2YWx1ZXMgd2l0aCB0YWdzIG9mXG4gKiBgQm9vbGVhbmAsIGBEYXRlYCwgYEVycm9yYCwgYE51bWJlcmAsIGBSZWdFeHBgLCBvciBgU3RyaW5nYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge09iamVjdH0gb3RoZXIgVGhlIG90aGVyIG9iamVjdCB0byBjb21wYXJlLlxuICogQHBhcmFtIHtzdHJpbmd9IHRhZyBUaGUgYHRvU3RyaW5nVGFnYCBvZiB0aGUgb2JqZWN0cyB0byBjb21wYXJlLlxuICogQHBhcmFtIHtudW1iZXJ9IGJpdG1hc2sgVGhlIGJpdG1hc2sgZmxhZ3MuIFNlZSBgYmFzZUlzRXF1YWxgIGZvciBtb3JlIGRldGFpbHMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjdXN0b21pemVyIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29tcGFyaXNvbnMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBlcXVhbEZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGRldGVybWluZSBlcXVpdmFsZW50cyBvZiB2YWx1ZXMuXG4gKiBAcGFyYW0ge09iamVjdH0gc3RhY2sgVHJhY2tzIHRyYXZlcnNlZCBgb2JqZWN0YCBhbmQgYG90aGVyYCBvYmplY3RzLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBvYmplY3RzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGVxdWFsQnlUYWcob2JqZWN0LCBvdGhlciwgdGFnLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKSB7XG4gIHN3aXRjaCAodGFnKSB7XG4gICAgY2FzZSBkYXRhVmlld1RhZzpcbiAgICAgIGlmICgob2JqZWN0LmJ5dGVMZW5ndGggIT0gb3RoZXIuYnl0ZUxlbmd0aCkgfHxcbiAgICAgICAgICAob2JqZWN0LmJ5dGVPZmZzZXQgIT0gb3RoZXIuYnl0ZU9mZnNldCkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgb2JqZWN0ID0gb2JqZWN0LmJ1ZmZlcjtcbiAgICAgIG90aGVyID0gb3RoZXIuYnVmZmVyO1xuXG4gICAgY2FzZSBhcnJheUJ1ZmZlclRhZzpcbiAgICAgIGlmICgob2JqZWN0LmJ5dGVMZW5ndGggIT0gb3RoZXIuYnl0ZUxlbmd0aCkgfHxcbiAgICAgICAgICAhZXF1YWxGdW5jKG5ldyBVaW50OEFycmF5KG9iamVjdCksIG5ldyBVaW50OEFycmF5KG90aGVyKSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG5cbiAgICBjYXNlIGJvb2xUYWc6XG4gICAgY2FzZSBkYXRlVGFnOlxuICAgIGNhc2UgbnVtYmVyVGFnOlxuICAgICAgLy8gQ29lcmNlIGJvb2xlYW5zIHRvIGAxYCBvciBgMGAgYW5kIGRhdGVzIHRvIG1pbGxpc2Vjb25kcy5cbiAgICAgIC8vIEludmFsaWQgZGF0ZXMgYXJlIGNvZXJjZWQgdG8gYE5hTmAuXG4gICAgICByZXR1cm4gZXEoK29iamVjdCwgK290aGVyKTtcblxuICAgIGNhc2UgZXJyb3JUYWc6XG4gICAgICByZXR1cm4gb2JqZWN0Lm5hbWUgPT0gb3RoZXIubmFtZSAmJiBvYmplY3QubWVzc2FnZSA9PSBvdGhlci5tZXNzYWdlO1xuXG4gICAgY2FzZSByZWdleHBUYWc6XG4gICAgY2FzZSBzdHJpbmdUYWc6XG4gICAgICAvLyBDb2VyY2UgcmVnZXhlcyB0byBzdHJpbmdzIGFuZCB0cmVhdCBzdHJpbmdzLCBwcmltaXRpdmVzIGFuZCBvYmplY3RzLFxuICAgICAgLy8gYXMgZXF1YWwuIFNlZSBodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtcmVnZXhwLnByb3RvdHlwZS50b3N0cmluZ1xuICAgICAgLy8gZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgIHJldHVybiBvYmplY3QgPT0gKG90aGVyICsgJycpO1xuXG4gICAgY2FzZSBtYXBUYWc6XG4gICAgICB2YXIgY29udmVydCA9IG1hcFRvQXJyYXk7XG5cbiAgICBjYXNlIHNldFRhZzpcbiAgICAgIHZhciBpc1BhcnRpYWwgPSBiaXRtYXNrICYgQ09NUEFSRV9QQVJUSUFMX0ZMQUc7XG4gICAgICBjb252ZXJ0IHx8IChjb252ZXJ0ID0gc2V0VG9BcnJheSk7XG5cbiAgICAgIGlmIChvYmplY3Quc2l6ZSAhPSBvdGhlci5zaXplICYmICFpc1BhcnRpYWwpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgLy8gQXNzdW1lIGN5Y2xpYyB2YWx1ZXMgYXJlIGVxdWFsLlxuICAgICAgdmFyIHN0YWNrZWQgPSBzdGFjay5nZXQob2JqZWN0KTtcbiAgICAgIGlmIChzdGFja2VkKSB7XG4gICAgICAgIHJldHVybiBzdGFja2VkID09IG90aGVyO1xuICAgICAgfVxuICAgICAgYml0bWFzayB8PSBDT01QQVJFX1VOT1JERVJFRF9GTEFHO1xuXG4gICAgICAvLyBSZWN1cnNpdmVseSBjb21wYXJlIG9iamVjdHMgKHN1c2NlcHRpYmxlIHRvIGNhbGwgc3RhY2sgbGltaXRzKS5cbiAgICAgIHN0YWNrLnNldChvYmplY3QsIG90aGVyKTtcbiAgICAgIHZhciByZXN1bHQgPSBlcXVhbEFycmF5cyhjb252ZXJ0KG9iamVjdCksIGNvbnZlcnQob3RoZXIpLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKTtcbiAgICAgIHN0YWNrWydkZWxldGUnXShvYmplY3QpO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcblxuICAgIGNhc2Ugc3ltYm9sVGFnOlxuICAgICAgaWYgKHN5bWJvbFZhbHVlT2YpIHtcbiAgICAgICAgcmV0dXJuIHN5bWJvbFZhbHVlT2YuY2FsbChvYmplY3QpID09IHN5bWJvbFZhbHVlT2YuY2FsbChvdGhlcik7XG4gICAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGVxdWFsQnlUYWc7XG4iLCJ2YXIgZ2V0QWxsS2V5cyA9IHJlcXVpcmUoJy4vX2dldEFsbEtleXMnKTtcblxuLyoqIFVzZWQgdG8gY29tcG9zZSBiaXRtYXNrcyBmb3IgdmFsdWUgY29tcGFyaXNvbnMuICovXG52YXIgQ09NUEFSRV9QQVJUSUFMX0ZMQUcgPSAxO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZUlzRXF1YWxEZWVwYCBmb3Igb2JqZWN0cyB3aXRoIHN1cHBvcnQgZm9yXG4gKiBwYXJ0aWFsIGRlZXAgY29tcGFyaXNvbnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBjb21wYXJlLlxuICogQHBhcmFtIHtPYmplY3R9IG90aGVyIFRoZSBvdGhlciBvYmplY3QgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBiaXRtYXNrIFRoZSBiaXRtYXNrIGZsYWdzLiBTZWUgYGJhc2VJc0VxdWFsYCBmb3IgbW9yZSBkZXRhaWxzLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY3VzdG9taXplciBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmlzb25zLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZXF1YWxGdW5jIFRoZSBmdW5jdGlvbiB0byBkZXRlcm1pbmUgZXF1aXZhbGVudHMgb2YgdmFsdWVzLlxuICogQHBhcmFtIHtPYmplY3R9IHN0YWNrIFRyYWNrcyB0cmF2ZXJzZWQgYG9iamVjdGAgYW5kIGBvdGhlcmAgb2JqZWN0cy5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgb2JqZWN0cyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBlcXVhbE9iamVjdHMob2JqZWN0LCBvdGhlciwgYml0bWFzaywgY3VzdG9taXplciwgZXF1YWxGdW5jLCBzdGFjaykge1xuICB2YXIgaXNQYXJ0aWFsID0gYml0bWFzayAmIENPTVBBUkVfUEFSVElBTF9GTEFHLFxuICAgICAgb2JqUHJvcHMgPSBnZXRBbGxLZXlzKG9iamVjdCksXG4gICAgICBvYmpMZW5ndGggPSBvYmpQcm9wcy5sZW5ndGgsXG4gICAgICBvdGhQcm9wcyA9IGdldEFsbEtleXMob3RoZXIpLFxuICAgICAgb3RoTGVuZ3RoID0gb3RoUHJvcHMubGVuZ3RoO1xuXG4gIGlmIChvYmpMZW5ndGggIT0gb3RoTGVuZ3RoICYmICFpc1BhcnRpYWwpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIGluZGV4ID0gb2JqTGVuZ3RoO1xuICB3aGlsZSAoaW5kZXgtLSkge1xuICAgIHZhciBrZXkgPSBvYmpQcm9wc1tpbmRleF07XG4gICAgaWYgKCEoaXNQYXJ0aWFsID8ga2V5IGluIG90aGVyIDogaGFzT3duUHJvcGVydHkuY2FsbChvdGhlciwga2V5KSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgLy8gQ2hlY2sgdGhhdCBjeWNsaWMgdmFsdWVzIGFyZSBlcXVhbC5cbiAgdmFyIG9ialN0YWNrZWQgPSBzdGFjay5nZXQob2JqZWN0KTtcbiAgdmFyIG90aFN0YWNrZWQgPSBzdGFjay5nZXQob3RoZXIpO1xuICBpZiAob2JqU3RhY2tlZCAmJiBvdGhTdGFja2VkKSB7XG4gICAgcmV0dXJuIG9ialN0YWNrZWQgPT0gb3RoZXIgJiYgb3RoU3RhY2tlZCA9PSBvYmplY3Q7XG4gIH1cbiAgdmFyIHJlc3VsdCA9IHRydWU7XG4gIHN0YWNrLnNldChvYmplY3QsIG90aGVyKTtcbiAgc3RhY2suc2V0KG90aGVyLCBvYmplY3QpO1xuXG4gIHZhciBza2lwQ3RvciA9IGlzUGFydGlhbDtcbiAgd2hpbGUgKCsraW5kZXggPCBvYmpMZW5ndGgpIHtcbiAgICBrZXkgPSBvYmpQcm9wc1tpbmRleF07XG4gICAgdmFyIG9ialZhbHVlID0gb2JqZWN0W2tleV0sXG4gICAgICAgIG90aFZhbHVlID0gb3RoZXJba2V5XTtcblxuICAgIGlmIChjdXN0b21pemVyKSB7XG4gICAgICB2YXIgY29tcGFyZWQgPSBpc1BhcnRpYWxcbiAgICAgICAgPyBjdXN0b21pemVyKG90aFZhbHVlLCBvYmpWYWx1ZSwga2V5LCBvdGhlciwgb2JqZWN0LCBzdGFjaylcbiAgICAgICAgOiBjdXN0b21pemVyKG9ialZhbHVlLCBvdGhWYWx1ZSwga2V5LCBvYmplY3QsIG90aGVyLCBzdGFjayk7XG4gICAgfVxuICAgIC8vIFJlY3Vyc2l2ZWx5IGNvbXBhcmUgb2JqZWN0cyAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpLlxuICAgIGlmICghKGNvbXBhcmVkID09PSB1bmRlZmluZWRcbiAgICAgICAgICA/IChvYmpWYWx1ZSA9PT0gb3RoVmFsdWUgfHwgZXF1YWxGdW5jKG9ialZhbHVlLCBvdGhWYWx1ZSwgYml0bWFzaywgY3VzdG9taXplciwgc3RhY2spKVxuICAgICAgICAgIDogY29tcGFyZWRcbiAgICAgICAgKSkge1xuICAgICAgcmVzdWx0ID0gZmFsc2U7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgc2tpcEN0b3IgfHwgKHNraXBDdG9yID0ga2V5ID09ICdjb25zdHJ1Y3RvcicpO1xuICB9XG4gIGlmIChyZXN1bHQgJiYgIXNraXBDdG9yKSB7XG4gICAgdmFyIG9iakN0b3IgPSBvYmplY3QuY29uc3RydWN0b3IsXG4gICAgICAgIG90aEN0b3IgPSBvdGhlci5jb25zdHJ1Y3RvcjtcblxuICAgIC8vIE5vbiBgT2JqZWN0YCBvYmplY3QgaW5zdGFuY2VzIHdpdGggZGlmZmVyZW50IGNvbnN0cnVjdG9ycyBhcmUgbm90IGVxdWFsLlxuICAgIGlmIChvYmpDdG9yICE9IG90aEN0b3IgJiZcbiAgICAgICAgKCdjb25zdHJ1Y3RvcicgaW4gb2JqZWN0ICYmICdjb25zdHJ1Y3RvcicgaW4gb3RoZXIpICYmXG4gICAgICAgICEodHlwZW9mIG9iakN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiBvYmpDdG9yIGluc3RhbmNlb2Ygb2JqQ3RvciAmJlxuICAgICAgICAgIHR5cGVvZiBvdGhDdG9yID09ICdmdW5jdGlvbicgJiYgb3RoQ3RvciBpbnN0YW5jZW9mIG90aEN0b3IpKSB7XG4gICAgICByZXN1bHQgPSBmYWxzZTtcbiAgICB9XG4gIH1cbiAgc3RhY2tbJ2RlbGV0ZSddKG9iamVjdCk7XG4gIHN0YWNrWydkZWxldGUnXShvdGhlcik7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZXF1YWxPYmplY3RzO1xuIiwidmFyIGZsYXR0ZW4gPSByZXF1aXJlKCcuL2ZsYXR0ZW4nKSxcbiAgICBvdmVyUmVzdCA9IHJlcXVpcmUoJy4vX292ZXJSZXN0JyksXG4gICAgc2V0VG9TdHJpbmcgPSByZXF1aXJlKCcuL19zZXRUb1N0cmluZycpO1xuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZVJlc3RgIHdoaWNoIGZsYXR0ZW5zIHRoZSByZXN0IGFycmF5LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBhcHBseSBhIHJlc3QgcGFyYW1ldGVyIHRvLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGZsYXRSZXN0KGZ1bmMpIHtcbiAgcmV0dXJuIHNldFRvU3RyaW5nKG92ZXJSZXN0KGZ1bmMsIHVuZGVmaW5lZCwgZmxhdHRlbiksIGZ1bmMgKyAnJyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZmxhdFJlc3Q7XG4iLCIvKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGdsb2JhbGAgZnJvbSBOb2RlLmpzLiAqL1xudmFyIGZyZWVHbG9iYWwgPSB0eXBlb2YgZ2xvYmFsID09ICdvYmplY3QnICYmIGdsb2JhbCAmJiBnbG9iYWwuT2JqZWN0ID09PSBPYmplY3QgJiYgZ2xvYmFsO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZyZWVHbG9iYWw7XG4iLCJ2YXIgYmFzZUdldEFsbEtleXMgPSByZXF1aXJlKCcuL19iYXNlR2V0QWxsS2V5cycpLFxuICAgIGdldFN5bWJvbHMgPSByZXF1aXJlKCcuL19nZXRTeW1ib2xzJyksXG4gICAga2V5cyA9IHJlcXVpcmUoJy4va2V5cycpO1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2Ygb3duIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgYW5kIHN5bWJvbHMgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMgYW5kIHN5bWJvbHMuXG4gKi9cbmZ1bmN0aW9uIGdldEFsbEtleXMob2JqZWN0KSB7XG4gIHJldHVybiBiYXNlR2V0QWxsS2V5cyhvYmplY3QsIGtleXMsIGdldFN5bWJvbHMpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldEFsbEtleXM7XG4iLCJ2YXIgYmFzZUdldEFsbEtleXMgPSByZXF1aXJlKCcuL19iYXNlR2V0QWxsS2V5cycpLFxuICAgIGdldFN5bWJvbHNJbiA9IHJlcXVpcmUoJy4vX2dldFN5bWJvbHNJbicpLFxuICAgIGtleXNJbiA9IHJlcXVpcmUoJy4va2V5c0luJyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiBvd24gYW5kIGluaGVyaXRlZCBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIGFuZFxuICogc3ltYm9scyBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcyBhbmQgc3ltYm9scy5cbiAqL1xuZnVuY3Rpb24gZ2V0QWxsS2V5c0luKG9iamVjdCkge1xuICByZXR1cm4gYmFzZUdldEFsbEtleXMob2JqZWN0LCBrZXlzSW4sIGdldFN5bWJvbHNJbik7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0QWxsS2V5c0luO1xuIiwidmFyIGlzS2V5YWJsZSA9IHJlcXVpcmUoJy4vX2lzS2V5YWJsZScpO1xuXG4vKipcbiAqIEdldHMgdGhlIGRhdGEgZm9yIGBtYXBgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gbWFwIFRoZSBtYXAgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSByZWZlcmVuY2Uga2V5LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIG1hcCBkYXRhLlxuICovXG5mdW5jdGlvbiBnZXRNYXBEYXRhKG1hcCwga2V5KSB7XG4gIHZhciBkYXRhID0gbWFwLl9fZGF0YV9fO1xuICByZXR1cm4gaXNLZXlhYmxlKGtleSlcbiAgICA/IGRhdGFbdHlwZW9mIGtleSA9PSAnc3RyaW5nJyA/ICdzdHJpbmcnIDogJ2hhc2gnXVxuICAgIDogZGF0YS5tYXA7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0TWFwRGF0YTtcbiIsInZhciBpc1N0cmljdENvbXBhcmFibGUgPSByZXF1aXJlKCcuL19pc1N0cmljdENvbXBhcmFibGUnKSxcbiAgICBrZXlzID0gcmVxdWlyZSgnLi9rZXlzJyk7XG5cbi8qKlxuICogR2V0cyB0aGUgcHJvcGVydHkgbmFtZXMsIHZhbHVlcywgYW5kIGNvbXBhcmUgZmxhZ3Mgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbWF0Y2ggZGF0YSBvZiBgb2JqZWN0YC5cbiAqL1xuZnVuY3Rpb24gZ2V0TWF0Y2hEYXRhKG9iamVjdCkge1xuICB2YXIgcmVzdWx0ID0ga2V5cyhvYmplY3QpLFxuICAgICAgbGVuZ3RoID0gcmVzdWx0Lmxlbmd0aDtcblxuICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICB2YXIga2V5ID0gcmVzdWx0W2xlbmd0aF0sXG4gICAgICAgIHZhbHVlID0gb2JqZWN0W2tleV07XG5cbiAgICByZXN1bHRbbGVuZ3RoXSA9IFtrZXksIHZhbHVlLCBpc1N0cmljdENvbXBhcmFibGUodmFsdWUpXTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldE1hdGNoRGF0YTtcbiIsInZhciBiYXNlSXNOYXRpdmUgPSByZXF1aXJlKCcuL19iYXNlSXNOYXRpdmUnKSxcbiAgICBnZXRWYWx1ZSA9IHJlcXVpcmUoJy4vX2dldFZhbHVlJyk7XG5cbi8qKlxuICogR2V0cyB0aGUgbmF0aXZlIGZ1bmN0aW9uIGF0IGBrZXlgIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIG1ldGhvZCB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZnVuY3Rpb24gaWYgaXQncyBuYXRpdmUsIGVsc2UgYHVuZGVmaW5lZGAuXG4gKi9cbmZ1bmN0aW9uIGdldE5hdGl2ZShvYmplY3QsIGtleSkge1xuICB2YXIgdmFsdWUgPSBnZXRWYWx1ZShvYmplY3QsIGtleSk7XG4gIHJldHVybiBiYXNlSXNOYXRpdmUodmFsdWUpID8gdmFsdWUgOiB1bmRlZmluZWQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0TmF0aXZlO1xuIiwidmFyIG92ZXJBcmcgPSByZXF1aXJlKCcuL19vdmVyQXJnJyk7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIGdldFByb3RvdHlwZSA9IG92ZXJBcmcoT2JqZWN0LmdldFByb3RvdHlwZU9mLCBPYmplY3QpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGdldFByb3RvdHlwZTtcbiIsInZhciBTeW1ib2wgPSByZXF1aXJlKCcuL19TeW1ib2wnKTtcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBVc2VkIHRvIHJlc29sdmUgdGhlXG4gKiBbYHRvU3RyaW5nVGFnYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtb2JqZWN0LnByb3RvdHlwZS50b3N0cmluZylcbiAqIG9mIHZhbHVlcy5cbiAqL1xudmFyIG5hdGl2ZU9iamVjdFRvU3RyaW5nID0gb2JqZWN0UHJvdG8udG9TdHJpbmc7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIHN5bVRvU3RyaW5nVGFnID0gU3ltYm9sID8gU3ltYm9sLnRvU3RyaW5nVGFnIDogdW5kZWZpbmVkO1xuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZUdldFRhZ2Agd2hpY2ggaWdub3JlcyBgU3ltYm9sLnRvU3RyaW5nVGFnYCB2YWx1ZXMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHF1ZXJ5LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgcmF3IGB0b1N0cmluZ1RhZ2AuXG4gKi9cbmZ1bmN0aW9uIGdldFJhd1RhZyh2YWx1ZSkge1xuICB2YXIgaXNPd24gPSBoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCBzeW1Ub1N0cmluZ1RhZyksXG4gICAgICB0YWcgPSB2YWx1ZVtzeW1Ub1N0cmluZ1RhZ107XG5cbiAgdHJ5IHtcbiAgICB2YWx1ZVtzeW1Ub1N0cmluZ1RhZ10gPSB1bmRlZmluZWQ7XG4gICAgdmFyIHVubWFza2VkID0gdHJ1ZTtcbiAgfSBjYXRjaCAoZSkge31cblxuICB2YXIgcmVzdWx0ID0gbmF0aXZlT2JqZWN0VG9TdHJpbmcuY2FsbCh2YWx1ZSk7XG4gIGlmICh1bm1hc2tlZCkge1xuICAgIGlmIChpc093bikge1xuICAgICAgdmFsdWVbc3ltVG9TdHJpbmdUYWddID0gdGFnO1xuICAgIH0gZWxzZSB7XG4gICAgICBkZWxldGUgdmFsdWVbc3ltVG9TdHJpbmdUYWddO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldFJhd1RhZztcbiIsInZhciBhcnJheUZpbHRlciA9IHJlcXVpcmUoJy4vX2FycmF5RmlsdGVyJyksXG4gICAgc3R1YkFycmF5ID0gcmVxdWlyZSgnLi9zdHViQXJyYXknKTtcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgcHJvcGVydHlJc0VudW1lcmFibGUgPSBvYmplY3RQcm90by5wcm9wZXJ0eUlzRW51bWVyYWJsZTtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgZm9yIHRob3NlIHdpdGggdGhlIHNhbWUgbmFtZSBhcyBvdGhlciBgbG9kYXNoYCBtZXRob2RzLiAqL1xudmFyIG5hdGl2ZUdldFN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzO1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIG93biBlbnVtZXJhYmxlIHN5bWJvbHMgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2Ygc3ltYm9scy5cbiAqL1xudmFyIGdldFN5bWJvbHMgPSAhbmF0aXZlR2V0U3ltYm9scyA/IHN0dWJBcnJheSA6IGZ1bmN0aW9uKG9iamVjdCkge1xuICBpZiAob2JqZWN0ID09IG51bGwpIHtcbiAgICByZXR1cm4gW107XG4gIH1cbiAgb2JqZWN0ID0gT2JqZWN0KG9iamVjdCk7XG4gIHJldHVybiBhcnJheUZpbHRlcihuYXRpdmVHZXRTeW1ib2xzKG9iamVjdCksIGZ1bmN0aW9uKHN5bWJvbCkge1xuICAgIHJldHVybiBwcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKG9iamVjdCwgc3ltYm9sKTtcbiAgfSk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGdldFN5bWJvbHM7XG4iLCJ2YXIgYXJyYXlQdXNoID0gcmVxdWlyZSgnLi9fYXJyYXlQdXNoJyksXG4gICAgZ2V0UHJvdG90eXBlID0gcmVxdWlyZSgnLi9fZ2V0UHJvdG90eXBlJyksXG4gICAgZ2V0U3ltYm9scyA9IHJlcXVpcmUoJy4vX2dldFN5bWJvbHMnKSxcbiAgICBzdHViQXJyYXkgPSByZXF1aXJlKCcuL3N0dWJBcnJheScpO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyBmb3IgdGhvc2Ugd2l0aCB0aGUgc2FtZSBuYW1lIGFzIG90aGVyIGBsb2Rhc2hgIG1ldGhvZHMuICovXG52YXIgbmF0aXZlR2V0U3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHM7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiB0aGUgb3duIGFuZCBpbmhlcml0ZWQgZW51bWVyYWJsZSBzeW1ib2xzIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHN5bWJvbHMuXG4gKi9cbnZhciBnZXRTeW1ib2xzSW4gPSAhbmF0aXZlR2V0U3ltYm9scyA/IHN0dWJBcnJheSA6IGZ1bmN0aW9uKG9iamVjdCkge1xuICB2YXIgcmVzdWx0ID0gW107XG4gIHdoaWxlIChvYmplY3QpIHtcbiAgICBhcnJheVB1c2gocmVzdWx0LCBnZXRTeW1ib2xzKG9iamVjdCkpO1xuICAgIG9iamVjdCA9IGdldFByb3RvdHlwZShvYmplY3QpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGdldFN5bWJvbHNJbjtcbiIsInZhciBEYXRhVmlldyA9IHJlcXVpcmUoJy4vX0RhdGFWaWV3JyksXG4gICAgTWFwID0gcmVxdWlyZSgnLi9fTWFwJyksXG4gICAgUHJvbWlzZSA9IHJlcXVpcmUoJy4vX1Byb21pc2UnKSxcbiAgICBTZXQgPSByZXF1aXJlKCcuL19TZXQnKSxcbiAgICBXZWFrTWFwID0gcmVxdWlyZSgnLi9fV2Vha01hcCcpLFxuICAgIGJhc2VHZXRUYWcgPSByZXF1aXJlKCcuL19iYXNlR2V0VGFnJyksXG4gICAgdG9Tb3VyY2UgPSByZXF1aXJlKCcuL190b1NvdXJjZScpO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgbWFwVGFnID0gJ1tvYmplY3QgTWFwXScsXG4gICAgb2JqZWN0VGFnID0gJ1tvYmplY3QgT2JqZWN0XScsXG4gICAgcHJvbWlzZVRhZyA9ICdbb2JqZWN0IFByb21pc2VdJyxcbiAgICBzZXRUYWcgPSAnW29iamVjdCBTZXRdJyxcbiAgICB3ZWFrTWFwVGFnID0gJ1tvYmplY3QgV2Vha01hcF0nO1xuXG52YXIgZGF0YVZpZXdUYWcgPSAnW29iamVjdCBEYXRhVmlld10nO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgbWFwcywgc2V0cywgYW5kIHdlYWttYXBzLiAqL1xudmFyIGRhdGFWaWV3Q3RvclN0cmluZyA9IHRvU291cmNlKERhdGFWaWV3KSxcbiAgICBtYXBDdG9yU3RyaW5nID0gdG9Tb3VyY2UoTWFwKSxcbiAgICBwcm9taXNlQ3RvclN0cmluZyA9IHRvU291cmNlKFByb21pc2UpLFxuICAgIHNldEN0b3JTdHJpbmcgPSB0b1NvdXJjZShTZXQpLFxuICAgIHdlYWtNYXBDdG9yU3RyaW5nID0gdG9Tb3VyY2UoV2Vha01hcCk7XG5cbi8qKlxuICogR2V0cyB0aGUgYHRvU3RyaW5nVGFnYCBvZiBgdmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGB0b1N0cmluZ1RhZ2AuXG4gKi9cbnZhciBnZXRUYWcgPSBiYXNlR2V0VGFnO1xuXG4vLyBGYWxsYmFjayBmb3IgZGF0YSB2aWV3cywgbWFwcywgc2V0cywgYW5kIHdlYWsgbWFwcyBpbiBJRSAxMSBhbmQgcHJvbWlzZXMgaW4gTm9kZS5qcyA8IDYuXG5pZiAoKERhdGFWaWV3ICYmIGdldFRhZyhuZXcgRGF0YVZpZXcobmV3IEFycmF5QnVmZmVyKDEpKSkgIT0gZGF0YVZpZXdUYWcpIHx8XG4gICAgKE1hcCAmJiBnZXRUYWcobmV3IE1hcCkgIT0gbWFwVGFnKSB8fFxuICAgIChQcm9taXNlICYmIGdldFRhZyhQcm9taXNlLnJlc29sdmUoKSkgIT0gcHJvbWlzZVRhZykgfHxcbiAgICAoU2V0ICYmIGdldFRhZyhuZXcgU2V0KSAhPSBzZXRUYWcpIHx8XG4gICAgKFdlYWtNYXAgJiYgZ2V0VGFnKG5ldyBXZWFrTWFwKSAhPSB3ZWFrTWFwVGFnKSkge1xuICBnZXRUYWcgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgIHZhciByZXN1bHQgPSBiYXNlR2V0VGFnKHZhbHVlKSxcbiAgICAgICAgQ3RvciA9IHJlc3VsdCA9PSBvYmplY3RUYWcgPyB2YWx1ZS5jb25zdHJ1Y3RvciA6IHVuZGVmaW5lZCxcbiAgICAgICAgY3RvclN0cmluZyA9IEN0b3IgPyB0b1NvdXJjZShDdG9yKSA6ICcnO1xuXG4gICAgaWYgKGN0b3JTdHJpbmcpIHtcbiAgICAgIHN3aXRjaCAoY3RvclN0cmluZykge1xuICAgICAgICBjYXNlIGRhdGFWaWV3Q3RvclN0cmluZzogcmV0dXJuIGRhdGFWaWV3VGFnO1xuICAgICAgICBjYXNlIG1hcEN0b3JTdHJpbmc6IHJldHVybiBtYXBUYWc7XG4gICAgICAgIGNhc2UgcHJvbWlzZUN0b3JTdHJpbmc6IHJldHVybiBwcm9taXNlVGFnO1xuICAgICAgICBjYXNlIHNldEN0b3JTdHJpbmc6IHJldHVybiBzZXRUYWc7XG4gICAgICAgIGNhc2Ugd2Vha01hcEN0b3JTdHJpbmc6IHJldHVybiB3ZWFrTWFwVGFnO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldFRhZztcbiIsIi8qKlxuICogR2V0cyB0aGUgdmFsdWUgYXQgYGtleWAgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0XSBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcHJvcGVydHkgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGdldFZhbHVlKG9iamVjdCwga2V5KSB7XG4gIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IG9iamVjdFtrZXldO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldFZhbHVlO1xuIiwidmFyIGNhc3RQYXRoID0gcmVxdWlyZSgnLi9fY2FzdFBhdGgnKSxcbiAgICBpc0FyZ3VtZW50cyA9IHJlcXVpcmUoJy4vaXNBcmd1bWVudHMnKSxcbiAgICBpc0FycmF5ID0gcmVxdWlyZSgnLi9pc0FycmF5JyksXG4gICAgaXNJbmRleCA9IHJlcXVpcmUoJy4vX2lzSW5kZXgnKSxcbiAgICBpc0xlbmd0aCA9IHJlcXVpcmUoJy4vaXNMZW5ndGgnKSxcbiAgICB0b0tleSA9IHJlcXVpcmUoJy4vX3RvS2V5Jyk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGBwYXRoYCBleGlzdHMgb24gYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIHRvIGNoZWNrLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaGFzRnVuYyBUaGUgZnVuY3Rpb24gdG8gY2hlY2sgcHJvcGVydGllcy5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgcGF0aGAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGhhc1BhdGgob2JqZWN0LCBwYXRoLCBoYXNGdW5jKSB7XG4gIHBhdGggPSBjYXN0UGF0aChwYXRoLCBvYmplY3QpO1xuXG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gcGF0aC5sZW5ndGgsXG4gICAgICByZXN1bHQgPSBmYWxzZTtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciBrZXkgPSB0b0tleShwYXRoW2luZGV4XSk7XG4gICAgaWYgKCEocmVzdWx0ID0gb2JqZWN0ICE9IG51bGwgJiYgaGFzRnVuYyhvYmplY3QsIGtleSkpKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgb2JqZWN0ID0gb2JqZWN0W2tleV07XG4gIH1cbiAgaWYgKHJlc3VsdCB8fCArK2luZGV4ICE9IGxlbmd0aCkge1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgbGVuZ3RoID0gb2JqZWN0ID09IG51bGwgPyAwIDogb2JqZWN0Lmxlbmd0aDtcbiAgcmV0dXJuICEhbGVuZ3RoICYmIGlzTGVuZ3RoKGxlbmd0aCkgJiYgaXNJbmRleChrZXksIGxlbmd0aCkgJiZcbiAgICAoaXNBcnJheShvYmplY3QpIHx8IGlzQXJndW1lbnRzKG9iamVjdCkpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGhhc1BhdGg7XG4iLCIvKiogVXNlZCB0byBjb21wb3NlIHVuaWNvZGUgY2hhcmFjdGVyIGNsYXNzZXMuICovXG52YXIgcnNBc3RyYWxSYW5nZSA9ICdcXFxcdWQ4MDAtXFxcXHVkZmZmJyxcbiAgICByc0NvbWJvTWFya3NSYW5nZSA9ICdcXFxcdTAzMDAtXFxcXHUwMzZmJyxcbiAgICByZUNvbWJvSGFsZk1hcmtzUmFuZ2UgPSAnXFxcXHVmZTIwLVxcXFx1ZmUyZicsXG4gICAgcnNDb21ib1N5bWJvbHNSYW5nZSA9ICdcXFxcdTIwZDAtXFxcXHUyMGZmJyxcbiAgICByc0NvbWJvUmFuZ2UgPSByc0NvbWJvTWFya3NSYW5nZSArIHJlQ29tYm9IYWxmTWFya3NSYW5nZSArIHJzQ29tYm9TeW1ib2xzUmFuZ2UsXG4gICAgcnNWYXJSYW5nZSA9ICdcXFxcdWZlMGVcXFxcdWZlMGYnO1xuXG4vKiogVXNlZCB0byBjb21wb3NlIHVuaWNvZGUgY2FwdHVyZSBncm91cHMuICovXG52YXIgcnNaV0ogPSAnXFxcXHUyMDBkJztcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IHN0cmluZ3Mgd2l0aCBbemVyby13aWR0aCBqb2luZXJzIG9yIGNvZGUgcG9pbnRzIGZyb20gdGhlIGFzdHJhbCBwbGFuZXNdKGh0dHA6Ly9lZXYuZWUvYmxvZy8yMDE1LzA5LzEyL2RhcmstY29ybmVycy1vZi11bmljb2RlLykuICovXG52YXIgcmVIYXNVbmljb2RlID0gUmVnRXhwKCdbJyArIHJzWldKICsgcnNBc3RyYWxSYW5nZSAgKyByc0NvbWJvUmFuZ2UgKyByc1ZhclJhbmdlICsgJ10nKTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHN0cmluZ2AgY29udGFpbnMgVW5pY29kZSBzeW1ib2xzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIFRoZSBzdHJpbmcgdG8gaW5zcGVjdC5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhIHN5bWJvbCBpcyBmb3VuZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBoYXNVbmljb2RlKHN0cmluZykge1xuICByZXR1cm4gcmVIYXNVbmljb2RlLnRlc3Qoc3RyaW5nKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBoYXNVbmljb2RlO1xuIiwidmFyIG5hdGl2ZUNyZWF0ZSA9IHJlcXVpcmUoJy4vX25hdGl2ZUNyZWF0ZScpO1xuXG4vKipcbiAqIFJlbW92ZXMgYWxsIGtleS12YWx1ZSBlbnRyaWVzIGZyb20gdGhlIGhhc2guXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGNsZWFyXG4gKiBAbWVtYmVyT2YgSGFzaFxuICovXG5mdW5jdGlvbiBoYXNoQ2xlYXIoKSB7XG4gIHRoaXMuX19kYXRhX18gPSBuYXRpdmVDcmVhdGUgPyBuYXRpdmVDcmVhdGUobnVsbCkgOiB7fTtcbiAgdGhpcy5zaXplID0gMDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBoYXNoQ2xlYXI7XG4iLCIvKipcbiAqIFJlbW92ZXMgYGtleWAgYW5kIGl0cyB2YWx1ZSBmcm9tIHRoZSBoYXNoLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBkZWxldGVcbiAqIEBtZW1iZXJPZiBIYXNoXG4gKiBAcGFyYW0ge09iamVjdH0gaGFzaCBUaGUgaGFzaCB0byBtb2RpZnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHJlbW92ZS5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZW50cnkgd2FzIHJlbW92ZWQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaGFzaERlbGV0ZShrZXkpIHtcbiAgdmFyIHJlc3VsdCA9IHRoaXMuaGFzKGtleSkgJiYgZGVsZXRlIHRoaXMuX19kYXRhX19ba2V5XTtcbiAgdGhpcy5zaXplIC09IHJlc3VsdCA/IDEgOiAwO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGhhc2hEZWxldGU7XG4iLCJ2YXIgbmF0aXZlQ3JlYXRlID0gcmVxdWlyZSgnLi9fbmF0aXZlQ3JlYXRlJyk7XG5cbi8qKiBVc2VkIHRvIHN0YW5kLWluIGZvciBgdW5kZWZpbmVkYCBoYXNoIHZhbHVlcy4gKi9cbnZhciBIQVNIX1VOREVGSU5FRCA9ICdfX2xvZGFzaF9oYXNoX3VuZGVmaW5lZF9fJztcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBHZXRzIHRoZSBoYXNoIHZhbHVlIGZvciBga2V5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZ2V0XG4gKiBAbWVtYmVyT2YgSGFzaFxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZW50cnkgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGhhc2hHZXQoa2V5KSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXztcbiAgaWYgKG5hdGl2ZUNyZWF0ZSkge1xuICAgIHZhciByZXN1bHQgPSBkYXRhW2tleV07XG4gICAgcmV0dXJuIHJlc3VsdCA9PT0gSEFTSF9VTkRFRklORUQgPyB1bmRlZmluZWQgOiByZXN1bHQ7XG4gIH1cbiAgcmV0dXJuIGhhc093blByb3BlcnR5LmNhbGwoZGF0YSwga2V5KSA/IGRhdGFba2V5XSA6IHVuZGVmaW5lZDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBoYXNoR2V0O1xuIiwidmFyIG5hdGl2ZUNyZWF0ZSA9IHJlcXVpcmUoJy4vX25hdGl2ZUNyZWF0ZScpO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIENoZWNrcyBpZiBhIGhhc2ggdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgaGFzXG4gKiBAbWVtYmVyT2YgSGFzaFxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlbnRyeSBmb3IgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGhhc2hIYXMoa2V5KSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXztcbiAgcmV0dXJuIG5hdGl2ZUNyZWF0ZSA/IChkYXRhW2tleV0gIT09IHVuZGVmaW5lZCkgOiBoYXNPd25Qcm9wZXJ0eS5jYWxsKGRhdGEsIGtleSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaGFzaEhhcztcbiIsInZhciBuYXRpdmVDcmVhdGUgPSByZXF1aXJlKCcuL19uYXRpdmVDcmVhdGUnKTtcblxuLyoqIFVzZWQgdG8gc3RhbmQtaW4gZm9yIGB1bmRlZmluZWRgIGhhc2ggdmFsdWVzLiAqL1xudmFyIEhBU0hfVU5ERUZJTkVEID0gJ19fbG9kYXNoX2hhc2hfdW5kZWZpbmVkX18nO1xuXG4vKipcbiAqIFNldHMgdGhlIGhhc2ggYGtleWAgdG8gYHZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgc2V0XG4gKiBAbWVtYmVyT2YgSGFzaFxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBoYXNoIGluc3RhbmNlLlxuICovXG5mdW5jdGlvbiBoYXNoU2V0KGtleSwgdmFsdWUpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fO1xuICB0aGlzLnNpemUgKz0gdGhpcy5oYXMoa2V5KSA/IDAgOiAxO1xuICBkYXRhW2tleV0gPSAobmF0aXZlQ3JlYXRlICYmIHZhbHVlID09PSB1bmRlZmluZWQpID8gSEFTSF9VTkRFRklORUQgOiB2YWx1ZTtcbiAgcmV0dXJuIHRoaXM7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaGFzaFNldDtcbiIsIi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogSW5pdGlhbGl6ZXMgYW4gYXJyYXkgY2xvbmUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBjbG9uZS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgaW5pdGlhbGl6ZWQgY2xvbmUuXG4gKi9cbmZ1bmN0aW9uIGluaXRDbG9uZUFycmF5KGFycmF5KSB7XG4gIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGgsXG4gICAgICByZXN1bHQgPSBuZXcgYXJyYXkuY29uc3RydWN0b3IobGVuZ3RoKTtcblxuICAvLyBBZGQgcHJvcGVydGllcyBhc3NpZ25lZCBieSBgUmVnRXhwI2V4ZWNgLlxuICBpZiAobGVuZ3RoICYmIHR5cGVvZiBhcnJheVswXSA9PSAnc3RyaW5nJyAmJiBoYXNPd25Qcm9wZXJ0eS5jYWxsKGFycmF5LCAnaW5kZXgnKSkge1xuICAgIHJlc3VsdC5pbmRleCA9IGFycmF5LmluZGV4O1xuICAgIHJlc3VsdC5pbnB1dCA9IGFycmF5LmlucHV0O1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaW5pdENsb25lQXJyYXk7XG4iLCJ2YXIgY2xvbmVBcnJheUJ1ZmZlciA9IHJlcXVpcmUoJy4vX2Nsb25lQXJyYXlCdWZmZXInKSxcbiAgICBjbG9uZURhdGFWaWV3ID0gcmVxdWlyZSgnLi9fY2xvbmVEYXRhVmlldycpLFxuICAgIGNsb25lUmVnRXhwID0gcmVxdWlyZSgnLi9fY2xvbmVSZWdFeHAnKSxcbiAgICBjbG9uZVN5bWJvbCA9IHJlcXVpcmUoJy4vX2Nsb25lU3ltYm9sJyksXG4gICAgY2xvbmVUeXBlZEFycmF5ID0gcmVxdWlyZSgnLi9fY2xvbmVUeXBlZEFycmF5Jyk7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBib29sVGFnID0gJ1tvYmplY3QgQm9vbGVhbl0nLFxuICAgIGRhdGVUYWcgPSAnW29iamVjdCBEYXRlXScsXG4gICAgbWFwVGFnID0gJ1tvYmplY3QgTWFwXScsXG4gICAgbnVtYmVyVGFnID0gJ1tvYmplY3QgTnVtYmVyXScsXG4gICAgcmVnZXhwVGFnID0gJ1tvYmplY3QgUmVnRXhwXScsXG4gICAgc2V0VGFnID0gJ1tvYmplY3QgU2V0XScsXG4gICAgc3RyaW5nVGFnID0gJ1tvYmplY3QgU3RyaW5nXScsXG4gICAgc3ltYm9sVGFnID0gJ1tvYmplY3QgU3ltYm9sXSc7XG5cbnZhciBhcnJheUJ1ZmZlclRhZyA9ICdbb2JqZWN0IEFycmF5QnVmZmVyXScsXG4gICAgZGF0YVZpZXdUYWcgPSAnW29iamVjdCBEYXRhVmlld10nLFxuICAgIGZsb2F0MzJUYWcgPSAnW29iamVjdCBGbG9hdDMyQXJyYXldJyxcbiAgICBmbG9hdDY0VGFnID0gJ1tvYmplY3QgRmxvYXQ2NEFycmF5XScsXG4gICAgaW50OFRhZyA9ICdbb2JqZWN0IEludDhBcnJheV0nLFxuICAgIGludDE2VGFnID0gJ1tvYmplY3QgSW50MTZBcnJheV0nLFxuICAgIGludDMyVGFnID0gJ1tvYmplY3QgSW50MzJBcnJheV0nLFxuICAgIHVpbnQ4VGFnID0gJ1tvYmplY3QgVWludDhBcnJheV0nLFxuICAgIHVpbnQ4Q2xhbXBlZFRhZyA9ICdbb2JqZWN0IFVpbnQ4Q2xhbXBlZEFycmF5XScsXG4gICAgdWludDE2VGFnID0gJ1tvYmplY3QgVWludDE2QXJyYXldJyxcbiAgICB1aW50MzJUYWcgPSAnW29iamVjdCBVaW50MzJBcnJheV0nO1xuXG4vKipcbiAqIEluaXRpYWxpemVzIGFuIG9iamVjdCBjbG9uZSBiYXNlZCBvbiBpdHMgYHRvU3RyaW5nVGFnYC5cbiAqXG4gKiAqKk5vdGU6KiogVGhpcyBmdW5jdGlvbiBvbmx5IHN1cHBvcnRzIGNsb25pbmcgdmFsdWVzIHdpdGggdGFncyBvZlxuICogYEJvb2xlYW5gLCBgRGF0ZWAsIGBFcnJvcmAsIGBNYXBgLCBgTnVtYmVyYCwgYFJlZ0V4cGAsIGBTZXRgLCBvciBgU3RyaW5nYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGNsb25lLlxuICogQHBhcmFtIHtzdHJpbmd9IHRhZyBUaGUgYHRvU3RyaW5nVGFnYCBvZiB0aGUgb2JqZWN0IHRvIGNsb25lLlxuICogQHBhcmFtIHtib29sZWFufSBbaXNEZWVwXSBTcGVjaWZ5IGEgZGVlcCBjbG9uZS5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGluaXRpYWxpemVkIGNsb25lLlxuICovXG5mdW5jdGlvbiBpbml0Q2xvbmVCeVRhZyhvYmplY3QsIHRhZywgaXNEZWVwKSB7XG4gIHZhciBDdG9yID0gb2JqZWN0LmNvbnN0cnVjdG9yO1xuICBzd2l0Y2ggKHRhZykge1xuICAgIGNhc2UgYXJyYXlCdWZmZXJUYWc6XG4gICAgICByZXR1cm4gY2xvbmVBcnJheUJ1ZmZlcihvYmplY3QpO1xuXG4gICAgY2FzZSBib29sVGFnOlxuICAgIGNhc2UgZGF0ZVRhZzpcbiAgICAgIHJldHVybiBuZXcgQ3Rvcigrb2JqZWN0KTtcblxuICAgIGNhc2UgZGF0YVZpZXdUYWc6XG4gICAgICByZXR1cm4gY2xvbmVEYXRhVmlldyhvYmplY3QsIGlzRGVlcCk7XG5cbiAgICBjYXNlIGZsb2F0MzJUYWc6IGNhc2UgZmxvYXQ2NFRhZzpcbiAgICBjYXNlIGludDhUYWc6IGNhc2UgaW50MTZUYWc6IGNhc2UgaW50MzJUYWc6XG4gICAgY2FzZSB1aW50OFRhZzogY2FzZSB1aW50OENsYW1wZWRUYWc6IGNhc2UgdWludDE2VGFnOiBjYXNlIHVpbnQzMlRhZzpcbiAgICAgIHJldHVybiBjbG9uZVR5cGVkQXJyYXkob2JqZWN0LCBpc0RlZXApO1xuXG4gICAgY2FzZSBtYXBUYWc6XG4gICAgICByZXR1cm4gbmV3IEN0b3I7XG5cbiAgICBjYXNlIG51bWJlclRhZzpcbiAgICBjYXNlIHN0cmluZ1RhZzpcbiAgICAgIHJldHVybiBuZXcgQ3RvcihvYmplY3QpO1xuXG4gICAgY2FzZSByZWdleHBUYWc6XG4gICAgICByZXR1cm4gY2xvbmVSZWdFeHAob2JqZWN0KTtcblxuICAgIGNhc2Ugc2V0VGFnOlxuICAgICAgcmV0dXJuIG5ldyBDdG9yO1xuXG4gICAgY2FzZSBzeW1ib2xUYWc6XG4gICAgICByZXR1cm4gY2xvbmVTeW1ib2wob2JqZWN0KTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGluaXRDbG9uZUJ5VGFnO1xuIiwidmFyIGJhc2VDcmVhdGUgPSByZXF1aXJlKCcuL19iYXNlQ3JlYXRlJyksXG4gICAgZ2V0UHJvdG90eXBlID0gcmVxdWlyZSgnLi9fZ2V0UHJvdG90eXBlJyksXG4gICAgaXNQcm90b3R5cGUgPSByZXF1aXJlKCcuL19pc1Byb3RvdHlwZScpO1xuXG4vKipcbiAqIEluaXRpYWxpemVzIGFuIG9iamVjdCBjbG9uZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGNsb25lLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgaW5pdGlhbGl6ZWQgY2xvbmUuXG4gKi9cbmZ1bmN0aW9uIGluaXRDbG9uZU9iamVjdChvYmplY3QpIHtcbiAgcmV0dXJuICh0eXBlb2Ygb2JqZWN0LmNvbnN0cnVjdG9yID09ICdmdW5jdGlvbicgJiYgIWlzUHJvdG90eXBlKG9iamVjdCkpXG4gICAgPyBiYXNlQ3JlYXRlKGdldFByb3RvdHlwZShvYmplY3QpKVxuICAgIDoge307XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaW5pdENsb25lT2JqZWN0O1xuIiwidmFyIFN5bWJvbCA9IHJlcXVpcmUoJy4vX1N5bWJvbCcpLFxuICAgIGlzQXJndW1lbnRzID0gcmVxdWlyZSgnLi9pc0FyZ3VtZW50cycpLFxuICAgIGlzQXJyYXkgPSByZXF1aXJlKCcuL2lzQXJyYXknKTtcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgc3ByZWFkYWJsZVN5bWJvbCA9IFN5bWJvbCA/IFN5bWJvbC5pc0NvbmNhdFNwcmVhZGFibGUgOiB1bmRlZmluZWQ7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSBmbGF0dGVuYWJsZSBgYXJndW1lbnRzYCBvYmplY3Qgb3IgYXJyYXkuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgZmxhdHRlbmFibGUsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNGbGF0dGVuYWJsZSh2YWx1ZSkge1xuICByZXR1cm4gaXNBcnJheSh2YWx1ZSkgfHwgaXNBcmd1bWVudHModmFsdWUpIHx8XG4gICAgISEoc3ByZWFkYWJsZVN5bWJvbCAmJiB2YWx1ZSAmJiB2YWx1ZVtzcHJlYWRhYmxlU3ltYm9sXSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNGbGF0dGVuYWJsZTtcbiIsIi8qKiBVc2VkIGFzIHJlZmVyZW5jZXMgZm9yIHZhcmlvdXMgYE51bWJlcmAgY29uc3RhbnRzLiAqL1xudmFyIE1BWF9TQUZFX0lOVEVHRVIgPSA5MDA3MTk5MjU0NzQwOTkxO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgdW5zaWduZWQgaW50ZWdlciB2YWx1ZXMuICovXG52YXIgcmVJc1VpbnQgPSAvXig/OjB8WzEtOV1cXGQqKSQvO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgYXJyYXktbGlrZSBpbmRleC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcGFyYW0ge251bWJlcn0gW2xlbmd0aD1NQVhfU0FGRV9JTlRFR0VSXSBUaGUgdXBwZXIgYm91bmRzIG9mIGEgdmFsaWQgaW5kZXguXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGluZGV4LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzSW5kZXgodmFsdWUsIGxlbmd0aCkge1xuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgbGVuZ3RoID0gbGVuZ3RoID09IG51bGwgPyBNQVhfU0FGRV9JTlRFR0VSIDogbGVuZ3RoO1xuXG4gIHJldHVybiAhIWxlbmd0aCAmJlxuICAgICh0eXBlID09ICdudW1iZXInIHx8XG4gICAgICAodHlwZSAhPSAnc3ltYm9sJyAmJiByZUlzVWludC50ZXN0KHZhbHVlKSkpICYmXG4gICAgICAgICh2YWx1ZSA+IC0xICYmIHZhbHVlICUgMSA9PSAwICYmIHZhbHVlIDwgbGVuZ3RoKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc0luZGV4O1xuIiwidmFyIGVxID0gcmVxdWlyZSgnLi9lcScpLFxuICAgIGlzQXJyYXlMaWtlID0gcmVxdWlyZSgnLi9pc0FycmF5TGlrZScpLFxuICAgIGlzSW5kZXggPSByZXF1aXJlKCcuL19pc0luZGV4JyksXG4gICAgaXNPYmplY3QgPSByZXF1aXJlKCcuL2lzT2JqZWN0Jyk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIHRoZSBnaXZlbiBhcmd1bWVudHMgYXJlIGZyb20gYW4gaXRlcmF0ZWUgY2FsbC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgcG90ZW50aWFsIGl0ZXJhdGVlIHZhbHVlIGFyZ3VtZW50LlxuICogQHBhcmFtIHsqfSBpbmRleCBUaGUgcG90ZW50aWFsIGl0ZXJhdGVlIGluZGV4IG9yIGtleSBhcmd1bWVudC5cbiAqIEBwYXJhbSB7Kn0gb2JqZWN0IFRoZSBwb3RlbnRpYWwgaXRlcmF0ZWUgb2JqZWN0IGFyZ3VtZW50LlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBhcmd1bWVudHMgYXJlIGZyb20gYW4gaXRlcmF0ZWUgY2FsbCxcbiAqICBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzSXRlcmF0ZWVDYWxsKHZhbHVlLCBpbmRleCwgb2JqZWN0KSB7XG4gIGlmICghaXNPYmplY3Qob2JqZWN0KSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgdHlwZSA9IHR5cGVvZiBpbmRleDtcbiAgaWYgKHR5cGUgPT0gJ251bWJlcidcbiAgICAgICAgPyAoaXNBcnJheUxpa2Uob2JqZWN0KSAmJiBpc0luZGV4KGluZGV4LCBvYmplY3QubGVuZ3RoKSlcbiAgICAgICAgOiAodHlwZSA9PSAnc3RyaW5nJyAmJiBpbmRleCBpbiBvYmplY3QpXG4gICAgICApIHtcbiAgICByZXR1cm4gZXEob2JqZWN0W2luZGV4XSwgdmFsdWUpO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc0l0ZXJhdGVlQ2FsbDtcbiIsInZhciBpc0FycmF5ID0gcmVxdWlyZSgnLi9pc0FycmF5JyksXG4gICAgaXNTeW1ib2wgPSByZXF1aXJlKCcuL2lzU3ltYm9sJyk7XG5cbi8qKiBVc2VkIHRvIG1hdGNoIHByb3BlcnR5IG5hbWVzIHdpdGhpbiBwcm9wZXJ0eSBwYXRocy4gKi9cbnZhciByZUlzRGVlcFByb3AgPSAvXFwufFxcWyg/OlteW1xcXV0qfChbXCInXSkoPzooPyFcXDEpW15cXFxcXXxcXFxcLikqP1xcMSlcXF0vLFxuICAgIHJlSXNQbGFpblByb3AgPSAvXlxcdyokLztcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHByb3BlcnR5IG5hbWUgYW5kIG5vdCBhIHByb3BlcnR5IHBhdGguXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3RdIFRoZSBvYmplY3QgdG8gcXVlcnkga2V5cyBvbi5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgcHJvcGVydHkgbmFtZSwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc0tleSh2YWx1ZSwgb2JqZWN0KSB7XG4gIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgaWYgKHR5cGUgPT0gJ251bWJlcicgfHwgdHlwZSA9PSAnc3ltYm9sJyB8fCB0eXBlID09ICdib29sZWFuJyB8fFxuICAgICAgdmFsdWUgPT0gbnVsbCB8fCBpc1N5bWJvbCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gcmVJc1BsYWluUHJvcC50ZXN0KHZhbHVlKSB8fCAhcmVJc0RlZXBQcm9wLnRlc3QodmFsdWUpIHx8XG4gICAgKG9iamVjdCAhPSBudWxsICYmIHZhbHVlIGluIE9iamVjdChvYmplY3QpKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc0tleTtcbiIsIi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgc3VpdGFibGUgZm9yIHVzZSBhcyB1bmlxdWUgb2JqZWN0IGtleS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBzdWl0YWJsZSwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc0tleWFibGUodmFsdWUpIHtcbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gIHJldHVybiAodHlwZSA9PSAnc3RyaW5nJyB8fCB0eXBlID09ICdudW1iZXInIHx8IHR5cGUgPT0gJ3N5bWJvbCcgfHwgdHlwZSA9PSAnYm9vbGVhbicpXG4gICAgPyAodmFsdWUgIT09ICdfX3Byb3RvX18nKVxuICAgIDogKHZhbHVlID09PSBudWxsKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc0tleWFibGU7XG4iLCJ2YXIgY29yZUpzRGF0YSA9IHJlcXVpcmUoJy4vX2NvcmVKc0RhdGEnKTtcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IG1ldGhvZHMgbWFzcXVlcmFkaW5nIGFzIG5hdGl2ZS4gKi9cbnZhciBtYXNrU3JjS2V5ID0gKGZ1bmN0aW9uKCkge1xuICB2YXIgdWlkID0gL1teLl0rJC8uZXhlYyhjb3JlSnNEYXRhICYmIGNvcmVKc0RhdGEua2V5cyAmJiBjb3JlSnNEYXRhLmtleXMuSUVfUFJPVE8gfHwgJycpO1xuICByZXR1cm4gdWlkID8gKCdTeW1ib2woc3JjKV8xLicgKyB1aWQpIDogJyc7XG59KCkpO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgZnVuY2AgaGFzIGl0cyBzb3VyY2UgbWFza2VkLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgZnVuY2AgaXMgbWFza2VkLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzTWFza2VkKGZ1bmMpIHtcbiAgcmV0dXJuICEhbWFza1NyY0tleSAmJiAobWFza1NyY0tleSBpbiBmdW5jKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc01hc2tlZDtcbiIsIi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgbGlrZWx5IGEgcHJvdG90eXBlIG9iamVjdC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHByb3RvdHlwZSwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc1Byb3RvdHlwZSh2YWx1ZSkge1xuICB2YXIgQ3RvciA9IHZhbHVlICYmIHZhbHVlLmNvbnN0cnVjdG9yLFxuICAgICAgcHJvdG8gPSAodHlwZW9mIEN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiBDdG9yLnByb3RvdHlwZSkgfHwgb2JqZWN0UHJvdG87XG5cbiAgcmV0dXJuIHZhbHVlID09PSBwcm90bztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc1Byb3RvdHlwZTtcbiIsInZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vaXNPYmplY3QnKTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBzdWl0YWJsZSBmb3Igc3RyaWN0IGVxdWFsaXR5IGNvbXBhcmlzb25zLCBpLmUuIGA9PT1gLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlmIHN1aXRhYmxlIGZvciBzdHJpY3RcbiAqICBlcXVhbGl0eSBjb21wYXJpc29ucywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc1N0cmljdENvbXBhcmFibGUodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlID09PSB2YWx1ZSAmJiAhaXNPYmplY3QodmFsdWUpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzU3RyaWN0Q29tcGFyYWJsZTtcbiIsIi8qKlxuICogUmVtb3ZlcyBhbGwga2V5LXZhbHVlIGVudHJpZXMgZnJvbSB0aGUgbGlzdCBjYWNoZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgY2xlYXJcbiAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAqL1xuZnVuY3Rpb24gbGlzdENhY2hlQ2xlYXIoKSB7XG4gIHRoaXMuX19kYXRhX18gPSBbXTtcbiAgdGhpcy5zaXplID0gMDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBsaXN0Q2FjaGVDbGVhcjtcbiIsInZhciBhc3NvY0luZGV4T2YgPSByZXF1aXJlKCcuL19hc3NvY0luZGV4T2YnKTtcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIGFycmF5UHJvdG8gPSBBcnJheS5wcm90b3R5cGU7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIHNwbGljZSA9IGFycmF5UHJvdG8uc3BsaWNlO1xuXG4vKipcbiAqIFJlbW92ZXMgYGtleWAgYW5kIGl0cyB2YWx1ZSBmcm9tIHRoZSBsaXN0IGNhY2hlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBkZWxldGVcbiAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gcmVtb3ZlLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBlbnRyeSB3YXMgcmVtb3ZlZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBsaXN0Q2FjaGVEZWxldGUoa2V5KSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXyxcbiAgICAgIGluZGV4ID0gYXNzb2NJbmRleE9mKGRhdGEsIGtleSk7XG5cbiAgaWYgKGluZGV4IDwgMCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgbGFzdEluZGV4ID0gZGF0YS5sZW5ndGggLSAxO1xuICBpZiAoaW5kZXggPT0gbGFzdEluZGV4KSB7XG4gICAgZGF0YS5wb3AoKTtcbiAgfSBlbHNlIHtcbiAgICBzcGxpY2UuY2FsbChkYXRhLCBpbmRleCwgMSk7XG4gIH1cbiAgLS10aGlzLnNpemU7XG4gIHJldHVybiB0cnVlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGxpc3RDYWNoZURlbGV0ZTtcbiIsInZhciBhc3NvY0luZGV4T2YgPSByZXF1aXJlKCcuL19hc3NvY0luZGV4T2YnKTtcblxuLyoqXG4gKiBHZXRzIHRoZSBsaXN0IGNhY2hlIHZhbHVlIGZvciBga2V5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZ2V0XG4gKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBlbnRyeSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gbGlzdENhY2hlR2V0KGtleSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18sXG4gICAgICBpbmRleCA9IGFzc29jSW5kZXhPZihkYXRhLCBrZXkpO1xuXG4gIHJldHVybiBpbmRleCA8IDAgPyB1bmRlZmluZWQgOiBkYXRhW2luZGV4XVsxXTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBsaXN0Q2FjaGVHZXQ7XG4iLCJ2YXIgYXNzb2NJbmRleE9mID0gcmVxdWlyZSgnLi9fYXNzb2NJbmRleE9mJyk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGEgbGlzdCBjYWNoZSB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBoYXNcbiAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW4gZW50cnkgZm9yIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBsaXN0Q2FjaGVIYXMoa2V5KSB7XG4gIHJldHVybiBhc3NvY0luZGV4T2YodGhpcy5fX2RhdGFfXywga2V5KSA+IC0xO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGxpc3RDYWNoZUhhcztcbiIsInZhciBhc3NvY0luZGV4T2YgPSByZXF1aXJlKCcuL19hc3NvY0luZGV4T2YnKTtcblxuLyoqXG4gKiBTZXRzIHRoZSBsaXN0IGNhY2hlIGBrZXlgIHRvIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIHNldFxuICogQG1lbWJlck9mIExpc3RDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBsaXN0IGNhY2hlIGluc3RhbmNlLlxuICovXG5mdW5jdGlvbiBsaXN0Q2FjaGVTZXQoa2V5LCB2YWx1ZSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18sXG4gICAgICBpbmRleCA9IGFzc29jSW5kZXhPZihkYXRhLCBrZXkpO1xuXG4gIGlmIChpbmRleCA8IDApIHtcbiAgICArK3RoaXMuc2l6ZTtcbiAgICBkYXRhLnB1c2goW2tleSwgdmFsdWVdKTtcbiAgfSBlbHNlIHtcbiAgICBkYXRhW2luZGV4XVsxXSA9IHZhbHVlO1xuICB9XG4gIHJldHVybiB0aGlzO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGxpc3RDYWNoZVNldDtcbiIsInZhciBIYXNoID0gcmVxdWlyZSgnLi9fSGFzaCcpLFxuICAgIExpc3RDYWNoZSA9IHJlcXVpcmUoJy4vX0xpc3RDYWNoZScpLFxuICAgIE1hcCA9IHJlcXVpcmUoJy4vX01hcCcpO1xuXG4vKipcbiAqIFJlbW92ZXMgYWxsIGtleS12YWx1ZSBlbnRyaWVzIGZyb20gdGhlIG1hcC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgY2xlYXJcbiAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICovXG5mdW5jdGlvbiBtYXBDYWNoZUNsZWFyKCkge1xuICB0aGlzLnNpemUgPSAwO1xuICB0aGlzLl9fZGF0YV9fID0ge1xuICAgICdoYXNoJzogbmV3IEhhc2gsXG4gICAgJ21hcCc6IG5ldyAoTWFwIHx8IExpc3RDYWNoZSksXG4gICAgJ3N0cmluZyc6IG5ldyBIYXNoXG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbWFwQ2FjaGVDbGVhcjtcbiIsInZhciBnZXRNYXBEYXRhID0gcmVxdWlyZSgnLi9fZ2V0TWFwRGF0YScpO1xuXG4vKipcbiAqIFJlbW92ZXMgYGtleWAgYW5kIGl0cyB2YWx1ZSBmcm9tIHRoZSBtYXAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGRlbGV0ZVxuICogQG1lbWJlck9mIE1hcENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHJlbW92ZS5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZW50cnkgd2FzIHJlbW92ZWQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gbWFwQ2FjaGVEZWxldGUoa2V5KSB7XG4gIHZhciByZXN1bHQgPSBnZXRNYXBEYXRhKHRoaXMsIGtleSlbJ2RlbGV0ZSddKGtleSk7XG4gIHRoaXMuc2l6ZSAtPSByZXN1bHQgPyAxIDogMDtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBtYXBDYWNoZURlbGV0ZTtcbiIsInZhciBnZXRNYXBEYXRhID0gcmVxdWlyZSgnLi9fZ2V0TWFwRGF0YScpO1xuXG4vKipcbiAqIEdldHMgdGhlIG1hcCB2YWx1ZSBmb3IgYGtleWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGdldFxuICogQG1lbWJlck9mIE1hcENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBlbnRyeSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gbWFwQ2FjaGVHZXQoa2V5KSB7XG4gIHJldHVybiBnZXRNYXBEYXRhKHRoaXMsIGtleSkuZ2V0KGtleSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbWFwQ2FjaGVHZXQ7XG4iLCJ2YXIgZ2V0TWFwRGF0YSA9IHJlcXVpcmUoJy4vX2dldE1hcERhdGEnKTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYSBtYXAgdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgaGFzXG4gKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW4gZW50cnkgZm9yIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBtYXBDYWNoZUhhcyhrZXkpIHtcbiAgcmV0dXJuIGdldE1hcERhdGEodGhpcywga2V5KS5oYXMoa2V5KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBtYXBDYWNoZUhhcztcbiIsInZhciBnZXRNYXBEYXRhID0gcmVxdWlyZSgnLi9fZ2V0TWFwRGF0YScpO1xuXG4vKipcbiAqIFNldHMgdGhlIG1hcCBga2V5YCB0byBgdmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBzZXRcbiAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBtYXAgY2FjaGUgaW5zdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIG1hcENhY2hlU2V0KGtleSwgdmFsdWUpIHtcbiAgdmFyIGRhdGEgPSBnZXRNYXBEYXRhKHRoaXMsIGtleSksXG4gICAgICBzaXplID0gZGF0YS5zaXplO1xuXG4gIGRhdGEuc2V0KGtleSwgdmFsdWUpO1xuICB0aGlzLnNpemUgKz0gZGF0YS5zaXplID09IHNpemUgPyAwIDogMTtcbiAgcmV0dXJuIHRoaXM7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbWFwQ2FjaGVTZXQ7XG4iLCIvKipcbiAqIENvbnZlcnRzIGBtYXBgIHRvIGl0cyBrZXktdmFsdWUgcGFpcnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBtYXAgVGhlIG1hcCB0byBjb252ZXJ0LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBrZXktdmFsdWUgcGFpcnMuXG4gKi9cbmZ1bmN0aW9uIG1hcFRvQXJyYXkobWFwKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgcmVzdWx0ID0gQXJyYXkobWFwLnNpemUpO1xuXG4gIG1hcC5mb3JFYWNoKGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHtcbiAgICByZXN1bHRbKytpbmRleF0gPSBba2V5LCB2YWx1ZV07XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG1hcFRvQXJyYXk7XG4iLCIvKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgbWF0Y2hlc1Byb3BlcnR5YCBmb3Igc291cmNlIHZhbHVlcyBzdWl0YWJsZVxuICogZm9yIHN0cmljdCBlcXVhbGl0eSBjb21wYXJpc29ucywgaS5lLiBgPT09YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gKiBAcGFyYW0geyp9IHNyY1ZhbHVlIFRoZSB2YWx1ZSB0byBtYXRjaC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHNwZWMgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIG1hdGNoZXNTdHJpY3RDb21wYXJhYmxlKGtleSwgc3JjVmFsdWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCkge1xuICAgIGlmIChvYmplY3QgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gb2JqZWN0W2tleV0gPT09IHNyY1ZhbHVlICYmXG4gICAgICAoc3JjVmFsdWUgIT09IHVuZGVmaW5lZCB8fCAoa2V5IGluIE9iamVjdChvYmplY3QpKSk7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbWF0Y2hlc1N0cmljdENvbXBhcmFibGU7XG4iLCJ2YXIgbWVtb2l6ZSA9IHJlcXVpcmUoJy4vbWVtb2l6ZScpO1xuXG4vKiogVXNlZCBhcyB0aGUgbWF4aW11bSBtZW1vaXplIGNhY2hlIHNpemUuICovXG52YXIgTUFYX01FTU9JWkVfU0laRSA9IDUwMDtcblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8ubWVtb2l6ZWAgd2hpY2ggY2xlYXJzIHRoZSBtZW1vaXplZCBmdW5jdGlvbidzXG4gKiBjYWNoZSB3aGVuIGl0IGV4Y2VlZHMgYE1BWF9NRU1PSVpFX1NJWkVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBoYXZlIGl0cyBvdXRwdXQgbWVtb2l6ZWQuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBtZW1vaXplZCBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gbWVtb2l6ZUNhcHBlZChmdW5jKSB7XG4gIHZhciByZXN1bHQgPSBtZW1vaXplKGZ1bmMsIGZ1bmN0aW9uKGtleSkge1xuICAgIGlmIChjYWNoZS5zaXplID09PSBNQVhfTUVNT0laRV9TSVpFKSB7XG4gICAgICBjYWNoZS5jbGVhcigpO1xuICAgIH1cbiAgICByZXR1cm4ga2V5O1xuICB9KTtcblxuICB2YXIgY2FjaGUgPSByZXN1bHQuY2FjaGU7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbWVtb2l6ZUNhcHBlZDtcbiIsInZhciBnZXROYXRpdmUgPSByZXF1aXJlKCcuL19nZXROYXRpdmUnKTtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgdGhhdCBhcmUgdmVyaWZpZWQgdG8gYmUgbmF0aXZlLiAqL1xudmFyIG5hdGl2ZUNyZWF0ZSA9IGdldE5hdGl2ZShPYmplY3QsICdjcmVhdGUnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBuYXRpdmVDcmVhdGU7XG4iLCJ2YXIgb3ZlckFyZyA9IHJlcXVpcmUoJy4vX292ZXJBcmcnKTtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgZm9yIHRob3NlIHdpdGggdGhlIHNhbWUgbmFtZSBhcyBvdGhlciBgbG9kYXNoYCBtZXRob2RzLiAqL1xudmFyIG5hdGl2ZUtleXMgPSBvdmVyQXJnKE9iamVjdC5rZXlzLCBPYmplY3QpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IG5hdGl2ZUtleXM7XG4iLCIvKipcbiAqIFRoaXMgZnVuY3Rpb24gaXMgbGlrZVxuICogW2BPYmplY3Qua2V5c2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLW9iamVjdC5rZXlzKVxuICogZXhjZXB0IHRoYXQgaXQgaW5jbHVkZXMgaW5oZXJpdGVkIGVudW1lcmFibGUgcHJvcGVydGllcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAqL1xuZnVuY3Rpb24gbmF0aXZlS2V5c0luKG9iamVjdCkge1xuICB2YXIgcmVzdWx0ID0gW107XG4gIGlmIChvYmplY3QgIT0gbnVsbCkge1xuICAgIGZvciAodmFyIGtleSBpbiBPYmplY3Qob2JqZWN0KSkge1xuICAgICAgcmVzdWx0LnB1c2goa2V5KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBuYXRpdmVLZXlzSW47XG4iLCJ2YXIgZnJlZUdsb2JhbCA9IHJlcXVpcmUoJy4vX2ZyZWVHbG9iYWwnKTtcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBleHBvcnRzYC4gKi9cbnZhciBmcmVlRXhwb3J0cyA9IHR5cGVvZiBleHBvcnRzID09ICdvYmplY3QnICYmIGV4cG9ydHMgJiYgIWV4cG9ydHMubm9kZVR5cGUgJiYgZXhwb3J0cztcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBtb2R1bGVgLiAqL1xudmFyIGZyZWVNb2R1bGUgPSBmcmVlRXhwb3J0cyAmJiB0eXBlb2YgbW9kdWxlID09ICdvYmplY3QnICYmIG1vZHVsZSAmJiAhbW9kdWxlLm5vZGVUeXBlICYmIG1vZHVsZTtcblxuLyoqIERldGVjdCB0aGUgcG9wdWxhciBDb21tb25KUyBleHRlbnNpb24gYG1vZHVsZS5leHBvcnRzYC4gKi9cbnZhciBtb2R1bGVFeHBvcnRzID0gZnJlZU1vZHVsZSAmJiBmcmVlTW9kdWxlLmV4cG9ydHMgPT09IGZyZWVFeHBvcnRzO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYHByb2Nlc3NgIGZyb20gTm9kZS5qcy4gKi9cbnZhciBmcmVlUHJvY2VzcyA9IG1vZHVsZUV4cG9ydHMgJiYgZnJlZUdsb2JhbC5wcm9jZXNzO1xuXG4vKiogVXNlZCB0byBhY2Nlc3MgZmFzdGVyIE5vZGUuanMgaGVscGVycy4gKi9cbnZhciBub2RlVXRpbCA9IChmdW5jdGlvbigpIHtcbiAgdHJ5IHtcbiAgICAvLyBVc2UgYHV0aWwudHlwZXNgIGZvciBOb2RlLmpzIDEwKy5cbiAgICB2YXIgdHlwZXMgPSBmcmVlTW9kdWxlICYmIGZyZWVNb2R1bGUucmVxdWlyZSAmJiBmcmVlTW9kdWxlLnJlcXVpcmUoJ3V0aWwnKS50eXBlcztcblxuICAgIGlmICh0eXBlcykge1xuICAgICAgcmV0dXJuIHR5cGVzO1xuICAgIH1cblxuICAgIC8vIExlZ2FjeSBgcHJvY2Vzcy5iaW5kaW5nKCd1dGlsJylgIGZvciBOb2RlLmpzIDwgMTAuXG4gICAgcmV0dXJuIGZyZWVQcm9jZXNzICYmIGZyZWVQcm9jZXNzLmJpbmRpbmcgJiYgZnJlZVByb2Nlc3MuYmluZGluZygndXRpbCcpO1xuICB9IGNhdGNoIChlKSB7fVxufSgpKTtcblxubW9kdWxlLmV4cG9ydHMgPSBub2RlVXRpbDtcbiIsIi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKlxuICogVXNlZCB0byByZXNvbHZlIHRoZVxuICogW2B0b1N0cmluZ1RhZ2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLW9iamVjdC5wcm90b3R5cGUudG9zdHJpbmcpXG4gKiBvZiB2YWx1ZXMuXG4gKi9cbnZhciBuYXRpdmVPYmplY3RUb1N0cmluZyA9IG9iamVjdFByb3RvLnRvU3RyaW5nO1xuXG4vKipcbiAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBzdHJpbmcgdXNpbmcgYE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmdgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb252ZXJ0LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgY29udmVydGVkIHN0cmluZy5cbiAqL1xuZnVuY3Rpb24gb2JqZWN0VG9TdHJpbmcodmFsdWUpIHtcbiAgcmV0dXJuIG5hdGl2ZU9iamVjdFRvU3RyaW5nLmNhbGwodmFsdWUpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG9iamVjdFRvU3RyaW5nO1xuIiwiLyoqXG4gKiBDcmVhdGVzIGEgdW5hcnkgZnVuY3Rpb24gdGhhdCBpbnZva2VzIGBmdW5jYCB3aXRoIGl0cyBhcmd1bWVudCB0cmFuc2Zvcm1lZC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gd3JhcC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHRyYW5zZm9ybSBUaGUgYXJndW1lbnQgdHJhbnNmb3JtLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIG92ZXJBcmcoZnVuYywgdHJhbnNmb3JtKSB7XG4gIHJldHVybiBmdW5jdGlvbihhcmcpIHtcbiAgICByZXR1cm4gZnVuYyh0cmFuc2Zvcm0oYXJnKSk7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gb3ZlckFyZztcbiIsInZhciBhcHBseSA9IHJlcXVpcmUoJy4vX2FwcGx5Jyk7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIGZvciB0aG9zZSB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgb3RoZXIgYGxvZGFzaGAgbWV0aG9kcy4gKi9cbnZhciBuYXRpdmVNYXggPSBNYXRoLm1heDtcblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VSZXN0YCB3aGljaCB0cmFuc2Zvcm1zIHRoZSByZXN0IGFycmF5LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBhcHBseSBhIHJlc3QgcGFyYW1ldGVyIHRvLlxuICogQHBhcmFtIHtudW1iZXJ9IFtzdGFydD1mdW5jLmxlbmd0aC0xXSBUaGUgc3RhcnQgcG9zaXRpb24gb2YgdGhlIHJlc3QgcGFyYW1ldGVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gdHJhbnNmb3JtIFRoZSByZXN0IGFycmF5IHRyYW5zZm9ybS5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBvdmVyUmVzdChmdW5jLCBzdGFydCwgdHJhbnNmb3JtKSB7XG4gIHN0YXJ0ID0gbmF0aXZlTWF4KHN0YXJ0ID09PSB1bmRlZmluZWQgPyAoZnVuYy5sZW5ndGggLSAxKSA6IHN0YXJ0LCAwKTtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHZhciBhcmdzID0gYXJndW1lbnRzLFxuICAgICAgICBpbmRleCA9IC0xLFxuICAgICAgICBsZW5ndGggPSBuYXRpdmVNYXgoYXJncy5sZW5ndGggLSBzdGFydCwgMCksXG4gICAgICAgIGFycmF5ID0gQXJyYXkobGVuZ3RoKTtcblxuICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICBhcnJheVtpbmRleF0gPSBhcmdzW3N0YXJ0ICsgaW5kZXhdO1xuICAgIH1cbiAgICBpbmRleCA9IC0xO1xuICAgIHZhciBvdGhlckFyZ3MgPSBBcnJheShzdGFydCArIDEpO1xuICAgIHdoaWxlICgrK2luZGV4IDwgc3RhcnQpIHtcbiAgICAgIG90aGVyQXJnc1tpbmRleF0gPSBhcmdzW2luZGV4XTtcbiAgICB9XG4gICAgb3RoZXJBcmdzW3N0YXJ0XSA9IHRyYW5zZm9ybShhcnJheSk7XG4gICAgcmV0dXJuIGFwcGx5KGZ1bmMsIHRoaXMsIG90aGVyQXJncyk7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gb3ZlclJlc3Q7XG4iLCJ2YXIgZnJlZUdsb2JhbCA9IHJlcXVpcmUoJy4vX2ZyZWVHbG9iYWwnKTtcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBzZWxmYC4gKi9cbnZhciBmcmVlU2VsZiA9IHR5cGVvZiBzZWxmID09ICdvYmplY3QnICYmIHNlbGYgJiYgc2VsZi5PYmplY3QgPT09IE9iamVjdCAmJiBzZWxmO1xuXG4vKiogVXNlZCBhcyBhIHJlZmVyZW5jZSB0byB0aGUgZ2xvYmFsIG9iamVjdC4gKi9cbnZhciByb290ID0gZnJlZUdsb2JhbCB8fCBmcmVlU2VsZiB8fCBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJvb3Q7XG4iLCIvKipcbiAqIEdldHMgdGhlIHZhbHVlIGF0IGBrZXlgLCB1bmxlc3MgYGtleWAgaXMgXCJfX3Byb3RvX19cIiBvciBcImNvbnN0cnVjdG9yXCIuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHByb3BlcnR5IHZhbHVlLlxuICovXG5mdW5jdGlvbiBzYWZlR2V0KG9iamVjdCwga2V5KSB7XG4gIGlmIChrZXkgPT09ICdjb25zdHJ1Y3RvcicgJiYgdHlwZW9mIG9iamVjdFtrZXldID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKGtleSA9PSAnX19wcm90b19fJykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHJldHVybiBvYmplY3Rba2V5XTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzYWZlR2V0O1xuIiwiLyoqIFVzZWQgdG8gc3RhbmQtaW4gZm9yIGB1bmRlZmluZWRgIGhhc2ggdmFsdWVzLiAqL1xudmFyIEhBU0hfVU5ERUZJTkVEID0gJ19fbG9kYXNoX2hhc2hfdW5kZWZpbmVkX18nO1xuXG4vKipcbiAqIEFkZHMgYHZhbHVlYCB0byB0aGUgYXJyYXkgY2FjaGUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGFkZFxuICogQG1lbWJlck9mIFNldENhY2hlXG4gKiBAYWxpYXMgcHVzaFxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2FjaGUuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjYWNoZSBpbnN0YW5jZS5cbiAqL1xuZnVuY3Rpb24gc2V0Q2FjaGVBZGQodmFsdWUpIHtcbiAgdGhpcy5fX2RhdGFfXy5zZXQodmFsdWUsIEhBU0hfVU5ERUZJTkVEKTtcbiAgcmV0dXJuIHRoaXM7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc2V0Q2FjaGVBZGQ7XG4iLCIvKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGluIHRoZSBhcnJheSBjYWNoZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgaGFzXG4gKiBAbWVtYmVyT2YgU2V0Q2FjaGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNlYXJjaCBmb3IuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGZvdW5kLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIHNldENhY2hlSGFzKHZhbHVlKSB7XG4gIHJldHVybiB0aGlzLl9fZGF0YV9fLmhhcyh2YWx1ZSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc2V0Q2FjaGVIYXM7XG4iLCIvKipcbiAqIENvbnZlcnRzIGBzZXRgIHRvIGFuIGFycmF5IG9mIGl0cyB2YWx1ZXMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBzZXQgVGhlIHNldCB0byBjb252ZXJ0LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSB2YWx1ZXMuXG4gKi9cbmZ1bmN0aW9uIHNldFRvQXJyYXkoc2V0KSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgcmVzdWx0ID0gQXJyYXkoc2V0LnNpemUpO1xuXG4gIHNldC5mb3JFYWNoKGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgcmVzdWx0WysraW5kZXhdID0gdmFsdWU7XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHNldFRvQXJyYXk7XG4iLCJ2YXIgYmFzZVNldFRvU3RyaW5nID0gcmVxdWlyZSgnLi9fYmFzZVNldFRvU3RyaW5nJyksXG4gICAgc2hvcnRPdXQgPSByZXF1aXJlKCcuL19zaG9ydE91dCcpO1xuXG4vKipcbiAqIFNldHMgdGhlIGB0b1N0cmluZ2AgbWV0aG9kIG9mIGBmdW5jYCB0byByZXR1cm4gYHN0cmluZ2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIG1vZGlmeS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHN0cmluZyBUaGUgYHRvU3RyaW5nYCByZXN1bHQuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgYGZ1bmNgLlxuICovXG52YXIgc2V0VG9TdHJpbmcgPSBzaG9ydE91dChiYXNlU2V0VG9TdHJpbmcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHNldFRvU3RyaW5nO1xuIiwiLyoqIFVzZWQgdG8gZGV0ZWN0IGhvdCBmdW5jdGlvbnMgYnkgbnVtYmVyIG9mIGNhbGxzIHdpdGhpbiBhIHNwYW4gb2YgbWlsbGlzZWNvbmRzLiAqL1xudmFyIEhPVF9DT1VOVCA9IDgwMCxcbiAgICBIT1RfU1BBTiA9IDE2O1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyBmb3IgdGhvc2Ugd2l0aCB0aGUgc2FtZSBuYW1lIGFzIG90aGVyIGBsb2Rhc2hgIG1ldGhvZHMuICovXG52YXIgbmF0aXZlTm93ID0gRGF0ZS5ub3c7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQnbGwgc2hvcnQgb3V0IGFuZCBpbnZva2UgYGlkZW50aXR5YCBpbnN0ZWFkXG4gKiBvZiBgZnVuY2Agd2hlbiBpdCdzIGNhbGxlZCBgSE9UX0NPVU5UYCBvciBtb3JlIHRpbWVzIGluIGBIT1RfU1BBTmBcbiAqIG1pbGxpc2Vjb25kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gcmVzdHJpY3QuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBzaG9ydGFibGUgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIHNob3J0T3V0KGZ1bmMpIHtcbiAgdmFyIGNvdW50ID0gMCxcbiAgICAgIGxhc3RDYWxsZWQgPSAwO1xuXG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB2YXIgc3RhbXAgPSBuYXRpdmVOb3coKSxcbiAgICAgICAgcmVtYWluaW5nID0gSE9UX1NQQU4gLSAoc3RhbXAgLSBsYXN0Q2FsbGVkKTtcblxuICAgIGxhc3RDYWxsZWQgPSBzdGFtcDtcbiAgICBpZiAocmVtYWluaW5nID4gMCkge1xuICAgICAgaWYgKCsrY291bnQgPj0gSE9UX0NPVU5UKSB7XG4gICAgICAgIHJldHVybiBhcmd1bWVudHNbMF07XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvdW50ID0gMDtcbiAgICB9XG4gICAgcmV0dXJuIGZ1bmMuYXBwbHkodW5kZWZpbmVkLCBhcmd1bWVudHMpO1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHNob3J0T3V0O1xuIiwidmFyIExpc3RDYWNoZSA9IHJlcXVpcmUoJy4vX0xpc3RDYWNoZScpO1xuXG4vKipcbiAqIFJlbW92ZXMgYWxsIGtleS12YWx1ZSBlbnRyaWVzIGZyb20gdGhlIHN0YWNrLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBjbGVhclxuICogQG1lbWJlck9mIFN0YWNrXG4gKi9cbmZ1bmN0aW9uIHN0YWNrQ2xlYXIoKSB7XG4gIHRoaXMuX19kYXRhX18gPSBuZXcgTGlzdENhY2hlO1xuICB0aGlzLnNpemUgPSAwO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHN0YWNrQ2xlYXI7XG4iLCIvKipcbiAqIFJlbW92ZXMgYGtleWAgYW5kIGl0cyB2YWx1ZSBmcm9tIHRoZSBzdGFjay5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZGVsZXRlXG4gKiBAbWVtYmVyT2YgU3RhY2tcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gcmVtb3ZlLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBlbnRyeSB3YXMgcmVtb3ZlZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBzdGFja0RlbGV0ZShrZXkpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fLFxuICAgICAgcmVzdWx0ID0gZGF0YVsnZGVsZXRlJ10oa2V5KTtcblxuICB0aGlzLnNpemUgPSBkYXRhLnNpemU7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc3RhY2tEZWxldGU7XG4iLCIvKipcbiAqIEdldHMgdGhlIHN0YWNrIHZhbHVlIGZvciBga2V5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZ2V0XG4gKiBAbWVtYmVyT2YgU3RhY2tcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGVudHJ5IHZhbHVlLlxuICovXG5mdW5jdGlvbiBzdGFja0dldChrZXkpIHtcbiAgcmV0dXJuIHRoaXMuX19kYXRhX18uZ2V0KGtleSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc3RhY2tHZXQ7XG4iLCIvKipcbiAqIENoZWNrcyBpZiBhIHN0YWNrIHZhbHVlIGZvciBga2V5YCBleGlzdHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGhhc1xuICogQG1lbWJlck9mIFN0YWNrXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gc3RhY2tIYXMoa2V5KSB7XG4gIHJldHVybiB0aGlzLl9fZGF0YV9fLmhhcyhrZXkpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHN0YWNrSGFzO1xuIiwidmFyIExpc3RDYWNoZSA9IHJlcXVpcmUoJy4vX0xpc3RDYWNoZScpLFxuICAgIE1hcCA9IHJlcXVpcmUoJy4vX01hcCcpLFxuICAgIE1hcENhY2hlID0gcmVxdWlyZSgnLi9fTWFwQ2FjaGUnKTtcblxuLyoqIFVzZWQgYXMgdGhlIHNpemUgdG8gZW5hYmxlIGxhcmdlIGFycmF5IG9wdGltaXphdGlvbnMuICovXG52YXIgTEFSR0VfQVJSQVlfU0laRSA9IDIwMDtcblxuLyoqXG4gKiBTZXRzIHRoZSBzdGFjayBga2V5YCB0byBgdmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBzZXRcbiAqIEBtZW1iZXJPZiBTdGFja1xuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBzdGFjayBjYWNoZSBpbnN0YW5jZS5cbiAqL1xuZnVuY3Rpb24gc3RhY2tTZXQoa2V5LCB2YWx1ZSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX187XG4gIGlmIChkYXRhIGluc3RhbmNlb2YgTGlzdENhY2hlKSB7XG4gICAgdmFyIHBhaXJzID0gZGF0YS5fX2RhdGFfXztcbiAgICBpZiAoIU1hcCB8fCAocGFpcnMubGVuZ3RoIDwgTEFSR0VfQVJSQVlfU0laRSAtIDEpKSB7XG4gICAgICBwYWlycy5wdXNoKFtrZXksIHZhbHVlXSk7XG4gICAgICB0aGlzLnNpemUgPSArK2RhdGEuc2l6ZTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBkYXRhID0gdGhpcy5fX2RhdGFfXyA9IG5ldyBNYXBDYWNoZShwYWlycyk7XG4gIH1cbiAgZGF0YS5zZXQoa2V5LCB2YWx1ZSk7XG4gIHRoaXMuc2l6ZSA9IGRhdGEuc2l6ZTtcbiAgcmV0dXJuIHRoaXM7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc3RhY2tTZXQ7XG4iLCIvKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5pbmRleE9mYCB3aGljaCBwZXJmb3JtcyBzdHJpY3QgZXF1YWxpdHlcbiAqIGNvbXBhcmlzb25zIG9mIHZhbHVlcywgaS5lLiBgPT09YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZWFyY2ggZm9yLlxuICogQHBhcmFtIHtudW1iZXJ9IGZyb21JbmRleCBUaGUgaW5kZXggdG8gc2VhcmNoIGZyb20uXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgbWF0Y2hlZCB2YWx1ZSwgZWxzZSBgLTFgLlxuICovXG5mdW5jdGlvbiBzdHJpY3RJbmRleE9mKGFycmF5LCB2YWx1ZSwgZnJvbUluZGV4KSB7XG4gIHZhciBpbmRleCA9IGZyb21JbmRleCAtIDEsXG4gICAgICBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICBpZiAoYXJyYXlbaW5kZXhdID09PSB2YWx1ZSkge1xuICAgICAgcmV0dXJuIGluZGV4O1xuICAgIH1cbiAgfVxuICByZXR1cm4gLTE7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc3RyaWN0SW5kZXhPZjtcbiIsInZhciBhc2NpaVNpemUgPSByZXF1aXJlKCcuL19hc2NpaVNpemUnKSxcbiAgICBoYXNVbmljb2RlID0gcmVxdWlyZSgnLi9faGFzVW5pY29kZScpLFxuICAgIHVuaWNvZGVTaXplID0gcmVxdWlyZSgnLi9fdW5pY29kZVNpemUnKTtcblxuLyoqXG4gKiBHZXRzIHRoZSBudW1iZXIgb2Ygc3ltYm9scyBpbiBgc3RyaW5nYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBUaGUgc3RyaW5nIHRvIGluc3BlY3QuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBzdHJpbmcgc2l6ZS5cbiAqL1xuZnVuY3Rpb24gc3RyaW5nU2l6ZShzdHJpbmcpIHtcbiAgcmV0dXJuIGhhc1VuaWNvZGUoc3RyaW5nKVxuICAgID8gdW5pY29kZVNpemUoc3RyaW5nKVxuICAgIDogYXNjaWlTaXplKHN0cmluZyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc3RyaW5nU2l6ZTtcbiIsInZhciBtZW1vaXplQ2FwcGVkID0gcmVxdWlyZSgnLi9fbWVtb2l6ZUNhcHBlZCcpO1xuXG4vKiogVXNlZCB0byBtYXRjaCBwcm9wZXJ0eSBuYW1lcyB3aXRoaW4gcHJvcGVydHkgcGF0aHMuICovXG52YXIgcmVQcm9wTmFtZSA9IC9bXi5bXFxdXSt8XFxbKD86KC0/XFxkKyg/OlxcLlxcZCspPyl8KFtcIiddKSgoPzooPyFcXDIpW15cXFxcXXxcXFxcLikqPylcXDIpXFxdfCg/PSg/OlxcLnxcXFtcXF0pKD86XFwufFxcW1xcXXwkKSkvZztcblxuLyoqIFVzZWQgdG8gbWF0Y2ggYmFja3NsYXNoZXMgaW4gcHJvcGVydHkgcGF0aHMuICovXG52YXIgcmVFc2NhcGVDaGFyID0gL1xcXFwoXFxcXCk/L2c7XG5cbi8qKlxuICogQ29udmVydHMgYHN0cmluZ2AgdG8gYSBwcm9wZXJ0eSBwYXRoIGFycmF5LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIFRoZSBzdHJpbmcgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgcHJvcGVydHkgcGF0aCBhcnJheS5cbiAqL1xudmFyIHN0cmluZ1RvUGF0aCA9IG1lbW9pemVDYXBwZWQoZnVuY3Rpb24oc3RyaW5nKSB7XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgaWYgKHN0cmluZy5jaGFyQ29kZUF0KDApID09PSA0NiAvKiAuICovKSB7XG4gICAgcmVzdWx0LnB1c2goJycpO1xuICB9XG4gIHN0cmluZy5yZXBsYWNlKHJlUHJvcE5hbWUsIGZ1bmN0aW9uKG1hdGNoLCBudW1iZXIsIHF1b3RlLCBzdWJTdHJpbmcpIHtcbiAgICByZXN1bHQucHVzaChxdW90ZSA/IHN1YlN0cmluZy5yZXBsYWNlKHJlRXNjYXBlQ2hhciwgJyQxJykgOiAobnVtYmVyIHx8IG1hdGNoKSk7XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0O1xufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gc3RyaW5nVG9QYXRoO1xuIiwidmFyIGlzU3ltYm9sID0gcmVxdWlyZSgnLi9pc1N5bWJvbCcpO1xuXG4vKiogVXNlZCBhcyByZWZlcmVuY2VzIGZvciB2YXJpb3VzIGBOdW1iZXJgIGNvbnN0YW50cy4gKi9cbnZhciBJTkZJTklUWSA9IDEgLyAwO1xuXG4vKipcbiAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBzdHJpbmcga2V5IGlmIGl0J3Mgbm90IGEgc3RyaW5nIG9yIHN5bWJvbC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gaW5zcGVjdC5cbiAqIEByZXR1cm5zIHtzdHJpbmd8c3ltYm9sfSBSZXR1cm5zIHRoZSBrZXkuXG4gKi9cbmZ1bmN0aW9uIHRvS2V5KHZhbHVlKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgPT0gJ3N0cmluZycgfHwgaXNTeW1ib2wodmFsdWUpKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIHZhciByZXN1bHQgPSAodmFsdWUgKyAnJyk7XG4gIHJldHVybiAocmVzdWx0ID09ICcwJyAmJiAoMSAvIHZhbHVlKSA9PSAtSU5GSU5JVFkpID8gJy0wJyA6IHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB0b0tleTtcbiIsIi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBmdW5jUHJvdG8gPSBGdW5jdGlvbi5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIHJlc29sdmUgdGhlIGRlY29tcGlsZWQgc291cmNlIG9mIGZ1bmN0aW9ucy4gKi9cbnZhciBmdW5jVG9TdHJpbmcgPSBmdW5jUHJvdG8udG9TdHJpbmc7XG5cbi8qKlxuICogQ29udmVydHMgYGZ1bmNgIHRvIGl0cyBzb3VyY2UgY29kZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHNvdXJjZSBjb2RlLlxuICovXG5mdW5jdGlvbiB0b1NvdXJjZShmdW5jKSB7XG4gIGlmIChmdW5jICE9IG51bGwpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGZ1bmNUb1N0cmluZy5jYWxsKGZ1bmMpO1xuICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiAoZnVuYyArICcnKTtcbiAgICB9IGNhdGNoIChlKSB7fVxuICB9XG4gIHJldHVybiAnJztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB0b1NvdXJjZTtcbiIsIi8qKiBVc2VkIHRvIG1hdGNoIGEgc2luZ2xlIHdoaXRlc3BhY2UgY2hhcmFjdGVyLiAqL1xudmFyIHJlV2hpdGVzcGFjZSA9IC9cXHMvO1xuXG4vKipcbiAqIFVzZWQgYnkgYF8udHJpbWAgYW5kIGBfLnRyaW1FbmRgIHRvIGdldCB0aGUgaW5kZXggb2YgdGhlIGxhc3Qgbm9uLXdoaXRlc3BhY2VcbiAqIGNoYXJhY3RlciBvZiBgc3RyaW5nYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBUaGUgc3RyaW5nIHRvIGluc3BlY3QuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgbGFzdCBub24td2hpdGVzcGFjZSBjaGFyYWN0ZXIuXG4gKi9cbmZ1bmN0aW9uIHRyaW1tZWRFbmRJbmRleChzdHJpbmcpIHtcbiAgdmFyIGluZGV4ID0gc3RyaW5nLmxlbmd0aDtcblxuICB3aGlsZSAoaW5kZXgtLSAmJiByZVdoaXRlc3BhY2UudGVzdChzdHJpbmcuY2hhckF0KGluZGV4KSkpIHt9XG4gIHJldHVybiBpbmRleDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB0cmltbWVkRW5kSW5kZXg7XG4iLCIvKiogVXNlZCB0byBjb21wb3NlIHVuaWNvZGUgY2hhcmFjdGVyIGNsYXNzZXMuICovXG52YXIgcnNBc3RyYWxSYW5nZSA9ICdcXFxcdWQ4MDAtXFxcXHVkZmZmJyxcbiAgICByc0NvbWJvTWFya3NSYW5nZSA9ICdcXFxcdTAzMDAtXFxcXHUwMzZmJyxcbiAgICByZUNvbWJvSGFsZk1hcmtzUmFuZ2UgPSAnXFxcXHVmZTIwLVxcXFx1ZmUyZicsXG4gICAgcnNDb21ib1N5bWJvbHNSYW5nZSA9ICdcXFxcdTIwZDAtXFxcXHUyMGZmJyxcbiAgICByc0NvbWJvUmFuZ2UgPSByc0NvbWJvTWFya3NSYW5nZSArIHJlQ29tYm9IYWxmTWFya3NSYW5nZSArIHJzQ29tYm9TeW1ib2xzUmFuZ2UsXG4gICAgcnNWYXJSYW5nZSA9ICdcXFxcdWZlMGVcXFxcdWZlMGYnO1xuXG4vKiogVXNlZCB0byBjb21wb3NlIHVuaWNvZGUgY2FwdHVyZSBncm91cHMuICovXG52YXIgcnNBc3RyYWwgPSAnWycgKyByc0FzdHJhbFJhbmdlICsgJ10nLFxuICAgIHJzQ29tYm8gPSAnWycgKyByc0NvbWJvUmFuZ2UgKyAnXScsXG4gICAgcnNGaXR6ID0gJ1xcXFx1ZDgzY1tcXFxcdWRmZmItXFxcXHVkZmZmXScsXG4gICAgcnNNb2RpZmllciA9ICcoPzonICsgcnNDb21ibyArICd8JyArIHJzRml0eiArICcpJyxcbiAgICByc05vbkFzdHJhbCA9ICdbXicgKyByc0FzdHJhbFJhbmdlICsgJ10nLFxuICAgIHJzUmVnaW9uYWwgPSAnKD86XFxcXHVkODNjW1xcXFx1ZGRlNi1cXFxcdWRkZmZdKXsyfScsXG4gICAgcnNTdXJyUGFpciA9ICdbXFxcXHVkODAwLVxcXFx1ZGJmZl1bXFxcXHVkYzAwLVxcXFx1ZGZmZl0nLFxuICAgIHJzWldKID0gJ1xcXFx1MjAwZCc7XG5cbi8qKiBVc2VkIHRvIGNvbXBvc2UgdW5pY29kZSByZWdleGVzLiAqL1xudmFyIHJlT3B0TW9kID0gcnNNb2RpZmllciArICc/JyxcbiAgICByc09wdFZhciA9ICdbJyArIHJzVmFyUmFuZ2UgKyAnXT8nLFxuICAgIHJzT3B0Sm9pbiA9ICcoPzonICsgcnNaV0ogKyAnKD86JyArIFtyc05vbkFzdHJhbCwgcnNSZWdpb25hbCwgcnNTdXJyUGFpcl0uam9pbignfCcpICsgJyknICsgcnNPcHRWYXIgKyByZU9wdE1vZCArICcpKicsXG4gICAgcnNTZXEgPSByc09wdFZhciArIHJlT3B0TW9kICsgcnNPcHRKb2luLFxuICAgIHJzU3ltYm9sID0gJyg/OicgKyBbcnNOb25Bc3RyYWwgKyByc0NvbWJvICsgJz8nLCByc0NvbWJvLCByc1JlZ2lvbmFsLCByc1N1cnJQYWlyLCByc0FzdHJhbF0uam9pbignfCcpICsgJyknO1xuXG4vKiogVXNlZCB0byBtYXRjaCBbc3RyaW5nIHN5bWJvbHNdKGh0dHBzOi8vbWF0aGlhc2J5bmVucy5iZS9ub3Rlcy9qYXZhc2NyaXB0LXVuaWNvZGUpLiAqL1xudmFyIHJlVW5pY29kZSA9IFJlZ0V4cChyc0ZpdHogKyAnKD89JyArIHJzRml0eiArICcpfCcgKyByc1N5bWJvbCArIHJzU2VxLCAnZycpO1xuXG4vKipcbiAqIEdldHMgdGhlIHNpemUgb2YgYSBVbmljb2RlIGBzdHJpbmdgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIFRoZSBzdHJpbmcgaW5zcGVjdC5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIHN0cmluZyBzaXplLlxuICovXG5mdW5jdGlvbiB1bmljb2RlU2l6ZShzdHJpbmcpIHtcbiAgdmFyIHJlc3VsdCA9IHJlVW5pY29kZS5sYXN0SW5kZXggPSAwO1xuICB3aGlsZSAocmVVbmljb2RlLnRlc3Qoc3RyaW5nKSkge1xuICAgICsrcmVzdWx0O1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gdW5pY29kZVNpemU7XG4iLCJ2YXIgYmFzZUNsb25lID0gcmVxdWlyZSgnLi9fYmFzZUNsb25lJyk7XG5cbi8qKiBVc2VkIHRvIGNvbXBvc2UgYml0bWFza3MgZm9yIGNsb25pbmcuICovXG52YXIgQ0xPTkVfU1lNQk9MU19GTEFHID0gNDtcblxuLyoqXG4gKiBDcmVhdGVzIGEgc2hhbGxvdyBjbG9uZSBvZiBgdmFsdWVgLlxuICpcbiAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBpcyBsb29zZWx5IGJhc2VkIG9uIHRoZVxuICogW3N0cnVjdHVyZWQgY2xvbmUgYWxnb3JpdGhtXShodHRwczovL21kbi5pby9TdHJ1Y3R1cmVkX2Nsb25lX2FsZ29yaXRobSlcbiAqIGFuZCBzdXBwb3J0cyBjbG9uaW5nIGFycmF5cywgYXJyYXkgYnVmZmVycywgYm9vbGVhbnMsIGRhdGUgb2JqZWN0cywgbWFwcyxcbiAqIG51bWJlcnMsIGBPYmplY3RgIG9iamVjdHMsIHJlZ2V4ZXMsIHNldHMsIHN0cmluZ3MsIHN5bWJvbHMsIGFuZCB0eXBlZFxuICogYXJyYXlzLiBUaGUgb3duIGVudW1lcmFibGUgcHJvcGVydGllcyBvZiBgYXJndW1lbnRzYCBvYmplY3RzIGFyZSBjbG9uZWRcbiAqIGFzIHBsYWluIG9iamVjdHMuIEFuIGVtcHR5IG9iamVjdCBpcyByZXR1cm5lZCBmb3IgdW5jbG9uZWFibGUgdmFsdWVzIHN1Y2hcbiAqIGFzIGVycm9yIG9iamVjdHMsIGZ1bmN0aW9ucywgRE9NIG5vZGVzLCBhbmQgV2Vha01hcHMuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNsb25lLlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGNsb25lZCB2YWx1ZS5cbiAqIEBzZWUgXy5jbG9uZURlZXBcbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdHMgPSBbeyAnYSc6IDEgfSwgeyAnYic6IDIgfV07XG4gKlxuICogdmFyIHNoYWxsb3cgPSBfLmNsb25lKG9iamVjdHMpO1xuICogY29uc29sZS5sb2coc2hhbGxvd1swXSA9PT0gb2JqZWN0c1swXSk7XG4gKiAvLyA9PiB0cnVlXG4gKi9cbmZ1bmN0aW9uIGNsb25lKHZhbHVlKSB7XG4gIHJldHVybiBiYXNlQ2xvbmUodmFsdWUsIENMT05FX1NZTUJPTFNfRkxBRyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY2xvbmU7XG4iLCJ2YXIgYmFzZUNsb25lID0gcmVxdWlyZSgnLi9fYmFzZUNsb25lJyk7XG5cbi8qKiBVc2VkIHRvIGNvbXBvc2UgYml0bWFza3MgZm9yIGNsb25pbmcuICovXG52YXIgQ0xPTkVfREVFUF9GTEFHID0gMSxcbiAgICBDTE9ORV9TWU1CT0xTX0ZMQUcgPSA0O1xuXG4vKipcbiAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uY2xvbmVgIGV4Y2VwdCB0aGF0IGl0IHJlY3Vyc2l2ZWx5IGNsb25lcyBgdmFsdWVgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMS4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byByZWN1cnNpdmVseSBjbG9uZS5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBkZWVwIGNsb25lZCB2YWx1ZS5cbiAqIEBzZWUgXy5jbG9uZVxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0cyA9IFt7ICdhJzogMSB9LCB7ICdiJzogMiB9XTtcbiAqXG4gKiB2YXIgZGVlcCA9IF8uY2xvbmVEZWVwKG9iamVjdHMpO1xuICogY29uc29sZS5sb2coZGVlcFswXSA9PT0gb2JqZWN0c1swXSk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBjbG9uZURlZXAodmFsdWUpIHtcbiAgcmV0dXJuIGJhc2VDbG9uZSh2YWx1ZSwgQ0xPTkVfREVFUF9GTEFHIHwgQ0xPTkVfU1lNQk9MU19GTEFHKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjbG9uZURlZXA7XG4iLCIvKipcbiAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgYHZhbHVlYC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDIuNC4wXG4gKiBAY2F0ZWdvcnkgVXRpbFxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcmV0dXJuIGZyb20gdGhlIG5ldyBmdW5jdGlvbi5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGNvbnN0YW50IGZ1bmN0aW9uLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0cyA9IF8udGltZXMoMiwgXy5jb25zdGFudCh7ICdhJzogMSB9KSk7XG4gKlxuICogY29uc29sZS5sb2cob2JqZWN0cyk7XG4gKiAvLyA9PiBbeyAnYSc6IDEgfSwgeyAnYSc6IDEgfV1cbiAqXG4gKiBjb25zb2xlLmxvZyhvYmplY3RzWzBdID09PSBvYmplY3RzWzFdKTtcbiAqIC8vID0+IHRydWVcbiAqL1xuZnVuY3Rpb24gY29uc3RhbnQodmFsdWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjb25zdGFudDtcbiIsInZhciBiYXNlUmVzdCA9IHJlcXVpcmUoJy4vX2Jhc2VSZXN0JyksXG4gICAgZXEgPSByZXF1aXJlKCcuL2VxJyksXG4gICAgaXNJdGVyYXRlZUNhbGwgPSByZXF1aXJlKCcuL19pc0l0ZXJhdGVlQ2FsbCcpLFxuICAgIGtleXNJbiA9IHJlcXVpcmUoJy4va2V5c0luJyk7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogQXNzaWducyBvd24gYW5kIGluaGVyaXRlZCBlbnVtZXJhYmxlIHN0cmluZyBrZXllZCBwcm9wZXJ0aWVzIG9mIHNvdXJjZVxuICogb2JqZWN0cyB0byB0aGUgZGVzdGluYXRpb24gb2JqZWN0IGZvciBhbGwgZGVzdGluYXRpb24gcHJvcGVydGllcyB0aGF0XG4gKiByZXNvbHZlIHRvIGB1bmRlZmluZWRgLiBTb3VyY2Ugb2JqZWN0cyBhcmUgYXBwbGllZCBmcm9tIGxlZnQgdG8gcmlnaHQuXG4gKiBPbmNlIGEgcHJvcGVydHkgaXMgc2V0LCBhZGRpdGlvbmFsIHZhbHVlcyBvZiB0aGUgc2FtZSBwcm9wZXJ0eSBhcmUgaWdub3JlZC5cbiAqXG4gKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgbXV0YXRlcyBgb2JqZWN0YC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBtZW1iZXJPZiBfXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gKiBAcGFyYW0gey4uLk9iamVjdH0gW3NvdXJjZXNdIFRoZSBzb3VyY2Ugb2JqZWN0cy5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gKiBAc2VlIF8uZGVmYXVsdHNEZWVwXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uZGVmYXVsdHMoeyAnYSc6IDEgfSwgeyAnYic6IDIgfSwgeyAnYSc6IDMgfSk7XG4gKiAvLyA9PiB7ICdhJzogMSwgJ2InOiAyIH1cbiAqL1xudmFyIGRlZmF1bHRzID0gYmFzZVJlc3QoZnVuY3Rpb24ob2JqZWN0LCBzb3VyY2VzKSB7XG4gIG9iamVjdCA9IE9iamVjdChvYmplY3QpO1xuXG4gIHZhciBpbmRleCA9IC0xO1xuICB2YXIgbGVuZ3RoID0gc291cmNlcy5sZW5ndGg7XG4gIHZhciBndWFyZCA9IGxlbmd0aCA+IDIgPyBzb3VyY2VzWzJdIDogdW5kZWZpbmVkO1xuXG4gIGlmIChndWFyZCAmJiBpc0l0ZXJhdGVlQ2FsbChzb3VyY2VzWzBdLCBzb3VyY2VzWzFdLCBndWFyZCkpIHtcbiAgICBsZW5ndGggPSAxO1xuICB9XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIgc291cmNlID0gc291cmNlc1tpbmRleF07XG4gICAgdmFyIHByb3BzID0ga2V5c0luKHNvdXJjZSk7XG4gICAgdmFyIHByb3BzSW5kZXggPSAtMTtcbiAgICB2YXIgcHJvcHNMZW5ndGggPSBwcm9wcy5sZW5ndGg7XG5cbiAgICB3aGlsZSAoKytwcm9wc0luZGV4IDwgcHJvcHNMZW5ndGgpIHtcbiAgICAgIHZhciBrZXkgPSBwcm9wc1twcm9wc0luZGV4XTtcbiAgICAgIHZhciB2YWx1ZSA9IG9iamVjdFtrZXldO1xuXG4gICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCB8fFxuICAgICAgICAgIChlcSh2YWx1ZSwgb2JqZWN0UHJvdG9ba2V5XSkgJiYgIWhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBrZXkpKSkge1xuICAgICAgICBvYmplY3Rba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBvYmplY3Q7XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBkZWZhdWx0cztcbiIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9mb3JFYWNoJyk7XG4iLCIvKipcbiAqIFBlcmZvcm1zIGFcbiAqIFtgU2FtZVZhbHVlWmVyb2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXNhbWV2YWx1ZXplcm8pXG4gKiBjb21wYXJpc29uIGJldHdlZW4gdHdvIHZhbHVlcyB0byBkZXRlcm1pbmUgaWYgdGhleSBhcmUgZXF1aXZhbGVudC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7Kn0gb3RoZXIgVGhlIG90aGVyIHZhbHVlIHRvIGNvbXBhcmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHZhbHVlcyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0ID0geyAnYSc6IDEgfTtcbiAqIHZhciBvdGhlciA9IHsgJ2EnOiAxIH07XG4gKlxuICogXy5lcShvYmplY3QsIG9iamVjdCk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5lcShvYmplY3QsIG90aGVyKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5lcSgnYScsICdhJyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5lcSgnYScsIE9iamVjdCgnYScpKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5lcShOYU4sIE5hTik7XG4gKiAvLyA9PiB0cnVlXG4gKi9cbmZ1bmN0aW9uIGVxKHZhbHVlLCBvdGhlcikge1xuICByZXR1cm4gdmFsdWUgPT09IG90aGVyIHx8ICh2YWx1ZSAhPT0gdmFsdWUgJiYgb3RoZXIgIT09IG90aGVyKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBlcTtcbiIsInZhciBhcnJheUZpbHRlciA9IHJlcXVpcmUoJy4vX2FycmF5RmlsdGVyJyksXG4gICAgYmFzZUZpbHRlciA9IHJlcXVpcmUoJy4vX2Jhc2VGaWx0ZXInKSxcbiAgICBiYXNlSXRlcmF0ZWUgPSByZXF1aXJlKCcuL19iYXNlSXRlcmF0ZWUnKSxcbiAgICBpc0FycmF5ID0gcmVxdWlyZSgnLi9pc0FycmF5Jyk7XG5cbi8qKlxuICogSXRlcmF0ZXMgb3ZlciBlbGVtZW50cyBvZiBgY29sbGVjdGlvbmAsIHJldHVybmluZyBhbiBhcnJheSBvZiBhbGwgZWxlbWVudHNcbiAqIGBwcmVkaWNhdGVgIHJldHVybnMgdHJ1dGh5IGZvci4gVGhlIHByZWRpY2F0ZSBpcyBpbnZva2VkIHdpdGggdGhyZWVcbiAqIGFyZ3VtZW50czogKHZhbHVlLCBpbmRleHxrZXksIGNvbGxlY3Rpb24pLlxuICpcbiAqICoqTm90ZToqKiBVbmxpa2UgYF8ucmVtb3ZlYCwgdGhpcyBtZXRob2QgcmV0dXJucyBhIG5ldyBhcnJheS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW3ByZWRpY2F0ZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZmlsdGVyZWQgYXJyYXkuXG4gKiBAc2VlIF8ucmVqZWN0XG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciB1c2VycyA9IFtcbiAqICAgeyAndXNlcic6ICdiYXJuZXknLCAnYWdlJzogMzYsICdhY3RpdmUnOiB0cnVlIH0sXG4gKiAgIHsgJ3VzZXInOiAnZnJlZCcsICAgJ2FnZSc6IDQwLCAnYWN0aXZlJzogZmFsc2UgfVxuICogXTtcbiAqXG4gKiBfLmZpbHRlcih1c2VycywgZnVuY3Rpb24obykgeyByZXR1cm4gIW8uYWN0aXZlOyB9KTtcbiAqIC8vID0+IG9iamVjdHMgZm9yIFsnZnJlZCddXG4gKlxuICogLy8gVGhlIGBfLm1hdGNoZXNgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAqIF8uZmlsdGVyKHVzZXJzLCB7ICdhZ2UnOiAzNiwgJ2FjdGl2ZSc6IHRydWUgfSk7XG4gKiAvLyA9PiBvYmplY3RzIGZvciBbJ2Jhcm5leSddXG4gKlxuICogLy8gVGhlIGBfLm1hdGNoZXNQcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICogXy5maWx0ZXIodXNlcnMsIFsnYWN0aXZlJywgZmFsc2VdKTtcbiAqIC8vID0+IG9iamVjdHMgZm9yIFsnZnJlZCddXG4gKlxuICogLy8gVGhlIGBfLnByb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gKiBfLmZpbHRlcih1c2VycywgJ2FjdGl2ZScpO1xuICogLy8gPT4gb2JqZWN0cyBmb3IgWydiYXJuZXknXVxuICpcbiAqIC8vIENvbWJpbmluZyBzZXZlcmFsIHByZWRpY2F0ZXMgdXNpbmcgYF8ub3ZlckV2ZXJ5YCBvciBgXy5vdmVyU29tZWAuXG4gKiBfLmZpbHRlcih1c2VycywgXy5vdmVyU29tZShbeyAnYWdlJzogMzYgfSwgWydhZ2UnLCA0MF1dKSk7XG4gKiAvLyA9PiBvYmplY3RzIGZvciBbJ2ZyZWQnLCAnYmFybmV5J11cbiAqL1xuZnVuY3Rpb24gZmlsdGVyKGNvbGxlY3Rpb24sIHByZWRpY2F0ZSkge1xuICB2YXIgZnVuYyA9IGlzQXJyYXkoY29sbGVjdGlvbikgPyBhcnJheUZpbHRlciA6IGJhc2VGaWx0ZXI7XG4gIHJldHVybiBmdW5jKGNvbGxlY3Rpb24sIGJhc2VJdGVyYXRlZShwcmVkaWNhdGUsIDMpKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmaWx0ZXI7XG4iLCJ2YXIgY3JlYXRlRmluZCA9IHJlcXVpcmUoJy4vX2NyZWF0ZUZpbmQnKSxcbiAgICBmaW5kSW5kZXggPSByZXF1aXJlKCcuL2ZpbmRJbmRleCcpO1xuXG4vKipcbiAqIEl0ZXJhdGVzIG92ZXIgZWxlbWVudHMgb2YgYGNvbGxlY3Rpb25gLCByZXR1cm5pbmcgdGhlIGZpcnN0IGVsZW1lbnRcbiAqIGBwcmVkaWNhdGVgIHJldHVybnMgdHJ1dGh5IGZvci4gVGhlIHByZWRpY2F0ZSBpcyBpbnZva2VkIHdpdGggdGhyZWVcbiAqIGFyZ3VtZW50czogKHZhbHVlLCBpbmRleHxrZXksIGNvbGxlY3Rpb24pLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpbnNwZWN0LlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW3ByZWRpY2F0ZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHBhcmFtIHtudW1iZXJ9IFtmcm9tSW5kZXg9MF0gVGhlIGluZGV4IHRvIHNlYXJjaCBmcm9tLlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIG1hdGNoZWQgZWxlbWVudCwgZWxzZSBgdW5kZWZpbmVkYC5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIHVzZXJzID0gW1xuICogICB7ICd1c2VyJzogJ2Jhcm5leScsICAnYWdlJzogMzYsICdhY3RpdmUnOiB0cnVlIH0sXG4gKiAgIHsgJ3VzZXInOiAnZnJlZCcsICAgICdhZ2UnOiA0MCwgJ2FjdGl2ZSc6IGZhbHNlIH0sXG4gKiAgIHsgJ3VzZXInOiAncGViYmxlcycsICdhZ2UnOiAxLCAgJ2FjdGl2ZSc6IHRydWUgfVxuICogXTtcbiAqXG4gKiBfLmZpbmQodXNlcnMsIGZ1bmN0aW9uKG8pIHsgcmV0dXJuIG8uYWdlIDwgNDA7IH0pO1xuICogLy8gPT4gb2JqZWN0IGZvciAnYmFybmV5J1xuICpcbiAqIC8vIFRoZSBgXy5tYXRjaGVzYCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gKiBfLmZpbmQodXNlcnMsIHsgJ2FnZSc6IDEsICdhY3RpdmUnOiB0cnVlIH0pO1xuICogLy8gPT4gb2JqZWN0IGZvciAncGViYmxlcydcbiAqXG4gKiAvLyBUaGUgYF8ubWF0Y2hlc1Byb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gKiBfLmZpbmQodXNlcnMsIFsnYWN0aXZlJywgZmFsc2VdKTtcbiAqIC8vID0+IG9iamVjdCBmb3IgJ2ZyZWQnXG4gKlxuICogLy8gVGhlIGBfLnByb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gKiBfLmZpbmQodXNlcnMsICdhY3RpdmUnKTtcbiAqIC8vID0+IG9iamVjdCBmb3IgJ2Jhcm5leSdcbiAqL1xudmFyIGZpbmQgPSBjcmVhdGVGaW5kKGZpbmRJbmRleCk7XG5cbm1vZHVsZS5leHBvcnRzID0gZmluZDtcbiIsInZhciBiYXNlRmluZEluZGV4ID0gcmVxdWlyZSgnLi9fYmFzZUZpbmRJbmRleCcpLFxuICAgIGJhc2VJdGVyYXRlZSA9IHJlcXVpcmUoJy4vX2Jhc2VJdGVyYXRlZScpLFxuICAgIHRvSW50ZWdlciA9IHJlcXVpcmUoJy4vdG9JbnRlZ2VyJyk7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIGZvciB0aG9zZSB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgb3RoZXIgYGxvZGFzaGAgbWV0aG9kcy4gKi9cbnZhciBuYXRpdmVNYXggPSBNYXRoLm1heDtcblxuLyoqXG4gKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmZpbmRgIGV4Y2VwdCB0aGF0IGl0IHJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBmaXJzdFxuICogZWxlbWVudCBgcHJlZGljYXRlYCByZXR1cm5zIHRydXRoeSBmb3IgaW5zdGVhZCBvZiB0aGUgZWxlbWVudCBpdHNlbGYuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAxLjEuMFxuICogQGNhdGVnb3J5IEFycmF5XG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtwcmVkaWNhdGU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbZnJvbUluZGV4PTBdIFRoZSBpbmRleCB0byBzZWFyY2ggZnJvbS5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBmb3VuZCBlbGVtZW50LCBlbHNlIGAtMWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciB1c2VycyA9IFtcbiAqICAgeyAndXNlcic6ICdiYXJuZXknLCAgJ2FjdGl2ZSc6IGZhbHNlIH0sXG4gKiAgIHsgJ3VzZXInOiAnZnJlZCcsICAgICdhY3RpdmUnOiBmYWxzZSB9LFxuICogICB7ICd1c2VyJzogJ3BlYmJsZXMnLCAnYWN0aXZlJzogdHJ1ZSB9XG4gKiBdO1xuICpcbiAqIF8uZmluZEluZGV4KHVzZXJzLCBmdW5jdGlvbihvKSB7IHJldHVybiBvLnVzZXIgPT0gJ2Jhcm5leSc7IH0pO1xuICogLy8gPT4gMFxuICpcbiAqIC8vIFRoZSBgXy5tYXRjaGVzYCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gKiBfLmZpbmRJbmRleCh1c2VycywgeyAndXNlcic6ICdmcmVkJywgJ2FjdGl2ZSc6IGZhbHNlIH0pO1xuICogLy8gPT4gMVxuICpcbiAqIC8vIFRoZSBgXy5tYXRjaGVzUHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAqIF8uZmluZEluZGV4KHVzZXJzLCBbJ2FjdGl2ZScsIGZhbHNlXSk7XG4gKiAvLyA9PiAwXG4gKlxuICogLy8gVGhlIGBfLnByb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gKiBfLmZpbmRJbmRleCh1c2VycywgJ2FjdGl2ZScpO1xuICogLy8gPT4gMlxuICovXG5mdW5jdGlvbiBmaW5kSW5kZXgoYXJyYXksIHByZWRpY2F0ZSwgZnJvbUluZGV4KSB7XG4gIHZhciBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcbiAgaWYgKCFsZW5ndGgpIHtcbiAgICByZXR1cm4gLTE7XG4gIH1cbiAgdmFyIGluZGV4ID0gZnJvbUluZGV4ID09IG51bGwgPyAwIDogdG9JbnRlZ2VyKGZyb21JbmRleCk7XG4gIGlmIChpbmRleCA8IDApIHtcbiAgICBpbmRleCA9IG5hdGl2ZU1heChsZW5ndGggKyBpbmRleCwgMCk7XG4gIH1cbiAgcmV0dXJuIGJhc2VGaW5kSW5kZXgoYXJyYXksIGJhc2VJdGVyYXRlZShwcmVkaWNhdGUsIDMpLCBpbmRleCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZmluZEluZGV4O1xuIiwidmFyIGJhc2VGbGF0dGVuID0gcmVxdWlyZSgnLi9fYmFzZUZsYXR0ZW4nKTtcblxuLyoqXG4gKiBGbGF0dGVucyBgYXJyYXlgIGEgc2luZ2xlIGxldmVsIGRlZXAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IEFycmF5XG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gZmxhdHRlbi5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGZsYXR0ZW5lZCBhcnJheS5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5mbGF0dGVuKFsxLCBbMiwgWzMsIFs0XV0sIDVdXSk7XG4gKiAvLyA9PiBbMSwgMiwgWzMsIFs0XV0sIDVdXG4gKi9cbmZ1bmN0aW9uIGZsYXR0ZW4oYXJyYXkpIHtcbiAgdmFyIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuICByZXR1cm4gbGVuZ3RoID8gYmFzZUZsYXR0ZW4oYXJyYXksIDEpIDogW107XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZmxhdHRlbjtcbiIsInZhciBhcnJheUVhY2ggPSByZXF1aXJlKCcuL19hcnJheUVhY2gnKSxcbiAgICBiYXNlRWFjaCA9IHJlcXVpcmUoJy4vX2Jhc2VFYWNoJyksXG4gICAgY2FzdEZ1bmN0aW9uID0gcmVxdWlyZSgnLi9fY2FzdEZ1bmN0aW9uJyksXG4gICAgaXNBcnJheSA9IHJlcXVpcmUoJy4vaXNBcnJheScpO1xuXG4vKipcbiAqIEl0ZXJhdGVzIG92ZXIgZWxlbWVudHMgb2YgYGNvbGxlY3Rpb25gIGFuZCBpbnZva2VzIGBpdGVyYXRlZWAgZm9yIGVhY2ggZWxlbWVudC5cbiAqIFRoZSBpdGVyYXRlZSBpcyBpbnZva2VkIHdpdGggdGhyZWUgYXJndW1lbnRzOiAodmFsdWUsIGluZGV4fGtleSwgY29sbGVjdGlvbikuXG4gKiBJdGVyYXRlZSBmdW5jdGlvbnMgbWF5IGV4aXQgaXRlcmF0aW9uIGVhcmx5IGJ5IGV4cGxpY2l0bHkgcmV0dXJuaW5nIGBmYWxzZWAuXG4gKlxuICogKipOb3RlOioqIEFzIHdpdGggb3RoZXIgXCJDb2xsZWN0aW9uc1wiIG1ldGhvZHMsIG9iamVjdHMgd2l0aCBhIFwibGVuZ3RoXCJcbiAqIHByb3BlcnR5IGFyZSBpdGVyYXRlZCBsaWtlIGFycmF5cy4gVG8gYXZvaWQgdGhpcyBiZWhhdmlvciB1c2UgYF8uZm9ySW5gXG4gKiBvciBgXy5mb3JPd25gIGZvciBvYmplY3QgaXRlcmF0aW9uLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBhbGlhcyBlYWNoXG4gKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcmV0dXJucyB7QXJyYXl8T2JqZWN0fSBSZXR1cm5zIGBjb2xsZWN0aW9uYC5cbiAqIEBzZWUgXy5mb3JFYWNoUmlnaHRcbiAqIEBleGFtcGxlXG4gKlxuICogXy5mb3JFYWNoKFsxLCAyXSwgZnVuY3Rpb24odmFsdWUpIHtcbiAqICAgY29uc29sZS5sb2codmFsdWUpO1xuICogfSk7XG4gKiAvLyA9PiBMb2dzIGAxYCB0aGVuIGAyYC5cbiAqXG4gKiBfLmZvckVhY2goeyAnYSc6IDEsICdiJzogMiB9LCBmdW5jdGlvbih2YWx1ZSwga2V5KSB7XG4gKiAgIGNvbnNvbGUubG9nKGtleSk7XG4gKiB9KTtcbiAqIC8vID0+IExvZ3MgJ2EnIHRoZW4gJ2InIChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpLlxuICovXG5mdW5jdGlvbiBmb3JFYWNoKGNvbGxlY3Rpb24sIGl0ZXJhdGVlKSB7XG4gIHZhciBmdW5jID0gaXNBcnJheShjb2xsZWN0aW9uKSA/IGFycmF5RWFjaCA6IGJhc2VFYWNoO1xuICByZXR1cm4gZnVuYyhjb2xsZWN0aW9uLCBjYXN0RnVuY3Rpb24oaXRlcmF0ZWUpKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmb3JFYWNoO1xuIiwidmFyIGJhc2VGb3IgPSByZXF1aXJlKCcuL19iYXNlRm9yJyksXG4gICAgY2FzdEZ1bmN0aW9uID0gcmVxdWlyZSgnLi9fY2FzdEZ1bmN0aW9uJyksXG4gICAga2V5c0luID0gcmVxdWlyZSgnLi9rZXlzSW4nKTtcblxuLyoqXG4gKiBJdGVyYXRlcyBvdmVyIG93biBhbmQgaW5oZXJpdGVkIGVudW1lcmFibGUgc3RyaW5nIGtleWVkIHByb3BlcnRpZXMgb2YgYW5cbiAqIG9iamVjdCBhbmQgaW52b2tlcyBgaXRlcmF0ZWVgIGZvciBlYWNoIHByb3BlcnR5LiBUaGUgaXRlcmF0ZWUgaXMgaW52b2tlZFxuICogd2l0aCB0aHJlZSBhcmd1bWVudHM6ICh2YWx1ZSwga2V5LCBvYmplY3QpLiBJdGVyYXRlZSBmdW5jdGlvbnMgbWF5IGV4aXRcbiAqIGl0ZXJhdGlvbiBlYXJseSBieSBleHBsaWNpdGx5IHJldHVybmluZyBgZmFsc2VgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4zLjBcbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gKiBAc2VlIF8uZm9ySW5SaWdodFxuICogQGV4YW1wbGVcbiAqXG4gKiBmdW5jdGlvbiBGb28oKSB7XG4gKiAgIHRoaXMuYSA9IDE7XG4gKiAgIHRoaXMuYiA9IDI7XG4gKiB9XG4gKlxuICogRm9vLnByb3RvdHlwZS5jID0gMztcbiAqXG4gKiBfLmZvckluKG5ldyBGb28sIGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHtcbiAqICAgY29uc29sZS5sb2coa2V5KTtcbiAqIH0pO1xuICogLy8gPT4gTG9ncyAnYScsICdiJywgdGhlbiAnYycgKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZCkuXG4gKi9cbmZ1bmN0aW9uIGZvckluKG9iamVjdCwgaXRlcmF0ZWUpIHtcbiAgcmV0dXJuIG9iamVjdCA9PSBudWxsXG4gICAgPyBvYmplY3RcbiAgICA6IGJhc2VGb3Iob2JqZWN0LCBjYXN0RnVuY3Rpb24oaXRlcmF0ZWUpLCBrZXlzSW4pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZvckluO1xuIiwidmFyIGJhc2VHZXQgPSByZXF1aXJlKCcuL19iYXNlR2V0Jyk7XG5cbi8qKlxuICogR2V0cyB0aGUgdmFsdWUgYXQgYHBhdGhgIG9mIGBvYmplY3RgLiBJZiB0aGUgcmVzb2x2ZWQgdmFsdWUgaXNcbiAqIGB1bmRlZmluZWRgLCB0aGUgYGRlZmF1bHRWYWx1ZWAgaXMgcmV0dXJuZWQgaW4gaXRzIHBsYWNlLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMy43LjBcbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gKiBAcGFyYW0geyp9IFtkZWZhdWx0VmFsdWVdIFRoZSB2YWx1ZSByZXR1cm5lZCBmb3IgYHVuZGVmaW5lZGAgcmVzb2x2ZWQgdmFsdWVzLlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHJlc29sdmVkIHZhbHVlLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0ID0geyAnYSc6IFt7ICdiJzogeyAnYyc6IDMgfSB9XSB9O1xuICpcbiAqIF8uZ2V0KG9iamVjdCwgJ2FbMF0uYi5jJyk7XG4gKiAvLyA9PiAzXG4gKlxuICogXy5nZXQob2JqZWN0LCBbJ2EnLCAnMCcsICdiJywgJ2MnXSk7XG4gKiAvLyA9PiAzXG4gKlxuICogXy5nZXQob2JqZWN0LCAnYS5iLmMnLCAnZGVmYXVsdCcpO1xuICogLy8gPT4gJ2RlZmF1bHQnXG4gKi9cbmZ1bmN0aW9uIGdldChvYmplY3QsIHBhdGgsIGRlZmF1bHRWYWx1ZSkge1xuICB2YXIgcmVzdWx0ID0gb2JqZWN0ID09IG51bGwgPyB1bmRlZmluZWQgOiBiYXNlR2V0KG9iamVjdCwgcGF0aCk7XG4gIHJldHVybiByZXN1bHQgPT09IHVuZGVmaW5lZCA/IGRlZmF1bHRWYWx1ZSA6IHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZXQ7XG4iLCJ2YXIgYmFzZUhhcyA9IHJlcXVpcmUoJy4vX2Jhc2VIYXMnKSxcbiAgICBoYXNQYXRoID0gcmVxdWlyZSgnLi9faGFzUGF0aCcpO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgcGF0aGAgaXMgYSBkaXJlY3QgcHJvcGVydHkgb2YgYG9iamVjdGAuXG4gKlxuICogQHN0YXRpY1xuICogQHNpbmNlIDAuMS4wXG4gKiBAbWVtYmVyT2YgX1xuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHBhdGhgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0ID0geyAnYSc6IHsgJ2InOiAyIH0gfTtcbiAqIHZhciBvdGhlciA9IF8uY3JlYXRlKHsgJ2EnOiBfLmNyZWF0ZSh7ICdiJzogMiB9KSB9KTtcbiAqXG4gKiBfLmhhcyhvYmplY3QsICdhJyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5oYXMob2JqZWN0LCAnYS5iJyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5oYXMob2JqZWN0LCBbJ2EnLCAnYiddKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmhhcyhvdGhlciwgJ2EnKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGhhcyhvYmplY3QsIHBhdGgpIHtcbiAgcmV0dXJuIG9iamVjdCAhPSBudWxsICYmIGhhc1BhdGgob2JqZWN0LCBwYXRoLCBiYXNlSGFzKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBoYXM7XG4iLCJ2YXIgYmFzZUhhc0luID0gcmVxdWlyZSgnLi9fYmFzZUhhc0luJyksXG4gICAgaGFzUGF0aCA9IHJlcXVpcmUoJy4vX2hhc1BhdGgnKTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHBhdGhgIGlzIGEgZGlyZWN0IG9yIGluaGVyaXRlZCBwcm9wZXJ0eSBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgcGF0aGAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3QgPSBfLmNyZWF0ZSh7ICdhJzogXy5jcmVhdGUoeyAnYic6IDIgfSkgfSk7XG4gKlxuICogXy5oYXNJbihvYmplY3QsICdhJyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5oYXNJbihvYmplY3QsICdhLmInKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmhhc0luKG9iamVjdCwgWydhJywgJ2InXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5oYXNJbihvYmplY3QsICdiJyk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBoYXNJbihvYmplY3QsIHBhdGgpIHtcbiAgcmV0dXJuIG9iamVjdCAhPSBudWxsICYmIGhhc1BhdGgob2JqZWN0LCBwYXRoLCBiYXNlSGFzSW4pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGhhc0luO1xuIiwiLyoqXG4gKiBUaGlzIG1ldGhvZCByZXR1cm5zIHRoZSBmaXJzdCBhcmd1bWVudCBpdCByZWNlaXZlcy5cbiAqXG4gKiBAc3RhdGljXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBtZW1iZXJPZiBfXG4gKiBAY2F0ZWdvcnkgVXRpbFxuICogQHBhcmFtIHsqfSB2YWx1ZSBBbnkgdmFsdWUuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyBgdmFsdWVgLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0ID0geyAnYSc6IDEgfTtcbiAqXG4gKiBjb25zb2xlLmxvZyhfLmlkZW50aXR5KG9iamVjdCkgPT09IG9iamVjdCk7XG4gKiAvLyA9PiB0cnVlXG4gKi9cbmZ1bmN0aW9uIGlkZW50aXR5KHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpZGVudGl0eTtcbiIsInZhciBiYXNlSXNBcmd1bWVudHMgPSByZXF1aXJlKCcuL19iYXNlSXNBcmd1bWVudHMnKSxcbiAgICBpc09iamVjdExpa2UgPSByZXF1aXJlKCcuL2lzT2JqZWN0TGlrZScpO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBwcm9wZXJ0eUlzRW51bWVyYWJsZSA9IG9iamVjdFByb3RvLnByb3BlcnR5SXNFbnVtZXJhYmxlO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGxpa2VseSBhbiBgYXJndW1lbnRzYCBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gYGFyZ3VtZW50c2Agb2JqZWN0LFxuICogIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0FyZ3VtZW50cyhmdW5jdGlvbigpIHsgcmV0dXJuIGFyZ3VtZW50czsgfSgpKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJndW1lbnRzKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG52YXIgaXNBcmd1bWVudHMgPSBiYXNlSXNBcmd1bWVudHMoZnVuY3Rpb24oKSB7IHJldHVybiBhcmd1bWVudHM7IH0oKSkgPyBiYXNlSXNBcmd1bWVudHMgOiBmdW5jdGlvbih2YWx1ZSkge1xuICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCAnY2FsbGVlJykgJiZcbiAgICAhcHJvcGVydHlJc0VudW1lcmFibGUuY2FsbCh2YWx1ZSwgJ2NhbGxlZScpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBpc0FyZ3VtZW50cztcbiIsIi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhbiBgQXJyYXlgIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBhcnJheSwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzQXJyYXkoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXkoZG9jdW1lbnQuYm9keS5jaGlsZHJlbik7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNBcnJheSgnYWJjJyk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNBcnJheShfLm5vb3ApO1xuICogLy8gPT4gZmFsc2VcbiAqL1xudmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGlzQXJyYXk7XG4iLCJ2YXIgaXNGdW5jdGlvbiA9IHJlcXVpcmUoJy4vaXNGdW5jdGlvbicpLFxuICAgIGlzTGVuZ3RoID0gcmVxdWlyZSgnLi9pc0xlbmd0aCcpO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGFycmF5LWxpa2UuIEEgdmFsdWUgaXMgY29uc2lkZXJlZCBhcnJheS1saWtlIGlmIGl0J3NcbiAqIG5vdCBhIGZ1bmN0aW9uIGFuZCBoYXMgYSBgdmFsdWUubGVuZ3RoYCB0aGF0J3MgYW4gaW50ZWdlciBncmVhdGVyIHRoYW4gb3JcbiAqIGVxdWFsIHRvIGAwYCBhbmQgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIGBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUmAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYXJyYXktbGlrZSwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5TGlrZShkb2N1bWVudC5ib2R5LmNoaWxkcmVuKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlKCdhYmMnKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlKF8ubm9vcCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0FycmF5TGlrZSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgIT0gbnVsbCAmJiBpc0xlbmd0aCh2YWx1ZS5sZW5ndGgpICYmICFpc0Z1bmN0aW9uKHZhbHVlKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc0FycmF5TGlrZTtcbiIsInZhciBpc0FycmF5TGlrZSA9IHJlcXVpcmUoJy4vaXNBcnJheUxpa2UnKSxcbiAgICBpc09iamVjdExpa2UgPSByZXF1aXJlKCcuL2lzT2JqZWN0TGlrZScpO1xuXG4vKipcbiAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uaXNBcnJheUxpa2VgIGV4Y2VwdCB0aGF0IGl0IGFsc28gY2hlY2tzIGlmIGB2YWx1ZWBcbiAqIGlzIGFuIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBhcnJheS1saWtlIG9iamVjdCxcbiAqICBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNBcnJheUxpa2VPYmplY3QoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlT2JqZWN0KGRvY3VtZW50LmJvZHkuY2hpbGRyZW4pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheUxpa2VPYmplY3QoJ2FiYycpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzQXJyYXlMaWtlT2JqZWN0KF8ubm9vcCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0FycmF5TGlrZU9iamVjdCh2YWx1ZSkge1xuICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBpc0FycmF5TGlrZSh2YWx1ZSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNBcnJheUxpa2VPYmplY3Q7XG4iLCJ2YXIgcm9vdCA9IHJlcXVpcmUoJy4vX3Jvb3QnKSxcbiAgICBzdHViRmFsc2UgPSByZXF1aXJlKCcuL3N0dWJGYWxzZScpO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGV4cG9ydHNgLiAqL1xudmFyIGZyZWVFeHBvcnRzID0gdHlwZW9mIGV4cG9ydHMgPT0gJ29iamVjdCcgJiYgZXhwb3J0cyAmJiAhZXhwb3J0cy5ub2RlVHlwZSAmJiBleHBvcnRzO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYG1vZHVsZWAuICovXG52YXIgZnJlZU1vZHVsZSA9IGZyZWVFeHBvcnRzICYmIHR5cGVvZiBtb2R1bGUgPT0gJ29iamVjdCcgJiYgbW9kdWxlICYmICFtb2R1bGUubm9kZVR5cGUgJiYgbW9kdWxlO1xuXG4vKiogRGV0ZWN0IHRoZSBwb3B1bGFyIENvbW1vbkpTIGV4dGVuc2lvbiBgbW9kdWxlLmV4cG9ydHNgLiAqL1xudmFyIG1vZHVsZUV4cG9ydHMgPSBmcmVlTW9kdWxlICYmIGZyZWVNb2R1bGUuZXhwb3J0cyA9PT0gZnJlZUV4cG9ydHM7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIEJ1ZmZlciA9IG1vZHVsZUV4cG9ydHMgPyByb290LkJ1ZmZlciA6IHVuZGVmaW5lZDtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgZm9yIHRob3NlIHdpdGggdGhlIHNhbWUgbmFtZSBhcyBvdGhlciBgbG9kYXNoYCBtZXRob2RzLiAqL1xudmFyIG5hdGl2ZUlzQnVmZmVyID0gQnVmZmVyID8gQnVmZmVyLmlzQnVmZmVyIDogdW5kZWZpbmVkO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgYnVmZmVyLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4zLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgYnVmZmVyLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNCdWZmZXIobmV3IEJ1ZmZlcigyKSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0J1ZmZlcihuZXcgVWludDhBcnJheSgyKSk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG52YXIgaXNCdWZmZXIgPSBuYXRpdmVJc0J1ZmZlciB8fCBzdHViRmFsc2U7XG5cbm1vZHVsZS5leHBvcnRzID0gaXNCdWZmZXI7XG4iLCJ2YXIgYmFzZUtleXMgPSByZXF1aXJlKCcuL19iYXNlS2V5cycpLFxuICAgIGdldFRhZyA9IHJlcXVpcmUoJy4vX2dldFRhZycpLFxuICAgIGlzQXJndW1lbnRzID0gcmVxdWlyZSgnLi9pc0FyZ3VtZW50cycpLFxuICAgIGlzQXJyYXkgPSByZXF1aXJlKCcuL2lzQXJyYXknKSxcbiAgICBpc0FycmF5TGlrZSA9IHJlcXVpcmUoJy4vaXNBcnJheUxpa2UnKSxcbiAgICBpc0J1ZmZlciA9IHJlcXVpcmUoJy4vaXNCdWZmZXInKSxcbiAgICBpc1Byb3RvdHlwZSA9IHJlcXVpcmUoJy4vX2lzUHJvdG90eXBlJyksXG4gICAgaXNUeXBlZEFycmF5ID0gcmVxdWlyZSgnLi9pc1R5cGVkQXJyYXknKTtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIG1hcFRhZyA9ICdbb2JqZWN0IE1hcF0nLFxuICAgIHNldFRhZyA9ICdbb2JqZWN0IFNldF0nO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGFuIGVtcHR5IG9iamVjdCwgY29sbGVjdGlvbiwgbWFwLCBvciBzZXQuXG4gKlxuICogT2JqZWN0cyBhcmUgY29uc2lkZXJlZCBlbXB0eSBpZiB0aGV5IGhhdmUgbm8gb3duIGVudW1lcmFibGUgc3RyaW5nIGtleWVkXG4gKiBwcm9wZXJ0aWVzLlxuICpcbiAqIEFycmF5LWxpa2UgdmFsdWVzIHN1Y2ggYXMgYGFyZ3VtZW50c2Agb2JqZWN0cywgYXJyYXlzLCBidWZmZXJzLCBzdHJpbmdzLCBvclxuICogalF1ZXJ5LWxpa2UgY29sbGVjdGlvbnMgYXJlIGNvbnNpZGVyZWQgZW1wdHkgaWYgdGhleSBoYXZlIGEgYGxlbmd0aGAgb2YgYDBgLlxuICogU2ltaWxhcmx5LCBtYXBzIGFuZCBzZXRzIGFyZSBjb25zaWRlcmVkIGVtcHR5IGlmIHRoZXkgaGF2ZSBhIGBzaXplYCBvZiBgMGAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgZW1wdHksIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0VtcHR5KG51bGwpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNFbXB0eSh0cnVlKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzRW1wdHkoMSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0VtcHR5KFsxLCAyLCAzXSk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNFbXB0eSh7ICdhJzogMSB9KTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzRW1wdHkodmFsdWUpIHtcbiAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAoaXNBcnJheUxpa2UodmFsdWUpICYmXG4gICAgICAoaXNBcnJheSh2YWx1ZSkgfHwgdHlwZW9mIHZhbHVlID09ICdzdHJpbmcnIHx8IHR5cGVvZiB2YWx1ZS5zcGxpY2UgPT0gJ2Z1bmN0aW9uJyB8fFxuICAgICAgICBpc0J1ZmZlcih2YWx1ZSkgfHwgaXNUeXBlZEFycmF5KHZhbHVlKSB8fCBpc0FyZ3VtZW50cyh2YWx1ZSkpKSB7XG4gICAgcmV0dXJuICF2YWx1ZS5sZW5ndGg7XG4gIH1cbiAgdmFyIHRhZyA9IGdldFRhZyh2YWx1ZSk7XG4gIGlmICh0YWcgPT0gbWFwVGFnIHx8IHRhZyA9PSBzZXRUYWcpIHtcbiAgICByZXR1cm4gIXZhbHVlLnNpemU7XG4gIH1cbiAgaWYgKGlzUHJvdG90eXBlKHZhbHVlKSkge1xuICAgIHJldHVybiAhYmFzZUtleXModmFsdWUpLmxlbmd0aDtcbiAgfVxuICBmb3IgKHZhciBrZXkgaW4gdmFsdWUpIHtcbiAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwga2V5KSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc0VtcHR5O1xuIiwidmFyIGJhc2VHZXRUYWcgPSByZXF1aXJlKCcuL19iYXNlR2V0VGFnJyksXG4gICAgaXNPYmplY3QgPSByZXF1aXJlKCcuL2lzT2JqZWN0Jyk7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBhc3luY1RhZyA9ICdbb2JqZWN0IEFzeW5jRnVuY3Rpb25dJyxcbiAgICBmdW5jVGFnID0gJ1tvYmplY3QgRnVuY3Rpb25dJyxcbiAgICBnZW5UYWcgPSAnW29iamVjdCBHZW5lcmF0b3JGdW5jdGlvbl0nLFxuICAgIHByb3h5VGFnID0gJ1tvYmplY3QgUHJveHldJztcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYEZ1bmN0aW9uYCBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBmdW5jdGlvbiwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzRnVuY3Rpb24oXyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0Z1bmN0aW9uKC9hYmMvKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzRnVuY3Rpb24odmFsdWUpIHtcbiAgaWYgKCFpc09iamVjdCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgLy8gVGhlIHVzZSBvZiBgT2JqZWN0I3RvU3RyaW5nYCBhdm9pZHMgaXNzdWVzIHdpdGggdGhlIGB0eXBlb2ZgIG9wZXJhdG9yXG4gIC8vIGluIFNhZmFyaSA5IHdoaWNoIHJldHVybnMgJ29iamVjdCcgZm9yIHR5cGVkIGFycmF5cyBhbmQgb3RoZXIgY29uc3RydWN0b3JzLlxuICB2YXIgdGFnID0gYmFzZUdldFRhZyh2YWx1ZSk7XG4gIHJldHVybiB0YWcgPT0gZnVuY1RhZyB8fCB0YWcgPT0gZ2VuVGFnIHx8IHRhZyA9PSBhc3luY1RhZyB8fCB0YWcgPT0gcHJveHlUYWc7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNGdW5jdGlvbjtcbiIsIi8qKiBVc2VkIGFzIHJlZmVyZW5jZXMgZm9yIHZhcmlvdXMgYE51bWJlcmAgY29uc3RhbnRzLiAqL1xudmFyIE1BWF9TQUZFX0lOVEVHRVIgPSA5MDA3MTk5MjU0NzQwOTkxO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgYXJyYXktbGlrZSBsZW5ndGguXG4gKlxuICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGlzIGxvb3NlbHkgYmFzZWQgb25cbiAqIFtgVG9MZW5ndGhgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy10b2xlbmd0aCkuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBsZW5ndGgsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0xlbmd0aCgzKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzTGVuZ3RoKE51bWJlci5NSU5fVkFMVUUpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzTGVuZ3RoKEluZmluaXR5KTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0xlbmd0aCgnMycpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNMZW5ndGgodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnbnVtYmVyJyAmJlxuICAgIHZhbHVlID4gLTEgJiYgdmFsdWUgJSAxID09IDAgJiYgdmFsdWUgPD0gTUFYX1NBRkVfSU5URUdFUjtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc0xlbmd0aDtcbiIsInZhciBiYXNlSXNNYXAgPSByZXF1aXJlKCcuL19iYXNlSXNNYXAnKSxcbiAgICBiYXNlVW5hcnkgPSByZXF1aXJlKCcuL19iYXNlVW5hcnknKSxcbiAgICBub2RlVXRpbCA9IHJlcXVpcmUoJy4vX25vZGVVdGlsJyk7XG5cbi8qIE5vZGUuanMgaGVscGVyIHJlZmVyZW5jZXMuICovXG52YXIgbm9kZUlzTWFwID0gbm9kZVV0aWwgJiYgbm9kZVV0aWwuaXNNYXA7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBNYXBgIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMy4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIG1hcCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzTWFwKG5ldyBNYXApO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNNYXAobmV3IFdlYWtNYXApO1xuICogLy8gPT4gZmFsc2VcbiAqL1xudmFyIGlzTWFwID0gbm9kZUlzTWFwID8gYmFzZVVuYXJ5KG5vZGVJc01hcCkgOiBiYXNlSXNNYXA7XG5cbm1vZHVsZS5leHBvcnRzID0gaXNNYXA7XG4iLCIvKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIHRoZVxuICogW2xhbmd1YWdlIHR5cGVdKGh0dHA6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1lY21hc2NyaXB0LWxhbmd1YWdlLXR5cGVzKVxuICogb2YgYE9iamVjdGAuIChlLmcuIGFycmF5cywgZnVuY3Rpb25zLCBvYmplY3RzLCByZWdleGVzLCBgbmV3IE51bWJlcigwKWAsIGFuZCBgbmV3IFN0cmluZygnJylgKVxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzT2JqZWN0KHt9KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdChfLm5vb3ApO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QobnVsbCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc09iamVjdCh2YWx1ZSkge1xuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgcmV0dXJuIHZhbHVlICE9IG51bGwgJiYgKHR5cGUgPT0gJ29iamVjdCcgfHwgdHlwZSA9PSAnZnVuY3Rpb24nKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc09iamVjdDtcbiIsIi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UuIEEgdmFsdWUgaXMgb2JqZWN0LWxpa2UgaWYgaXQncyBub3QgYG51bGxgXG4gKiBhbmQgaGFzIGEgYHR5cGVvZmAgcmVzdWx0IG9mIFwib2JqZWN0XCIuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc09iamVjdExpa2Uoe30pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdExpa2UoXy5ub29wKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc09iamVjdExpa2UobnVsbCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc09iamVjdExpa2UodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlICE9IG51bGwgJiYgdHlwZW9mIHZhbHVlID09ICdvYmplY3QnO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzT2JqZWN0TGlrZTtcbiIsInZhciBiYXNlR2V0VGFnID0gcmVxdWlyZSgnLi9fYmFzZUdldFRhZycpLFxuICAgIGdldFByb3RvdHlwZSA9IHJlcXVpcmUoJy4vX2dldFByb3RvdHlwZScpLFxuICAgIGlzT2JqZWN0TGlrZSA9IHJlcXVpcmUoJy4vaXNPYmplY3RMaWtlJyk7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RUYWcgPSAnW29iamVjdCBPYmplY3RdJztcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIGZ1bmNQcm90byA9IEZ1bmN0aW9uLnByb3RvdHlwZSxcbiAgICBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIHJlc29sdmUgdGhlIGRlY29tcGlsZWQgc291cmNlIG9mIGZ1bmN0aW9ucy4gKi9cbnZhciBmdW5jVG9TdHJpbmcgPSBmdW5jUHJvdG8udG9TdHJpbmc7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKiBVc2VkIHRvIGluZmVyIHRoZSBgT2JqZWN0YCBjb25zdHJ1Y3Rvci4gKi9cbnZhciBvYmplY3RDdG9yU3RyaW5nID0gZnVuY1RvU3RyaW5nLmNhbGwoT2JqZWN0KTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHBsYWluIG9iamVjdCwgdGhhdCBpcywgYW4gb2JqZWN0IGNyZWF0ZWQgYnkgdGhlXG4gKiBgT2JqZWN0YCBjb25zdHJ1Y3RvciBvciBvbmUgd2l0aCBhIGBbW1Byb3RvdHlwZV1dYCBvZiBgbnVsbGAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjguMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBwbGFpbiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogZnVuY3Rpb24gRm9vKCkge1xuICogICB0aGlzLmEgPSAxO1xuICogfVxuICpcbiAqIF8uaXNQbGFpbk9iamVjdChuZXcgRm9vKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc1BsYWluT2JqZWN0KFsxLCAyLCAzXSk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNQbGFpbk9iamVjdCh7ICd4JzogMCwgJ3knOiAwIH0pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNQbGFpbk9iamVjdChPYmplY3QuY3JlYXRlKG51bGwpKTtcbiAqIC8vID0+IHRydWVcbiAqL1xuZnVuY3Rpb24gaXNQbGFpbk9iamVjdCh2YWx1ZSkge1xuICBpZiAoIWlzT2JqZWN0TGlrZSh2YWx1ZSkgfHwgYmFzZUdldFRhZyh2YWx1ZSkgIT0gb2JqZWN0VGFnKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciBwcm90byA9IGdldFByb3RvdHlwZSh2YWx1ZSk7XG4gIGlmIChwcm90byA9PT0gbnVsbCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHZhciBDdG9yID0gaGFzT3duUHJvcGVydHkuY2FsbChwcm90bywgJ2NvbnN0cnVjdG9yJykgJiYgcHJvdG8uY29uc3RydWN0b3I7XG4gIHJldHVybiB0eXBlb2YgQ3RvciA9PSAnZnVuY3Rpb24nICYmIEN0b3IgaW5zdGFuY2VvZiBDdG9yICYmXG4gICAgZnVuY1RvU3RyaW5nLmNhbGwoQ3RvcikgPT0gb2JqZWN0Q3RvclN0cmluZztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc1BsYWluT2JqZWN0O1xuIiwidmFyIGJhc2VJc1NldCA9IHJlcXVpcmUoJy4vX2Jhc2VJc1NldCcpLFxuICAgIGJhc2VVbmFyeSA9IHJlcXVpcmUoJy4vX2Jhc2VVbmFyeScpLFxuICAgIG5vZGVVdGlsID0gcmVxdWlyZSgnLi9fbm9kZVV0aWwnKTtcblxuLyogTm9kZS5qcyBoZWxwZXIgcmVmZXJlbmNlcy4gKi9cbnZhciBub2RlSXNTZXQgPSBub2RlVXRpbCAmJiBub2RlVXRpbC5pc1NldDtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYFNldGAgb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4zLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgc2V0LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNTZXQobmV3IFNldCk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc1NldChuZXcgV2Vha1NldCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG52YXIgaXNTZXQgPSBub2RlSXNTZXQgPyBiYXNlVW5hcnkobm9kZUlzU2V0KSA6IGJhc2VJc1NldDtcblxubW9kdWxlLmV4cG9ydHMgPSBpc1NldDtcbiIsInZhciBiYXNlR2V0VGFnID0gcmVxdWlyZSgnLi9fYmFzZUdldFRhZycpLFxuICAgIGlzQXJyYXkgPSByZXF1aXJlKCcuL2lzQXJyYXknKSxcbiAgICBpc09iamVjdExpa2UgPSByZXF1aXJlKCcuL2lzT2JqZWN0TGlrZScpO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgc3RyaW5nVGFnID0gJ1tvYmplY3QgU3RyaW5nXSc7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBTdHJpbmdgIHByaW1pdGl2ZSBvciBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQHNpbmNlIDAuMS4wXG4gKiBAbWVtYmVyT2YgX1xuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBzdHJpbmcsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc1N0cmluZygnYWJjJyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc1N0cmluZygxKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzU3RyaW5nKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ3N0cmluZycgfHxcbiAgICAoIWlzQXJyYXkodmFsdWUpICYmIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgYmFzZUdldFRhZyh2YWx1ZSkgPT0gc3RyaW5nVGFnKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc1N0cmluZztcbiIsInZhciBiYXNlR2V0VGFnID0gcmVxdWlyZSgnLi9fYmFzZUdldFRhZycpLFxuICAgIGlzT2JqZWN0TGlrZSA9IHJlcXVpcmUoJy4vaXNPYmplY3RMaWtlJyk7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBzeW1ib2xUYWcgPSAnW29iamVjdCBTeW1ib2xdJztcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYFN5bWJvbGAgcHJpbWl0aXZlIG9yIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHN5bWJvbCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzU3ltYm9sKFN5bWJvbC5pdGVyYXRvcik7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc1N5bWJvbCgnYWJjJyk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc1N5bWJvbCh2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09ICdzeW1ib2wnIHx8XG4gICAgKGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgYmFzZUdldFRhZyh2YWx1ZSkgPT0gc3ltYm9sVGFnKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc1N5bWJvbDtcbiIsInZhciBiYXNlSXNUeXBlZEFycmF5ID0gcmVxdWlyZSgnLi9fYmFzZUlzVHlwZWRBcnJheScpLFxuICAgIGJhc2VVbmFyeSA9IHJlcXVpcmUoJy4vX2Jhc2VVbmFyeScpLFxuICAgIG5vZGVVdGlsID0gcmVxdWlyZSgnLi9fbm9kZVV0aWwnKTtcblxuLyogTm9kZS5qcyBoZWxwZXIgcmVmZXJlbmNlcy4gKi9cbnZhciBub2RlSXNUeXBlZEFycmF5ID0gbm9kZVV0aWwgJiYgbm9kZVV0aWwuaXNUeXBlZEFycmF5O1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSB0eXBlZCBhcnJheS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDMuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHR5cGVkIGFycmF5LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNUeXBlZEFycmF5KG5ldyBVaW50OEFycmF5KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzVHlwZWRBcnJheShbXSk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG52YXIgaXNUeXBlZEFycmF5ID0gbm9kZUlzVHlwZWRBcnJheSA/IGJhc2VVbmFyeShub2RlSXNUeXBlZEFycmF5KSA6IGJhc2VJc1R5cGVkQXJyYXk7XG5cbm1vZHVsZS5leHBvcnRzID0gaXNUeXBlZEFycmF5O1xuIiwiLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBgdW5kZWZpbmVkYC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBtZW1iZXJPZiBfXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBgdW5kZWZpbmVkYCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzVW5kZWZpbmVkKHZvaWQgMCk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc1VuZGVmaW5lZChudWxsKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzVW5kZWZpbmVkKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSA9PT0gdW5kZWZpbmVkO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzVW5kZWZpbmVkO1xuIiwidmFyIGFycmF5TGlrZUtleXMgPSByZXF1aXJlKCcuL19hcnJheUxpa2VLZXlzJyksXG4gICAgYmFzZUtleXMgPSByZXF1aXJlKCcuL19iYXNlS2V5cycpLFxuICAgIGlzQXJyYXlMaWtlID0gcmVxdWlyZSgnLi9pc0FycmF5TGlrZScpO1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIG93biBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIG9mIGBvYmplY3RgLlxuICpcbiAqICoqTm90ZToqKiBOb24tb2JqZWN0IHZhbHVlcyBhcmUgY29lcmNlZCB0byBvYmplY3RzLiBTZWUgdGhlXG4gKiBbRVMgc3BlY10oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtb2JqZWN0LmtleXMpXG4gKiBmb3IgbW9yZSBkZXRhaWxzLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBzaW5jZSAwLjEuMFxuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gKiBAZXhhbXBsZVxuICpcbiAqIGZ1bmN0aW9uIEZvbygpIHtcbiAqICAgdGhpcy5hID0gMTtcbiAqICAgdGhpcy5iID0gMjtcbiAqIH1cbiAqXG4gKiBGb28ucHJvdG90eXBlLmMgPSAzO1xuICpcbiAqIF8ua2V5cyhuZXcgRm9vKTtcbiAqIC8vID0+IFsnYScsICdiJ10gKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZClcbiAqXG4gKiBfLmtleXMoJ2hpJyk7XG4gKiAvLyA9PiBbJzAnLCAnMSddXG4gKi9cbmZ1bmN0aW9uIGtleXMob2JqZWN0KSB7XG4gIHJldHVybiBpc0FycmF5TGlrZShvYmplY3QpID8gYXJyYXlMaWtlS2V5cyhvYmplY3QpIDogYmFzZUtleXMob2JqZWN0KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBrZXlzO1xuIiwidmFyIGFycmF5TGlrZUtleXMgPSByZXF1aXJlKCcuL19hcnJheUxpa2VLZXlzJyksXG4gICAgYmFzZUtleXNJbiA9IHJlcXVpcmUoJy4vX2Jhc2VLZXlzSW4nKSxcbiAgICBpc0FycmF5TGlrZSA9IHJlcXVpcmUoJy4vaXNBcnJheUxpa2UnKTtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBvd24gYW5kIGluaGVyaXRlZCBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIG9mIGBvYmplY3RgLlxuICpcbiAqICoqTm90ZToqKiBOb24tb2JqZWN0IHZhbHVlcyBhcmUgY29lcmNlZCB0byBvYmplY3RzLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMy4wLjBcbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gKiBAZXhhbXBsZVxuICpcbiAqIGZ1bmN0aW9uIEZvbygpIHtcbiAqICAgdGhpcy5hID0gMTtcbiAqICAgdGhpcy5iID0gMjtcbiAqIH1cbiAqXG4gKiBGb28ucHJvdG90eXBlLmMgPSAzO1xuICpcbiAqIF8ua2V5c0luKG5ldyBGb28pO1xuICogLy8gPT4gWydhJywgJ2InLCAnYyddIChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpXG4gKi9cbmZ1bmN0aW9uIGtleXNJbihvYmplY3QpIHtcbiAgcmV0dXJuIGlzQXJyYXlMaWtlKG9iamVjdCkgPyBhcnJheUxpa2VLZXlzKG9iamVjdCwgdHJ1ZSkgOiBiYXNlS2V5c0luKG9iamVjdCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ga2V5c0luO1xuIiwiLyoqXG4gKiBHZXRzIHRoZSBsYXN0IGVsZW1lbnQgb2YgYGFycmF5YC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgQXJyYXlcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBsYXN0IGVsZW1lbnQgb2YgYGFycmF5YC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5sYXN0KFsxLCAyLCAzXSk7XG4gKiAvLyA9PiAzXG4gKi9cbmZ1bmN0aW9uIGxhc3QoYXJyYXkpIHtcbiAgdmFyIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuICByZXR1cm4gbGVuZ3RoID8gYXJyYXlbbGVuZ3RoIC0gMV0gOiB1bmRlZmluZWQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbGFzdDtcbiIsInZhciBhcnJheU1hcCA9IHJlcXVpcmUoJy4vX2FycmF5TWFwJyksXG4gICAgYmFzZUl0ZXJhdGVlID0gcmVxdWlyZSgnLi9fYmFzZUl0ZXJhdGVlJyksXG4gICAgYmFzZU1hcCA9IHJlcXVpcmUoJy4vX2Jhc2VNYXAnKSxcbiAgICBpc0FycmF5ID0gcmVxdWlyZSgnLi9pc0FycmF5Jyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiB2YWx1ZXMgYnkgcnVubmluZyBlYWNoIGVsZW1lbnQgaW4gYGNvbGxlY3Rpb25gIHRocnVcbiAqIGBpdGVyYXRlZWAuIFRoZSBpdGVyYXRlZSBpcyBpbnZva2VkIHdpdGggdGhyZWUgYXJndW1lbnRzOlxuICogKHZhbHVlLCBpbmRleHxrZXksIGNvbGxlY3Rpb24pLlxuICpcbiAqIE1hbnkgbG9kYXNoIG1ldGhvZHMgYXJlIGd1YXJkZWQgdG8gd29yayBhcyBpdGVyYXRlZXMgZm9yIG1ldGhvZHMgbGlrZVxuICogYF8uZXZlcnlgLCBgXy5maWx0ZXJgLCBgXy5tYXBgLCBgXy5tYXBWYWx1ZXNgLCBgXy5yZWplY3RgLCBhbmQgYF8uc29tZWAuXG4gKlxuICogVGhlIGd1YXJkZWQgbWV0aG9kcyBhcmU6XG4gKiBgYXJ5YCwgYGNodW5rYCwgYGN1cnJ5YCwgYGN1cnJ5UmlnaHRgLCBgZHJvcGAsIGBkcm9wUmlnaHRgLCBgZXZlcnlgLFxuICogYGZpbGxgLCBgaW52ZXJ0YCwgYHBhcnNlSW50YCwgYHJhbmRvbWAsIGByYW5nZWAsIGByYW5nZVJpZ2h0YCwgYHJlcGVhdGAsXG4gKiBgc2FtcGxlU2l6ZWAsIGBzbGljZWAsIGBzb21lYCwgYHNvcnRCeWAsIGBzcGxpdGAsIGB0YWtlYCwgYHRha2VSaWdodGAsXG4gKiBgdGVtcGxhdGVgLCBgdHJpbWAsIGB0cmltRW5kYCwgYHRyaW1TdGFydGAsIGFuZCBgd29yZHNgXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgbWFwcGVkIGFycmF5LlxuICogQGV4YW1wbGVcbiAqXG4gKiBmdW5jdGlvbiBzcXVhcmUobikge1xuICogICByZXR1cm4gbiAqIG47XG4gKiB9XG4gKlxuICogXy5tYXAoWzQsIDhdLCBzcXVhcmUpO1xuICogLy8gPT4gWzE2LCA2NF1cbiAqXG4gKiBfLm1hcCh7ICdhJzogNCwgJ2InOiA4IH0sIHNxdWFyZSk7XG4gKiAvLyA9PiBbMTYsIDY0XSAoaXRlcmF0aW9uIG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKVxuICpcbiAqIHZhciB1c2VycyA9IFtcbiAqICAgeyAndXNlcic6ICdiYXJuZXknIH0sXG4gKiAgIHsgJ3VzZXInOiAnZnJlZCcgfVxuICogXTtcbiAqXG4gKiAvLyBUaGUgYF8ucHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAqIF8ubWFwKHVzZXJzLCAndXNlcicpO1xuICogLy8gPT4gWydiYXJuZXknLCAnZnJlZCddXG4gKi9cbmZ1bmN0aW9uIG1hcChjb2xsZWN0aW9uLCBpdGVyYXRlZSkge1xuICB2YXIgZnVuYyA9IGlzQXJyYXkoY29sbGVjdGlvbikgPyBhcnJheU1hcCA6IGJhc2VNYXA7XG4gIHJldHVybiBmdW5jKGNvbGxlY3Rpb24sIGJhc2VJdGVyYXRlZShpdGVyYXRlZSwgMykpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG1hcDtcbiIsInZhciBiYXNlQXNzaWduVmFsdWUgPSByZXF1aXJlKCcuL19iYXNlQXNzaWduVmFsdWUnKSxcbiAgICBiYXNlRm9yT3duID0gcmVxdWlyZSgnLi9fYmFzZUZvck93bicpLFxuICAgIGJhc2VJdGVyYXRlZSA9IHJlcXVpcmUoJy4vX2Jhc2VJdGVyYXRlZScpO1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gb2JqZWN0IHdpdGggdGhlIHNhbWUga2V5cyBhcyBgb2JqZWN0YCBhbmQgdmFsdWVzIGdlbmVyYXRlZFxuICogYnkgcnVubmluZyBlYWNoIG93biBlbnVtZXJhYmxlIHN0cmluZyBrZXllZCBwcm9wZXJ0eSBvZiBgb2JqZWN0YCB0aHJ1XG4gKiBgaXRlcmF0ZWVgLiBUaGUgaXRlcmF0ZWUgaXMgaW52b2tlZCB3aXRoIHRocmVlIGFyZ3VtZW50czpcbiAqICh2YWx1ZSwga2V5LCBvYmplY3QpLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMi40LjBcbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBtYXBwZWQgb2JqZWN0LlxuICogQHNlZSBfLm1hcEtleXNcbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIHVzZXJzID0ge1xuICogICAnZnJlZCc6ICAgIHsgJ3VzZXInOiAnZnJlZCcsICAgICdhZ2UnOiA0MCB9LFxuICogICAncGViYmxlcyc6IHsgJ3VzZXInOiAncGViYmxlcycsICdhZ2UnOiAxIH1cbiAqIH07XG4gKlxuICogXy5tYXBWYWx1ZXModXNlcnMsIGZ1bmN0aW9uKG8pIHsgcmV0dXJuIG8uYWdlOyB9KTtcbiAqIC8vID0+IHsgJ2ZyZWQnOiA0MCwgJ3BlYmJsZXMnOiAxIH0gKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZClcbiAqXG4gKiAvLyBUaGUgYF8ucHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAqIF8ubWFwVmFsdWVzKHVzZXJzLCAnYWdlJyk7XG4gKiAvLyA9PiB7ICdmcmVkJzogNDAsICdwZWJibGVzJzogMSB9IChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpXG4gKi9cbmZ1bmN0aW9uIG1hcFZhbHVlcyhvYmplY3QsIGl0ZXJhdGVlKSB7XG4gIHZhciByZXN1bHQgPSB7fTtcbiAgaXRlcmF0ZWUgPSBiYXNlSXRlcmF0ZWUoaXRlcmF0ZWUsIDMpO1xuXG4gIGJhc2VGb3JPd24ob2JqZWN0LCBmdW5jdGlvbih2YWx1ZSwga2V5LCBvYmplY3QpIHtcbiAgICBiYXNlQXNzaWduVmFsdWUocmVzdWx0LCBrZXksIGl0ZXJhdGVlKHZhbHVlLCBrZXksIG9iamVjdCkpO1xuICB9KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBtYXBWYWx1ZXM7XG4iLCJ2YXIgYmFzZUV4dHJlbXVtID0gcmVxdWlyZSgnLi9fYmFzZUV4dHJlbXVtJyksXG4gICAgYmFzZUd0ID0gcmVxdWlyZSgnLi9fYmFzZUd0JyksXG4gICAgaWRlbnRpdHkgPSByZXF1aXJlKCcuL2lkZW50aXR5Jyk7XG5cbi8qKlxuICogQ29tcHV0ZXMgdGhlIG1heGltdW0gdmFsdWUgb2YgYGFycmF5YC4gSWYgYGFycmF5YCBpcyBlbXB0eSBvciBmYWxzZXksXG4gKiBgdW5kZWZpbmVkYCBpcyByZXR1cm5lZC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBtZW1iZXJPZiBfXG4gKiBAY2F0ZWdvcnkgTWF0aFxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBtYXhpbXVtIHZhbHVlLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLm1heChbNCwgMiwgOCwgNl0pO1xuICogLy8gPT4gOFxuICpcbiAqIF8ubWF4KFtdKTtcbiAqIC8vID0+IHVuZGVmaW5lZFxuICovXG5mdW5jdGlvbiBtYXgoYXJyYXkpIHtcbiAgcmV0dXJuIChhcnJheSAmJiBhcnJheS5sZW5ndGgpXG4gICAgPyBiYXNlRXh0cmVtdW0oYXJyYXksIGlkZW50aXR5LCBiYXNlR3QpXG4gICAgOiB1bmRlZmluZWQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbWF4O1xuIiwidmFyIE1hcENhY2hlID0gcmVxdWlyZSgnLi9fTWFwQ2FjaGUnKTtcblxuLyoqIEVycm9yIG1lc3NhZ2UgY29uc3RhbnRzLiAqL1xudmFyIEZVTkNfRVJST1JfVEVYVCA9ICdFeHBlY3RlZCBhIGZ1bmN0aW9uJztcblxuLyoqXG4gKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBtZW1vaXplcyB0aGUgcmVzdWx0IG9mIGBmdW5jYC4gSWYgYHJlc29sdmVyYCBpc1xuICogcHJvdmlkZWQsIGl0IGRldGVybWluZXMgdGhlIGNhY2hlIGtleSBmb3Igc3RvcmluZyB0aGUgcmVzdWx0IGJhc2VkIG9uIHRoZVxuICogYXJndW1lbnRzIHByb3ZpZGVkIHRvIHRoZSBtZW1vaXplZCBmdW5jdGlvbi4gQnkgZGVmYXVsdCwgdGhlIGZpcnN0IGFyZ3VtZW50XG4gKiBwcm92aWRlZCB0byB0aGUgbWVtb2l6ZWQgZnVuY3Rpb24gaXMgdXNlZCBhcyB0aGUgbWFwIGNhY2hlIGtleS4gVGhlIGBmdW5jYFxuICogaXMgaW52b2tlZCB3aXRoIHRoZSBgdGhpc2AgYmluZGluZyBvZiB0aGUgbWVtb2l6ZWQgZnVuY3Rpb24uXG4gKlxuICogKipOb3RlOioqIFRoZSBjYWNoZSBpcyBleHBvc2VkIGFzIHRoZSBgY2FjaGVgIHByb3BlcnR5IG9uIHRoZSBtZW1vaXplZFxuICogZnVuY3Rpb24uIEl0cyBjcmVhdGlvbiBtYXkgYmUgY3VzdG9taXplZCBieSByZXBsYWNpbmcgdGhlIGBfLm1lbW9pemUuQ2FjaGVgXG4gKiBjb25zdHJ1Y3RvciB3aXRoIG9uZSB3aG9zZSBpbnN0YW5jZXMgaW1wbGVtZW50IHRoZVxuICogW2BNYXBgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1wcm9wZXJ0aWVzLW9mLXRoZS1tYXAtcHJvdG90eXBlLW9iamVjdClcbiAqIG1ldGhvZCBpbnRlcmZhY2Ugb2YgYGNsZWFyYCwgYGRlbGV0ZWAsIGBnZXRgLCBgaGFzYCwgYW5kIGBzZXRgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gaGF2ZSBpdHMgb3V0cHV0IG1lbW9pemVkLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW3Jlc29sdmVyXSBUaGUgZnVuY3Rpb24gdG8gcmVzb2x2ZSB0aGUgY2FjaGUga2V5LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgbWVtb2l6ZWQgZnVuY3Rpb24uXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3QgPSB7ICdhJzogMSwgJ2InOiAyIH07XG4gKiB2YXIgb3RoZXIgPSB7ICdjJzogMywgJ2QnOiA0IH07XG4gKlxuICogdmFyIHZhbHVlcyA9IF8ubWVtb2l6ZShfLnZhbHVlcyk7XG4gKiB2YWx1ZXMob2JqZWN0KTtcbiAqIC8vID0+IFsxLCAyXVxuICpcbiAqIHZhbHVlcyhvdGhlcik7XG4gKiAvLyA9PiBbMywgNF1cbiAqXG4gKiBvYmplY3QuYSA9IDI7XG4gKiB2YWx1ZXMob2JqZWN0KTtcbiAqIC8vID0+IFsxLCAyXVxuICpcbiAqIC8vIE1vZGlmeSB0aGUgcmVzdWx0IGNhY2hlLlxuICogdmFsdWVzLmNhY2hlLnNldChvYmplY3QsIFsnYScsICdiJ10pO1xuICogdmFsdWVzKG9iamVjdCk7XG4gKiAvLyA9PiBbJ2EnLCAnYiddXG4gKlxuICogLy8gUmVwbGFjZSBgXy5tZW1vaXplLkNhY2hlYC5cbiAqIF8ubWVtb2l6ZS5DYWNoZSA9IFdlYWtNYXA7XG4gKi9cbmZ1bmN0aW9uIG1lbW9pemUoZnVuYywgcmVzb2x2ZXIpIHtcbiAgaWYgKHR5cGVvZiBmdW5jICE9ICdmdW5jdGlvbicgfHwgKHJlc29sdmVyICE9IG51bGwgJiYgdHlwZW9mIHJlc29sdmVyICE9ICdmdW5jdGlvbicpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihGVU5DX0VSUk9SX1RFWFQpO1xuICB9XG4gIHZhciBtZW1vaXplZCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBhcmdzID0gYXJndW1lbnRzLFxuICAgICAgICBrZXkgPSByZXNvbHZlciA/IHJlc29sdmVyLmFwcGx5KHRoaXMsIGFyZ3MpIDogYXJnc1swXSxcbiAgICAgICAgY2FjaGUgPSBtZW1vaXplZC5jYWNoZTtcblxuICAgIGlmIChjYWNoZS5oYXMoa2V5KSkge1xuICAgICAgcmV0dXJuIGNhY2hlLmdldChrZXkpO1xuICAgIH1cbiAgICB2YXIgcmVzdWx0ID0gZnVuYy5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICBtZW1vaXplZC5jYWNoZSA9IGNhY2hlLnNldChrZXksIHJlc3VsdCkgfHwgY2FjaGU7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcbiAgbWVtb2l6ZWQuY2FjaGUgPSBuZXcgKG1lbW9pemUuQ2FjaGUgfHwgTWFwQ2FjaGUpO1xuICByZXR1cm4gbWVtb2l6ZWQ7XG59XG5cbi8vIEV4cG9zZSBgTWFwQ2FjaGVgLlxubWVtb2l6ZS5DYWNoZSA9IE1hcENhY2hlO1xuXG5tb2R1bGUuZXhwb3J0cyA9IG1lbW9pemU7XG4iLCJ2YXIgYmFzZU1lcmdlID0gcmVxdWlyZSgnLi9fYmFzZU1lcmdlJyksXG4gICAgY3JlYXRlQXNzaWduZXIgPSByZXF1aXJlKCcuL19jcmVhdGVBc3NpZ25lcicpO1xuXG4vKipcbiAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uYXNzaWduYCBleGNlcHQgdGhhdCBpdCByZWN1cnNpdmVseSBtZXJnZXMgb3duIGFuZFxuICogaW5oZXJpdGVkIGVudW1lcmFibGUgc3RyaW5nIGtleWVkIHByb3BlcnRpZXMgb2Ygc291cmNlIG9iamVjdHMgaW50byB0aGVcbiAqIGRlc3RpbmF0aW9uIG9iamVjdC4gU291cmNlIHByb3BlcnRpZXMgdGhhdCByZXNvbHZlIHRvIGB1bmRlZmluZWRgIGFyZVxuICogc2tpcHBlZCBpZiBhIGRlc3RpbmF0aW9uIHZhbHVlIGV4aXN0cy4gQXJyYXkgYW5kIHBsYWluIG9iamVjdCBwcm9wZXJ0aWVzXG4gKiBhcmUgbWVyZ2VkIHJlY3Vyc2l2ZWx5LiBPdGhlciBvYmplY3RzIGFuZCB2YWx1ZSB0eXBlcyBhcmUgb3ZlcnJpZGRlbiBieVxuICogYXNzaWdubWVudC4gU291cmNlIG9iamVjdHMgYXJlIGFwcGxpZWQgZnJvbSBsZWZ0IHRvIHJpZ2h0LiBTdWJzZXF1ZW50XG4gKiBzb3VyY2VzIG92ZXJ3cml0ZSBwcm9wZXJ0eSBhc3NpZ25tZW50cyBvZiBwcmV2aW91cyBzb3VyY2VzLlxuICpcbiAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBtdXRhdGVzIGBvYmplY3RgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC41LjBcbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAqIEBwYXJhbSB7Li4uT2JqZWN0fSBbc291cmNlc10gVGhlIHNvdXJjZSBvYmplY3RzLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdCA9IHtcbiAqICAgJ2EnOiBbeyAnYic6IDIgfSwgeyAnZCc6IDQgfV1cbiAqIH07XG4gKlxuICogdmFyIG90aGVyID0ge1xuICogICAnYSc6IFt7ICdjJzogMyB9LCB7ICdlJzogNSB9XVxuICogfTtcbiAqXG4gKiBfLm1lcmdlKG9iamVjdCwgb3RoZXIpO1xuICogLy8gPT4geyAnYSc6IFt7ICdiJzogMiwgJ2MnOiAzIH0sIHsgJ2QnOiA0LCAnZSc6IDUgfV0gfVxuICovXG52YXIgbWVyZ2UgPSBjcmVhdGVBc3NpZ25lcihmdW5jdGlvbihvYmplY3QsIHNvdXJjZSwgc3JjSW5kZXgpIHtcbiAgYmFzZU1lcmdlKG9iamVjdCwgc291cmNlLCBzcmNJbmRleCk7XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBtZXJnZTtcbiIsInZhciBiYXNlRXh0cmVtdW0gPSByZXF1aXJlKCcuL19iYXNlRXh0cmVtdW0nKSxcbiAgICBiYXNlTHQgPSByZXF1aXJlKCcuL19iYXNlTHQnKSxcbiAgICBpZGVudGl0eSA9IHJlcXVpcmUoJy4vaWRlbnRpdHknKTtcblxuLyoqXG4gKiBDb21wdXRlcyB0aGUgbWluaW11bSB2YWx1ZSBvZiBgYXJyYXlgLiBJZiBgYXJyYXlgIGlzIGVtcHR5IG9yIGZhbHNleSxcbiAqIGB1bmRlZmluZWRgIGlzIHJldHVybmVkLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBzaW5jZSAwLjEuMFxuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBNYXRoXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIG1pbmltdW0gdmFsdWUuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8ubWluKFs0LCAyLCA4LCA2XSk7XG4gKiAvLyA9PiAyXG4gKlxuICogXy5taW4oW10pO1xuICogLy8gPT4gdW5kZWZpbmVkXG4gKi9cbmZ1bmN0aW9uIG1pbihhcnJheSkge1xuICByZXR1cm4gKGFycmF5ICYmIGFycmF5Lmxlbmd0aClcbiAgICA/IGJhc2VFeHRyZW11bShhcnJheSwgaWRlbnRpdHksIGJhc2VMdClcbiAgICA6IHVuZGVmaW5lZDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBtaW47XG4iLCJ2YXIgYmFzZUV4dHJlbXVtID0gcmVxdWlyZSgnLi9fYmFzZUV4dHJlbXVtJyksXG4gICAgYmFzZUl0ZXJhdGVlID0gcmVxdWlyZSgnLi9fYmFzZUl0ZXJhdGVlJyksXG4gICAgYmFzZUx0ID0gcmVxdWlyZSgnLi9fYmFzZUx0Jyk7XG5cbi8qKlxuICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5taW5gIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYGl0ZXJhdGVlYCB3aGljaCBpc1xuICogaW52b2tlZCBmb3IgZWFjaCBlbGVtZW50IGluIGBhcnJheWAgdG8gZ2VuZXJhdGUgdGhlIGNyaXRlcmlvbiBieSB3aGljaFxuICogdGhlIHZhbHVlIGlzIHJhbmtlZC4gVGhlIGl0ZXJhdGVlIGlzIGludm9rZWQgd2l0aCBvbmUgYXJndW1lbnQ6ICh2YWx1ZSkuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IE1hdGhcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGl0ZXJhdGVlIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgbWluaW11bSB2YWx1ZS5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdHMgPSBbeyAnbic6IDEgfSwgeyAnbic6IDIgfV07XG4gKlxuICogXy5taW5CeShvYmplY3RzLCBmdW5jdGlvbihvKSB7IHJldHVybiBvLm47IH0pO1xuICogLy8gPT4geyAnbic6IDEgfVxuICpcbiAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICogXy5taW5CeShvYmplY3RzLCAnbicpO1xuICogLy8gPT4geyAnbic6IDEgfVxuICovXG5mdW5jdGlvbiBtaW5CeShhcnJheSwgaXRlcmF0ZWUpIHtcbiAgcmV0dXJuIChhcnJheSAmJiBhcnJheS5sZW5ndGgpXG4gICAgPyBiYXNlRXh0cmVtdW0oYXJyYXksIGJhc2VJdGVyYXRlZShpdGVyYXRlZSwgMiksIGJhc2VMdClcbiAgICA6IHVuZGVmaW5lZDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBtaW5CeTtcbiIsIi8qKlxuICogVGhpcyBtZXRob2QgcmV0dXJucyBgdW5kZWZpbmVkYC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDIuMy4wXG4gKiBAY2F0ZWdvcnkgVXRpbFxuICogQGV4YW1wbGVcbiAqXG4gKiBfLnRpbWVzKDIsIF8ubm9vcCk7XG4gKiAvLyA9PiBbdW5kZWZpbmVkLCB1bmRlZmluZWRdXG4gKi9cbmZ1bmN0aW9uIG5vb3AoKSB7XG4gIC8vIE5vIG9wZXJhdGlvbiBwZXJmb3JtZWQuXG59XG5cbm1vZHVsZS5leHBvcnRzID0gbm9vcDtcbiIsInZhciByb290ID0gcmVxdWlyZSgnLi9fcm9vdCcpO1xuXG4vKipcbiAqIEdldHMgdGhlIHRpbWVzdGFtcCBvZiB0aGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyB0aGF0IGhhdmUgZWxhcHNlZCBzaW5jZVxuICogdGhlIFVuaXggZXBvY2ggKDEgSmFudWFyeSAxOTcwIDAwOjAwOjAwIFVUQykuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAyLjQuMFxuICogQGNhdGVnb3J5IERhdGVcbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIHRpbWVzdGFtcC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5kZWZlcihmdW5jdGlvbihzdGFtcCkge1xuICogICBjb25zb2xlLmxvZyhfLm5vdygpIC0gc3RhbXApO1xuICogfSwgXy5ub3coKSk7XG4gKiAvLyA9PiBMb2dzIHRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIGl0IHRvb2sgZm9yIHRoZSBkZWZlcnJlZCBpbnZvY2F0aW9uLlxuICovXG52YXIgbm93ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiByb290LkRhdGUubm93KCk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IG5vdztcbiIsInZhciBiYXNlUGljayA9IHJlcXVpcmUoJy4vX2Jhc2VQaWNrJyksXG4gICAgZmxhdFJlc3QgPSByZXF1aXJlKCcuL19mbGF0UmVzdCcpO1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gb2JqZWN0IGNvbXBvc2VkIG9mIHRoZSBwaWNrZWQgYG9iamVjdGAgcHJvcGVydGllcy5cbiAqXG4gKiBAc3RhdGljXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBtZW1iZXJPZiBfXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBzb3VyY2Ugb2JqZWN0LlxuICogQHBhcmFtIHsuLi4oc3RyaW5nfHN0cmluZ1tdKX0gW3BhdGhzXSBUaGUgcHJvcGVydHkgcGF0aHMgdG8gcGljay5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBvYmplY3QuXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3QgPSB7ICdhJzogMSwgJ2InOiAnMicsICdjJzogMyB9O1xuICpcbiAqIF8ucGljayhvYmplY3QsIFsnYScsICdjJ10pO1xuICogLy8gPT4geyAnYSc6IDEsICdjJzogMyB9XG4gKi9cbnZhciBwaWNrID0gZmxhdFJlc3QoZnVuY3Rpb24ob2JqZWN0LCBwYXRocykge1xuICByZXR1cm4gb2JqZWN0ID09IG51bGwgPyB7fSA6IGJhc2VQaWNrKG9iamVjdCwgcGF0aHMpO1xufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gcGljaztcbiIsInZhciBiYXNlUHJvcGVydHkgPSByZXF1aXJlKCcuL19iYXNlUHJvcGVydHknKSxcbiAgICBiYXNlUHJvcGVydHlEZWVwID0gcmVxdWlyZSgnLi9fYmFzZVByb3BlcnR5RGVlcCcpLFxuICAgIGlzS2V5ID0gcmVxdWlyZSgnLi9faXNLZXknKSxcbiAgICB0b0tleSA9IHJlcXVpcmUoJy4vX3RvS2V5Jyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0aGUgdmFsdWUgYXQgYHBhdGhgIG9mIGEgZ2l2ZW4gb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMi40LjBcbiAqIEBjYXRlZ29yeSBVdGlsXG4gKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYWNjZXNzb3IgZnVuY3Rpb24uXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3RzID0gW1xuICogICB7ICdhJzogeyAnYic6IDIgfSB9LFxuICogICB7ICdhJzogeyAnYic6IDEgfSB9XG4gKiBdO1xuICpcbiAqIF8ubWFwKG9iamVjdHMsIF8ucHJvcGVydHkoJ2EuYicpKTtcbiAqIC8vID0+IFsyLCAxXVxuICpcbiAqIF8ubWFwKF8uc29ydEJ5KG9iamVjdHMsIF8ucHJvcGVydHkoWydhJywgJ2InXSkpLCAnYS5iJyk7XG4gKiAvLyA9PiBbMSwgMl1cbiAqL1xuZnVuY3Rpb24gcHJvcGVydHkocGF0aCkge1xuICByZXR1cm4gaXNLZXkocGF0aCkgPyBiYXNlUHJvcGVydHkodG9LZXkocGF0aCkpIDogYmFzZVByb3BlcnR5RGVlcChwYXRoKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBwcm9wZXJ0eTtcbiIsInZhciBjcmVhdGVSYW5nZSA9IHJlcXVpcmUoJy4vX2NyZWF0ZVJhbmdlJyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiBudW1iZXJzIChwb3NpdGl2ZSBhbmQvb3IgbmVnYXRpdmUpIHByb2dyZXNzaW5nIGZyb21cbiAqIGBzdGFydGAgdXAgdG8sIGJ1dCBub3QgaW5jbHVkaW5nLCBgZW5kYC4gQSBzdGVwIG9mIGAtMWAgaXMgdXNlZCBpZiBhIG5lZ2F0aXZlXG4gKiBgc3RhcnRgIGlzIHNwZWNpZmllZCB3aXRob3V0IGFuIGBlbmRgIG9yIGBzdGVwYC4gSWYgYGVuZGAgaXMgbm90IHNwZWNpZmllZCxcbiAqIGl0J3Mgc2V0IHRvIGBzdGFydGAgd2l0aCBgc3RhcnRgIHRoZW4gc2V0IHRvIGAwYC5cbiAqXG4gKiAqKk5vdGU6KiogSmF2YVNjcmlwdCBmb2xsb3dzIHRoZSBJRUVFLTc1NCBzdGFuZGFyZCBmb3IgcmVzb2x2aW5nXG4gKiBmbG9hdGluZy1wb2ludCB2YWx1ZXMgd2hpY2ggY2FuIHByb2R1Y2UgdW5leHBlY3RlZCByZXN1bHRzLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBzaW5jZSAwLjEuMFxuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBVdGlsXG4gKiBAcGFyYW0ge251bWJlcn0gW3N0YXJ0PTBdIFRoZSBzdGFydCBvZiB0aGUgcmFuZ2UuXG4gKiBAcGFyYW0ge251bWJlcn0gZW5kIFRoZSBlbmQgb2YgdGhlIHJhbmdlLlxuICogQHBhcmFtIHtudW1iZXJ9IFtzdGVwPTFdIFRoZSB2YWx1ZSB0byBpbmNyZW1lbnQgb3IgZGVjcmVtZW50IGJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSByYW5nZSBvZiBudW1iZXJzLlxuICogQHNlZSBfLmluUmFuZ2UsIF8ucmFuZ2VSaWdodFxuICogQGV4YW1wbGVcbiAqXG4gKiBfLnJhbmdlKDQpO1xuICogLy8gPT4gWzAsIDEsIDIsIDNdXG4gKlxuICogXy5yYW5nZSgtNCk7XG4gKiAvLyA9PiBbMCwgLTEsIC0yLCAtM11cbiAqXG4gKiBfLnJhbmdlKDEsIDUpO1xuICogLy8gPT4gWzEsIDIsIDMsIDRdXG4gKlxuICogXy5yYW5nZSgwLCAyMCwgNSk7XG4gKiAvLyA9PiBbMCwgNSwgMTAsIDE1XVxuICpcbiAqIF8ucmFuZ2UoMCwgLTQsIC0xKTtcbiAqIC8vID0+IFswLCAtMSwgLTIsIC0zXVxuICpcbiAqIF8ucmFuZ2UoMSwgNCwgMCk7XG4gKiAvLyA9PiBbMSwgMSwgMV1cbiAqXG4gKiBfLnJhbmdlKDApO1xuICogLy8gPT4gW11cbiAqL1xudmFyIHJhbmdlID0gY3JlYXRlUmFuZ2UoKTtcblxubW9kdWxlLmV4cG9ydHMgPSByYW5nZTtcbiIsInZhciBhcnJheVJlZHVjZSA9IHJlcXVpcmUoJy4vX2FycmF5UmVkdWNlJyksXG4gICAgYmFzZUVhY2ggPSByZXF1aXJlKCcuL19iYXNlRWFjaCcpLFxuICAgIGJhc2VJdGVyYXRlZSA9IHJlcXVpcmUoJy4vX2Jhc2VJdGVyYXRlZScpLFxuICAgIGJhc2VSZWR1Y2UgPSByZXF1aXJlKCcuL19iYXNlUmVkdWNlJyksXG4gICAgaXNBcnJheSA9IHJlcXVpcmUoJy4vaXNBcnJheScpO1xuXG4vKipcbiAqIFJlZHVjZXMgYGNvbGxlY3Rpb25gIHRvIGEgdmFsdWUgd2hpY2ggaXMgdGhlIGFjY3VtdWxhdGVkIHJlc3VsdCBvZiBydW5uaW5nXG4gKiBlYWNoIGVsZW1lbnQgaW4gYGNvbGxlY3Rpb25gIHRocnUgYGl0ZXJhdGVlYCwgd2hlcmUgZWFjaCBzdWNjZXNzaXZlXG4gKiBpbnZvY2F0aW9uIGlzIHN1cHBsaWVkIHRoZSByZXR1cm4gdmFsdWUgb2YgdGhlIHByZXZpb3VzLiBJZiBgYWNjdW11bGF0b3JgXG4gKiBpcyBub3QgZ2l2ZW4sIHRoZSBmaXJzdCBlbGVtZW50IG9mIGBjb2xsZWN0aW9uYCBpcyB1c2VkIGFzIHRoZSBpbml0aWFsXG4gKiB2YWx1ZS4gVGhlIGl0ZXJhdGVlIGlzIGludm9rZWQgd2l0aCBmb3VyIGFyZ3VtZW50czpcbiAqIChhY2N1bXVsYXRvciwgdmFsdWUsIGluZGV4fGtleSwgY29sbGVjdGlvbikuXG4gKlxuICogTWFueSBsb2Rhc2ggbWV0aG9kcyBhcmUgZ3VhcmRlZCB0byB3b3JrIGFzIGl0ZXJhdGVlcyBmb3IgbWV0aG9kcyBsaWtlXG4gKiBgXy5yZWR1Y2VgLCBgXy5yZWR1Y2VSaWdodGAsIGFuZCBgXy50cmFuc2Zvcm1gLlxuICpcbiAqIFRoZSBndWFyZGVkIG1ldGhvZHMgYXJlOlxuICogYGFzc2lnbmAsIGBkZWZhdWx0c2AsIGBkZWZhdWx0c0RlZXBgLCBgaW5jbHVkZXNgLCBgbWVyZ2VgLCBgb3JkZXJCeWAsXG4gKiBhbmQgYHNvcnRCeWBcbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcGFyYW0geyp9IFthY2N1bXVsYXRvcl0gVGhlIGluaXRpYWwgdmFsdWUuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgYWNjdW11bGF0ZWQgdmFsdWUuXG4gKiBAc2VlIF8ucmVkdWNlUmlnaHRcbiAqIEBleGFtcGxlXG4gKlxuICogXy5yZWR1Y2UoWzEsIDJdLCBmdW5jdGlvbihzdW0sIG4pIHtcbiAqICAgcmV0dXJuIHN1bSArIG47XG4gKiB9LCAwKTtcbiAqIC8vID0+IDNcbiAqXG4gKiBfLnJlZHVjZSh7ICdhJzogMSwgJ2InOiAyLCAnYyc6IDEgfSwgZnVuY3Rpb24ocmVzdWx0LCB2YWx1ZSwga2V5KSB7XG4gKiAgIChyZXN1bHRbdmFsdWVdIHx8IChyZXN1bHRbdmFsdWVdID0gW10pKS5wdXNoKGtleSk7XG4gKiAgIHJldHVybiByZXN1bHQ7XG4gKiB9LCB7fSk7XG4gKiAvLyA9PiB7ICcxJzogWydhJywgJ2MnXSwgJzInOiBbJ2InXSB9IChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpXG4gKi9cbmZ1bmN0aW9uIHJlZHVjZShjb2xsZWN0aW9uLCBpdGVyYXRlZSwgYWNjdW11bGF0b3IpIHtcbiAgdmFyIGZ1bmMgPSBpc0FycmF5KGNvbGxlY3Rpb24pID8gYXJyYXlSZWR1Y2UgOiBiYXNlUmVkdWNlLFxuICAgICAgaW5pdEFjY3VtID0gYXJndW1lbnRzLmxlbmd0aCA8IDM7XG5cbiAgcmV0dXJuIGZ1bmMoY29sbGVjdGlvbiwgYmFzZUl0ZXJhdGVlKGl0ZXJhdGVlLCA0KSwgYWNjdW11bGF0b3IsIGluaXRBY2N1bSwgYmFzZUVhY2gpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHJlZHVjZTtcbiIsInZhciBiYXNlS2V5cyA9IHJlcXVpcmUoJy4vX2Jhc2VLZXlzJyksXG4gICAgZ2V0VGFnID0gcmVxdWlyZSgnLi9fZ2V0VGFnJyksXG4gICAgaXNBcnJheUxpa2UgPSByZXF1aXJlKCcuL2lzQXJyYXlMaWtlJyksXG4gICAgaXNTdHJpbmcgPSByZXF1aXJlKCcuL2lzU3RyaW5nJyksXG4gICAgc3RyaW5nU2l6ZSA9IHJlcXVpcmUoJy4vX3N0cmluZ1NpemUnKTtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIG1hcFRhZyA9ICdbb2JqZWN0IE1hcF0nLFxuICAgIHNldFRhZyA9ICdbb2JqZWN0IFNldF0nO1xuXG4vKipcbiAqIEdldHMgdGhlIHNpemUgb2YgYGNvbGxlY3Rpb25gIGJ5IHJldHVybmluZyBpdHMgbGVuZ3RoIGZvciBhcnJheS1saWtlXG4gKiB2YWx1ZXMgb3IgdGhlIG51bWJlciBvZiBvd24gZW51bWVyYWJsZSBzdHJpbmcga2V5ZWQgcHJvcGVydGllcyBmb3Igb2JqZWN0cy5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICogQHBhcmFtIHtBcnJheXxPYmplY3R8c3RyaW5nfSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGluc3BlY3QuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBjb2xsZWN0aW9uIHNpemUuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uc2l6ZShbMSwgMiwgM10pO1xuICogLy8gPT4gM1xuICpcbiAqIF8uc2l6ZSh7ICdhJzogMSwgJ2InOiAyIH0pO1xuICogLy8gPT4gMlxuICpcbiAqIF8uc2l6ZSgncGViYmxlcycpO1xuICogLy8gPT4gN1xuICovXG5mdW5jdGlvbiBzaXplKGNvbGxlY3Rpb24pIHtcbiAgaWYgKGNvbGxlY3Rpb24gPT0gbnVsbCkge1xuICAgIHJldHVybiAwO1xuICB9XG4gIGlmIChpc0FycmF5TGlrZShjb2xsZWN0aW9uKSkge1xuICAgIHJldHVybiBpc1N0cmluZyhjb2xsZWN0aW9uKSA/IHN0cmluZ1NpemUoY29sbGVjdGlvbikgOiBjb2xsZWN0aW9uLmxlbmd0aDtcbiAgfVxuICB2YXIgdGFnID0gZ2V0VGFnKGNvbGxlY3Rpb24pO1xuICBpZiAodGFnID09IG1hcFRhZyB8fCB0YWcgPT0gc2V0VGFnKSB7XG4gICAgcmV0dXJuIGNvbGxlY3Rpb24uc2l6ZTtcbiAgfVxuICByZXR1cm4gYmFzZUtleXMoY29sbGVjdGlvbikubGVuZ3RoO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHNpemU7XG4iLCJ2YXIgYmFzZUZsYXR0ZW4gPSByZXF1aXJlKCcuL19iYXNlRmxhdHRlbicpLFxuICAgIGJhc2VPcmRlckJ5ID0gcmVxdWlyZSgnLi9fYmFzZU9yZGVyQnknKSxcbiAgICBiYXNlUmVzdCA9IHJlcXVpcmUoJy4vX2Jhc2VSZXN0JyksXG4gICAgaXNJdGVyYXRlZUNhbGwgPSByZXF1aXJlKCcuL19pc0l0ZXJhdGVlQ2FsbCcpO1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgZWxlbWVudHMsIHNvcnRlZCBpbiBhc2NlbmRpbmcgb3JkZXIgYnkgdGhlIHJlc3VsdHMgb2ZcbiAqIHJ1bm5pbmcgZWFjaCBlbGVtZW50IGluIGEgY29sbGVjdGlvbiB0aHJ1IGVhY2ggaXRlcmF0ZWUuIFRoaXMgbWV0aG9kXG4gKiBwZXJmb3JtcyBhIHN0YWJsZSBzb3J0LCB0aGF0IGlzLCBpdCBwcmVzZXJ2ZXMgdGhlIG9yaWdpbmFsIHNvcnQgb3JkZXIgb2ZcbiAqIGVxdWFsIGVsZW1lbnRzLiBUaGUgaXRlcmF0ZWVzIGFyZSBpbnZva2VkIHdpdGggb25lIGFyZ3VtZW50OiAodmFsdWUpLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0gey4uLihGdW5jdGlvbnxGdW5jdGlvbltdKX0gW2l0ZXJhdGVlcz1bXy5pZGVudGl0eV1dXG4gKiAgVGhlIGl0ZXJhdGVlcyB0byBzb3J0IGJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgc29ydGVkIGFycmF5LlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgdXNlcnMgPSBbXG4gKiAgIHsgJ3VzZXInOiAnZnJlZCcsICAgJ2FnZSc6IDQ4IH0sXG4gKiAgIHsgJ3VzZXInOiAnYmFybmV5JywgJ2FnZSc6IDM2IH0sXG4gKiAgIHsgJ3VzZXInOiAnZnJlZCcsICAgJ2FnZSc6IDMwIH0sXG4gKiAgIHsgJ3VzZXInOiAnYmFybmV5JywgJ2FnZSc6IDM0IH1cbiAqIF07XG4gKlxuICogXy5zb3J0QnkodXNlcnMsIFtmdW5jdGlvbihvKSB7IHJldHVybiBvLnVzZXI7IH1dKTtcbiAqIC8vID0+IG9iamVjdHMgZm9yIFtbJ2Jhcm5leScsIDM2XSwgWydiYXJuZXknLCAzNF0sIFsnZnJlZCcsIDQ4XSwgWydmcmVkJywgMzBdXVxuICpcbiAqIF8uc29ydEJ5KHVzZXJzLCBbJ3VzZXInLCAnYWdlJ10pO1xuICogLy8gPT4gb2JqZWN0cyBmb3IgW1snYmFybmV5JywgMzRdLCBbJ2Jhcm5leScsIDM2XSwgWydmcmVkJywgMzBdLCBbJ2ZyZWQnLCA0OF1dXG4gKi9cbnZhciBzb3J0QnkgPSBiYXNlUmVzdChmdW5jdGlvbihjb2xsZWN0aW9uLCBpdGVyYXRlZXMpIHtcbiAgaWYgKGNvbGxlY3Rpb24gPT0gbnVsbCkge1xuICAgIHJldHVybiBbXTtcbiAgfVxuICB2YXIgbGVuZ3RoID0gaXRlcmF0ZWVzLmxlbmd0aDtcbiAgaWYgKGxlbmd0aCA+IDEgJiYgaXNJdGVyYXRlZUNhbGwoY29sbGVjdGlvbiwgaXRlcmF0ZWVzWzBdLCBpdGVyYXRlZXNbMV0pKSB7XG4gICAgaXRlcmF0ZWVzID0gW107XG4gIH0gZWxzZSBpZiAobGVuZ3RoID4gMiAmJiBpc0l0ZXJhdGVlQ2FsbChpdGVyYXRlZXNbMF0sIGl0ZXJhdGVlc1sxXSwgaXRlcmF0ZWVzWzJdKSkge1xuICAgIGl0ZXJhdGVlcyA9IFtpdGVyYXRlZXNbMF1dO1xuICB9XG4gIHJldHVybiBiYXNlT3JkZXJCeShjb2xsZWN0aW9uLCBiYXNlRmxhdHRlbihpdGVyYXRlZXMsIDEpLCBbXSk7XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBzb3J0Qnk7XG4iLCIvKipcbiAqIFRoaXMgbWV0aG9kIHJldHVybnMgYSBuZXcgZW1wdHkgYXJyYXkuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjEzLjBcbiAqIEBjYXRlZ29yeSBVdGlsXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBlbXB0eSBhcnJheS5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIGFycmF5cyA9IF8udGltZXMoMiwgXy5zdHViQXJyYXkpO1xuICpcbiAqIGNvbnNvbGUubG9nKGFycmF5cyk7XG4gKiAvLyA9PiBbW10sIFtdXVxuICpcbiAqIGNvbnNvbGUubG9nKGFycmF5c1swXSA9PT0gYXJyYXlzWzFdKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIHN0dWJBcnJheSgpIHtcbiAgcmV0dXJuIFtdO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHN0dWJBcnJheTtcbiIsIi8qKlxuICogVGhpcyBtZXRob2QgcmV0dXJucyBgZmFsc2VgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4xMy4wXG4gKiBAY2F0ZWdvcnkgVXRpbFxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy50aW1lcygyLCBfLnN0dWJGYWxzZSk7XG4gKiAvLyA9PiBbZmFsc2UsIGZhbHNlXVxuICovXG5mdW5jdGlvbiBzdHViRmFsc2UoKSB7XG4gIHJldHVybiBmYWxzZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzdHViRmFsc2U7XG4iLCJ2YXIgdG9OdW1iZXIgPSByZXF1aXJlKCcuL3RvTnVtYmVyJyk7XG5cbi8qKiBVc2VkIGFzIHJlZmVyZW5jZXMgZm9yIHZhcmlvdXMgYE51bWJlcmAgY29uc3RhbnRzLiAqL1xudmFyIElORklOSVRZID0gMSAvIDAsXG4gICAgTUFYX0lOVEVHRVIgPSAxLjc5NzY5MzEzNDg2MjMxNTdlKzMwODtcblxuLyoqXG4gKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGEgZmluaXRlIG51bWJlci5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMTIuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgbnVtYmVyLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLnRvRmluaXRlKDMuMik7XG4gKiAvLyA9PiAzLjJcbiAqXG4gKiBfLnRvRmluaXRlKE51bWJlci5NSU5fVkFMVUUpO1xuICogLy8gPT4gNWUtMzI0XG4gKlxuICogXy50b0Zpbml0ZShJbmZpbml0eSk7XG4gKiAvLyA9PiAxLjc5NzY5MzEzNDg2MjMxNTdlKzMwOFxuICpcbiAqIF8udG9GaW5pdGUoJzMuMicpO1xuICogLy8gPT4gMy4yXG4gKi9cbmZ1bmN0aW9uIHRvRmluaXRlKHZhbHVlKSB7XG4gIGlmICghdmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgPT09IDAgPyB2YWx1ZSA6IDA7XG4gIH1cbiAgdmFsdWUgPSB0b051bWJlcih2YWx1ZSk7XG4gIGlmICh2YWx1ZSA9PT0gSU5GSU5JVFkgfHwgdmFsdWUgPT09IC1JTkZJTklUWSkge1xuICAgIHZhciBzaWduID0gKHZhbHVlIDwgMCA/IC0xIDogMSk7XG4gICAgcmV0dXJuIHNpZ24gKiBNQVhfSU5URUdFUjtcbiAgfVxuICByZXR1cm4gdmFsdWUgPT09IHZhbHVlID8gdmFsdWUgOiAwO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHRvRmluaXRlO1xuIiwidmFyIHRvRmluaXRlID0gcmVxdWlyZSgnLi90b0Zpbml0ZScpO1xuXG4vKipcbiAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYW4gaW50ZWdlci5cbiAqXG4gKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgaXMgbG9vc2VseSBiYXNlZCBvblxuICogW2BUb0ludGVnZXJgXShodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtdG9pbnRlZ2VyKS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBpbnRlZ2VyLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLnRvSW50ZWdlcigzLjIpO1xuICogLy8gPT4gM1xuICpcbiAqIF8udG9JbnRlZ2VyKE51bWJlci5NSU5fVkFMVUUpO1xuICogLy8gPT4gMFxuICpcbiAqIF8udG9JbnRlZ2VyKEluZmluaXR5KTtcbiAqIC8vID0+IDEuNzk3NjkzMTM0ODYyMzE1N2UrMzA4XG4gKlxuICogXy50b0ludGVnZXIoJzMuMicpO1xuICogLy8gPT4gM1xuICovXG5mdW5jdGlvbiB0b0ludGVnZXIodmFsdWUpIHtcbiAgdmFyIHJlc3VsdCA9IHRvRmluaXRlKHZhbHVlKSxcbiAgICAgIHJlbWFpbmRlciA9IHJlc3VsdCAlIDE7XG5cbiAgcmV0dXJuIHJlc3VsdCA9PT0gcmVzdWx0ID8gKHJlbWFpbmRlciA/IHJlc3VsdCAtIHJlbWFpbmRlciA6IHJlc3VsdCkgOiAwO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHRvSW50ZWdlcjtcbiIsInZhciBiYXNlVHJpbSA9IHJlcXVpcmUoJy4vX2Jhc2VUcmltJyksXG4gICAgaXNPYmplY3QgPSByZXF1aXJlKCcuL2lzT2JqZWN0JyksXG4gICAgaXNTeW1ib2wgPSByZXF1aXJlKCcuL2lzU3ltYm9sJyk7XG5cbi8qKiBVc2VkIGFzIHJlZmVyZW5jZXMgZm9yIHZhcmlvdXMgYE51bWJlcmAgY29uc3RhbnRzLiAqL1xudmFyIE5BTiA9IDAgLyAwO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgYmFkIHNpZ25lZCBoZXhhZGVjaW1hbCBzdHJpbmcgdmFsdWVzLiAqL1xudmFyIHJlSXNCYWRIZXggPSAvXlstK10weFswLTlhLWZdKyQvaTtcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IGJpbmFyeSBzdHJpbmcgdmFsdWVzLiAqL1xudmFyIHJlSXNCaW5hcnkgPSAvXjBiWzAxXSskL2k7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBvY3RhbCBzdHJpbmcgdmFsdWVzLiAqL1xudmFyIHJlSXNPY3RhbCA9IC9eMG9bMC03XSskL2k7XG5cbi8qKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyB3aXRob3V0IGEgZGVwZW5kZW5jeSBvbiBgcm9vdGAuICovXG52YXIgZnJlZVBhcnNlSW50ID0gcGFyc2VJbnQ7XG5cbi8qKlxuICogQ29udmVydHMgYHZhbHVlYCB0byBhIG51bWJlci5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcHJvY2Vzcy5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIG51bWJlci5cbiAqIEBleGFtcGxlXG4gKlxuICogXy50b051bWJlcigzLjIpO1xuICogLy8gPT4gMy4yXG4gKlxuICogXy50b051bWJlcihOdW1iZXIuTUlOX1ZBTFVFKTtcbiAqIC8vID0+IDVlLTMyNFxuICpcbiAqIF8udG9OdW1iZXIoSW5maW5pdHkpO1xuICogLy8gPT4gSW5maW5pdHlcbiAqXG4gKiBfLnRvTnVtYmVyKCczLjInKTtcbiAqIC8vID0+IDMuMlxuICovXG5mdW5jdGlvbiB0b051bWJlcih2YWx1ZSkge1xuICBpZiAodHlwZW9mIHZhbHVlID09ICdudW1iZXInKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIGlmIChpc1N5bWJvbCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gTkFOO1xuICB9XG4gIGlmIChpc09iamVjdCh2YWx1ZSkpIHtcbiAgICB2YXIgb3RoZXIgPSB0eXBlb2YgdmFsdWUudmFsdWVPZiA9PSAnZnVuY3Rpb24nID8gdmFsdWUudmFsdWVPZigpIDogdmFsdWU7XG4gICAgdmFsdWUgPSBpc09iamVjdChvdGhlcikgPyAob3RoZXIgKyAnJykgOiBvdGhlcjtcbiAgfVxuICBpZiAodHlwZW9mIHZhbHVlICE9ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHZhbHVlID09PSAwID8gdmFsdWUgOiArdmFsdWU7XG4gIH1cbiAgdmFsdWUgPSBiYXNlVHJpbSh2YWx1ZSk7XG4gIHZhciBpc0JpbmFyeSA9IHJlSXNCaW5hcnkudGVzdCh2YWx1ZSk7XG4gIHJldHVybiAoaXNCaW5hcnkgfHwgcmVJc09jdGFsLnRlc3QodmFsdWUpKVxuICAgID8gZnJlZVBhcnNlSW50KHZhbHVlLnNsaWNlKDIpLCBpc0JpbmFyeSA/IDIgOiA4KVxuICAgIDogKHJlSXNCYWRIZXgudGVzdCh2YWx1ZSkgPyBOQU4gOiArdmFsdWUpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHRvTnVtYmVyO1xuIiwidmFyIGNvcHlPYmplY3QgPSByZXF1aXJlKCcuL19jb3B5T2JqZWN0JyksXG4gICAga2V5c0luID0gcmVxdWlyZSgnLi9rZXlzSW4nKTtcblxuLyoqXG4gKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGEgcGxhaW4gb2JqZWN0IGZsYXR0ZW5pbmcgaW5oZXJpdGVkIGVudW1lcmFibGUgc3RyaW5nXG4gKiBrZXllZCBwcm9wZXJ0aWVzIG9mIGB2YWx1ZWAgdG8gb3duIHByb3BlcnRpZXMgb2YgdGhlIHBsYWluIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDMuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBwbGFpbiBvYmplY3QuXG4gKiBAZXhhbXBsZVxuICpcbiAqIGZ1bmN0aW9uIEZvbygpIHtcbiAqICAgdGhpcy5iID0gMjtcbiAqIH1cbiAqXG4gKiBGb28ucHJvdG90eXBlLmMgPSAzO1xuICpcbiAqIF8uYXNzaWduKHsgJ2EnOiAxIH0sIG5ldyBGb28pO1xuICogLy8gPT4geyAnYSc6IDEsICdiJzogMiB9XG4gKlxuICogXy5hc3NpZ24oeyAnYSc6IDEgfSwgXy50b1BsYWluT2JqZWN0KG5ldyBGb28pKTtcbiAqIC8vID0+IHsgJ2EnOiAxLCAnYic6IDIsICdjJzogMyB9XG4gKi9cbmZ1bmN0aW9uIHRvUGxhaW5PYmplY3QodmFsdWUpIHtcbiAgcmV0dXJuIGNvcHlPYmplY3QodmFsdWUsIGtleXNJbih2YWx1ZSkpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHRvUGxhaW5PYmplY3Q7XG4iLCJ2YXIgYmFzZVRvU3RyaW5nID0gcmVxdWlyZSgnLi9fYmFzZVRvU3RyaW5nJyk7XG5cbi8qKlxuICogQ29udmVydHMgYHZhbHVlYCB0byBhIHN0cmluZy4gQW4gZW1wdHkgc3RyaW5nIGlzIHJldHVybmVkIGZvciBgbnVsbGBcbiAqIGFuZCBgdW5kZWZpbmVkYCB2YWx1ZXMuIFRoZSBzaWduIG9mIGAtMGAgaXMgcHJlc2VydmVkLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb252ZXJ0LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgY29udmVydGVkIHN0cmluZy5cbiAqIEBleGFtcGxlXG4gKlxuICogXy50b1N0cmluZyhudWxsKTtcbiAqIC8vID0+ICcnXG4gKlxuICogXy50b1N0cmluZygtMCk7XG4gKiAvLyA9PiAnLTAnXG4gKlxuICogXy50b1N0cmluZyhbMSwgMiwgM10pO1xuICogLy8gPT4gJzEsMiwzJ1xuICovXG5mdW5jdGlvbiB0b1N0cmluZyh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgPT0gbnVsbCA/ICcnIDogYmFzZVRvU3RyaW5nKHZhbHVlKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB0b1N0cmluZztcbiIsInZhciBhcnJheUVhY2ggPSByZXF1aXJlKCcuL19hcnJheUVhY2gnKSxcbiAgICBiYXNlQ3JlYXRlID0gcmVxdWlyZSgnLi9fYmFzZUNyZWF0ZScpLFxuICAgIGJhc2VGb3JPd24gPSByZXF1aXJlKCcuL19iYXNlRm9yT3duJyksXG4gICAgYmFzZUl0ZXJhdGVlID0gcmVxdWlyZSgnLi9fYmFzZUl0ZXJhdGVlJyksXG4gICAgZ2V0UHJvdG90eXBlID0gcmVxdWlyZSgnLi9fZ2V0UHJvdG90eXBlJyksXG4gICAgaXNBcnJheSA9IHJlcXVpcmUoJy4vaXNBcnJheScpLFxuICAgIGlzQnVmZmVyID0gcmVxdWlyZSgnLi9pc0J1ZmZlcicpLFxuICAgIGlzRnVuY3Rpb24gPSByZXF1aXJlKCcuL2lzRnVuY3Rpb24nKSxcbiAgICBpc09iamVjdCA9IHJlcXVpcmUoJy4vaXNPYmplY3QnKSxcbiAgICBpc1R5cGVkQXJyYXkgPSByZXF1aXJlKCcuL2lzVHlwZWRBcnJheScpO1xuXG4vKipcbiAqIEFuIGFsdGVybmF0aXZlIHRvIGBfLnJlZHVjZWA7IHRoaXMgbWV0aG9kIHRyYW5zZm9ybXMgYG9iamVjdGAgdG8gYSBuZXdcbiAqIGBhY2N1bXVsYXRvcmAgb2JqZWN0IHdoaWNoIGlzIHRoZSByZXN1bHQgb2YgcnVubmluZyBlYWNoIG9mIGl0cyBvd25cbiAqIGVudW1lcmFibGUgc3RyaW5nIGtleWVkIHByb3BlcnRpZXMgdGhydSBgaXRlcmF0ZWVgLCB3aXRoIGVhY2ggaW52b2NhdGlvblxuICogcG90ZW50aWFsbHkgbXV0YXRpbmcgdGhlIGBhY2N1bXVsYXRvcmAgb2JqZWN0LiBJZiBgYWNjdW11bGF0b3JgIGlzIG5vdFxuICogcHJvdmlkZWQsIGEgbmV3IG9iamVjdCB3aXRoIHRoZSBzYW1lIGBbW1Byb3RvdHlwZV1dYCB3aWxsIGJlIHVzZWQuIFRoZVxuICogaXRlcmF0ZWUgaXMgaW52b2tlZCB3aXRoIGZvdXIgYXJndW1lbnRzOiAoYWNjdW11bGF0b3IsIHZhbHVlLCBrZXksIG9iamVjdCkuXG4gKiBJdGVyYXRlZSBmdW5jdGlvbnMgbWF5IGV4aXQgaXRlcmF0aW9uIGVhcmx5IGJ5IGV4cGxpY2l0bHkgcmV0dXJuaW5nIGBmYWxzZWAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAxLjMuMFxuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHBhcmFtIHsqfSBbYWNjdW11bGF0b3JdIFRoZSBjdXN0b20gYWNjdW11bGF0b3IgdmFsdWUuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgYWNjdW11bGF0ZWQgdmFsdWUuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8udHJhbnNmb3JtKFsyLCAzLCA0XSwgZnVuY3Rpb24ocmVzdWx0LCBuKSB7XG4gKiAgIHJlc3VsdC5wdXNoKG4gKj0gbik7XG4gKiAgIHJldHVybiBuICUgMiA9PSAwO1xuICogfSwgW10pO1xuICogLy8gPT4gWzQsIDldXG4gKlxuICogXy50cmFuc2Zvcm0oeyAnYSc6IDEsICdiJzogMiwgJ2MnOiAxIH0sIGZ1bmN0aW9uKHJlc3VsdCwgdmFsdWUsIGtleSkge1xuICogICAocmVzdWx0W3ZhbHVlXSB8fCAocmVzdWx0W3ZhbHVlXSA9IFtdKSkucHVzaChrZXkpO1xuICogfSwge30pO1xuICogLy8gPT4geyAnMSc6IFsnYScsICdjJ10sICcyJzogWydiJ10gfVxuICovXG5mdW5jdGlvbiB0cmFuc2Zvcm0ob2JqZWN0LCBpdGVyYXRlZSwgYWNjdW11bGF0b3IpIHtcbiAgdmFyIGlzQXJyID0gaXNBcnJheShvYmplY3QpLFxuICAgICAgaXNBcnJMaWtlID0gaXNBcnIgfHwgaXNCdWZmZXIob2JqZWN0KSB8fCBpc1R5cGVkQXJyYXkob2JqZWN0KTtcblxuICBpdGVyYXRlZSA9IGJhc2VJdGVyYXRlZShpdGVyYXRlZSwgNCk7XG4gIGlmIChhY2N1bXVsYXRvciA9PSBudWxsKSB7XG4gICAgdmFyIEN0b3IgPSBvYmplY3QgJiYgb2JqZWN0LmNvbnN0cnVjdG9yO1xuICAgIGlmIChpc0Fyckxpa2UpIHtcbiAgICAgIGFjY3VtdWxhdG9yID0gaXNBcnIgPyBuZXcgQ3RvciA6IFtdO1xuICAgIH1cbiAgICBlbHNlIGlmIChpc09iamVjdChvYmplY3QpKSB7XG4gICAgICBhY2N1bXVsYXRvciA9IGlzRnVuY3Rpb24oQ3RvcikgPyBiYXNlQ3JlYXRlKGdldFByb3RvdHlwZShvYmplY3QpKSA6IHt9O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGFjY3VtdWxhdG9yID0ge307XG4gICAgfVxuICB9XG4gIChpc0Fyckxpa2UgPyBhcnJheUVhY2ggOiBiYXNlRm9yT3duKShvYmplY3QsIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgb2JqZWN0KSB7XG4gICAgcmV0dXJuIGl0ZXJhdGVlKGFjY3VtdWxhdG9yLCB2YWx1ZSwgaW5kZXgsIG9iamVjdCk7XG4gIH0pO1xuICByZXR1cm4gYWNjdW11bGF0b3I7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gdHJhbnNmb3JtO1xuIiwidmFyIGJhc2VGbGF0dGVuID0gcmVxdWlyZSgnLi9fYmFzZUZsYXR0ZW4nKSxcbiAgICBiYXNlUmVzdCA9IHJlcXVpcmUoJy4vX2Jhc2VSZXN0JyksXG4gICAgYmFzZVVuaXEgPSByZXF1aXJlKCcuL19iYXNlVW5pcScpLFxuICAgIGlzQXJyYXlMaWtlT2JqZWN0ID0gcmVxdWlyZSgnLi9pc0FycmF5TGlrZU9iamVjdCcpO1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdW5pcXVlIHZhbHVlcywgaW4gb3JkZXIsIGZyb20gYWxsIGdpdmVuIGFycmF5cyB1c2luZ1xuICogW2BTYW1lVmFsdWVaZXJvYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtc2FtZXZhbHVlemVybylcbiAqIGZvciBlcXVhbGl0eSBjb21wYXJpc29ucy5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgQXJyYXlcbiAqIEBwYXJhbSB7Li4uQXJyYXl9IFthcnJheXNdIFRoZSBhcnJheXMgdG8gaW5zcGVjdC5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIGNvbWJpbmVkIHZhbHVlcy5cbiAqIEBleGFtcGxlXG4gKlxuICogXy51bmlvbihbMl0sIFsxLCAyXSk7XG4gKiAvLyA9PiBbMiwgMV1cbiAqL1xudmFyIHVuaW9uID0gYmFzZVJlc3QoZnVuY3Rpb24oYXJyYXlzKSB7XG4gIHJldHVybiBiYXNlVW5pcShiYXNlRmxhdHRlbihhcnJheXMsIDEsIGlzQXJyYXlMaWtlT2JqZWN0LCB0cnVlKSk7XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSB1bmlvbjtcbiIsInZhciB0b1N0cmluZyA9IHJlcXVpcmUoJy4vdG9TdHJpbmcnKTtcblxuLyoqIFVzZWQgdG8gZ2VuZXJhdGUgdW5pcXVlIElEcy4gKi9cbnZhciBpZENvdW50ZXIgPSAwO1xuXG4vKipcbiAqIEdlbmVyYXRlcyBhIHVuaXF1ZSBJRC4gSWYgYHByZWZpeGAgaXMgZ2l2ZW4sIHRoZSBJRCBpcyBhcHBlbmRlZCB0byBpdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBtZW1iZXJPZiBfXG4gKiBAY2F0ZWdvcnkgVXRpbFxuICogQHBhcmFtIHtzdHJpbmd9IFtwcmVmaXg9JyddIFRoZSB2YWx1ZSB0byBwcmVmaXggdGhlIElEIHdpdGguXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSB1bmlxdWUgSUQuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8udW5pcXVlSWQoJ2NvbnRhY3RfJyk7XG4gKiAvLyA9PiAnY29udGFjdF8xMDQnXG4gKlxuICogXy51bmlxdWVJZCgpO1xuICogLy8gPT4gJzEwNSdcbiAqL1xuZnVuY3Rpb24gdW5pcXVlSWQocHJlZml4KSB7XG4gIHZhciBpZCA9ICsraWRDb3VudGVyO1xuICByZXR1cm4gdG9TdHJpbmcocHJlZml4KSArIGlkO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHVuaXF1ZUlkO1xuIiwidmFyIGJhc2VWYWx1ZXMgPSByZXF1aXJlKCcuL19iYXNlVmFsdWVzJyksXG4gICAga2V5cyA9IHJlcXVpcmUoJy4va2V5cycpO1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIG93biBlbnVtZXJhYmxlIHN0cmluZyBrZXllZCBwcm9wZXJ0eSB2YWx1ZXMgb2YgYG9iamVjdGAuXG4gKlxuICogKipOb3RlOioqIE5vbi1vYmplY3QgdmFsdWVzIGFyZSBjb2VyY2VkIHRvIG9iamVjdHMuXG4gKlxuICogQHN0YXRpY1xuICogQHNpbmNlIDAuMS4wXG4gKiBAbWVtYmVyT2YgX1xuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSB2YWx1ZXMuXG4gKiBAZXhhbXBsZVxuICpcbiAqIGZ1bmN0aW9uIEZvbygpIHtcbiAqICAgdGhpcy5hID0gMTtcbiAqICAgdGhpcy5iID0gMjtcbiAqIH1cbiAqXG4gKiBGb28ucHJvdG90eXBlLmMgPSAzO1xuICpcbiAqIF8udmFsdWVzKG5ldyBGb28pO1xuICogLy8gPT4gWzEsIDJdIChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpXG4gKlxuICogXy52YWx1ZXMoJ2hpJyk7XG4gKiAvLyA9PiBbJ2gnLCAnaSddXG4gKi9cbmZ1bmN0aW9uIHZhbHVlcyhvYmplY3QpIHtcbiAgcmV0dXJuIG9iamVjdCA9PSBudWxsID8gW10gOiBiYXNlVmFsdWVzKG9iamVjdCwga2V5cyhvYmplY3QpKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB2YWx1ZXM7XG4iLCJ2YXIgYXNzaWduVmFsdWUgPSByZXF1aXJlKCcuL19hc3NpZ25WYWx1ZScpLFxuICAgIGJhc2VaaXBPYmplY3QgPSByZXF1aXJlKCcuL19iYXNlWmlwT2JqZWN0Jyk7XG5cbi8qKlxuICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5mcm9tUGFpcnNgIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgdHdvIGFycmF5cyxcbiAqIG9uZSBvZiBwcm9wZXJ0eSBpZGVudGlmaWVycyBhbmQgb25lIG9mIGNvcnJlc3BvbmRpbmcgdmFsdWVzLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC40LjBcbiAqIEBjYXRlZ29yeSBBcnJheVxuICogQHBhcmFtIHtBcnJheX0gW3Byb3BzPVtdXSBUaGUgcHJvcGVydHkgaWRlbnRpZmllcnMuXG4gKiBAcGFyYW0ge0FycmF5fSBbdmFsdWVzPVtdXSBUaGUgcHJvcGVydHkgdmFsdWVzLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IG9iamVjdC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy56aXBPYmplY3QoWydhJywgJ2InXSwgWzEsIDJdKTtcbiAqIC8vID0+IHsgJ2EnOiAxLCAnYic6IDIgfVxuICovXG5mdW5jdGlvbiB6aXBPYmplY3QocHJvcHMsIHZhbHVlcykge1xuICByZXR1cm4gYmFzZVppcE9iamVjdChwcm9wcyB8fCBbXSwgdmFsdWVzIHx8IFtdLCBhc3NpZ25WYWx1ZSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gemlwT2JqZWN0O1xuIiwiLy8gZXh0cmFjdGVkIGJ5IG1pbmktY3NzLWV4dHJhY3QtcGx1Z2luXG5leHBvcnQge307IiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuZXhwb3J0cy5BbmltU2VxdWVuY2UgPSBleHBvcnRzLkFuaW0gPSB2b2lkIDA7XHJcbmNsYXNzIEFuaW0ge1xyXG4gICAgY29uc3RydWN0b3IodGFyZ2V0LCBkdXJhdGlvbiA9IDEwMDApIHtcclxuICAgICAgICB0aGlzLnRhcmdldCA9IHRhcmdldDtcclxuICAgICAgICB0aGlzLmR1cmF0aW9uID0gZHVyYXRpb247XHJcbiAgICAgICAgdGhpcy5zdGFydCA9IDA7XHJcbiAgICB9XHJcbiAgICBnZXQgc3RvcCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5zdGFydCArIHRoaXMuZHVyYXRpb247XHJcbiAgICB9XHJcbiAgICBwbGF5KCkge1xyXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHRoaXMuc3RhcnQgIT0gMCA/XHJcbiAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4gdGhpcy5ydW4ocmVzb2x2ZSksIHRoaXMuc3RhcnQpIDpcclxuICAgICAgICAgICAgdGhpcy5ydW4ocmVzb2x2ZSkpO1xyXG4gICAgfVxyXG59XHJcbmV4cG9ydHMuQW5pbSA9IEFuaW07XHJcbmNsYXNzIEFuaW1TZXF1ZW5jZSB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICB0aGlzLmFuaW1zID0gW107XHJcbiAgICB9XHJcbiAgICBwbGF5KCkge1xyXG4gICAgICAgIHJldHVybiBQcm9taXNlLmFsbCh0aGlzLmFuaW1zLm1hcChhID0+IGEucGxheSgpKSk7XHJcbiAgICB9XHJcbiAgICBhZGQoYW5pbSwgc3RhcnQpIHtcclxuICAgICAgICBhbmltLnN0YXJ0ID0gc3RhcnQ7XHJcbiAgICAgICAgbGV0IGkgPSB0aGlzLmFuaW1zLmZpbmRJbmRleChhID0+IGEuc3RhcnQgPiBzdGFydCk7XHJcbiAgICAgICAgaWYgKGkgPCAwKVxyXG4gICAgICAgICAgICB0aGlzLmFuaW1zLnB1c2goYW5pbSk7XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICB0aGlzLmFuaW1zLnNwbGljZShpLCAwLCBhbmltKTtcclxuICAgIH1cclxuICAgIGFkZEF0KGFuaW0sIHN0YXJ0KSB7XHJcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoYW5pbSkpXHJcbiAgICAgICAgICAgIGFuaW0uZm9yRWFjaChhID0+IHRoaXMuYWRkKGEsIHN0YXJ0KSk7XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICB0aGlzLmFkZChhbmltLCBzdGFydCk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcbiAgICBhZGRBZnRlcihhbmltLCBhZnRlciwgZGVsYXkgPSAwKSB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBhZnRlciA9PT0gXCJudW1iZXJcIilcclxuICAgICAgICAgICAgYWZ0ZXIgPSB0aGlzLmFuaW1zW2FmdGVyXTtcclxuICAgICAgICB0aGlzLmFkZEF0KGFuaW0sIGFmdGVyLnN0b3AgKyBkZWxheSk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcbiAgICBhZGRUb0VuZChhbmltLCBkZWxheSA9IDApIHtcclxuICAgICAgICBsZXQgbWF4c3RvcCA9IHRoaXMuYW5pbXMubGVuZ3RoID09IDAgPyAwIDpcclxuICAgICAgICAgICAgTWF0aC5tYXgoLi4udGhpcy5hbmltcy5tYXAoYSA9PiBhLnN0b3ApKTtcclxuICAgICAgICB0aGlzLmFkZEF0KGFuaW0sIG1heHN0b3AgKyBkZWxheSk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcbiAgICBhZGRUb0VuZFN0YWdnZXJlZChhbmltcywgZ2FwLCBkZWxheSA9IDApIHtcclxuICAgICAgICBsZXQgbWF4c3RvcCA9IHRoaXMuYW5pbXMubGVuZ3RoID09IDAgPyAwIDpcclxuICAgICAgICAgICAgTWF0aC5tYXgoLi4udGhpcy5hbmltcy5tYXAoYSA9PiBhLnN0b3ApKTtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFuaW1zLmxlbmd0aDsgKytpKVxyXG4gICAgICAgICAgICB0aGlzLmFkZEF0KGFuaW1zW2ldLCBtYXhzdG9wICsgZGVsYXkgKyAoaSAqIGdhcCkpO1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG59XHJcbmV4cG9ydHMuQW5pbVNlcXVlbmNlID0gQW5pbVNlcXVlbmNlO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1hbmltLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xyXG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XHJcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH0pO1xyXG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xyXG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcclxuICAgIG9bazJdID0gbVtrXTtcclxufSkpO1xyXG52YXIgX19zZXRNb2R1bGVEZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX3NldE1vZHVsZURlZmF1bHQpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIHYpIHtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBcImRlZmF1bHRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdiB9KTtcclxufSkgOiBmdW5jdGlvbihvLCB2KSB7XHJcbiAgICBvW1wiZGVmYXVsdFwiXSA9IHY7XHJcbn0pO1xyXG52YXIgX19pbXBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydFN0YXIpIHx8IGZ1bmN0aW9uIChtb2QpIHtcclxuICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XHJcbiAgICB2YXIgcmVzdWx0ID0ge307XHJcbiAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoayAhPT0gXCJkZWZhdWx0XCIgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIF9fY3JlYXRlQmluZGluZyhyZXN1bHQsIG1vZCwgayk7XHJcbiAgICBfX3NldE1vZHVsZURlZmF1bHQocmVzdWx0LCBtb2QpO1xyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxufTtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5leHBvcnRzLmFuaW1hdGVkVmlldyA9IGV4cG9ydHMuQW5pbWF0ZWRWaWV3ID0gdm9pZCAwO1xyXG5jb25zdCBlbCA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwiLi4vc3ZnL2VsZW1cIikpO1xyXG5jb25zdCBhZCA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwiLi9hbmltYXRlZFwiKSk7XHJcbmNvbnN0IGtmYSA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwiLi9rZXlmcmFtZS1hbmltXCIpKTtcclxuY2xhc3MgQW5pbWF0ZWRWaWV3IGV4dGVuZHMgYWQuQW5pbWF0ZWQge1xyXG4gICAgY29uc3RydWN0b3IocGFyZW50KSB7XHJcbiAgICAgICAgc3VwZXIocGFyZW50LmVsZW1lbnQpO1xyXG4gICAgICAgIHRoaXMuc3ZncGFyZW50ID0gcGFyZW50O1xyXG4gICAgfVxyXG4gICAgZ2V0IHBhcmVudFZCb3goKSB7XHJcbiAgICAgICAgcmV0dXJuIGVsLmdldFZpZXdCb3godGhpcy5zdmdwYXJlbnQpO1xyXG4gICAgfVxyXG4gICAgem9vbSh0bywgZHVyYXRpb24gPSAxMDAwKSB7XHJcbiAgICAgICAgbGV0IHZib3ggPSB0aGlzLnBhcmVudFZCb3g7XHJcbiAgICAgICAgbGV0IHNjYWxlID0gTWF0aC5taW4odmJveC53aWR0aCAvIHRvLndpZHRoLCB2Ym94LmhlaWdodCAvIHRvLmhlaWdodCk7XHJcbiAgICAgICAgbGV0IHggPSB2Ym94LmxlZnQgLSB0by5sZWZ0O1xyXG4gICAgICAgIGxldCB5ID0gdmJveC50b3AgLSB0by50b3A7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBrZmEuS2V5ZnJhbWVBbmltKHRoaXMsIFthZC5jdXJyZW50LCBhID0+IGEuc3RhdGUuc2NhbGUoc2NhbGUsIHNjYWxlKS5tb3ZlKHgsIHkpXSwgZHVyYXRpb24pO1xyXG4gICAgfVxyXG4gICAgem9vbUZhY3RvcihzY2FsZSwgeCwgeSwgZHVyYXRpb24gPSAxMDAwKSB7XHJcbiAgICAgICAgbGV0IHZib3ggPSB0aGlzLnBhcmVudFZCb3g7XHJcbiAgICAgICAgbGV0IHN4ID0gdmJveC5jZW50ZXJYIC0geDtcclxuICAgICAgICBsZXQgc3kgPSB2Ym94LmNlbnRlclkgLSB5O1xyXG4gICAgICAgIHJldHVybiBuZXcga2ZhLktleWZyYW1lQW5pbSh0aGlzLCBbYWQuY3VycmVudCwgYSA9PiBhLnN0YXRlLnNjYWxlKHNjYWxlLCBzY2FsZSkubW92ZShzeCwgc3kpXSwgZHVyYXRpb24pO1xyXG4gICAgfVxyXG4gICAgem9vbUhvbWUoZHVyYXRpb24gPSAxMDAwKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBrZmEuS2V5ZnJhbWVBbmltKHRoaXMsIFthZC5jdXJyZW50LCBhID0+IGEuc3RhdGUuc2NhbGUoMSwgMSkubW92ZSgwLCAwKV0sIGR1cmF0aW9uKTtcclxuICAgIH1cclxuICAgIHBhbih4LCB5LCBkdXJhdGlvbiA9IDEwMDApIHtcclxuICAgICAgICByZXR1cm4gbmV3IGtmYS5LZXlmcmFtZUFuaW0odGhpcywgW2FkLmN1cnJlbnQsXHJcbiAgICAgICAgICAgIGFkLm1vdmVSZWxhdGl2ZSgteCwgLXkpXSwgZHVyYXRpb24pO1xyXG4gICAgfVxyXG4gICAgcGFuVG8oeCwgeSwgZHVyYXRpb24gPSAxMDAwKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBrZmEuS2V5ZnJhbWVBbmltKHRoaXMsIFthZC5jdXJyZW50LCBhZC5tb3ZlKHgsIHkpXSwgZHVyYXRpb24pO1xyXG4gICAgfVxyXG59XHJcbmV4cG9ydHMuQW5pbWF0ZWRWaWV3ID0gQW5pbWF0ZWRWaWV3O1xyXG5mdW5jdGlvbiBhbmltYXRlZFZpZXcocGFyZW50KSB7XHJcbiAgICByZXR1cm4gbmV3IEFuaW1hdGVkVmlldyhwYXJlbnQpO1xyXG59XHJcbmV4cG9ydHMuYW5pbWF0ZWRWaWV3ID0gYW5pbWF0ZWRWaWV3O1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1hbmltYXRlZC12aWV3LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xyXG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XHJcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH0pO1xyXG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xyXG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcclxuICAgIG9bazJdID0gbVtrXTtcclxufSkpO1xyXG52YXIgX19zZXRNb2R1bGVEZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX3NldE1vZHVsZURlZmF1bHQpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIHYpIHtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBcImRlZmF1bHRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdiB9KTtcclxufSkgOiBmdW5jdGlvbihvLCB2KSB7XHJcbiAgICBvW1wiZGVmYXVsdFwiXSA9IHY7XHJcbn0pO1xyXG52YXIgX19pbXBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydFN0YXIpIHx8IGZ1bmN0aW9uIChtb2QpIHtcclxuICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XHJcbiAgICB2YXIgcmVzdWx0ID0ge307XHJcbiAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoayAhPT0gXCJkZWZhdWx0XCIgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIF9fY3JlYXRlQmluZGluZyhyZXN1bHQsIG1vZCwgayk7XHJcbiAgICBfX3NldE1vZHVsZURlZmF1bHQocmVzdWx0LCBtb2QpO1xyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxufTtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5leHBvcnRzLmJvdW5jZURvd24gPSBleHBvcnRzLmJvdW5jZVVwID0gZXhwb3J0cy5ib3VuY2VSaWdodCA9IGV4cG9ydHMuYm91bmNlTGVmdCA9IGV4cG9ydHMud29iYmxlWFkgPSBleHBvcnRzLndvYmJsZVkgPSBleHBvcnRzLndvYmJsZVggPSBleHBvcnRzLnNjYWxlWFkgPSBleHBvcnRzLnNjYWxlWSA9IGV4cG9ydHMuc2NhbGVYID0gZXhwb3J0cy5zaGlmdERvd24gPSBleHBvcnRzLnNoaWZ0VXAgPSBleHBvcnRzLnNoaWZ0UmlnaHQgPSBleHBvcnRzLnNoaWZ0TGVmdCA9IGV4cG9ydHMuc2hpZnQgPSBleHBvcnRzLm1vdmVSZWxhdGl2ZSA9IGV4cG9ydHMubW92ZSA9IGV4cG9ydHMubm9ybWFsU2l6ZSA9IGV4cG9ydHMuemVyb1NpemUgPSBleHBvcnRzLmN1cnJlbnQgPSBleHBvcnRzLnJlc2V0ID0gZXhwb3J0cy5vZmZzZXQgPSBleHBvcnRzLmFuaW1hdGVkID0gZXhwb3J0cy5BbmltYXRlZCA9IGV4cG9ydHMuQW5pbVN0YXRlID0gdm9pZCAwO1xyXG4vKipcclxuICogIyBBbmltYXRpbmcgU1ZHIEVsZW1lbnRzXHJcbiAqL1xyXG5jb25zdCBlbCA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwiLi4vc3ZnL2VsZW1cIikpO1xyXG5jb25zdCB2ZWMgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcIi4uL3N2Zy92ZWN0b3JcIikpO1xyXG5jbGFzcyBBbmltU3RhdGUge1xyXG4gICAgY29uc3RydWN0b3Ioc2NhbGluZywgcm90YXRpb24sIHBvc2l0aW9uLCBzaGlmdCkge1xyXG4gICAgICAgIHRoaXMuc2NhbGluZyA9IHNjYWxpbmc7XHJcbiAgICAgICAgdGhpcy5yb3RhdGlvbiA9IHJvdGF0aW9uO1xyXG4gICAgICAgIHRoaXMucG9zaXRpb24gPSBwb3NpdGlvbjtcclxuICAgICAgICB0aGlzLnNoaWZ0ID0gc2hpZnQ7XHJcbiAgICB9XHJcbiAgICBzY2FsZSh4LCB5KSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBBbmltU3RhdGUoW3gsIHldLCB0aGlzLnJvdGF0aW9uLCB0aGlzLnBvc2l0aW9uLCB0aGlzLnNoaWZ0KTtcclxuICAgIH1cclxuICAgIHJvdGF0ZShhbmdsZSkge1xyXG4gICAgICAgIHJldHVybiBuZXcgQW5pbVN0YXRlKHRoaXMuc2NhbGluZywgYW5nbGUsIHRoaXMucG9zaXRpb24sIHRoaXMuc2hpZnQpO1xyXG4gICAgfVxyXG4gICAgbW92ZSh4LCB5KSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBBbmltU3RhdGUodGhpcy5zY2FsaW5nLCB0aGlzLnJvdGF0aW9uLCBbeCwgeV0sIHRoaXMuc2hpZnQpO1xyXG4gICAgfVxyXG4gICAgbW92ZVJlbGF0aXZlKGR4LCBkeSkge1xyXG4gICAgICAgIGxldCBbeCwgeV0gPSB0aGlzLnBvc2l0aW9uO1xyXG4gICAgICAgIHJldHVybiBuZXcgQW5pbVN0YXRlKHRoaXMuc2NhbGluZywgdGhpcy5yb3RhdGlvbiwgW3ggKyBkeCwgeSArIGR5XSwgdGhpcy5zaGlmdCk7XHJcbiAgICB9XHJcbiAgICBzaGlmdFBvc2l0aW9uKHgsIHkpIHtcclxuICAgICAgICByZXR1cm4gbmV3IEFuaW1TdGF0ZSh0aGlzLnNjYWxpbmcsIHRoaXMucm90YXRpb24sIHRoaXMucG9zaXRpb24sIFt4LCB5XSk7XHJcbiAgICB9XHJcbiAgICBnZXQgbWF0cml4KCkge1xyXG4gICAgICAgIGxldCBbc3gsIHN5XSA9IHRoaXMuc2NhbGluZztcclxuICAgICAgICBsZXQgW3gsIHldID0gdmVjLmFkZFZlYyh0aGlzLnBvc2l0aW9uLCB0aGlzLnNoaWZ0KTtcclxuICAgICAgICByZXR1cm4gbmV3IERPTU1hdHJpeCgpXHJcbiAgICAgICAgICAgIC5zY2FsZShzeCwgc3kpXHJcbiAgICAgICAgICAgIC5yb3RhdGUoMCwgMCwgdGhpcy5yb3RhdGlvbilcclxuICAgICAgICAgICAgLnRyYW5zbGF0ZSh4LCB5KTtcclxuICAgIH1cclxuICAgIHRvS2V5ZnJhbWUoKSB7XHJcbiAgICAgICAgbGV0IFtzeCwgc3ldID0gdGhpcy5zY2FsaW5nO1xyXG4gICAgICAgIGxldCBbeCwgeV0gPSB2ZWMuYWRkVmVjKHRoaXMucG9zaXRpb24sIHRoaXMuc2hpZnQpO1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHRyYW5zZm9ybTogYHJvdGF0ZVooJHt0aGlzLnJvdGF0aW9ufWRlZykgYCArXHJcbiAgICAgICAgICAgICAgICBgdHJhbnNsYXRlM2QoJHt4fXB4LCAke3l9cHgsIDApIGAgK1xyXG4gICAgICAgICAgICAgICAgYHNjYWxlM2QoJHtzeH0sICR7c3l9LCAxKWAsXHJcbiAgICAgICAgICAgIG9mZnNldDogdGhpcy5vZmZzZXRcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG59XHJcbmV4cG9ydHMuQW5pbVN0YXRlID0gQW5pbVN0YXRlO1xyXG5BbmltU3RhdGUuemVybyA9IG5ldyBBbmltU3RhdGUodmVjLm9uZVZlY3RvciwgMCwgdmVjLnplcm9WZWN0b3IsIHZlYy56ZXJvVmVjdG9yKTtcclxuY2xhc3MgQW5pbWF0ZWQgZXh0ZW5kcyBlbC5HcmFwaEVsZW0ge1xyXG4gICAgY29uc3RydWN0b3IocGFyZW50KSB7XHJcbiAgICAgICAgc3VwZXIoZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKGVsLm5zLCAnZycpLCBwYXJlbnQpO1xyXG4gICAgICAgIHRoaXMuc3RhdGUgPSBBbmltU3RhdGUuemVybztcclxuICAgICAgICB0aGlzLnN0eWxlcyh7XHJcbiAgICAgICAgICAgIHRyYW5zZm9ybU9yaWdpbjogJ2NlbnRlcicsXHJcbiAgICAgICAgICAgIHRyYW5zZm9ybUJveDogJ2ZpbGwtYm94J1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgZ2V0IGFuaW1hdGVkQkJveCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5iYm94LnRyYW5zZm9ybSh0aGlzLnN0YXRlLm1hdHJpeCk7XHJcbiAgICB9XHJcbiAgICBwb3NpdGlvbihwb3MpIHtcclxuICAgICAgICBsZXQgW3gsIHldID0gcG9zO1xyXG4gICAgICAgIHRoaXMuc3RhdGUgPSB0aGlzLnN0YXRlLm1vdmUoeCwgeSk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcbn1cclxuZXhwb3J0cy5BbmltYXRlZCA9IEFuaW1hdGVkO1xyXG5mdW5jdGlvbiBhbmltYXRlZChwYXJlbnQpIHtcclxuICAgIHJldHVybiBuZXcgQW5pbWF0ZWQocGFyZW50IGluc3RhbmNlb2YgZWwuRWxlbSA/IHBhcmVudC5lbGVtZW50IDogcGFyZW50KTtcclxufVxyXG5leHBvcnRzLmFuaW1hdGVkID0gYW5pbWF0ZWQ7XHJcbmZ1bmN0aW9uIG9mZnNldChnZXRTdGF0ZSwgb2Zmc2V0KSB7XHJcbiAgICByZXR1cm4gYSA9PiB7XHJcbiAgICAgICAgbGV0IHN0YXRlID0gZ2V0U3RhdGUoYSk7XHJcbiAgICAgICAgc3RhdGUub2Zmc2V0ID0gb2Zmc2V0O1xyXG4gICAgICAgIHJldHVybiBzdGF0ZTtcclxuICAgIH07XHJcbn1cclxuZXhwb3J0cy5vZmZzZXQgPSBvZmZzZXQ7XHJcbmNvbnN0IHJlc2V0ID0gYSA9PiBuZXcgQW5pbVN0YXRlKFsxLCAxXSwgMCwgWzAsIDBdLCBbMCwgMF0pO1xyXG5leHBvcnRzLnJlc2V0ID0gcmVzZXQ7XHJcbmNvbnN0IGN1cnJlbnQgPSBhID0+IGEuc3RhdGU7XHJcbmV4cG9ydHMuY3VycmVudCA9IGN1cnJlbnQ7XHJcbmNvbnN0IHplcm9TaXplID0gYSA9PiBhLnN0YXRlLnNjYWxlKDAsIDApO1xyXG5leHBvcnRzLnplcm9TaXplID0gemVyb1NpemU7XHJcbmNvbnN0IG5vcm1hbFNpemUgPSBhID0+IGEuc3RhdGUuc2NhbGUoMSwgMSk7XHJcbmV4cG9ydHMubm9ybWFsU2l6ZSA9IG5vcm1hbFNpemU7XHJcbmZ1bmN0aW9uIG1vdmUoeCwgeSkge1xyXG4gICAgcmV0dXJuIGEgPT4gYS5zdGF0ZS5tb3ZlKHgsIHkpO1xyXG59XHJcbmV4cG9ydHMubW92ZSA9IG1vdmU7XHJcbmZ1bmN0aW9uIG1vdmVSZWxhdGl2ZSh4LCB5KSB7XHJcbiAgICByZXR1cm4gYSA9PiBhLnN0YXRlLm1vdmVSZWxhdGl2ZSh4LCB5KTtcclxufVxyXG5leHBvcnRzLm1vdmVSZWxhdGl2ZSA9IG1vdmVSZWxhdGl2ZTtcclxuZnVuY3Rpb24gc2hpZnQoeCwgeSkge1xyXG4gICAgcmV0dXJuIGEgPT4gYS5zdGF0ZS5zaGlmdFBvc2l0aW9uKHgsIHkpO1xyXG59XHJcbmV4cG9ydHMuc2hpZnQgPSBzaGlmdDtcclxuZnVuY3Rpb24gc2hpZnRMZWZ0KGRpc3QpIHtcclxuICAgIHJldHVybiBhID0+IGEuc3RhdGUuc2hpZnRQb3NpdGlvbigtZGlzdCAqIDEwMCwgMCk7XHJcbn1cclxuZXhwb3J0cy5zaGlmdExlZnQgPSBzaGlmdExlZnQ7XHJcbmZ1bmN0aW9uIHNoaWZ0UmlnaHQoZGlzdCkge1xyXG4gICAgcmV0dXJuIGEgPT4gYS5zdGF0ZS5zaGlmdFBvc2l0aW9uKGRpc3QgKiAxMDAsIDApO1xyXG59XHJcbmV4cG9ydHMuc2hpZnRSaWdodCA9IHNoaWZ0UmlnaHQ7XHJcbmZ1bmN0aW9uIHNoaWZ0VXAoZGlzdCkge1xyXG4gICAgcmV0dXJuIGEgPT4gYS5zdGF0ZS5zaGlmdFBvc2l0aW9uKDAsIC1kaXN0ICogMTAwKTtcclxufVxyXG5leHBvcnRzLnNoaWZ0VXAgPSBzaGlmdFVwO1xyXG5mdW5jdGlvbiBzaGlmdERvd24oZGlzdCkge1xyXG4gICAgcmV0dXJuIGEgPT4gYS5zdGF0ZS5zaGlmdFBvc2l0aW9uKDAsIGRpc3QgKiAxMDApO1xyXG59XHJcbmV4cG9ydHMuc2hpZnREb3duID0gc2hpZnREb3duO1xyXG5mdW5jdGlvbiBzY2FsZVgoc2NhbGUpIHtcclxuICAgIHJldHVybiBhID0+IGEuc3RhdGUuc2NhbGUoc2NhbGUsIDEpO1xyXG59XHJcbmV4cG9ydHMuc2NhbGVYID0gc2NhbGVYO1xyXG5mdW5jdGlvbiBzY2FsZVkoc2NhbGUpIHtcclxuICAgIHJldHVybiBhID0+IGEuc3RhdGUuc2NhbGUoMSwgc2NhbGUpO1xyXG59XHJcbmV4cG9ydHMuc2NhbGVZID0gc2NhbGVZO1xyXG5mdW5jdGlvbiBzY2FsZVhZKHNjYWxlKSB7XHJcbiAgICByZXR1cm4gYSA9PiBhLnN0YXRlLnNjYWxlKHNjYWxlLCBzY2FsZSk7XHJcbn1cclxuZXhwb3J0cy5zY2FsZVhZID0gc2NhbGVYWTtcclxuZnVuY3Rpb24qIHB1bHNhdGUodGltZXMsIGFtcGxpdHVkZSkge1xyXG4gICAgdGltZXMgKj0gMjtcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGltZXM7IGkrKylcclxuICAgICAgICB5aWVsZCBpICUgMiA9PSAxID8gMSA6ICgxIC0gYW1wbGl0dWRlKSArICgoaSAvIHRpbWVzKSAqIGFtcGxpdHVkZSk7XHJcbn1cclxuZnVuY3Rpb24gcHVsc2F0ZVRyYW5zZm9ybSh0aW1lcywgYW1wbGl0dWRlLCB0cmFuc2Zvcm0pIHtcclxuICAgIHJldHVybiBBcnJheS5mcm9tKHB1bHNhdGUodGltZXMsIGFtcGxpdHVkZSkpLm1hcCh0cmFuc2Zvcm0pO1xyXG59XHJcbmZ1bmN0aW9uIG9uZU1pbnVzKHRyYW5zZm9ybSkge1xyXG4gICAgcmV0dXJuIHNjYWxlID0+IHRyYW5zZm9ybSgxIC0gc2NhbGUpO1xyXG59XHJcbmZ1bmN0aW9uIGNyZWF0ZVB1bHNhdG9yKHRyYW5zZm9ybSkge1xyXG4gICAgcmV0dXJuICh0aW1lcyA9IDUsIGFtcGxpdHVkZSA9IHRpbWVzIC8gMTApID0+IHB1bHNhdGVUcmFuc2Zvcm0odGltZXMsIGFtcGxpdHVkZSwgdHJhbnNmb3JtKTtcclxufVxyXG5leHBvcnRzLndvYmJsZVggPSBjcmVhdGVQdWxzYXRvcihzY2FsZVgpO1xyXG5leHBvcnRzLndvYmJsZVkgPSBjcmVhdGVQdWxzYXRvcihzY2FsZVkpO1xyXG5leHBvcnRzLndvYmJsZVhZID0gY3JlYXRlUHVsc2F0b3Ioc2NhbGVYWSk7XHJcbmV4cG9ydHMuYm91bmNlTGVmdCA9IGNyZWF0ZVB1bHNhdG9yKG9uZU1pbnVzKHNoaWZ0TGVmdCkpO1xyXG5leHBvcnRzLmJvdW5jZVJpZ2h0ID0gY3JlYXRlUHVsc2F0b3Iob25lTWludXMoc2hpZnRSaWdodCkpO1xyXG5leHBvcnRzLmJvdW5jZVVwID0gY3JlYXRlUHVsc2F0b3Iob25lTWludXMoc2hpZnRVcCkpO1xyXG5leHBvcnRzLmJvdW5jZURvd24gPSBjcmVhdGVQdWxzYXRvcihvbmVNaW51cyhzaGlmdERvd24pKTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YW5pbWF0ZWQuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcclxuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfSk7XHJcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XHJcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xyXG4gICAgb1trMl0gPSBtW2tdO1xyXG59KSk7XHJcbnZhciBfX3NldE1vZHVsZURlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9fc2V0TW9kdWxlRGVmYXVsdCkgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgdikge1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIFwiZGVmYXVsdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2IH0pO1xyXG59KSA6IGZ1bmN0aW9uKG8sIHYpIHtcclxuICAgIG9bXCJkZWZhdWx0XCJdID0gdjtcclxufSk7XHJcbnZhciBfX2ltcG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0U3RhcikgfHwgZnVuY3Rpb24gKG1vZCkge1xyXG4gICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcclxuICAgIHZhciByZXN1bHQgPSB7fTtcclxuICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChrICE9PSBcImRlZmF1bHRcIiAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgX19jcmVhdGVCaW5kaW5nKHJlc3VsdCwgbW9kLCBrKTtcclxuICAgIF9fc2V0TW9kdWxlRGVmYXVsdChyZXN1bHQsIG1vZCk7XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG59O1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmV4cG9ydHMuY3VzdG9tQW5pbSA9IGV4cG9ydHMuQ3VzdG9tQW5pbSA9IHZvaWQgMDtcclxuY29uc3QgYW4gPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcIi4vYW5pbVwiKSk7XHJcbmNsYXNzIEN1c3RvbUFuaW0gZXh0ZW5kcyBhbi5BbmltIHtcclxuICAgIGNvbnN0cnVjdG9yKHRhcmdldCwgYWN0aW9uLCBkdXJhdGlvbiA9IDEwMDApIHtcclxuICAgICAgICBzdXBlcih0YXJnZXQsIGR1cmF0aW9uKTtcclxuICAgICAgICB0aGlzLmFjdGlvbiA9IGFjdGlvbjtcclxuICAgIH1cclxuICAgIHJ1bihyZXNvbHZlKSB7XHJcbiAgICAgICAgdGhpcy5hY3Rpb24odGhpcyk7XHJcbiAgICAgICAgcmVzb2x2ZSh0aGlzKTtcclxuICAgIH1cclxufVxyXG5leHBvcnRzLkN1c3RvbUFuaW0gPSBDdXN0b21BbmltO1xyXG5mdW5jdGlvbiBjdXN0b21BbmltKHRhcmdldCwgYWN0aW9uLCBkdXJhdGlvbiA9IDEwMDApIHtcclxuICAgIHJldHVybiBuZXcgQ3VzdG9tQW5pbSh0YXJnZXQsIGFjdGlvbiwgZHVyYXRpb24pO1xyXG59XHJcbmV4cG9ydHMuY3VzdG9tQW5pbSA9IGN1c3RvbUFuaW07XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWN1c3RvbS1hbmltLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xyXG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XHJcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH0pO1xyXG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xyXG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcclxuICAgIG9bazJdID0gbVtrXTtcclxufSkpO1xyXG52YXIgX19leHBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2V4cG9ydFN0YXIpIHx8IGZ1bmN0aW9uKG0sIGV4cG9ydHMpIHtcclxuICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKHAgIT09IFwiZGVmYXVsdFwiICYmICFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZXhwb3J0cywgcCkpIF9fY3JlYXRlQmluZGluZyhleHBvcnRzLCBtLCBwKTtcclxufTtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vYW5pbWF0ZWRcIiksIGV4cG9ydHMpO1xyXG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vYW5pbVwiKSwgZXhwb3J0cyk7XHJcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9rZXlmcmFtZS1hbmltXCIpLCBleHBvcnRzKTtcclxuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2N1c3RvbS1hbmltXCIpLCBleHBvcnRzKTtcclxuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2FuaW1hdGVkLXZpZXdcIiksIGV4cG9ydHMpO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcclxudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xyXG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9KTtcclxufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcclxuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XHJcbiAgICBvW2syXSA9IG1ba107XHJcbn0pKTtcclxudmFyIF9fc2V0TW9kdWxlRGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19zZXRNb2R1bGVEZWZhdWx0KSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCB2KSB7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgXCJkZWZhdWx0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHYgfSk7XHJcbn0pIDogZnVuY3Rpb24obywgdikge1xyXG4gICAgb1tcImRlZmF1bHRcIl0gPSB2O1xyXG59KTtcclxudmFyIF9faW1wb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnRTdGFyKSB8fCBmdW5jdGlvbiAobW9kKSB7XHJcbiAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xyXG4gICAgdmFyIHJlc3VsdCA9IHt9O1xyXG4gICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkgaWYgKGsgIT09IFwiZGVmYXVsdFwiICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSBfX2NyZWF0ZUJpbmRpbmcocmVzdWx0LCBtb2QsIGspO1xyXG4gICAgX19zZXRNb2R1bGVEZWZhdWx0KHJlc3VsdCwgbW9kKTtcclxuICAgIHJldHVybiByZXN1bHQ7XHJcbn07XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuZXhwb3J0cy5zcHJlYWRBcm91bmQgPSBleHBvcnRzLmZhZGVJbk91dCA9IGV4cG9ydHMuZmFkZU91dCA9IGV4cG9ydHMuZmFkZUluID0gZXhwb3J0cy56b29tSW4gPSBleHBvcnRzLnNsaWRlT3V0Qm90dG9tID0gZXhwb3J0cy5zbGlkZU91dFRvcCA9IGV4cG9ydHMuc2xpZGVPdXRSaWdodCA9IGV4cG9ydHMuc2xpZGVPdXRMZWZ0ID0gZXhwb3J0cy5zbGlkZUluQm90dG9tID0gZXhwb3J0cy5zbGlkZUluVG9wID0gZXhwb3J0cy5zbGlkZUluUmlnaHQgPSBleHBvcnRzLnNsaWRlSW5MZWZ0ID0gZXhwb3J0cy5zbGlkZVRvID0gZXhwb3J0cy52aXNpYmxlID0gZXhwb3J0cy5pbnZpc2libGUgPSBleHBvcnRzLktleWZyYW1lQW5pbSA9IHZvaWQgMDtcclxuY29uc3QgYWQgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcIi4vYW5pbWF0ZWRcIikpO1xyXG5jb25zdCBhbiA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwiLi9hbmltXCIpKTtcclxuY2xhc3MgS2V5ZnJhbWVBbmltIGV4dGVuZHMgYW4uQW5pbSB7XHJcbiAgICBjb25zdHJ1Y3Rvcih0YXJnZXQsIGtleWZyYW1lcywgZHVyYXRpb24gPSAxMDAwLCBmaWxsID0gXCJib3RoXCIsIGRpcmVjdGlvbiA9IFwibm9ybWFsXCIsIGl0ZXJhdGlvbnMgPSAxKSB7XHJcbiAgICAgICAgc3VwZXIodGFyZ2V0LCBkdXJhdGlvbik7XHJcbiAgICAgICAgdGhpcy5rZXlmcmFtZXMgPSBrZXlmcmFtZXM7XHJcbiAgICAgICAgdGhpcy5maWxsID0gZmlsbDtcclxuICAgICAgICB0aGlzLmRpcmVjdGlvbiA9IGRpcmVjdGlvbjtcclxuICAgICAgICB0aGlzLml0ZXJhdGlvbnMgPSBpdGVyYXRpb25zO1xyXG4gICAgfVxyXG4gICAgc3RvcE9uKGV2ZW50KSB7XHJcbiAgICAgICAgdGhpcy5zdG9wRXZlbnQgPSBldmVudDtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuICAgIGdldEtleWZyYW1lKGtmKSB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBrZiA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgICAgICBpZiAoISh0aGlzLnRhcmdldCBpbnN0YW5jZW9mIGFkLkFuaW1hdGVkKSlcclxuICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwiVGFyZ2V0IG5vdCBvZiB0eXBlIEFuaW1hdGVkXCIpO1xyXG4gICAgICAgICAgICBsZXQgc3RhdGUgPSBrZih0aGlzLnRhcmdldCk7XHJcbiAgICAgICAgICAgIHRoaXMudGFyZ2V0LnN0YXRlID0gc3RhdGU7XHJcbiAgICAgICAgICAgIHJldHVybiBzdGF0ZS50b0tleWZyYW1lKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBrZjtcclxuICAgIH1cclxuICAgIHJ1bihyZXNvbHZlKSB7XHJcbiAgICAgICAgbGV0IGEgPSB0aGlzLnRhcmdldC5lbGVtZW50LmFuaW1hdGUodGhpcy5rZXlmcmFtZXMubWFwKGtmID0+IHRoaXMuZ2V0S2V5ZnJhbWUoa2YpKSwge1xyXG4gICAgICAgICAgICBkdXJhdGlvbjogdGhpcy5kdXJhdGlvbixcclxuICAgICAgICAgICAgZmlsbDogdGhpcy5maWxsLFxyXG4gICAgICAgICAgICBkaXJlY3Rpb246IHRoaXMuZGlyZWN0aW9uLFxyXG4gICAgICAgICAgICBpdGVyYXRpb25zOiB0aGlzLml0ZXJhdGlvbnNcclxuICAgICAgICB9KTtcclxuICAgICAgICBhLm9uZmluaXNoID0gKCkgPT4gcmVzb2x2ZSh0aGlzKTtcclxuICAgICAgICBhLm9uY2FuY2VsID0gKCkgPT4gcmVzb2x2ZSh0aGlzKTtcclxuICAgICAgICBpZiAodGhpcy5zdG9wRXZlbnQpXHJcbiAgICAgICAgICAgIHRoaXMudGFyZ2V0LmVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcih0aGlzLnN0b3BFdmVudCwgKCkgPT4gYS5jYW5jZWwoKSk7XHJcbiAgICB9XHJcbn1cclxuZXhwb3J0cy5LZXlmcmFtZUFuaW0gPSBLZXlmcmFtZUFuaW07XHJcbmZ1bmN0aW9uIGludmlzaWJsZSgpIHsgcmV0dXJuIHsgb3BhY2l0eTogMCB9OyB9XHJcbmV4cG9ydHMuaW52aXNpYmxlID0gaW52aXNpYmxlO1xyXG5mdW5jdGlvbiB2aXNpYmxlKCkgeyByZXR1cm4geyBvcGFjaXR5OiAxIH07IH1cclxuZXhwb3J0cy52aXNpYmxlID0gdmlzaWJsZTtcclxuZnVuY3Rpb24gc2xpZGVUbyhlbGVtLCBwb3MsIGR1cmF0aW9uID0gMTAwMCkge1xyXG4gICAgbGV0IFt4LCB5XSA9IHBvcztcclxuICAgIHJldHVybiBuZXcgS2V5ZnJhbWVBbmltKGVsZW0sIFthZC5jdXJyZW50LCBhZC5tb3ZlKHgsIHkpXSwgZHVyYXRpb24pO1xyXG59XHJcbmV4cG9ydHMuc2xpZGVUbyA9IHNsaWRlVG87XHJcbmZ1bmN0aW9uIGNyZWF0ZVNsaWRlSW4obW92ZSwgYm91bmNlKSB7XHJcbiAgICByZXR1cm4gKGVsZW0sIGRpc3RhbmNlID0gMSwgZHVyYXRpb24gPSAxMDAwKSA9PiB7XHJcbiAgICAgICAgbGV0IGtmcyA9IFttb3ZlKGRpc3RhbmNlKSwgbW92ZSgwKV0uY29uY2F0KGJvdW5jZSgyKSk7XHJcbiAgICAgICAga2ZzWzFdID0gYWQub2Zmc2V0KGtmc1sxXSwgMC41ICsgTWF0aC5taW4oZHVyYXRpb24gLyAxMDAwMCwgMC41KSk7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBLZXlmcmFtZUFuaW0oZWxlbSwga2ZzLCBkdXJhdGlvbik7XHJcbiAgICB9O1xyXG59XHJcbmZ1bmN0aW9uIGNyZWF0ZVNsaWRlT3V0KG1vdmUpIHtcclxuICAgIHJldHVybiAoZWxlbSwgZGlzdGFuY2UgPSAxLCBkdXJhdGlvbiA9IDEwMDApID0+IHtcclxuICAgICAgICBsZXQga2ZzID0gKFttb3ZlKDApLCBtb3ZlKC1kaXN0YW5jZSAvIDIwKSwgbW92ZShkaXN0YW5jZSldKTtcclxuICAgICAgICBrZnNbMV0gPSBhZC5vZmZzZXQoa2ZzWzFdLCAwLjIpO1xyXG4gICAgICAgIHJldHVybiBuZXcgS2V5ZnJhbWVBbmltKGVsZW0sIGtmcywgZHVyYXRpb24pO1xyXG4gICAgfTtcclxufVxyXG5leHBvcnRzLnNsaWRlSW5MZWZ0ID0gY3JlYXRlU2xpZGVJbihhZC5zaGlmdExlZnQsIGFkLmJvdW5jZUxlZnQpO1xyXG5leHBvcnRzLnNsaWRlSW5SaWdodCA9IGNyZWF0ZVNsaWRlSW4oYWQuc2hpZnRSaWdodCwgYWQuYm91bmNlUmlnaHQpO1xyXG5leHBvcnRzLnNsaWRlSW5Ub3AgPSBjcmVhdGVTbGlkZUluKGFkLnNoaWZ0VXAsIGFkLmJvdW5jZVVwKTtcclxuZXhwb3J0cy5zbGlkZUluQm90dG9tID0gY3JlYXRlU2xpZGVJbihhZC5zaGlmdERvd24sIGFkLmJvdW5jZURvd24pO1xyXG5leHBvcnRzLnNsaWRlT3V0TGVmdCA9IGNyZWF0ZVNsaWRlT3V0KGFkLnNoaWZ0TGVmdCk7XHJcbmV4cG9ydHMuc2xpZGVPdXRSaWdodCA9IGNyZWF0ZVNsaWRlT3V0KGFkLnNoaWZ0UmlnaHQpO1xyXG5leHBvcnRzLnNsaWRlT3V0VG9wID0gY3JlYXRlU2xpZGVPdXQoYWQuc2hpZnRVcCk7XHJcbmV4cG9ydHMuc2xpZGVPdXRCb3R0b20gPSBjcmVhdGVTbGlkZU91dChhZC5zaGlmdERvd24pO1xyXG5mdW5jdGlvbiB6b29tSW4oZWxlbSwgZHVyYXRpb24gPSAxMDAwKSB7XHJcbiAgICBsZXQga2ZzID0gW2FkLnNjYWxlWFkoMCksIGFkLnNjYWxlWFkoMSldLmNvbmNhdChhZC53b2JibGVYWSgyKSk7XHJcbiAgICBrZnNbMV0gPSBhZC5vZmZzZXQoa2ZzWzFdLCAwLjUgKyBNYXRoLm1pbihkdXJhdGlvbiAvIDEwMDAwLCAwLjUpKTtcclxuICAgIHJldHVybiBuZXcgS2V5ZnJhbWVBbmltKGVsZW0sIGtmcywgZHVyYXRpb24pO1xyXG59XHJcbmV4cG9ydHMuem9vbUluID0gem9vbUluO1xyXG5mdW5jdGlvbiBmYWRlSW4oZWxlbSwgZHVyYXRpb24gPSAxMDAwKSB7XHJcbiAgICByZXR1cm4gbmV3IEtleWZyYW1lQW5pbShlbGVtLCBbaW52aXNpYmxlKCksIHZpc2libGUoKV0sIGR1cmF0aW9uKTtcclxufVxyXG5leHBvcnRzLmZhZGVJbiA9IGZhZGVJbjtcclxuZnVuY3Rpb24gZmFkZU91dChlbGVtLCBkdXJhdGlvbiA9IDEwMDApIHtcclxuICAgIHJldHVybiBuZXcgS2V5ZnJhbWVBbmltKGVsZW0sIFt2aXNpYmxlKCksIGludmlzaWJsZSgpXSwgZHVyYXRpb24pO1xyXG59XHJcbmV4cG9ydHMuZmFkZU91dCA9IGZhZGVPdXQ7XHJcbmZ1bmN0aW9uIGZhZGVJbk91dChlbGVtLCBkdXJhdGlvbiA9IDEwMDAsIGl0ZXJhdGlvbnMgPSAxKSB7XHJcbiAgICByZXR1cm4gbmV3IEtleWZyYW1lQW5pbShlbGVtLCBbaW52aXNpYmxlKCksIHZpc2libGUoKV0sIGR1cmF0aW9uLCBcImF1dG9cIiwgXCJhbHRlcm5hdGVcIiwgaXRlcmF0aW9ucyAqIDIpO1xyXG59XHJcbmV4cG9ydHMuZmFkZUluT3V0ID0gZmFkZUluT3V0O1xyXG5mdW5jdGlvbiBzZW1pQ2lyY2xlUG9zaXRpb25zKGNvdW50LCByYWRpdXMpIHtcclxuICAgIGxldCByZXMgPSBuZXcgQXJyYXkoY291bnQpO1xyXG4gICAgbGV0IGFuZ2xlID0gTWF0aC5QSSAvIChjb3VudCArIDEpO1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb3VudDsgaSsrKSB7XHJcbiAgICAgICAgbGV0IHggPSAtTWF0aC5jb3MoKGkgKyAxKSAqIGFuZ2xlKSAqIHJhZGl1cztcclxuICAgICAgICBsZXQgeSA9IC1NYXRoLnNpbigoaSArIDEpICogYW5nbGUpICogcmFkaXVzO1xyXG4gICAgICAgIHJlc1tpXSA9IFt4LCB5XTtcclxuICAgIH1cclxuICAgIHJldHVybiByZXM7XHJcbn1cclxuZnVuY3Rpb24gc3ByZWFkQXJvdW5kKGVsZW1zLCByYWRpdXMsIGR1cmF0aW9uKSB7XHJcbiAgICBsZXQgcG9zID0gc2VtaUNpcmNsZVBvc2l0aW9ucyhlbGVtcy5sZW5ndGgsIHJhZGl1cyk7XHJcbiAgICByZXR1cm4gZWxlbXMubWFwKChlLCBpKSA9PiB7XHJcbiAgICAgICAgbGV0IFt4LCB5XSA9IHBvc1tpXTtcclxuICAgICAgICByZXR1cm4gbmV3IEtleWZyYW1lQW5pbShlLCBbYWQubW92ZVJlbGF0aXZlKDAsIDApLCBhZC5tb3ZlUmVsYXRpdmUoeCwgeSldLCBkdXJhdGlvbik7XHJcbiAgICB9KTtcclxufVxyXG5leHBvcnRzLnNwcmVhZEFyb3VuZCA9IHNwcmVhZEFyb3VuZDtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9a2V5ZnJhbWUtYW5pbS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcclxudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xyXG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9KTtcclxufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcclxuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XHJcbiAgICBvW2syXSA9IG1ba107XHJcbn0pKTtcclxudmFyIF9fc2V0TW9kdWxlRGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19zZXRNb2R1bGVEZWZhdWx0KSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCB2KSB7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgXCJkZWZhdWx0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHYgfSk7XHJcbn0pIDogZnVuY3Rpb24obywgdikge1xyXG4gICAgb1tcImRlZmF1bHRcIl0gPSB2O1xyXG59KTtcclxudmFyIF9faW1wb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnRTdGFyKSB8fCBmdW5jdGlvbiAobW9kKSB7XHJcbiAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xyXG4gICAgdmFyIHJlc3VsdCA9IHt9O1xyXG4gICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkgaWYgKGsgIT09IFwiZGVmYXVsdFwiICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSBfX2NyZWF0ZUJpbmRpbmcocmVzdWx0LCBtb2QsIGspO1xyXG4gICAgX19zZXRNb2R1bGVEZWZhdWx0KHJlc3VsdCwgbW9kKTtcclxuICAgIHJldHVybiByZXN1bHQ7XHJcbn07XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuZXhwb3J0cy5kaWdyYXBoID0gZXhwb3J0cy5lZGdlcyA9IGV4cG9ydHMubm9kZXMgPSBleHBvcnRzLkFycm93UG9zID0gdm9pZCAwO1xyXG5jb25zdCBzdmcgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcIi4vc3ZnXCIpKTtcclxuY29uc3QgYW5pbSA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwiLi9hbmltXCIpKTtcclxuY29uc3QgZGFncmUgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcImRhZ3JlXCIpKTtcclxudmFyIEFycm93UG9zO1xyXG4oZnVuY3Rpb24gKEFycm93UG9zKSB7XHJcbiAgICBBcnJvd1Bvc1tBcnJvd1Bvc1tcIlNvdXJjZVwiXSA9IDBdID0gXCJTb3VyY2VcIjtcclxuICAgIEFycm93UG9zW0Fycm93UG9zW1wiRGVzdGluYXRpb25cIl0gPSAxXSA9IFwiRGVzdGluYXRpb25cIjtcclxufSkoQXJyb3dQb3MgPSBleHBvcnRzLkFycm93UG9zIHx8IChleHBvcnRzLkFycm93UG9zID0ge30pKTtcclxuY29uc3QgZGVmYXVsdE5vZGVzZXAgPSAxNjtcclxuY29uc3QgZGVmYXVsdFJhbmtzZXAgPSAxNjtcclxuZnVuY3Rpb24gbm9kZXMoLi4ubm9kZXMpIHtcclxuICAgIHJldHVybiBub2Rlcy5tYXAobiA9PiB7XHJcbiAgICAgICAgcmV0dXJuIHR5cGVvZiAobikgPT0gJ3N0cmluZycgP1xyXG4gICAgICAgICAgICB7IG5hbWU6IG4sIGxhYmVsOiBuIH0gOlxyXG4gICAgICAgICAgICB7IG5hbWU6IG5bMF0sIGxhYmVsOiBuWzFdIH07XHJcbiAgICB9KTtcclxufVxyXG5leHBvcnRzLm5vZGVzID0gbm9kZXM7XHJcbmZ1bmN0aW9uIGVkZ2VzKGVkZ2VzLCBhcnJvdykge1xyXG4gICAgcmV0dXJuIGVkZ2VzLm1hcChlID0+IHtcclxuICAgICAgICByZXR1cm4gZS5sZW5ndGggPCAzID9cclxuICAgICAgICAgICAgeyBhcnJvdywgc291cmNlOiBlWzBdLCBkZXN0aW5hdGlvbjogZVsxXSB9IDpcclxuICAgICAgICAgICAgeyBhcnJvdywgc291cmNlOiBlWzBdLCBkZXN0aW5hdGlvbjogZVsxXSwgbGFiZWw6IGVbMl0gfTtcclxuICAgIH0pO1xyXG59XHJcbmV4cG9ydHMuZWRnZXMgPSBlZGdlcztcclxuZnVuY3Rpb24gZHJhd05vZGUobm9kZSwgcGFyZW50LCBtYXJnaW4gPSAxMCkge1xyXG4gICAgbGV0IGdyb3VwID0gc3ZnLmdyb3VwKHBhcmVudCk7XHJcbiAgICBsZXQgcCA9IG5vZGUubGluayA/IHN2Zy5saW5rKGdyb3VwLCBub2RlLmxpbmspIDogZ3JvdXA7XHJcbiAgICBsZXQgdGV4dCA9IHN2Zy50ZXh0KHAsIG5vZGUubGFiZWwpO1xyXG4gICAgbGV0IGJiID0gdGV4dC5iYm94LmluZmxhdGUobWFyZ2luLCBtYXJnaW4pO1xyXG4gICAgbGV0IHNoYXBlID0gbm9kZS5zaGFwZSB8fCBzdmcucmVjdDtcclxuICAgIHNoYXBlKHAsIGJiLmxlZnQsIGJiLnRvcCwgYmIud2lkdGgsIGJiLmhlaWdodCkubW92ZVRvQmFjaygpO1xyXG4gICAgZ3JvdXAudHJhbnNsYXRlKHN2Zy5SZWN0UG9zLkNlbnRlcik7XHJcbiAgICBub2RlLmVsZW0gPSBncm91cC5hZGRDbGFzcyhcIm5vZGVcIik7XHJcbn1cclxuZnVuY3Rpb24gZHJhd0VkZ2VMYWJlbChlZGdlLCBwYXJlbnQpIHtcclxuICAgIGxldCB0ZXh0ID0gc3ZnLnRleHQocGFyZW50LCBlZGdlLmxhYmVsKTtcclxuICAgIHRleHQudHJhbnNsYXRlKHN2Zy5SZWN0UG9zLkNlbnRlcik7XHJcbiAgICBlZGdlLmVsZW0gPSB0ZXh0LmFkZENsYXNzKFwiZWRnZWxhYmVsXCIpO1xyXG59XHJcbmZ1bmN0aW9uIGFkZEFycm93KGFycm93LCBzdmdyb290LCBwYXRoKSB7XHJcbiAgICBpZiAoIWFycm93LmVsZW0pXHJcbiAgICAgICAgYXJyb3cuZWxlbSA9IHN2Zy5hcnJvdyhzdmdyb290LmNoaWxkKCdkZWZzJyksIGFycm93LndpZHRoLCBhcnJvdy5sZW5ndGgsIGFycm93LmNsb3NlZCkuYWRkQ2xhc3MoYXJyb3cuY2xhc3NOYW1lKTtcclxuICAgIGlmIChhcnJvdy5wb3NpdGlvbnMuaW5jbHVkZXMoQXJyb3dQb3MuU291cmNlKSlcclxuICAgICAgICBzdmcuc2V0TWFya2VyKHBhdGgsIGFycm93LmVsZW0sIHN2Zy5NYXJrZXJQb3MuU3RhcnQpO1xyXG4gICAgaWYgKGFycm93LnBvc2l0aW9ucy5pbmNsdWRlcyhBcnJvd1Bvcy5EZXN0aW5hdGlvbikpXHJcbiAgICAgICAgc3ZnLnNldE1hcmtlcihwYXRoLCBhcnJvdy5lbGVtLCBzdmcuTWFya2VyUG9zLkVuZCk7XHJcbn1cclxuZnVuY3Rpb24gZGlzdChwdDEsIHB0Mikge1xyXG4gICAgbGV0IGR4ID0gcHQxLnggLSBwdDIueDtcclxuICAgIGxldCBkeSA9IHB0MS55IC0gcHQyLnk7XHJcbiAgICByZXR1cm4gTWF0aC5zcXJ0KGR4ICogZHggKyBkeSAqIGR5KTtcclxufVxyXG5mdW5jdGlvbiBkcmF3RWRnZShlZGdlLCBzdmdyb290LCBwYXJlbnQsIGFycm93LCBjdXJ2ZWRFZGdlcywgcmFua3NlcCkge1xyXG4gICAgbGV0IHAgPSBlZGdlLnBvaW50cztcclxuICAgIGxldCBjbWRzID0gW25ldyBzdmcuTW92ZVRvKCdNJywgcFswXS54LCBwWzBdLnkpXTtcclxuICAgIGxldCBsZW4gPSBwLmxlbmd0aDtcclxuICAgIGxldCBpID0gMTtcclxuICAgIHdoaWxlIChpIDwgbGVuKVxyXG4gICAgICAgIGlmICghY3VydmVkRWRnZXMgfHxcclxuICAgICAgICAgICAgKGxlbiA8PSAzICYmIChpID09IGxlbiAtIDEgfHwgZGlzdChwW2ldLCBwW2kgKyAxXSkgPCByYW5rc2VwKSkpIHtcclxuICAgICAgICAgICAgY21kcy5wdXNoKG5ldyBzdmcuTGluZVRvKCdMJywgcFtpXS54LCBwW2ldLnkpKTtcclxuICAgICAgICAgICAgaSsrO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChpIDwgbGVuIC0gMSkge1xyXG4gICAgICAgICAgICBjbWRzLnB1c2gobmV3IHN2Zy5Db250Q3ViaWNDdXJ2ZVRvKCdTJywgcFtpXS54LCBwW2ldLnksIHBbaSArIDFdLngsIHBbaSArIDFdLnkpKTtcclxuICAgICAgICAgICAgaSArPSAyO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgY21kcy5wdXNoKG5ldyBzdmcuQ29udFF1YWRDdXJ2ZVRvKCdUJywgcFtpXS54LCBwW2ldLnkpKTtcclxuICAgICAgICAgICAgaSsrO1xyXG4gICAgICAgIH1cclxuICAgIGxldCByZXMgPSBzdmcucGF0aChwYXJlbnQsIGNtZHMpLmFkZENsYXNzKFwiZWRnZVwiKTtcclxuICAgIGlmIChhcnJvdylcclxuICAgICAgICBhZGRBcnJvdyhhcnJvdywgc3Zncm9vdCwgcmVzKTtcclxuICAgIHJldHVybiByZXMubW92ZVRvQmFjaygpO1xyXG59XHJcbmZ1bmN0aW9uIGRlZmluZURpZ3JhcGgoZGlncmFwaCwgc3Zncm9vdCwgdmlld3BvcnQsIGRnKSB7XHJcbiAgICBkaWdyYXBoLm5vZGVzLmZvckVhY2gobm9kZSA9PiB7XHJcbiAgICAgICAgZHJhd05vZGUobm9kZSwgdmlld3BvcnQsIGRpZ3JhcGgubm9kZU1hcmdpbik7XHJcbiAgICAgICAgbGV0IGJib3ggPSBub2RlLmVsZW0uYmJveDtcclxuICAgICAgICBkZy5zZXROb2RlKG5vZGUubmFtZSwge1xyXG4gICAgICAgICAgICBsYWJlbDogbm9kZS5sYWJlbCxcclxuICAgICAgICAgICAgd2lkdGg6IGJib3gud2lkdGgsXHJcbiAgICAgICAgICAgIGhlaWdodDogYmJveC5oZWlnaHRcclxuICAgICAgICB9KTtcclxuICAgIH0pO1xyXG4gICAgZGlncmFwaC5lZGdlcy5mb3JFYWNoKGVkZ2UgPT4ge1xyXG4gICAgICAgIGlmIChlZGdlLmxhYmVsKSB7XHJcbiAgICAgICAgICAgIGRyYXdFZGdlTGFiZWwoZWRnZSwgdmlld3BvcnQpO1xyXG4gICAgICAgICAgICBsZXQgeyB3aWR0aCwgaGVpZ2h0IH0gPSBlZGdlLmVsZW0uYmJveDtcclxuICAgICAgICAgICAgZGcuc2V0RWRnZShlZGdlLnNvdXJjZS5uYW1lLCBlZGdlLmRlc3RpbmF0aW9uLm5hbWUsIHtcclxuICAgICAgICAgICAgICAgIGxhYmVsOiBlZGdlLmxhYmVsLFxyXG4gICAgICAgICAgICAgICAgbGFiZWxwb3M6IGRpZ3JhcGguZWRnZUxhYmVsUG9zIHx8ICdyJyxcclxuICAgICAgICAgICAgICAgIHdpZHRoLCBoZWlnaHRcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2VcclxuICAgICAgICAgICAgZGcuc2V0RWRnZShlZGdlLnNvdXJjZS5uYW1lLCBlZGdlLmRlc3RpbmF0aW9uLm5hbWUpO1xyXG4gICAgfSk7XHJcbn1cclxuZnVuY3Rpb24gbGF5b3V0RGlncmFwaChkaWdyYXBoLCBzdmdyb290LCB2aWV3cG9ydCwgZGcpIHtcclxuICAgIGRpZ3JhcGgubm9kZXMuZm9yRWFjaChub2RlID0+IHtcclxuICAgICAgICBsZXQgZG4gPSBkZy5ub2RlKG5vZGUubmFtZSk7XHJcbiAgICAgICAgbGV0IGUgPSBub2RlLmVsZW07XHJcbiAgICAgICAgZS50cmFuc2Zvcm0gPSBlLnRyYW5zZm9ybS50cmFuc2xhdGUoZG4ueCwgZG4ueSk7XHJcbiAgICB9KTtcclxuICAgIGRpZ3JhcGguZWRnZXMuZm9yRWFjaChlZGdlID0+IHtcclxuICAgICAgICBsZXQgZGUgPSBkZy5lZGdlKGVkZ2Uuc291cmNlLm5hbWUsIGVkZ2UuZGVzdGluYXRpb24ubmFtZSk7XHJcbiAgICAgICAgZHJhd0VkZ2UoZGUsIHN2Z3Jvb3QsIHZpZXdwb3J0LCBlZGdlLmFycm93LCBkaWdyYXBoLmN1cnZlZEVkZ2VzLCBkaWdyYXBoLnJhbmtzZXAgfHwgZGVmYXVsdFJhbmtzZXApO1xyXG4gICAgICAgIGxldCBlID0gZWRnZS5lbGVtO1xyXG4gICAgICAgIGlmIChlKVxyXG4gICAgICAgICAgICBlLnRyYW5zZm9ybSA9IGUudHJhbnNmb3JtLnRyYW5zbGF0ZShkZS54LCBkZS55KTtcclxuICAgIH0pO1xyXG59XHJcbmZ1bmN0aW9uIGNyZWF0ZURpZ3JhcGgoZGlncmFwaCwgcGFyZW50KSB7XHJcbiAgICBsZXQgc3Zncm9vdCA9IHN2Zy5jcmVhdGUoJ3N2ZycsIHBhcmVudCkuYWRkQ2xhc3MoXCJkaWdyYXBoXCIpXHJcbiAgICAgICAgLnN0eWxlcyh7IGN1cnNvcjogXCJ6b29tLWluXCIgfSk7XHJcbiAgICBzdmcuZGVmcyhzdmdyb290KTtcclxuICAgIGxldCBncmFwaCA9IG5ldyBkYWdyZS5ncmFwaGxpYi5HcmFwaCgpO1xyXG4gICAgZ3JhcGguc2V0R3JhcGgoe1xyXG4gICAgICAgIHJhbmtkaXI6IGRpZ3JhcGguZGlyZWN0aW9uIHx8ICdUQicsXHJcbiAgICAgICAgbm9kZXNlcDogZGlncmFwaC5ub2Rlc2VwIHx8IGRlZmF1bHROb2Rlc2VwLFxyXG4gICAgICAgIHJhbmtzZXA6IGRpZ3JhcGgucmFua3NlcCB8fCBkZWZhdWx0UmFua3NlcFxyXG4gICAgfSk7XHJcbiAgICBncmFwaC5zZXREZWZhdWx0RWRnZUxhYmVsKCh2LCB3KSA9PiB7IHJldHVybiB7fTsgfSk7XHJcbiAgICBsZXQgdmlld3BvcnQgPSBhbmltLmFuaW1hdGVkVmlldyhzdmdyb290KS5zdHlsZXMoeyBjdXJzb3I6IFwiem9vbS1pblwiIH0pO1xyXG4gICAgZGVmaW5lRGlncmFwaChkaWdyYXBoLCBzdmdyb290LCB2aWV3cG9ydCwgZ3JhcGgpO1xyXG4gICAgZGFncmUubGF5b3V0KGdyYXBoKTtcclxuICAgIGxheW91dERpZ3JhcGgoZGlncmFwaCwgc3Zncm9vdCwgdmlld3BvcnQsIGdyYXBoKTtcclxuICAgIHN2Zy5zZXRCb3VuZHMoc3Zncm9vdCwgZGlncmFwaC5tYXJnaW4gfHwgMTApO1xyXG4gICAgcmV0dXJuIHN2Z3Jvb3QuY2xpY2tlZChlID0+IHpvb21Jbk91dChzdmdyb290LCB2aWV3cG9ydCwgZSkpO1xyXG59XHJcbmxldCB6b29tZWQgPSBmYWxzZTtcclxuY29uc3Qgem9vbVNwZWVkID0gMzAwO1xyXG5mdW5jdGlvbiB6b29tSW5PdXQoc3Zncm9vdCwgdmlld3BvcnQsIGV2ZW50KSB7XHJcbiAgICBsZXQgem9vbUFuaW0gPSBudWxsO1xyXG4gICAgaWYgKCF6b29tZWQpIHtcclxuICAgICAgICBsZXQgcyA9IHN2Z3Jvb3QuZWxlbWVudDtcclxuICAgICAgICBsZXQgcHQgPSBzLmNyZWF0ZVNWR1BvaW50KCk7XHJcbiAgICAgICAgcHQueCA9IGV2ZW50LmNsaWVudFg7XHJcbiAgICAgICAgcHQueSA9IGV2ZW50LmNsaWVudFk7XHJcbiAgICAgICAgbGV0IHsgeCwgeSB9ID0gcHQubWF0cml4VHJhbnNmb3JtKHMuZ2V0U2NyZWVuQ1RNKCkuaW52ZXJzZSgpKTtcclxuICAgICAgICB6b29tQW5pbSA9IHZpZXdwb3J0Lnpvb21GYWN0b3IoMiwgeCwgeSwgem9vbVNwZWVkKTtcclxuICAgIH1cclxuICAgIGVsc2VcclxuICAgICAgICB6b29tQW5pbSA9IHZpZXdwb3J0Lnpvb21Ib21lKHpvb21TcGVlZCk7XHJcbiAgICB6b29tZWQgPSAhem9vbWVkO1xyXG4gICAgc3Zncm9vdC5zdHlsZXMoeyBjdXJzb3I6IHpvb21lZCA/IFwiem9vbS1vdXRcIiA6IFwiem9vbS1pblwiIH0pO1xyXG4gICAgbmV3IGFuaW0uQW5pbVNlcXVlbmNlKCkuYWRkQXQoem9vbUFuaW0sIDApLnBsYXkoKTtcclxufVxyXG5mdW5jdGlvbiBkaWdyYXBoKGRnLCBwYXJlbnQpIHtcclxuICAgIGxldCBzdmdyb290ID0gbnVsbDtcclxuICAgIGlmICghZG9jdW1lbnQuZm9udHMgfHwgZG9jdW1lbnQuZm9udHMuc3RhdHVzID09IFwibG9hZGVkXCIpXHJcbiAgICAgICAgc3Zncm9vdCA9IGNyZWF0ZURpZ3JhcGgoZGcsIHBhcmVudCk7XHJcbiAgICBlbHNlXHJcbiAgICAgICAgZG9jdW1lbnQuZm9udHMub25sb2FkaW5nZG9uZSA9ICgpID0+IHtcclxuICAgICAgICAgICAgaWYgKHN2Z3Jvb3QpXHJcbiAgICAgICAgICAgICAgICBzdmdyb290LmRlbGV0ZSgpO1xyXG4gICAgICAgICAgICBzdmdyb290ID0gY3JlYXRlRGlncmFwaChkZywgcGFyZW50KTtcclxuICAgICAgICB9O1xyXG59XHJcbmV4cG9ydHMuZGlncmFwaCA9IGRpZ3JhcGg7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRpZ3JhcGguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcclxuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfSk7XHJcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XHJcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xyXG4gICAgb1trMl0gPSBtW2tdO1xyXG59KSk7XHJcbnZhciBfX3NldE1vZHVsZURlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9fc2V0TW9kdWxlRGVmYXVsdCkgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgdikge1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIFwiZGVmYXVsdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2IH0pO1xyXG59KSA6IGZ1bmN0aW9uKG8sIHYpIHtcclxuICAgIG9bXCJkZWZhdWx0XCJdID0gdjtcclxufSk7XHJcbnZhciBfX2ltcG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0U3RhcikgfHwgZnVuY3Rpb24gKG1vZCkge1xyXG4gICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcclxuICAgIHZhciByZXN1bHQgPSB7fTtcclxuICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChrICE9PSBcImRlZmF1bHRcIiAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgX19jcmVhdGVCaW5kaW5nKHJlc3VsdCwgbW9kLCBrKTtcclxuICAgIF9fc2V0TW9kdWxlRGVmYXVsdChyZXN1bHQsIG1vZCk7XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG59O1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmV4cG9ydHMuZmlsZURpYWdyYW0gPSBleHBvcnRzLnRlcm1pbmFsID0gZXhwb3J0cy5maWxlID0gZXhwb3J0cy5mb2xkZXIgPSBleHBvcnRzLnRlcm1pbmFsRGltZW5zaW9ucyA9IGV4cG9ydHMuZmlsZURpbWVuc2lvbnMgPSBleHBvcnRzLmZvbGRlckRpbWVuc2lvbnMgPSB2b2lkIDA7XHJcbmNvbnN0IHN2ZyA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwiLi9zdmdcIikpO1xyXG5jb25zdCBhbmltID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCIuL2FuaW1cIikpO1xyXG5leHBvcnRzLmZvbGRlckRpbWVuc2lvbnMgPSB7XHJcbiAgICB3aWR0aDogODAsXHJcbiAgICBoZWlnaHQ6IDYwLFxyXG4gICAgcmFkaXVzOiA0XHJcbn07XHJcbmV4cG9ydHMuZmlsZURpbWVuc2lvbnMgPSB7XHJcbiAgICB3aWR0aDogNjAsXHJcbiAgICBoZWlnaHQ6IDgwLFxyXG4gICAgcmFkaXVzOiA0XHJcbn07XHJcbmV4cG9ydHMudGVybWluYWxEaW1lbnNpb25zID0ge1xyXG4gICAgd2lkdGg6IDEwMCxcclxuICAgIGhlaWdodDogODAsXHJcbiAgICByYWRpdXM6IDRcclxufTtcclxuZnVuY3Rpb24gY29udGFpbmVyM0QocGFyZW50KSB7XHJcbiAgICByZXR1cm4gc3ZnLmdyb3VwKHBhcmVudCkuYWRkQ2xhc3MoXCJjb250YWluZXIzRFwiKTtcclxufVxyXG5mdW5jdGlvbiBpY29uUmVjdChwYXJlbnQsIGRpbXMpIHtcclxuICAgIGxldCB4ID0gZGltcy53aWR0aCAvIDI7XHJcbiAgICBsZXQgeSA9IGRpbXMuaGVpZ2h0IC8gMjtcclxuICAgIHJldHVybiBzdmcucmVjdChwYXJlbnQsIC14LCAteSwgZGltcy53aWR0aCwgZGltcy5oZWlnaHQsIGRpbXMucmFkaXVzKTtcclxufVxyXG5mdW5jdGlvbiBmb2xkZXIocGFyZW50LCBjYXB0aW9uLCBkaW1zID0gZXhwb3J0cy5mb2xkZXJEaW1lbnNpb25zKSB7XHJcbiAgICBsZXQgcmVzID0gY29udGFpbmVyM0QocGFyZW50KTtcclxuICAgIGxldCBiYWNrID0gc3ZnLmdyb3VwKHJlcykuYWRkQ2xhc3MoXCJmb2xkZXItYmFja1wiKTtcclxuICAgIGljb25SZWN0KGJhY2ssIGRpbXMpO1xyXG4gICAgbGV0IHggPSBkaW1zLndpZHRoIC8gMjtcclxuICAgIGxldCB5ID0gZGltcy5oZWlnaHQgLyAyO1xyXG4gICAgbGV0IHR3ID0gMC4zMCAqIGRpbXMud2lkdGg7XHJcbiAgICBsZXQgdGggPSAwLjI1ICogZGltcy5oZWlnaHQ7XHJcbiAgICBzdmcucmVjdChiYWNrLCAteCwgLXkgLSAodGggLyAyKSwgdHcsIHRoLCBkaW1zLnJhZGl1cyk7XHJcbiAgICBsZXQgZnJvbnQgPSBzdmcuZ3JvdXAocmVzKS5hZGRDbGFzcyhcImZvbGRlci1mcm9udFwiKVxyXG4gICAgICAgIC5zdHlsZXMoe1xyXG4gICAgICAgIHRyYW5zZm9ybU9yaWdpbjogYCR7eH1weCAke3l9cHhgXHJcbiAgICB9KTtcclxuICAgIGljb25SZWN0KGZyb250LCBkaW1zKTtcclxuICAgIHN2Zy50ZXh0KGZyb250LCBjYXB0aW9uKS50cmFuc2xhdGUoc3ZnLlJlY3RQb3MuQ2VudGVyKTtcclxuICAgIGxldCBrZnMgPSBbXHJcbiAgICAgICAgeyB0cmFuc2Zvcm06ICdyb3RhdGVYKDBkZWcpJyB9LFxyXG4gICAgICAgIHsgdHJhbnNmb3JtOiAncm90YXRlWCgzMGRlZyknIH1cclxuICAgIF07XHJcbiAgICByZXMub3BlbiA9IG5ldyBhbmltLktleWZyYW1lQW5pbShmcm9udCwga2ZzLCAyMDApO1xyXG4gICAgcmVzLmNsb3NlID0gbmV3IGFuaW0uS2V5ZnJhbWVBbmltKGZyb250LCBrZnMuc2xpY2UoKS5yZXZlcnNlKCksIDIwMCk7XHJcbiAgICByZXR1cm4gcmVzO1xyXG59XHJcbmV4cG9ydHMuZm9sZGVyID0gZm9sZGVyO1xyXG5mdW5jdGlvbiBkb2NMaW5lcyhkaW1zKSB7XHJcbiAgICBsZXQgdyA9IGRpbXMud2lkdGggLSAyMDtcclxuICAgIGxldCBoID0gZGltcy5oZWlnaHQgLSAyMDtcclxuICAgIGxldCByZXMgPSBbXTtcclxuICAgIGZvciAobGV0IHkgPSAwOyB5IDwgaDsgeSArPSA1KSB7XHJcbiAgICAgICAgaWYgKE1hdGgucmFuZG9tKCkgPiAwLjIpIHtcclxuICAgICAgICAgICAgcmVzLnB1c2gobmV3IHN2Zy5Nb3ZlVG8oXCJNXCIsIDAsIHkpKTtcclxuICAgICAgICAgICAgcmVzLnB1c2gobmV3IHN2Zy5ITGluZVRvKFwiaFwiLCB3IC0gKE1hdGgucmFuZG9tKCkgKiA1KSkpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiByZXM7XHJcbn1cclxuZnVuY3Rpb24gZmlsZShwYXJlbnQsIHR5cGVTdHIsIGNhcHRpb24sIGRpbXMgPSBleHBvcnRzLmZpbGVEaW1lbnNpb25zKSB7XHJcbiAgICBsZXQgY29udGFpbmVyID0gY29udGFpbmVyM0QocGFyZW50KTtcclxuICAgIGxldCBkb2MgPSBzdmcuZ3JvdXAoY29udGFpbmVyKS5hZGRDbGFzcyhcImRvY3VtZW50XCIpO1xyXG4gICAgbGV0IG1hc2sgPSBzdmcubWFzayhkb2MpO1xyXG4gICAgaWNvblJlY3QobWFzaywgZGltcykuYXR0cnMoe1xyXG4gICAgICAgIGZpbGw6IFwid2hpdGVcIixcclxuICAgICAgICBzdHJva2U6IFwid2hpdGVcIlxyXG4gICAgfSk7XHJcbiAgICBsZXQgbXcgPSBkaW1zLndpZHRoIC8gMjtcclxuICAgIGxldCBtaCA9IGRpbXMuaGVpZ2h0IC8gMjtcclxuICAgIGxldCBmc2l6ZSA9IG13IC8gMjtcclxuICAgIHN2Zy5wYXRoKG1hc2ssIGBNMCAtMSBoJHttd30gdiR7bXd9IHpgKS5hdHRycyh7XHJcbiAgICAgICAgdHJhbnNmb3JtOiBgdHJhbnNsYXRlKCR7ZnNpemV9ICR7LW1ofSlgLFxyXG4gICAgICAgIGZpbGw6IFwiYmxhY2tcIixcclxuICAgICAgICBzdHJva2U6IFwiYmxhY2tcIlxyXG4gICAgfSk7XHJcbiAgICBsZXQgZ3JvdXAgPSBzdmcuZ3JvdXAoZG9jKS5hdHRycyh7XHJcbiAgICAgICAgbWFzazogYHVybCgjJHttYXNrLmlkfSlgXHJcbiAgICB9KTtcclxuICAgIGljb25SZWN0KGdyb3VwLCBkaW1zKTtcclxuICAgIHN2Zy5wYXRoKGdyb3VwLCBkb2NMaW5lcyhkaW1zKSkuYXR0cnMoe1xyXG4gICAgICAgIFwic3Ryb2tlLXdpZHRoXCI6IDJcclxuICAgIH0pXHJcbiAgICAgICAgLnRyYW5zbGF0ZShzdmcuUmVjdFBvcy5DZW50ZXIpO1xyXG4gICAgc3ZnLnRleHQoZ3JvdXAsIHR5cGVTdHIpLmFkZENsYXNzKFwiZG9jLWJnXCIpO1xyXG4gICAgc3ZnLnJlY3QoZ3JvdXAsIGZzaXplLCAtbWgsIGZzaXplLCBmc2l6ZSwgZGltcy5yYWRpdXMgLyAyKTtcclxuICAgIHN2Zy50ZXh0KGRvYywgY2FwdGlvbikuYWRkQ2xhc3MoXCJkb2MtdGV4dFwiKVxyXG4gICAgICAgIC50cmFuc2xhdGUoc3ZnLlJlY3RQb3MuQ2VudGVyLCBbMCwgZnNpemVdKTtcclxuICAgIHJldHVybiBjb250YWluZXI7XHJcbn1cclxuZXhwb3J0cy5maWxlID0gZmlsZTtcclxuZnVuY3Rpb24gdGl0bGVCdXR0b24ocGFyZW50LCB4LCB5LCB0aCkge1xyXG4gICAgbGV0IGJkID0gdGggLyAyO1xyXG4gICAgbGV0IGJyID0gdGggLyA0O1xyXG4gICAgcmV0dXJuIHN2Zy5lbGxpcHNlKHBhcmVudCwgeCAtIGJkLCAteSArIGJkLCBiciwgYnIpO1xyXG59XHJcbmZ1bmN0aW9uIHRlcm1pbmFsKHBhcmVudCwgY2FwdGlvbiwgZGltcyA9IGV4cG9ydHMudGVybWluYWxEaW1lbnNpb25zKSB7XHJcbiAgICBsZXQgY29udGFpbmVyID0gY29udGFpbmVyM0QocGFyZW50KTtcclxuICAgIGxldCB0ZXJtID0gc3ZnLmdyb3VwKGNvbnRhaW5lcikuYWRkQ2xhc3MoXCJ0ZXJtaW5hbFwiKTtcclxuICAgIGljb25SZWN0KHRlcm0sIGRpbXMpO1xyXG4gICAgbGV0IHggPSBkaW1zLndpZHRoIC8gMjtcclxuICAgIGxldCB5ID0gZGltcy5oZWlnaHQgLyAyO1xyXG4gICAgbGV0IHRoID0gZGltcy5oZWlnaHQgLyA4O1xyXG4gICAgc3ZnLnJlY3QodGVybSwgLXgsIC15LCBkaW1zLndpZHRoLCB0aCwgZGltcy5yYWRpdXMgLyAyKVxyXG4gICAgICAgIC5hZGRDbGFzcyhcInRpdGxlLWJhclwiKTtcclxuICAgIGxldCBzcCA9IHRoICogMC43NTtcclxuICAgIHRpdGxlQnV0dG9uKHRlcm0sIHgsIHksIHRoKTtcclxuICAgIHRpdGxlQnV0dG9uKHRlcm0sIHggLSBzcCwgeSwgdGgpO1xyXG4gICAgdGl0bGVCdXR0b24odGVybSwgeCAtIChzcCAqIDIpLCB5LCB0aCk7XHJcbiAgICBjYXB0aW9uID0gXCI+XCIgKyBjYXB0aW9uICsgXCJfXCI7XHJcbiAgICBsZXQgdGV4dCA9IHN2Zy50ZXh0KHRlcm0sIGNhcHRpb24pLmFkZENsYXNzKFwidGVybWluYWwtdGV4dFwiKVxyXG4gICAgICAgIC50cmFuc2xhdGUoc3ZnLlJlY3RQb3MuQ2VudGVyKTtcclxuICAgIGNvbnRhaW5lci5zZXRDYXB0aW9uID0gdmFsdWUgPT4gQXJyYXkuZnJvbSh7IGxlbmd0aDogdmFsdWUubGVuZ3RoICsgMSB9KVxyXG4gICAgICAgIC5tYXAoKF8sIGkpID0+IGFuaW0uY3VzdG9tQW5pbSh0ZXh0LCBhID0+IGEudGFyZ2V0LnRleHQgPSBcIj5cIiArIHZhbHVlLnNsaWNlKDAsIGkpICsgXCJfXCIsIDApKTtcclxuICAgIHJldHVybiBjb250YWluZXI7XHJcbn1cclxuZXhwb3J0cy50ZXJtaW5hbCA9IHRlcm1pbmFsO1xyXG5mdW5jdGlvbiBmaWxlRGlhZ3JhbShwYXJlbnQsIHdpZHRoLCBoZWlnaHQpIHtcclxuICAgIGxldCB2YiA9IG5ldyBzdmcuUmVjdCgwLCAwLCB3aWR0aCwgaGVpZ2h0KTtcclxuICAgIGxldCByZXMgPSBzdmcuY3JlYXRlKCdzdmcnLCBwYXJlbnQpLmFkZENsYXNzKFwiZmlsZS1kaWFncmFtXCIpLmF0dHJzKHsgd2lkdGg6IHZiLndpZHRoLCBoZWlnaHQ6IHZiLmhlaWdodCB9KTtcclxuICAgIHN2Zy5zZXRWaWV3Qm94KHJlcywgdmIpO1xyXG4gICAgcmV0dXJuIHJlcztcclxufVxyXG5leHBvcnRzLmZpbGVEaWFncmFtID0gZmlsZURpYWdyYW07XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWZpbGUtZGlhZ3JhbS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcclxudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xyXG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9KTtcclxufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcclxuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XHJcbiAgICBvW2syXSA9IG1ba107XHJcbn0pKTtcclxudmFyIF9fc2V0TW9kdWxlRGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19zZXRNb2R1bGVEZWZhdWx0KSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCB2KSB7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgXCJkZWZhdWx0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHYgfSk7XHJcbn0pIDogZnVuY3Rpb24obywgdikge1xyXG4gICAgb1tcImRlZmF1bHRcIl0gPSB2O1xyXG59KTtcclxudmFyIF9faW1wb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnRTdGFyKSB8fCBmdW5jdGlvbiAobW9kKSB7XHJcbiAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xyXG4gICAgdmFyIHJlc3VsdCA9IHt9O1xyXG4gICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkgaWYgKGsgIT09IFwiZGVmYXVsdFwiICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSBfX2NyZWF0ZUJpbmRpbmcocmVzdWx0LCBtb2QsIGspO1xyXG4gICAgX19zZXRNb2R1bGVEZWZhdWx0KHJlc3VsdCwgbW9kKTtcclxuICAgIHJldHVybiByZXN1bHQ7XHJcbn07XHJcbnZhciBfX2V4cG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9fZXhwb3J0U3RhcikgfHwgZnVuY3Rpb24obSwgZXhwb3J0cykge1xyXG4gICAgZm9yICh2YXIgcCBpbiBtKSBpZiAocCAhPT0gXCJkZWZhdWx0XCIgJiYgIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChleHBvcnRzLCBwKSkgX19jcmVhdGVCaW5kaW5nKGV4cG9ydHMsIG0sIHApO1xyXG59O1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmV4cG9ydHMuYW5pbSA9IGV4cG9ydHMuc3ZnID0gdm9pZCAwO1xyXG5jb25zdCBzdmcgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcIi4vc3ZnXCIpKTtcclxuZXhwb3J0cy5zdmcgPSBzdmc7XHJcbmNvbnN0IGFuaW0gPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcIi4vYW5pbVwiKSk7XHJcbmV4cG9ydHMuYW5pbSA9IGFuaW07XHJcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9kaWdyYXBoXCIpLCBleHBvcnRzKTtcclxuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2ZpbGUtZGlhZ3JhbVwiKSwgZXhwb3J0cyk7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xyXG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XHJcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH0pO1xyXG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xyXG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcclxuICAgIG9bazJdID0gbVtrXTtcclxufSkpO1xyXG52YXIgX19zZXRNb2R1bGVEZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX3NldE1vZHVsZURlZmF1bHQpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIHYpIHtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBcImRlZmF1bHRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdiB9KTtcclxufSkgOiBmdW5jdGlvbihvLCB2KSB7XHJcbiAgICBvW1wiZGVmYXVsdFwiXSA9IHY7XHJcbn0pO1xyXG52YXIgX19pbXBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydFN0YXIpIHx8IGZ1bmN0aW9uIChtb2QpIHtcclxuICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XHJcbiAgICB2YXIgcmVzdWx0ID0ge307XHJcbiAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoayAhPT0gXCJkZWZhdWx0XCIgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIF9fY3JlYXRlQmluZGluZyhyZXN1bHQsIG1vZCwgayk7XHJcbiAgICBfX3NldE1vZHVsZURlZmF1bHQocmVzdWx0LCBtb2QpO1xyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxufTtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5leHBvcnRzLmxpbmsgPSBleHBvcnRzLm1hc2sgPSBleHBvcnRzLnBvbHlnb24gPSBleHBvcnRzLnBvbHlsaW5lID0gZXhwb3J0cy5wYXRoID0gZXhwb3J0cy5lbGxpcHNlID0gZXhwb3J0cy5jaXJjbGUgPSBleHBvcnRzLnJlY3QgPSBleHBvcnRzLnRzcGFuID0gZXhwb3J0cy50ZXh0ID0gZXhwb3J0cy5ncm91cCA9IGV4cG9ydHMuY3NzID0gZXhwb3J0cy5zZXRWaWV3Qm94ID0gZXhwb3J0cy5nZXRWaWV3Qm94ID0gZXhwb3J0cy5zZXRCb3VuZHMgPSBleHBvcnRzLmRlZnMgPSBleHBvcnRzLmNyZWF0ZSA9IGV4cG9ydHMuR3JhcGhFbGVtID0gZXhwb3J0cy5FbGVtID0gZXhwb3J0cy54bGluayA9IGV4cG9ydHMubnMgPSB2b2lkIDA7XHJcbmNvbnN0IHJ0ID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCIuL3JlY3RcIikpO1xyXG5leHBvcnRzLm5zID0gJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJztcclxuZXhwb3J0cy54bGluayA9ICdodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rJztcclxudmFyIGxhc3RHZW5JZCA9IDA7XHJcbmNsYXNzIEVsZW0ge1xyXG4gICAgY29uc3RydWN0b3IoZWxlbSwgcGFyZW50KSB7XHJcbiAgICAgICAgdGhpcy5lbGVtID0gZWxlbTtcclxuICAgICAgICBwYXJlbnQuYXBwZW5kQ2hpbGQodGhpcy5lbGVtKTtcclxuICAgIH1cclxuICAgIGdldCBlbGVtZW50KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmVsZW07XHJcbiAgICB9XHJcbiAgICBnZXQgaWQoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZWxlbS5pZDtcclxuICAgIH1cclxuICAgIHNldCBpZCh2YWx1ZSkge1xyXG4gICAgICAgIHRoaXMuZWxlbS5pZCA9IHZhbHVlO1xyXG4gICAgfVxyXG4gICAgZ2V0IHBhcmVudCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5lbGVtLnBhcmVudEVsZW1lbnQ7XHJcbiAgICB9XHJcbiAgICBnZXQgY2xhc3NlcygpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5lbGVtLmNsYXNzTGlzdDtcclxuICAgIH1cclxuICAgIGdldCBzdHlsZSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5lbGVtLnN0eWxlO1xyXG4gICAgfVxyXG4gICAgZ2V0IHRleHQoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZWxlbS50ZXh0Q29udGVudDtcclxuICAgIH1cclxuICAgIHNldCB0ZXh0KGNvbnRlbnQpIHtcclxuICAgICAgICB0aGlzLmVsZW0udGV4dENvbnRlbnQgPSBjb250ZW50O1xyXG4gICAgfVxyXG4gICAgYWRkQ2xhc3MobmFtZSkge1xyXG4gICAgICAgIHRoaXMuZWxlbS5jbGFzc0xpc3QuYWRkKG5hbWUpO1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG4gICAgcmVtb3ZlQ2xhc3MobmFtZSkge1xyXG4gICAgICAgIHRoaXMuZWxlbS5jbGFzc0xpc3QucmVtb3ZlKG5hbWUpO1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG4gICAgdG9nZ2xlQ2xhc3MobmFtZSkge1xyXG4gICAgICAgIHRoaXMuZWxlbS5jbGFzc0xpc3QudG9nZ2xlKG5hbWUpO1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG4gICAgYXR0cihuYW1lKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZWxlbS5nZXRBdHRyaWJ1dGUobmFtZSk7XHJcbiAgICB9XHJcbiAgICBhdHRycyhvYmosIG5hbWVzcGFjZSA9IG51bGwpIHtcclxuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBvYmopXHJcbiAgICAgICAgICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkoa2V5KSkge1xyXG4gICAgICAgICAgICAgICAgbGV0IHZhbCA9IG9ialtrZXldO1xyXG4gICAgICAgICAgICAgICAgaWYgKHZhbCBpbnN0YW5jZW9mIEFycmF5KVxyXG4gICAgICAgICAgICAgICAgICAgIHZhbCA9IHZhbC5qb2luKFwiIFwiKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuZWxlbS5zZXRBdHRyaWJ1dGVOUyhuYW1lc3BhY2UsIGtleSwgdmFsKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG4gICAgY2hpbGQodGFnKSB7XHJcbiAgICAgICAgbGV0IGVsID0gdGhpcy5lbGVtLnF1ZXJ5U2VsZWN0b3IodGFnKTtcclxuICAgICAgICByZXR1cm4gKGVsIGluc3RhbmNlb2YgU1ZHR3JhcGhpY3NFbGVtZW50ID8gbmV3IEdyYXBoRWxlbShlbCwgdGhpcy5lbGVtKSA6XHJcbiAgICAgICAgICAgIGVsIGluc3RhbmNlb2YgU1ZHRWxlbWVudCA/IG5ldyBFbGVtKGVsLCB0aGlzLmVsZW0pIDpcclxuICAgICAgICAgICAgICAgIG51bGwpO1xyXG4gICAgfVxyXG4gICAgc3R5bGVzKG9iaikge1xyXG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIG9iailcclxuICAgICAgICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShrZXkpKVxyXG4gICAgICAgICAgICAgICAgdGhpcy5lbGVtLnN0eWxlW2tleV0gPSBvYmpba2V5XTtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuICAgIGRlbGV0ZSgpIHtcclxuICAgICAgICB0aGlzLmVsZW0ucGFyZW50RWxlbWVudC5yZW1vdmVDaGlsZCh0aGlzLmVsZW0pO1xyXG4gICAgfVxyXG4gICAgZGVsZXRlQ2hpbGRyZW4oKSB7XHJcbiAgICAgICAgd2hpbGUgKHRoaXMuZWxlbS5maXJzdENoaWxkKVxyXG4gICAgICAgICAgICB0aGlzLmVsZW0ucmVtb3ZlQ2hpbGQodGhpcy5lbGVtLmZpcnN0Q2hpbGQpO1xyXG4gICAgfVxyXG4gICAgbW92ZVVuZGVyKHBhcmVudCkge1xyXG4gICAgICAgIHBhcmVudC5lbGVtLmFwcGVuZENoaWxkKHRoaXMuZWxlbSk7XHJcbiAgICB9XHJcbiAgICBtb3ZlVG9CYWNrKCkge1xyXG4gICAgICAgIGxldCBwYXJlbnQgPSB0aGlzLmVsZW0ucGFyZW50RWxlbWVudDtcclxuICAgICAgICBwYXJlbnQuaW5zZXJ0QmVmb3JlKHRoaXMuZWxlbSwgcGFyZW50LmNoaWxkcmVuWzBdKTtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuICAgIG1vdmVUb0Zyb250KCkge1xyXG4gICAgICAgIHRoaXMuZWxlbS5wYXJlbnRFbGVtZW50LmFwcGVuZENoaWxkKHRoaXMuZWxlbSk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcbn1cclxuZXhwb3J0cy5FbGVtID0gRWxlbTtcclxuY2xhc3MgR3JhcGhFbGVtIGV4dGVuZHMgRWxlbSB7XHJcbiAgICBnZXQgYmJveCgpIHtcclxuICAgICAgICByZXR1cm4gcnQuUmVjdC5mcm9tRE9NUmVjdCh0aGlzLmVsZW0uZ2V0QkJveCh7IHN0cm9rZTogdHJ1ZSB9KSk7XHJcbiAgICB9XHJcbiAgICBnZXQgdHJhbnNmb3JtKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmVsZW0uZ2V0Q1RNKCk7XHJcbiAgICB9XHJcbiAgICBzZXQgdHJhbnNmb3JtKG1hdCkge1xyXG4gICAgICAgIGxldCB0ciA9IHRoaXMuZWxlbS5vd25lclNWR0VsZW1lbnQuY3JlYXRlU1ZHVHJhbnNmb3JtRnJvbU1hdHJpeChtYXQpO1xyXG4gICAgICAgIHRoaXMuZWxlbS50cmFuc2Zvcm0uYmFzZVZhbC5pbml0aWFsaXplKHRyKTtcclxuICAgIH1cclxuICAgIGhpZGUoKSB7XHJcbiAgICAgICAgdGhpcy5zdHlsZXMoeyBvcGFjaXR5OiAnMCcgfSk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcbiAgICBzaG93KCkge1xyXG4gICAgICAgIHRoaXMuc3R5bGVzKHsgb3BhY2l0eTogJzEnIH0pO1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG4gICAgdHJhbnNsYXRlKHBvcywgdG8gPSBbMCwgMF0pIHtcclxuICAgICAgICB0aGlzLnRyYW5zZm9ybSA9IHRoaXMuYmJveC50cmFuc2xhdGVUbyh0aGlzLnRyYW5zZm9ybSwgcG9zLCB0byk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcbiAgICBjbGlja2VkKGhhbmRsZXIpIHtcclxuICAgICAgICB0aGlzLmVsZW0ub25jbGljayA9IGhhbmRsZXI7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcbiAgICBtb3VzZW92ZXIoaGFuZGxlcikge1xyXG4gICAgICAgIHRoaXMuZWxlbS5vbm1vdXNlb3ZlciA9IGhhbmRsZXI7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcbiAgICBtb3VzZW1vdmUoaGFuZGxlcikge1xyXG4gICAgICAgIHRoaXMuZWxlbS5vbm1vdXNlbW92ZSA9IGhhbmRsZXI7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcbn1cclxuZXhwb3J0cy5HcmFwaEVsZW0gPSBHcmFwaEVsZW07XHJcbmZ1bmN0aW9uIGNyZWF0ZSh0YWcsIHBhcmVudCkge1xyXG4gICAgbGV0IGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoZXhwb3J0cy5ucywgdGFnKTtcclxuICAgIGxldCBwID0gcGFyZW50IGluc3RhbmNlb2YgRWxlbSA/IHBhcmVudC5lbGVtZW50IDogcGFyZW50O1xyXG4gICAgcmV0dXJuIChlIGluc3RhbmNlb2YgU1ZHR3JhcGhpY3NFbGVtZW50ID9cclxuICAgICAgICBuZXcgR3JhcGhFbGVtKGUsIHApIDogbmV3IEVsZW0oZSwgcCkpO1xyXG59XHJcbmV4cG9ydHMuY3JlYXRlID0gY3JlYXRlO1xyXG5mdW5jdGlvbiBkZWZzKHN2Z3Jvb3QpIHtcclxuICAgIHJldHVybiBjcmVhdGUoJ2RlZnMnLCBzdmdyb290KTtcclxufVxyXG5leHBvcnRzLmRlZnMgPSBkZWZzO1xyXG5mdW5jdGlvbiBzZXRCb3VuZHMoc3Zncm9vdCwgaG1hcmdpbiwgdm1hcmdpbiA9IGhtYXJnaW4pIHtcclxuICAgIGxldCB2YiA9IHN2Z3Jvb3QuYmJveC5pbmZsYXRlKGhtYXJnaW4sIHZtYXJnaW4pO1xyXG4gICAgc2V0Vmlld0JveChzdmdyb290LCB2Yik7XHJcbiAgICBzdmdyb290LmF0dHJzKHsgd2lkdGg6IHZiLndpZHRoLCBoZWlnaHQ6IHZiLmhlaWdodCB9KTtcclxufVxyXG5leHBvcnRzLnNldEJvdW5kcyA9IHNldEJvdW5kcztcclxuZnVuY3Rpb24gZ2V0Vmlld0JveChlbGVtKSB7XHJcbiAgICByZXR1cm4gcnQuUmVjdC5mcm9tRE9NUmVjdChlbGVtLmVsZW1lbnQudmlld0JveC5iYXNlVmFsKTtcclxufVxyXG5leHBvcnRzLmdldFZpZXdCb3ggPSBnZXRWaWV3Qm94O1xyXG5mdW5jdGlvbiBzZXRWaWV3Qm94KGVsZW0sIHZpZXdCb3gpIHtcclxuICAgIGxldCB7IGxlZnQsIHRvcCwgd2lkdGgsIGhlaWdodCB9ID0gdmlld0JveDtcclxuICAgIGVsZW0uYXR0cnMoeyB2aWV3Qm94OiBgJHtsZWZ0fSAke3RvcH0gJHt3aWR0aH0gJHtoZWlnaHR9YCB9KTtcclxufVxyXG5leHBvcnRzLnNldFZpZXdCb3ggPSBzZXRWaWV3Qm94O1xyXG5mdW5jdGlvbiBjc3MocGFyZW50KSB7XHJcbiAgICByZXR1cm4gcGFyZW50LmNoaWxkKCdzdHlsZScpIHx8IGNyZWF0ZSgnc3R5bGUnLCBwYXJlbnQpO1xyXG59XHJcbmV4cG9ydHMuY3NzID0gY3NzO1xyXG5mdW5jdGlvbiBncm91cChwYXJlbnQpIHtcclxuICAgIHJldHVybiBjcmVhdGUoJ2cnLCBwYXJlbnQpO1xyXG59XHJcbmV4cG9ydHMuZ3JvdXAgPSBncm91cDtcclxuZnVuY3Rpb24gdGV4dChwYXJlbnQsIGNhcHRpb24pIHtcclxuICAgIGxldCByZXMgPSBjcmVhdGUoJ3RleHQnLCBwYXJlbnQpO1xyXG4gICAgaWYgKGNhcHRpb24pXHJcbiAgICAgICAgcmVzLnRleHQgPSBjYXB0aW9uO1xyXG4gICAgcmV0dXJuIHJlcztcclxufVxyXG5leHBvcnRzLnRleHQgPSB0ZXh0O1xyXG5mdW5jdGlvbiB0c3BhbihwYXJlbnQsIGNhcHRpb24pIHtcclxuICAgIGxldCByZXMgPSBjcmVhdGUoJ3RzcGFuJywgcGFyZW50KTtcclxuICAgIGlmIChjYXB0aW9uKVxyXG4gICAgICAgIHJlcy50ZXh0ID0gY2FwdGlvbjtcclxuICAgIHJldHVybiByZXM7XHJcbn1cclxuZXhwb3J0cy50c3BhbiA9IHRzcGFuO1xyXG5mdW5jdGlvbiByZWN0KHBhcmVudCwgeCwgeSwgd2lkdGgsIGhlaWdodCwgcnggPSAwLCByeSA9IHJ4KSB7XHJcbiAgICByZXR1cm4gY3JlYXRlKCdyZWN0JywgcGFyZW50KS5hdHRycyh7IHgsIHksIHdpZHRoLCBoZWlnaHQsIHJ4LCByeSB9KTtcclxufVxyXG5leHBvcnRzLnJlY3QgPSByZWN0O1xyXG5mdW5jdGlvbiBjaXJjbGUocGFyZW50LCBjeCwgY3ksIHIpIHtcclxuICAgIHJldHVybiBjcmVhdGUoJ2NpcmNsZScsIHBhcmVudCkuYXR0cnMoeyBjeCwgY3ksIHIgfSk7XHJcbn1cclxuZXhwb3J0cy5jaXJjbGUgPSBjaXJjbGU7XHJcbmZ1bmN0aW9uIGVsbGlwc2UocGFyZW50LCBjeCwgY3ksIHJ4LCByeSkge1xyXG4gICAgcmV0dXJuIGNyZWF0ZSgnZWxsaXBzZScsIHBhcmVudCkuYXR0cnMoeyBjeCwgY3ksIHJ4LCByeSB9KTtcclxufVxyXG5leHBvcnRzLmVsbGlwc2UgPSBlbGxpcHNlO1xyXG5mdW5jdGlvbiBwYXRoKHBhcmVudCwgY29tbWFuZHMpIHtcclxuICAgIHJldHVybiBjcmVhdGUoJ3BhdGgnLCBwYXJlbnQpLmF0dHJzKHtcclxuICAgICAgICBkOiB0eXBlb2YgY29tbWFuZHMgPT09ICdzdHJpbmcnID8gY29tbWFuZHMgOiBjb21tYW5kcy5qb2luKCcgJylcclxuICAgIH0pO1xyXG59XHJcbmV4cG9ydHMucGF0aCA9IHBhdGg7XHJcbmZ1bmN0aW9uIHBvbHlsaW5lKHBhcmVudCwgcG9pbnRzKSB7XHJcbiAgICByZXR1cm4gY3JlYXRlKCdwb2x5bGluZScsIHBhcmVudCkuYXR0cnMoeyBwb2ludHM6IHBvaW50cy5qb2luKCcgJykgfSk7XHJcbn1cclxuZXhwb3J0cy5wb2x5bGluZSA9IHBvbHlsaW5lO1xyXG5mdW5jdGlvbiBwb2x5Z29uKHBhcmVudCwgcG9pbnRzKSB7XHJcbiAgICByZXR1cm4gY3JlYXRlKCdwb2x5Z29uJywgcGFyZW50KS5hdHRycyh7IHBvaW50czogcG9pbnRzLmpvaW4oJyAnKSB9KTtcclxufVxyXG5leHBvcnRzLnBvbHlnb24gPSBwb2x5Z29uO1xyXG5mdW5jdGlvbiBtYXNrKHBhcmVudCkge1xyXG4gICAgbGV0IHJlcyA9IGNyZWF0ZShcIm1hc2tcIiwgcGFyZW50KTtcclxuICAgIHJlcy5pZCA9IFwibWFza1wiICsgKCsrbGFzdEdlbklkKTtcclxuICAgIHJldHVybiByZXM7XHJcbn1cclxuZXhwb3J0cy5tYXNrID0gbWFzaztcclxuZnVuY3Rpb24gbGluayhwYXJlbnQsIGhyZWYpIHtcclxuICAgIHJldHVybiBjcmVhdGUoJ2EnLCBwYXJlbnQpLmF0dHJzKHsgaHJlZiB9LCBleHBvcnRzLnhsaW5rKTtcclxufVxyXG5leHBvcnRzLmxpbmsgPSBsaW5rO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1lbGVtLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xyXG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XHJcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH0pO1xyXG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xyXG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcclxuICAgIG9bazJdID0gbVtrXTtcclxufSkpO1xyXG52YXIgX19zZXRNb2R1bGVEZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX3NldE1vZHVsZURlZmF1bHQpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIHYpIHtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBcImRlZmF1bHRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdiB9KTtcclxufSkgOiBmdW5jdGlvbihvLCB2KSB7XHJcbiAgICBvW1wiZGVmYXVsdFwiXSA9IHY7XHJcbn0pO1xyXG52YXIgX19pbXBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydFN0YXIpIHx8IGZ1bmN0aW9uIChtb2QpIHtcclxuICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XHJcbiAgICB2YXIgcmVzdWx0ID0ge307XHJcbiAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoayAhPT0gXCJkZWZhdWx0XCIgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIF9fY3JlYXRlQmluZGluZyhyZXN1bHQsIG1vZCwgayk7XHJcbiAgICBfX3NldE1vZHVsZURlZmF1bHQocmVzdWx0LCBtb2QpO1xyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxufTtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5leHBvcnRzLnNoYWRvdyA9IGV4cG9ydHMuc2V0RmlsdGVyID0gZXhwb3J0cy5maWx0ZXIgPSB2b2lkIDA7XHJcbmNvbnN0IGVsID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCIuL2VsZW1cIikpO1xyXG52YXIgbGFzdElkID0gMDtcclxuZnVuY3Rpb24gZmlsdGVyKHBhcmVudCwgaWQpIHtcclxuICAgIHJldHVybiBlbC5jcmVhdGUoJ2ZpbHRlcicsIHBhcmVudCkuYXR0cnMoeyBpZCB9KTtcclxufVxyXG5leHBvcnRzLmZpbHRlciA9IGZpbHRlcjtcclxuZnVuY3Rpb24gc2V0RmlsdGVyKGVsZW0sIGZpbHRlcikge1xyXG4gICAgZWxlbS5hdHRycyh7IGZpbHRlcjogYHVybCgjJHt0eXBlb2YgZmlsdGVyID09PSAnc3RyaW5nJyA/XHJcbiAgICAgICAgICAgIGZpbHRlciA6IGZpbHRlci5pZH0pYCB9KTtcclxuICAgIHJldHVybiBlbGVtO1xyXG59XHJcbmV4cG9ydHMuc2V0RmlsdGVyID0gc2V0RmlsdGVyO1xyXG5mdW5jdGlvbiBzaGFkb3cocGFyZW50LCBkeCwgZHkgPSBkeCwgc3RkRGV2aWF0aW9uID0gZHgpIHtcclxuICAgIGxldCByZXMgPSBmaWx0ZXIocGFyZW50LCBcImZpbHRlclwiICsgKytsYXN0SWQpO1xyXG4gICAgZWwuY3JlYXRlKCdmZU9mZnNldCcsIHJlcykuYXR0cnMoe1xyXG4gICAgICAgIHJlc3VsdDogJ29mZk91dCcsIGluOiAnc291cmNlR3JhcGhpYycsIGR4OiA0LCBkeTogNFxyXG4gICAgfSk7XHJcbiAgICBlbC5jcmVhdGUoJ2ZlQmxlbmQnLCByZXMpLmF0dHJzKHtcclxuICAgICAgICBpbjogJ3NvdXJjZUdyYXBoaWMnLCBpbjI6ICdvZmZPdXQnLCBtb2RlOiAnbm9ybWFsJ1xyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gcmVzO1xyXG59XHJcbmV4cG9ydHMuc2hhZG93ID0gc2hhZG93O1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1maWx0ZXIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcclxuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfSk7XHJcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XHJcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xyXG4gICAgb1trMl0gPSBtW2tdO1xyXG59KSk7XHJcbnZhciBfX2V4cG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9fZXhwb3J0U3RhcikgfHwgZnVuY3Rpb24obSwgZXhwb3J0cykge1xyXG4gICAgZm9yICh2YXIgcCBpbiBtKSBpZiAocCAhPT0gXCJkZWZhdWx0XCIgJiYgIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChleHBvcnRzLCBwKSkgX19jcmVhdGVCaW5kaW5nKGV4cG9ydHMsIG0sIHApO1xyXG59O1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi92ZWN0b3JcIiksIGV4cG9ydHMpO1xyXG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vcmVjdFwiKSwgZXhwb3J0cyk7XHJcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9wYXRoXCIpLCBleHBvcnRzKTtcclxuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2VsZW1cIiksIGV4cG9ydHMpO1xyXG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vbWFya2VyXCIpLCBleHBvcnRzKTtcclxuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2ZpbHRlclwiKSwgZXhwb3J0cyk7XHJcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi90ZXh0XCIpLCBleHBvcnRzKTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcclxuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfSk7XHJcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XHJcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xyXG4gICAgb1trMl0gPSBtW2tdO1xyXG59KSk7XHJcbnZhciBfX3NldE1vZHVsZURlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9fc2V0TW9kdWxlRGVmYXVsdCkgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgdikge1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIFwiZGVmYXVsdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2IH0pO1xyXG59KSA6IGZ1bmN0aW9uKG8sIHYpIHtcclxuICAgIG9bXCJkZWZhdWx0XCJdID0gdjtcclxufSk7XHJcbnZhciBfX2ltcG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0U3RhcikgfHwgZnVuY3Rpb24gKG1vZCkge1xyXG4gICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcclxuICAgIHZhciByZXN1bHQgPSB7fTtcclxuICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChrICE9PSBcImRlZmF1bHRcIiAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgX19jcmVhdGVCaW5kaW5nKHJlc3VsdCwgbW9kLCBrKTtcclxuICAgIF9fc2V0TW9kdWxlRGVmYXVsdChyZXN1bHQsIG1vZCk7XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG59O1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmV4cG9ydHMuYXJyb3cgPSBleHBvcnRzLnNldE1hcmtlciA9IGV4cG9ydHMubWFya2VyID0gZXhwb3J0cy5NYXJrZXJQb3MgPSB2b2lkIDA7XHJcbmNvbnN0IGVsID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCIuL2VsZW1cIikpO1xyXG52YXIgTWFya2VyUG9zO1xyXG4oZnVuY3Rpb24gKE1hcmtlclBvcykge1xyXG4gICAgTWFya2VyUG9zW01hcmtlclBvc1tcIlN0YXJ0XCJdID0gMF0gPSBcIlN0YXJ0XCI7XHJcbiAgICBNYXJrZXJQb3NbTWFya2VyUG9zW1wiTWlkXCJdID0gMV0gPSBcIk1pZFwiO1xyXG4gICAgTWFya2VyUG9zW01hcmtlclBvc1tcIkVuZFwiXSA9IDJdID0gXCJFbmRcIjtcclxufSkoTWFya2VyUG9zID0gZXhwb3J0cy5NYXJrZXJQb3MgfHwgKGV4cG9ydHMuTWFya2VyUG9zID0ge30pKTtcclxudmFyIGxhc3RJZCA9IDA7XHJcbmZ1bmN0aW9uIG1hcmtlcihwYXJlbnQsIGlkKSB7XHJcbiAgICByZXR1cm4gZWwuY3JlYXRlKCdtYXJrZXInLCBwYXJlbnQpLmF0dHJzKHsgaWQgfSk7XHJcbn1cclxuZXhwb3J0cy5tYXJrZXIgPSBtYXJrZXI7XHJcbmZ1bmN0aW9uIHNldE1hcmtlcihlbGVtLCBtYXJrZXIsIHBvcykge1xyXG4gICAgbGV0IG1hcmtlclVybCA9IGB1cmwoIyR7dHlwZW9mIG1hcmtlciA9PT0gJ3N0cmluZycgPyBtYXJrZXIgOiBtYXJrZXIuaWR9KWA7XHJcbiAgICBzd2l0Y2ggKHBvcykge1xyXG4gICAgICAgIGNhc2UgTWFya2VyUG9zLlN0YXJ0OlxyXG4gICAgICAgICAgICByZXR1cm4gZWxlbS5hdHRycyh7IFwibWFya2VyLXN0YXJ0XCI6IG1hcmtlclVybCB9KTtcclxuICAgICAgICBjYXNlIE1hcmtlclBvcy5NaWQ6XHJcbiAgICAgICAgICAgIHJldHVybiBlbGVtLmF0dHJzKHsgXCJtYXJrZXItbWlkXCI6IG1hcmtlclVybCB9KTtcclxuICAgICAgICBjYXNlIE1hcmtlclBvcy5FbmQ6XHJcbiAgICAgICAgICAgIHJldHVybiBlbGVtLmF0dHJzKHsgXCJtYXJrZXItZW5kXCI6IG1hcmtlclVybCB9KTtcclxuICAgIH1cclxuICAgIHJldHVybiBlbGVtO1xyXG59XHJcbmV4cG9ydHMuc2V0TWFya2VyID0gc2V0TWFya2VyO1xyXG5mdW5jdGlvbiBhcnJvdyhwYXJlbnQsIHdpZHRoLCBsZW5ndGggPSB3aWR0aCwgY2xvc2VkID0gdHJ1ZSkge1xyXG4gICAgbGV0IHJlcyA9IG1hcmtlcihwYXJlbnQsIFwiYXJyb3dcIiArICsrbGFzdElkKS5hdHRycyh7XHJcbiAgICAgICAgdmlld0JveDogXCItMSAtMSAxMiAxMlwiLFxyXG4gICAgICAgIHJlZlg6IDEwLCByZWZZOiA1LFxyXG4gICAgICAgIG9yaWVudDogXCJhdXRvLXN0YXJ0LXJldmVyc2VcIixcclxuICAgICAgICBtYXJrZXJXaWR0aDogbGVuZ3RoLCBtYXJrZXJIZWlnaHQ6IHdpZHRoLFxyXG4gICAgICAgIHByZXNlcnZlQXNwZWN0UmF0aW86IFwibm9uZVwiXHJcbiAgICB9KTtcclxuICAgIGVsLnBhdGgocmVzLCBcIk0gMCAwIEwgMTAgNSBMIDAgMTBcIiArIChjbG9zZWQgPyBcIiB6XCIgOiBcIlwiKSk7XHJcbiAgICByZXR1cm4gcmVzO1xyXG59XHJcbmV4cG9ydHMuYXJyb3cgPSBhcnJvdztcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bWFya2VyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmV4cG9ydHMuQ2xvc2VQYXRoID0gZXhwb3J0cy5BcmNUbyA9IGV4cG9ydHMuU3dlZXAgPSBleHBvcnRzLkFyYyA9IGV4cG9ydHMuQ29udFF1YWRDdXJ2ZVRvID0gZXhwb3J0cy5RdWFkQ3VydmVUbyA9IGV4cG9ydHMuQ29udEN1YmljQ3VydmVUbyA9IGV4cG9ydHMuQ3ViaWNDdXJ2ZVRvID0gZXhwb3J0cy5WTGluZVRvID0gZXhwb3J0cy5ITGluZVRvID0gZXhwb3J0cy5MaW5lVG8gPSBleHBvcnRzLk1vdmVUbyA9IHZvaWQgMDtcclxuY2xhc3MgTW92ZVRvIHtcclxuICAgIGNvbnN0cnVjdG9yKGNvbW1hbmQsIHgsIHkpIHtcclxuICAgICAgICB0aGlzLmNvbW1hbmQgPSBjb21tYW5kO1xyXG4gICAgICAgIHRoaXMueCA9IHg7XHJcbiAgICAgICAgdGhpcy55ID0geTtcclxuICAgICAgICB0aGlzLnRvU3RyaW5nID0gKCkgPT4gYCR7dGhpcy5jb21tYW5kfSR7dGhpcy54fSAke3RoaXMueX1gO1xyXG4gICAgfVxyXG59XHJcbmV4cG9ydHMuTW92ZVRvID0gTW92ZVRvO1xyXG5jbGFzcyBMaW5lVG8ge1xyXG4gICAgY29uc3RydWN0b3IoY29tbWFuZCwgeCwgeSkge1xyXG4gICAgICAgIHRoaXMuY29tbWFuZCA9IGNvbW1hbmQ7XHJcbiAgICAgICAgdGhpcy54ID0geDtcclxuICAgICAgICB0aGlzLnkgPSB5O1xyXG4gICAgICAgIHRoaXMudG9TdHJpbmcgPSAoKSA9PiBgJHt0aGlzLmNvbW1hbmR9JHt0aGlzLnh9ICR7dGhpcy55fWA7XHJcbiAgICB9XHJcbn1cclxuZXhwb3J0cy5MaW5lVG8gPSBMaW5lVG87XHJcbmNsYXNzIEhMaW5lVG8ge1xyXG4gICAgY29uc3RydWN0b3IoY29tbWFuZCwgeCkge1xyXG4gICAgICAgIHRoaXMuY29tbWFuZCA9IGNvbW1hbmQ7XHJcbiAgICAgICAgdGhpcy54ID0geDtcclxuICAgICAgICB0aGlzLnRvU3RyaW5nID0gKCkgPT4gYCR7dGhpcy5jb21tYW5kfSR7dGhpcy54fWA7XHJcbiAgICB9XHJcbn1cclxuZXhwb3J0cy5ITGluZVRvID0gSExpbmVUbztcclxuY2xhc3MgVkxpbmVUbyB7XHJcbiAgICBjb25zdHJ1Y3Rvcihjb21tYW5kLCB5KSB7XHJcbiAgICAgICAgdGhpcy5jb21tYW5kID0gY29tbWFuZDtcclxuICAgICAgICB0aGlzLnkgPSB5O1xyXG4gICAgICAgIHRoaXMudG9TdHJpbmcgPSAoKSA9PiBgJHt0aGlzLmNvbW1hbmR9JHt0aGlzLnl9YDtcclxuICAgIH1cclxufVxyXG5leHBvcnRzLlZMaW5lVG8gPSBWTGluZVRvO1xyXG5jbGFzcyBDdWJpY0N1cnZlVG8ge1xyXG4gICAgY29uc3RydWN0b3IoY29tbWFuZCwgeDEsIHkxLCB4MiwgeTIsIHgsIHkpIHtcclxuICAgICAgICB0aGlzLmNvbW1hbmQgPSBjb21tYW5kO1xyXG4gICAgICAgIHRoaXMueDEgPSB4MTtcclxuICAgICAgICB0aGlzLnkxID0geTE7XHJcbiAgICAgICAgdGhpcy54MiA9IHgyO1xyXG4gICAgICAgIHRoaXMueTIgPSB5MjtcclxuICAgICAgICB0aGlzLnggPSB4O1xyXG4gICAgICAgIHRoaXMueSA9IHk7XHJcbiAgICAgICAgdGhpcy50b1N0cmluZyA9ICgpID0+IGAke3RoaXMuY29tbWFuZH0ke3RoaXMueDF9ICR7dGhpcy55MX0gJHt0aGlzLngyfSAke3RoaXMueTJ9ICR7dGhpcy54fSAke3RoaXMueX1gO1xyXG4gICAgfVxyXG59XHJcbmV4cG9ydHMuQ3ViaWNDdXJ2ZVRvID0gQ3ViaWNDdXJ2ZVRvO1xyXG5jbGFzcyBDb250Q3ViaWNDdXJ2ZVRvIHtcclxuICAgIGNvbnN0cnVjdG9yKGNvbW1hbmQsIHgyLCB5MiwgeCwgeSkge1xyXG4gICAgICAgIHRoaXMuY29tbWFuZCA9IGNvbW1hbmQ7XHJcbiAgICAgICAgdGhpcy54MiA9IHgyO1xyXG4gICAgICAgIHRoaXMueTIgPSB5MjtcclxuICAgICAgICB0aGlzLnggPSB4O1xyXG4gICAgICAgIHRoaXMueSA9IHk7XHJcbiAgICAgICAgdGhpcy50b1N0cmluZyA9ICgpID0+IGAke3RoaXMuY29tbWFuZH0ke3RoaXMueDJ9ICR7dGhpcy55Mn0gJHt0aGlzLnh9ICR7dGhpcy55fWA7XHJcbiAgICB9XHJcbn1cclxuZXhwb3J0cy5Db250Q3ViaWNDdXJ2ZVRvID0gQ29udEN1YmljQ3VydmVUbztcclxuY2xhc3MgUXVhZEN1cnZlVG8ge1xyXG4gICAgY29uc3RydWN0b3IoY29tbWFuZCwgeDEsIHkxLCB4LCB5KSB7XHJcbiAgICAgICAgdGhpcy5jb21tYW5kID0gY29tbWFuZDtcclxuICAgICAgICB0aGlzLngxID0geDE7XHJcbiAgICAgICAgdGhpcy55MSA9IHkxO1xyXG4gICAgICAgIHRoaXMueCA9IHg7XHJcbiAgICAgICAgdGhpcy55ID0geTtcclxuICAgICAgICB0aGlzLnRvU3RyaW5nID0gKCkgPT4gYCR7dGhpcy5jb21tYW5kfSR7dGhpcy54MX0gJHt0aGlzLnkxfSAke3RoaXMueH0gJHt0aGlzLnl9YDtcclxuICAgIH1cclxufVxyXG5leHBvcnRzLlF1YWRDdXJ2ZVRvID0gUXVhZEN1cnZlVG87XHJcbmNsYXNzIENvbnRRdWFkQ3VydmVUbyB7XHJcbiAgICBjb25zdHJ1Y3Rvcihjb21tYW5kLCB4LCB5KSB7XHJcbiAgICAgICAgdGhpcy5jb21tYW5kID0gY29tbWFuZDtcclxuICAgICAgICB0aGlzLnggPSB4O1xyXG4gICAgICAgIHRoaXMueSA9IHk7XHJcbiAgICAgICAgdGhpcy50b1N0cmluZyA9ICgpID0+IGAke3RoaXMuY29tbWFuZH0ke3RoaXMueH0gJHt0aGlzLnl9YDtcclxuICAgIH1cclxufVxyXG5leHBvcnRzLkNvbnRRdWFkQ3VydmVUbyA9IENvbnRRdWFkQ3VydmVUbztcclxudmFyIEFyYztcclxuKGZ1bmN0aW9uIChBcmMpIHtcclxuICAgIEFyY1tBcmNbXCJTbWFsbFwiXSA9IDBdID0gXCJTbWFsbFwiO1xyXG4gICAgQXJjW0FyY1tcIkxhcmdlXCJdID0gMV0gPSBcIkxhcmdlXCI7XHJcbn0pKEFyYyA9IGV4cG9ydHMuQXJjIHx8IChleHBvcnRzLkFyYyA9IHt9KSk7XHJcbnZhciBTd2VlcDtcclxuKGZ1bmN0aW9uIChTd2VlcCkge1xyXG4gICAgU3dlZXBbU3dlZXBbXCJDV1wiXSA9IDBdID0gXCJDV1wiO1xyXG4gICAgU3dlZXBbU3dlZXBbXCJDQ1dcIl0gPSAxXSA9IFwiQ0NXXCI7XHJcbn0pKFN3ZWVwID0gZXhwb3J0cy5Td2VlcCB8fCAoZXhwb3J0cy5Td2VlcCA9IHt9KSk7XHJcbmNsYXNzIEFyY1RvIHtcclxuICAgIGNvbnN0cnVjdG9yKGNvbW1hbmQsIHJ4LCByeSwgcm90LCBhcmMsIHN3ZWVwLCB4LCB5KSB7XHJcbiAgICAgICAgdGhpcy5jb21tYW5kID0gY29tbWFuZDtcclxuICAgICAgICB0aGlzLnJ4ID0gcng7XHJcbiAgICAgICAgdGhpcy5yeSA9IHJ5O1xyXG4gICAgICAgIHRoaXMucm90ID0gcm90O1xyXG4gICAgICAgIHRoaXMuYXJjID0gYXJjO1xyXG4gICAgICAgIHRoaXMuc3dlZXAgPSBzd2VlcDtcclxuICAgICAgICB0aGlzLnggPSB4O1xyXG4gICAgICAgIHRoaXMueSA9IHk7XHJcbiAgICAgICAgdGhpcy50b1N0cmluZyA9ICgpID0+IGAke3RoaXMuY29tbWFuZH0ke3RoaXMucnh9ICR7dGhpcy5yeX0gJHt0aGlzLnJvdH0gJHt0aGlzLmFyY30gJHt0aGlzLnN3ZWVwfSAke3RoaXMueH0gJHt0aGlzLnl9YDtcclxuICAgIH1cclxufVxyXG5leHBvcnRzLkFyY1RvID0gQXJjVG87XHJcbmNsYXNzIENsb3NlUGF0aCB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICB0aGlzLnRvU3RyaW5nID0gKCkgPT4gdGhpcy5jb21tYW5kO1xyXG4gICAgfVxyXG59XHJcbmV4cG9ydHMuQ2xvc2VQYXRoID0gQ2xvc2VQYXRoO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1wYXRoLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xyXG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XHJcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH0pO1xyXG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xyXG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcclxuICAgIG9bazJdID0gbVtrXTtcclxufSkpO1xyXG52YXIgX19zZXRNb2R1bGVEZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX3NldE1vZHVsZURlZmF1bHQpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIHYpIHtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBcImRlZmF1bHRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdiB9KTtcclxufSkgOiBmdW5jdGlvbihvLCB2KSB7XHJcbiAgICBvW1wiZGVmYXVsdFwiXSA9IHY7XHJcbn0pO1xyXG52YXIgX19pbXBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydFN0YXIpIHx8IGZ1bmN0aW9uIChtb2QpIHtcclxuICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XHJcbiAgICB2YXIgcmVzdWx0ID0ge307XHJcbiAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoayAhPT0gXCJkZWZhdWx0XCIgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIF9fY3JlYXRlQmluZGluZyhyZXN1bHQsIG1vZCwgayk7XHJcbiAgICBfX3NldE1vZHVsZURlZmF1bHQocmVzdWx0LCBtb2QpO1xyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxufTtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5leHBvcnRzLlJlY3QgPSBleHBvcnRzLlJlY3RQb3MgPSB2b2lkIDA7XHJcbmNvbnN0IHZlYyA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwiLi92ZWN0b3JcIikpO1xyXG52YXIgUmVjdFBvcztcclxuKGZ1bmN0aW9uIChSZWN0UG9zKSB7XHJcbiAgICBSZWN0UG9zW1JlY3RQb3NbXCJDZW50ZXJcIl0gPSAwXSA9IFwiQ2VudGVyXCI7XHJcbiAgICBSZWN0UG9zW1JlY3RQb3NbXCJUb3BMZWZ0XCJdID0gMV0gPSBcIlRvcExlZnRcIjtcclxuICAgIFJlY3RQb3NbUmVjdFBvc1tcIlRvcFJpZ2h0XCJdID0gMl0gPSBcIlRvcFJpZ2h0XCI7XHJcbiAgICBSZWN0UG9zW1JlY3RQb3NbXCJCb3R0b21MZWZ0XCJdID0gM10gPSBcIkJvdHRvbUxlZnRcIjtcclxuICAgIFJlY3RQb3NbUmVjdFBvc1tcIkJvdHRvbVJpZ2h0XCJdID0gNF0gPSBcIkJvdHRvbVJpZ2h0XCI7XHJcbn0pKFJlY3RQb3MgPSBleHBvcnRzLlJlY3RQb3MgfHwgKGV4cG9ydHMuUmVjdFBvcyA9IHt9KSk7XHJcbi8qKlxyXG4gKiBEZWZpbmVzIGEgcmVjdGFuZ2xlIHdoaWNoIGNvdmVycyBhcmVhIFtsZWZ0LCByaWdodCkgYWxvbmcgeC1heGlzXHJcbiAqIGFuZCBbdG9wLCBib3R0b20pIGFsb25nIHktYXhpcy5cclxuICovXHJcbmNsYXNzIFJlY3Qge1xyXG4gICAgY29uc3RydWN0b3IobGVmdCwgdG9wLCByaWdodCwgYm90dG9tKSB7XHJcbiAgICAgICAgdGhpcy5sZWZ0ID0gbGVmdDtcclxuICAgICAgICB0aGlzLnRvcCA9IHRvcDtcclxuICAgICAgICB0aGlzLnJpZ2h0ID0gcmlnaHQ7XHJcbiAgICAgICAgdGhpcy5ib3R0b20gPSBib3R0b207XHJcbiAgICB9XHJcbiAgICBnZXQgd2lkdGgoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucmlnaHQgLSB0aGlzLmxlZnQ7XHJcbiAgICB9XHJcbiAgICBnZXQgaGVpZ2h0KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmJvdHRvbSAtIHRoaXMudG9wO1xyXG4gICAgfVxyXG4gICAgZ2V0IGNlbnRlclgoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubGVmdCArICh0aGlzLndpZHRoIC8gMik7XHJcbiAgICB9XHJcbiAgICBnZXQgY2VudGVyWSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy50b3AgKyAodGhpcy5oZWlnaHQgLyAyKTtcclxuICAgIH1cclxuICAgIGdldCBpc0VtcHR5KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLndpZHRoIDw9IDAgfHwgdGhpcy5oZWlnaHQgPD0gMDtcclxuICAgIH1cclxuICAgIGNvbnRhaW5zUG9pbnQoeCwgeSkge1xyXG4gICAgICAgIHJldHVybiB4ID49IHRoaXMubGVmdCAmJiB4IDwgdGhpcy5yaWdodCAmJlxyXG4gICAgICAgICAgICB5ID49IHRoaXMudG9wICYmIHkgPCB0aGlzLmJvdHRvbTtcclxuICAgIH1cclxuICAgIHJlY3RQb3MocG9zKSB7XHJcbiAgICAgICAgc3dpdGNoIChwb3MpIHtcclxuICAgICAgICAgICAgY2FzZSBSZWN0UG9zLkNlbnRlcjogcmV0dXJuIFt0aGlzLmNlbnRlclgsIHRoaXMuY2VudGVyWV07XHJcbiAgICAgICAgICAgIGNhc2UgUmVjdFBvcy5Ub3BMZWZ0OiByZXR1cm4gW3RoaXMubGVmdCwgdGhpcy50b3BdO1xyXG4gICAgICAgICAgICBjYXNlIFJlY3RQb3MuVG9wUmlnaHQ6IHJldHVybiBbdGhpcy5yaWdodCwgdGhpcy50b3BdO1xyXG4gICAgICAgICAgICBjYXNlIFJlY3RQb3MuQm90dG9tTGVmdDogcmV0dXJuIFt0aGlzLmxlZnQsIHRoaXMuYm90dG9tXTtcclxuICAgICAgICAgICAgY2FzZSBSZWN0UG9zLkJvdHRvbVJpZ2h0OiByZXR1cm4gW3RoaXMucmlnaHQsIHRoaXMuYm90dG9tXTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBjb3JuZXJQb2ludHMoY2xvc2VMb29wID0gZmFsc2UpIHtcclxuICAgICAgICBsZXQgcmVzID0gW1xyXG4gICAgICAgICAgICB0aGlzLnJlY3RQb3MoUmVjdFBvcy5Ub3BMZWZ0KSxcclxuICAgICAgICAgICAgdGhpcy5yZWN0UG9zKFJlY3RQb3MuVG9wUmlnaHQpLFxyXG4gICAgICAgICAgICB0aGlzLnJlY3RQb3MoUmVjdFBvcy5Cb3R0b21SaWdodCksXHJcbiAgICAgICAgICAgIHRoaXMucmVjdFBvcyhSZWN0UG9zLkJvdHRvbUxlZnQpXHJcbiAgICAgICAgXTtcclxuICAgICAgICBpZiAoY2xvc2VMb29wKVxyXG4gICAgICAgICAgICByZXMucHVzaChyZXNbMF0pO1xyXG4gICAgICAgIHJldHVybiByZXM7XHJcbiAgICB9XHJcbiAgICBjb250YWluc1JlY3Qob3RoZXIpIHtcclxuICAgICAgICByZXR1cm4gb3RoZXIubGVmdCA+PSB0aGlzLmxlZnQgJiYgb3RoZXIucmlnaHQgPD0gdGhpcy5yaWdodCAmJlxyXG4gICAgICAgICAgICBvdGhlci50b3AgPj0gdGhpcy50b3AgJiYgb3RoZXIuYm90dG9tIDw9IHRoaXMuYm90dG9tO1xyXG4gICAgfVxyXG4gICAgZXF1YWxzKG90aGVyKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubGVmdCA9PSBvdGhlci5sZWZ0ICYmIHRoaXMudG9wID09IG90aGVyLnRvcCAmJlxyXG4gICAgICAgICAgICB0aGlzLndpZHRoID09IG90aGVyLndpZHRoICYmIHRoaXMuaGVpZ2h0ID09IG90aGVyLmhlaWdodDtcclxuICAgIH1cclxuICAgIGluZmxhdGUoZHgsIGR5KSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBSZWN0KHRoaXMubGVmdCAtIGR4LCB0aGlzLnRvcCAtIGR5LCB0aGlzLnJpZ2h0ICsgZHgsIHRoaXMuYm90dG9tICsgZHkpO1xyXG4gICAgfVxyXG4gICAgaW50ZXJzZWN0KG90aGVyKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBSZWN0KE1hdGgubWF4KHRoaXMubGVmdCwgb3RoZXIubGVmdCksIE1hdGgubWF4KHRoaXMudG9wLCBvdGhlci50b3ApLCBNYXRoLm1pbih0aGlzLnJpZ2h0LCBvdGhlci5yaWdodCksIE1hdGgubWluKHRoaXMuYm90dG9tLCBvdGhlci5ib3R0b20pKTtcclxuICAgIH1cclxuICAgIGludGVyc2VjdHNXaXRoKG90aGVyKSB7XHJcbiAgICAgICAgcmV0dXJuICF0aGlzLmludGVyc2VjdChvdGhlcikuaXNFbXB0eTtcclxuICAgIH1cclxuICAgIG9mZnNldChkeCwgZHkpIHtcclxuICAgICAgICByZXR1cm4gbmV3IFJlY3QodGhpcy5sZWZ0ICsgZHgsIHRoaXMudG9wICsgZHksIHRoaXMucmlnaHQgKyBkeCwgdGhpcy5ib3R0b20gKyBkeSk7XHJcbiAgICB9XHJcbiAgICB0cmFuc2xhdGVUbyhtYXQsIHBvcywgdG8gPSBbMCwgMF0pIHtcclxuICAgICAgICBsZXQgW3N4LCBzeV0gPSBwb3MgaW5zdGFuY2VvZiBBcnJheSA/IHBvcyA6IHRoaXMucmVjdFBvcyhwb3MpO1xyXG4gICAgICAgIGxldCBbdHgsIHR5XSA9IHRvO1xyXG4gICAgICAgIHJldHVybiBtYXQudHJhbnNsYXRlKHR4IC0gc3gsIHR5IC0gc3kpO1xyXG4gICAgfVxyXG4gICAgdHJhbnNmb3JtKG1hdCkge1xyXG4gICAgICAgIHJldHVybiBSZWN0LmZyb21Qb2ludHModGhpcy5jb3JuZXJQb2ludHMoKS5tYXAocHQgPT4ge1xyXG4gICAgICAgICAgICBsZXQgW3gsIHldID0gcHQ7XHJcbiAgICAgICAgICAgIGxldCB0cCA9IG1hdC50cmFuc2Zvcm1Qb2ludCh7IHgsIHkgfSk7XHJcbiAgICAgICAgICAgIHJldHVybiBbdHAueCwgdHAueV07XHJcbiAgICAgICAgfSkpO1xyXG4gICAgfVxyXG4gICAgdW5pb24ob3RoZXIpIHtcclxuICAgICAgICByZXR1cm4gbmV3IFJlY3QoTWF0aC5taW4odGhpcy5sZWZ0LCBvdGhlci5sZWZ0KSwgTWF0aC5taW4odGhpcy50b3AsIG90aGVyLnRvcCksIE1hdGgubWF4KHRoaXMucmlnaHQsIG90aGVyLnJpZ2h0KSwgTWF0aC5tYXgodGhpcy5ib3R0b20sIG90aGVyLmJvdHRvbSkpO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIGZyb21ET01SZWN0KGRvbVJlY3QpIHtcclxuICAgICAgICByZXR1cm4gbmV3IFJlY3QoZG9tUmVjdC54LCBkb21SZWN0LnksIGRvbVJlY3QueCArIGRvbVJlY3Qud2lkdGgsIGRvbVJlY3QueSArIGRvbVJlY3QuaGVpZ2h0KTtcclxuICAgIH1cclxuICAgIHN0YXRpYyBmcm9tUG9pbnRzKHBvaW50cykge1xyXG4gICAgICAgIHJldHVybiBuZXcgUmVjdChNYXRoLm1pbiguLi5wb2ludHMubWFwKHZlYy52ZWNYKSksIE1hdGgubWluKC4uLnBvaW50cy5tYXAodmVjLnZlY1kpKSwgTWF0aC5tYXgoLi4ucG9pbnRzLm1hcCh2ZWMudmVjWCkpLCBNYXRoLm1heCguLi5wb2ludHMubWFwKHZlYy52ZWNZKSkpO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIGZyb21SZWN0cyhyZWN0cykge1xyXG4gICAgICAgIHJldHVybiByZWN0cy5yZWR1Y2UoKHIsIGMpID0+IGMudW5pb24ocikpO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIGZyb21TdHJpbmcodmFsdWUpIHtcclxuICAgICAgICBsZXQgW2xlZnQsIHRvcCwgd2lkdGgsIGhlaWdodF0gPSB2YWx1ZS5zcGxpdChcIiBcIikubWFwKE51bWJlcik7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBSZWN0KGxlZnQsIHRvcCwgbGVmdCArIHdpZHRoLCB0b3AgKyBoZWlnaHQpO1xyXG4gICAgfVxyXG59XHJcbmV4cG9ydHMuUmVjdCA9IFJlY3Q7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlY3QuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcclxuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfSk7XHJcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XHJcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xyXG4gICAgb1trMl0gPSBtW2tdO1xyXG59KSk7XHJcbnZhciBfX3NldE1vZHVsZURlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9fc2V0TW9kdWxlRGVmYXVsdCkgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgdikge1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIFwiZGVmYXVsdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2IH0pO1xyXG59KSA6IGZ1bmN0aW9uKG8sIHYpIHtcclxuICAgIG9bXCJkZWZhdWx0XCJdID0gdjtcclxufSk7XHJcbnZhciBfX2ltcG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0U3RhcikgfHwgZnVuY3Rpb24gKG1vZCkge1xyXG4gICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcclxuICAgIHZhciByZXN1bHQgPSB7fTtcclxuICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChrICE9PSBcImRlZmF1bHRcIiAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgX19jcmVhdGVCaW5kaW5nKHJlc3VsdCwgbW9kLCBrKTtcclxuICAgIF9fc2V0TW9kdWxlRGVmYXVsdChyZXN1bHQsIG1vZCk7XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG59O1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmV4cG9ydHMuY2hhbmdlV29yZFdyYXBUZXh0ID0gZXhwb3J0cy53b3JkV3JhcFRleHQgPSB2b2lkIDA7XHJcbmNvbnN0IGVsID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCIuL2VsZW1cIikpO1xyXG5mdW5jdGlvbiB3b3JkV3JhcFRleHQocGFyZW50LCB4LCB5LCB3cmFwQWZ0ZXIsIGNhcHRpb24pIHtcclxuICAgIGxldCB0ZXh0ID0gZWwudGV4dChwYXJlbnQpLmF0dHJzKHsgeCwgeSwgXCJkYXRhLXdyYXBBZnRlclwiOiB3cmFwQWZ0ZXIgfSk7XHJcbiAgICBjaGFuZ2VXb3JkV3JhcFRleHQodGV4dCwgY2FwdGlvbik7XHJcbiAgICByZXR1cm4gdGV4dDtcclxufVxyXG5leHBvcnRzLndvcmRXcmFwVGV4dCA9IHdvcmRXcmFwVGV4dDtcclxuZnVuY3Rpb24gY2hhbmdlV29yZFdyYXBUZXh0KHRleHQsIGNhcHRpb24sIHgsIHdyYXBBZnRlcikge1xyXG4gICAgdGV4dC5kZWxldGVDaGlsZHJlbigpO1xyXG4gICAgbGV0IHdvcmRzID0gY2FwdGlvbi5zcGxpdChcIiBcIik7XHJcbiAgICBpZiAoeClcclxuICAgICAgICB0ZXh0LmF0dHJzKHsgeCB9KTtcclxuICAgIGVsc2VcclxuICAgICAgICB4ID0gTnVtYmVyKHRleHQuYXR0cihcInhcIikpO1xyXG4gICAgaWYgKHdyYXBBZnRlcilcclxuICAgICAgICB0ZXh0LmF0dHJzKHsgXCJkYXRhLXdyYXBBZnRlclwiOiB3cmFwQWZ0ZXIgfSk7XHJcbiAgICBlbHNlXHJcbiAgICAgICAgd3JhcEFmdGVyID0gTnVtYmVyKHRleHQuYXR0cihcImRhdGEtd3JhcEFmdGVyXCIpIHx8IDEwMCk7XHJcbiAgICBsZXQgaSA9IDA7XHJcbiAgICBsZXQgYmIgPSBudWxsO1xyXG4gICAgd2hpbGUgKGkgPCB3b3Jkcy5sZW5ndGgpIHtcclxuICAgICAgICBsZXQgdHMgPSBlbC50c3Bhbih0ZXh0LCB3b3Jkc1tpXSk7XHJcbiAgICAgICAgbGV0IHcgPSB0cy5lbGVtZW50LmdldENvbXB1dGVkVGV4dExlbmd0aCgpO1xyXG4gICAgICAgIHdoaWxlICgrK2kgPCB3b3Jkcy5sZW5ndGggJiYgdyA8IHdyYXBBZnRlcikge1xyXG4gICAgICAgICAgICB0cy50ZXh0ID0gdHMudGV4dCArIFwiIFwiICsgd29yZHNbaV07XHJcbiAgICAgICAgICAgIHcgPSB0cy5lbGVtZW50LmdldENvbXB1dGVkVGV4dExlbmd0aCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIWJiKVxyXG4gICAgICAgICAgICBiYiA9IHRleHQuYmJveDtcclxuICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIHRzLmF0dHJzKHsgeCwgZHk6IGJiLmhlaWdodCB9KTtcclxuICAgIH1cclxufVxyXG5leHBvcnRzLmNoYW5nZVdvcmRXcmFwVGV4dCA9IGNoYW5nZVdvcmRXcmFwVGV4dDtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dGV4dC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5leHBvcnRzLmRpdlZlYyA9IGV4cG9ydHMubXVsVmVjID0gZXhwb3J0cy5zdWJWZWMgPSBleHBvcnRzLmFkZFZlYyA9IGV4cG9ydHMudmVjWSA9IGV4cG9ydHMudmVjWCA9IGV4cG9ydHMub25lVmVjdG9yID0gZXhwb3J0cy56ZXJvVmVjdG9yID0gdm9pZCAwO1xyXG5leHBvcnRzLnplcm9WZWN0b3IgPSBbMCwgMF07XHJcbmV4cG9ydHMub25lVmVjdG9yID0gWzEsIDFdO1xyXG5mdW5jdGlvbiB2ZWNYKHZlYykge1xyXG4gICAgcmV0dXJuIHZlY1swXTtcclxufVxyXG5leHBvcnRzLnZlY1ggPSB2ZWNYO1xyXG5mdW5jdGlvbiB2ZWNZKHZlYykge1xyXG4gICAgcmV0dXJuIHZlY1sxXTtcclxufVxyXG5leHBvcnRzLnZlY1kgPSB2ZWNZO1xyXG5mdW5jdGlvbiBhZGRWZWModmVjMSwgdmVjMikge1xyXG4gICAgcmV0dXJuIHZlYzEubWFwKChhLCBpKSA9PiBhICsgdmVjMltpXSk7XHJcbn1cclxuZXhwb3J0cy5hZGRWZWMgPSBhZGRWZWM7XHJcbmZ1bmN0aW9uIHN1YlZlYyh2ZWMxLCB2ZWMyKSB7XHJcbiAgICByZXR1cm4gdmVjMS5tYXAoKGEsIGkpID0+IGEgLSB2ZWMyW2ldKTtcclxufVxyXG5leHBvcnRzLnN1YlZlYyA9IHN1YlZlYztcclxuZnVuY3Rpb24gbXVsVmVjKHZlYzEsIHZlYzIpIHtcclxuICAgIHJldHVybiB2ZWMxLm1hcCgoYSwgaSkgPT4gYSAqIHZlYzJbaV0pO1xyXG59XHJcbmV4cG9ydHMubXVsVmVjID0gbXVsVmVjO1xyXG5mdW5jdGlvbiBkaXZWZWModmVjMSwgdmVjMikge1xyXG4gICAgcmV0dXJuIHZlYzEubWFwKChhLCBpKSA9PiBhIC8gdmVjMltpXSk7XHJcbn1cclxuZXhwb3J0cy5kaXZWZWMgPSBkaXZWZWM7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXZlY3Rvci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5leHBvcnRzLm9wZXJhdG9ycyA9IHZvaWQgMDtcclxuLyoqXHJcbiAqICMgQ29tYmluYXRvcnMgZm9yIFBhcnNpbmcgQXJyYXlzIGFuZCBFeHByZXNzaW9uc1xyXG4gKlxyXG4gKiBUaGlzIG1vZHVsZSBjb250YWlucyBhZGRpdGlvbmFsIGNvbWJpbmF0b3JzIHRoYXQgYXJlIHVzZWZ1bCB3aGVuIHBhcnNpbmdcclxuICogc2VxdWVuY2VzIG9yIGV4cHJlc3Npb25zLiBUaGV5IGFyZSBhZGFwdGVkIGZyb20gdGhlIG9yaWdpbmFsXHJcbiAqIFtQYXJzZWNdKGh0dHA6Ly9oYWNrYWdlLmhhc2tlbGwub3JnL3BhY2thZ2UvcGFyc2VjLTMuMS4xMy4wL2RvY3MvVGV4dC1QYXJzZWMtQ29tYmluYXRvci5odG1sKVxyXG4gKiBsaWJyYXJ5LlxyXG4gKi9cclxuY29uc3QgcGFyID0gcmVxdWlyZShcIi4vcGFyc2VyXCIpO1xyXG4vKipcclxuICogIyMgUGFyc2luZyBTZXBhcmF0ZWQgTGlzdHNcclxuICpcclxuICogUGFyc2UgYW4gYXJyYXkgY29udGFpbmluZyBhdCBsZWFzdCBvbmUgZWxlbWVudC4gVGhlIGl0ZW1zIG9mIHRoZSBhcnJheSBhcmVcclxuICogcmVjb2duaXplZCBieSBgcGFyc2VyYC4gVGhlIGl0ZW1zIGFyZSBzZXBhcmF0ZWQgYnkgaW5wdXQgcmVjb2duaXplZCBieVxyXG4gKiBgc2VwYXJhdG9yYC4gVGhlIGZ1bmN0aW9uIHJldHVybnMgYW4gYXJyYXkgb2YgcGFyc2VkIGVsZW1lbnRzLlxyXG4gKi9cclxucGFyLlBhcnNlci5wcm90b3R5cGUub25lT3JNb3JlU2VwYXJhdGVkQnkgPSBmdW5jdGlvbiAoc2VwYXJhdG9yKSB7XHJcbiAgICByZXR1cm4gdGhpcy5iaW5kKHggPT4gc2VwYXJhdG9yLnNlcSh0aGlzKS56ZXJvT3JNb3JlKCkuYmluZCh4cyA9PiBwYXIubXJldChbeF0uY29uY2F0KHhzKSkpKTtcclxufTtcclxuLyoqXHJcbiAqIFBhcnNlIGEgcG90ZW50aWFsbHkgZW1wdHkgYXJyYXkuIFRoZSBpdGVtcyBvZiB0aGUgYXJyYXkgYXJlIHJlY29nbml6ZWQgYnlcclxuICogYHBhcnNlcmAuIFRoZSBpdGVtcyBhcmUgc2VwYXJhdGVkIGJ5IGlucHV0IHJlY29nbml6ZWQgYnkgYHNlcGFyYXRvcmAuXHJcbiAqL1xyXG5wYXIuUGFyc2VyLnByb3RvdHlwZS56ZXJvT3JNb3JlU2VwYXJhdGVkQnkgPSBmdW5jdGlvbiAoc2VwYXJhdG9yKSB7XHJcbiAgICByZXR1cm4gdGhpcy5vbmVPck1vcmVTZXBhcmF0ZWRCeShzZXBhcmF0b3IpLm9yKHBhci5tcmV0KFtdKSk7XHJcbn07XHJcbi8qKlxyXG4gKiAjIyBUZXJtaW5hdG9ycyAmIEJyYWNrZXRzXHJcbiAqXHJcbiAqIFBhcnNlIGl0ZW0ocykgZm9sbG93ZWQgYnkgYSB0ZXJtaW5hdG9yIGdpdmVuIGluIHRoZSBgYWZ0ZXJgIHBhcnNlci4gVGhlXHJcbiAqIHJlc3VsdCBvZiBgcGFyc2VyYCBpcyByZXR1cm5lZCwgYW5kIHJlc3VsdCBvZiBgYWZ0ZXJgIGlzIGlnbm9yZWQuXHJcbiAqL1xyXG5wYXIuUGFyc2VyLnByb3RvdHlwZS5mb2xsb3dlZEJ5ID0gZnVuY3Rpb24gKGFmdGVyKSB7XHJcbiAgICByZXR1cm4gdGhpcy5iaW5kKHAgPT4gYWZ0ZXIuYmluZChfID0+IHBhci5tcmV0KHApKSk7XHJcbn07XHJcbi8qKlxyXG4gKiBQYXJzZSBpdGVtKHMpIHN1cnJvdW5kZWQgYnkgaW5wdXQgcmVjb2duaXplZCBieSB0aGUgYHN1cnJvdW5kYCBwYXJzZXIuIFRoZVxyXG4gKiByZXN1bHQgb2YgYHBhcnNlcmAgaXMgcmV0dXJuZWQuXHJcbiAqL1xyXG5wYXIuUGFyc2VyLnByb3RvdHlwZS5zdXJyb3VuZGVkQnkgPSBmdW5jdGlvbiAoc3Vycm91bmQpIHtcclxuICAgIHJldHVybiBzdXJyb3VuZC5iaW5kKG8gPT4gdGhpcy5iaW5kKHAgPT4gc3Vycm91bmQuYmluZChjID0+IHBhci5tcmV0KHApKSkpO1xyXG59O1xyXG4vKipcclxuICogUGFyc2UgaXRlbShzKSBzdXJyb3VuZGVkIGJ5IGFuIG9wZW4gYW5kIGNsb3NpbmcgYnJhY2tldC4gVGhlIHJlc3VsdCBgcGFyc2VyYFxyXG4gKiBpcyByZXR1cm5lZC5cclxuICovXHJcbnBhci5QYXJzZXIucHJvdG90eXBlLmJyYWNrZXRlZEJ5ID0gZnVuY3Rpb24gKG9wZW4sIGNsb3NlKSB7XHJcbiAgICByZXR1cm4gb3Blbi5iaW5kKG8gPT4gdGhpcy5iaW5kKHAgPT4gY2xvc2UuYmluZChjID0+IHBhci5tcmV0KHApKSkpO1xyXG59O1xyXG4vKipcclxuICogIyMgUGFyc2luZyBFeHByZXNzaW9uc1xyXG4gKlxyXG4gKiBQYXJzZSBvbmUgb3IgbW9yZSBvY2N1cnJlbmNlcyBvZiBgcGFyc2VyYCwgc2VwYXJhdGVkIGJ5IGBvcGVyYXRpb25gLlxyXG4gKiBSZXR1cm4gYSB2YWx1ZSBvYnRhaW5lZCBieSBhIGxlZnQgYXNzb2NpYXRpdmUgYXBwbGljYXRpb24gb2YgYWxsIGZ1bmN0aW9uc1xyXG4gKiByZXR1cm5lZCBieSBgb3BlcmF0aW9uYCB0byB0aGUgdmFsdWVzIHJldHVybmVkIGJ5IGBwYXJzZXJgLiBUaGlzIHBhcnNlciBjYW5cclxuICogZm9yIGV4YW1wbGUgYmUgdXNlZCB0byBlbGltaW5hdGUgbGVmdCByZWN1cnNpb24gd2hpY2ggdHlwaWNhbGx5IG9jY3VycyBpblxyXG4gKiBleHByZXNzaW9uIGdyYW1tYXJzLlxyXG4gKi9cclxucGFyLlBhcnNlci5wcm90b3R5cGUuY2hhaW5PbmVPck1vcmUgPSBmdW5jdGlvbiAob3BlcmF0aW9uKSB7XHJcbiAgICByZXR1cm4gdGhpcy5iaW5kKHggPT4gb3BlcmF0aW9uLmJpbmQoZiA9PiB0aGlzLmJpbmQoeSA9PiBwYXIubXJldChbZiwgeV0pKSkuemVyb09yTW9yZSgpLmJpbmQoZnlzID0+IHBhci5tcmV0KGZ5cy5yZWR1Y2UoKHosIFtmLCB5XSkgPT4gZih6LCB5KSwgeCkpKSk7XHJcbn07XHJcbi8qKlxyXG4gKiBQYXJzZSB6ZXJvIG9yIG1vcmUgb2NjdXJyZW5jZXMgb2YgYHBhcnNlcmAsIHNlcGFyYXRlZCBieSBgb3BlcmF0aW9uYC5cclxuICogUmV0dXJuIGEgdmFsdWUgb2J0YWluZWQgYnkgYSBsZWZ0IGFzc29jaWF0aXZlIGFwcGxpY2F0aW9uIG9mIGFsbCBmdW5jdGlvbnNcclxuICogcmV0dXJuZWQgYnkgYG9wZXJhdGlvbmAgdG8gdGhlIHZhbHVlcyByZXR1cm5lZCBieSBgcGFyc2VyYC4gSWYgdGhlcmUgYXJlXHJcbiAqIHplcm8gb2NjdXJyZW5jZXMgb2YgYHBhcnNlcmAsIHRoZSBgdmFsdWVgIGlzIHJldHVybmVkLlxyXG4gKi9cclxucGFyLlBhcnNlci5wcm90b3R5cGUuY2hhaW5aZXJvT3JNb3JlID0gZnVuY3Rpb24gKG9wZXJhdGlvbiwgdmFsdWUpIHtcclxuICAgIHJldHVybiB0aGlzLmNoYWluT25lT3JNb3JlKG9wZXJhdGlvbikub3IocGFyLm1yZXQodmFsdWUpKTtcclxufTtcclxuLyoqXHJcbiAqIENvbnN0cnVjdCBhIHBhcnNlciBmb3Igb3BlcmF0b3Igc2VsZWN0aW9uLiBVc2VkIHR5cGljYWxseSBpbiBjb25qdW5jdGlvblxyXG4gKiB3aXRoIGBjaGFpbipgIGZ1bmN0aW9ucy5cclxuICovXHJcbmZ1bmN0aW9uIG9wZXJhdG9ycyguLi5vcHMpIHtcclxuICAgIHJldHVybiBwYXIuYW55KC4uLm9wcy5tYXAoKFtwLCBvXSkgPT4gcC5tYXAoXyA9PiBvKSkpO1xyXG59XHJcbmV4cG9ydHMub3BlcmF0b3JzID0gb3BlcmF0b3JzO1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5leHBvcnRzLlBhcnNlRXJyb3IgPSBleHBvcnRzLkVycm9yU291cmNlID0gdm9pZCAwO1xyXG4vKipcclxuICogIyBFcnJvciBSZXBvcnRpbmdcclxuICpcclxuICogV2UgZGVmaW5lIGEgY3VzdG9tIEVycm9yIGNsYXNzIGZvciBwYXJzaW5nIGVycm9ycy5cclxuICpcclxuICogVGhlIHBvc3NpYmxlIHNvdXJjZXMgb2YgZXJyb3JzIGFyZSBkZWZpbmVkIGluIHRoZSBlbnVtZXJhdGlvbiBiZWxvdy5cclxuICovXHJcbnZhciBFcnJvclNvdXJjZTtcclxuKGZ1bmN0aW9uIChFcnJvclNvdXJjZSkge1xyXG4gICAgRXJyb3JTb3VyY2VbXCJJbnB1dFwiXSA9IFwiSW5wdXRcIjtcclxuICAgIEVycm9yU291cmNlW1wiTGV4ZXJcIl0gPSBcIkxleGVyXCI7XHJcbiAgICBFcnJvclNvdXJjZVtcIlBhcnNlclwiXSA9IFwiUGFyc2luZ1wiO1xyXG59KShFcnJvclNvdXJjZSA9IGV4cG9ydHMuRXJyb3JTb3VyY2UgfHwgKGV4cG9ydHMuRXJyb3JTb3VyY2UgPSB7fSkpO1xyXG4vKipcclxuICogVGhlIFBhcnNlRXJyb3IgY2xhc3MgY29udGFpbnMgaW5mb3JtYXRpb24gYWJvdXQgdGhlIHBhcnNpbmcgZXJyb3IgaW5cclxuICogYW4gZWFzaWx5IGFjY2Vzc2libGUgZm9ybS5cclxuICovXHJcbmNsYXNzIFBhcnNlRXJyb3IgZXh0ZW5kcyBFcnJvciB7XHJcbiAgICBjb25zdHJ1Y3RvcihcclxuICAgIC8qKlxyXG4gICAgICogVGhlIHNvdXJjZSBvZiB0aGUgZXJyb3IuXHJcbiAgICAgKi9cclxuICAgIHNvdXJjZSwgXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBwb3NpdGlvbiB3aGVyZSB0aGUgZXJyb3IgaGFwcGVuZWQuXHJcbiAgICAgKi9cclxuICAgIHBvc2l0aW9uLCBcclxuICAgIC8qKlxyXG4gICAgICogSW5wdXQgZm91bmQgYXQgYHBvc2l0aW9uYC5cclxuICAgICAqL1xyXG4gICAgZm91bmQsIFxyXG4gICAgLyoqXHJcbiAgICAgKiBJbnB1dCBleHBlY3RlZCBhdCBgcG9zaXRpb25gLiBUaGVyZSBjYW4gYmUgbXVsdGlwbGUgdGVybWluYWxzLlxyXG4gICAgICovXHJcbiAgICBleHBlY3RlZCA9IFtdKSB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ29uc3RydWN0b3IgZm9ybWF0cyB0aGUgZXJyb3IgbWVzc2FnZSB1c2luZyB0aGUgcGFyYW1ldGVycyBwcm92aWRlZC5cclxuICAgICAgICAgKi9cclxuICAgICAgICBzdXBlcihgJHtzb3VyY2V9IGVycm9yIGF0IHBvc2l0aW9uICR7cG9zaXRpb24gKyAxfS5cXG5gICtcclxuICAgICAgICAgICAgYFxcdEZvdW5kOiBcIiR7Zm91bmR9XCJcXG5gICtcclxuICAgICAgICAgICAgYFxcdEV4cGVjdGVkOiAke2V4cGVjdGVkLm1hcChzID0+IGBcIiR7c31cImApLmpvaW4oXCIsIFwiKX1gKTtcclxuICAgICAgICB0aGlzLnNvdXJjZSA9IHNvdXJjZTtcclxuICAgICAgICB0aGlzLnBvc2l0aW9uID0gcG9zaXRpb247XHJcbiAgICAgICAgdGhpcy5mb3VuZCA9IGZvdW5kO1xyXG4gICAgICAgIHRoaXMuZXhwZWN0ZWQgPSBleHBlY3RlZDtcclxuICAgIH1cclxufVxyXG5leHBvcnRzLlBhcnNlRXJyb3IgPSBQYXJzZUVycm9yO1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xyXG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9KTtcclxufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcclxuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XHJcbiAgICBvW2syXSA9IG1ba107XHJcbn0pKTtcclxudmFyIF9fZXhwb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19leHBvcnRTdGFyKSB8fCBmdW5jdGlvbihtLCBleHBvcnRzKSB7XHJcbiAgICBmb3IgKHZhciBwIGluIG0pIGlmIChwICE9PSBcImRlZmF1bHRcIiAmJiAhT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGV4cG9ydHMsIHApKSBfX2NyZWF0ZUJpbmRpbmcoZXhwb3J0cywgbSwgcCk7XHJcbn07XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuLyoqXHJcbiAqIC0tLVxyXG4gKiB7XHJcbiAqICBcInZpc3VhbGl6ZXJzXCI6IFtcclxuICogICAgICB7XHJcbiAqICAgICAgICAgIFwicGF0aFwiOiBcIi4vc3JjL3Zpc3VhbGl6ZXJzL2RlcGVuZGVuY3ktZGlhZy50c1wiLFxyXG4gKiAgICAgICAgICBcImluY2x1ZGVTdHlsZXNcIjogdHJ1ZVxyXG4gKiAgICAgIH1cclxuICogIF1cclxuICogfVxyXG4gKiAtLS1cclxuICogIyBMaWJyYXJ5IFN0cnVjdHVyZVxyXG4gKlxyXG4gKiBCZWxvdyBpcyB0aGUgZGVwZW5kZW5jeSBncmFwaCBzaG93aW5nIHRoZSBtb2R1bGUgaGllcmFyY2h5LiBOb3RlIHRoYXQgaXRcclxuICogc2hvd3MgYWxzbyB0aGUgdGVzdGluZyBtb2R1bGVzIHdoaWNoIGFyZSBub3QgaW5jbHVkZWQgaW4gdGhlIHB1Ymxpc2hlZFxyXG4gKiBwYWNrYWdlLiBZb3UgY2FuIGp1bXAgdG8gYSBtb2R1bGUgYnkgY2xpY2tpbmcgaXQgaW4gdGhlIGRpYWdyYW0uXHJcbiAqXHJcbiAqIDw8djpkZXBlbmRlbmN5LWRpYWcgLi4vZGVwZW5kZW5jaWVzLmpzb24gc3JjXFwvKD8hZXh0cmFzKT4+XHJcbiAqXHJcbiAqICMjIEV4cG9ydHNcclxuICpcclxuICogUGFyemVjIGxpYnJhcnkgY29uc2lzdHMgb2YgZm9sbG93aW5nIG1vZHVsZXMuIEFsbCBvZiB0aGVtIGFyZSBleHBvcnRlZFxyXG4gKiBvdXRzaWRlIHRoZSBsaWJyYXJ5LlxyXG4gKi9cclxuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL3JlZlwiKSwgZXhwb3J0cyk7XHJcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9lcnJvclwiKSwgZXhwb3J0cyk7XHJcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9pbnB1dFwiKSwgZXhwb3J0cyk7XHJcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9yZXN1bHRcIiksIGV4cG9ydHMpO1xyXG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vZXJyb3JcIiksIGV4cG9ydHMpO1xyXG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vbGV4ZXJcIiksIGV4cG9ydHMpO1xyXG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vcGFyc2VyXCIpLCBleHBvcnRzKTtcclxuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2FycmF5cGFyc2Vyc1wiKSwgZXhwb3J0cyk7XHJcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi91dGlsc1wiKSwgZXhwb3J0cyk7XHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmV4cG9ydHMuYXJyYXlJbnB1dCA9IHZvaWQgMDtcclxuLyoqXHJcbiAqICMjIEFycmF5IElucHV0XHJcbiAqXHJcbiAqIEFycmF5cyBhcmUgdGhlIG1vc3QgY29tbW9uIGlucHV0IGRhdGEgdHlwZS4gVGhlcmVmb3JlIHdlIHByb3ZpZGUgYSBnZW5lcmljXHJcbiAqIGltcGxlbWVudGF0aW9uIGZvciB0aGVtLiBBcnJheSBpdGVtcyBtYXkgaGF2ZSBhbnkgdHlwZSBgU2AuIFRoZSBjbGFzcyBpc1xyXG4gKiBub3QgZXhwb3J0ZWQgb3V0c2lkZSB0aGUgbW9kdWxlLiBVc2VycyBjYW4gY3JlYXRlIGl0IHVzaW5nIHRoZSBgYXJyYXlJbnB1dGBcclxuICogZnVuY3Rpb24uXHJcbiAqL1xyXG5jbGFzcyBBcnJheUlucHV0IHtcclxuICAgIC8qKlxyXG4gICAgICogV2Ugc2V0IHRoZSBwb3NpdGlvbiBpbml0aWFsbHkgdG8gLTEgdG8gaW5kaWNhdGUgdGhhdCBubyBpbnB1dCBoYXMgYmVlblxyXG4gICAgICogY29uc3VtZWQuIFRoZSBjdXJyZW50IGl0ZW0gaXMgYHVuZGVmaW5lZGAuXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKGFycmF5LCBlb2YpIHtcclxuICAgICAgICB0aGlzLmFycmF5ID0gYXJyYXk7XHJcbiAgICAgICAgdGhpcy5wb3NpdGlvbiA9IC0xO1xyXG4gICAgICAgIHRoaXMuY3VycmVudCA9IHVuZGVmaW5lZDtcclxuICAgICAgICB0aGlzLmVvZiA9IGVvZjtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJuIHRoZSBuZXh0IGl0ZW0gaW4gdGhlIGFycmF5LiBVcGRhdGUgYHBvc2l0aW9uYCBhbmRcclxuICAgICAqIGBjdXJyZW50YCBmaWVsZHMuXHJcbiAgICAgKi9cclxuICAgIG5leHQoKSB7XHJcbiAgICAgICAgbGV0IHBvcyA9IHRoaXMucG9zaXRpb24gKyAxO1xyXG4gICAgICAgIGlmIChwb3MgPj0gdGhpcy5hcnJheS5sZW5ndGgpXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmVvZjtcclxuICAgICAgICB0aGlzLnBvc2l0aW9uID0gcG9zO1xyXG4gICAgICAgIHRoaXMuY3VycmVudCA9IHRoaXMuYXJyYXlbcG9zXTtcclxuICAgICAgICByZXR1cm4gdGhpcy5jdXJyZW50O1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiAjIyBFeHBvcnRlZCBGdW5jdGlvbnNcclxuICpcclxuICogQ3JlYXRlIGEgUGFyc2VySW5wdXQgd3JhcHBlciBmb3IgYW4gYXJyYXkuXHJcbiAqL1xyXG5mdW5jdGlvbiBhcnJheUlucHV0KGFycmF5LCBlb2YpIHtcclxuICAgIHJldHVybiBuZXcgQXJyYXlJbnB1dChhcnJheSwgZW9mKTtcclxufVxyXG5leHBvcnRzLmFycmF5SW5wdXQgPSBhcnJheUlucHV0O1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5leHBvcnRzLmxleGVySW5wdXQgPSBleHBvcnRzLkxleGVyID0gZXhwb3J0cy5Ub2tlbiA9IHZvaWQgMDtcclxuY29uc3QgdXRpbHMgPSByZXF1aXJlKFwiLi91dGlsc1wiKTtcclxuY29uc3QgZXJyID0gcmVxdWlyZShcIi4vZXJyb3JcIik7XHJcbi8qKlxyXG4gKiAjIyBSZXByZXNlbnRpbmcgYSBUb2tlblxyXG4gKlxyXG4gKiBXaGVuIGEgdG9rZW4gaXMgcmVjb2duaXplZCBpdCBpcyB3cmFwcGVkIGluIGEgYFRva2VuPFM+YCBvYmplY3QuIFRoaXNcclxuICogY29udGFpbnMgYWxzbyB0aGUgcmVjb2duaXplZCBzdHJpbmcgZm9yIGVycm9yIHJlcG9ydGluZyBhbmQgZGlhZ25vc3RpY3MuXHJcbiAqL1xyXG5jbGFzcyBUb2tlbiB7XHJcbiAgICBjb25zdHJ1Y3Rvcih0b2tlbiwgdGV4dCkge1xyXG4gICAgICAgIHRoaXMudG9rZW4gPSB0b2tlbjtcclxuICAgICAgICB0aGlzLnRleHQgPSB0ZXh0O1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBXZSBvdmVycmlkZSB0aGUgYHRvU3RyaW5nYCBmdW5jdGlvbiBzbyB3ZSBjYW4gb3V0cHV0IGEgdG9rZW5cclxuICAgICAqIHRvIHNjcmVlbi5cclxuICAgICAqL1xyXG4gICAgdG9TdHJpbmcoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMudGV4dCA/IHV0aWxzLmVzY2FwZVdoaXRlc3BhY2UodGhpcy50ZXh0KSA6IHRoaXMudG9rZW47XHJcbiAgICB9XHJcbn1cclxuZXhwb3J0cy5Ub2tlbiA9IFRva2VuO1xyXG4vKipcclxuICogIyMgTGV4ZXJcclxuICpcclxuICogVGhlIGxleGVyIGl0c2VsZiBpcyBhIHNpbXBsZSBjbGFzcyB0aGF0IGNvbnRhaW5zIGFsbCB0aGUgVG9rZW5NYXRjaGVycyBhbmRcclxuICogcmVjb2duaXplcyB0aGUgbmV4dCB0b2tlbiBpbiBhIHN0cmluZy5cclxuICovXHJcbmNsYXNzIExleGVyIHtcclxuICAgIC8qKlxyXG4gICAgICogVGhlIGNvbnN0cnVjdG9yIGFkZHMgdHdvIGZsYWdzIHRvIHRoZSByZWd1bGFyIGV4cHJlc3Npb25zIGdpdmVuIGFzXHJcbiAgICAgKiBhcmd1bWVudHMuIFRoZSBgeWAgZmxhZyBtYWtlcyB0aGUgc2VhcmNoIHN0aWNreSBzbyB0aGF0IGl0IHNjYW5zIHRoZVxyXG4gICAgICogaW5wdXQgc3RyaW5nIGZyb20gdGhlIHBvc2l0aW9uIGluZGljYXRlZCBieSB0aGUgYGxhc3RJbmRleGAgcHJvcGVydHkuXHJcbiAgICAgKiBUaGUgYHVgIGZsYWcgbWFrZXMgdGhlIHNlYXJjaCBzdXBwb3J0IHVuaWNvZGUgY2hhcmFjdGVycy5cclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IoLi4udG9rZW5zKSB7XHJcbiAgICAgICAgdGhpcy5tYXRjaGVycyA9IHRva2Vucy5tYXAodCA9PiAoe1xyXG4gICAgICAgICAgICByZWdleDogbmV3IFJlZ0V4cCh0WzBdLCBcInl1XCIpLFxyXG4gICAgICAgICAgICB0b2tlbjogdFsxXVxyXG4gICAgICAgIH0pKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogV2UgY2hlY2sgbWF0Y2hlcnMgb25lLWJ5LW9uZSBpbiB0aGUgb3JkZXIgdGhleSB3ZXJlIGdpdmVuIHRvXHJcbiAgICAgKiByZWNvZ25pemUgdGhlIHRva2VuIGluIHRoZSBnaXZlbiBwb3NpdGlvbi4gSWYgbm9uZSBvZiB0aGUgbWF0Y2hlcnNcclxuICAgICAqIHN1Y2NlZWQsIHdlIHJldHVybiBgbnVsbGAuXHJcbiAgICAgKi9cclxuICAgIG1hdGNoVG9rZW4oaW5wdXQsIHBvcykge1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5tYXRjaGVycy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBsZXQgbWF0Y2hlciA9IHRoaXMubWF0Y2hlcnNbaV07XHJcbiAgICAgICAgICAgIG1hdGNoZXIucmVnZXgubGFzdEluZGV4ID0gcG9zO1xyXG4gICAgICAgICAgICBsZXQgbWF0Y2ggPSBtYXRjaGVyLnJlZ2V4LmV4ZWMoaW5wdXQpO1xyXG4gICAgICAgICAgICBpZiAobWF0Y2ggIT0gbnVsbClcclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgVG9rZW4obWF0Y2hlci50b2tlbiwgbWF0Y2hbMF0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxufVxyXG5leHBvcnRzLkxleGVyID0gTGV4ZXI7XHJcbi8qKlxyXG4gKiAjIyBMZXhlciBhcyBJbnB1dFxyXG4gKlxyXG4gKiBXZSBjYW4gaW50ZWdyYXRlIGxleGluZyBkaXJlY3RseSBpbnRvIHRoZSBwYXJzaW5nIHByb2Nlc3MgYnkgaW1wbGVtZW50aW5nXHJcbiAqIHRoZSBgUGFyc2VySW5wdXRgIGludGVyZmFjZSBmb3IgYW55IHRva2VuLiBXZSBkb24ndCBleHBvc2UgYExleGVySW5wdXRgXHJcbiAqIGNsYXNzIG91dHNpZGUgdGhlIG1vZHVsZS4gSXQgY2FuIGJlIGNyZWF0ZWQgd2l0aCB0aGUgYGxleGVySW5wdXRgIGZ1bmN0aW9uLlxyXG4gKi9cclxuY2xhc3MgTGV4ZXJJbnB1dCB7XHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZSBhbiBpbnB1dCBzdHJlYW0gZm9yIGdpdmVuIHN0cmluZyBhbmQgbGV4ZXIuIEluaXRpYWxpemUgdGhlXHJcbiAgICAgKiBpbnN0YW5jZSB2YXJpYWJsZXMuXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKGlucHV0LCBsZXhlciwgZW9mKSB7XHJcbiAgICAgICAgdGhpcy5pbnB1dCA9IGlucHV0O1xyXG4gICAgICAgIHRoaXMubGV4ZXIgPSBsZXhlcjtcclxuICAgICAgICB0aGlzLnRva2VucyA9IG5ldyBBcnJheShpbnB1dC5sZW5ndGgpO1xyXG4gICAgICAgIHRoaXMucG9zaXRpb24gPSAtMTtcclxuICAgICAgICB0aGlzLmVvZiA9IGVvZjtcclxuICAgICAgICB0aGlzLmN1cnJlbnQgPSB0aGlzLmVvZjtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVGhlIGl0ZXJhdG9yIGltcGxlbWVudGF0aW9uIGlzIGZhaXJseSBzdHJhaWdodGZvcndhcmQuIFdlIG5lZWQgdG8gbWFrZVxyXG4gICAgICogc3VyZSB0aGF0IHRoZSBzdGF0ZSB2YXJpYWJsZXMgYHBvc2l0aW9uYCBhbmQgYGN1cnJlbnRgIGFyZSBrZXB0IGluIHN5bmNcclxuICAgICAqIHdoaWxlIHdlIGFkdmFuY2UgaW4gdGhlIGlucHV0IHN0cmluZy4gV2UgbXVzdCBhbHNvIGRvIGEgbG9va3VwIGluIHRoZVxyXG4gICAgICogY2FjaMOpIGJlZm9yZSBjYWxsaW5nIHRoZSBsZXhlciB0byByZWNvZ25pemUgdGhlIHRva2VuLiBJZiB0aGUgbGV4ZXIgZmluZHNcclxuICAgICAqIGEgbWF0Y2gsIHdlIHVwZGF0ZSB0aGUgY2FjaMOpLiBJZiB0aGUgbGV4ZXIgY2Fubm90IHJlY29nbml6ZSB0aGUgbmV4dFxyXG4gICAgICogdG9rZW4sIHdlIHRocm93IGEgYFBhcnNlRXJyb3JgLlxyXG4gICAgICovXHJcbiAgICBuZXh0KCkge1xyXG4gICAgICAgIGxldCBwb3MgPSB0aGlzLnBvc2l0aW9uO1xyXG4gICAgICAgIHBvcyArPSB0aGlzLnRva2Vuc1twb3NdID8gdGhpcy50b2tlbnNbcG9zXS50ZXh0Lmxlbmd0aCA6IDE7XHJcbiAgICAgICAgaWYgKHBvcyA+PSB0aGlzLmlucHV0Lmxlbmd0aClcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZW9mO1xyXG4gICAgICAgIHRoaXMucG9zaXRpb24gPSBwb3M7XHJcbiAgICAgICAgbGV0IG1hdGNoID0gdGhpcy50b2tlbnNbcG9zXSB8fCB0aGlzLmxleGVyLm1hdGNoVG9rZW4odGhpcy5pbnB1dCwgcG9zKTtcclxuICAgICAgICBpZiAoIW1hdGNoKVxyXG4gICAgICAgICAgICB0aHJvdyBuZXcgZXJyLlBhcnNlRXJyb3IoZXJyLkVycm9yU291cmNlLkxleGVyLCBwb3MsIHRoaXMuaW5wdXQuc3Vic3RyKHBvcywgMTApICsgXCIuLi5cIiwgW1wiPHZhbGlkIHRva2VuPlwiXSk7XHJcbiAgICAgICAgdGhpcy50b2tlbnNbcG9zXSA9IG1hdGNoO1xyXG4gICAgICAgIHRoaXMuY3VycmVudCA9IG1hdGNoO1xyXG4gICAgICAgIHJldHVybiBtYXRjaDtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogQ3JlYXRlIGFuIGlucHV0IHN0cmVhbSBmb3IgZ2l2ZW4gYHRleHRgIHN0cmluZyB1c2luZyB0aGUgZ2l2ZW4gYGxleGVyYC5cclxuICovXHJcbmZ1bmN0aW9uIGxleGVySW5wdXQodGV4dCwgbGV4ZXIsIGVvZikge1xyXG4gICAgcmV0dXJuIG5ldyBMZXhlcklucHV0KHRleHQsIGxleGVyLCBlb2YpO1xyXG59XHJcbmV4cG9ydHMubGV4ZXJJbnB1dCA9IGxleGVySW5wdXQ7XHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmV4cG9ydHMudGVybWluYWwgPSBleHBvcnRzLnRva2VuID0gZXhwb3J0cy5pcyA9IGV4cG9ydHMuYW55dGhpbmcgPSBleHBvcnRzLmZvcndhcmRSZWYgPSBleHBvcnRzLmNsZWFudXBTdGF0ZSA9IGV4cG9ydHMuY2hlY2tTdGF0ZSA9IGV4cG9ydHMubXV0YXRlU3RhdGUgPSBleHBvcnRzLnNldFN0YXRlID0gZXhwb3J0cy5nZXRTdGF0ZSA9IGV4cG9ydHMucG9zaXRpb24gPSBleHBvcnRzLmNob29zZSA9IGV4cG9ydHMucGVlayA9IGV4cG9ydHMuYW55ID0gZXhwb3J0cy5ub3RTYXRpc2Z5ID0gZXhwb3J0cy5zYXRpc2Z5ID0gZXhwb3J0cy5mYWlsID0gZXhwb3J0cy5tcmV0ID0gZXhwb3J0cy5wYXJzZSA9IGV4cG9ydHMudHJ5UGFyc2UgPSBleHBvcnRzLnBhcnNlckRlYnVnID0gZXhwb3J0cy5QYXJzZXIgPSB2b2lkIDA7XHJcbmNvbnN0IHByID0gcmVxdWlyZShcIi4vcmVzdWx0XCIpO1xyXG5jb25zdCB1dGlscyA9IHJlcXVpcmUoXCIuL3V0aWxzXCIpO1xyXG5jb25zdCBlcnIgPSByZXF1aXJlKFwiLi9lcnJvclwiKTtcclxuLyoqXHJcbiAqICMjIFBhcnNlciBDbGFzc1xyXG4gKlxyXG4gKiBUaGUgY2VudHJhbCB0eXBlIGluIHRoZSBQYXJ6ZWMgbGlicmFyeSBpcyB0aGUgYFBhcnNlcjxULCBTPmAgY2xhc3MuIEl0IHdyYXBzXHJcbiAqIGEgcGFyc2luZyBmdW5jdGlvbiBhbmQgcHJvdmlkZXMgdGhlIGNvcmUgY29tYmluYXRvcnMgdG8gY29tYmluZSBwYXJzZXJzIGluXHJcbiAqIHZhcmlvdXMgd2F5cy5cclxuICovXHJcbmNsYXNzIFBhcnNlciB7XHJcbiAgICAvKipcclxuICAgICAqIENvbnN0cnVjdG9yIHdyYXBzIHRoZSBwYXJzaW5nIGZ1bmN0aW9uLlxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3RvcihwYXJzZSkge1xyXG4gICAgICAgIHRoaXMucGFyc2UgPSBwYXJzZTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVGhlIG1vbmFkaWMgYmluZCB0aGF0IGNvcnJlc3BvbmRzIHRvIEhhc2tlbGwncyBgPj49YCBvcGVyYXRvci4gUnVuc1xyXG4gICAgICogYHRoaXNgIHBhcnNlciwgYW5kIGlmIGl0IHN1Y2NlZWRzLCBmZWVkcyBpdHMgcmVzdWx0IHRvIHRoZSBgYmluZGVyYFxyXG4gICAgICogZnVuY3Rpb24gdGhhdCByZXR1cm5zIGEgbmV3IFBhcnNlci4gVGhpcyBpcyB0aGUgYmFzaWMgb3BlcmF0aW9uIHRoYXQgaXNcclxuICAgICAqIHVzZWQgaW4gb3RoZXIgY29tYmluYXRvcnMgdG8gZ2x1ZSBwYXJzZXJzIHRvZ2V0aGVyLlxyXG4gICAgICovXHJcbiAgICBiaW5kKGJpbmRlcikge1xyXG4gICAgICAgIHJldHVybiBuZXcgUGFyc2VyKGlucHV0ID0+IHtcclxuICAgICAgICAgICAgbGV0IHBvcyA9IGlucHV0LnBvc2l0aW9uO1xyXG4gICAgICAgICAgICBsZXQgcmVzMSA9IHRoaXMucGFyc2UoaW5wdXQpO1xyXG4gICAgICAgICAgICBpZiAocmVzMS5raW5kID09IFwib2tcIikge1xyXG4gICAgICAgICAgICAgICAgbGV0IHJlczIgPSBiaW5kZXIocmVzMS5yZXN1bHQpLnBhcnNlKGlucHV0KTtcclxuICAgICAgICAgICAgICAgIGlmIChyZXMyLmtpbmQgPT0gXCJmYWlsXCIgJiYgcG9zICE9PSBpbnB1dC5wb3NpdGlvbilcclxuICAgICAgICAgICAgICAgICAgICBpbnB1dC5wb3NpdGlvbiA9IHBvczsgLy8gYmFja3RyYWNrXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzMjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gcmVzMTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVGhlIHNlcXVlbmNlIG9wZXJhdG9yLiBSdW5zIGB0aGlzYCBwYXJzZXIsIGFuZCBpZiBpdCBzdWNjZWVkcywgcnVucyB0aGVcclxuICAgICAqIGBvdGhlcmAgcGFyc2VyIGlnbm9yaW5nIHRoZSByZXN1bHQgb2YgYHRoaXNgIG9uZS5cclxuICAgICAqL1xyXG4gICAgc2VxKG90aGVyKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuYmluZChfID0+IG90aGVyKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogTWFwIHJlc3VsdCBvZiB0aGUgcGFyc2VyIHRvIGFub3RoZXIgdmFsdWUuIFRoaXMgZnVuY3Rpb24gaW1wbGVtZW50cyBhXHJcbiAgICAgKiBbX2Z1bmN0b3JfXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9GdW5jdG9yKSB3aGljaCBpcyBhIHN1cGVyY2xhc3NcclxuICAgICAqIG9mIG1vbmFkLlxyXG4gICAgICovXHJcbiAgICBtYXAobWFwcGVyKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuYmluZCh4ID0+IG1yZXQobWFwcGVyKHgpKSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqICMjIENvbmRpdGlvbmFsIFBhcnNpbmdcclxuICAgICAqXHJcbiAgICAgKiBUaGUgb3JkZXJlZCBjaG9pY2Ugb3BlcmF0aW9uLiBDcmVhdGVzIGEgcGFyc2VyIHRoYXQgZmlyc3QgcnVucyBgdGhpc2BcclxuICAgICAqIHBhcnNlciwgYW5kIGlmIHRoYXQgZmFpbHMsIHJ1bnMgdGhlIGBvdGhlcmAgb25lLiBDb3JyZXNwb25kcyB0byB0aGUgYC9gXHJcbiAgICAgKiBvcGVyYXRpb24gaW4gW1BFRyBncmFtbWFyc10oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvUGFyc2luZ19leHByZXNzaW9uX2dyYW1tYXIpLlxyXG4gICAgICovXHJcbiAgICBvcihvdGhlcikge1xyXG4gICAgICAgIHJldHVybiBuZXcgUGFyc2VyKGlucHV0ID0+IHtcclxuICAgICAgICAgICAgbGV0IHBvcyA9IGlucHV0LnBvc2l0aW9uO1xyXG4gICAgICAgICAgICBsZXQgcmVzMSA9IHRoaXMucGFyc2UoaW5wdXQpO1xyXG4gICAgICAgICAgICBpZiAocmVzMS5raW5kID09IFwib2tcIilcclxuICAgICAgICAgICAgICAgIHJldHVybiByZXMxO1xyXG4gICAgICAgICAgICBpZiAocmVzMS5wb3NpdGlvbiA+IHBvcylcclxuICAgICAgICAgICAgICAgIHJldHVybiByZXMxO1xyXG4gICAgICAgICAgICBsZXQgcmVzMiA9IG90aGVyLnBhcnNlKGlucHV0KTtcclxuICAgICAgICAgICAgaWYgKHJlczIua2luZCA9PSBcIm9rXCIpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzMjtcclxuICAgICAgICAgICAgcHIuam9pbkV4cGVjdGVkKHJlczIsIHJlczEpO1xyXG4gICAgICAgICAgICByZXR1cm4gcmVzMjtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUGFyc2UgYW4gb3B0aW9uYWwgdmFsdWUsIGlmIHRoZSBwYXJzZXIgZmFpbHMgdGhlbiB0aGUgZGVmYXVsdCB2YWx1ZSBpc1xyXG4gICAgICogcmV0dXJuZWQuXHJcbiAgICAgKi9cclxuICAgIG9wdGlvbmFsKGRlZmF1bHRWYWx1ZSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLm9yKG1yZXQoZGVmYXVsdFZhbHVlKSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFBhcnNlIGFuIG9wdGlvbmFsIHJlZmVyZW5jZSB2YWx1ZSwgaWYgdGhlIHBhcnNlciBmYWlscyB0aGVuIG51bGwgaXNcclxuICAgICAqIHJldHVybmVkLlxyXG4gICAgICovXHJcbiAgICBvcHRpb25hbFJlZigpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5vcihtcmV0KG51bGwpKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUnVucyBwYXJzZXIgYW5kIGNoZWNrcyB0aGF0IGl0IHN1Y2NlZWRzIGFuZCB0aGF0IHRoZSByZXN1bHQgaXQgcmV0dXJuc1xyXG4gICAgICogc2F0aXNmaWVzIGEgZ2l2ZW4gcHJlZGljYXRlLlxyXG4gICAgICovXHJcbiAgICB3aGVyZShwcmVkaWNhdGUpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5iaW5kKHggPT4gcHJlZGljYXRlKHgpID8gbXJldCh4KSA6IGZhaWwoYCR7eH1gLCBcInByZWRpY2F0ZVwiKSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqICMjIFBhcnNpbmcgTXVsdGlwbGUgSXRlbXNcclxuICAgICAqXHJcbiAgICAgKiBDcmVhdGVzIGEgcGFyc2VyIHRoYXQgd2lsbCBydW4gYHRoaXNgIHBhcnNlciB6ZXJvIG9yIG1vcmUgdGltZXMuIFRoZVxyXG4gICAgICogcmVzdWx0cyBvZiB0aGUgaW5wdXQgcGFyc2VyIGFyZSBhZGRlZCB0byBhbiBhcnJheS5cclxuICAgICAqL1xyXG4gICAgemVyb09yTW9yZSgpIHtcclxuICAgICAgICByZXR1cm4gbmV3IFBhcnNlcihpbnB1dCA9PiB7XHJcbiAgICAgICAgICAgIGxldCBsaXN0ID0gW107XHJcbiAgICAgICAgICAgIHdoaWxlICh0cnVlKSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgcG9zID0gaW5wdXQucG9zaXRpb247XHJcbiAgICAgICAgICAgICAgICBsZXQgcmVzID0gdGhpcy5wYXJzZShpbnB1dCk7XHJcbiAgICAgICAgICAgICAgICBpZiAocmVzLmtpbmQgPT0gXCJmYWlsXCIpXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlcy5wb3NpdGlvbiA+IHBvcyA/XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcyA6IHByLnN1Y2NlZWRlZChyZXMucG9zaXRpb24sIGxpc3QpO1xyXG4gICAgICAgICAgICAgICAgbGlzdC5wdXNoKHJlcy5yZXN1bHQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBwYXJzZXIgdGhhdCBydW5zIGB0aGlzYCBwYXJzZXIgb25lIG9yIG1vcmUgdGltZXMuXHJcbiAgICAgKi9cclxuICAgIG9uZU9yTW9yZSgpIHtcclxuICAgICAgICByZXR1cm4gbmV3IFBhcnNlcihpbnB1dCA9PiB7XHJcbiAgICAgICAgICAgIGxldCByZXMgPSB0aGlzLnBhcnNlKGlucHV0KTtcclxuICAgICAgICAgICAgaWYgKHJlcy5raW5kID09IFwiZmFpbFwiKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlcztcclxuICAgICAgICAgICAgbGV0IGxpc3QgPSBbcmVzLnJlc3VsdF07XHJcbiAgICAgICAgICAgIHdoaWxlICh0cnVlKSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgcG9zID0gaW5wdXQucG9zaXRpb247XHJcbiAgICAgICAgICAgICAgICByZXMgPSB0aGlzLnBhcnNlKGlucHV0KTtcclxuICAgICAgICAgICAgICAgIGlmIChyZXMua2luZCA9PSBcImZhaWxcIilcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzLnBvc2l0aW9uID4gcG9zID9cclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzIDogcHIuc3VjY2VlZGVkKHJlcy5wb3NpdGlvbiwgbGlzdCk7XHJcbiAgICAgICAgICAgICAgICBsaXN0LnB1c2gocmVzLnJlc3VsdCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUGFyc2luZyBzdWNjZWVkcyBpZiBgdGhpc2AgcGFyc2VyIHN1Y2NlZWRzIGZyb20gYG1pbmAgdG8gYG1heGAgdGltZXMuXHJcbiAgICAgKi9cclxuICAgIG9jY3VycmVuY2VzKG1pbiwgbWF4KSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuemVyb09yTW9yZSgpLmJpbmQobGlzdCA9PiB7XHJcbiAgICAgICAgICAgIGxldCBjbnQgPSBsaXN0Lmxlbmd0aDtcclxuICAgICAgICAgICAgcmV0dXJuIGNudCA+PSBtaW4gJiYgY250IDw9IG1heCA/XHJcbiAgICAgICAgICAgICAgICBtcmV0KGxpc3QpIDpcclxuICAgICAgICAgICAgICAgIGZhaWwoYCR7Y250fSBvY2N1cnJlbmNlc2AsIGAke21pbn0tJHttYXh9IG9jY3VycmVuY2VzYCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqICMjIExvb2thaGVhZCAmIEJhY2t0cmFja2luZ1xyXG4gICAgICpcclxuICAgICAqIENoZWNrIHRoYXQgYHRoaXNgIHBhcnNlciBzdWNjZWVkcyB3aXRob3V0IGNvbnN1bWluZyBhbnkgaW5wdXQuXHJcbiAgICAgKiBDb3JyZXNwb25kcyB0byB0aGUgYCZgIG9wZXJhdG9yIGluIFBFRyBncmFtbWFycy5cclxuICAgICAqL1xyXG4gICAgYW5kKCkge1xyXG4gICAgICAgIHJldHVybiBuZXcgUGFyc2VyKGlucHV0ID0+IHtcclxuICAgICAgICAgICAgbGV0IHBvcyA9IGlucHV0LnBvc2l0aW9uO1xyXG4gICAgICAgICAgICBsZXQgcmVzID0gdGhpcy5wYXJzZShpbnB1dCk7XHJcbiAgICAgICAgICAgIGlucHV0LnBvc2l0aW9uID0gcG9zO1xyXG4gICAgICAgICAgICByZXR1cm4gcmVzO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDaGVjayB0aGF0IGB0aGlzYCBwYXJzZXIgZmFpbHMgd2l0aG91dCBjb25zdW1pbmcgYW55IGlucHV0LiBDb3JyZXNwb25kc1xyXG4gICAgICogdG8gdGhlIGAhYCBvcGVyYXRvciBpbiBQRUcgZ3JhbW1hcnMuXHJcbiAgICAgKi9cclxuICAgIG5vdCgpIHtcclxuICAgICAgICByZXR1cm4gbmV3IFBhcnNlcihpbnB1dCA9PiB7XHJcbiAgICAgICAgICAgIGxldCBwb3MgPSBpbnB1dC5wb3NpdGlvbjtcclxuICAgICAgICAgICAgbGV0IHJlcyA9IHRoaXMucGFyc2UoaW5wdXQpO1xyXG4gICAgICAgICAgICBpbnB1dC5wb3NpdGlvbiA9IHBvcztcclxuICAgICAgICAgICAgaWYgKHJlcy5raW5kID09IFwib2tcIikge1xyXG4gICAgICAgICAgICAgICAgbGV0IGZvdW5kID0gYCR7cmVzLnJlc3VsdH1gO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHByLmZhaWxlZChyZXMucG9zaXRpb24sIGZvdW5kLCBbXCJub3QgXCIgKyBmb3VuZF0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBwci5zdWNjZWVkZWQocmVzLnBvc2l0aW9uLCB1bmRlZmluZWQpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBCYWN0cmFjayB0byB0aGUgY3VycmVudCBpbnB1dCBwb3NpdGlvbiwgZXZlbiBpZiB0aGUgZ2l2ZW4gcGFyc2VyIGZhaWxzXHJcbiAgICAgKiBhbmQgaGFzIGFkdmFuY2VkIHRoZSBpbnB1dCBwb3NpdGlvbi4gTm9ybWFsbHkgd2UgZG8gbm90IGJhY3RyYWNrIHdoZW4gYVxyXG4gICAgICogcGFyc2VyIGhhcyBhZHZhbmNlZCBpbiB0aGUgaW5wdXQuIERvaW5nIHNvIHdvdWxkIGxvb3NlIHRoZSBwb3NpdGlvbiB3aGVyZVxyXG4gICAgICogdGhlIHBhcnNpbmcgZmFpbGVkIGFuZCBtYWtlIGVycm9yIG1lc3NhZ2VzIG1vcmUgdmFndWUuIFNvbWV0aW1lcyxcclxuICAgICAqIGhvd2V2ZXIsIHdlIG5lZWQgbW9yZSBpbnB1dCBsb29rYWhlYWQuIEluIHRoZXNlIGNhc2VzLCB5b3UgY2FuIHVzZSB0aGVcclxuICAgICAqIGJhY2t0cmFjayBvcGVyYXRpb24gdG8gcmV0cnkgdGhlIG5leHQgcnVsZS5cclxuICAgICAqL1xyXG4gICAgYmFja3RyYWNrKCkge1xyXG4gICAgICAgIHJldHVybiBuZXcgUGFyc2VyKGlucHV0ID0+IHtcclxuICAgICAgICAgICAgbGV0IHBvcyA9IGlucHV0LnBvc2l0aW9uO1xyXG4gICAgICAgICAgICBsZXQgcmVzID0gdGhpcy5wYXJzZShpbnB1dCk7XHJcbiAgICAgICAgICAgIGlmIChyZXMua2luZCA9PSBcImZhaWxcIiAmJiByZXMucG9zaXRpb24gPiBwb3MpXHJcbiAgICAgICAgICAgICAgICByZXMucG9zaXRpb24gPSBwb3M7XHJcbiAgICAgICAgICAgIHJldHVybiByZXM7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqICMjIEVycm9yIFJlcG9ydGluZyBhbmQgRGVidWdnaW5nXHJcbiAgICAgKlxyXG4gICAgICogR2l2ZSBhIGh1bWFuLXJlYWRhYmxlIG5hbWUgdG8gdGhlIFwidGhpbmdcIiB0aGF0IHRoZSBnaXZlbiBwYXJzZXIgbWF0Y2hlcy5cclxuICAgICAqIFRoaXMgbmFtZSBpcyByZXBvcnRlZCBhcyBleHBlY3RlZCB2YWx1ZSwgaWYgdGhlIHBhcnNpbmcgZmFpbHMuXHJcbiAgICAgKi9cclxuICAgIGV4cGVjdChleHBlY3RlZCkge1xyXG4gICAgICAgIGlmICghZXhwb3J0cy5wYXJzZXJEZWJ1Zy5lcnJvck1lc3NhZ2VzKVxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICBsZXQgcmVzUGFyc2VyID0gbmV3IFBhcnNlcigoaW5wdXQpID0+IHtcclxuICAgICAgICAgICAgbGV0IHJlcyA9IHRoaXMucGFyc2UoaW5wdXQpO1xyXG4gICAgICAgICAgICBpZiAocmVzLmtpbmQgPT0gXCJmYWlsXCIpXHJcbiAgICAgICAgICAgICAgICByZXMuZXhwZWN0ZWQucHVzaChleHBlY3RlZCk7XHJcbiAgICAgICAgICAgIHJldHVybiByZXM7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIGV4cG9ydHMucGFyc2VyRGVidWcuZGVidWdnaW5nID8gcmVzUGFyc2VyLnRyYWNlKGV4cGVjdGVkKSA6IHJlc1BhcnNlcjtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQXR0YWNoIGRlYnVnZ2luZyBpbmZvcm1hdGlvbiB0byBhIHBhcnNlci4gVG8gdHJhY2Ugd2hpY2ggcnVsZXMgYXJlXHJcbiAgICAgKiB0cmlnZ2VyZWQgZHVyaW5nIHBhcnNpbmcsIHlvdSBjYW4gYWRkIGRlYnVnZ2luZyBpbmZvIHRvIGFueSBwYXJzZXIuIFRoaXNcclxuICAgICAqIGNvbWJpbmF0b3IgcHJvZHVjZXMgYSBoaWVyYXJjaGljYWwgdHJlZSBvZiBwYXJzZXIgaW52b2NhdGlvbnMgd2hpY2hcclxuICAgICAqIGluY2x1ZGVzIGluZm9ybWF0aW9uIGFib3V0IGlucHV0IHN5bWJvbCBhbmQgaXRzIHBvc2l0aW9uLiBJZiBkZWJ1Z2dpbmdcclxuICAgICAqIGlzIGRpc2FibGVkLCB0aGlzIGZ1bmN0aW9uIGRvZXMgbm90aGluZy5cclxuICAgICAqL1xyXG4gICAgdHJhY2UocnVsZU5hbWUpIHtcclxuICAgICAgICBpZiAoIWV4cG9ydHMucGFyc2VyRGVidWcuZGVidWdnaW5nKVxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICByZXR1cm4gbmV3IFBhcnNlcihpbnB1dCA9PiB7XHJcbiAgICAgICAgICAgIGV4cG9ydHMucGFyc2VyRGVidWcud3JpdGUoYCR7cnVsZU5hbWV9IGNhbGxlZCB3aXRoIGlucHV0ICcke2lucHV0LmN1cnJlbnR9Jy5gKTtcclxuICAgICAgICAgICAgZXhwb3J0cy5wYXJzZXJEZWJ1Zy5pbmRlbnQoKTtcclxuICAgICAgICAgICAgbGV0IHJlcyA9IHRoaXMucGFyc2UoaW5wdXQpO1xyXG4gICAgICAgICAgICBleHBvcnRzLnBhcnNlckRlYnVnLnJ1bGVzRXZhbHVhdGVkKys7XHJcbiAgICAgICAgICAgIGV4cG9ydHMucGFyc2VyRGVidWcudW5pbmRlbnQoKTtcclxuICAgICAgICAgICAgZXhwb3J0cy5wYXJzZXJEZWJ1Zy53cml0ZSgocmVzLmtpbmQgPT0gXCJva1wiID9cclxuICAgICAgICAgICAgICAgIGAke3J1bGVOYW1lfSBTVUNDRUVERUQgd2l0aCB2YWx1ZSAnJHt1dGlscy5lc2NhcGVXaGl0ZXNwYWNlKGAke3Jlcy5yZXN1bHR9YCl9J2AgOlxyXG4gICAgICAgICAgICAgICAgYCR7cnVsZU5hbWV9IEZBSUxFRCB3aXRoIHZhbHVlICcke3V0aWxzLmVzY2FwZVdoaXRlc3BhY2UoYCR7cmVzLmZvdW5kfWApfScuIEV4cGVjdGVkIHZhbHVlczogJHtwci5leHBlY3RlZEFzQ3N2KHJlcyl9YCkgK1xyXG4gICAgICAgICAgICAgICAgYCBhdCBwb3NpdGlvbiAke3Jlcy5wb3NpdGlvbn1gKTtcclxuICAgICAgICAgICAgcmV0dXJuIHJlcztcclxuICAgICAgICB9KTtcclxuICAgIH1cclxufVxyXG5leHBvcnRzLlBhcnNlciA9IFBhcnNlcjtcclxuLyoqXHJcbiAqICMjIERlYnVnZ2luZyBPcHRpb25zXHJcbiAqXHJcbiAqIFRoZSBmb2xsb3dpbmcgb2JqZWN0IGNvbnRhaW5zIHRoZSBnbG9iYWwgc2V0dGluZ3MgdGhhdCBjb250cm9sIHRoZSBwYXJzZXJcclxuICogcmVwb3J0aW5nLlxyXG4gKi9cclxuZXhwb3J0cy5wYXJzZXJEZWJ1ZyA9IHtcclxuICAgIC8qKlxyXG4gICAgICogV2hlbiBgZGVidWdnaW5nYCBmbGFnIGlzIG9uIHBhcnNlcnMgY291bnQgdGhlIG51bWJlciBvZiBydWxlcyBldmFsdWF0ZWRcclxuICAgICAqIGR1cmluZyB0aGVpciBvcGVyYXRpb24uIFRoZSBgcnVsZXNFdmFsdWF0ZWRgIGZpZWxkIGNvbnRhaW5zIHRoaXNcclxuICAgICAqIGluZm9ybWF0aW9uLlxyXG4gICAgICovXHJcbiAgICBkZWJ1Z2dpbmc6IGZhbHNlLFxyXG4gICAgcnVsZXNFdmFsdWF0ZWQ6IDAsXHJcbiAgICAvKipcclxuICAgICAqIElmIGVycm9yTWVzc2FnZXMgZmxhZyBpcyB0dXJuZWQgb2ZmLCB0aGUgZXhwZWN0ZWQgaW5mb3JtYXRpb24gd2lsbCBub3QgYmVcclxuICAgICAqIGF2YWlsYWJsZSBpbiBwYXJzZSBlcnJvcnMuIFRoaXMgc3BlZWRzIHVwIHRoZSBwYXJzaW5nIG5vbWluYWxseS5cclxuICAgICAqL1xyXG4gICAgZXJyb3JNZXNzYWdlczogdHJ1ZSxcclxuICAgIC8qKlxyXG4gICAgICogVGhlIGN1cnJlbnQgaW5kZW50YXRpb24gbGV2ZWwgaW4gdGhlIGRlYnVnZ2luZyBvdXRwdXQgaXMgc3RvcmVkIGluIHRoaXNcclxuICAgICAqIGZpZWxkLlxyXG4gICAgICovXHJcbiAgICBpbmRlbnRhdGlvbjogMCxcclxuICAgIC8qKlxyXG4gICAgICogSW5kZW50IHRoZSBkZWJ1ZyBvdXRwdXQgYnkgb25lIGxldmVsLlxyXG4gICAgICovXHJcbiAgICBpbmRlbnQoKSB7XHJcbiAgICAgICAgdGhpcy5pbmRlbnRhdGlvbisrO1xyXG4gICAgfSxcclxuICAgIC8qKlxyXG4gICAgICogVW5uZGVudCB0aGUgZGVidWcgb3V0cHV0IGJ5IG9uZSBsZXZlbC5cclxuICAgICAqL1xyXG4gICAgdW5pbmRlbnQoKSB7XHJcbiAgICAgICAgdGhpcy5pbmRlbnRhdGlvbi0tO1xyXG4gICAgfSxcclxuICAgIC8qKlxyXG4gICAgICogV3JpdGUgYSBzdHJpbmcgdG8gdGhlIGRlYnVnIG91dHB1dC5cclxuICAgICAqL1xyXG4gICAgd3JpdGUodGV4dCkge1xyXG4gICAgICAgIGxldCB0YWJzID0gXCIgIFwiLnJlcGVhdCh0aGlzLmluZGVudGF0aW9uKTtcclxuICAgICAgICBjb25zb2xlLmxvZyh0YWJzICsgdGV4dCk7XHJcbiAgICB9XHJcbn07XHJcbi8qKlxyXG4gKiAjIyBNYWluIEZ1bmN0aW9uc1xyXG4gKlxyXG4gKiBBdHRlbXB0IHRvIHBhcnNlIGFuIGlucHV0IHdpdGggYSBnaXZlbiBwYXJzZXIuIFRha2VzIGEgUGFyc2VyIGFuZCBhXHJcbiAqIFBhcnNlcklucHV0IGFzIGFyZ3VtZW50cyBhbmQgcmV0dXJuIGEgUGFyc2VSZXN1bHQuXHJcbiAqL1xyXG5mdW5jdGlvbiB0cnlQYXJzZShwYXJzZXIsIGlucHV0KSB7XHJcbiAgICBleHBvcnRzLnBhcnNlckRlYnVnLnJ1bGVzRXZhbHVhdGVkID0gMDtcclxuICAgIGxldCByZXMgPSBwYXJzZXIucGFyc2UoaW5wdXQpO1xyXG4gICAgaWYgKGV4cG9ydHMucGFyc2VyRGVidWcuZGVidWdnaW5nKVxyXG4gICAgICAgIGNvbnNvbGUuaW5mbyhcIk51bWJlciBvZiBydWxlcyBldmFsdWF0ZWQ6IFwiICsgZXhwb3J0cy5wYXJzZXJEZWJ1Zy5ydWxlc0V2YWx1YXRlZCk7XHJcbiAgICByZXR1cm4gcmVzO1xyXG59XHJcbmV4cG9ydHMudHJ5UGFyc2UgPSB0cnlQYXJzZTtcclxuLyoqXHJcbiAqIFBhcnNlIGFuIGlucHV0IHVzaW5nIGEgZ2l2ZW4gcGFyc2VyLCBvciB0aHJvdyBhbiBleGNlcHRpb24sIGlmIHBhcnNpbmcgZmFpbHMuXHJcbiAqL1xyXG5mdW5jdGlvbiBwYXJzZShwYXJzZXIsIGlucHV0KSB7XHJcbiAgICB2YXIgcmVzID0gdHJ5UGFyc2UocGFyc2VyLCBpbnB1dCk7XHJcbiAgICBpZiAocmVzLmtpbmQgPT0gXCJmYWlsXCIpXHJcbiAgICAgICAgdGhyb3cgbmV3IGVyci5QYXJzZUVycm9yKGVyci5FcnJvclNvdXJjZS5QYXJzZXIsIHJlcy5wb3NpdGlvbiwgcmVzLmZvdW5kLCByZXMuZXhwZWN0ZWQpO1xyXG4gICAgcmV0dXJuIHJlcy5yZXN1bHQ7XHJcbn1cclxuZXhwb3J0cy5wYXJzZSA9IHBhcnNlO1xyXG4vKipcclxuICogIyMgTW9uYWRpYyBSZXR1cm5zXHJcbiAqXHJcbiAqIENyZWF0ZSBhIHBhcnNlciB0aGF0IGFsd2F5cyBzdWNjZWVkcyBhbmQgcmV0dXJucyB0aGUgZ2l2ZW4gdmFsdWUgd2l0aG91dFxyXG4gKiBjb25zdW1pbmcgYW55IGlucHV0LiBUaGlzIGZ1bmN0aW9uIGltcGxlbWVudHMgdGhlIG1vbmFkaWMgcmV0dXJuLCB0aGF0IGlzLFxyXG4gKiBpdCBsaWZ0cyBhIHZhbHVlIHRvIHRoZSBwYXJzZXIgbW9uYWQuXHJcbiAqL1xyXG5mdW5jdGlvbiBtcmV0KHZhbHVlKSB7XHJcbiAgICByZXR1cm4gbmV3IFBhcnNlcihpbnB1dCA9PiBwci5zdWNjZWVkZWQoaW5wdXQucG9zaXRpb24sIHZhbHVlKSk7XHJcbn1cclxuZXhwb3J0cy5tcmV0ID0gbXJldDtcclxuLyoqXHJcbiAqIENyZWF0ZSBhIHBhcnNlciB0aGF0IGFsd2F5cyBmYWlscy4gVGhlIHRlcm1pbmFscyByZXBvcnRlZCBhc1xyXG4gKiBmb3VuZCBvciBleHBlY3RlZCBhcmUgZ2l2ZW4gYXMgYW4gYXJndW1lbnQuXHJcbiAqL1xyXG5mdW5jdGlvbiBmYWlsKGZvdW5kLCAuLi5leHBlY3RlZCkge1xyXG4gICAgcmV0dXJuIG5ldyBQYXJzZXIoaW5wdXQgPT4gcHIuZmFpbGVkKGlucHV0LnBvc2l0aW9uLCBmb3VuZCwgZXhwZWN0ZWQpKTtcclxufVxyXG5leHBvcnRzLmZhaWwgPSBmYWlsO1xyXG4vKipcclxuICogIyMgUGFyc2luZyBUZXJtaW5hbHNcclxuICpcclxuICogQ3JlYXRlcyBhIHBhcnNlciB0aGF0IHJlYWRzIG9uZSB0ZXJtaW5hbCBmcm9tIHRoZSBpbnB1dCBhbmQgcmV0dXJucyBpdCwgaWYgaXRcclxuICogc2F0aXNmaWVzIHRoZSBnaXZlbiBwcmVkaWNhdGU7IG90aGVyd2lzZSB0aGUgcGFyc2VyIGZhaWxzLlxyXG4gKi9cclxuZnVuY3Rpb24gc2F0aXNmeShwcmVkaWNhdGUpIHtcclxuICAgIHJldHVybiBuZXcgUGFyc2VyKGlucHV0ID0+IHtcclxuICAgICAgICBsZXQgcG9zID0gaW5wdXQucG9zaXRpb247XHJcbiAgICAgICAgbGV0IGl0ZW0gPSBpbnB1dC5uZXh0KCk7XHJcbiAgICAgICAgaWYgKHByZWRpY2F0ZShpdGVtKSlcclxuICAgICAgICAgICAgcmV0dXJuIHByLnN1Y2NlZWRlZChpbnB1dC5wb3NpdGlvbiwgaXRlbSk7XHJcbiAgICAgICAgaW5wdXQucG9zaXRpb24gPSBwb3M7XHJcbiAgICAgICAgcmV0dXJuIHByLmZhaWxlZChpbnB1dC5wb3NpdGlvbiwgYCR7aXRlbX1gKTtcclxuICAgIH0pO1xyXG59XHJcbmV4cG9ydHMuc2F0aXNmeSA9IHNhdGlzZnk7XHJcbi8qKlxyXG4gKiBDcmVhdGVzIGEgcGFyc2VyIHRoYXQgcmVhZHMgb25lIHRlcm1pbmFsIGZyb20gdGhlIGlucHV0IGFuZCByZXR1cm5zIGl0LCBpZiBpdFxyXG4gKiBkb2VzICoqbm90Kiogc2F0aXNmeSBhIGdpdmVuIHByZWRpY2F0ZS5cclxuICovXHJcbmZ1bmN0aW9uIG5vdFNhdGlzZnkocHJlZGljYXRlKSB7XHJcbiAgICByZXR1cm4gc2F0aXNmeSh4ID0+ICFwcmVkaWNhdGUoeCkpO1xyXG59XHJcbmV4cG9ydHMubm90U2F0aXNmeSA9IG5vdFNhdGlzZnk7XHJcbi8qKlxyXG4gKiBBbnkgb2YgdGhlIGdpdmVuIHBhcnNlcnMgbXVzdCBzdWNjZWVkLiBUaGUgb3BlcmF0aW9uIGlzIHRoZSBzYW1lXHJcbiAqIGFzIHRoZSBgb3JgIGNvbWJpbmF0b3IgZ2VuZXJhbGl6ZWQgdG8gYXJiaXRyYXJ5IG51bWJlciBvZiBjaG9pY2VzLlxyXG4gKi9cclxuZnVuY3Rpb24gYW55KC4uLnBhcnNlcnMpIHtcclxuICAgIGlmIChwYXJzZXJzLmxlbmd0aCA9PSAwKVxyXG4gICAgICAgIHRocm93IEVycm9yKFwiQXQgbGVhc3Qgb25lIHBhcnNlciBtdXN0IGJlIGdpdmVuLlwiKTtcclxuICAgIHJldHVybiBuZXcgUGFyc2VyKGlucHV0ID0+IHtcclxuICAgICAgICBsZXQgcmVzID0gbnVsbDtcclxuICAgICAgICBsZXQgaSA9IDA7XHJcbiAgICAgICAgbGV0IHBvcyA9IGlucHV0LnBvc2l0aW9uO1xyXG4gICAgICAgIGRvIHtcclxuICAgICAgICAgICAgbGV0IHIgPSBwYXJzZXJzW2krK10ucGFyc2UoaW5wdXQpO1xyXG4gICAgICAgICAgICBpZiAoci5raW5kID09IFwib2tcIilcclxuICAgICAgICAgICAgICAgIHJldHVybiByO1xyXG4gICAgICAgICAgICBpZiAoci5wb3NpdGlvbiA+IHBvcylcclxuICAgICAgICAgICAgICAgIHJldHVybiByO1xyXG4gICAgICAgICAgICBpZiAocmVzID09IG51bGwpXHJcbiAgICAgICAgICAgICAgICByZXMgPSByO1xyXG4gICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICBwci5qb2luRXhwZWN0ZWQocmVzLCByKTtcclxuICAgICAgICB9IHdoaWxlIChpIDwgcGFyc2Vycy5sZW5ndGgpO1xyXG4gICAgICAgIHJldHVybiByZXM7XHJcbiAgICB9KTtcclxufVxyXG5leHBvcnRzLmFueSA9IGFueTtcclxuLyoqXHJcbiAqIFBlZWsgbmV4dCBzeW1ib2wgaW4gdGhlIGlucHV0IHN0cmVhbSB3aXRob3V0IGNoYW5naW5nIHRoZSBwb3NpdGlvbi5cclxuICovXHJcbmZ1bmN0aW9uIHBlZWsoKSB7XHJcbiAgICByZXR1cm4gbmV3IFBhcnNlcihpbnB1dCA9PiB7XHJcbiAgICAgICAgbGV0IHBvcyA9IGlucHV0LnBvc2l0aW9uO1xyXG4gICAgICAgIGxldCBuZXh0ID0gaW5wdXQubmV4dCgpO1xyXG4gICAgICAgIGlucHV0LnBvc2l0aW9uID0gcG9zO1xyXG4gICAgICAgIHJldHVybiBwci5zdWNjZWVkZWQocG9zLCBuZXh0KTtcclxuICAgIH0pO1xyXG59XHJcbmV4cG9ydHMucGVlayA9IHBlZWs7XHJcbi8qKlxyXG4gKiBTZWxlY3QgYSBwYXJzZXIgdG8gYmUgdXNlZCBiYXNlZCBvbiB0aGUgbmV4dCBzeW1ib2wgaW4gdGhlIGlucHV0LiBUaGlzXHJcbiAqIGZ1bmN0aW9uIGlzIGFuIGFsdGVybmF0aXZlIHRvIHRoZSB0aGUgXCJhbnlcIiBjb21iaW5hdG9yLiBJdCByZWR1Y2VzXHJcbiAqIGJhY2t0cmFja2luZyB3aGVuIHRoZSBwYXJzZXIgdG8gYmUgYXBwbGllZCBjYW4gYmUgZGVkdWNlZCBmcm9tIHRoZSBuZXh0XHJcbiAqIHN5bWJvbC5cclxuICovXHJcbmZ1bmN0aW9uIGNob29zZShzZWxlY3Rvcikge1xyXG4gICAgcmV0dXJuIHBlZWsoKS5iaW5kKHNlbGVjdG9yKTtcclxufVxyXG5leHBvcnRzLmNob29zZSA9IGNob29zZTtcclxuLyoqXHJcbiAqICMjIEdldHRpbmcgQ3VycmVudCBQb3NpdGlvblxyXG4gKlxyXG4gKiBBIHBhcnNlciB0aGF0IHJldHVybnMgdGhlIGN1cnJlbnQgcG9zaXRpb24gb2YgdGhlIGlucHV0LiBUaGlzIGlzIHVzZWZ1bFxyXG4gKiB3aGVuIGJpbmRpbmcgcGFyc2VycyB0b2dldGhlciBhbmQgeW91IHdhbnQgdG8ga25vdyB0aGUgcG9zaXRpb24gd2hlcmUgeW91XHJcbiAqIGN1cnJlbnRseSBhcmUuIFRoZSBwb3NpdGlvbiBjYW4gYmUgYWxzbyB1c2VkIGZvciBiYWNrdHJhY2tpbmcuXHJcbiAqL1xyXG5mdW5jdGlvbiBwb3NpdGlvbigpIHtcclxuICAgIHJldHVybiBuZXcgUGFyc2VyKGlucHV0ID0+IHByLnN1Y2NlZWRlZChpbnB1dC5wb3NpdGlvbiwgaW5wdXQucG9zaXRpb24pKTtcclxufVxyXG5leHBvcnRzLnBvc2l0aW9uID0gcG9zaXRpb247XHJcbi8qKlxyXG4gKiAjIyBVc2VyLU1hbmFnZWQgU3RhdGVcclxuICpcclxuICogR2V0IHRoZSBjdXJyZW50IHNhdGVsbGl0ZSBzdGF0ZSBzdG9yZWQgaW4gdGhlIGlucHV0LlxyXG4gKi9cclxuZnVuY3Rpb24gZ2V0U3RhdGUoKSB7XHJcbiAgICByZXR1cm4gbmV3IFBhcnNlcihpbnB1dCA9PiBwci5zdWNjZWVkZWQoaW5wdXQucG9zaXRpb24sIGlucHV0LnN0YXRlKSk7XHJcbn1cclxuZXhwb3J0cy5nZXRTdGF0ZSA9IGdldFN0YXRlO1xyXG4vKipcclxuICogU2V0IHRoZSBjdXJyZW50IHNhdGVsbGl0ZSBzdGF0ZSBzdG9yZWQgaW4gdGhlIGlucHV0LiBUaGUgbmV3IHN0YXRlXHJcbiAqIGlzIG5vdCBnaXZlbiBleHBsaWNpdGx5LiBSYXRoZXIsIGEgZnVuY2lvbiB3aGljaCByZXR1cm5zIHRoZSBuZXdcclxuICogc3RhdGUgaXMgc3BlY2lmaWVkLlxyXG4gKi9cclxuZnVuY3Rpb24gc2V0U3RhdGUobmV3VmFsdWUpIHtcclxuICAgIHJldHVybiBuZXcgUGFyc2VyKGlucHV0ID0+IHByLnN1Y2NlZWRlZChpbnB1dC5wb3NpdGlvbiwgaW5wdXQuc3RhdGUgPSBuZXdWYWx1ZSgpKSk7XHJcbn1cclxuZXhwb3J0cy5zZXRTdGF0ZSA9IHNldFN0YXRlO1xyXG4vKipcclxuICogTXV0YXRlIHRoZSBzYXRlbGxpdGUgc3RhdGUgc3RvcmVkIGluIHRoZSBpbnB1dC4gVGhlIG11dGF0aW9uIGlzIGRvbmVcclxuICogd2l0aCBhIGZ1bmN0aW9uIGdpdmVuIGFzIGFuIGFyZ3VtZW50LlxyXG4gKi9cclxuZnVuY3Rpb24gbXV0YXRlU3RhdGUobXV0YXRlKSB7XHJcbiAgICByZXR1cm4gbmV3IFBhcnNlcihpbnB1dCA9PiB7XHJcbiAgICAgICAgbXV0YXRlKGlucHV0LnN0YXRlKTtcclxuICAgICAgICByZXR1cm4gcHIuc3VjY2VlZGVkKGlucHV0LnBvc2l0aW9uLCBpbnB1dC5zdGF0ZSk7XHJcbiAgICB9KTtcclxufVxyXG5leHBvcnRzLm11dGF0ZVN0YXRlID0gbXV0YXRlU3RhdGU7XHJcbi8qKlxyXG4gKiBDaGVjayB0aGF0IHRoZSBjdXJyZW50IHN0YXRlIG1hdGNoZXMgYSBwcmVkaWNhdGUuIElmIG5vdCwgdGhlIHJlc3VsdCBwYXJzZXJcclxuICogZmFpbHMuXHJcbiAqL1xyXG5mdW5jdGlvbiBjaGVja1N0YXRlKHByZWRpY2F0ZSkge1xyXG4gICAgcmV0dXJuIG5ldyBQYXJzZXIoaW5wdXQgPT4gcHJlZGljYXRlKGlucHV0LnN0YXRlKSA/XHJcbiAgICAgICAgcHIuc3VjY2VlZGVkKGlucHV0LnBvc2l0aW9uLCBpbnB1dC5zdGF0ZSkgOlxyXG4gICAgICAgIHByLmZhaWxlZChpbnB1dC5wb3NpdGlvbiwgXCJNYXRjaGluZyBwcmVkaWNhdGUuXCIpKTtcclxufVxyXG5leHBvcnRzLmNoZWNrU3RhdGUgPSBjaGVja1N0YXRlO1xyXG4vKipcclxuICogQ2xlYW4gdXAgdGhlIGN1cnJlbnQgc3RhdGUgYWZ0ZXIgYSBwYXJzZXIgaGFzIGJlZW4gZXhlY3V0ZWQuIFRoZSBjbGVhbi11cFxyXG4gKiBmdW5jdGlvbiBpcyBydW4gcmVnYXJkbGVzcyBvZiB3aGV0aGVyIHRoZSBwYXJzZXIgc3VjY2VlZHMgb3IgZmFpbHMuXHJcbiAqL1xyXG5mdW5jdGlvbiBjbGVhbnVwU3RhdGUocGFyc2VyLCBjbGVhbnVwKSB7XHJcbiAgICByZXR1cm4gbmV3IFBhcnNlcihpbnB1dCA9PiB7XHJcbiAgICAgICAgbGV0IHJlcyA9IHBhcnNlci5wYXJzZShpbnB1dCk7XHJcbiAgICAgICAgY2xlYW51cChpbnB1dC5zdGF0ZSk7XHJcbiAgICAgICAgcmV0dXJuIHJlcztcclxuICAgIH0pO1xyXG59XHJcbmV4cG9ydHMuY2xlYW51cFN0YXRlID0gY2xlYW51cFN0YXRlO1xyXG4vKipcclxuICogIyMgRGVmaW5pbmcgTXV0dWFsbHkgUmVjdXJzaXZlIFBhcnNlcnNcclxuICpcclxuICogT2Z0ZW4gZ3JhbW1hciBydWxlcyBhcmUgbXV0dWFsbHkgcmVjdXJzaXZlLCB3aGljaCBtZWFucyB0aGF0IHRoZXJlIGlzIG5vIHdheVxyXG4gKiB0byB3cml0ZSB0aGVtIGluIGFuIG9yZGVyIHdoZXJlIGFsbCB0aGUgZGVwZW5kZW50IHJ1bGVzIGFyZSBkZWZpbmVkLiBJbiB0aGVzZVxyXG4gKiBvY2Nhc2lvbnMsIHlvdSBjYW4ganVzdCBjcmVhdGUgYSBfcmVmZXJlbmNlXyB0byBhIHBhcnNlciBhbmQgc2V0IGl0c1xyXG4gKiBpbXBsZW1lbnRhdGlvbiBsYXRlci4gVG8gcmVmZXIgdG8gdGhlIHBhcnNlciB0aGF0IGlzIG5vdCB5ZXQgZGVmaW5lZCwgeW91IGNhblxyXG4gKiB1c2UgdGhpcyBmdW5jdGlvbi5cclxuICovXHJcbmZ1bmN0aW9uIGZvcndhcmRSZWYocGFyc2VyKSB7XHJcbiAgICByZXR1cm4gbmV3IFBhcnNlcihpbnB1dCA9PiBwYXJzZXIudGFyZ2V0LnBhcnNlKGlucHV0KSk7XHJcbn1cclxuZXhwb3J0cy5mb3J3YXJkUmVmID0gZm9yd2FyZFJlZjtcclxuLyoqXHJcbiAqICMjIEdlbmVyYWwgUGFyc2Vyc1xyXG4gKlxyXG4gKiBUaGUgY2F0Y2gtYWxsIHBhcnNlciB0aGF0IHdpbGwgbWF0Y2ggYW55IHN5bWJvbCByZWFkIGZyb20gdGhlIGlucHV0LlxyXG4gKi9cclxuZnVuY3Rpb24gYW55dGhpbmcoKSB7XHJcbiAgICByZXR1cm4gc2F0aXNmeShfID0+IHRydWUpO1xyXG59XHJcbmV4cG9ydHMuYW55dGhpbmcgPSBhbnl0aGluZztcclxuLyoqXHJcbiAqIFBhcnNlciB0aGF0IHN1Y2NlZWRzIGlmIHRoZSBzeW1ib2wgcmVhZCBmcm9tIHRoZSBpbnB1dCBpcyBlcXVhbCAoPT09KSB0b1xyXG4gKiBnaXZlbiBwYXJhbWV0ZXI7IG90aGVyd2lzZSBwYXJzaW5nIGZhaWxzLlxyXG4gKi9cclxuZnVuY3Rpb24gaXModmFsdWUpIHtcclxuICAgIHJldHVybiBzYXRpc2Z5KHggPT4geCA9PT0gdmFsdWUpO1xyXG59XHJcbmV4cG9ydHMuaXMgPSBpcztcclxuLyoqXHJcbiAqIFBhcnNlIGEgc3BlY2lmaWMgdG9rZW4gZnJvbSB0aGUgbGV4ZXIgaW5wdXQgc3RyZWFtLlxyXG4gKi9cclxuZnVuY3Rpb24gdG9rZW4odG9rZW4pIHtcclxuICAgIHJldHVybiBzYXRpc2Z5KHQgPT4gdC50b2tlbiA9PT0gdG9rZW4pO1xyXG59XHJcbmV4cG9ydHMudG9rZW4gPSB0b2tlbjtcclxuLyoqXHJcbiAqIEhlbHBlciBmdW5jdGlvbiB0byBjcmVhdGUgYSB0ZXJtaW5hbCBwYXJzZXIuXHJcbiAqL1xyXG5mdW5jdGlvbiB0ZXJtaW5hbCh0b2ssIG5hbWUpIHtcclxuICAgIHJldHVybiB0b2tlbih0b2spLmV4cGVjdChuYW1lKTtcclxufVxyXG5leHBvcnRzLnRlcm1pbmFsID0gdGVybWluYWw7XHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmV4cG9ydHMuUmVmID0gdm9pZCAwO1xyXG4vKipcclxuICogIyBSZWZlcmVuY2UgQ2VsbHNcclxuICpcclxuICogYFJlZjxUPmAgY2xhc3MgcHJvdmlkZXMgYSBzaW1wbGUgcmVmZXJlbmNlIGNlbGwsIHdoaWNoIGNhbiBiZSB1c2VkXHJcbiAqIGFzIGEgc3Vycm9nYXRlIGZvciBhIHBhcnNlciB0aGF0IGlzIGRlZmluZWQgbGF0ZXIgb24uIFdlIGNhbiBkZWZpbmVcclxuICogYSBfcmVmZXJlbmNlXyB0byBwYXJzZXIsIGJ1dCB3ZSBkb24ndCBoYXZlIHRvIGdpdmUgdGhlIHRhcmdldCByaWdodFxyXG4gKiBhd2F5LiBXaGVuIGNvbXBvc2luZyBwYXJzZXJzIHdlIGNhbiB1c2UgdGhlIGBmb3J3YXJkUmVmYCBmdW5jdGlvblxyXG4gKiB0byBwYXNzIGEgcmVmZXJlbmNlIHRvIGFueSBjb21iaW5hdG9yIGV4cGVjdGluZyBhIGBQYXJzZXI8VCwgUz5gLlxyXG4gKiBPZiBjb3Vyc2UsIHdlIGhhdmUgdG8gZXZlbnR1YWxseSBhc3NpZ24gYSByZWFsIHBhcnNlciBhcyB0aGUgdGFyZ2V0XHJcbiAqIG9mIHRoZSByZWZlcmVuY2UgYmVmb3JlIHJ1bm5pbmcgdGhlIHBhcnNlci5cclxuICovXHJcbmNsYXNzIFJlZiB7XHJcbiAgICAvKipcclxuICAgICAqIENvbnN0cnVjdGluZyBhIHJlZmVyZW5jZS4gVGhlIHRhcmdldCB2YWx1ZSBpcyBvcHRpb25hbC5cclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IodmFsdWUpIHtcclxuICAgICAgICB0aGlzLl90YXJnZXQgPSBudWxsO1xyXG4gICAgICAgIGlmICh2YWx1ZSlcclxuICAgICAgICAgICAgdGhpcy5fdGFyZ2V0ID0gdmFsdWU7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEdldCB0aGUgdGFyZ2V0IG9mIHRoZSByZWZlcmVuY2UuIElmIG5vIHRhcmdldCBpcyBzZXQsIGFcclxuICAgICAqIGBSZWZlcmVuY2VFcnJvcmAgaXMgdGhyb3duLlxyXG4gICAgICovXHJcbiAgICBnZXQgdGFyZ2V0KCkge1xyXG4gICAgICAgIGlmICh0aGlzLl90YXJnZXQpXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl90YXJnZXQ7XHJcbiAgICAgICAgdGhyb3cgUmVmZXJlbmNlRXJyb3IoXCJUYXJnZXQgbm90IHNldC5cIik7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFNldCB0aGUgdGFyZ2V0LlxyXG4gICAgICovXHJcbiAgICBzZXQgdGFyZ2V0KHZhbHVlKSB7XHJcbiAgICAgICAgdGhpcy5fdGFyZ2V0ID0gdmFsdWU7XHJcbiAgICB9XHJcbn1cclxuZXhwb3J0cy5SZWYgPSBSZWY7XHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmV4cG9ydHMuZmFpbGVkID0gZXhwb3J0cy5zdWNjZWVkZWQgPSBleHBvcnRzLmV4cGVjdGVkQXNDc3YgPSBleHBvcnRzLmpvaW5FeHBlY3RlZCA9IHZvaWQgMDtcclxuLyoqXHJcbiAqICMjIEhlbHBlciBGdW5jdGlvbnNcclxuICpcclxuICogVGhlIGBqb2luRXhwZWN0ZWRgIGZ1bmN0aW9uIGNvbmNhdGVuYXRlcyB0aGUgbGlzdCBvZiBleHBlY3RlZFxyXG4gKiBpbnB1dHMgZnJvbSB0aGUgYG90aGVyYCBmYWlsZWQgcGFyc2UgcmVzdWx0IGludG8gdGhlIGBleHBlY3RlZGBcclxuICogYXJyYXkgb2YgdGhlIGZpcnN0IG9uZS5cclxuICovXHJcbmZ1bmN0aW9uIGpvaW5FeHBlY3RlZChyZXN1bHQsIG90aGVyKSB7XHJcbiAgICBpZiAob3RoZXIuZXhwZWN0ZWQubGVuZ3RoID4gMClcclxuICAgICAgICByZXN1bHQuZXhwZWN0ZWQgPSByZXN1bHQuZXhwZWN0ZWQuY29uY2F0KG90aGVyLmV4cGVjdGVkKTtcclxufVxyXG5leHBvcnRzLmpvaW5FeHBlY3RlZCA9IGpvaW5FeHBlY3RlZDtcclxuLyoqXHJcbiAqIFRoaXMgZnVuY3Rpb24gZm9ybWF0cyB0aGUgYXJyYXkgb2YgZXhwZWN0ZWQgaW5wdXRzIGFzIGEgc3RyaW5nIGZvclxyXG4gKiBwcmludGluZy5cclxuICovXHJcbmZ1bmN0aW9uIGV4cGVjdGVkQXNDc3YocmVzdWx0KSB7XHJcbiAgICByZXR1cm4gcmVzdWx0LmV4cGVjdGVkLm1hcChzID0+IGBcIiR7c31cImApLmpvaW4oXCIsIFwiKTtcclxufVxyXG5leHBvcnRzLmV4cGVjdGVkQXNDc3YgPSBleHBlY3RlZEFzQ3N2O1xyXG4vKipcclxuICogIyMgQ29uc3RydWN0b3IgRnVuY3Rpb25zXHJcbiAqXHJcbiAqIFRoZSBmb2xsb3dpbmcgZnVuY3Rpb24gaXMgdXNlZCB0byBjb25zdHJ1Y3QgYW4gYE9rPFQ+YCByZXN1bHQuXHJcbiAqL1xyXG5mdW5jdGlvbiBzdWNjZWVkZWQocG9zLCByZXMpIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAga2luZDogXCJva1wiLFxyXG4gICAgICAgIHBvc2l0aW9uOiBwb3MsXHJcbiAgICAgICAgcmVzdWx0OiByZXNcclxuICAgIH07XHJcbn1cclxuZXhwb3J0cy5zdWNjZWVkZWQgPSBzdWNjZWVkZWQ7XHJcbi8qKlxyXG4gKiBUaGUgbmV4dCBvbmUgY29uc3RydWN0cyBhIGBGYWlsYCByZXN1bHQuXHJcbiAqL1xyXG5mdW5jdGlvbiBmYWlsZWQocG9zLCBmbmQsIGV4cCA9IFtdKSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIGtpbmQ6IFwiZmFpbFwiLFxyXG4gICAgICAgIHBvc2l0aW9uOiBwb3MsXHJcbiAgICAgICAgZm91bmQ6IGZuZCxcclxuICAgICAgICBleHBlY3RlZDogZXhwXHJcbiAgICB9O1xyXG59XHJcbmV4cG9ydHMuZmFpbGVkID0gZmFpbGVkO1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5leHBvcnRzLnBhcnNlSnNvbiA9IGV4cG9ydHMuanNvbklucHV0ID0gZXhwb3J0cy5Kc29uVG9rZW4gPSB2b2lkIDA7XHJcbi8qKlxyXG4gKiAjIFBhcnNpbmcgSlNPTlxyXG4gKlxyXG4gKiBUaGUgbmV4dCBleGFtcGxlIHBhcnNlciBjb252ZXJ0cyBKU09OIHN0cmluZ3MgdG8gSmF2YVNjcmlwdCBvYmplY3RzLiBJdFxyXG4gKiBlZmZlY3RpdmVseSBkb2VzIHRoZSBzYW1lIHRoaW5nIGFzIHRoZSBgSlNPTi5wYXJzZWAgZnVuY3Rpb24uIFNvLCBpdCBzZXJ2ZXNcclxuICogbm8gcHJhY3RpY2FsIHB1cnBvc2UsIGJ1dCBpcyBhIG5pY2UgZXhhbXBsZSBkdWUgdG8gc2ltcGxpY2l0eSBvZiB0aGUgSlNPTlxyXG4gKiBncmFtbWFyLiBUbyBtYWtlIG91ciBpbXBsZW1lbnRhdGlvbiBtYXJnaW5hbGx5IG1vcmUgdXNlZnVsLCBsZXQncyBhbGxvdyB0b1xyXG4gKiBpbmNsdWRlIGNvbW1lbnRzIGluc2lkZSBKU09OLlxyXG4gKi9cclxuY29uc3QgcHogPSByZXF1aXJlKFwiLi5cIik7XHJcbi8qKlxyXG4gKiAjIyBUb2tlbnNcclxuICpcclxuICogRmlyc3Qgd2UgZGVmaW5lIGFsbCB0aGUgdG9rZW5zIHRoYXQgSlNPTiBmaWxlcyBtYXkgY29udGFpbi4gVGhlc2UgYXJlIGFsbFxyXG4gKiBzcGVjaWZpZWQgaW4gW2pzb24ub3JnXVtdLlxyXG4gKlxyXG4gKiBbanNvbi5vcmddOiBodHRwczovL3d3dy5qc29uLm9yZ1xyXG4gKi9cclxudmFyIEpzb25Ub2tlbjtcclxuKGZ1bmN0aW9uIChKc29uVG9rZW4pIHtcclxuICAgIEpzb25Ub2tlbltKc29uVG9rZW5bXCJUcnVlXCJdID0gMF0gPSBcIlRydWVcIjtcclxuICAgIEpzb25Ub2tlbltKc29uVG9rZW5bXCJGYWxzZVwiXSA9IDFdID0gXCJGYWxzZVwiO1xyXG4gICAgSnNvblRva2VuW0pzb25Ub2tlbltcIk51bGxcIl0gPSAyXSA9IFwiTnVsbFwiO1xyXG4gICAgSnNvblRva2VuW0pzb25Ub2tlbltcIkxlZnRCcmFjZVwiXSA9IDNdID0gXCJMZWZ0QnJhY2VcIjtcclxuICAgIEpzb25Ub2tlbltKc29uVG9rZW5bXCJSaWdodEJyYWNlXCJdID0gNF0gPSBcIlJpZ2h0QnJhY2VcIjtcclxuICAgIEpzb25Ub2tlbltKc29uVG9rZW5bXCJMZWZ0QnJhY2tldFwiXSA9IDVdID0gXCJMZWZ0QnJhY2tldFwiO1xyXG4gICAgSnNvblRva2VuW0pzb25Ub2tlbltcIlJpZ2h0QnJhY2tldFwiXSA9IDZdID0gXCJSaWdodEJyYWNrZXRcIjtcclxuICAgIEpzb25Ub2tlbltKc29uVG9rZW5bXCJDb21tYVwiXSA9IDddID0gXCJDb21tYVwiO1xyXG4gICAgSnNvblRva2VuW0pzb25Ub2tlbltcIkNvbG9uXCJdID0gOF0gPSBcIkNvbG9uXCI7XHJcbiAgICBKc29uVG9rZW5bSnNvblRva2VuW1wiTnVtYmVyXCJdID0gOV0gPSBcIk51bWJlclwiO1xyXG4gICAgSnNvblRva2VuW0pzb25Ub2tlbltcIlN0cmluZ1wiXSA9IDEwXSA9IFwiU3RyaW5nXCI7XHJcbiAgICBKc29uVG9rZW5bSnNvblRva2VuW1wiV2hpdGVzcGFjZVwiXSA9IDExXSA9IFwiV2hpdGVzcGFjZVwiO1xyXG4gICAgSnNvblRva2VuW0pzb25Ub2tlbltcIkNvbW1lbnRcIl0gPSAxMl0gPSBcIkNvbW1lbnRcIjtcclxuICAgIEpzb25Ub2tlbltKc29uVG9rZW5bXCJFT0ZcIl0gPSAxM10gPSBcIkVPRlwiO1xyXG59KShKc29uVG9rZW4gPSBleHBvcnRzLkpzb25Ub2tlbiB8fCAoZXhwb3J0cy5Kc29uVG9rZW4gPSB7fSkpO1xyXG4vLyNyZWdpb24gLWMgRGVidWcgc2V0dGluZ3NcclxucHoucGFyc2VyRGVidWcuZGVidWdnaW5nID0gZmFsc2U7XHJcbi8vI2VuZHJlZ2lvblxyXG4vKipcclxuICogIyMgTGV4ZXJcclxuICpcclxuICogV2UgZGVmaW5lIGxleGVycyBmb3IgYWxsIHRoZSB0b2tlbnMuIEZpcnN0IHdlIGhhbmRsZSBjb25zdGFudHMgYW5kIHNlcGFyYXRvclxyXG4gKiBjaGFyYWN0ZXJzLiBUaGV5IGFyZSB0cml2aWFsIHRvIHJlY29nbml6ZS5cclxuICpcclxuICogTnVtYmVycyBhcmUgYSBiaXQgdHJpY2tpZXIgYXMgd2UgbmVlZCB0byBzdXBwb3J0IGRlY2ltYWwgZm9ybWF0cyB3aXRoXHJcbiAqIGFuZCB3aXRob3V0IGV4cG9uZW50cy5cclxuICpcclxuICogIVtudW1iZXJdKC4uLy4uL2ltYWdlcy9udW1iZXIucG5nKVxyXG4gKlxyXG4gKiBTdHJpbmdzIGNhbiBiZSBhIGJpdCB0cmlja3kgYXMgd2VsbCwgYXMgdGhlcmUgYXJlIHNwZWNpYWwgY2hhcmFjdGVycyB0aGF0XHJcbiAqIGhhdmUgdG8gYmUgYWNjb3VudGVkIGZvci4gQW5vdGhlciBub3RhYmxlIHRoaW5nIGlzIHRoYXQgd2UgbmVlZCB0byB1c2UgdGhlXHJcbiAqIGB1YCBzcGVjaWZpZXIgaW4gb3VyIHJlZ2V4IGZvciB1bmljb2RlIHN1cHBvcnQuXHJcbiAqXHJcbiAqICFbc3RyaW5nXSguLi8uLi9pbWFnZXMvc3RyaW5nLnBuZylcclxuICpcclxuICogQmVsb3cgd2Ugc2VlIGhvdyB3aGl0ZXNwYWNlIGlzIHNjYW5uZWQgaW4gSlNPTi4gV2UnbGwgYWRkIGEgbGV4ZXIgZm9yIGlubGluZVxyXG4gKiBjb21tZW50cyBgLy8uLi5gIGFzIHdlbGwuXHJcbiAqXHJcbiAqICFbc3RyaW5nXSguLi8uLi9pbWFnZXMvd2hpdGVzcGFjZS5wbmcpXHJcbiAqL1xyXG5jb25zdCBsZXhlciA9IG5ldyBwei5MZXhlcihbL3RydWUvLCBKc29uVG9rZW4uVHJ1ZV0sIFsvZmFsc2UvLCBKc29uVG9rZW4uRmFsc2VdLCBbL251bGwvLCBKc29uVG9rZW4uTnVsbF0sIFsvXFx7LywgSnNvblRva2VuLkxlZnRCcmFjZV0sIFsvXFx9LywgSnNvblRva2VuLlJpZ2h0QnJhY2VdLCBbL1xcWy8sIEpzb25Ub2tlbi5MZWZ0QnJhY2tldF0sIFsvXFxdLywgSnNvblRva2VuLlJpZ2h0QnJhY2tldF0sIFsvLC8sIEpzb25Ub2tlbi5Db21tYV0sIFsvOi8sIEpzb25Ub2tlbi5Db2xvbl0sIFsvLT8oPzpbMS05XVxcZCt8XFxkKD8hXFxkKSkoPzpcXC5cXGQrKT8oPzpbZUVdWystXT9cXGQrKT8vLCBKc29uVG9rZW4uTnVtYmVyXSwgWy9cIig/Oig/Oig/IVtcIlxcXFxdKVtcXHV7MDAyMH0tXFx1e2ZmZmZ9XSl8KD86XFxcXCg/OltcIlxcXFxcXC9ibmZydF18KD86dVswLTlhLWZBLUZdezR9KSkpKSpcIi91LFxyXG4gICAgSnNvblRva2VuLlN0cmluZ10sIFsvW1xcdFxcblxcciBdKy8sIEpzb25Ub2tlbi5XaGl0ZXNwYWNlXSwgWy9cXC9cXC9bXlxcblxccl0qLywgSnNvblRva2VuLkNvbW1lbnRdKTtcclxuLyoqXHJcbiAqICMjIFRlcm1pbmFsc1xyXG4gKlxyXG4gKiBXaXRoIHRva2VucyBkZWZpbmVkLCBwYXJzZXJzIGZvciB0ZXJtaW5hbHMgYXJlIHRyaXZpYWwgdG8gd3JpdGUuIE5vdGUgaG93XHJcbiAqIHdlIG1hcCB0aGUgdGVybWluYWxzIHRvIEphdmFTY3JpcHQgdHlwZXMuIFdlIGV2ZW4gY2hlYXQgYSBiaXQsIGFuZCBjb252ZXJ0XHJcbiAqIHN0cmluZ3MgdXNpbmcgYEpTT04ucGFyc2VgLiBXZSBza2lwIHRoZSB0cmFpbGluZyB3aGl0ZXNwYWNlIChpbmNsdWRpbmdcclxuICogY29tbWVudHMpIGZvciBlYWNoIHRva2VuIHdoaWNoIG1ha2VzIG91ciBvdGhlciBydWxlcyBzaW1wbGVyLlxyXG4gKi9cclxuY29uc3QgY29tbWVudCA9IHB6LnRva2VuKEpzb25Ub2tlbi5Db21tZW50KTtcclxuY29uc3Qgd2hpdGVzcGFjZSA9IHB6LnRva2VuKEpzb25Ub2tlbi5XaGl0ZXNwYWNlKS5vcihjb21tZW50KS56ZXJvT3JNb3JlKCk7XHJcbmNvbnN0IG51bWJlciA9IHB6LnRlcm1pbmFsKEpzb25Ub2tlbi5OdW1iZXIsIFwiPG51bWJlcj5cIilcclxuICAgIC5tYXAodCA9PiBOdW1iZXIodC50ZXh0KSkuZm9sbG93ZWRCeSh3aGl0ZXNwYWNlKTtcclxuY29uc3Qgc3RyaW5nID0gcHoudGVybWluYWwoSnNvblRva2VuLlN0cmluZywgXCI8c3RyaW5nPlwiKVxyXG4gICAgLm1hcCh0ID0+IEpTT04ucGFyc2UodC50ZXh0KSkuZm9sbG93ZWRCeSh3aGl0ZXNwYWNlKTtcclxuY29uc3QgbGl0dHJ1ZSA9IHB6LnRlcm1pbmFsKEpzb25Ub2tlbi5UcnVlLCBcInRydWVcIikubWFwKHQgPT4gdHJ1ZSlcclxuICAgIC5mb2xsb3dlZEJ5KHdoaXRlc3BhY2UpO1xyXG5jb25zdCBsaXRmYWxzZSA9IHB6LnRlcm1pbmFsKEpzb25Ub2tlbi5GYWxzZSwgXCJmYWxzZVwiKS5tYXAodCA9PiBmYWxzZSlcclxuICAgIC5mb2xsb3dlZEJ5KHdoaXRlc3BhY2UpO1xyXG5jb25zdCBsaXRudWxsID0gcHoudGVybWluYWwoSnNvblRva2VuLk51bGwsIFwibnVsbFwiKS5tYXAodCA9PiBudWxsKVxyXG4gICAgLmZvbGxvd2VkQnkod2hpdGVzcGFjZSk7XHJcbmNvbnN0IGNvbW1hID0gcHoudGVybWluYWwoSnNvblRva2VuLkNvbW1hLCBcIixcIikuZm9sbG93ZWRCeSh3aGl0ZXNwYWNlKTtcclxuY29uc3QgY29sb24gPSBwei50ZXJtaW5hbChKc29uVG9rZW4uQ29sb24sIFwiOlwiKS5mb2xsb3dlZEJ5KHdoaXRlc3BhY2UpO1xyXG5jb25zdCBiZWdpbmFycmF5ID0gcHoudGVybWluYWwoSnNvblRva2VuLkxlZnRCcmFja2V0LCBcIltcIikuZm9sbG93ZWRCeSh3aGl0ZXNwYWNlKTtcclxuY29uc3QgZW5kYXJyYXkgPSBwei50ZXJtaW5hbChKc29uVG9rZW4uUmlnaHRCcmFja2V0LCBcIl1cIikuZm9sbG93ZWRCeSh3aGl0ZXNwYWNlKTtcclxuY29uc3QgYmVnaW5vYmplY3QgPSBwei50ZXJtaW5hbChKc29uVG9rZW4uTGVmdEJyYWNlLCBcIntcIikuZm9sbG93ZWRCeSh3aGl0ZXNwYWNlKTtcclxuY29uc3QgZW5kb2JqZWN0ID0gcHoudGVybWluYWwoSnNvblRva2VuLlJpZ2h0QnJhY2UsIFwifVwiKS5mb2xsb3dlZEJ5KHdoaXRlc3BhY2UpO1xyXG5jb25zdCBlb2YgPSBwei50ZXJtaW5hbChKc29uVG9rZW4uRU9GLCBcIjxlbmQgb2YgaW5wdXQ+XCIpO1xyXG4vKipcclxuICogIyMgTm9udGVybWluYWxzXHJcbiAqXHJcbiAqIE5vdyB3ZSBjYW4gZGVmaW5lIHBhcnNlcnMgZm9yIG5vbnRlcm1pbmFscywgdGhlIGFic3RyYWN0IGFuZCByZWN1cnNpdmUgcGFydFxyXG4gKiBvZiB0aGUgZ3JhbW1hci4gYGVsZW1lbnRgIGlzIGEgcmVjdXJzaXZlIHBhcnNpbmcgcnVsZSB0aGF0IHdlIG5lZWQgdG8gZGVmaW5lXHJcbiAqIGxhdGVyIHNpbmNlIGl0IGRlcGVuZHMgb24gb3RoZXIgcnVsZXMuIFdlIGNyZWF0ZSBhIHJlZmVyZW5jZSBjZWxsIGZvciBpdCBhbmRcclxuICogdGhlbiBkZWZpbmUgdGhhdCBtdWx0aXBsZSBlbGVtZW50cyBjYW4gYmUgc2VwYXJhdGVkIGJ5IGNvbW1hLlxyXG4gKi9cclxuY29uc3QgZWxlbWVudCA9IG5ldyBwei5SZWYoKTtcclxuY29uc3QgZWxlbWVudHMgPSBwei5mb3J3YXJkUmVmKGVsZW1lbnQpLnplcm9Pck1vcmVTZXBhcmF0ZWRCeShjb21tYSlcclxuICAgIC50cmFjZShcImVsZW1lbnRzXCIpO1xyXG4vKipcclxuICogQW4gYXJyYXkgY29uc2lzdHMgb2YgbGlzdCBvZiBlbGVtZW50cyBzZXBhcmF0ZWQgYnkgY29tbWEgYW5kIGJyYWNrZXRlZCBieVxyXG4gKiBgW2AgYW5kIGBdYC5cclxuICovXHJcbmNvbnN0IGFycmF5ID0gZWxlbWVudHMuYnJhY2tldGVkQnkoYmVnaW5hcnJheSwgZW5kYXJyYXkpLnRyYWNlKFwiYXJyYXlcIik7XHJcbi8qKlxyXG4gKiBBIG1lbWJlciAob2YgYW4gb2JqZWN0KSBjb25zaXN0IG9mIGEgc3RyaW5nIGtleSwgYSBjb2xvbiwgYW5kIGFuIGVsZW1lbnQuXHJcbiAqIFRoZSBgbWVtYmVyYCBwYXJzZXIgcmV0dXJucyBhIFtfa2V5XywgX3ZhbHVlX10gcGFpci4gVGhlIGBtZW1iZXJzYCBwYXJzZXMgYVxyXG4gKiBsaXN0IG9mIG1lbWJlcnMgc2VwYXJhdGVkIGJ5IGNvbW1hcyBhbmQgcmV0dXJucyBhcnJheSBvZiBwYWlycy5cclxuICovXHJcbmNvbnN0IG1lbWJlciA9IHN0cmluZy5iaW5kKHMgPT4gY29sb24uYmluZChjID0+IHB6LmZvcndhcmRSZWYoZWxlbWVudCkuYmluZChlID0+IHB6Lm1yZXQoW3MsIGVdKSkpKVxyXG4gICAgLnRyYWNlKFwibWVtYmVyXCIpO1xyXG5jb25zdCBtZW1iZXJzID0gbWVtYmVyLnplcm9Pck1vcmVTZXBhcmF0ZWRCeShjb21tYSkudHJhY2UoXCJtZW1iZXJzXCIpO1xyXG4vKipcclxuICogQW4gb2JqZWN0IGlzIGxpc3Qgb2YgbWVtYmVycyBzdXJyb3VuZGVkIGJ5IGB7YCBhbmQgYH1gLiBUaGUgcGFyc2VyIHJldHVybnMgYVxyXG4gKiBKYXZhU2NyaXB0IG9iamVjdCB3aGljaCBpcyBjcmVhdGVkIGJ5IHRoZSBgaW5pdE9iamVjdGAgaGVscGVyIGZ1bmN0aW9uLiBJdFxyXG4gKiBjb25zdHJ1Y3RzIGFuIG9iamVjdCBmcm9tIGFuIGFycmF5IG9mIFtfa2V5XywgX3ZhbHVlX10gcGFpcnMuXHJcbiAqL1xyXG5jb25zdCBvYmplY3QgPSBtZW1iZXJzLmJyYWNrZXRlZEJ5KGJlZ2lub2JqZWN0LCBlbmRvYmplY3QpXHJcbiAgICAubWFwKG1zID0+IHB6LmluaXRPYmplY3QobXMpKS50cmFjZShcIm9iamVjdFwiKTtcclxuLyoqXHJcbiAqIE5vdyB3ZSBjYW4gZGVmaW5lIHRoZSBgZWxlbWVudGAgcnVsZS4gSXQgY2hvb3NlcyB0aGUgbmV4dCBwYXJzZXIgdG8gYmVcclxuICogYXBwbGllZCBiYXNlZCBvbiBhIGxvb2thaGVhZCB0b2tlbi4gSWYgaXQgaXMgYSBsZWZ0IGJyYWNlIG9yIGJyYWNrZXQsIHdlXHJcbiAqIHBhcnNlIGFuIG9iamVjdCBvciBhbiBhcnJheSByZXNwZWN0aXZlbHkuIElmIGl0IGlzIGEgcHJpbWl0aXZlIGVsZW1lbnRcclxuICogKHN0cmluZywgbnVtYmVyLCBib29sZWFuLCBvciBudWxsKSwgd2UganVtcCBkaXJlY3RseSB0byB0aGUgY29ycmVjdCBwYXJzZXIuXHJcbiAqIFRoaXMgc3BlZWRzIHVwIHBhcnNpbmcgYXMgd2UgZG9uJ3QgbmVlZCB0byB1c2UgdGhlIGBvcmAgY29tYmluYXRvciwgd2hpY2hcclxuICogdHJpZXMgYWx0ZXJuYXRpdmUgcGFyc2VycyBpbiB0dXJuLlxyXG4gKi9cclxuZWxlbWVudC50YXJnZXQgPSBwei5jaG9vc2UoKHRva2VuKSA9PiB7XHJcbiAgICBzd2l0Y2ggKHRva2VuLnRva2VuKSB7XHJcbiAgICAgICAgY2FzZSBKc29uVG9rZW4uTGVmdEJyYWNlOiByZXR1cm4gb2JqZWN0O1xyXG4gICAgICAgIGNhc2UgSnNvblRva2VuLkxlZnRCcmFja2V0OiByZXR1cm4gYXJyYXk7XHJcbiAgICAgICAgY2FzZSBKc29uVG9rZW4uU3RyaW5nOiByZXR1cm4gc3RyaW5nO1xyXG4gICAgICAgIGNhc2UgSnNvblRva2VuLk51bWJlcjogcmV0dXJuIG51bWJlcjtcclxuICAgICAgICBjYXNlIEpzb25Ub2tlbi5UcnVlOiByZXR1cm4gbGl0dHJ1ZTtcclxuICAgICAgICBjYXNlIEpzb25Ub2tlbi5GYWxzZTogcmV0dXJuIGxpdGZhbHNlO1xyXG4gICAgICAgIGNhc2UgSnNvblRva2VuLk51bGw6IHJldHVybiBsaXRudWxsO1xyXG4gICAgICAgIGRlZmF1bHQ6IHJldHVybiBwei5mYWlsKHRva2VuLnRleHQsIFwie1wiLCBcIltcIiwgXCI8c3RyaW5nPlwiLCBcIjxudW1iZXI+XCIsIFwidHJ1ZVwiLCBcImZhbHNlXCIsIFwibnVsbFwiKTtcclxuICAgIH1cclxufSkudHJhY2UoXCJlbGVtZW50XCIpO1xyXG4vKipcclxuICogRmluYWxseSB3ZSBjYW4gZGVmaW5lIHRoZSByb290IHBhcnNlciBmb3IgSlNPTi4gSXQgaXMganVzdCBhbiBgZWxlbWVudGBcclxuICogcGFyc2VyIHByZWNlZGVkIGJ5IG9wdGlvbmFsIHdoaXRlc3BhY2UuXHJcbiAqL1xyXG5jb25zdCBqc29uID0gd2hpdGVzcGFjZS5zZXEoZWxlbWVudC50YXJnZXQpLmZvbGxvd2VkQnkoZW9mKS50cmFjZShcImpzb25cIik7XHJcbi8qKlxyXG4gKiBJZiB5b3UgY29tcGFyZSB0aGUgZGVmaW5pdGlvbnMgYWJvdmUgdG8gdGhlIG9mZmljaWFsIGdyYW1tYXIgaW4gW2pzb24ub3JnXVtdLFxyXG4gKiB5b3UnbGwgZmluZCB0aGF0IHRoZXkgYXJlIGFsbW9zdCBpZGVudGljYWwuIFRoZSBvbmx5IGRpZmZlcmVuY2UgaXMgdGhhdCB3ZVxyXG4gKiBuZWVkIHRvIGRlY2xhcmUgdGhlIHJ1bGVzIGJvdHRvbS11cCBhcyB5b3UgY2Fubm90IHJlZmVyIHRvIGEgcnVsZSB3aGljaCBpc1xyXG4gKiBub3QgeWV0IGRlZmluZWQuIE90aGVyd2lzZSBpdCBpcyBhbG1vc3QgbWVjaGFuaWNhbCBleGVyY2lzZSB0byBjb252ZXJ0IHRoZVxyXG4gKiBncmFtbWFyIHRvIFBhcnplYyBjb21iaW5hdG9ycy5cclxuICpcclxuICogIyMgRXhwb3J0ZWQgUGFyc2luZyBGdW5jdGlvbnNcclxuICpcclxuICogRmlyc3Qgd2UgcHJvdmlkZSBhIGZ1bmN0aW9uIHRoYXQgY3JlYXRlcyBhIGxleGVyIGlucHV0IHN0cmVhbSBmb3IgYSBKU09OXHJcbiAqIHN0cmluZy5cclxuICovXHJcbmZ1bmN0aW9uIGpzb25JbnB1dCh0ZXh0KSB7XHJcbiAgICByZXR1cm4gcHoubGV4ZXJJbnB1dCh0ZXh0LCBsZXhlciwgbmV3IHB6LlRva2VuKEpzb25Ub2tlbi5FT0YsIFwiPGVuZCBvZiBpbnB1dD5cIikpO1xyXG59XHJcbmV4cG9ydHMuanNvbklucHV0ID0ganNvbklucHV0O1xyXG4vKipcclxuICogVGhlbiB3ZSBjYW4gZGVmaW5lIGEgZnVuY3Rpb24gdGhhdCB0YWtlcyBhIHN0cmluZyBhbmQgcmV0dXJucyBhIEpTIG9iamVjdC5cclxuICogSXQgdGhyb3dzIGFuIGV4Y2VwdGlvbiwgaWYgcGFyc2luZyBmYWlscy4gU28sIGl0IHdvcmtzIHRoZSBzYW1lIHdheSBhc1xyXG4gKiBgSlNPTi5wYXJzZWAuXHJcbiAqL1xyXG5mdW5jdGlvbiBwYXJzZUpzb24odGV4dCkge1xyXG4gICAgcmV0dXJuIHB6LnBhcnNlKGpzb24sIGpzb25JbnB1dCh0ZXh0KSk7XHJcbn1cclxuZXhwb3J0cy5wYXJzZUpzb24gPSBwYXJzZUpzb247XHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG52YXIgX19hd2FpdGVyID0gKHRoaXMgJiYgdGhpcy5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcclxuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxyXG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxyXG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxyXG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XHJcbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xyXG4gICAgfSk7XHJcbn07XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuLyoqXHJcbiAqIC0tLVxyXG4gKiB7XHJcbiAqICBcInZpc3VhbGl6ZXJzXCI6IFtcclxuICogICAgICB7XHJcbiAqICAgICAgICAgIFwicGF0aFwiOiBcIi4vc3JjL3Zpc3VhbGl6ZXJzL3J1bi1qc29uLXRlc3RzLnRzXCIsXHJcbiAqICAgICAgICAgIFwiaW5jbHVkZVN0eWxlc1wiOiB0cnVlXHJcbiAqICAgICAgfVxyXG4gKiAgXVxyXG4gKiB9XHJcbiAqIC0tLVxyXG4gKlxyXG4gKiAjIFRlc3RpbmcgSlNPTiBQYXJzZXJcclxuICpcclxuICogVG8gbWFudWFsbHkgdGVzdCB0aGUgcGFyc2VyIGVudGVyIG9yIHBhc3RlIHNvbWUgSlNPTiB0byB0aGUgdGV4dCBib3ggYmVsb3cuXHJcbiAqIFRyeSBhbHNvIGFkZCBjb21tZW50cyBhbnl3aGVyZSBpbnNpZGUgSlNPTi5cclxuICpcclxuICogPDx2Ompzb24tcGFyc2VyPj5cclxuICpcclxuICogTWFudWFsbHkgZW50ZXJpbmcgdGVzdCBkYXRhIGJlY29tZXMgYm9yaW5nIHNvb24sIHNvIHdlJ2xsIGFnYWluIHVzZVxyXG4gKiAqKmZhc3QtY2hlY2sqKiB0byBhdXRvbWF0ZSB0ZXN0IGNhc2UgZ2VuZXJhdGlvbi4gSW4gdGhpcyBjYXNlIHdlIGNhbiB1c2UgdGhlXHJcbiAqIGJ1aWx0LWluIGNvbWJpbmF0b3IgdGhhdCBnZW5lcmF0ZXMgYXJiaXRyYXJ5IEpTT04gZGF0YS4gU28sIG91ciBqb2IgaXMgbWFkZVxyXG4gKiBlYXN5IGZvciB1cy5cclxuICovXHJcbmNvbnN0IGpzb25wYXJzZXJfMSA9IHJlcXVpcmUoXCIuL2pzb25wYXJzZXJcIik7XHJcbmNvbnN0IHRlc3Rlcl8xID0gcmVxdWlyZShcImxpdHMtZXh0cmFzL2xpYi90ZXN0ZXJcIik7XHJcbmNvbnN0IGZjID0gcmVxdWlyZShcImZhc3QtY2hlY2tcIik7XHJcbi8qKlxyXG4gKiBXZSBzaG91bGQgZ2V0IGludGVyZXN0aW5nIHRlc3QgZGF0YS4gWW91IGNhbiBjaGVjayB0aGUgdGVzdCBjYXNlcyBiZWxvdy5cclxuICpcclxuICogPDx2OnJ1bi1qc29uLXRlc3RzIEpTT04gdGVzdHM+PlxyXG4gKlxyXG4gKiBVc2luZyBgSlNPTi5wYXJzZWAgYXMgdGhlIGJhc2VsaW5lIGZvciBvdXIgcGFyc2VyLCB3ZSBjYW4gY2hlY2sgdGhhdCBpdCBhbmRcclxuICogb3VyIHBhcnNpbmcgZnVuY3Rpb25zIHByb2R1Y2UgaWRlbnRpY2FsIEphdmFTY3JpcHQgb2JqZWN0cy4gV2UgdXNlIHRoZVxyXG4gKiBgZGVlcEVxdWFsYCBhc3NlcnRpb24gdG8gY2hlY2sgdGhhdC5cclxuICovXHJcbnRlc3Rlcl8xLnRlc3QoXCJUZXN0IGFyYml0cmFyeSBKU09OIGRhdGFcIiwgKHQpID0+IF9fYXdhaXRlcih2b2lkIDAsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgcmV0dXJuIGZjLmFzc2VydChmYy5wcm9wZXJ0eShmYy5qc29uKCksIHN0ciA9PiB7XHJcbiAgICAgICAgbGV0IG9iajEgPSBKU09OLnBhcnNlKHN0cik7XHJcbiAgICAgICAgbGV0IG9iajIgPSBqc29ucGFyc2VyXzEucGFyc2VKc29uKHN0cik7XHJcbiAgICAgICAgdC5kZWVwRXF1YWwob2JqMiwgb2JqMSwgSlNPTi5zdHJpbmdpZnkob2JqMikgK1xyXG4gICAgICAgICAgICBcIiBzaG91bGQgYmUgZGVlcCBlcXVhbCB0byBcIiArIEpTT04uc3RyaW5naWZ5KG9iajEpKTtcclxuICAgIH0pKTtcclxufSkpO1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5leHBvcnRzLmVzY2FwZVdoaXRlc3BhY2UgPSBleHBvcnRzLmluaXRPYmplY3QgPSB2b2lkIDA7XHJcbi8qKlxyXG4gKiAjIFV0aWxpdHkgRnVuY3Rpb25zXHJcbiAqXHJcbiAqIFRoaXMgbW9kdWxlIGNvbnRhaW5zIGdlbmVyYWwgZnVuY3Rpb25zIHVzZWQgZWxzZXdoZXJlIGluIHRoZSBsaWJyYXJ5LlxyXG4gKlxyXG4gKiBUaGUgZmlyc3QgZnVuY3Rpb24gaW5pdGlhbGl6ZXMgYW4gb2JqZWN0IGZyb20gYW4gYXJyYXkgb2YgYFtzdHJpbmcsIGFueV1gXHJcbiAqIHBhaXJzLiBJdCBpcyB1c2VkIHRvIHBvcHVsYXRlIGFuIG9iamVjdCBkeW5hbWljYWxseS5cclxuICovXHJcbmZ1bmN0aW9uIGluaXRPYmplY3QobWVtYmVycykge1xyXG4gICAgbGV0IHJlcyA9IHt9O1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtZW1iZXJzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgbGV0IFttLCB2XSA9IG1lbWJlcnNbaV07XHJcbiAgICAgICAgcmVzW21dID0gdjtcclxuICAgIH1cclxuICAgIHJldHVybiByZXM7XHJcbn1cclxuZXhwb3J0cy5pbml0T2JqZWN0ID0gaW5pdE9iamVjdDtcclxuLyoqXHJcbiAqIFRoZSBgZXNjYXBlV2hpdGVzcGFjZWAgZnVuY3Rpb24gaGVscHMgcHJpbnRpbmcgc3RyaW5ncyBjb250YWluaW5nIHdoaXRlc3BhY2VcclxuICogY2hhcmFjdGVycy4gSXQgcmVwbGFjZXMgdGhlbSB3aXRoIHRoZWlyIGVzY2FwZSBjb2Rlcy5cclxuICovXHJcbmZ1bmN0aW9uIGVzY2FwZVdoaXRlc3BhY2UodGV4dCkge1xyXG4gICAgcmV0dXJuIHRleHQucmVwbGFjZShcIlxcblwiLCBcIlxcXFxuXCIpLnJlcGxhY2UoXCJcXHJcIiwgXCJcXFxcclwiKS5yZXBsYWNlKFwiXFx0XCIsIFwiXFxcXHRcIik7XHJcbn1cclxuZXhwb3J0cy5lc2NhcGVXaGl0ZXNwYWNlID0gZXNjYXBlV2hpdGVzcGFjZTtcclxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG5jb25zdCBzdGFydFRlc3RNZXNzYWdlID0gKHRlc3QsIG9mZnNldCkgPT4gKHtcbiAgICB0eXBlOiBcIlRFU1RfU1RBUlRcIiAvKiBURVNUX1NUQVJUICovLFxuICAgIGRhdGE6IHRlc3QsXG4gICAgb2Zmc2V0XG59KTtcbmNvbnN0IGFzc2VydGlvbk1lc3NhZ2UgPSAoYXNzZXJ0aW9uLCBvZmZzZXQpID0+ICh7XG4gICAgdHlwZTogXCJBU1NFUlRJT05cIiAvKiBBU1NFUlRJT04gKi8sXG4gICAgZGF0YTogYXNzZXJ0aW9uLFxuICAgIG9mZnNldFxufSk7XG5jb25zdCBlbmRUZXN0TWVzc2FnZSA9ICh0ZXN0LCBvZmZzZXQpID0+ICh7XG4gICAgdHlwZTogXCJURVNUX0VORFwiIC8qIFRFU1RfRU5EICovLFxuICAgIGRhdGE6IHRlc3QsXG4gICAgb2Zmc2V0XG59KTtcbmNvbnN0IGJhaWxvdXQgPSAoZXJyb3IsIG9mZnNldCkgPT4gKHtcbiAgICB0eXBlOiBcIkJBSUxfT1VUXCIgLyogQkFJTF9PVVQgKi8sXG4gICAgZGF0YTogZXJyb3IsXG4gICAgb2Zmc2V0XG59KTtcblxuY29uc3QgZGVsZWdhdGVUb0NvdW50ZXIgPSAoY291bnRlcikgPT4gKHRhcmdldCkgPT4gT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGFyZ2V0LCB7XG4gICAgc2tpcENvdW50OiB7XG4gICAgICAgIGdldCgpIHtcbiAgICAgICAgICAgIHJldHVybiBjb3VudGVyLnNraXBDb3VudDtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgZmFpbHVyZUNvdW50OiB7XG4gICAgICAgIGdldCgpIHtcbiAgICAgICAgICAgIHJldHVybiBjb3VudGVyLmZhaWx1cmVDb3VudDtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgc3VjY2Vzc0NvdW50OiB7XG4gICAgICAgIGdldCgpIHtcbiAgICAgICAgICAgIHJldHVybiBjb3VudGVyLnN1Y2Nlc3NDb3VudDtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgY291bnQ6IHtcbiAgICAgICAgZ2V0KCkge1xuICAgICAgICAgICAgcmV0dXJuIGNvdW50ZXIuY291bnQ7XG4gICAgICAgIH1cbiAgICB9XG59KTtcbmNvbnN0IGNvdW50ZXIgPSAoKSA9PiB7XG4gICAgbGV0IHN1Y2Nlc3MgPSAwO1xuICAgIGxldCBmYWlsdXJlID0gMDtcbiAgICBsZXQgc2tpcCA9IDA7XG4gICAgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHtcbiAgICAgICAgdXBkYXRlKGFzc2VydGlvbikge1xuICAgICAgICAgICAgY29uc3QgeyBwYXNzLCBza2lwOiBpc1NraXBwZWQgfSA9IGFzc2VydGlvbjtcbiAgICAgICAgICAgIGlmIChpc1NraXBwZWQpIHtcbiAgICAgICAgICAgICAgICBza2lwKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICghaXNBc3NlcnRpb25SZXN1bHQoYXNzZXJ0aW9uKSkge1xuICAgICAgICAgICAgICAgIHNraXAgKz0gYXNzZXJ0aW9uLnNraXBDb3VudDtcbiAgICAgICAgICAgICAgICBzdWNjZXNzICs9IGFzc2VydGlvbi5zdWNjZXNzQ291bnQ7XG4gICAgICAgICAgICAgICAgZmFpbHVyZSArPSBhc3NlcnRpb24uZmFpbHVyZUNvdW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAocGFzcykge1xuICAgICAgICAgICAgICAgIHN1Y2Nlc3MrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGZhaWx1cmUrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAgc3VjY2Vzc0NvdW50OiB7XG4gICAgICAgICAgICBnZXQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN1Y2Nlc3M7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGZhaWx1cmVDb3VudDoge1xuICAgICAgICAgICAgZ2V0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWlsdXJlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBza2lwQ291bnQ6IHtcbiAgICAgICAgICAgIGdldCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc2tpcDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgY291bnQ6IHtcbiAgICAgICAgICAgIGdldCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc2tpcCArIHN1Y2Nlc3MgKyBmYWlsdXJlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG59O1xuXG5jb25zdCBkZWZhdWx0VGVzdE9wdGlvbnMgPSBPYmplY3QuZnJlZXplKHtcbiAgICBvZmZzZXQ6IDAsXG4gICAgc2tpcDogZmFsc2UsXG4gICAgcnVuT25seTogZmFsc2Vcbn0pO1xuY29uc3Qgbm9vcCA9ICgpID0+IHtcbn07XG5jb25zdCBUZXN0ZXJQcm90b3R5cGUgPSB7XG4gICAgW1N5bWJvbC5hc3luY0l0ZXJhdG9yXTogYXN5bmMgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgYXdhaXQgdGhpcy5yb3V0aW5lO1xuICAgICAgICBmb3IgKGNvbnN0IGFzc2VydGlvbiBvZiB0aGlzLmFzc2VydGlvbnMpIHtcbiAgICAgICAgICAgIGlmIChhc3NlcnRpb25bU3ltYm9sLmFzeW5jSXRlcmF0b3JdKSB7XG4gICAgICAgICAgICAgICAgLy8gU3ViIHRlc3RcbiAgICAgICAgICAgICAgICB5aWVsZCBzdGFydFRlc3RNZXNzYWdlKHsgZGVzY3JpcHRpb246IGFzc2VydGlvbi5kZXNjcmlwdGlvbiB9LCB0aGlzLm9mZnNldCk7XG4gICAgICAgICAgICAgICAgeWllbGQqIGFzc2VydGlvbjtcbiAgICAgICAgICAgICAgICBpZiAoYXNzZXJ0aW9uLmVycm9yICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEJ1YmJsZSB1cCB0aGUgZXJyb3IgYW5kIHJldHVyblxuICAgICAgICAgICAgICAgICAgICB0aGlzLmVycm9yID0gYXNzZXJ0aW9uLmVycm9yO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnBhc3MgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHlpZWxkIGFzc2VydGlvbk1lc3NhZ2UoYXNzZXJ0aW9uLCB0aGlzLm9mZnNldCk7XG4gICAgICAgICAgICB0aGlzLnBhc3MgPSB0aGlzLnBhc3MgJiYgYXNzZXJ0aW9uLnBhc3M7XG4gICAgICAgICAgICB0aGlzLmNvdW50ZXIudXBkYXRlKGFzc2VydGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuZXJyb3IgIT09IG51bGwgP1xuICAgICAgICAgICAgeWllbGQgYmFpbG91dCh0aGlzLmVycm9yLCB0aGlzLm9mZnNldCkgOlxuICAgICAgICAgICAgeWllbGQgZW5kVGVzdE1lc3NhZ2UodGhpcywgdGhpcy5vZmZzZXQpO1xuICAgIH1cbn07XG5jb25zdCB0ZXN0ZXJMaWtlUHJvdmlkZXIgPSAoQmFzZVByb3RvID0gVGVzdGVyUHJvdG90eXBlKSA9PiAoYXNzZXJ0aW9ucywgcm91dGluZSwgb2Zmc2V0KSA9PiB7XG4gICAgY29uc3QgdGVzdENvdW50ZXIgPSBjb3VudGVyKCk7XG4gICAgY29uc3Qgd2l0aFRlc3RDb3VudGVyID0gZGVsZWdhdGVUb0NvdW50ZXIodGVzdENvdW50ZXIpO1xuICAgIGxldCBwYXNzID0gdHJ1ZTtcbiAgICByZXR1cm4gd2l0aFRlc3RDb3VudGVyKE9iamVjdC5jcmVhdGUoQmFzZVByb3RvLCB7XG4gICAgICAgIHJvdXRpbmU6IHtcbiAgICAgICAgICAgIHZhbHVlOiByb3V0aW5lXG4gICAgICAgIH0sXG4gICAgICAgIGFzc2VydGlvbnM6IHtcbiAgICAgICAgICAgIHZhbHVlOiBhc3NlcnRpb25zXG4gICAgICAgIH0sXG4gICAgICAgIG9mZnNldDoge1xuICAgICAgICAgICAgdmFsdWU6IG9mZnNldFxuICAgICAgICB9LFxuICAgICAgICBjb3VudGVyOiB7XG4gICAgICAgICAgICB2YWx1ZTogdGVzdENvdW50ZXJcbiAgICAgICAgfSxcbiAgICAgICAgbGVuZ3RoOiB7XG4gICAgICAgICAgICBnZXQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFzc2VydGlvbnMubGVuZ3RoO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBwYXNzOiB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgZ2V0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBwYXNzO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNldCh2YWwpIHtcbiAgICAgICAgICAgICAgICBwYXNzID0gdmFsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSkpO1xufTtcbmNvbnN0IHRlc3RlckZhY3RvcnkgPSB0ZXN0ZXJMaWtlUHJvdmlkZXIoKTtcblxuY29uc3QgdGVzdGVyID0gKGRlc2NyaXB0aW9uLCBzcGVjLCB7IG9mZnNldCA9IDAsIHNraXAgPSBmYWxzZSwgcnVuT25seSA9IGZhbHNlIH0gPSBkZWZhdWx0VGVzdE9wdGlvbnMpID0+IHtcbiAgICBsZXQgZXhlY3V0aW9uVGltZSA9IDA7XG4gICAgbGV0IGVycm9yID0gbnVsbDtcbiAgICBsZXQgZG9uZSA9IGZhbHNlO1xuICAgIGNvbnN0IGFzc2VydGlvbnMgPSBbXTtcbiAgICBjb25zdCBjb2xsZWN0ID0gaXRlbSA9PiB7XG4gICAgICAgIGlmIChkb25lKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHRlc3QgXCIke2Rlc2NyaXB0aW9ufVwiIFxudHJpZWQgdG8gY29sbGVjdCBhbiBhc3NlcnRpb24gYWZ0ZXIgaXQgaGFzIHJ1biB0byBpdHMgY29tcGxldGlvbi4gXG5Zb3UgbWlnaHQgaGF2ZSBmb3Jnb3R0ZW4gdG8gd2FpdCBmb3IgYW4gYXN5bmNocm9ub3VzIHRhc2sgdG8gY29tcGxldGVcbi0tLS0tLVxuJHtzcGVjLnRvU3RyaW5nKCl9XG5gKTtcbiAgICAgICAgfVxuICAgICAgICBhc3NlcnRpb25zLnB1c2goaXRlbSk7XG4gICAgfTtcbiAgICBjb25zdCBzcGVjRnVuY3Rpb24gPSBza2lwID09PSB0cnVlID8gbm9vcCA6IGZ1bmN0aW9uIHpvcmFfc3BlY19mbigpIHtcbiAgICAgICAgcmV0dXJuIHNwZWMoYXNzZXJ0KGNvbGxlY3QsIG9mZnNldCwgcnVuT25seSkpO1xuICAgIH07XG4gICAgY29uc3QgdGVzdFJvdXRpbmUgPSAoYXN5bmMgZnVuY3Rpb24gKCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3Qgc3RhcnQgPSBEYXRlLm5vdygpO1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgc3BlY0Z1bmN0aW9uKCk7XG4gICAgICAgICAgICBleGVjdXRpb25UaW1lID0gRGF0ZS5ub3coKSAtIHN0YXJ0O1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgZXJyb3IgPSBlO1xuICAgICAgICB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgZG9uZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9KSgpO1xuICAgIHJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0ZXN0ZXJGYWN0b3J5KGFzc2VydGlvbnMsIHRlc3RSb3V0aW5lLCBvZmZzZXQpLCB7XG4gICAgICAgIGVycm9yOiB7XG4gICAgICAgICAgICBnZXQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVycm9yO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNldCh2YWwpIHtcbiAgICAgICAgICAgICAgICBlcnJvciA9IHZhbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZXhlY3V0aW9uVGltZToge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGdldCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZXhlY3V0aW9uVGltZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgc2tpcDoge1xuICAgICAgICAgICAgdmFsdWU6IHNraXBcbiAgICAgICAgfSxcbiAgICAgICAgZGVzY3JpcHRpb246IHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogZGVzY3JpcHRpb25cbiAgICAgICAgfVxuICAgIH0pO1xufTtcblxuLy8gZG8gbm90IGVkaXQgLmpzIGZpbGVzIGRpcmVjdGx5IC0gZWRpdCBzcmMvaW5kZXguanN0XG5cblxuXG52YXIgZmFzdERlZXBFcXVhbCA9IGZ1bmN0aW9uIGVxdWFsKGEsIGIpIHtcbiAgaWYgKGEgPT09IGIpIHJldHVybiB0cnVlO1xuXG4gIGlmIChhICYmIGIgJiYgdHlwZW9mIGEgPT0gJ29iamVjdCcgJiYgdHlwZW9mIGIgPT0gJ29iamVjdCcpIHtcbiAgICBpZiAoYS5jb25zdHJ1Y3RvciAhPT0gYi5jb25zdHJ1Y3RvcikgcmV0dXJuIGZhbHNlO1xuXG4gICAgdmFyIGxlbmd0aCwgaSwga2V5cztcbiAgICBpZiAoQXJyYXkuaXNBcnJheShhKSkge1xuICAgICAgbGVuZ3RoID0gYS5sZW5ndGg7XG4gICAgICBpZiAobGVuZ3RoICE9IGIubGVuZ3RoKSByZXR1cm4gZmFsc2U7XG4gICAgICBmb3IgKGkgPSBsZW5ndGg7IGktLSAhPT0gMDspXG4gICAgICAgIGlmICghZXF1YWwoYVtpXSwgYltpXSkpIHJldHVybiBmYWxzZTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuXG5cbiAgICBpZiAoYS5jb25zdHJ1Y3RvciA9PT0gUmVnRXhwKSByZXR1cm4gYS5zb3VyY2UgPT09IGIuc291cmNlICYmIGEuZmxhZ3MgPT09IGIuZmxhZ3M7XG4gICAgaWYgKGEudmFsdWVPZiAhPT0gT2JqZWN0LnByb3RvdHlwZS52YWx1ZU9mKSByZXR1cm4gYS52YWx1ZU9mKCkgPT09IGIudmFsdWVPZigpO1xuICAgIGlmIChhLnRvU3RyaW5nICE9PSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nKSByZXR1cm4gYS50b1N0cmluZygpID09PSBiLnRvU3RyaW5nKCk7XG5cbiAgICBrZXlzID0gT2JqZWN0LmtleXMoYSk7XG4gICAgbGVuZ3RoID0ga2V5cy5sZW5ndGg7XG4gICAgaWYgKGxlbmd0aCAhPT0gT2JqZWN0LmtleXMoYikubGVuZ3RoKSByZXR1cm4gZmFsc2U7XG5cbiAgICBmb3IgKGkgPSBsZW5ndGg7IGktLSAhPT0gMDspXG4gICAgICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiLCBrZXlzW2ldKSkgcmV0dXJuIGZhbHNlO1xuXG4gICAgZm9yIChpID0gbGVuZ3RoOyBpLS0gIT09IDA7KSB7XG4gICAgICB2YXIga2V5ID0ga2V5c1tpXTtcblxuICAgICAgaWYgKCFlcXVhbChhW2tleV0sIGJba2V5XSkpIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8vIHRydWUgaWYgYm90aCBOYU4sIGZhbHNlIG90aGVyd2lzZVxuICByZXR1cm4gYSE9PWEgJiYgYiE9PWI7XG59O1xuXG5jb25zdCBpc0Fzc2VydGlvblJlc3VsdCA9IChyZXN1bHQpID0+IHtcbiAgICByZXR1cm4gJ29wZXJhdG9yJyBpbiByZXN1bHQ7XG59O1xuY29uc3Qgc3BlY0ZuUmVnZXhwID0gL3pvcmFfc3BlY19mbi87XG5jb25zdCB6b3JhSW50ZXJuYWwgPSAvem9yYVxcL2Rpc3RcXC9idW5kbGUvO1xuY29uc3QgZmlsdGVyU3RhY2tMaW5lID0gbCA9PiAobCAmJiAhem9yYUludGVybmFsLnRlc3QobCkgJiYgIWwuc3RhcnRzV2l0aCgnRXJyb3InKSB8fCBzcGVjRm5SZWdleHAudGVzdChsKSk7XG5jb25zdCBnZXRBc3NlcnRpb25Mb2NhdGlvbiA9ICgpID0+IHtcbiAgICBjb25zdCBlcnIgPSBuZXcgRXJyb3IoKTtcbiAgICBjb25zdCBzdGFjayA9IChlcnIuc3RhY2sgfHwgJycpXG4gICAgICAgIC5zcGxpdCgnXFxuJylcbiAgICAgICAgLm1hcChsID0+IGwudHJpbSgpKVxuICAgICAgICAuZmlsdGVyKGZpbHRlclN0YWNrTGluZSk7XG4gICAgY29uc3QgdXNlckxhbmRJbmRleCA9IHN0YWNrLmZpbmRJbmRleChsID0+IHNwZWNGblJlZ2V4cC50ZXN0KGwpKTtcbiAgICBjb25zdCBzdGFja2xpbmUgPSB1c2VyTGFuZEluZGV4ID49IDEgPyBzdGFja1t1c2VyTGFuZEluZGV4IC0gMV0gOiAoc3RhY2tbMF0gfHwgJ04vQScpO1xuICAgIHJldHVybiBzdGFja2xpbmVcbiAgICAgICAgLnJlcGxhY2UoL15hdHxeQC8sICcnKTtcbn07XG5jb25zdCBhc3NlcnRNZXRob2RIb29rID0gKGZuKSA9PiBmdW5jdGlvbiAoLi4uYXJncykge1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICByZXR1cm4gdGhpcy5jb2xsZWN0KGZuKC4uLmFyZ3MpKTtcbn07XG5jb25zdCBhbGlhc01ldGhvZEhvb2sgPSAobWV0aG9kTmFtZSkgPT4gZnVuY3Rpb24gKC4uLmFyZ3MpIHtcbiAgICByZXR1cm4gdGhpc1ttZXRob2ROYW1lXSguLi5hcmdzKTtcbn07XG5jb25zdCB1bmJpbmRBc3NlcnQgPSAodGFyZ2V0KSA9PiBPYmplY3QuZnJvbUVudHJpZXMoWy4uLk9iamVjdC5rZXlzKEFzc2VydFByb3RvdHlwZSksICdjb2xsZWN0J11cbiAgICAubWFwKChtZXRob2ROYW1lKSA9PiBbbWV0aG9kTmFtZSwgKC4uLmFyZ3MpID0+IHRhcmdldFttZXRob2ROYW1lXSguLi5hcmdzKV0pKTtcbmNvbnN0IEFzc2VydFByb3RvdHlwZSA9IHtcbiAgICBlcXVhbDogYXNzZXJ0TWV0aG9kSG9vaygoYWN0dWFsLCBleHBlY3RlZCwgZGVzY3JpcHRpb24gPSAnc2hvdWxkIGJlIGVxdWl2YWxlbnQnKSA9PiAoe1xuICAgICAgICBwYXNzOiBmYXN0RGVlcEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQpLFxuICAgICAgICBhY3R1YWwsXG4gICAgICAgIGV4cGVjdGVkLFxuICAgICAgICBkZXNjcmlwdGlvbixcbiAgICAgICAgb3BlcmF0b3I6IFwiZXF1YWxcIiAvKiBFUVVBTCAqL1xuICAgIH0pKSxcbiAgICBlcXVhbHM6IGFsaWFzTWV0aG9kSG9vaygnZXF1YWwnKSxcbiAgICBlcTogYWxpYXNNZXRob2RIb29rKCdlcXVhbCcpLFxuICAgIGRlZXBFcXVhbDogYWxpYXNNZXRob2RIb29rKCdlcXVhbCcpLFxuICAgIHNhbWU6IGFsaWFzTWV0aG9kSG9vaygnZXF1YWwnKSxcbiAgICBub3RFcXVhbDogYXNzZXJ0TWV0aG9kSG9vaygoYWN0dWFsLCBleHBlY3RlZCwgZGVzY3JpcHRpb24gPSAnc2hvdWxkIG5vdCBiZSBlcXVpdmFsZW50JykgPT4gKHtcbiAgICAgICAgcGFzczogIWZhc3REZWVwRXF1YWwoYWN0dWFsLCBleHBlY3RlZCksXG4gICAgICAgIGFjdHVhbCxcbiAgICAgICAgZXhwZWN0ZWQsXG4gICAgICAgIGRlc2NyaXB0aW9uLFxuICAgICAgICBvcGVyYXRvcjogXCJub3RFcXVhbFwiIC8qIE5PVF9FUVVBTCAqL1xuICAgIH0pKSxcbiAgICBub3RFcXVhbHM6IGFsaWFzTWV0aG9kSG9vaygnbm90RXF1YWwnKSxcbiAgICBub3RFcTogYWxpYXNNZXRob2RIb29rKCdub3RFcXVhbCcpLFxuICAgIG5vdERlZXBFcXVhbDogYWxpYXNNZXRob2RIb29rKCdub3RFcXVhbCcpLFxuICAgIGlzOiBhc3NlcnRNZXRob2RIb29rKChhY3R1YWwsIGV4cGVjdGVkLCBkZXNjcmlwdGlvbiA9ICdzaG91bGQgYmUgdGhlIHNhbWUnKSA9PiAoe1xuICAgICAgICBwYXNzOiBPYmplY3QuaXMoYWN0dWFsLCBleHBlY3RlZCksXG4gICAgICAgIGFjdHVhbCxcbiAgICAgICAgZXhwZWN0ZWQsXG4gICAgICAgIGRlc2NyaXB0aW9uLFxuICAgICAgICBvcGVyYXRvcjogXCJpc1wiIC8qIElTICovXG4gICAgfSkpLFxuICAgIGlzTm90OiBhc3NlcnRNZXRob2RIb29rKChhY3R1YWwsIGV4cGVjdGVkLCBkZXNjcmlwdGlvbiA9ICdzaG91bGQgbm90IGJlIHRoZSBzYW1lJykgPT4gKHtcbiAgICAgICAgcGFzczogIU9iamVjdC5pcyhhY3R1YWwsIGV4cGVjdGVkKSxcbiAgICAgICAgYWN0dWFsLFxuICAgICAgICBleHBlY3RlZCxcbiAgICAgICAgZGVzY3JpcHRpb24sXG4gICAgICAgIG9wZXJhdG9yOiBcImlzTm90XCIgLyogSVNfTk9UICovXG4gICAgfSkpLFxuICAgIG5vdFNhbWU6IGFsaWFzTWV0aG9kSG9vaygnaXNOb3QnKSxcbiAgICBvazogYXNzZXJ0TWV0aG9kSG9vaygoYWN0dWFsLCBkZXNjcmlwdGlvbiA9ICdzaG91bGQgYmUgdHJ1dGh5JykgPT4gKHtcbiAgICAgICAgcGFzczogQm9vbGVhbihhY3R1YWwpLFxuICAgICAgICBhY3R1YWwsXG4gICAgICAgIGV4cGVjdGVkOiAndHJ1dGh5IHZhbHVlJyxcbiAgICAgICAgZGVzY3JpcHRpb24sXG4gICAgICAgIG9wZXJhdG9yOiBcIm9rXCIgLyogT0sgKi9cbiAgICB9KSksXG4gICAgdHJ1dGh5OiBhbGlhc01ldGhvZEhvb2soJ29rJyksXG4gICAgbm90T2s6IGFzc2VydE1ldGhvZEhvb2soKGFjdHVhbCwgZGVzY3JpcHRpb24gPSAnc2hvdWxkIGJlIGZhbHN5JykgPT4gKHtcbiAgICAgICAgcGFzczogIUJvb2xlYW4oYWN0dWFsKSxcbiAgICAgICAgYWN0dWFsLFxuICAgICAgICBleHBlY3RlZDogJ2ZhbHN5IHZhbHVlJyxcbiAgICAgICAgZGVzY3JpcHRpb24sXG4gICAgICAgIG9wZXJhdG9yOiBcIm5vdE9rXCIgLyogTk9UX09LICovXG4gICAgfSkpLFxuICAgIGZhbHN5OiBhbGlhc01ldGhvZEhvb2soJ25vdE9rJyksXG4gICAgZmFpbDogYXNzZXJ0TWV0aG9kSG9vaygoZGVzY3JpcHRpb24gPSAnZmFpbCBjYWxsZWQnKSA9PiAoe1xuICAgICAgICBwYXNzOiBmYWxzZSxcbiAgICAgICAgYWN0dWFsOiAnZmFpbCBjYWxsZWQnLFxuICAgICAgICBleHBlY3RlZDogJ2ZhaWwgbm90IGNhbGxlZCcsXG4gICAgICAgIGRlc2NyaXB0aW9uLFxuICAgICAgICBvcGVyYXRvcjogXCJmYWlsXCIgLyogRkFJTCAqL1xuICAgIH0pKSxcbiAgICB0aHJvd3M6IGFzc2VydE1ldGhvZEhvb2soKGZ1bmMsIGV4cGVjdGVkLCBkZXNjcmlwdGlvbikgPT4ge1xuICAgICAgICBsZXQgY2F1Z2h0O1xuICAgICAgICBsZXQgcGFzcztcbiAgICAgICAgbGV0IGFjdHVhbDtcbiAgICAgICAgaWYgKHR5cGVvZiBleHBlY3RlZCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIFtleHBlY3RlZCwgZGVzY3JpcHRpb25dID0gW2Rlc2NyaXB0aW9uLCBleHBlY3RlZF07XG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGZ1bmMoKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBjYXVnaHQgPSB7IGVycm9yOiBlcnIgfTtcbiAgICAgICAgfVxuICAgICAgICBwYXNzID0gY2F1Z2h0ICE9PSB1bmRlZmluZWQ7XG4gICAgICAgIGFjdHVhbCA9IGNhdWdodCAmJiBjYXVnaHQuZXJyb3I7XG4gICAgICAgIGlmIChleHBlY3RlZCBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuICAgICAgICAgICAgcGFzcyA9IGV4cGVjdGVkLnRlc3QoYWN0dWFsKSB8fCBleHBlY3RlZC50ZXN0KGFjdHVhbCAmJiBhY3R1YWwubWVzc2FnZSk7XG4gICAgICAgICAgICBhY3R1YWwgPSBhY3R1YWwgJiYgYWN0dWFsLm1lc3NhZ2UgfHwgYWN0dWFsO1xuICAgICAgICAgICAgZXhwZWN0ZWQgPSBTdHJpbmcoZXhwZWN0ZWQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiBleHBlY3RlZCA9PT0gJ2Z1bmN0aW9uJyAmJiBjYXVnaHQpIHtcbiAgICAgICAgICAgIHBhc3MgPSBhY3R1YWwgaW5zdGFuY2VvZiBleHBlY3RlZDtcbiAgICAgICAgICAgIGFjdHVhbCA9IGFjdHVhbC5jb25zdHJ1Y3RvcjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcGFzcyxcbiAgICAgICAgICAgIGFjdHVhbCxcbiAgICAgICAgICAgIGV4cGVjdGVkLFxuICAgICAgICAgICAgZGVzY3JpcHRpb246IGRlc2NyaXB0aW9uIHx8ICdzaG91bGQgdGhyb3cnLFxuICAgICAgICAgICAgb3BlcmF0b3I6IFwidGhyb3dzXCIgLyogVEhST1dTICovXG4gICAgICAgIH07XG4gICAgfSksXG4gICAgZG9lc05vdFRocm93OiBhc3NlcnRNZXRob2RIb29rKChmdW5jLCBleHBlY3RlZCwgZGVzY3JpcHRpb24pID0+IHtcbiAgICAgICAgbGV0IGNhdWdodDtcbiAgICAgICAgaWYgKHR5cGVvZiBleHBlY3RlZCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIFtleHBlY3RlZCwgZGVzY3JpcHRpb25dID0gW2Rlc2NyaXB0aW9uLCBleHBlY3RlZF07XG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGZ1bmMoKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBjYXVnaHQgPSB7IGVycm9yOiBlcnIgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcGFzczogY2F1Z2h0ID09PSB1bmRlZmluZWQsXG4gICAgICAgICAgICBleHBlY3RlZDogJ25vIHRocm93biBlcnJvcicsXG4gICAgICAgICAgICBhY3R1YWw6IGNhdWdodCAmJiBjYXVnaHQuZXJyb3IsXG4gICAgICAgICAgICBvcGVyYXRvcjogXCJkb2VzTm90VGhyb3dcIiAvKiBET0VTX05PVF9USFJPVyAqLyxcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBkZXNjcmlwdGlvbiB8fCAnc2hvdWxkIG5vdCB0aHJvdydcbiAgICAgICAgfTtcbiAgICB9KVxufTtcbmNvbnN0IGFzc2VydCA9IChjb2xsZWN0LCBvZmZzZXQsIHJ1bk9ubHkgPSBmYWxzZSkgPT4ge1xuICAgIGNvbnN0IGFjdHVhbENvbGxlY3QgPSBpdGVtID0+IHtcbiAgICAgICAgaWYgKCFpdGVtLnBhc3MpIHtcbiAgICAgICAgICAgIGl0ZW0uYXQgPSBnZXRBc3NlcnRpb25Mb2NhdGlvbigpO1xuICAgICAgICB9XG4gICAgICAgIGNvbGxlY3QoaXRlbSk7XG4gICAgICAgIHJldHVybiBpdGVtO1xuICAgIH07XG4gICAgY29uc3QgdGVzdCA9IChkZXNjcmlwdGlvbiwgc3BlYywgb3B0cykgPT4ge1xuICAgICAgICBjb25zdCBvcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgZGVmYXVsdFRlc3RPcHRpb25zLCBvcHRzLCB7IG9mZnNldDogb2Zmc2V0ICsgMSwgcnVuT25seSB9KTtcbiAgICAgICAgY29uc3Qgc3ViVGVzdCA9IHRlc3RlcihkZXNjcmlwdGlvbiwgc3BlYywgb3B0aW9ucyk7XG4gICAgICAgIGNvbGxlY3Qoc3ViVGVzdCk7XG4gICAgICAgIHJldHVybiBzdWJUZXN0LnJvdXRpbmU7XG4gICAgfTtcbiAgICBjb25zdCBza2lwID0gKGRlc2NyaXB0aW9uLCBzcGVjLCBvcHRzKSA9PiB7XG4gICAgICAgIHJldHVybiB0ZXN0KGRlc2NyaXB0aW9uLCBzcGVjLCBPYmplY3QuYXNzaWduKHt9LCBvcHRzLCB7IHNraXA6IHRydWUgfSkpO1xuICAgIH07XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIHJldHVybiB7XG4gICAgICAgIC4uLnVuYmluZEFzc2VydChPYmplY3QuY3JlYXRlKEFzc2VydFByb3RvdHlwZSwgeyBjb2xsZWN0OiB7IHZhbHVlOiBhY3R1YWxDb2xsZWN0IH0gfSkpLFxuICAgICAgICB0ZXN0KGRlc2NyaXB0aW9uLCBzcGVjLCBvcHRzID0ge30pIHtcbiAgICAgICAgICAgIGlmIChydW5Pbmx5KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNraXAoZGVzY3JpcHRpb24sIHNwZWMsIG9wdHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRlc3QoZGVzY3JpcHRpb24sIHNwZWMsIG9wdHMpO1xuICAgICAgICB9LFxuICAgICAgICBza2lwKGRlc2NyaXB0aW9uLCBzcGVjID0gbm9vcCwgb3B0cyA9IHt9KSB7XG4gICAgICAgICAgICByZXR1cm4gc2tpcChkZXNjcmlwdGlvbiwgc3BlYywgb3B0cyk7XG4gICAgICAgIH0sXG4gICAgICAgIG9ubHkoZGVzY3JpcHRpb24sIHNwZWMsIG9wdHMgPSB7fSkge1xuICAgICAgICAgICAgY29uc3Qgc3BlY0ZuID0gcnVuT25seSA9PT0gZmFsc2UgPyBfID0+IHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENhbiBub3QgdXNlIFwib25seVwiIG1ldGhvZCB3aGVuIG5vdCBpbiBydW4gb25seSBtb2RlYCk7XG4gICAgICAgICAgICB9IDogc3BlYztcbiAgICAgICAgICAgIHJldHVybiB0ZXN0KGRlc2NyaXB0aW9uLCBzcGVjRm4sIG9wdHMpO1xuICAgICAgICB9XG4gICAgfTtcbn07XG5cbmNvbnN0IG1hcCA9IChmbikgPT4gYXN5bmMgZnVuY3Rpb24qIChzdHJlYW0pIHtcbiAgICBmb3IgYXdhaXQgKGNvbnN0IG0gb2Ygc3RyZWFtKSB7XG4gICAgICAgIHlpZWxkIGZuKG0pO1xuICAgIH1cbn07XG4vLyAhIGl0IG11dGF0ZXMgdGhlIHVuZGVybHlpbmcgc3RydWN0dXJlIHlldCBpdCBpcyBtb3JlIGVmZmljaWVudCByZWdhcmRpbmcgcGVyZm9ybWFuY2VzXG5jb25zdCBmbGF0dGVuID0gbWFwKChtKSA9PiB7XG4gICAgbS5vZmZzZXQgPSAwO1xuICAgIHJldHVybiBtO1xufSk7XG5jb25zdCBpc0Fzc2VydGlvblJlc3VsdCQxID0gKHJlc3VsdCkgPT4ge1xuICAgIHJldHVybiAnb3BlcmF0b3InIGluIHJlc3VsdDtcbn07XG5jb25zdCBzdHJpbmdpZnlTeW1ib2wgPSAoa2V5LCB2YWx1ZSkgPT4ge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzeW1ib2wnKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZS50b1N0cmluZygpO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG59O1xuXG4vLyBAdHMtaWdub3JlXG5jb25zdCBmbGF0RGlhZ25vc3RpYyA9ICh7IHBhc3MsIGRlc2NyaXB0aW9uLCAuLi5yZXN0IH0pID0+IHJlc3Q7XG5jb25zdCBUYXAgPSB7XG4gICAgcHJpbnQobWVzc2FnZSwgb2Zmc2V0ID0gMCkge1xuICAgICAgICB0aGlzLmxvZyhtZXNzYWdlLnBhZFN0YXJ0KG1lc3NhZ2UubGVuZ3RoICsgKG9mZnNldCAqIDQpKSk7IC8vIDQgd2hpdGUgc3BhY2UgdXNlZCBhcyBpbmRlbnQgKHNlZSB0YXAtcGFyc2VyKVxuICAgIH0sXG4gICAgcHJpbnRZQU1MKG9iaiwgb2Zmc2V0ID0gMCkge1xuICAgICAgICBjb25zdCBZQU1MT2Zmc2V0ID0gb2Zmc2V0ICsgMC41O1xuICAgICAgICB0aGlzLnByaW50KCctLS0nLCBZQU1MT2Zmc2V0KTtcbiAgICAgICAgZm9yIChjb25zdCBbcHJvcCwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKG9iaikpIHtcbiAgICAgICAgICAgIHRoaXMucHJpbnQoYCR7cHJvcH06ICR7SlNPTi5zdHJpbmdpZnkodmFsdWUsIHN0cmluZ2lmeVN5bWJvbCl9YCwgWUFNTE9mZnNldCArIDAuNSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wcmludCgnLi4uJywgWUFNTE9mZnNldCk7XG4gICAgfSxcbiAgICBwcmludENvbW1lbnQoY29tbWVudCwgb2Zmc2V0ID0gMCkge1xuICAgICAgICB0aGlzLnByaW50KGAjICR7Y29tbWVudH1gLCBvZmZzZXQpO1xuICAgIH0sXG4gICAgcHJpbnRCYWlsT3V0KG1lc3NhZ2UpIHtcbiAgICAgICAgdGhpcy5wcmludCgnQmFpbCBvdXQhIFVuaGFuZGxlZCBlcnJvci4nKTtcbiAgICB9LFxuICAgIHByaW50VGVzdFN0YXJ0KG1lc3NhZ2UpIHtcbiAgICAgICAgY29uc3QgeyBkYXRhOiB7IGRlc2NyaXB0aW9uIH0sIG9mZnNldCB9ID0gbWVzc2FnZTtcbiAgICAgICAgdGhpcy5wcmludENvbW1lbnQoZGVzY3JpcHRpb24sIG9mZnNldCk7XG4gICAgfSxcbiAgICBwcmludFRlc3RFbmQobWVzc2FnZSkge1xuICAgICAgICAvLyBkbyBub3RoaW5nXG4gICAgfSxcbiAgICBwcmludEFzc2VydGlvbihtZXNzYWdlKSB7XG4gICAgICAgIGNvbnN0IHsgZGF0YSwgb2Zmc2V0IH0gPSBtZXNzYWdlO1xuICAgICAgICBjb25zdCB7IHBhc3MsIGRlc2NyaXB0aW9uIH0gPSBkYXRhO1xuICAgICAgICBjb25zdCBsYWJlbCA9IHBhc3MgPT09IHRydWUgPyAnb2snIDogJ25vdCBvayc7XG4gICAgICAgIGlmIChpc0Fzc2VydGlvblJlc3VsdCQxKGRhdGEpKSB7XG4gICAgICAgICAgICBjb25zdCBpZCA9IHRoaXMubmV4dElkKCk7XG4gICAgICAgICAgICB0aGlzLnByaW50KGAke2xhYmVsfSAke2lkfSAtICR7ZGVzY3JpcHRpb259YCwgb2Zmc2V0KTtcbiAgICAgICAgICAgIGlmIChwYXNzID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIHRoaXMucHJpbnRZQU1MKGZsYXREaWFnbm9zdGljKGRhdGEpLCBvZmZzZXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGRhdGEuc2tpcCkge1xuICAgICAgICAgICAgY29uc3QgaWQgPSB0aGlzLm5leHRJZCgpO1xuICAgICAgICAgICAgdGhpcy5wcmludChgJHtwYXNzID8gJ29rJyA6ICdub3Qgb2snfSAke2lkfSAtICR7ZGVzY3JpcHRpb259ICMgU0tJUGAsIG9mZnNldCk7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIHByaW50U3VtbWFyeShlbmRNZXNzYWdlKSB7XG4gICAgICAgIHRoaXMucHJpbnQoJycsIDApO1xuICAgICAgICB0aGlzLnByaW50Q29tbWVudChlbmRNZXNzYWdlLmRhdGEucGFzcyA/ICdvaycgOiAnbm90IG9rJywgMCk7XG4gICAgICAgIHRoaXMucHJpbnRDb21tZW50KGBzdWNjZXNzOiAke2VuZE1lc3NhZ2UuZGF0YS5zdWNjZXNzQ291bnR9YCwgMCk7XG4gICAgICAgIHRoaXMucHJpbnRDb21tZW50KGBza2lwcGVkOiAke2VuZE1lc3NhZ2UuZGF0YS5za2lwQ291bnR9YCwgMCk7XG4gICAgICAgIHRoaXMucHJpbnRDb21tZW50KGBmYWlsdXJlOiAke2VuZE1lc3NhZ2UuZGF0YS5mYWlsdXJlQ291bnR9YCwgMCk7XG4gICAgfSxcbiAgICBhc3luYyByZXBvcnQoc3RyZWFtKSB7XG4gICAgICAgIGNvbnN0IHNyYyA9IGZsYXR0ZW4oc3RyZWFtKTtcbiAgICAgICAgbGV0IGxhc3RNZXNzYWdlID0gbnVsbDtcbiAgICAgICAgdGhpcy5wcmludCgnVEFQIHZlcnNpb24gMTMnKTtcbiAgICAgICAgZm9yIGF3YWl0IChjb25zdCBtZXNzYWdlIG9mIHNyYykge1xuICAgICAgICAgICAgbGFzdE1lc3NhZ2UgPSBtZXNzYWdlO1xuICAgICAgICAgICAgc3dpdGNoIChtZXNzYWdlLnR5cGUpIHtcbiAgICAgICAgICAgICAgICBjYXNlIFwiVEVTVF9TVEFSVFwiIC8qIFRFU1RfU1RBUlQgKi86XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucHJpbnRUZXN0U3RhcnQobWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJBU1NFUlRJT05cIiAvKiBBU1NFUlRJT04gKi86XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucHJpbnRBc3NlcnRpb24obWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJCQUlMX09VVFwiIC8qIEJBSUxfT1VUICovOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLnByaW50QmFpbE91dChtZXNzYWdlKTtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbWVzc2FnZS5kYXRhO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMucHJpbnQoYDEuLiR7bGFzdE1lc3NhZ2UuZGF0YS5jb3VudH1gLCAwKTtcbiAgICAgICAgdGhpcy5wcmludFN1bW1hcnkobGFzdE1lc3NhZ2UpO1xuICAgIH1cbn07XG5jb25zdCBmYWN0b3J5ID0gKGxvZykgPT4ge1xuICAgIGxldCBpID0gMDtcbiAgICByZXR1cm4gT2JqZWN0LmNyZWF0ZShUYXAsIHtcbiAgICAgICAgbmV4dElkOiB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6ICgpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKytpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBsb2c6IHsgdmFsdWU6IGxvZyB9XG4gICAgfSk7XG59O1xuXG5jb25zdCBpbmRlbnRlZERpYWdub3N0aWMgPSAoeyBleHBlY3RlZCwgcGFzcywgZGVzY3JpcHRpb24sIGFjdHVhbCwgb3BlcmF0b3IsIGF0ID0gJ04vQScsIC4uLnJlc3QgfSkgPT4gKHtcbiAgICB3YW50ZWQ6IGV4cGVjdGVkLFxuICAgIGZvdW5kOiBhY3R1YWwsXG4gICAgYXQsXG4gICAgb3BlcmF0b3IsXG4gICAgLi4ucmVzdFxufSk7XG5jb25zdCBpZCA9IGZ1bmN0aW9uKiAoKSB7XG4gICAgbGV0IGkgPSAwO1xuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIHlpZWxkICsraTtcbiAgICB9XG59O1xuY29uc3QgaWRHZW4gPSAoKSA9PiB7XG4gICAgbGV0IHN0YWNrID0gW2lkKCldO1xuICAgIHJldHVybiB7XG4gICAgICAgIFtTeW1ib2wuaXRlcmF0b3JdKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG4gICAgICAgIG5leHQoKSB7XG4gICAgICAgICAgICByZXR1cm4gc3RhY2tbMF0ubmV4dCgpO1xuICAgICAgICB9LFxuICAgICAgICBmb3JrKCkge1xuICAgICAgICAgICAgc3RhY2sudW5zaGlmdChpZCgpKTtcbiAgICAgICAgfSxcbiAgICAgICAgbWVyZ2UoKSB7XG4gICAgICAgICAgICBzdGFjay5zaGlmdCgpO1xuICAgICAgICB9XG4gICAgfTtcbn07XG5jb25zdCBJbmRlbnRlZFRhcCA9IE9iamVjdC5hc3NpZ24oe30sIFRhcCwge1xuICAgIHByaW50VGVzdFN0YXJ0KG1lc3NhZ2UpIHtcbiAgICAgICAgY29uc3QgeyBkYXRhOiB7IGRlc2NyaXB0aW9uIH0sIG9mZnNldCB9ID0gbWVzc2FnZTtcbiAgICAgICAgdGhpcy5wcmludENvbW1lbnQoYFN1YnRlc3Q6ICR7ZGVzY3JpcHRpb259YCwgb2Zmc2V0KTtcbiAgICB9LFxuICAgIHByaW50QXNzZXJ0aW9uKG1lc3NhZ2UpIHtcbiAgICAgICAgY29uc3QgeyBkYXRhLCBvZmZzZXQgfSA9IG1lc3NhZ2U7XG4gICAgICAgIGNvbnN0IHsgcGFzcywgZGVzY3JpcHRpb24gfSA9IGRhdGE7XG4gICAgICAgIGNvbnN0IGxhYmVsID0gcGFzcyA9PT0gdHJ1ZSA/ICdvaycgOiAnbm90IG9rJztcbiAgICAgICAgY29uc3QgaWQgPSB0aGlzLm5leHRJZCgpO1xuICAgICAgICBpZiAoaXNBc3NlcnRpb25SZXN1bHQkMShkYXRhKSkge1xuICAgICAgICAgICAgdGhpcy5wcmludChgJHtsYWJlbH0gJHtpZH0gLSAke2Rlc2NyaXB0aW9ufWAsIG9mZnNldCk7XG4gICAgICAgICAgICBpZiAocGFzcyA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnByaW50WUFNTChpbmRlbnRlZERpYWdub3N0aWMoZGF0YSksIG9mZnNldCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBjb21tZW50ID0gZGF0YS5za2lwID09PSB0cnVlID8gJ1NLSVAnIDogYCR7ZGF0YS5leGVjdXRpb25UaW1lfW1zYDtcbiAgICAgICAgICAgIHRoaXMucHJpbnQoYCR7cGFzcyA/ICdvaycgOiAnbm90IG9rJ30gJHtpZH0gLSAke2Rlc2NyaXB0aW9ufSAjICR7Y29tbWVudH1gLCBtZXNzYWdlLm9mZnNldCk7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIHByaW50VGVzdEVuZChtZXNzYWdlKSB7XG4gICAgICAgIGNvbnN0IGxlbmd0aCA9IG1lc3NhZ2UuZGF0YS5sZW5ndGg7XG4gICAgICAgIGNvbnN0IHsgb2Zmc2V0IH0gPSBtZXNzYWdlO1xuICAgICAgICB0aGlzLnByaW50KGAxLi4ke2xlbmd0aH1gLCBvZmZzZXQpO1xuICAgIH1cbn0pO1xuY29uc3QgZmFjdG9yeSQxID0gKGxvZykgPT4ge1xuICAgIGNvbnN0IGlkID0gaWRHZW4oKTtcbiAgICByZXR1cm4gT2JqZWN0LmNyZWF0ZShJbmRlbnRlZFRhcCwge1xuICAgICAgICBuZXh0SWQ6IHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogKCkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBpZC5uZXh0KCkudmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHJlcG9ydDoge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBhc3luYyBmdW5jdGlvbiAoc3RyZWFtKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wcmludCgnVEFQIHZlcnNpb24gMTMnKTtcbiAgICAgICAgICAgICAgICBsZXQgbGFzdE1lc3NhZ2UgPSBudWxsO1xuICAgICAgICAgICAgICAgIGZvciBhd2FpdCAoY29uc3QgbWVzc2FnZSBvZiBzdHJlYW0pIHtcbiAgICAgICAgICAgICAgICAgICAgbGFzdE1lc3NhZ2UgPSBtZXNzYWdlO1xuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKG1lc3NhZ2UudHlwZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcIlRFU1RfU1RBUlRcIiAvKiBURVNUX1NUQVJUICovOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkLmZvcmsoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnByaW50VGVzdFN0YXJ0KG1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcIkFTU0VSVElPTlwiIC8qIEFTU0VSVElPTiAqLzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnByaW50QXNzZXJ0aW9uKG1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcIlRFU1RfRU5EXCIgLyogVEVTVF9FTkQgKi86XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWQubWVyZ2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnByaW50VGVzdEVuZChtZXNzYWdlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJCQUlMX09VVFwiIC8qIEJBSUxfT1VUICovOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucHJpbnRCYWlsT3V0KG1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG1lc3NhZ2UuZGF0YTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLnByaW50U3VtbWFyeShsYXN0TWVzc2FnZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGxvZzogeyB2YWx1ZTogbG9nIH1cbiAgICB9KTtcbn07XG5cbmNvbnN0IHJlcG9ydCA9IChmYWN0b3J5KSA9PiAobG9nZ2VyID0gY29uc29sZSkgPT4ge1xuICAgIGNvbnN0IGxvZyA9IGxvZ2dlci5sb2cuYmluZChsb2dnZXIpO1xuICAgIHJldHVybiBhc3luYyAoc3RyZWFtKSA9PiBmYWN0b3J5KGxvZykucmVwb3J0KHN0cmVhbSk7XG59O1xuY29uc3QgdGFwUmVwb3J0ZXIgPSByZXBvcnQoZmFjdG9yeSk7XG5jb25zdCBpbmRlbnRlZFRhcFJlcG9ydGVyID0gcmVwb3J0KGZhY3RvcnkkMSk7XG5cbi8vQHRzLWlnbm9yZVxuY29uc3QgbW9jaGFUYXBMaWtlID0gaW5kZW50ZWRUYXBSZXBvcnRlcigpO1xuLy9AdHMtaWdub3JlXG5jb25zdCB0YXBlVGFwTGlrZSA9IHRhcFJlcG9ydGVyKCk7XG5cbmNvbnN0IGhhcm5lc3NGYWN0b3J5ID0gKHsgcnVuT25seSA9IGZhbHNlLCBpbmRlbnQgPSBmYWxzZSB9ID0ge1xuICAgIHJ1bk9ubHk6IGZhbHNlLFxuICAgIGluZGVudDogZmFsc2Vcbn0pID0+IHtcbiAgICBjb25zdCB0ZXN0cyA9IFtdO1xuICAgIGNvbnN0IHJvb3RPZmZzZXQgPSAwO1xuICAgIGNvbnN0IGNvbGxlY3QgPSBpdGVtID0+IHRlc3RzLnB1c2goaXRlbSk7XG4gICAgY29uc3QgYXBpID0gYXNzZXJ0KGNvbGxlY3QsIHJvb3RPZmZzZXQsIHJ1bk9ubHkpO1xuICAgIGxldCBlcnJvciA9IG51bGw7XG4gICAgY29uc3QgZmFjdG9yeSA9IHRlc3Rlckxpa2VQcm92aWRlcihPYmplY3QuYXNzaWduKGFwaSwgVGVzdGVyUHJvdG90eXBlLCB7XG4gICAgICAgIHJlcG9ydDogYXN5bmMgZnVuY3Rpb24gKHJlcG9ydGVyKSB7XG4gICAgICAgICAgICBjb25zdCByZXAgPSByZXBvcnRlciB8fCAoaW5kZW50ID8gbW9jaGFUYXBMaWtlIDogdGFwZVRhcExpa2UpO1xuICAgICAgICAgICAgcmV0dXJuIHJlcCh0aGlzKTtcbiAgICAgICAgfVxuICAgIH0pKTtcbiAgICByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoZmFjdG9yeSh0ZXN0cywgUHJvbWlzZS5yZXNvbHZlKCksIHJvb3RPZmZzZXQpLCB7XG4gICAgICAgIGVycm9yOiB7XG4gICAgICAgICAgICBnZXQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVycm9yO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNldCh2YWwpIHtcbiAgICAgICAgICAgICAgICBlcnJvciA9IHZhbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xufTtcblxuY29uc3QgZmluZENvbmZpZ3VyYXRpb25GbGFnID0gKG5hbWUpID0+IHtcbiAgICBpZiAodHlwZW9mIHByb2Nlc3MgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHJldHVybiBwcm9jZXNzLmVudltuYW1lXSA9PT0gJ3RydWUnO1xuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZiBEZW5vICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIHJldHVybiBEZW5vLmVudi5nZXQobmFtZSkgPT09ICd0cnVlJztcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIHJldHVybiBCb29sZWFuKHdpbmRvd1tuYW1lXSk7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn07XG5jb25zdCBkZWZhdWx0VGVzdEhhcm5lc3MgPSBoYXJuZXNzRmFjdG9yeSh7XG4gICAgcnVuT25seTogZmluZENvbmZpZ3VyYXRpb25GbGFnKCdSVU5fT05MWScpXG59KTtcbmxldCBhdXRvU3RhcnQgPSB0cnVlO1xubGV0IGluZGVudCA9IGZpbmRDb25maWd1cmF0aW9uRmxhZygnSU5ERU5UJyk7XG5jb25zdCByb290VGVzdCA9IGRlZmF1bHRUZXN0SGFybmVzcy50ZXN0LmJpbmQoZGVmYXVsdFRlc3RIYXJuZXNzKTtcbnJvb3RUZXN0LmluZGVudCA9ICgpID0+IHtcbiAgICBjb25zb2xlLndhcm4oJ2luZGVudCBmdW5jdGlvbiBpcyBkZXByZWNhdGVkLCB1c2UgXCJJTkRFTlRcIiBjb25maWd1cmF0aW9uIGZsYWcgaW5zdGVhZCcpO1xuICAgIGluZGVudCA9IHRydWU7XG59O1xuY29uc3QgdGVzdCA9IHJvb3RUZXN0O1xuY29uc3Qgc2tpcCA9IGRlZmF1bHRUZXN0SGFybmVzcy5za2lwLmJpbmQoZGVmYXVsdFRlc3RIYXJuZXNzKTtcbmNvbnN0IG9ubHkgPSBkZWZhdWx0VGVzdEhhcm5lc3Mub25seS5iaW5kKGRlZmF1bHRUZXN0SGFybmVzcyk7XG5yb290VGVzdC5za2lwID0gc2tpcDtcbmNvbnN0IGVxdWFsID0gZGVmYXVsdFRlc3RIYXJuZXNzLmVxdWFsLmJpbmQoZGVmYXVsdFRlc3RIYXJuZXNzKTtcbmNvbnN0IGVxdWFscyA9IGVxdWFsO1xuY29uc3QgZXEgPSBlcXVhbDtcbmNvbnN0IGRlZXBFcXVhbCA9IGVxdWFsO1xuY29uc3Qgbm90RXF1YWwgPSBkZWZhdWx0VGVzdEhhcm5lc3Mubm90RXF1YWwuYmluZChkZWZhdWx0VGVzdEhhcm5lc3MpO1xuY29uc3Qgbm90RXF1YWxzID0gbm90RXF1YWw7XG5jb25zdCBub3RFcSA9IG5vdEVxdWFsO1xuY29uc3Qgbm90RGVlcEVxdWFsID0gbm90RXF1YWw7XG5jb25zdCBpcyA9IGRlZmF1bHRUZXN0SGFybmVzcy5pcy5iaW5kKGRlZmF1bHRUZXN0SGFybmVzcyk7XG5jb25zdCBzYW1lID0gaXM7XG5jb25zdCBpc05vdCA9IGRlZmF1bHRUZXN0SGFybmVzcy5pc05vdC5iaW5kKGRlZmF1bHRUZXN0SGFybmVzcyk7XG5jb25zdCBub3RTYW1lID0gaXNOb3Q7XG5jb25zdCBvayA9IGRlZmF1bHRUZXN0SGFybmVzcy5vay5iaW5kKGRlZmF1bHRUZXN0SGFybmVzcyk7XG5jb25zdCB0cnV0aHkgPSBvaztcbmNvbnN0IG5vdE9rID0gZGVmYXVsdFRlc3RIYXJuZXNzLm5vdE9rLmJpbmQoZGVmYXVsdFRlc3RIYXJuZXNzKTtcbmNvbnN0IGZhbHN5ID0gbm90T2s7XG5jb25zdCBmYWlsID0gZGVmYXVsdFRlc3RIYXJuZXNzLmZhaWwuYmluZChkZWZhdWx0VGVzdEhhcm5lc3MpO1xuY29uc3QgdGhyb3dzID0gZGVmYXVsdFRlc3RIYXJuZXNzLnRocm93cy5iaW5kKGRlZmF1bHRUZXN0SGFybmVzcyk7XG5jb25zdCBkb2VzTm90VGhyb3cgPSBkZWZhdWx0VGVzdEhhcm5lc3MuZG9lc05vdFRocm93LmJpbmQoZGVmYXVsdFRlc3RIYXJuZXNzKTtcbmNvbnN0IGNyZWF0ZUhhcm5lc3MgPSAob3B0cyA9IHt9KSA9PiB7XG4gICAgYXV0b1N0YXJ0ID0gZmFsc2U7XG4gICAgcmV0dXJuIGhhcm5lc3NGYWN0b3J5KG9wdHMpO1xufTtcbmNvbnN0IHN0YXJ0ID0gKCkgPT4ge1xuICAgIGlmIChhdXRvU3RhcnQpIHtcbiAgICAgICAgZGVmYXVsdFRlc3RIYXJuZXNzLnJlcG9ydChpbmRlbnQgPyBtb2NoYVRhcExpa2UgOiB0YXBlVGFwTGlrZSk7XG4gICAgfVxufTtcbi8vIG9uIG5leHQgdGljayBzdGFydCByZXBvcnRpbmdcbi8vIEB0cy1pZ25vcmVcbmlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykge1xuICAgIHNldFRpbWVvdXQoc3RhcnQsIDApO1xufVxuZWxzZSB7XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdsb2FkJywgc3RhcnQpO1xufVxuXG5leHBvcnRzLkFzc2VydFByb3RvdHlwZSA9IEFzc2VydFByb3RvdHlwZTtcbmV4cG9ydHMuY3JlYXRlSGFybmVzcyA9IGNyZWF0ZUhhcm5lc3M7XG5leHBvcnRzLmRlZXBFcXVhbCA9IGRlZXBFcXVhbDtcbmV4cG9ydHMuZG9lc05vdFRocm93ID0gZG9lc05vdFRocm93O1xuZXhwb3J0cy5lcSA9IGVxO1xuZXhwb3J0cy5lcXVhbCA9IGVxdWFsO1xuZXhwb3J0cy5lcXVhbHMgPSBlcXVhbHM7XG5leHBvcnRzLmZhaWwgPSBmYWlsO1xuZXhwb3J0cy5mYWxzeSA9IGZhbHN5O1xuZXhwb3J0cy5pcyA9IGlzO1xuZXhwb3J0cy5pc05vdCA9IGlzTm90O1xuZXhwb3J0cy5tb2NoYVRhcExpa2UgPSBtb2NoYVRhcExpa2U7XG5leHBvcnRzLm5vdERlZXBFcXVhbCA9IG5vdERlZXBFcXVhbDtcbmV4cG9ydHMubm90RXEgPSBub3RFcTtcbmV4cG9ydHMubm90RXF1YWwgPSBub3RFcXVhbDtcbmV4cG9ydHMubm90RXF1YWxzID0gbm90RXF1YWxzO1xuZXhwb3J0cy5ub3RPayA9IG5vdE9rO1xuZXhwb3J0cy5ub3RTYW1lID0gbm90U2FtZTtcbmV4cG9ydHMub2sgPSBvaztcbmV4cG9ydHMub25seSA9IG9ubHk7XG5leHBvcnRzLnNhbWUgPSBzYW1lO1xuZXhwb3J0cy5za2lwID0gc2tpcDtcbmV4cG9ydHMudGFwZVRhcExpa2UgPSB0YXBlVGFwTGlrZTtcbmV4cG9ydHMudGVzdCA9IHRlc3Q7XG5leHBvcnRzLnRocm93cyA9IHRocm93cztcbmV4cG9ydHMudHJ1dGh5ID0gdHJ1dGh5O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkFycmF5QXJiaXRyYXJ5ID0gdm9pZCAwO1xuY29uc3QgU3RyZWFtXzEgPSByZXF1aXJlKFwiLi4vLi4vc3RyZWFtL1N0cmVhbVwiKTtcbmNvbnN0IHN5bWJvbHNfMSA9IHJlcXVpcmUoXCIuLi8uLi9jaGVjay9zeW1ib2xzXCIpO1xuY29uc3QgaW50ZWdlcl8xID0gcmVxdWlyZShcIi4uL2ludGVnZXJcIik7XG5jb25zdCBMYXp5SXRlcmFibGVJdGVyYXRvcl8xID0gcmVxdWlyZShcIi4uLy4uL3N0cmVhbS9MYXp5SXRlcmFibGVJdGVyYXRvclwiKTtcbmNvbnN0IEJ1aWxkQ29tcGFyZUZpbHRlcl8xID0gcmVxdWlyZShcIi4vaGVscGVycy9CdWlsZENvbXBhcmVGaWx0ZXJcIik7XG5jb25zdCBOZXh0QXJiaXRyYXJ5XzEgPSByZXF1aXJlKFwiLi4vLi4vY2hlY2svYXJiaXRyYXJ5L2RlZmluaXRpb24vTmV4dEFyYml0cmFyeVwiKTtcbmNvbnN0IENvbnZlcnRlcnNfMSA9IHJlcXVpcmUoXCIuLi8uLi9jaGVjay9hcmJpdHJhcnkvZGVmaW5pdGlvbi9Db252ZXJ0ZXJzXCIpO1xuY29uc3QgTmV4dFZhbHVlXzEgPSByZXF1aXJlKFwiLi4vLi4vY2hlY2svYXJiaXRyYXJ5L2RlZmluaXRpb24vTmV4dFZhbHVlXCIpO1xuY2xhc3MgQXJyYXlBcmJpdHJhcnkgZXh0ZW5kcyBOZXh0QXJiaXRyYXJ5XzEuTmV4dEFyYml0cmFyeSB7XG4gICAgY29uc3RydWN0b3IoYXJiLCBtaW5MZW5ndGgsIG1heExlbmd0aCwgaXNFcXVhbCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmFyYiA9IGFyYjtcbiAgICAgICAgdGhpcy5taW5MZW5ndGggPSBtaW5MZW5ndGg7XG4gICAgICAgIHRoaXMubWF4TGVuZ3RoID0gbWF4TGVuZ3RoO1xuICAgICAgICB0aGlzLmlzRXF1YWwgPSBpc0VxdWFsO1xuICAgICAgICB0aGlzLmxlbmd0aEFyYiA9IENvbnZlcnRlcnNfMS5jb252ZXJ0VG9OZXh0KGludGVnZXJfMS5pbnRlZ2VyKG1pbkxlbmd0aCwgbWF4TGVuZ3RoKSk7XG4gICAgICAgIHRoaXMucHJlRmlsdGVyID0gdGhpcy5pc0VxdWFsICE9PSB1bmRlZmluZWQgPyBCdWlsZENvbXBhcmVGaWx0ZXJfMS5idWlsZENvbXBhcmVGaWx0ZXIodGhpcy5pc0VxdWFsKSA6ICh0YWIpID0+IHRhYjtcbiAgICB9XG4gICAgc3RhdGljIG1ha2VJdENsb25lYWJsZSh2cywgc2hyaW5rYWJsZXMpIHtcbiAgICAgICAgdnNbc3ltYm9sc18xLmNsb25lTWV0aG9kXSA9ICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGNsb25lZCA9IFtdO1xuICAgICAgICAgICAgZm9yIChsZXQgaWR4ID0gMDsgaWR4ICE9PSBzaHJpbmthYmxlcy5sZW5ndGg7ICsraWR4KSB7XG4gICAgICAgICAgICAgICAgY2xvbmVkLnB1c2goc2hyaW5rYWJsZXNbaWR4XS52YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLm1ha2VJdENsb25lYWJsZShjbG9uZWQsIHNocmlua2FibGVzKTtcbiAgICAgICAgICAgIHJldHVybiBjbG9uZWQ7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB2cztcbiAgICB9XG4gICAgc3RhdGljIGNhbkFwcGVuZEl0ZW0oaXRlbXMsIG5ld0l0ZW0sIGlzRXF1YWwpIHtcbiAgICAgICAgZm9yIChsZXQgaWR4ID0gMDsgaWR4ICE9PSBpdGVtcy5sZW5ndGg7ICsraWR4KSB7XG4gICAgICAgICAgICBpZiAoaXNFcXVhbChpdGVtc1tpZHhdLnZhbHVlXywgbmV3SXRlbS52YWx1ZV8pKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBnZW5lcmF0ZU5JdGVtc05vRHVwbGljYXRlcyhOLCBtcm5nLCBiaWFzRmFjdG9ySXRlbXMpIHtcbiAgICAgICAgbGV0IG51bVNraXBwZWRJblJvdyA9IDA7XG4gICAgICAgIGNvbnN0IGl0ZW1zID0gW107XG4gICAgICAgIHdoaWxlIChpdGVtcy5sZW5ndGggPCBOICYmIG51bVNraXBwZWRJblJvdyA8IHRoaXMubWF4TGVuZ3RoKSB7XG4gICAgICAgICAgICBjb25zdCBjdXJyZW50ID0gdGhpcy5hcmIuZ2VuZXJhdGUobXJuZywgYmlhc0ZhY3Rvckl0ZW1zKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmlzRXF1YWwgPT09IHVuZGVmaW5lZCB8fCBBcnJheUFyYml0cmFyeS5jYW5BcHBlbmRJdGVtKGl0ZW1zLCBjdXJyZW50LCB0aGlzLmlzRXF1YWwpKSB7XG4gICAgICAgICAgICAgICAgbnVtU2tpcHBlZEluUm93ID0gMDtcbiAgICAgICAgICAgICAgICBpdGVtcy5wdXNoKGN1cnJlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbnVtU2tpcHBlZEluUm93ICs9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGl0ZW1zO1xuICAgIH1cbiAgICBnZW5lcmF0ZU5JdGVtcyhOLCBtcm5nLCBiaWFzRmFjdG9ySXRlbXMpIHtcbiAgICAgICAgY29uc3QgaXRlbXMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCAhPT0gTjsgKytpbmRleCkge1xuICAgICAgICAgICAgY29uc3QgY3VycmVudCA9IHRoaXMuYXJiLmdlbmVyYXRlKG1ybmcsIGJpYXNGYWN0b3JJdGVtcyk7XG4gICAgICAgICAgICBpdGVtcy5wdXNoKGN1cnJlbnQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpdGVtcztcbiAgICB9XG4gICAgd3JhcHBlcihpdGVtc1Jhdywgc2hydW5rT25jZSwgaXRlbXNSYXdMZW5ndGhDb250ZXh0KSB7XG4gICAgICAgIGNvbnN0IGl0ZW1zID0gc2hydW5rT25jZSA/IHRoaXMucHJlRmlsdGVyKGl0ZW1zUmF3KSA6IGl0ZW1zUmF3O1xuICAgICAgICBsZXQgY2xvbmVhYmxlID0gZmFsc2U7XG4gICAgICAgIGNvbnN0IHZzID0gW107XG4gICAgICAgIGNvbnN0IGl0ZW1zQ29udGV4dHMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaWR4ID0gMDsgaWR4ICE9PSBpdGVtcy5sZW5ndGg7ICsraWR4KSB7XG4gICAgICAgICAgICBjb25zdCBzID0gaXRlbXNbaWR4XTtcbiAgICAgICAgICAgIGNsb25lYWJsZSA9IGNsb25lYWJsZSB8fCBzLmhhc1RvQmVDbG9uZWQ7XG4gICAgICAgICAgICB2cy5wdXNoKHMudmFsdWUpO1xuICAgICAgICAgICAgaXRlbXNDb250ZXh0cy5wdXNoKHMuY29udGV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNsb25lYWJsZSkge1xuICAgICAgICAgICAgQXJyYXlBcmJpdHJhcnkubWFrZUl0Q2xvbmVhYmxlKHZzLCBpdGVtcyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY29udGV4dCA9IHtcbiAgICAgICAgICAgIHNocnVua09uY2UsXG4gICAgICAgICAgICBsZW5ndGhDb250ZXh0OiBpdGVtc1Jhdy5sZW5ndGggPT09IGl0ZW1zLmxlbmd0aCAmJiBpdGVtc1Jhd0xlbmd0aENvbnRleHQgIT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgID8gaXRlbXNSYXdMZW5ndGhDb250ZXh0XG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBpdGVtc0NvbnRleHRzLFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gbmV3IE5leHRWYWx1ZV8xLk5leHRWYWx1ZSh2cywgY29udGV4dCk7XG4gICAgfVxuICAgIGdlbmVyYXRlKG1ybmcsIGJpYXNGYWN0b3IpIHtcbiAgICAgICAgY29uc3QgYmlhc01ldGEgPSB0aGlzLmFwcGx5Qmlhcyhtcm5nLCBiaWFzRmFjdG9yKTtcbiAgICAgICAgY29uc3QgdGFyZ2V0U2l6ZSA9IGJpYXNNZXRhLnNpemU7XG4gICAgICAgIGNvbnN0IGl0ZW1zID0gdGhpcy5pc0VxdWFsICE9PSB1bmRlZmluZWRcbiAgICAgICAgICAgID8gdGhpcy5nZW5lcmF0ZU5JdGVtc05vRHVwbGljYXRlcyh0YXJnZXRTaXplLCBtcm5nLCBiaWFzTWV0YS5iaWFzRmFjdG9ySXRlbXMpXG4gICAgICAgICAgICA6IHRoaXMuZ2VuZXJhdGVOSXRlbXModGFyZ2V0U2l6ZSwgbXJuZywgYmlhc01ldGEuYmlhc0ZhY3Rvckl0ZW1zKTtcbiAgICAgICAgcmV0dXJuIHRoaXMud3JhcHBlcihpdGVtcywgZmFsc2UsIHVuZGVmaW5lZCk7XG4gICAgfVxuICAgIGFwcGx5Qmlhcyhtcm5nLCBiaWFzRmFjdG9yKSB7XG4gICAgICAgIGlmIChiaWFzRmFjdG9yID09PSB1bmRlZmluZWQgfHwgbXJuZy5uZXh0SW50KDEsIGJpYXNGYWN0b3IpICE9PSAxKSB7XG4gICAgICAgICAgICByZXR1cm4geyBzaXplOiB0aGlzLmxlbmd0aEFyYi5nZW5lcmF0ZShtcm5nLCB1bmRlZmluZWQpLnZhbHVlIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1ybmcubmV4dEludCgxLCBiaWFzRmFjdG9yKSAhPT0gMSB8fCB0aGlzLm1pbkxlbmd0aCA9PT0gdGhpcy5tYXhMZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiB7IHNpemU6IHRoaXMubGVuZ3RoQXJiLmdlbmVyYXRlKG1ybmcsIHVuZGVmaW5lZCkudmFsdWUsIGJpYXNGYWN0b3JJdGVtczogYmlhc0ZhY3RvciB9O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1heEJpYXNlZExlbmd0aCA9IHRoaXMubWluTGVuZ3RoICsgTWF0aC5mbG9vcihNYXRoLmxvZyh0aGlzLm1heExlbmd0aCAtIHRoaXMubWluTGVuZ3RoKSAvIE1hdGgubG9nKDIpKTtcbiAgICAgICAgY29uc3QgdGFyZ2V0U2l6ZVZhbHVlID0gQ29udmVydGVyc18xLmNvbnZlcnRUb05leHQoaW50ZWdlcl8xLmludGVnZXIodGhpcy5taW5MZW5ndGgsIG1heEJpYXNlZExlbmd0aCkpLmdlbmVyYXRlKG1ybmcsIHVuZGVmaW5lZCk7XG4gICAgICAgIHJldHVybiB7IHNpemU6IHRhcmdldFNpemVWYWx1ZS52YWx1ZSwgYmlhc0ZhY3Rvckl0ZW1zOiBiaWFzRmFjdG9yIH07XG4gICAgfVxuICAgIGNhblNocmlua1dpdGhvdXRDb250ZXh0KHZhbHVlKSB7XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheSh2YWx1ZSkgfHwgdGhpcy5taW5MZW5ndGggPiB2YWx1ZS5sZW5ndGggfHwgdmFsdWUubGVuZ3RoID4gdGhpcy5tYXhMZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4ICE9PSB2YWx1ZS5sZW5ndGg7ICsraW5kZXgpIHtcbiAgICAgICAgICAgIGlmICghKGluZGV4IGluIHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghdGhpcy5hcmIuY2FuU2hyaW5rV2l0aG91dENvbnRleHQodmFsdWVbaW5kZXhdKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBmaWx0ZXJlZCA9IHRoaXMucHJlRmlsdGVyKHZhbHVlLm1hcCgoaXRlbSkgPT4gbmV3IE5leHRWYWx1ZV8xLk5leHRWYWx1ZShpdGVtLCB1bmRlZmluZWQpKSk7XG4gICAgICAgIHJldHVybiBmaWx0ZXJlZC5sZW5ndGggPT09IHZhbHVlLmxlbmd0aDtcbiAgICB9XG4gICAgc2hyaW5rSW1wbCh2YWx1ZSwgY29udGV4dCkge1xuICAgICAgICBpZiAodmFsdWUubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gU3RyZWFtXzEuU3RyZWFtLm5pbCgpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNhZmVDb250ZXh0ID0gY29udGV4dCAhPT0gdW5kZWZpbmVkXG4gICAgICAgICAgICA/IGNvbnRleHRcbiAgICAgICAgICAgIDogeyBzaHJ1bmtPbmNlOiBmYWxzZSwgbGVuZ3RoQ29udGV4dDogdW5kZWZpbmVkLCBpdGVtc0NvbnRleHRzOiBbXSB9O1xuICAgICAgICByZXR1cm4gKHRoaXMubGVuZ3RoQXJiXG4gICAgICAgICAgICAuc2hyaW5rKHZhbHVlLmxlbmd0aCwgc2FmZUNvbnRleHQubGVuZ3RoQ29udGV4dClcbiAgICAgICAgICAgIC5kcm9wKHNhZmVDb250ZXh0LnNocnVua09uY2UgJiYgc2FmZUNvbnRleHQubGVuZ3RoQ29udGV4dCA9PT0gdW5kZWZpbmVkICYmIHZhbHVlLmxlbmd0aCA+IHRoaXMubWluTGVuZ3RoICsgMSA/IDEgOiAwKVxuICAgICAgICAgICAgLm1hcCgobGVuZ3RoVmFsdWUpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHNsaWNlU3RhcnQgPSB2YWx1ZS5sZW5ndGggLSBsZW5ndGhWYWx1ZS52YWx1ZTtcbiAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgdmFsdWVcbiAgICAgICAgICAgICAgICAgICAgLnNsaWNlKHNsaWNlU3RhcnQpXG4gICAgICAgICAgICAgICAgICAgIC5tYXAoKHYsIGluZGV4KSA9PiBuZXcgTmV4dFZhbHVlXzEuTmV4dFZhbHVlKHN5bWJvbHNfMS5jbG9uZUlmTmVlZGVkKHYpLCBzYWZlQ29udGV4dC5pdGVtc0NvbnRleHRzW2luZGV4ICsgc2xpY2VTdGFydF0pKSxcbiAgICAgICAgICAgICAgICBsZW5ndGhWYWx1ZS5jb250ZXh0LFxuICAgICAgICAgICAgXTtcbiAgICAgICAgfSlcbiAgICAgICAgICAgIC5qb2luKHRoaXMuYXJiLnNocmluayh2YWx1ZVswXSwgc2FmZUNvbnRleHQuaXRlbXNDb250ZXh0c1swXSkubWFwKCh2KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgIFt2XS5jb25jYXQodmFsdWUuc2xpY2UoMSkubWFwKCh2LCBpbmRleCkgPT4gbmV3IE5leHRWYWx1ZV8xLk5leHRWYWx1ZShzeW1ib2xzXzEuY2xvbmVJZk5lZWRlZCh2KSwgc2FmZUNvbnRleHQuaXRlbXNDb250ZXh0c1tpbmRleCArIDFdKSkpLFxuICAgICAgICAgICAgICAgIHVuZGVmaW5lZCxcbiAgICAgICAgICAgIF07XG4gICAgICAgIH0pKVxuICAgICAgICAgICAgLmpvaW4odmFsdWUubGVuZ3RoID4gdGhpcy5taW5MZW5ndGhcbiAgICAgICAgICAgID8gTGF6eUl0ZXJhYmxlSXRlcmF0b3JfMS5tYWtlTGF6eSgoKSA9PiB0aGlzLnNocmlua0ltcGwodmFsdWUuc2xpY2UoMSksIHtcbiAgICAgICAgICAgICAgICBzaHJ1bmtPbmNlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBsZW5ndGhDb250ZXh0OiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgaXRlbXNDb250ZXh0czogc2FmZUNvbnRleHQuaXRlbXNDb250ZXh0cy5zbGljZSgxKSxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLmZpbHRlcigodikgPT4gdGhpcy5taW5MZW5ndGggPD0gdlswXS5sZW5ndGggKyAxKVxuICAgICAgICAgICAgICAgIC5tYXAoKHYpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgICAgICBbbmV3IE5leHRWYWx1ZV8xLk5leHRWYWx1ZShzeW1ib2xzXzEuY2xvbmVJZk5lZWRlZCh2YWx1ZVswXSksIHNhZmVDb250ZXh0Lml0ZW1zQ29udGV4dHNbMF0pXS5jb25jYXQodlswXSksXG4gICAgICAgICAgICAgICAgICAgIHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgfSkpXG4gICAgICAgICAgICA6IFN0cmVhbV8xLlN0cmVhbS5uaWwoKSkpO1xuICAgIH1cbiAgICBzaHJpbmsodmFsdWUsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2hyaW5rSW1wbCh2YWx1ZSwgY29udGV4dCkubWFwKChjb250ZXh0dWFsVmFsdWUpID0+IHRoaXMud3JhcHBlcihjb250ZXh0dWFsVmFsdWVbMF0sIHRydWUsIGNvbnRleHR1YWxWYWx1ZVsxXSkpO1xuICAgIH1cbn1cbmV4cG9ydHMuQXJyYXlBcmJpdHJhcnkgPSBBcnJheUFyYml0cmFyeTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5CaWdJbnRBcmJpdHJhcnkgPSB2b2lkIDA7XG5jb25zdCBTdHJlYW1fMSA9IHJlcXVpcmUoXCIuLi8uLi9zdHJlYW0vU3RyZWFtXCIpO1xuY29uc3QgTmV4dEFyYml0cmFyeV8xID0gcmVxdWlyZShcIi4uLy4uL2NoZWNrL2FyYml0cmFyeS9kZWZpbml0aW9uL05leHRBcmJpdHJhcnlcIik7XG5jb25zdCBOZXh0VmFsdWVfMSA9IHJlcXVpcmUoXCIuLi8uLi9jaGVjay9hcmJpdHJhcnkvZGVmaW5pdGlvbi9OZXh0VmFsdWVcIik7XG5jb25zdCBCaWFzTnVtZXJpY1JhbmdlXzEgPSByZXF1aXJlKFwiLi9oZWxwZXJzL0JpYXNOdW1lcmljUmFuZ2VcIik7XG5jb25zdCBTaHJpbmtCaWdJbnRfMSA9IHJlcXVpcmUoXCIuL2hlbHBlcnMvU2hyaW5rQmlnSW50XCIpO1xuY2xhc3MgQmlnSW50QXJiaXRyYXJ5IGV4dGVuZHMgTmV4dEFyYml0cmFyeV8xLk5leHRBcmJpdHJhcnkge1xuICAgIGNvbnN0cnVjdG9yKG1pbiwgbWF4KSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMubWluID0gbWluO1xuICAgICAgICB0aGlzLm1heCA9IG1heDtcbiAgICB9XG4gICAgZ2VuZXJhdGUobXJuZywgYmlhc0ZhY3Rvcikge1xuICAgICAgICBjb25zdCByYW5nZSA9IHRoaXMuY29tcHV0ZUdlbmVyYXRlUmFuZ2UobXJuZywgYmlhc0ZhY3Rvcik7XG4gICAgICAgIHJldHVybiBuZXcgTmV4dFZhbHVlXzEuTmV4dFZhbHVlKG1ybmcubmV4dEJpZ0ludChyYW5nZS5taW4sIHJhbmdlLm1heCksIHVuZGVmaW5lZCk7XG4gICAgfVxuICAgIGNvbXB1dGVHZW5lcmF0ZVJhbmdlKG1ybmcsIGJpYXNGYWN0b3IpIHtcbiAgICAgICAgaWYgKGJpYXNGYWN0b3IgPT09IHVuZGVmaW5lZCB8fCBtcm5nLm5leHRJbnQoMSwgYmlhc0ZhY3RvcikgIT09IDEpIHtcbiAgICAgICAgICAgIHJldHVybiB7IG1pbjogdGhpcy5taW4sIG1heDogdGhpcy5tYXggfTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByYW5nZXMgPSBCaWFzTnVtZXJpY1JhbmdlXzEuYmlhc051bWVyaWNSYW5nZSh0aGlzLm1pbiwgdGhpcy5tYXgsIEJpYXNOdW1lcmljUmFuZ2VfMS5iaWdJbnRMb2dMaWtlKTtcbiAgICAgICAgaWYgKHJhbmdlcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIHJldHVybiByYW5nZXNbMF07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaWQgPSBtcm5nLm5leHRJbnQoLTIgKiAocmFuZ2VzLmxlbmd0aCAtIDEpLCByYW5nZXMubGVuZ3RoIC0gMik7XG4gICAgICAgIHJldHVybiBpZCA8IDAgPyByYW5nZXNbMF0gOiByYW5nZXNbaWQgKyAxXTtcbiAgICB9XG4gICAgY2FuU2hyaW5rV2l0aG91dENvbnRleHQodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ2JpZ2ludCcgJiYgdGhpcy5taW4gPD0gdmFsdWUgJiYgdmFsdWUgPD0gdGhpcy5tYXg7XG4gICAgfVxuICAgIHNocmluayhjdXJyZW50LCBjb250ZXh0KSB7XG4gICAgICAgIGlmICghQmlnSW50QXJiaXRyYXJ5LmlzVmFsaWRDb250ZXh0KGN1cnJlbnQsIGNvbnRleHQpKSB7XG4gICAgICAgICAgICBjb25zdCB0YXJnZXQgPSB0aGlzLmRlZmF1bHRUYXJnZXQoKTtcbiAgICAgICAgICAgIHJldHVybiBTaHJpbmtCaWdJbnRfMS5zaHJpbmtCaWdJbnQoY3VycmVudCwgdGFyZ2V0LCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5pc0xhc3RDaGFuY2VUcnkoY3VycmVudCwgY29udGV4dCkpIHtcbiAgICAgICAgICAgIHJldHVybiBTdHJlYW1fMS5TdHJlYW0ub2YobmV3IE5leHRWYWx1ZV8xLk5leHRWYWx1ZShjb250ZXh0LCB1bmRlZmluZWQpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gU2hyaW5rQmlnSW50XzEuc2hyaW5rQmlnSW50KGN1cnJlbnQsIGNvbnRleHQsIGZhbHNlKTtcbiAgICB9XG4gICAgZGVmYXVsdFRhcmdldCgpIHtcbiAgICAgICAgaWYgKHRoaXMubWluIDw9IDAgJiYgdGhpcy5tYXggPj0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIEJpZ0ludCgwKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5taW4gPCAwID8gdGhpcy5tYXggOiB0aGlzLm1pbjtcbiAgICB9XG4gICAgaXNMYXN0Q2hhbmNlVHJ5KGN1cnJlbnQsIGNvbnRleHQpIHtcbiAgICAgICAgaWYgKGN1cnJlbnQgPiAwKVxuICAgICAgICAgICAgcmV0dXJuIGN1cnJlbnQgPT09IGNvbnRleHQgKyBCaWdJbnQoMSkgJiYgY3VycmVudCA+IHRoaXMubWluO1xuICAgICAgICBpZiAoY3VycmVudCA8IDApXG4gICAgICAgICAgICByZXR1cm4gY3VycmVudCA9PT0gY29udGV4dCAtIEJpZ0ludCgxKSAmJiBjdXJyZW50IDwgdGhpcy5tYXg7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgc3RhdGljIGlzVmFsaWRDb250ZXh0KGN1cnJlbnQsIGNvbnRleHQpIHtcbiAgICAgICAgaWYgKGNvbnRleHQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgY29udGV4dCAhPT0gJ2JpZ2ludCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBjb250ZXh0IHR5cGUgcGFzc2VkIHRvIEJpZ0ludEFyYml0cmFyeSAoIzEpYCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZGlmZmVyZW50U2lnbnMgPSAoY3VycmVudCA+IDAgJiYgY29udGV4dCA8IDApIHx8IChjdXJyZW50IDwgMCAmJiBjb250ZXh0ID4gMCk7XG4gICAgICAgIGlmIChjb250ZXh0ICE9PSBCaWdJbnQoMCkgJiYgZGlmZmVyZW50U2lnbnMpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBjb250ZXh0IHZhbHVlIHBhc3NlZCB0byBCaWdJbnRBcmJpdHJhcnkgKCMyKWApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbn1cbmV4cG9ydHMuQmlnSW50QXJiaXRyYXJ5ID0gQmlnSW50QXJiaXRyYXJ5O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkNsb25lQXJiaXRyYXJ5ID0gdm9pZCAwO1xuY29uc3QgTmV4dEFyYml0cmFyeV8xID0gcmVxdWlyZShcIi4uLy4uL2NoZWNrL2FyYml0cmFyeS9kZWZpbml0aW9uL05leHRBcmJpdHJhcnlcIik7XG5jb25zdCBOZXh0VmFsdWVfMSA9IHJlcXVpcmUoXCIuLi8uLi9jaGVjay9hcmJpdHJhcnkvZGVmaW5pdGlvbi9OZXh0VmFsdWVcIik7XG5jb25zdCBzeW1ib2xzXzEgPSByZXF1aXJlKFwiLi4vLi4vY2hlY2svc3ltYm9sc1wiKTtcbmNvbnN0IFN0cmVhbV8xID0gcmVxdWlyZShcIi4uLy4uL3N0cmVhbS9TdHJlYW1cIik7XG5jbGFzcyBDbG9uZUFyYml0cmFyeSBleHRlbmRzIE5leHRBcmJpdHJhcnlfMS5OZXh0QXJiaXRyYXJ5IHtcbiAgICBjb25zdHJ1Y3RvcihhcmIsIG51bVZhbHVlcykge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmFyYiA9IGFyYjtcbiAgICAgICAgdGhpcy5udW1WYWx1ZXMgPSBudW1WYWx1ZXM7XG4gICAgfVxuICAgIGdlbmVyYXRlKG1ybmcsIGJpYXNGYWN0b3IpIHtcbiAgICAgICAgY29uc3QgaXRlbXMgPSBbXTtcbiAgICAgICAgaWYgKHRoaXMubnVtVmFsdWVzIDw9IDApIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLndyYXBwZXIoaXRlbXMpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGlkeCA9IDA7IGlkeCAhPT0gdGhpcy5udW1WYWx1ZXMgLSAxOyArK2lkeCkge1xuICAgICAgICAgICAgaXRlbXMucHVzaCh0aGlzLmFyYi5nZW5lcmF0ZShtcm5nLmNsb25lKCksIGJpYXNGYWN0b3IpKTtcbiAgICAgICAgfVxuICAgICAgICBpdGVtcy5wdXNoKHRoaXMuYXJiLmdlbmVyYXRlKG1ybmcsIGJpYXNGYWN0b3IpKTtcbiAgICAgICAgcmV0dXJuIHRoaXMud3JhcHBlcihpdGVtcyk7XG4gICAgfVxuICAgIGNhblNocmlua1dpdGhvdXRDb250ZXh0KHZhbHVlKSB7XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheSh2YWx1ZSkgfHwgdmFsdWUubGVuZ3RoICE9PSB0aGlzLm51bVZhbHVlcykge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2YWx1ZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGluZGV4ID0gMTsgaW5kZXggPCB2YWx1ZS5sZW5ndGg7ICsraW5kZXgpIHtcbiAgICAgICAgICAgIGlmICghT2JqZWN0LmlzKHZhbHVlWzBdLCB2YWx1ZVtpbmRleF0pKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmFyYi5jYW5TaHJpbmtXaXRob3V0Q29udGV4dCh2YWx1ZVswXSk7XG4gICAgfVxuICAgIHNocmluayh2YWx1ZSwgY29udGV4dCkge1xuICAgICAgICBpZiAodmFsdWUubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gU3RyZWFtXzEuU3RyZWFtLm5pbCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgU3RyZWFtXzEuU3RyZWFtKHRoaXMuc2hyaW5rSW1wbCh2YWx1ZSwgY29udGV4dCAhPT0gdW5kZWZpbmVkID8gY29udGV4dCA6IFtdKSkubWFwKCh2KSA9PiB0aGlzLndyYXBwZXIodikpO1xuICAgIH1cbiAgICAqc2hyaW5rSW1wbCh2YWx1ZSwgY29udGV4dHMpIHtcbiAgICAgICAgY29uc3QgaXRzID0gdmFsdWUubWFwKCh2LCBpZHgpID0+IHRoaXMuYXJiLnNocmluayh2LCBjb250ZXh0c1tpZHhdKVtTeW1ib2wuaXRlcmF0b3JdKCkpO1xuICAgICAgICBsZXQgY3VyID0gaXRzLm1hcCgoaXQpID0+IGl0Lm5leHQoKSk7XG4gICAgICAgIHdoaWxlICghY3VyWzBdLmRvbmUpIHtcbiAgICAgICAgICAgIHlpZWxkIGN1ci5tYXAoKGMpID0+IGMudmFsdWUpO1xuICAgICAgICAgICAgY3VyID0gaXRzLm1hcCgoaXQpID0+IGl0Lm5leHQoKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3RhdGljIG1ha2VJdENsb25lYWJsZSh2cywgc2hyaW5rYWJsZXMpIHtcbiAgICAgICAgdnNbc3ltYm9sc18xLmNsb25lTWV0aG9kXSA9ICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGNsb25lZCA9IFtdO1xuICAgICAgICAgICAgZm9yIChsZXQgaWR4ID0gMDsgaWR4ICE9PSBzaHJpbmthYmxlcy5sZW5ndGg7ICsraWR4KSB7XG4gICAgICAgICAgICAgICAgY2xvbmVkLnB1c2goc2hyaW5rYWJsZXNbaWR4XS52YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLm1ha2VJdENsb25lYWJsZShjbG9uZWQsIHNocmlua2FibGVzKTtcbiAgICAgICAgICAgIHJldHVybiBjbG9uZWQ7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB2cztcbiAgICB9XG4gICAgd3JhcHBlcihpdGVtcykge1xuICAgICAgICBsZXQgY2xvbmVhYmxlID0gZmFsc2U7XG4gICAgICAgIGNvbnN0IHZzID0gW107XG4gICAgICAgIGNvbnN0IGNvbnRleHRzID0gW107XG4gICAgICAgIGZvciAobGV0IGlkeCA9IDA7IGlkeCAhPT0gaXRlbXMubGVuZ3RoOyArK2lkeCkge1xuICAgICAgICAgICAgY29uc3QgcyA9IGl0ZW1zW2lkeF07XG4gICAgICAgICAgICBjbG9uZWFibGUgPSBjbG9uZWFibGUgfHwgcy5oYXNUb0JlQ2xvbmVkO1xuICAgICAgICAgICAgdnMucHVzaChzLnZhbHVlKTtcbiAgICAgICAgICAgIGNvbnRleHRzLnB1c2gocy5jb250ZXh0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2xvbmVhYmxlKSB7XG4gICAgICAgICAgICBDbG9uZUFyYml0cmFyeS5tYWtlSXRDbG9uZWFibGUodnMsIGl0ZW1zKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IE5leHRWYWx1ZV8xLk5leHRWYWx1ZSh2cywgY29udGV4dHMpO1xuICAgIH1cbn1cbmV4cG9ydHMuQ2xvbmVBcmJpdHJhcnkgPSBDbG9uZUFyYml0cmFyeTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Db25zdGFudEFyYml0cmFyeSA9IHZvaWQgMDtcbmNvbnN0IFN0cmVhbV8xID0gcmVxdWlyZShcIi4uLy4uL3N0cmVhbS9TdHJlYW1cIik7XG5jb25zdCBOZXh0QXJiaXRyYXJ5XzEgPSByZXF1aXJlKFwiLi4vLi4vY2hlY2svYXJiaXRyYXJ5L2RlZmluaXRpb24vTmV4dEFyYml0cmFyeVwiKTtcbmNvbnN0IE5leHRWYWx1ZV8xID0gcmVxdWlyZShcIi4uLy4uL2NoZWNrL2FyYml0cmFyeS9kZWZpbml0aW9uL05leHRWYWx1ZVwiKTtcbmNvbnN0IHN5bWJvbHNfMSA9IHJlcXVpcmUoXCIuLi8uLi9jaGVjay9zeW1ib2xzXCIpO1xuY2xhc3MgQ29uc3RhbnRBcmJpdHJhcnkgZXh0ZW5kcyBOZXh0QXJiaXRyYXJ5XzEuTmV4dEFyYml0cmFyeSB7XG4gICAgY29uc3RydWN0b3IodmFsdWVzKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMudmFsdWVzID0gdmFsdWVzO1xuICAgIH1cbiAgICBnZW5lcmF0ZShtcm5nLCBfYmlhc0ZhY3Rvcikge1xuICAgICAgICBjb25zdCBpZHggPSB0aGlzLnZhbHVlcy5sZW5ndGggPT09IDEgPyAwIDogbXJuZy5uZXh0SW50KDAsIHRoaXMudmFsdWVzLmxlbmd0aCAtIDEpO1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHRoaXMudmFsdWVzW2lkeF07XG4gICAgICAgIGlmICghc3ltYm9sc18xLmhhc0Nsb25lTWV0aG9kKHZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBOZXh0VmFsdWVfMS5OZXh0VmFsdWUodmFsdWUsIGlkeCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBOZXh0VmFsdWVfMS5OZXh0VmFsdWUodmFsdWUsIGlkeCwgKCkgPT4gdmFsdWVbc3ltYm9sc18xLmNsb25lTWV0aG9kXSgpKTtcbiAgICB9XG4gICAgY2FuU2hyaW5rV2l0aG91dENvbnRleHQodmFsdWUpIHtcbiAgICAgICAgZm9yIChsZXQgaWR4ID0gMDsgaWR4ICE9PSB0aGlzLnZhbHVlcy5sZW5ndGg7ICsraWR4KSB7XG4gICAgICAgICAgICBpZiAoT2JqZWN0LmlzKHRoaXMudmFsdWVzW2lkeF0sIHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgc2hyaW5rKHZhbHVlLCBjb250ZXh0KSB7XG4gICAgICAgIGlmIChjb250ZXh0ID09PSAwIHx8IE9iamVjdC5pcyh2YWx1ZSwgdGhpcy52YWx1ZXNbMF0pKSB7XG4gICAgICAgICAgICByZXR1cm4gU3RyZWFtXzEuU3RyZWFtLm5pbCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBTdHJlYW1fMS5TdHJlYW0ub2YobmV3IE5leHRWYWx1ZV8xLk5leHRWYWx1ZSh0aGlzLnZhbHVlc1swXSwgMCkpO1xuICAgIH1cbn1cbmV4cG9ydHMuQ29uc3RhbnRBcmJpdHJhcnkgPSBDb25zdGFudEFyYml0cmFyeTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5GcmVxdWVuY3lBcmJpdHJhcnkgPSB2b2lkIDA7XG5jb25zdCBTdHJlYW1fMSA9IHJlcXVpcmUoXCIuLi8uLi9zdHJlYW0vU3RyZWFtXCIpO1xuY29uc3QgQ29udmVydGVyc18xID0gcmVxdWlyZShcIi4uLy4uL2NoZWNrL2FyYml0cmFyeS9kZWZpbml0aW9uL0NvbnZlcnRlcnNcIik7XG5jb25zdCBOZXh0QXJiaXRyYXJ5XzEgPSByZXF1aXJlKFwiLi4vLi4vY2hlY2svYXJiaXRyYXJ5L2RlZmluaXRpb24vTmV4dEFyYml0cmFyeVwiKTtcbmNvbnN0IE5leHRWYWx1ZV8xID0gcmVxdWlyZShcIi4uLy4uL2NoZWNrL2FyYml0cmFyeS9kZWZpbml0aW9uL05leHRWYWx1ZVwiKTtcbmNvbnN0IERlcHRoQ29udGV4dF8xID0gcmVxdWlyZShcIi4vaGVscGVycy9EZXB0aENvbnRleHRcIik7XG5jbGFzcyBGcmVxdWVuY3lBcmJpdHJhcnkgZXh0ZW5kcyBOZXh0QXJiaXRyYXJ5XzEuTmV4dEFyYml0cmFyeSB7XG4gICAgY29uc3RydWN0b3Iod2FyYnMsIGNvbnN0cmFpbnRzLCBjb250ZXh0KSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMud2FyYnMgPSB3YXJicztcbiAgICAgICAgdGhpcy5jb25zdHJhaW50cyA9IGNvbnN0cmFpbnRzO1xuICAgICAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICAgICAgICBsZXQgY3VycmVudFdlaWdodCA9IDA7XG4gICAgICAgIHRoaXMuY3VtdWxhdGVkV2VpZ2h0cyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpZHggPSAwOyBpZHggIT09IHdhcmJzLmxlbmd0aDsgKytpZHgpIHtcbiAgICAgICAgICAgIGN1cnJlbnRXZWlnaHQgKz0gd2FyYnNbaWR4XS53ZWlnaHQ7XG4gICAgICAgICAgICB0aGlzLmN1bXVsYXRlZFdlaWdodHMucHVzaChjdXJyZW50V2VpZ2h0KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnRvdGFsV2VpZ2h0ID0gY3VycmVudFdlaWdodDtcbiAgICB9XG4gICAgc3RhdGljIGZyb21PbGQod2FyYnMsIGNvbnN0cmFpbnRzLCBsYWJlbCkge1xuICAgICAgICByZXR1cm4gQ29udmVydGVyc18xLmNvbnZlcnRGcm9tTmV4dChGcmVxdWVuY3lBcmJpdHJhcnkuZnJvbSh3YXJicy5tYXAoKHcpID0+IChPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHcpLCB7IGFyYml0cmFyeTogQ29udmVydGVyc18xLmNvbnZlcnRUb05leHQody5hcmJpdHJhcnkpIH0pKSksIGNvbnN0cmFpbnRzLCBsYWJlbCkpO1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbSh3YXJicywgY29uc3RyYWludHMsIGxhYmVsKSB7XG4gICAgICAgIGlmICh3YXJicy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgJHtsYWJlbH0gZXhwZWN0cyBhdCBsZWFzdCBvbmUgd2VpZ3RoZWQgYXJiaXRyYXJ5YCk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHRvdGFsV2VpZ2h0ID0gMDtcbiAgICAgICAgZm9yIChsZXQgaWR4ID0gMDsgaWR4ICE9PSB3YXJicy5sZW5ndGg7ICsraWR4KSB7XG4gICAgICAgICAgICBjb25zdCBjdXJyZW50QXJiaXRyYXJ5ID0gd2FyYnNbaWR4XS5hcmJpdHJhcnk7XG4gICAgICAgICAgICBpZiAoY3VycmVudEFyYml0cmFyeSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAke2xhYmVsfSBleHBlY3RzIGFyYml0cmFyaWVzIHRvIGJlIHNwZWNpZmllZGApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgY3VycmVudFdlaWdodCA9IHdhcmJzW2lkeF0ud2VpZ2h0O1xuICAgICAgICAgICAgdG90YWxXZWlnaHQgKz0gY3VycmVudFdlaWdodDtcbiAgICAgICAgICAgIGlmICghTnVtYmVyLmlzSW50ZWdlcihjdXJyZW50V2VpZ2h0KSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgJHtsYWJlbH0gZXhwZWN0cyB3ZWlnaHRzIHRvIGJlIGludGVnZXIgdmFsdWVzYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY3VycmVudFdlaWdodCA8IDApIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7bGFiZWx9IGV4cGVjdHMgd2VpZ2h0cyB0byBiZSBzdXBlcmlvciBvciBlcXVhbCB0byAwYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRvdGFsV2VpZ2h0IDw9IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgJHtsYWJlbH0gZXhwZWN0cyB0aGUgc3VtIG9mIHdlaWdodHMgdG8gYmUgc3RyaWN0bHkgc3VwZXJpb3IgdG8gMGApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgRnJlcXVlbmN5QXJiaXRyYXJ5KHdhcmJzLCBjb25zdHJhaW50cywgRGVwdGhDb250ZXh0XzEuZ2V0RGVwdGhDb250ZXh0Rm9yKGNvbnN0cmFpbnRzLmRlcHRoSWRlbnRpZmllcikpO1xuICAgIH1cbiAgICBnZW5lcmF0ZShtcm5nLCBiaWFzRmFjdG9yKSB7XG4gICAgICAgIGlmICh0aGlzLm11c3RHZW5lcmF0ZUZpcnN0KCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNhZmVHZW5lcmF0ZUZvckluZGV4KG1ybmcsIDAsIGJpYXNGYWN0b3IpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNlbGVjdGVkID0gbXJuZy5uZXh0SW50KHRoaXMuY29tcHV0ZU5lZ0RlcHRoQmVuZWZpdCgpLCB0aGlzLnRvdGFsV2VpZ2h0IC0gMSk7XG4gICAgICAgIGZvciAobGV0IGlkeCA9IDA7IGlkeCAhPT0gdGhpcy5jdW11bGF0ZWRXZWlnaHRzLmxlbmd0aDsgKytpZHgpIHtcbiAgICAgICAgICAgIGlmIChzZWxlY3RlZCA8IHRoaXMuY3VtdWxhdGVkV2VpZ2h0c1tpZHhdKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2FmZUdlbmVyYXRlRm9ySW5kZXgobXJuZywgaWR4LCBiaWFzRmFjdG9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuYWJsZSB0byBnZW5lcmF0ZSBmcm9tIGZjLmZyZXF1ZW5jeWApO1xuICAgIH1cbiAgICBjYW5TaHJpbmtXaXRob3V0Q29udGV4dCh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5jYW5TaHJpbmtXaXRob3V0Q29udGV4dEluZGV4KHZhbHVlKSAhPT0gLTE7XG4gICAgfVxuICAgIHNocmluayh2YWx1ZSwgY29udGV4dCkge1xuICAgICAgICBpZiAoY29udGV4dCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb25zdCBzYWZlQ29udGV4dCA9IGNvbnRleHQ7XG4gICAgICAgICAgICBjb25zdCBzZWxlY3RlZEluZGV4ID0gc2FmZUNvbnRleHQuc2VsZWN0ZWRJbmRleDtcbiAgICAgICAgICAgIGNvbnN0IG9yaWdpbmFsQmlhcyA9IHNhZmVDb250ZXh0Lm9yaWdpbmFsQmlhcztcbiAgICAgICAgICAgIGNvbnN0IG9yaWdpbmFsQXJiaXRyYXJ5ID0gdGhpcy53YXJic1tzZWxlY3RlZEluZGV4XS5hcmJpdHJhcnk7XG4gICAgICAgICAgICBjb25zdCBvcmlnaW5hbFNocmlua3MgPSBvcmlnaW5hbEFyYml0cmFyeVxuICAgICAgICAgICAgICAgIC5zaHJpbmsodmFsdWUsIHNhZmVDb250ZXh0Lm9yaWdpbmFsQ29udGV4dClcbiAgICAgICAgICAgICAgICAubWFwKCh2KSA9PiB0aGlzLm1hcEludG9OZXh0VmFsdWUoc2VsZWN0ZWRJbmRleCwgdiwgbnVsbCwgb3JpZ2luYWxCaWFzKSk7XG4gICAgICAgICAgICBpZiAoc2FmZUNvbnRleHQuY2xvbmVkTXJuZ0ZvckZhbGxiYWNrRmlyc3QgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpZiAoc2FmZUNvbnRleHQuY2FjaGVkR2VuZXJhdGVkRm9yRmlyc3QgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBzYWZlQ29udGV4dC5jYWNoZWRHZW5lcmF0ZWRGb3JGaXJzdCA9IHRoaXMuc2FmZUdlbmVyYXRlRm9ySW5kZXgoc2FmZUNvbnRleHQuY2xvbmVkTXJuZ0ZvckZhbGxiYWNrRmlyc3QsIDAsIG9yaWdpbmFsQmlhcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlRnJvbUZpcnN0ID0gc2FmZUNvbnRleHQuY2FjaGVkR2VuZXJhdGVkRm9yRmlyc3Q7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFN0cmVhbV8xLlN0cmVhbS5vZih2YWx1ZUZyb21GaXJzdCkuam9pbihvcmlnaW5hbFNocmlua3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG9yaWdpbmFsU2hyaW5rcztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwb3RlbnRpYWxTZWxlY3RlZEluZGV4ID0gdGhpcy5jYW5TaHJpbmtXaXRob3V0Q29udGV4dEluZGV4KHZhbHVlKTtcbiAgICAgICAgaWYgKHBvdGVudGlhbFNlbGVjdGVkSW5kZXggPT09IC0xKSB7XG4gICAgICAgICAgICByZXR1cm4gU3RyZWFtXzEuU3RyZWFtLm5pbCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmRlZmF1bHRTaHJpbmtGb3JGaXJzdChwb3RlbnRpYWxTZWxlY3RlZEluZGV4KS5qb2luKHRoaXMud2FyYnNbcG90ZW50aWFsU2VsZWN0ZWRJbmRleF0uYXJiaXRyYXJ5XG4gICAgICAgICAgICAuc2hyaW5rKHZhbHVlLCB1bmRlZmluZWQpXG4gICAgICAgICAgICAubWFwKCh2KSA9PiB0aGlzLm1hcEludG9OZXh0VmFsdWUocG90ZW50aWFsU2VsZWN0ZWRJbmRleCwgdiwgbnVsbCwgdW5kZWZpbmVkKSkpO1xuICAgIH1cbiAgICBkZWZhdWx0U2hyaW5rRm9yRmlyc3Qoc2VsZWN0ZWRJbmRleCkge1xuICAgICAgICArK3RoaXMuY29udGV4dC5kZXB0aDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmICghdGhpcy5tdXN0RmFsbGJhY2tUb0ZpcnN0SW5TaHJpbmsoc2VsZWN0ZWRJbmRleCkgfHwgdGhpcy53YXJic1swXS5mYWxsYmFja1ZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gU3RyZWFtXzEuU3RyZWFtLm5pbCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgLS10aGlzLmNvbnRleHQuZGVwdGg7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmF3U2hyaW5rVmFsdWUgPSBuZXcgTmV4dFZhbHVlXzEuTmV4dFZhbHVlKHRoaXMud2FyYnNbMF0uZmFsbGJhY2tWYWx1ZS5kZWZhdWx0LCB1bmRlZmluZWQpO1xuICAgICAgICByZXR1cm4gU3RyZWFtXzEuU3RyZWFtLm9mKHRoaXMubWFwSW50b05leHRWYWx1ZSgwLCByYXdTaHJpbmtWYWx1ZSwgbnVsbCwgdW5kZWZpbmVkKSk7XG4gICAgfVxuICAgIGNhblNocmlua1dpdGhvdXRDb250ZXh0SW5kZXgodmFsdWUpIHtcbiAgICAgICAgaWYgKHRoaXMubXVzdEdlbmVyYXRlRmlyc3QoKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMud2FyYnNbMF0uYXJiaXRyYXJ5LmNhblNocmlua1dpdGhvdXRDb250ZXh0KHZhbHVlKSA/IDAgOiAtMTtcbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgKyt0aGlzLmNvbnRleHQuZGVwdGg7XG4gICAgICAgICAgICBmb3IgKGxldCBpZHggPSAwOyBpZHggIT09IHRoaXMud2FyYnMubGVuZ3RoOyArK2lkeCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHdhcmIgPSB0aGlzLndhcmJzW2lkeF07XG4gICAgICAgICAgICAgICAgaWYgKHdhcmIud2VpZ2h0ICE9PSAwICYmIHdhcmIuYXJiaXRyYXJ5LmNhblNocmlua1dpdGhvdXRDb250ZXh0KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaWR4O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgIC0tdGhpcy5jb250ZXh0LmRlcHRoO1xuICAgICAgICB9XG4gICAgfVxuICAgIG1hcEludG9OZXh0VmFsdWUoaWR4LCB2YWx1ZSwgY2xvbmVkTXJuZ0ZvckZhbGxiYWNrRmlyc3QsIGJpYXNGYWN0b3IpIHtcbiAgICAgICAgY29uc3QgY29udGV4dCA9IHtcbiAgICAgICAgICAgIHNlbGVjdGVkSW5kZXg6IGlkeCxcbiAgICAgICAgICAgIG9yaWdpbmFsQmlhczogYmlhc0ZhY3RvcixcbiAgICAgICAgICAgIG9yaWdpbmFsQ29udGV4dDogdmFsdWUuY29udGV4dCxcbiAgICAgICAgICAgIGNsb25lZE1ybmdGb3JGYWxsYmFja0ZpcnN0LFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gbmV3IE5leHRWYWx1ZV8xLk5leHRWYWx1ZSh2YWx1ZS52YWx1ZSwgY29udGV4dCk7XG4gICAgfVxuICAgIHNhZmVHZW5lcmF0ZUZvckluZGV4KG1ybmcsIGlkeCwgYmlhc0ZhY3Rvcikge1xuICAgICAgICArK3RoaXMuY29udGV4dC5kZXB0aDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy53YXJic1tpZHhdLmFyYml0cmFyeS5nZW5lcmF0ZShtcm5nLCBiaWFzRmFjdG9yKTtcbiAgICAgICAgICAgIGNvbnN0IGNsb25lZE1ybmdGb3JGYWxsYmFja0ZpcnN0ID0gdGhpcy5tdXN0RmFsbGJhY2tUb0ZpcnN0SW5TaHJpbmsoaWR4KSA/IG1ybmcuY2xvbmUoKSA6IG51bGw7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tYXBJbnRvTmV4dFZhbHVlKGlkeCwgdmFsdWUsIGNsb25lZE1ybmdGb3JGYWxsYmFja0ZpcnN0LCBiaWFzRmFjdG9yKTtcbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgIC0tdGhpcy5jb250ZXh0LmRlcHRoO1xuICAgICAgICB9XG4gICAgfVxuICAgIG11c3RHZW5lcmF0ZUZpcnN0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb25zdHJhaW50cy5tYXhEZXB0aCAhPT0gdW5kZWZpbmVkICYmIHRoaXMuY29uc3RyYWludHMubWF4RGVwdGggPD0gdGhpcy5jb250ZXh0LmRlcHRoO1xuICAgIH1cbiAgICBtdXN0RmFsbGJhY2tUb0ZpcnN0SW5TaHJpbmsoaWR4KSB7XG4gICAgICAgIHJldHVybiBpZHggIT09IDAgJiYgISF0aGlzLmNvbnN0cmFpbnRzLndpdGhDcm9zc1NocmluayAmJiB0aGlzLndhcmJzWzBdLndlaWdodCAhPT0gMDtcbiAgICB9XG4gICAgY29tcHV0ZU5lZ0RlcHRoQmVuZWZpdCgpIHtcbiAgICAgICAgY29uc3QgZGVwdGhGYWN0b3IgPSB0aGlzLmNvbnN0cmFpbnRzLmRlcHRoRmFjdG9yO1xuICAgICAgICBpZiAoZGVwdGhGYWN0b3IgPT09IHVuZGVmaW5lZCB8fCBkZXB0aEZhY3RvciA8PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBkZXB0aEJlbmVmaXQgPSBNYXRoLmZsb29yKE1hdGgucG93KDEgKyBkZXB0aEZhY3RvciwgdGhpcy5jb250ZXh0LmRlcHRoKSkgLSAxO1xuICAgICAgICByZXR1cm4gLU1hdGgubWluKHRoaXMud2FyYnNbMF0ud2VpZ2h0ICogZGVwdGhCZW5lZml0LCBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUikgfHwgMDtcbiAgICB9XG59XG5leHBvcnRzLkZyZXF1ZW5jeUFyYml0cmFyeSA9IEZyZXF1ZW5jeUFyYml0cmFyeTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5JbnRlZ2VyQXJiaXRyYXJ5ID0gdm9pZCAwO1xuY29uc3QgTmV4dEFyYml0cmFyeV8xID0gcmVxdWlyZShcIi4uLy4uL2NoZWNrL2FyYml0cmFyeS9kZWZpbml0aW9uL05leHRBcmJpdHJhcnlcIik7XG5jb25zdCBOZXh0VmFsdWVfMSA9IHJlcXVpcmUoXCIuLi8uLi9jaGVjay9hcmJpdHJhcnkvZGVmaW5pdGlvbi9OZXh0VmFsdWVcIik7XG5jb25zdCBTdHJlYW1fMSA9IHJlcXVpcmUoXCIuLi8uLi9zdHJlYW0vU3RyZWFtXCIpO1xuY29uc3QgQmlhc051bWVyaWNSYW5nZV8xID0gcmVxdWlyZShcIi4vaGVscGVycy9CaWFzTnVtZXJpY1JhbmdlXCIpO1xuY29uc3QgU2hyaW5rSW50ZWdlcl8xID0gcmVxdWlyZShcIi4vaGVscGVycy9TaHJpbmtJbnRlZ2VyXCIpO1xuY2xhc3MgSW50ZWdlckFyYml0cmFyeSBleHRlbmRzIE5leHRBcmJpdHJhcnlfMS5OZXh0QXJiaXRyYXJ5IHtcbiAgICBjb25zdHJ1Y3RvcihtaW4sIG1heCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLm1pbiA9IG1pbjtcbiAgICAgICAgdGhpcy5tYXggPSBtYXg7XG4gICAgfVxuICAgIGdlbmVyYXRlKG1ybmcsIGJpYXNGYWN0b3IpIHtcbiAgICAgICAgY29uc3QgcmFuZ2UgPSB0aGlzLmNvbXB1dGVHZW5lcmF0ZVJhbmdlKG1ybmcsIGJpYXNGYWN0b3IpO1xuICAgICAgICByZXR1cm4gbmV3IE5leHRWYWx1ZV8xLk5leHRWYWx1ZShtcm5nLm5leHRJbnQocmFuZ2UubWluLCByYW5nZS5tYXgpLCB1bmRlZmluZWQpO1xuICAgIH1cbiAgICBjYW5TaHJpbmtXaXRob3V0Q29udGV4dCh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgJiZcbiAgICAgICAgICAgIE51bWJlci5pc0ludGVnZXIodmFsdWUpICYmXG4gICAgICAgICAgICAhT2JqZWN0LmlzKHZhbHVlLCAtMCkgJiZcbiAgICAgICAgICAgIHRoaXMubWluIDw9IHZhbHVlICYmXG4gICAgICAgICAgICB2YWx1ZSA8PSB0aGlzLm1heCk7XG4gICAgfVxuICAgIHNocmluayhjdXJyZW50LCBjb250ZXh0KSB7XG4gICAgICAgIGlmICghSW50ZWdlckFyYml0cmFyeS5pc1ZhbGlkQ29udGV4dChjdXJyZW50LCBjb250ZXh0KSkge1xuICAgICAgICAgICAgY29uc3QgdGFyZ2V0ID0gdGhpcy5kZWZhdWx0VGFyZ2V0KCk7XG4gICAgICAgICAgICByZXR1cm4gU2hyaW5rSW50ZWdlcl8xLnNocmlua0ludGVnZXIoY3VycmVudCwgdGFyZ2V0LCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5pc0xhc3RDaGFuY2VUcnkoY3VycmVudCwgY29udGV4dCkpIHtcbiAgICAgICAgICAgIHJldHVybiBTdHJlYW1fMS5TdHJlYW0ub2YobmV3IE5leHRWYWx1ZV8xLk5leHRWYWx1ZShjb250ZXh0LCB1bmRlZmluZWQpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gU2hyaW5rSW50ZWdlcl8xLnNocmlua0ludGVnZXIoY3VycmVudCwgY29udGV4dCwgZmFsc2UpO1xuICAgIH1cbiAgICBkZWZhdWx0VGFyZ2V0KCkge1xuICAgICAgICBpZiAodGhpcy5taW4gPD0gMCAmJiB0aGlzLm1heCA+PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5taW4gPCAwID8gdGhpcy5tYXggOiB0aGlzLm1pbjtcbiAgICB9XG4gICAgY29tcHV0ZUdlbmVyYXRlUmFuZ2UobXJuZywgYmlhc0ZhY3Rvcikge1xuICAgICAgICBpZiAoYmlhc0ZhY3RvciA9PT0gdW5kZWZpbmVkIHx8IG1ybmcubmV4dEludCgxLCBiaWFzRmFjdG9yKSAhPT0gMSkge1xuICAgICAgICAgICAgcmV0dXJuIHsgbWluOiB0aGlzLm1pbiwgbWF4OiB0aGlzLm1heCB9O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJhbmdlcyA9IEJpYXNOdW1lcmljUmFuZ2VfMS5iaWFzTnVtZXJpY1JhbmdlKHRoaXMubWluLCB0aGlzLm1heCwgQmlhc051bWVyaWNSYW5nZV8xLmludGVnZXJMb2dMaWtlKTtcbiAgICAgICAgaWYgKHJhbmdlcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIHJldHVybiByYW5nZXNbMF07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaWQgPSBtcm5nLm5leHRJbnQoLTIgKiAocmFuZ2VzLmxlbmd0aCAtIDEpLCByYW5nZXMubGVuZ3RoIC0gMik7XG4gICAgICAgIHJldHVybiBpZCA8IDAgPyByYW5nZXNbMF0gOiByYW5nZXNbaWQgKyAxXTtcbiAgICB9XG4gICAgaXNMYXN0Q2hhbmNlVHJ5KGN1cnJlbnQsIGNvbnRleHQpIHtcbiAgICAgICAgaWYgKGN1cnJlbnQgPiAwKVxuICAgICAgICAgICAgcmV0dXJuIGN1cnJlbnQgPT09IGNvbnRleHQgKyAxICYmIGN1cnJlbnQgPiB0aGlzLm1pbjtcbiAgICAgICAgaWYgKGN1cnJlbnQgPCAwKVxuICAgICAgICAgICAgcmV0dXJuIGN1cnJlbnQgPT09IGNvbnRleHQgLSAxICYmIGN1cnJlbnQgPCB0aGlzLm1heDtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBzdGF0aWMgaXNWYWxpZENvbnRleHQoY3VycmVudCwgY29udGV4dCkge1xuICAgICAgICBpZiAoY29udGV4dCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBjb250ZXh0ICE9PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGNvbnRleHQgdHlwZSBwYXNzZWQgdG8gSW50ZWdlckFyYml0cmFyeSAoIzEpYCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbnRleHQgIT09IDAgJiYgTWF0aC5zaWduKGN1cnJlbnQpICE9PSBNYXRoLnNpZ24oY29udGV4dCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBjb250ZXh0IHZhbHVlIHBhc3NlZCB0byBJbnRlZ2VyQXJiaXRyYXJ5ICgjMilgKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG59XG5leHBvcnRzLkludGVnZXJBcmJpdHJhcnkgPSBJbnRlZ2VyQXJiaXRyYXJ5O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkxhenlBcmJpdHJhcnkgPSB2b2lkIDA7XG5jb25zdCBOZXh0QXJiaXRyYXJ5XzEgPSByZXF1aXJlKFwiLi4vLi4vY2hlY2svYXJiaXRyYXJ5L2RlZmluaXRpb24vTmV4dEFyYml0cmFyeVwiKTtcbmNsYXNzIExhenlBcmJpdHJhcnkgZXh0ZW5kcyBOZXh0QXJiaXRyYXJ5XzEuTmV4dEFyYml0cmFyeSB7XG4gICAgY29uc3RydWN0b3IobmFtZSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICB0aGlzLnVuZGVybHlpbmcgPSBudWxsO1xuICAgIH1cbiAgICBnZW5lcmF0ZShtcm5nLCBiaWFzRmFjdG9yKSB7XG4gICAgICAgIGlmICghdGhpcy51bmRlcmx5aW5nKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYExhenkgYXJiaXRyYXJ5ICR7SlNPTi5zdHJpbmdpZnkodGhpcy5uYW1lKX0gbm90IGNvcnJlY3RseSBpbml0aWFsaXplZGApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnVuZGVybHlpbmcuZ2VuZXJhdGUobXJuZywgYmlhc0ZhY3Rvcik7XG4gICAgfVxuICAgIGNhblNocmlua1dpdGhvdXRDb250ZXh0KHZhbHVlKSB7XG4gICAgICAgIGlmICghdGhpcy51bmRlcmx5aW5nKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYExhenkgYXJiaXRyYXJ5ICR7SlNPTi5zdHJpbmdpZnkodGhpcy5uYW1lKX0gbm90IGNvcnJlY3RseSBpbml0aWFsaXplZGApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnVuZGVybHlpbmcuY2FuU2hyaW5rV2l0aG91dENvbnRleHQodmFsdWUpO1xuICAgIH1cbiAgICBzaHJpbmsodmFsdWUsIGNvbnRleHQpIHtcbiAgICAgICAgaWYgKCF0aGlzLnVuZGVybHlpbmcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgTGF6eSBhcmJpdHJhcnkgJHtKU09OLnN0cmluZ2lmeSh0aGlzLm5hbWUpfSBub3QgY29ycmVjdGx5IGluaXRpYWxpemVkYCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMudW5kZXJseWluZy5zaHJpbmsodmFsdWUsIGNvbnRleHQpO1xuICAgIH1cbn1cbmV4cG9ydHMuTGF6eUFyYml0cmFyeSA9IExhenlBcmJpdHJhcnk7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuTWl4ZWRDYXNlQXJiaXRyYXJ5ID0gZXhwb3J0cy5jb21wdXRlTmV4dEZsYWdzID0gZXhwb3J0cy5jb3VudFRvZ2dsZWRCaXRzID0gdm9pZCAwO1xuY29uc3QgU3RyZWFtXzEgPSByZXF1aXJlKFwiLi4vLi4vc3RyZWFtL1N0cmVhbVwiKTtcbmNvbnN0IGJpZ1VpbnROXzEgPSByZXF1aXJlKFwiLi4vYmlnVWludE5cIik7XG5jb25zdCBOZXh0QXJiaXRyYXJ5XzEgPSByZXF1aXJlKFwiLi4vLi4vY2hlY2svYXJiaXRyYXJ5L2RlZmluaXRpb24vTmV4dEFyYml0cmFyeVwiKTtcbmNvbnN0IENvbnZlcnRlcnNfMSA9IHJlcXVpcmUoXCIuLi8uLi9jaGVjay9hcmJpdHJhcnkvZGVmaW5pdGlvbi9Db252ZXJ0ZXJzXCIpO1xuY29uc3QgTmV4dFZhbHVlXzEgPSByZXF1aXJlKFwiLi4vLi4vY2hlY2svYXJiaXRyYXJ5L2RlZmluaXRpb24vTmV4dFZhbHVlXCIpO1xuY29uc3QgTGF6eUl0ZXJhYmxlSXRlcmF0b3JfMSA9IHJlcXVpcmUoXCIuLi8uLi9zdHJlYW0vTGF6eUl0ZXJhYmxlSXRlcmF0b3JcIik7XG5mdW5jdGlvbiBjb3VudFRvZ2dsZWRCaXRzKG4pIHtcbiAgICBsZXQgY291bnQgPSAwO1xuICAgIHdoaWxlIChuID4gQmlnSW50KDApKSB7XG4gICAgICAgIGlmIChuICYgQmlnSW50KDEpKVxuICAgICAgICAgICAgKytjb3VudDtcbiAgICAgICAgbiA+Pj0gQmlnSW50KDEpO1xuICAgIH1cbiAgICByZXR1cm4gY291bnQ7XG59XG5leHBvcnRzLmNvdW50VG9nZ2xlZEJpdHMgPSBjb3VudFRvZ2dsZWRCaXRzO1xuZnVuY3Rpb24gY29tcHV0ZU5leHRGbGFncyhmbGFncywgbmV4dFNpemUpIHtcbiAgICBjb25zdCBhbGxvd2VkTWFzayA9IChCaWdJbnQoMSkgPDwgQmlnSW50KG5leHRTaXplKSkgLSBCaWdJbnQoMSk7XG4gICAgY29uc3QgcHJlc2VydmVkRmxhZ3MgPSBmbGFncyAmIGFsbG93ZWRNYXNrO1xuICAgIGxldCBudW1NaXNzaW5nRmxhZ3MgPSBjb3VudFRvZ2dsZWRCaXRzKGZsYWdzIC0gcHJlc2VydmVkRmxhZ3MpO1xuICAgIGxldCBuRmxhZ3MgPSBwcmVzZXJ2ZWRGbGFncztcbiAgICBmb3IgKGxldCBtYXNrID0gQmlnSW50KDEpOyBtYXNrIDw9IGFsbG93ZWRNYXNrICYmIG51bU1pc3NpbmdGbGFncyAhPT0gMDsgbWFzayA8PD0gQmlnSW50KDEpKSB7XG4gICAgICAgIGlmICghKG5GbGFncyAmIG1hc2spKSB7XG4gICAgICAgICAgICBuRmxhZ3MgfD0gbWFzaztcbiAgICAgICAgICAgIC0tbnVtTWlzc2luZ0ZsYWdzO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBuRmxhZ3M7XG59XG5leHBvcnRzLmNvbXB1dGVOZXh0RmxhZ3MgPSBjb21wdXRlTmV4dEZsYWdzO1xuY2xhc3MgTWl4ZWRDYXNlQXJiaXRyYXJ5IGV4dGVuZHMgTmV4dEFyYml0cmFyeV8xLk5leHRBcmJpdHJhcnkge1xuICAgIGNvbnN0cnVjdG9yKHN0cmluZ0FyYiwgdG9nZ2xlQ2FzZSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLnN0cmluZ0FyYiA9IHN0cmluZ0FyYjtcbiAgICAgICAgdGhpcy50b2dnbGVDYXNlID0gdG9nZ2xlQ2FzZTtcbiAgICB9XG4gICAgY29tcHV0ZVRvZ2dsZVBvc2l0aW9ucyhjaGFycykge1xuICAgICAgICBjb25zdCBwb3NpdGlvbnMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaWR4ID0gMDsgaWR4ICE9PSBjaGFycy5sZW5ndGg7ICsraWR4KSB7XG4gICAgICAgICAgICBpZiAodGhpcy50b2dnbGVDYXNlKGNoYXJzW2lkeF0pICE9PSBjaGFyc1tpZHhdKVxuICAgICAgICAgICAgICAgIHBvc2l0aW9ucy5wdXNoKGlkeCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBvc2l0aW9ucztcbiAgICB9XG4gICAgYXBwbHlGbGFnc09uQ2hhcnMoY2hhcnMsIGZsYWdzLCB0b2dnbGVQb3NpdGlvbnMpIHtcbiAgICAgICAgZm9yIChsZXQgaWR4ID0gMCwgbWFzayA9IEJpZ0ludCgxKTsgaWR4ICE9PSB0b2dnbGVQb3NpdGlvbnMubGVuZ3RoOyArK2lkeCwgbWFzayA8PD0gQmlnSW50KDEpKSB7XG4gICAgICAgICAgICBpZiAoZmxhZ3MgJiBtYXNrKVxuICAgICAgICAgICAgICAgIGNoYXJzW3RvZ2dsZVBvc2l0aW9uc1tpZHhdXSA9IHRoaXMudG9nZ2xlQ2FzZShjaGFyc1t0b2dnbGVQb3NpdGlvbnNbaWR4XV0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjaGFycztcbiAgICB9XG4gICAgYnVpbGRDb250ZXh0Rm9yKHJhd1N0cmluZ05leHRWYWx1ZSwgZmxhZ3NOZXh0VmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHJhd1N0cmluZzogcmF3U3RyaW5nTmV4dFZhbHVlLnZhbHVlLFxuICAgICAgICAgICAgcmF3U3RyaW5nQ29udGV4dDogcmF3U3RyaW5nTmV4dFZhbHVlLmNvbnRleHQsXG4gICAgICAgICAgICBmbGFnczogZmxhZ3NOZXh0VmFsdWUudmFsdWUsXG4gICAgICAgICAgICBmbGFnc0NvbnRleHQ6IGZsYWdzTmV4dFZhbHVlLmNvbnRleHQsXG4gICAgICAgIH07XG4gICAgfVxuICAgIGdlbmVyYXRlKG1ybmcsIGJpYXNGYWN0b3IpIHtcbiAgICAgICAgY29uc3QgcmF3U3RyaW5nTmV4dFZhbHVlID0gdGhpcy5zdHJpbmdBcmIuZ2VuZXJhdGUobXJuZywgYmlhc0ZhY3Rvcik7XG4gICAgICAgIGNvbnN0IGNoYXJzID0gWy4uLnJhd1N0cmluZ05leHRWYWx1ZS52YWx1ZV07XG4gICAgICAgIGNvbnN0IHRvZ2dsZVBvc2l0aW9ucyA9IHRoaXMuY29tcHV0ZVRvZ2dsZVBvc2l0aW9ucyhjaGFycyk7XG4gICAgICAgIGNvbnN0IGZsYWdzQXJiID0gQ29udmVydGVyc18xLmNvbnZlcnRUb05leHQoYmlnVWludE5fMS5iaWdVaW50Tih0b2dnbGVQb3NpdGlvbnMubGVuZ3RoKSk7XG4gICAgICAgIGNvbnN0IGZsYWdzTmV4dFZhbHVlID0gZmxhZ3NBcmIuZ2VuZXJhdGUobXJuZywgdW5kZWZpbmVkKTtcbiAgICAgICAgdGhpcy5hcHBseUZsYWdzT25DaGFycyhjaGFycywgZmxhZ3NOZXh0VmFsdWUudmFsdWUsIHRvZ2dsZVBvc2l0aW9ucyk7XG4gICAgICAgIHJldHVybiBuZXcgTmV4dFZhbHVlXzEuTmV4dFZhbHVlKGNoYXJzLmpvaW4oJycpLCB0aGlzLmJ1aWxkQ29udGV4dEZvcihyYXdTdHJpbmdOZXh0VmFsdWUsIGZsYWdzTmV4dFZhbHVlKSk7XG4gICAgfVxuICAgIGNhblNocmlua1dpdGhvdXRDb250ZXh0KHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgc2hyaW5rKF92YWx1ZSwgY29udGV4dCkge1xuICAgICAgICBpZiAoY29udGV4dCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gU3RyZWFtXzEuU3RyZWFtLm5pbCgpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNvbnRleHRTYWZlID0gY29udGV4dDtcbiAgICAgICAgY29uc3QgcmF3U3RyaW5nID0gY29udGV4dFNhZmUucmF3U3RyaW5nO1xuICAgICAgICBjb25zdCBmbGFncyA9IGNvbnRleHRTYWZlLmZsYWdzO1xuICAgICAgICByZXR1cm4gdGhpcy5zdHJpbmdBcmJcbiAgICAgICAgICAgIC5zaHJpbmsocmF3U3RyaW5nLCBjb250ZXh0U2FmZS5yYXdTdHJpbmdDb250ZXh0KVxuICAgICAgICAgICAgLm1hcCgoblJhd1N0cmluZ05leHRWYWx1ZSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgbkNoYXJzID0gWy4uLm5SYXdTdHJpbmdOZXh0VmFsdWUudmFsdWVdO1xuICAgICAgICAgICAgY29uc3QgblRvZ2dsZVBvc2l0aW9ucyA9IHRoaXMuY29tcHV0ZVRvZ2dsZVBvc2l0aW9ucyhuQ2hhcnMpO1xuICAgICAgICAgICAgY29uc3QgbkZsYWdzID0gY29tcHV0ZU5leHRGbGFncyhmbGFncywgblRvZ2dsZVBvc2l0aW9ucy5sZW5ndGgpO1xuICAgICAgICAgICAgdGhpcy5hcHBseUZsYWdzT25DaGFycyhuQ2hhcnMsIG5GbGFncywgblRvZ2dsZVBvc2l0aW9ucyk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IE5leHRWYWx1ZV8xLk5leHRWYWx1ZShuQ2hhcnMuam9pbignJyksIHRoaXMuYnVpbGRDb250ZXh0Rm9yKG5SYXdTdHJpbmdOZXh0VmFsdWUsIG5ldyBOZXh0VmFsdWVfMS5OZXh0VmFsdWUobkZsYWdzLCB1bmRlZmluZWQpKSk7XG4gICAgICAgIH0pXG4gICAgICAgICAgICAuam9pbihMYXp5SXRlcmFibGVJdGVyYXRvcl8xLm1ha2VMYXp5KCgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGNoYXJzID0gWy4uLnJhd1N0cmluZ107XG4gICAgICAgICAgICBjb25zdCB0b2dnbGVQb3NpdGlvbnMgPSB0aGlzLmNvbXB1dGVUb2dnbGVQb3NpdGlvbnMoY2hhcnMpO1xuICAgICAgICAgICAgcmV0dXJuIENvbnZlcnRlcnNfMS5jb252ZXJ0VG9OZXh0KGJpZ1VpbnROXzEuYmlnVWludE4odG9nZ2xlUG9zaXRpb25zLmxlbmd0aCkpXG4gICAgICAgICAgICAgICAgLnNocmluayhmbGFncywgY29udGV4dFNhZmUuZmxhZ3NDb250ZXh0KVxuICAgICAgICAgICAgICAgIC5tYXAoKG5GbGFnc05leHRWYWx1ZSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IG5DaGFycyA9IGNoYXJzLnNsaWNlKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5hcHBseUZsYWdzT25DaGFycyhuQ2hhcnMsIG5GbGFnc05leHRWYWx1ZS52YWx1ZSwgdG9nZ2xlUG9zaXRpb25zKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IE5leHRWYWx1ZV8xLk5leHRWYWx1ZShuQ2hhcnMuam9pbignJyksIHRoaXMuYnVpbGRDb250ZXh0Rm9yKG5ldyBOZXh0VmFsdWVfMS5OZXh0VmFsdWUocmF3U3RyaW5nLCBjb250ZXh0U2FmZS5yYXdTdHJpbmdDb250ZXh0KSwgbkZsYWdzTmV4dFZhbHVlKSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSkpO1xuICAgIH1cbn1cbmV4cG9ydHMuTWl4ZWRDYXNlQXJiaXRyYXJ5ID0gTWl4ZWRDYXNlQXJiaXRyYXJ5O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlNjaGVkdWxlckFyYml0cmFyeSA9IHZvaWQgMDtcbmNvbnN0IE5leHRBcmJpdHJhcnlfMSA9IHJlcXVpcmUoXCIuLi8uLi9jaGVjay9hcmJpdHJhcnkvZGVmaW5pdGlvbi9OZXh0QXJiaXRyYXJ5XCIpO1xuY29uc3QgTmV4dFZhbHVlXzEgPSByZXF1aXJlKFwiLi4vLi4vY2hlY2svYXJiaXRyYXJ5L2RlZmluaXRpb24vTmV4dFZhbHVlXCIpO1xuY29uc3QgU3RyZWFtXzEgPSByZXF1aXJlKFwiLi4vLi4vc3RyZWFtL1N0cmVhbVwiKTtcbmNvbnN0IFNjaGVkdWxlckltcGxlbV8xID0gcmVxdWlyZShcIi4vaW1wbGVtZW50YXRpb25zL1NjaGVkdWxlckltcGxlbVwiKTtcbmZ1bmN0aW9uIGJ1aWxkTmV4dFRhc2tJbmRleChtcm5nKSB7XG4gICAgY29uc3QgY2xvbmVkTXJuZyA9IG1ybmcuY2xvbmUoKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBjbG9uZTogKCkgPT4gYnVpbGROZXh0VGFza0luZGV4KGNsb25lZE1ybmcpLFxuICAgICAgICBuZXh0VGFza0luZGV4OiAoc2NoZWR1bGVkVGFza3MpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBtcm5nLm5leHRJbnQoMCwgc2NoZWR1bGVkVGFza3MubGVuZ3RoIC0gMSk7XG4gICAgICAgIH0sXG4gICAgfTtcbn1cbmNsYXNzIFNjaGVkdWxlckFyYml0cmFyeSBleHRlbmRzIE5leHRBcmJpdHJhcnlfMS5OZXh0QXJiaXRyYXJ5IHtcbiAgICBjb25zdHJ1Y3RvcihhY3QpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5hY3QgPSBhY3Q7XG4gICAgfVxuICAgIGdlbmVyYXRlKG1ybmcsIF9iaWFzRmFjdG9yKSB7XG4gICAgICAgIHJldHVybiBuZXcgTmV4dFZhbHVlXzEuTmV4dFZhbHVlKG5ldyBTY2hlZHVsZXJJbXBsZW1fMS5TY2hlZHVsZXJJbXBsZW0odGhpcy5hY3QsIGJ1aWxkTmV4dFRhc2tJbmRleChtcm5nLmNsb25lKCkpKSwgdW5kZWZpbmVkKTtcbiAgICB9XG4gICAgY2FuU2hyaW5rV2l0aG91dENvbnRleHQodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBzaHJpbmsoX3ZhbHVlLCBfY29udGV4dCkge1xuICAgICAgICByZXR1cm4gU3RyZWFtXzEuU3RyZWFtLm5pbCgpO1xuICAgIH1cbn1cbmV4cG9ydHMuU2NoZWR1bGVyQXJiaXRyYXJ5ID0gU2NoZWR1bGVyQXJiaXRyYXJ5O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlN0cmVhbUFyYml0cmFyeSA9IHZvaWQgMDtcbmNvbnN0IE5leHRBcmJpdHJhcnlfMSA9IHJlcXVpcmUoXCIuLi8uLi9jaGVjay9hcmJpdHJhcnkvZGVmaW5pdGlvbi9OZXh0QXJiaXRyYXJ5XCIpO1xuY29uc3QgTmV4dFZhbHVlXzEgPSByZXF1aXJlKFwiLi4vLi4vY2hlY2svYXJiaXRyYXJ5L2RlZmluaXRpb24vTmV4dFZhbHVlXCIpO1xuY29uc3Qgc3ltYm9sc18xID0gcmVxdWlyZShcIi4uLy4uL2NoZWNrL3N5bWJvbHNcIik7XG5jb25zdCBTdHJlYW1fMSA9IHJlcXVpcmUoXCIuLi8uLi9zdHJlYW0vU3RyZWFtXCIpO1xuY29uc3Qgc3RyaW5naWZ5XzEgPSByZXF1aXJlKFwiLi4vLi4vdXRpbHMvc3RyaW5naWZ5XCIpO1xuZnVuY3Rpb24gcHJldHR5UHJpbnQoc2VlblZhbHVlc1N0cmluZ3MpIHtcbiAgICByZXR1cm4gYFN0cmVhbSgke3NlZW5WYWx1ZXNTdHJpbmdzLmpvaW4oJywnKX3igKYpYDtcbn1cbmNsYXNzIFN0cmVhbUFyYml0cmFyeSBleHRlbmRzIE5leHRBcmJpdHJhcnlfMS5OZXh0QXJiaXRyYXJ5IHtcbiAgICBjb25zdHJ1Y3RvcihhcmIpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5hcmIgPSBhcmI7XG4gICAgfVxuICAgIGdlbmVyYXRlKG1ybmcsIGJpYXNGYWN0b3IpIHtcbiAgICAgICAgY29uc3QgYXBwbGllZEJpYXNGYWN0b3IgPSBiaWFzRmFjdG9yICE9PSB1bmRlZmluZWQgJiYgbXJuZy5uZXh0SW50KDEsIGJpYXNGYWN0b3IpID09PSAxID8gYmlhc0ZhY3RvciA6IHVuZGVmaW5lZDtcbiAgICAgICAgY29uc3QgZW5yaWNoZWRQcm9kdWNlciA9ICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHNlZW5WYWx1ZXMgPSBbXTtcbiAgICAgICAgICAgIGNvbnN0IGcgPSBmdW5jdGlvbiogKGFyYiwgY2xvbmVkTXJuZykge1xuICAgICAgICAgICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gYXJiLmdlbmVyYXRlKGNsb25lZE1ybmcsIGFwcGxpZWRCaWFzRmFjdG9yKS52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgc2VlblZhbHVlcy5wdXNoKHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgeWllbGQgdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNvbnN0IHMgPSBuZXcgU3RyZWFtXzEuU3RyZWFtKGcodGhpcy5hcmIsIG1ybmcuY2xvbmUoKSkpO1xuICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHMsIHtcbiAgICAgICAgICAgICAgICB0b1N0cmluZzogeyB2YWx1ZTogKCkgPT4gcHJldHR5UHJpbnQoc2VlblZhbHVlcy5tYXAoc3RyaW5naWZ5XzEuc3RyaW5naWZ5KSkgfSxcbiAgICAgICAgICAgICAgICBbc3RyaW5naWZ5XzEudG9TdHJpbmdNZXRob2RdOiB7IHZhbHVlOiAoKSA9PiBwcmV0dHlQcmludChzZWVuVmFsdWVzLm1hcChzdHJpbmdpZnlfMS5zdHJpbmdpZnkpKSB9LFxuICAgICAgICAgICAgICAgIFtzdHJpbmdpZnlfMS5hc3luY1RvU3RyaW5nTWV0aG9kXTogeyB2YWx1ZTogYXN5bmMgKCkgPT4gcHJldHR5UHJpbnQoYXdhaXQgUHJvbWlzZS5hbGwoc2VlblZhbHVlcy5tYXAoc3RyaW5naWZ5XzEuYXN5bmNTdHJpbmdpZnkpKSkgfSxcbiAgICAgICAgICAgICAgICBbc3ltYm9sc18xLmNsb25lTWV0aG9kXTogeyB2YWx1ZTogZW5yaWNoZWRQcm9kdWNlciwgZW51bWVyYWJsZTogdHJ1ZSB9LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBuZXcgTmV4dFZhbHVlXzEuTmV4dFZhbHVlKGVucmljaGVkUHJvZHVjZXIoKSwgdW5kZWZpbmVkKTtcbiAgICB9XG4gICAgY2FuU2hyaW5rV2l0aG91dENvbnRleHQodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBzaHJpbmsoX3ZhbHVlLCBfY29udGV4dCkge1xuICAgICAgICByZXR1cm4gU3RyZWFtXzEuU3RyZWFtLm5pbCgpO1xuICAgIH1cbn1cbmV4cG9ydHMuU3RyZWFtQXJiaXRyYXJ5ID0gU3RyZWFtQXJiaXRyYXJ5O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlR1cGxlQXJiaXRyYXJ5ID0gdm9pZCAwO1xuY29uc3QgU3RyZWFtXzEgPSByZXF1aXJlKFwiLi4vLi4vc3RyZWFtL1N0cmVhbVwiKTtcbmNvbnN0IHN5bWJvbHNfMSA9IHJlcXVpcmUoXCIuLi8uLi9jaGVjay9zeW1ib2xzXCIpO1xuY29uc3QgTmV4dEFyYml0cmFyeV8xID0gcmVxdWlyZShcIi4uLy4uL2NoZWNrL2FyYml0cmFyeS9kZWZpbml0aW9uL05leHRBcmJpdHJhcnlcIik7XG5jb25zdCBOZXh0VmFsdWVfMSA9IHJlcXVpcmUoXCIuLi8uLi9jaGVjay9hcmJpdHJhcnkvZGVmaW5pdGlvbi9OZXh0VmFsdWVcIik7XG5jbGFzcyBUdXBsZUFyYml0cmFyeSBleHRlbmRzIE5leHRBcmJpdHJhcnlfMS5OZXh0QXJiaXRyYXJ5IHtcbiAgICBjb25zdHJ1Y3RvcihhcmJzKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuYXJicyA9IGFyYnM7XG4gICAgICAgIGZvciAobGV0IGlkeCA9IDA7IGlkeCAhPT0gYXJicy5sZW5ndGg7ICsraWR4KSB7XG4gICAgICAgICAgICBjb25zdCBhcmIgPSBhcmJzW2lkeF07XG4gICAgICAgICAgICBpZiAoYXJiID09IG51bGwgfHwgYXJiLmdlbmVyYXRlID09IG51bGwpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHBhcmFtZXRlciBlbmNvdW50ZXJlZCBhdCBpbmRleCAke2lkeH06IGV4cGVjdGluZyBhbiBBcmJpdHJhcnlgKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzdGF0aWMgbWFrZUl0Q2xvbmVhYmxlKHZzLCB2YWx1ZXMpIHtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh2cywgc3ltYm9sc18xLmNsb25lTWV0aG9kLCB7XG4gICAgICAgICAgICB2YWx1ZTogKCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNsb25lZCA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGlkeCA9IDA7IGlkeCAhPT0gdmFsdWVzLmxlbmd0aDsgKytpZHgpIHtcbiAgICAgICAgICAgICAgICAgICAgY2xvbmVkLnB1c2godmFsdWVzW2lkeF0udmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBUdXBsZUFyYml0cmFyeS5tYWtlSXRDbG9uZWFibGUoY2xvbmVkLCB2YWx1ZXMpO1xuICAgICAgICAgICAgICAgIHJldHVybiBjbG9uZWQ7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgc3RhdGljIHdyYXBwZXIodmFsdWVzKSB7XG4gICAgICAgIGxldCBjbG9uZWFibGUgPSBmYWxzZTtcbiAgICAgICAgY29uc3QgdnMgPSBbXTtcbiAgICAgICAgY29uc3QgY3R4cyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpZHggPSAwOyBpZHggIT09IHZhbHVlcy5sZW5ndGg7ICsraWR4KSB7XG4gICAgICAgICAgICBjb25zdCB2ID0gdmFsdWVzW2lkeF07XG4gICAgICAgICAgICBjbG9uZWFibGUgPSBjbG9uZWFibGUgfHwgdi5oYXNUb0JlQ2xvbmVkO1xuICAgICAgICAgICAgdnMucHVzaCh2LnZhbHVlKTtcbiAgICAgICAgICAgIGN0eHMucHVzaCh2LmNvbnRleHQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjbG9uZWFibGUpIHtcbiAgICAgICAgICAgIFR1cGxlQXJiaXRyYXJ5Lm1ha2VJdENsb25lYWJsZSh2cywgdmFsdWVzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IE5leHRWYWx1ZV8xLk5leHRWYWx1ZSh2cywgY3R4cyk7XG4gICAgfVxuICAgIGdlbmVyYXRlKG1ybmcsIGJpYXNGYWN0b3IpIHtcbiAgICAgICAgcmV0dXJuIFR1cGxlQXJiaXRyYXJ5LndyYXBwZXIodGhpcy5hcmJzLm1hcCgoYSkgPT4gYS5nZW5lcmF0ZShtcm5nLCBiaWFzRmFjdG9yKSkpO1xuICAgIH1cbiAgICBjYW5TaHJpbmtXaXRob3V0Q29udGV4dCh2YWx1ZSkge1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkodmFsdWUpIHx8IHZhbHVlLmxlbmd0aCAhPT0gdGhpcy5hcmJzLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggIT09IHRoaXMuYXJicy5sZW5ndGg7ICsraW5kZXgpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5hcmJzW2luZGV4XS5jYW5TaHJpbmtXaXRob3V0Q29udGV4dCh2YWx1ZVtpbmRleF0pKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBzaHJpbmsodmFsdWUsIGNvbnRleHQpIHtcbiAgICAgICAgbGV0IHMgPSBTdHJlYW1fMS5TdHJlYW0ubmlsKCk7XG4gICAgICAgIGNvbnN0IHNhZmVDb250ZXh0ID0gQXJyYXkuaXNBcnJheShjb250ZXh0KSA/IGNvbnRleHQgOiBbXTtcbiAgICAgICAgZm9yIChsZXQgaWR4ID0gMDsgaWR4ICE9PSB0aGlzLmFyYnMubGVuZ3RoOyArK2lkeCkge1xuICAgICAgICAgICAgY29uc3Qgc2hyaW5rc0ZvckluZGV4ID0gdGhpcy5hcmJzW2lkeF1cbiAgICAgICAgICAgICAgICAuc2hyaW5rKHZhbHVlW2lkeF0sIHNhZmVDb250ZXh0W2lkeF0pXG4gICAgICAgICAgICAgICAgLm1hcCgodikgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IG5leHRWYWx1ZXMgPSB2YWx1ZS5tYXAoKHYsIGlkeCkgPT4gbmV3IE5leHRWYWx1ZV8xLk5leHRWYWx1ZShzeW1ib2xzXzEuY2xvbmVJZk5lZWRlZCh2KSwgc2FmZUNvbnRleHRbaWR4XSkpO1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXh0VmFsdWVzXG4gICAgICAgICAgICAgICAgICAgIC5zbGljZSgwLCBpZHgpXG4gICAgICAgICAgICAgICAgICAgIC5jb25jYXQoW3ZdKVxuICAgICAgICAgICAgICAgICAgICAuY29uY2F0KG5leHRWYWx1ZXMuc2xpY2UoaWR4ICsgMSkpO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAubWFwKCh2YWx1ZXMpID0+IFR1cGxlQXJiaXRyYXJ5LndyYXBwZXIodmFsdWVzKSk7XG4gICAgICAgICAgICBzID0gcy5qb2luKHNocmlua3NGb3JJbmRleCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHM7XG4gICAgfVxufVxuZXhwb3J0cy5UdXBsZUFyYml0cmFyeSA9IFR1cGxlQXJiaXRyYXJ5O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmJ1aWxkQ2hhcmFjdGVyQXJiaXRyYXJ5ID0gdm9pZCAwO1xuY29uc3QgQ29udmVydGVyc18xID0gcmVxdWlyZShcIi4uLy4uLy4uL2NoZWNrL2FyYml0cmFyeS9kZWZpbml0aW9uL0NvbnZlcnRlcnNcIik7XG5jb25zdCBpbnRlZ2VyXzEgPSByZXF1aXJlKFwiLi4vLi4vaW50ZWdlclwiKTtcbmNvbnN0IEluZGV4VG9DaGFyU3RyaW5nXzEgPSByZXF1aXJlKFwiLi4vbWFwcGVycy9JbmRleFRvQ2hhclN0cmluZ1wiKTtcbmZ1bmN0aW9uIGJ1aWxkQ2hhcmFjdGVyQXJiaXRyYXJ5KG1pbiwgbWF4LCBtYXBUb0NvZGUsIHVubWFwRnJvbUNvZGUpIHtcbiAgICByZXR1cm4gQ29udmVydGVyc18xLmNvbnZlcnRGcm9tTmV4dChDb252ZXJ0ZXJzXzEuY29udmVydFRvTmV4dChpbnRlZ2VyXzEuaW50ZWdlcihtaW4sIG1heCkpLm1hcCgobikgPT4gSW5kZXhUb0NoYXJTdHJpbmdfMS5pbmRleFRvQ2hhclN0cmluZ01hcHBlcihtYXBUb0NvZGUobikpLCAoYykgPT4gdW5tYXBGcm9tQ29kZShJbmRleFRvQ2hhclN0cmluZ18xLmluZGV4VG9DaGFyU3RyaW5nVW5tYXBwZXIoYykpKSk7XG59XG5leHBvcnRzLmJ1aWxkQ2hhcmFjdGVyQXJiaXRyYXJ5ID0gYnVpbGRDaGFyYWN0ZXJBcmJpdHJhcnk7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuYnVpbGRDb21wYXJlRnVuY3Rpb25BcmJpdHJhcnkgPSB2b2lkIDA7XG5jb25zdCBUZXh0RXNjYXBlcl8xID0gcmVxdWlyZShcIi4uLy4uLy4uL2NoZWNrL2FyYml0cmFyeS9oZWxwZXJzL1RleHRFc2NhcGVyXCIpO1xuY29uc3Qgc3ltYm9sc18xID0gcmVxdWlyZShcIi4uLy4uLy4uL2NoZWNrL3N5bWJvbHNcIik7XG5jb25zdCBoYXNoXzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vdXRpbHMvaGFzaFwiKTtcbmNvbnN0IHN0cmluZ2lmeV8xID0gcmVxdWlyZShcIi4uLy4uLy4uL3V0aWxzL3N0cmluZ2lmeVwiKTtcbmNvbnN0IGludGVnZXJfMSA9IHJlcXVpcmUoXCIuLi8uLi9pbnRlZ2VyXCIpO1xuY29uc3QgdHVwbGVfMSA9IHJlcXVpcmUoXCIuLi8uLi90dXBsZVwiKTtcbmZ1bmN0aW9uIGJ1aWxkQ29tcGFyZUZ1bmN0aW9uQXJiaXRyYXJ5KGNtcCkge1xuICAgIHJldHVybiB0dXBsZV8xLnR1cGxlKGludGVnZXJfMS5pbnRlZ2VyKCkubm9TaHJpbmsoKSwgaW50ZWdlcl8xLmludGVnZXIoMSwgMHhmZmZmZmZmZikubm9TaHJpbmsoKSkubWFwKChbc2VlZCwgaGFzaEVudlNpemVdKSA9PiB7XG4gICAgICAgIGNvbnN0IHByb2R1Y2VyID0gKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgcmVjb3JkZWQgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGYgPSAoYSwgYikgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlcHJBID0gc3RyaW5naWZ5XzEuc3RyaW5naWZ5KGEpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlcHJCID0gc3RyaW5naWZ5XzEuc3RyaW5naWZ5KGIpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGhBID0gaGFzaF8xLmhhc2goYCR7c2VlZH0ke3JlcHJBfWApICUgaGFzaEVudlNpemU7XG4gICAgICAgICAgICAgICAgY29uc3QgaEIgPSBoYXNoXzEuaGFzaChgJHtzZWVkfSR7cmVwckJ9YCkgJSBoYXNoRW52U2l6ZTtcbiAgICAgICAgICAgICAgICBjb25zdCB2YWwgPSBjbXAoaEEsIGhCKTtcbiAgICAgICAgICAgICAgICByZWNvcmRlZFtgWyR7cmVwckF9LCR7cmVwckJ9XWBdID0gdmFsO1xuICAgICAgICAgICAgICAgIHJldHVybiB2YWw7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oZiwge1xuICAgICAgICAgICAgICAgIHRvU3RyaW5nOiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHNlZW5WYWx1ZXMgPSBPYmplY3Qua2V5cyhyZWNvcmRlZClcbiAgICAgICAgICAgICAgICAgICAgICAgIC5zb3J0KClcbiAgICAgICAgICAgICAgICAgICAgICAgIC5tYXAoKGspID0+IGAke2t9ID0+ICR7c3RyaW5naWZ5XzEuc3RyaW5naWZ5KHJlY29yZGVkW2tdKX1gKVxuICAgICAgICAgICAgICAgICAgICAgICAgLm1hcCgobGluZSkgPT4gYC8qICR7VGV4dEVzY2FwZXJfMS5lc2NhcGVGb3JNdWx0aWxpbmVDb21tZW50cyhsaW5lKX0gKi9gKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGBmdW5jdGlvbihhLCBiKSB7XG4gIC8vIFdpdGggaGFzaCBhbmQgc3RyaW5naWZ5IGNvbWluZyBmcm9tIGZhc3QtY2hlY2ske3NlZW5WYWx1ZXMubGVuZ3RoICE9PSAwID8gYFxcbiAgJHtzZWVuVmFsdWVzLmpvaW4oJ1xcbiAgJyl9YCA6ICcnfVxuICBjb25zdCBjbXAgPSAke2NtcH07XG4gIGNvbnN0IGhBID0gaGFzaCgnJHtzZWVkfScgKyBzdHJpbmdpZnkoYSkpICUgJHtoYXNoRW52U2l6ZX07XG4gIGNvbnN0IGhCID0gaGFzaCgnJHtzZWVkfScgKyBzdHJpbmdpZnkoYikpICUgJHtoYXNoRW52U2l6ZX07XG4gIHJldHVybiBjbXAoaEEsIGhCKTtcbn1gO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgW3N5bWJvbHNfMS5jbG9uZU1ldGhvZF06IHByb2R1Y2VyLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBwcm9kdWNlcigpO1xuICAgIH0pO1xufVxuZXhwb3J0cy5idWlsZENvbXBhcmVGdW5jdGlvbkFyYml0cmFyeSA9IGJ1aWxkQ29tcGFyZUZ1bmN0aW9uQXJiaXRyYXJ5O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmJ1aWxkUGFydGlhbFJlY29yZEFyYml0cmFyeSA9IHZvaWQgMDtcbmNvbnN0IENvbnZlcnRlcnNfMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi9jaGVjay9hcmJpdHJhcnkvZGVmaW5pdGlvbi9Db252ZXJ0ZXJzXCIpO1xuY29uc3Qgb3B0aW9uXzEgPSByZXF1aXJlKFwiLi4vLi4vb3B0aW9uXCIpO1xuY29uc3QgdHVwbGVfMSA9IHJlcXVpcmUoXCIuLi8uLi90dXBsZVwiKTtcbmNvbnN0IEVudW1lcmFibGVLZXlzRXh0cmFjdG9yXzEgPSByZXF1aXJlKFwiLi4vaGVscGVycy9FbnVtZXJhYmxlS2V5c0V4dHJhY3RvclwiKTtcbmNvbnN0IFZhbHVlc0FuZFNlcGFyYXRlS2V5c1RvT2JqZWN0XzEgPSByZXF1aXJlKFwiLi4vbWFwcGVycy9WYWx1ZXNBbmRTZXBhcmF0ZUtleXNUb09iamVjdFwiKTtcbmNvbnN0IG5vS2V5VmFsdWUgPSBTeW1ib2woJ25vLWtleScpO1xuZnVuY3Rpb24gYnVpbGRQYXJ0aWFsUmVjb3JkQXJiaXRyYXJ5KHJlY29yZE1vZGVsLCByZXF1aXJlZEtleXMpIHtcbiAgICBjb25zdCBrZXlzID0gRW51bWVyYWJsZUtleXNFeHRyYWN0b3JfMS5leHRyYWN0RW51bWVyYWJsZUtleXMocmVjb3JkTW9kZWwpO1xuICAgIGNvbnN0IGFyYnMgPSBbXTtcbiAgICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4ICE9PSBrZXlzLmxlbmd0aDsgKytpbmRleCkge1xuICAgICAgICBjb25zdCBrID0ga2V5c1tpbmRleF07XG4gICAgICAgIGNvbnN0IHJlcXVpcmVkQXJiaXRyYXJ5ID0gcmVjb3JkTW9kZWxba107XG4gICAgICAgIGlmIChyZXF1aXJlZEtleXMgPT09IHVuZGVmaW5lZCB8fCByZXF1aXJlZEtleXMuaW5kZXhPZihrKSAhPT0gLTEpXG4gICAgICAgICAgICBhcmJzLnB1c2gocmVxdWlyZWRBcmJpdHJhcnkpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICBhcmJzLnB1c2gob3B0aW9uXzEub3B0aW9uKHJlcXVpcmVkQXJiaXRyYXJ5LCB7IG5pbDogbm9LZXlWYWx1ZSB9KSk7XG4gICAgfVxuICAgIHJldHVybiBDb252ZXJ0ZXJzXzEuY29udmVydEZyb21OZXh0KENvbnZlcnRlcnNfMS5jb252ZXJ0VG9OZXh0KHR1cGxlXzEudHVwbGUoLi4uYXJicykpLm1hcChWYWx1ZXNBbmRTZXBhcmF0ZUtleXNUb09iamVjdF8xLmJ1aWxkVmFsdWVzQW5kU2VwYXJhdGVLZXlzVG9PYmplY3RNYXBwZXIoa2V5cywgbm9LZXlWYWx1ZSksIFZhbHVlc0FuZFNlcGFyYXRlS2V5c1RvT2JqZWN0XzEuYnVpbGRWYWx1ZXNBbmRTZXBhcmF0ZUtleXNUb09iamVjdFVubWFwcGVyKGtleXMsIG5vS2V5VmFsdWUpKSk7XG59XG5leHBvcnRzLmJ1aWxkUGFydGlhbFJlY29yZEFyYml0cmFyeSA9IGJ1aWxkUGFydGlhbFJlY29yZEFyYml0cmFyeTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5idWlsZFN0cmluZ2lmaWVkTmF0QXJiaXRyYXJ5ID0gdm9pZCAwO1xuY29uc3QgQ29udmVydGVyc18xID0gcmVxdWlyZShcIi4uLy4uLy4uL2NoZWNrL2FyYml0cmFyeS9kZWZpbml0aW9uL0NvbnZlcnRlcnNcIik7XG5jb25zdCBjb25zdGFudEZyb21fMSA9IHJlcXVpcmUoXCIuLi8uLi9jb25zdGFudEZyb21cIik7XG5jb25zdCBuYXRfMSA9IHJlcXVpcmUoXCIuLi8uLi9uYXRcIik7XG5jb25zdCB0dXBsZV8xID0gcmVxdWlyZShcIi4uLy4uL3R1cGxlXCIpO1xuY29uc3QgTmF0VG9TdHJpbmdpZmllZE5hdF8xID0gcmVxdWlyZShcIi4uL21hcHBlcnMvTmF0VG9TdHJpbmdpZmllZE5hdFwiKTtcbmZ1bmN0aW9uIGJ1aWxkU3RyaW5naWZpZWROYXRBcmJpdHJhcnkobWF4VmFsdWUpIHtcbiAgICByZXR1cm4gQ29udmVydGVyc18xLmNvbnZlcnRGcm9tTmV4dChDb252ZXJ0ZXJzXzEuY29udmVydFRvTmV4dCh0dXBsZV8xLnR1cGxlKGNvbnN0YW50RnJvbV8xLmNvbnN0YW50RnJvbSgnZGVjJywgJ29jdCcsICdoZXgnKSwgbmF0XzEubmF0KG1heFZhbHVlKSkpLm1hcChOYXRUb1N0cmluZ2lmaWVkTmF0XzEubmF0VG9TdHJpbmdpZmllZE5hdE1hcHBlciwgTmF0VG9TdHJpbmdpZmllZE5hdF8xLm5hdFRvU3RyaW5naWZpZWROYXRVbm1hcHBlcikpO1xufVxuZXhwb3J0cy5idWlsZFN0cmluZ2lmaWVkTmF0QXJiaXRyYXJ5ID0gYnVpbGRTdHJpbmdpZmllZE5hdEFyYml0cmFyeTtcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fcmVzdCA9ICh0aGlzICYmIHRoaXMuX19yZXN0KSB8fCBmdW5jdGlvbiAocywgZSkge1xuICAgIHZhciB0ID0ge307XG4gICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApICYmIGUuaW5kZXhPZihwKSA8IDApXG4gICAgICAgIHRbcF0gPSBzW3BdO1xuICAgIGlmIChzICE9IG51bGwgJiYgdHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPT09IFwiZnVuY3Rpb25cIilcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIHAgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHMpOyBpIDwgcC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKGUuaW5kZXhPZihwW2ldKSA8IDAgJiYgT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHMsIHBbaV0pKVxuICAgICAgICAgICAgICAgIHRbcFtpXV0gPSBzW3BbaV1dO1xuICAgICAgICB9XG4gICAgcmV0dXJuIHQ7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy50eXBlZEludEFycmF5QXJiaXRyYXJ5QXJiaXRyYXJ5QnVpbGRlciA9IHZvaWQgMDtcbmNvbnN0IGFycmF5XzEgPSByZXF1aXJlKFwiLi4vLi4vYXJyYXlcIik7XG5mdW5jdGlvbiB0eXBlZEludEFycmF5QXJiaXRyYXJ5QXJiaXRyYXJ5QnVpbGRlcihjb25zdHJhaW50cywgZGVmYXVsdE1pbiwgZGVmYXVsdE1heCwgVHlwZWRBcnJheUNsYXNzLCBhcmJpdHJhcnlCdWlsZGVyKSB7XG4gICAgY29uc3QgZ2VuZXJhdG9yTmFtZSA9IFR5cGVkQXJyYXlDbGFzcy5uYW1lO1xuICAgIGNvbnN0IHsgbWluID0gZGVmYXVsdE1pbiwgbWF4ID0gZGVmYXVsdE1heCB9ID0gY29uc3RyYWludHMsIGFycmF5Q29uc3RyYWludHMgPSBfX3Jlc3QoY29uc3RyYWludHMsIFtcIm1pblwiLCBcIm1heFwiXSk7XG4gICAgaWYgKG1pbiA+IG1heCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgcmFuZ2UgcGFzc2VkIHRvICR7Z2VuZXJhdG9yTmFtZX06IG1pbiBtdXN0IGJlIGxvd2VyIHRoYW4gb3IgZXF1YWwgdG8gbWF4YCk7XG4gICAgfVxuICAgIGlmIChtaW4gPCBkZWZhdWx0TWluKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBtaW4gdmFsdWUgcGFzc2VkIHRvICR7Z2VuZXJhdG9yTmFtZX06IG1pbiBtdXN0IGJlIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byAke2RlZmF1bHRNaW59YCk7XG4gICAgfVxuICAgIGlmIChtYXggPiBkZWZhdWx0TWF4KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBtYXggdmFsdWUgcGFzc2VkIHRvICR7Z2VuZXJhdG9yTmFtZX06IG1heCBtdXN0IGJlIGxvd2VyIHRoYW4gb3IgZXF1YWwgdG8gJHtkZWZhdWx0TWF4fWApO1xuICAgIH1cbiAgICByZXR1cm4gYXJyYXlfMS5hcnJheShhcmJpdHJhcnlCdWlsZGVyKHsgbWluLCBtYXggfSksIGFycmF5Q29uc3RyYWludHMpLm1hcCgoZGF0YSkgPT4gVHlwZWRBcnJheUNsYXNzLmZyb20oZGF0YSkpO1xufVxuZXhwb3J0cy50eXBlZEludEFycmF5QXJiaXRyYXJ5QXJiaXRyYXJ5QnVpbGRlciA9IHR5cGVkSW50QXJyYXlBcmJpdHJhcnlBcmJpdHJhcnlCdWlsZGVyO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmJpYXNOdW1lcmljUmFuZ2UgPSBleHBvcnRzLmJpZ0ludExvZ0xpa2UgPSBleHBvcnRzLmludGVnZXJMb2dMaWtlID0gdm9pZCAwO1xuZnVuY3Rpb24gaW50ZWdlckxvZ0xpa2Uodikge1xuICAgIHJldHVybiBNYXRoLmZsb29yKE1hdGgubG9nKHYpIC8gTWF0aC5sb2coMikpO1xufVxuZXhwb3J0cy5pbnRlZ2VyTG9nTGlrZSA9IGludGVnZXJMb2dMaWtlO1xuZnVuY3Rpb24gYmlnSW50TG9nTGlrZSh2KSB7XG4gICAgaWYgKHYgPT09IEJpZ0ludCgwKSlcbiAgICAgICAgcmV0dXJuIEJpZ0ludCgwKTtcbiAgICByZXR1cm4gQmlnSW50KHYudG9TdHJpbmcoKS5sZW5ndGgpO1xufVxuZXhwb3J0cy5iaWdJbnRMb2dMaWtlID0gYmlnSW50TG9nTGlrZTtcbmZ1bmN0aW9uIGJpYXNOdW1lcmljUmFuZ2UobWluLCBtYXgsIGxvZ0xpa2UpIHtcbiAgICBpZiAobWluID09PSBtYXgpIHtcbiAgICAgICAgcmV0dXJuIFt7IG1pbjogbWluLCBtYXg6IG1heCB9XTtcbiAgICB9XG4gICAgaWYgKG1pbiA8IDAgJiYgbWF4ID4gMCkge1xuICAgICAgICBjb25zdCBsb2dNaW4gPSBsb2dMaWtlKC1taW4pO1xuICAgICAgICBjb25zdCBsb2dNYXggPSBsb2dMaWtlKG1heCk7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB7IG1pbjogLWxvZ01pbiwgbWF4OiBsb2dNYXggfSxcbiAgICAgICAgICAgIHsgbWluOiAobWF4IC0gbG9nTWF4KSwgbWF4OiBtYXggfSxcbiAgICAgICAgICAgIHsgbWluOiBtaW4sIG1heDogbWluICsgbG9nTWluIH0sXG4gICAgICAgIF07XG4gICAgfVxuICAgIGNvbnN0IGxvZ0dhcCA9IGxvZ0xpa2UoKG1heCAtIG1pbikpO1xuICAgIGNvbnN0IGFyYkNsb3NlVG9NaW4gPSB7IG1pbjogbWluLCBtYXg6IG1pbiArIGxvZ0dhcCB9O1xuICAgIGNvbnN0IGFyYkNsb3NlVG9NYXggPSB7IG1pbjogKG1heCAtIGxvZ0dhcCksIG1heDogbWF4IH07XG4gICAgcmV0dXJuIG1pbiA8IDBcbiAgICAgICAgPyBbYXJiQ2xvc2VUb01heCwgYXJiQ2xvc2VUb01pbl1cbiAgICAgICAgOiBbYXJiQ2xvc2VUb01pbiwgYXJiQ2xvc2VUb01heF07XG59XG5leHBvcnRzLmJpYXNOdW1lcmljUmFuZ2UgPSBiaWFzTnVtZXJpY1JhbmdlO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmJ1aWxkQ29tcGFyZUZpbHRlciA9IHZvaWQgMDtcbmZ1bmN0aW9uIHN1YkFycmF5Q29udGFpbnModGFiLCB1cHBlckJvdW5kLCBpbmNsdWRlVmFsdWUpIHtcbiAgICBmb3IgKGxldCBpZHggPSAwOyBpZHggPCB1cHBlckJvdW5kOyArK2lkeCkge1xuICAgICAgICBpZiAoaW5jbHVkZVZhbHVlKHRhYltpZHhdKSlcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBzd2FwKHRhYiwgaWR4MSwgaWR4Mikge1xuICAgIGNvbnN0IHRlbXAgPSB0YWJbaWR4MV07XG4gICAgdGFiW2lkeDFdID0gdGFiW2lkeDJdO1xuICAgIHRhYltpZHgyXSA9IHRlbXA7XG59XG5mdW5jdGlvbiBidWlsZENvbXBhcmVGaWx0ZXIoY29tcGFyZSkge1xuICAgIHJldHVybiAodGFiKSA9PiB7XG4gICAgICAgIGxldCBmaW5hbExlbmd0aCA9IHRhYi5sZW5ndGg7XG4gICAgICAgIGZvciAobGV0IGlkeCA9IHRhYi5sZW5ndGggLSAxOyBpZHggIT09IC0xOyAtLWlkeCkge1xuICAgICAgICAgICAgaWYgKHN1YkFycmF5Q29udGFpbnModGFiLCBpZHgsICh0KSA9PiBjb21wYXJlKHQudmFsdWVfLCB0YWJbaWR4XS52YWx1ZV8pKSkge1xuICAgICAgICAgICAgICAgIC0tZmluYWxMZW5ndGg7XG4gICAgICAgICAgICAgICAgc3dhcCh0YWIsIGlkeCwgZmluYWxMZW5ndGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0YWIuc2xpY2UoMCwgZmluYWxMZW5ndGgpO1xuICAgIH07XG59XG5leHBvcnRzLmJ1aWxkQ29tcGFyZUZpbHRlciA9IGJ1aWxkQ29tcGFyZUZpbHRlcjtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5idWlsZFNjaGVkdWxlckZvciA9IHZvaWQgMDtcbmNvbnN0IFNjaGVkdWxlckltcGxlbV8xID0gcmVxdWlyZShcIi4uL2ltcGxlbWVudGF0aW9ucy9TY2hlZHVsZXJJbXBsZW1cIik7XG5mdW5jdGlvbiBidWlsZE5leHRUYXNrSW5kZXgob3JkZXJpbmcpIHtcbiAgICBsZXQgbnVtVGFza3MgPSAwO1xuICAgIHJldHVybiB7XG4gICAgICAgIGNsb25lOiAoKSA9PiBidWlsZE5leHRUYXNrSW5kZXgob3JkZXJpbmcpLFxuICAgICAgICBuZXh0VGFza0luZGV4OiAoc2NoZWR1bGVkVGFza3MpID0+IHtcbiAgICAgICAgICAgIGlmIChvcmRlcmluZy5sZW5ndGggPD0gbnVtVGFza3MpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgc2NoZWR1bGVyRm9yIGRlZmluZWQ6IHRvbyBtYW55IHRhc2tzIGhhdmUgYmVlbiBzY2hlZHVsZWRgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHRhc2tJbmRleCA9IHNjaGVkdWxlZFRhc2tzLmZpbmRJbmRleCgodCkgPT4gdC50YXNrSWQgPT09IG9yZGVyaW5nW251bVRhc2tzXSk7XG4gICAgICAgICAgICBpZiAodGFza0luZGV4ID09PSAtMSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBzY2hlZHVsZXJGb3IgZGVmaW5lZDogdW5hYmxlIHRvIGZpbmQgbmV4dCB0YXNrYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICArK251bVRhc2tzO1xuICAgICAgICAgICAgcmV0dXJuIHRhc2tJbmRleDtcbiAgICAgICAgfSxcbiAgICB9O1xufVxuZnVuY3Rpb24gYnVpbGRTY2hlZHVsZXJGb3IoYWN0LCBvcmRlcmluZykge1xuICAgIHJldHVybiBuZXcgU2NoZWR1bGVySW1wbGVtXzEuU2NoZWR1bGVySW1wbGVtKGFjdCwgYnVpbGROZXh0VGFza0luZGV4KG9yZGVyaW5nKSk7XG59XG5leHBvcnRzLmJ1aWxkU2NoZWR1bGVyRm9yID0gYnVpbGRTY2hlZHVsZXJGb3I7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZ2V0RGVwdGhDb250ZXh0Rm9yID0gdm9pZCAwO1xuY29uc3QgZGVwdGhDb250ZXh0Q2FjaGUgPSBuZXcgTWFwKCk7XG5mdW5jdGlvbiBnZXREZXB0aENvbnRleHRGb3IoY29udGV4dE1ldGEpIHtcbiAgICBpZiAoY29udGV4dE1ldGEgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4geyBkZXB0aDogMCB9O1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGNvbnRleHRNZXRhICE9PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gY29udGV4dE1ldGE7XG4gICAgfVxuICAgIGNvbnN0IGNhY2hlZENvbnRleHQgPSBkZXB0aENvbnRleHRDYWNoZS5nZXQoY29udGV4dE1ldGEpO1xuICAgIGlmIChjYWNoZWRDb250ZXh0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIGNhY2hlZENvbnRleHQ7XG4gICAgfVxuICAgIGNvbnN0IGNvbnRleHQgPSB7IGRlcHRoOiAwIH07XG4gICAgZGVwdGhDb250ZXh0Q2FjaGUuc2V0KGNvbnRleHRNZXRhLCBjb250ZXh0KTtcbiAgICByZXR1cm4gY29udGV4dDtcbn1cbmV4cG9ydHMuZ2V0RGVwdGhDb250ZXh0Rm9yID0gZ2V0RGVwdGhDb250ZXh0Rm9yO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmV4dHJhY3RFbnVtZXJhYmxlS2V5cyA9IHZvaWQgMDtcbmZ1bmN0aW9uIGV4dHJhY3RFbnVtZXJhYmxlS2V5cyhpbnN0YW5jZSkge1xuICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhpbnN0YW5jZSk7XG4gICAgY29uc3Qgc3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoaW5zdGFuY2UpO1xuICAgIGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggIT09IHN5bWJvbHMubGVuZ3RoOyArK2luZGV4KSB7XG4gICAgICAgIGNvbnN0IHN5bWJvbCA9IHN5bWJvbHNbaW5kZXhdO1xuICAgICAgICBjb25zdCBkZXNjcmlwdG9yID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihpbnN0YW5jZSwgc3ltYm9sKTtcbiAgICAgICAgaWYgKGRlc2NyaXB0b3IgJiYgZGVzY3JpcHRvci5lbnVtZXJhYmxlKSB7XG4gICAgICAgICAgICBrZXlzLnB1c2goc3ltYm9sKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4ga2V5cztcbn1cbmV4cG9ydHMuZXh0cmFjdEVudW1lcmFibGVLZXlzID0gZXh0cmFjdEVudW1lcmFibGVLZXlzO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLm1heExlbmd0aEZyb21NaW5MZW5ndGggPSB2b2lkIDA7XG5mdW5jdGlvbiBtYXhMZW5ndGhGcm9tTWluTGVuZ3RoKG1pbkxlbmd0aCkge1xuICAgIHJldHVybiAyICogbWluTGVuZ3RoICsgMTA7XG59XG5leHBvcnRzLm1heExlbmd0aEZyb21NaW5MZW5ndGggPSBtYXhMZW5ndGhGcm9tTWluTGVuZ3RoO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnNocmlua0JpZ0ludCA9IHZvaWQgMDtcbmNvbnN0IFN0cmVhbV8xID0gcmVxdWlyZShcIi4uLy4uLy4uL3N0cmVhbS9TdHJlYW1cIik7XG5jb25zdCBOZXh0VmFsdWVfMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi9jaGVjay9hcmJpdHJhcnkvZGVmaW5pdGlvbi9OZXh0VmFsdWVcIik7XG5mdW5jdGlvbiBoYWx2ZUJpZ0ludChuKSB7XG4gICAgcmV0dXJuIG4gLyBCaWdJbnQoMik7XG59XG5mdW5jdGlvbiBzaHJpbmtCaWdJbnQoY3VycmVudCwgdGFyZ2V0LCB0cnlUYXJnZXRBc2FwKSB7XG4gICAgY29uc3QgcmVhbEdhcCA9IGN1cnJlbnQgLSB0YXJnZXQ7XG4gICAgZnVuY3Rpb24qIHNocmlua0RlY3IoKSB7XG4gICAgICAgIGxldCBwcmV2aW91cyA9IHRyeVRhcmdldEFzYXAgPyB1bmRlZmluZWQgOiB0YXJnZXQ7XG4gICAgICAgIGNvbnN0IGdhcCA9IHRyeVRhcmdldEFzYXAgPyByZWFsR2FwIDogaGFsdmVCaWdJbnQocmVhbEdhcCk7XG4gICAgICAgIGZvciAobGV0IHRvcmVtb3ZlID0gZ2FwOyB0b3JlbW92ZSA+IDA7IHRvcmVtb3ZlID0gaGFsdmVCaWdJbnQodG9yZW1vdmUpKSB7XG4gICAgICAgICAgICBjb25zdCBuZXh0ID0gY3VycmVudCAtIHRvcmVtb3ZlO1xuICAgICAgICAgICAgeWllbGQgbmV3IE5leHRWYWx1ZV8xLk5leHRWYWx1ZShuZXh0LCBwcmV2aW91cyk7XG4gICAgICAgICAgICBwcmV2aW91cyA9IG5leHQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24qIHNocmlua0luY3IoKSB7XG4gICAgICAgIGxldCBwcmV2aW91cyA9IHRyeVRhcmdldEFzYXAgPyB1bmRlZmluZWQgOiB0YXJnZXQ7XG4gICAgICAgIGNvbnN0IGdhcCA9IHRyeVRhcmdldEFzYXAgPyByZWFsR2FwIDogaGFsdmVCaWdJbnQocmVhbEdhcCk7XG4gICAgICAgIGZvciAobGV0IHRvcmVtb3ZlID0gZ2FwOyB0b3JlbW92ZSA8IDA7IHRvcmVtb3ZlID0gaGFsdmVCaWdJbnQodG9yZW1vdmUpKSB7XG4gICAgICAgICAgICBjb25zdCBuZXh0ID0gY3VycmVudCAtIHRvcmVtb3ZlO1xuICAgICAgICAgICAgeWllbGQgbmV3IE5leHRWYWx1ZV8xLk5leHRWYWx1ZShuZXh0LCBwcmV2aW91cyk7XG4gICAgICAgICAgICBwcmV2aW91cyA9IG5leHQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlYWxHYXAgPiAwID8gU3RyZWFtXzEuc3RyZWFtKHNocmlua0RlY3IoKSkgOiBTdHJlYW1fMS5zdHJlYW0oc2hyaW5rSW5jcigpKTtcbn1cbmV4cG9ydHMuc2hyaW5rQmlnSW50ID0gc2hyaW5rQmlnSW50O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnNocmlua0ludGVnZXIgPSB2b2lkIDA7XG5jb25zdCBOZXh0VmFsdWVfMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi9jaGVjay9hcmJpdHJhcnkvZGVmaW5pdGlvbi9OZXh0VmFsdWVcIik7XG5jb25zdCBTdHJlYW1fMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi9zdHJlYW0vU3RyZWFtXCIpO1xuZnVuY3Rpb24gaGFsdmVQb3NJbnRlZ2VyKG4pIHtcbiAgICByZXR1cm4gTWF0aC5mbG9vcihuIC8gMik7XG59XG5mdW5jdGlvbiBoYWx2ZU5lZ0ludGVnZXIobikge1xuICAgIHJldHVybiBNYXRoLmNlaWwobiAvIDIpO1xufVxuZnVuY3Rpb24gc2hyaW5rSW50ZWdlcihjdXJyZW50LCB0YXJnZXQsIHRyeVRhcmdldEFzYXApIHtcbiAgICBjb25zdCByZWFsR2FwID0gY3VycmVudCAtIHRhcmdldDtcbiAgICBmdW5jdGlvbiogc2hyaW5rRGVjcigpIHtcbiAgICAgICAgbGV0IHByZXZpb3VzID0gdHJ5VGFyZ2V0QXNhcCA/IHVuZGVmaW5lZCA6IHRhcmdldDtcbiAgICAgICAgY29uc3QgZ2FwID0gdHJ5VGFyZ2V0QXNhcCA/IHJlYWxHYXAgOiBoYWx2ZVBvc0ludGVnZXIocmVhbEdhcCk7XG4gICAgICAgIGZvciAobGV0IHRvcmVtb3ZlID0gZ2FwOyB0b3JlbW92ZSA+IDA7IHRvcmVtb3ZlID0gaGFsdmVQb3NJbnRlZ2VyKHRvcmVtb3ZlKSkge1xuICAgICAgICAgICAgY29uc3QgbmV4dCA9IHRvcmVtb3ZlID09PSByZWFsR2FwID8gdGFyZ2V0IDogY3VycmVudCAtIHRvcmVtb3ZlO1xuICAgICAgICAgICAgeWllbGQgbmV3IE5leHRWYWx1ZV8xLk5leHRWYWx1ZShuZXh0LCBwcmV2aW91cyk7XG4gICAgICAgICAgICBwcmV2aW91cyA9IG5leHQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24qIHNocmlua0luY3IoKSB7XG4gICAgICAgIGxldCBwcmV2aW91cyA9IHRyeVRhcmdldEFzYXAgPyB1bmRlZmluZWQgOiB0YXJnZXQ7XG4gICAgICAgIGNvbnN0IGdhcCA9IHRyeVRhcmdldEFzYXAgPyByZWFsR2FwIDogaGFsdmVOZWdJbnRlZ2VyKHJlYWxHYXApO1xuICAgICAgICBmb3IgKGxldCB0b3JlbW92ZSA9IGdhcDsgdG9yZW1vdmUgPCAwOyB0b3JlbW92ZSA9IGhhbHZlTmVnSW50ZWdlcih0b3JlbW92ZSkpIHtcbiAgICAgICAgICAgIGNvbnN0IG5leHQgPSB0b3JlbW92ZSA9PT0gcmVhbEdhcCA/IHRhcmdldCA6IGN1cnJlbnQgLSB0b3JlbW92ZTtcbiAgICAgICAgICAgIHlpZWxkIG5ldyBOZXh0VmFsdWVfMS5OZXh0VmFsdWUobmV4dCwgcHJldmlvdXMpO1xuICAgICAgICAgICAgcHJldmlvdXMgPSBuZXh0O1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZWFsR2FwID4gMCA/IFN0cmVhbV8xLnN0cmVhbShzaHJpbmtEZWNyKCkpIDogU3RyZWFtXzEuc3RyZWFtKHNocmlua0luY3IoKSk7XG59XG5leHBvcnRzLnNocmlua0ludGVnZXIgPSBzaHJpbmtJbnRlZ2VyO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmV4dHJhY3RTdHJpbmdDb25zdHJhaW50cyA9IHZvaWQgMDtcbmZ1bmN0aW9uIGV4dHJhY3RTdHJpbmdDb25zdHJhaW50cyhvcHRpb25zKSB7XG4gICAgcmV0dXJuIG9wdGlvbnNbMF0gIT09IHVuZGVmaW5lZFxuICAgICAgICA/IHR5cGVvZiBvcHRpb25zWzBdID09PSAnbnVtYmVyJ1xuICAgICAgICAgICAgPyB0eXBlb2Ygb3B0aW9uc1sxXSA9PT0gJ251bWJlcidcbiAgICAgICAgICAgICAgICA/IHsgbWluTGVuZ3RoOiBvcHRpb25zWzBdLCBtYXhMZW5ndGg6IG9wdGlvbnNbMV0gfVxuICAgICAgICAgICAgICAgIDogeyBtYXhMZW5ndGg6IG9wdGlvbnNbMF0gfVxuICAgICAgICAgICAgOiBvcHRpb25zWzBdXG4gICAgICAgIDoge307XG59XG5leHBvcnRzLmV4dHJhY3RTdHJpbmdDb25zdHJhaW50cyA9IGV4dHJhY3RTdHJpbmdDb25zdHJhaW50cztcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5TY2hlZHVsZXJJbXBsZW0gPSB2b2lkIDA7XG5jb25zdCBUZXh0RXNjYXBlcl8xID0gcmVxdWlyZShcIi4uLy4uLy4uL2NoZWNrL2FyYml0cmFyeS9oZWxwZXJzL1RleHRFc2NhcGVyXCIpO1xuY29uc3Qgc3ltYm9sc18xID0gcmVxdWlyZShcIi4uLy4uLy4uL2NoZWNrL3N5bWJvbHNcIik7XG5jb25zdCBzdHJpbmdpZnlfMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi91dGlscy9zdHJpbmdpZnlcIik7XG5jbGFzcyBTY2hlZHVsZXJJbXBsZW0ge1xuICAgIGNvbnN0cnVjdG9yKGFjdCwgdGFza1NlbGVjdG9yKSB7XG4gICAgICAgIHRoaXMuYWN0ID0gYWN0O1xuICAgICAgICB0aGlzLnRhc2tTZWxlY3RvciA9IHRhc2tTZWxlY3RvcjtcbiAgICAgICAgdGhpcy5sYXN0VGFza0lkID0gMDtcbiAgICAgICAgdGhpcy5zb3VyY2VUYXNrU2VsZWN0b3IgPSB0YXNrU2VsZWN0b3IuY2xvbmUoKTtcbiAgICAgICAgdGhpcy5zY2hlZHVsZWRUYXNrcyA9IFtdO1xuICAgICAgICB0aGlzLnRyaWdnZXJlZFRhc2tzID0gW107XG4gICAgfVxuICAgIHN0YXRpYyBidWlsZExvZyhyZXBvcnRJdGVtKSB7XG4gICAgICAgIHJldHVybiBgW3Rhc2tcXCR7JHtyZXBvcnRJdGVtLnRhc2tJZH19XSAke3JlcG9ydEl0ZW0ubGFiZWwubGVuZ3RoICE9PSAwID8gYCR7cmVwb3J0SXRlbS5zY2hlZHVsaW5nVHlwZX06OiR7cmVwb3J0SXRlbS5sYWJlbH1gIDogcmVwb3J0SXRlbS5zY2hlZHVsaW5nVHlwZX0gJHtyZXBvcnRJdGVtLnN0YXR1c30ke3JlcG9ydEl0ZW0ub3V0cHV0VmFsdWUgIT09IHVuZGVmaW5lZCA/IGAgd2l0aCB2YWx1ZSAke1RleHRFc2NhcGVyXzEuZXNjYXBlRm9yVGVtcGxhdGVTdHJpbmcocmVwb3J0SXRlbS5vdXRwdXRWYWx1ZSl9YCA6ICcnfWA7XG4gICAgfVxuICAgIGxvZyhzY2hlZHVsaW5nVHlwZSwgdGFza0lkLCBsYWJlbCwgbWV0YWRhdGEsIHN0YXR1cywgZGF0YSkge1xuICAgICAgICB0aGlzLnRyaWdnZXJlZFRhc2tzLnB1c2goe1xuICAgICAgICAgICAgc3RhdHVzLFxuICAgICAgICAgICAgc2NoZWR1bGluZ1R5cGUsXG4gICAgICAgICAgICB0YXNrSWQsXG4gICAgICAgICAgICBsYWJlbCxcbiAgICAgICAgICAgIG1ldGFkYXRhLFxuICAgICAgICAgICAgb3V0cHV0VmFsdWU6IGRhdGEgIT09IHVuZGVmaW5lZCA/IHN0cmluZ2lmeV8xLnN0cmluZ2lmeShkYXRhKSA6IHVuZGVmaW5lZCxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHNjaGVkdWxlSW50ZXJuYWwoc2NoZWR1bGluZ1R5cGUsIGxhYmVsLCB0YXNrLCBtZXRhZGF0YSwgdGhlblRhc2tUb0JlQXdhaXRlZCkge1xuICAgICAgICBsZXQgdHJpZ2dlciA9IG51bGw7XG4gICAgICAgIGNvbnN0IHRhc2tJZCA9ICsrdGhpcy5sYXN0VGFza0lkO1xuICAgICAgICBjb25zdCBzY2hlZHVsZWRQcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgdHJpZ2dlciA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICAodGhlblRhc2tUb0JlQXdhaXRlZCA/IHRhc2sudGhlbigoKSA9PiB0aGVuVGFza1RvQmVBd2FpdGVkKCkpIDogdGFzaykudGhlbigoZGF0YSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmxvZyhzY2hlZHVsaW5nVHlwZSwgdGFza0lkLCBsYWJlbCwgbWV0YWRhdGEsICdyZXNvbHZlZCcsIGRhdGEpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzb2x2ZShkYXRhKTtcbiAgICAgICAgICAgICAgICB9LCAoZXJyKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubG9nKHNjaGVkdWxpbmdUeXBlLCB0YXNrSWQsIGxhYmVsLCBtZXRhZGF0YSwgJ3JlamVjdGVkJywgZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdChlcnIpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuc2NoZWR1bGVkVGFza3MucHVzaCh7XG4gICAgICAgICAgICBvcmlnaW5hbDogdGFzayxcbiAgICAgICAgICAgIHNjaGVkdWxlZDogc2NoZWR1bGVkUHJvbWlzZSxcbiAgICAgICAgICAgIHRyaWdnZXI6IHRyaWdnZXIsXG4gICAgICAgICAgICBzY2hlZHVsaW5nVHlwZSxcbiAgICAgICAgICAgIHRhc2tJZCxcbiAgICAgICAgICAgIGxhYmVsLFxuICAgICAgICAgICAgbWV0YWRhdGEsXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gc2NoZWR1bGVkUHJvbWlzZTtcbiAgICB9XG4gICAgc2NoZWR1bGUodGFzaywgbGFiZWwsIG1ldGFkYXRhKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNjaGVkdWxlSW50ZXJuYWwoJ3Byb21pc2UnLCBsYWJlbCB8fCAnJywgdGFzaywgbWV0YWRhdGEpO1xuICAgIH1cbiAgICBzY2hlZHVsZUZ1bmN0aW9uKGFzeW5jRnVuY3Rpb24pIHtcbiAgICAgICAgcmV0dXJuICguLi5hcmdzKSA9PiB0aGlzLnNjaGVkdWxlSW50ZXJuYWwoJ2Z1bmN0aW9uJywgYCR7YXN5bmNGdW5jdGlvbi5uYW1lfSgke2FyZ3MubWFwKHN0cmluZ2lmeV8xLnN0cmluZ2lmeSkuam9pbignLCcpfSlgLCBhc3luY0Z1bmN0aW9uKC4uLmFyZ3MpLCB1bmRlZmluZWQpO1xuICAgIH1cbiAgICBzY2hlZHVsZVNlcXVlbmNlKHNlcXVlbmNlQnVpbGRlcnMpIHtcbiAgICAgICAgY29uc3Qgc3RhdHVzID0geyBkb25lOiBmYWxzZSwgZmF1bHR5OiBmYWxzZSB9O1xuICAgICAgICBjb25zdCBkdW1teVJlc29sdmVkUHJvbWlzZSA9IHsgdGhlbjogKGYpID0+IGYoKSB9O1xuICAgICAgICBsZXQgcmVzb2x2ZVNlcXVlbmNlVGFzayA9ICgpID0+IHsgfTtcbiAgICAgICAgY29uc3Qgc2VxdWVuY2VUYXNrID0gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IChyZXNvbHZlU2VxdWVuY2VUYXNrID0gcmVzb2x2ZSkpO1xuICAgICAgICBzZXF1ZW5jZUJ1aWxkZXJzXG4gICAgICAgICAgICAucmVkdWNlKChwcmV2aW91c2x5U2NoZWR1bGVkLCBpdGVtKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBbYnVpbGRlciwgbGFiZWwsIG1ldGFkYXRhXSA9IHR5cGVvZiBpdGVtID09PSAnZnVuY3Rpb24nID8gW2l0ZW0sIGl0ZW0ubmFtZSwgdW5kZWZpbmVkXSA6IFtpdGVtLmJ1aWxkZXIsIGl0ZW0ubGFiZWwsIGl0ZW0ubWV0YWRhdGFdO1xuICAgICAgICAgICAgcmV0dXJuIHByZXZpb3VzbHlTY2hlZHVsZWQudGhlbigoKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2NoZWR1bGVkID0gdGhpcy5zY2hlZHVsZUludGVybmFsKCdzZXF1ZW5jZScsIGxhYmVsLCBkdW1teVJlc29sdmVkUHJvbWlzZSwgbWV0YWRhdGEsICgpID0+IGJ1aWxkZXIoKSk7XG4gICAgICAgICAgICAgICAgc2NoZWR1bGVkLmNhdGNoKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmZhdWx0eSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmVTZXF1ZW5jZVRhc2soKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gc2NoZWR1bGVkO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sIGR1bW15UmVzb2x2ZWRQcm9taXNlKVxuICAgICAgICAgICAgLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgc3RhdHVzLmRvbmUgPSB0cnVlO1xuICAgICAgICAgICAgcmVzb2x2ZVNlcXVlbmNlVGFzaygpO1xuICAgICAgICB9LCAoKSA9PiB7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihzdGF0dXMsIHtcbiAgICAgICAgICAgIHRhc2s6IFByb21pc2UucmVzb2x2ZShzZXF1ZW5jZVRhc2spLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IGRvbmU6IHN0YXR1cy5kb25lLCBmYXVsdHk6IHN0YXR1cy5mYXVsdHkgfTtcbiAgICAgICAgICAgIH0pLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgY291bnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNjaGVkdWxlZFRhc2tzLmxlbmd0aDtcbiAgICB9XG4gICAgYXN5bmMgaW50ZXJuYWxXYWl0T25lKCkge1xuICAgICAgICBpZiAodGhpcy5zY2hlZHVsZWRUYXNrcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTm8gdGFzayBzY2hlZHVsZWQnKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0YXNrSW5kZXggPSB0aGlzLnRhc2tTZWxlY3Rvci5uZXh0VGFza0luZGV4KHRoaXMuc2NoZWR1bGVkVGFza3MpO1xuICAgICAgICBjb25zdCBbc2NoZWR1bGVkVGFza10gPSB0aGlzLnNjaGVkdWxlZFRhc2tzLnNwbGljZSh0YXNrSW5kZXgsIDEpO1xuICAgICAgICBzY2hlZHVsZWRUYXNrLnRyaWdnZXIoKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGF3YWl0IHNjaGVkdWxlZFRhc2suc2NoZWR1bGVkO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChfZXJyKSB7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgd2FpdE9uZSgpIHtcbiAgICAgICAgYXdhaXQgdGhpcy5hY3QoYXN5bmMgKCkgPT4gYXdhaXQgdGhpcy5pbnRlcm5hbFdhaXRPbmUoKSk7XG4gICAgfVxuICAgIGFzeW5jIHdhaXRBbGwoKSB7XG4gICAgICAgIHdoaWxlICh0aGlzLnNjaGVkdWxlZFRhc2tzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMud2FpdE9uZSgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJlcG9ydCgpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIC4uLnRoaXMudHJpZ2dlcmVkVGFza3MsXG4gICAgICAgICAgICAuLi50aGlzLnNjaGVkdWxlZFRhc2tzLm1hcCgodCkgPT4gKHtcbiAgICAgICAgICAgICAgICBzdGF0dXM6ICdwZW5kaW5nJyxcbiAgICAgICAgICAgICAgICBzY2hlZHVsaW5nVHlwZTogdC5zY2hlZHVsaW5nVHlwZSxcbiAgICAgICAgICAgICAgICB0YXNrSWQ6IHQudGFza0lkLFxuICAgICAgICAgICAgICAgIGxhYmVsOiB0LmxhYmVsLFxuICAgICAgICAgICAgICAgIG1ldGFkYXRhOiB0Lm1ldGFkYXRhLFxuICAgICAgICAgICAgfSkpLFxuICAgICAgICBdO1xuICAgIH1cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuICgnc2NoZWR1bGVyRm9yKClgXFxuJyArXG4gICAgICAgICAgICB0aGlzLnJlcG9ydCgpXG4gICAgICAgICAgICAgICAgLm1hcChTY2hlZHVsZXJJbXBsZW0uYnVpbGRMb2cpXG4gICAgICAgICAgICAgICAgLm1hcCgobG9nKSA9PiBgLT4gJHtsb2d9YClcbiAgICAgICAgICAgICAgICAuam9pbignXFxuJykgK1xuICAgICAgICAgICAgJ2AnKTtcbiAgICB9XG4gICAgW3N5bWJvbHNfMS5jbG9uZU1ldGhvZF0oKSB7XG4gICAgICAgIHJldHVybiBuZXcgU2NoZWR1bGVySW1wbGVtKHRoaXMuYWN0LCB0aGlzLnNvdXJjZVRhc2tTZWxlY3Rvcik7XG4gICAgfVxufVxuZXhwb3J0cy5TY2hlZHVsZXJJbXBsZW0gPSBTY2hlZHVsZXJJbXBsZW07XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuY2hhcnNUb1N0cmluZ1VubWFwcGVyID0gZXhwb3J0cy5jaGFyc1RvU3RyaW5nTWFwcGVyID0gdm9pZCAwO1xuZnVuY3Rpb24gY2hhcnNUb1N0cmluZ01hcHBlcih0YWIpIHtcbiAgICByZXR1cm4gdGFiLmpvaW4oJycpO1xufVxuZXhwb3J0cy5jaGFyc1RvU3RyaW5nTWFwcGVyID0gY2hhcnNUb1N0cmluZ01hcHBlcjtcbmZ1bmN0aW9uIGNoYXJzVG9TdHJpbmdVbm1hcHBlcih2YWx1ZSkge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IHVubWFwIHRoZSBwYXNzZWQgdmFsdWUnKTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlLnNwbGl0KCcnKTtcbn1cbmV4cG9ydHMuY2hhcnNUb1N0cmluZ1VubWFwcGVyID0gY2hhcnNUb1N0cmluZ1VubWFwcGVyO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmNvZGVQb2ludHNUb1N0cmluZ1VubWFwcGVyID0gZXhwb3J0cy5jb2RlUG9pbnRzVG9TdHJpbmdNYXBwZXIgPSB2b2lkIDA7XG5mdW5jdGlvbiBjb2RlUG9pbnRzVG9TdHJpbmdNYXBwZXIodGFiKSB7XG4gICAgcmV0dXJuIHRhYi5qb2luKCcnKTtcbn1cbmV4cG9ydHMuY29kZVBvaW50c1RvU3RyaW5nTWFwcGVyID0gY29kZVBvaW50c1RvU3RyaW5nTWFwcGVyO1xuZnVuY3Rpb24gY29kZVBvaW50c1RvU3RyaW5nVW5tYXBwZXIodmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnc3RyaW5nJykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCB1bm1hcCB0aGUgcGFzc2VkIHZhbHVlJyk7XG4gICAgfVxuICAgIHJldHVybiBbLi4udmFsdWVdO1xufVxuZXhwb3J0cy5jb2RlUG9pbnRzVG9TdHJpbmdVbm1hcHBlciA9IGNvZGVQb2ludHNUb1N0cmluZ1VubWFwcGVyO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLm5vVHJhaWxpbmdVbm1hcHBlciA9IGV4cG9ydHMubm9UcmFpbGluZ01hcHBlciA9IGV4cG9ydHMuc2luZ2xlVHJhaWxpbmdVbm1hcHBlciA9IGV4cG9ydHMuc2luZ2xlVHJhaWxpbmdNYXBwZXIgPSBleHBvcnRzLm11bHRpVHJhaWxpbmdVbm1hcHBlck9uZSA9IGV4cG9ydHMubXVsdGlUcmFpbGluZ01hcHBlck9uZSA9IGV4cG9ydHMubXVsdGlUcmFpbGluZ1VubWFwcGVyID0gZXhwb3J0cy5tdWx0aVRyYWlsaW5nTWFwcGVyID0gZXhwb3J0cy5vbmx5VHJhaWxpbmdVbm1hcHBlciA9IGV4cG9ydHMub25seVRyYWlsaW5nTWFwcGVyID0gZXhwb3J0cy5mdWxseVNwZWNpZmllZFVubWFwcGVyID0gZXhwb3J0cy5mdWxseVNwZWNpZmllZE1hcHBlciA9IHZvaWQgMDtcbmZ1bmN0aW9uIHJlYWRCaCh2YWx1ZSkge1xuICAgIGlmICh2YWx1ZS5sZW5ndGggPT09IDApXG4gICAgICAgIHJldHVybiBbXTtcbiAgICBlbHNlXG4gICAgICAgIHJldHVybiB2YWx1ZS5zcGxpdCgnOicpO1xufVxuZnVuY3Rpb24gZXh0cmFjdEVoQW5kTCh2YWx1ZSkge1xuICAgIGNvbnN0IHZhbHVlU3BsaXRzID0gdmFsdWUuc3BsaXQoJzonKTtcbiAgICBpZiAodmFsdWVTcGxpdHMubGVuZ3RoID49IDIgJiYgdmFsdWVTcGxpdHNbdmFsdWVTcGxpdHMubGVuZ3RoIC0gMV0ubGVuZ3RoIDw9IDQpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHZhbHVlU3BsaXRzLnNsaWNlKDAsIHZhbHVlU3BsaXRzLmxlbmd0aCAtIDIpLFxuICAgICAgICAgICAgYCR7dmFsdWVTcGxpdHNbdmFsdWVTcGxpdHMubGVuZ3RoIC0gMl19OiR7dmFsdWVTcGxpdHNbdmFsdWVTcGxpdHMubGVuZ3RoIC0gMV19YCxcbiAgICAgICAgXTtcbiAgICB9XG4gICAgcmV0dXJuIFt2YWx1ZVNwbGl0cy5zbGljZSgwLCB2YWx1ZVNwbGl0cy5sZW5ndGggLSAxKSwgdmFsdWVTcGxpdHNbdmFsdWVTcGxpdHMubGVuZ3RoIC0gMV1dO1xufVxuZnVuY3Rpb24gZnVsbHlTcGVjaWZpZWRNYXBwZXIoZGF0YSkge1xuICAgIHJldHVybiBgJHtkYXRhWzBdLmpvaW4oJzonKX06JHtkYXRhWzFdfWA7XG59XG5leHBvcnRzLmZ1bGx5U3BlY2lmaWVkTWFwcGVyID0gZnVsbHlTcGVjaWZpZWRNYXBwZXI7XG5mdW5jdGlvbiBmdWxseVNwZWNpZmllZFVubWFwcGVyKHZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ3N0cmluZycpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCB0eXBlJyk7XG4gICAgcmV0dXJuIGV4dHJhY3RFaEFuZEwodmFsdWUpO1xufVxuZXhwb3J0cy5mdWxseVNwZWNpZmllZFVubWFwcGVyID0gZnVsbHlTcGVjaWZpZWRVbm1hcHBlcjtcbmZ1bmN0aW9uIG9ubHlUcmFpbGluZ01hcHBlcihkYXRhKSB7XG4gICAgcmV0dXJuIGA6OiR7ZGF0YVswXS5qb2luKCc6Jyl9OiR7ZGF0YVsxXX1gO1xufVxuZXhwb3J0cy5vbmx5VHJhaWxpbmdNYXBwZXIgPSBvbmx5VHJhaWxpbmdNYXBwZXI7XG5mdW5jdGlvbiBvbmx5VHJhaWxpbmdVbm1hcHBlcih2YWx1ZSkge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdzdHJpbmcnKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgdHlwZScpO1xuICAgIGlmICghdmFsdWUuc3RhcnRzV2l0aCgnOjonKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHZhbHVlJyk7XG4gICAgcmV0dXJuIGV4dHJhY3RFaEFuZEwodmFsdWUuc3Vic3RyaW5nKDIpKTtcbn1cbmV4cG9ydHMub25seVRyYWlsaW5nVW5tYXBwZXIgPSBvbmx5VHJhaWxpbmdVbm1hcHBlcjtcbmZ1bmN0aW9uIG11bHRpVHJhaWxpbmdNYXBwZXIoZGF0YSkge1xuICAgIHJldHVybiBgJHtkYXRhWzBdLmpvaW4oJzonKX06OiR7ZGF0YVsxXS5qb2luKCc6Jyl9OiR7ZGF0YVsyXX1gO1xufVxuZXhwb3J0cy5tdWx0aVRyYWlsaW5nTWFwcGVyID0gbXVsdGlUcmFpbGluZ01hcHBlcjtcbmZ1bmN0aW9uIG11bHRpVHJhaWxpbmdVbm1hcHBlcih2YWx1ZSkge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdzdHJpbmcnKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgdHlwZScpO1xuICAgIGNvbnN0IFtiaFN0cmluZywgdHJhaWxpbmdTdHJpbmddID0gdmFsdWUuc3BsaXQoJzo6JywgMik7XG4gICAgY29uc3QgW2VoLCBsXSA9IGV4dHJhY3RFaEFuZEwodHJhaWxpbmdTdHJpbmcpO1xuICAgIHJldHVybiBbcmVhZEJoKGJoU3RyaW5nKSwgZWgsIGxdO1xufVxuZXhwb3J0cy5tdWx0aVRyYWlsaW5nVW5tYXBwZXIgPSBtdWx0aVRyYWlsaW5nVW5tYXBwZXI7XG5mdW5jdGlvbiBtdWx0aVRyYWlsaW5nTWFwcGVyT25lKGRhdGEpIHtcbiAgICByZXR1cm4gbXVsdGlUcmFpbGluZ01hcHBlcihbZGF0YVswXSwgW2RhdGFbMV1dLCBkYXRhWzJdXSk7XG59XG5leHBvcnRzLm11bHRpVHJhaWxpbmdNYXBwZXJPbmUgPSBtdWx0aVRyYWlsaW5nTWFwcGVyT25lO1xuZnVuY3Rpb24gbXVsdGlUcmFpbGluZ1VubWFwcGVyT25lKHZhbHVlKSB7XG4gICAgY29uc3Qgb3V0ID0gbXVsdGlUcmFpbGluZ1VubWFwcGVyKHZhbHVlKTtcbiAgICByZXR1cm4gW291dFswXSwgb3V0WzFdLmpvaW4oJzonKSwgb3V0WzJdXTtcbn1cbmV4cG9ydHMubXVsdGlUcmFpbGluZ1VubWFwcGVyT25lID0gbXVsdGlUcmFpbGluZ1VubWFwcGVyT25lO1xuZnVuY3Rpb24gc2luZ2xlVHJhaWxpbmdNYXBwZXIoZGF0YSkge1xuICAgIHJldHVybiBgJHtkYXRhWzBdLmpvaW4oJzonKX06OiR7ZGF0YVsxXX1gO1xufVxuZXhwb3J0cy5zaW5nbGVUcmFpbGluZ01hcHBlciA9IHNpbmdsZVRyYWlsaW5nTWFwcGVyO1xuZnVuY3Rpb24gc2luZ2xlVHJhaWxpbmdVbm1hcHBlcih2YWx1ZSkge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdzdHJpbmcnKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgdHlwZScpO1xuICAgIGNvbnN0IFtiaFN0cmluZywgdHJhaWxpbmddID0gdmFsdWUuc3BsaXQoJzo6JywgMik7XG4gICAgcmV0dXJuIFtyZWFkQmgoYmhTdHJpbmcpLCB0cmFpbGluZ107XG59XG5leHBvcnRzLnNpbmdsZVRyYWlsaW5nVW5tYXBwZXIgPSBzaW5nbGVUcmFpbGluZ1VubWFwcGVyO1xuZnVuY3Rpb24gbm9UcmFpbGluZ01hcHBlcihkYXRhKSB7XG4gICAgcmV0dXJuIGAke2RhdGFbMF0uam9pbignOicpfTo6YDtcbn1cbmV4cG9ydHMubm9UcmFpbGluZ01hcHBlciA9IG5vVHJhaWxpbmdNYXBwZXI7XG5mdW5jdGlvbiBub1RyYWlsaW5nVW5tYXBwZXIodmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnc3RyaW5nJylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHR5cGUnKTtcbiAgICBpZiAoIXZhbHVlLmVuZHNXaXRoKCc6OicpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgdmFsdWUnKTtcbiAgICByZXR1cm4gW3JlYWRCaCh2YWx1ZS5zdWJzdHJpbmcoMCwgdmFsdWUubGVuZ3RoIC0gMikpXTtcbn1cbmV4cG9ydHMubm9UcmFpbGluZ1VubWFwcGVyID0gbm9UcmFpbGluZ1VubWFwcGVyO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmluZGV4VG9DaGFyU3RyaW5nVW5tYXBwZXIgPSBleHBvcnRzLmluZGV4VG9DaGFyU3RyaW5nTWFwcGVyID0gdm9pZCAwO1xuZXhwb3J0cy5pbmRleFRvQ2hhclN0cmluZ01hcHBlciA9IFN0cmluZy5mcm9tQ29kZVBvaW50O1xuZnVuY3Rpb24gaW5kZXhUb0NoYXJTdHJpbmdVbm1hcHBlcihjKSB7XG4gICAgaWYgKHR5cGVvZiBjICE9PSAnc3RyaW5nJykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCB1bm1hcCBub24tc3RyaW5nJyk7XG4gICAgfVxuICAgIGlmIChjLmxlbmd0aCA9PT0gMCB8fCBjLmxlbmd0aCA+IDIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgdW5tYXAgc3RyaW5nIHdpdGggbW9yZSBvciBsZXNzIHRoYW4gb25lIGNoYXJhY3RlcicpO1xuICAgIH1cbiAgICBjb25zdCBjMSA9IGMuY2hhckNvZGVBdCgwKTtcbiAgICBpZiAoYy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgcmV0dXJuIGMxO1xuICAgIH1cbiAgICBjb25zdCBjMiA9IGMuY2hhckNvZGVBdCgxKTtcbiAgICBpZiAoYzEgPCAweGQ4MDAgfHwgYzEgPiAweGRiZmYgfHwgYzIgPCAweGRjMDAgfHwgYzIgPiAweGRmZmYpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgdW5tYXAgaW52YWxpZCBzdXJyb2dhdGUgcGFpcnMnKTtcbiAgICB9XG4gICAgcmV0dXJuIGMuY29kZVBvaW50QXQoMCk7XG59XG5leHBvcnRzLmluZGV4VG9DaGFyU3RyaW5nVW5tYXBwZXIgPSBpbmRleFRvQ2hhclN0cmluZ1VubWFwcGVyO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmluZGV4VG9NYXBwZWRDb25zdGFudFVubWFwcGVyRm9yID0gZXhwb3J0cy5pbmRleFRvTWFwcGVkQ29uc3RhbnRNYXBwZXJGb3IgPSB2b2lkIDA7XG5mdW5jdGlvbiBpbmRleFRvTWFwcGVkQ29uc3RhbnRNYXBwZXJGb3IoZW50cmllcykge1xuICAgIHJldHVybiBmdW5jdGlvbiBpbmRleFRvTWFwcGVkQ29uc3RhbnRNYXBwZXIoY2hvaWNlSW5kZXgpIHtcbiAgICAgICAgbGV0IGlkeCA9IC0xO1xuICAgICAgICBsZXQgbnVtU2tpcHMgPSAwO1xuICAgICAgICB3aGlsZSAoY2hvaWNlSW5kZXggPj0gbnVtU2tpcHMpIHtcbiAgICAgICAgICAgIG51bVNraXBzICs9IGVudHJpZXNbKytpZHhdLm51bTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZW50cmllc1tpZHhdLmJ1aWxkKGNob2ljZUluZGV4IC0gbnVtU2tpcHMgKyBlbnRyaWVzW2lkeF0ubnVtKTtcbiAgICB9O1xufVxuZXhwb3J0cy5pbmRleFRvTWFwcGVkQ29uc3RhbnRNYXBwZXJGb3IgPSBpbmRleFRvTWFwcGVkQ29uc3RhbnRNYXBwZXJGb3I7XG5mdW5jdGlvbiBidWlsZFJldmVyc2VNYXBwaW5nKGVudHJpZXMpIHtcbiAgICBjb25zdCByZXZlcnNlTWFwcGluZyA9IHsgbWFwcGluZzogbmV3IE1hcCgpLCBuZWdhdGl2ZVplcm9JbmRleDogdW5kZWZpbmVkIH07XG4gICAgbGV0IGNob2ljZUluZGV4ID0gMDtcbiAgICBmb3IgKGxldCBlbnRyeUlkeCA9IDA7IGVudHJ5SWR4ICE9PSBlbnRyaWVzLmxlbmd0aDsgKytlbnRyeUlkeCkge1xuICAgICAgICBjb25zdCBlbnRyeSA9IGVudHJpZXNbZW50cnlJZHhdO1xuICAgICAgICBmb3IgKGxldCBpZHhJbkVudHJ5ID0gMDsgaWR4SW5FbnRyeSAhPT0gZW50cnkubnVtOyArK2lkeEluRW50cnkpIHtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gZW50cnkuYnVpbGQoaWR4SW5FbnRyeSk7XG4gICAgICAgICAgICBpZiAodmFsdWUgPT09IDAgJiYgMSAvIHZhbHVlID09PSBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFkpIHtcbiAgICAgICAgICAgICAgICByZXZlcnNlTWFwcGluZy5uZWdhdGl2ZVplcm9JbmRleCA9IGNob2ljZUluZGV4O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV2ZXJzZU1hcHBpbmcubWFwcGluZy5zZXQodmFsdWUsIGNob2ljZUluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgICsrY2hvaWNlSW5kZXg7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJldmVyc2VNYXBwaW5nO1xufVxuZnVuY3Rpb24gaW5kZXhUb01hcHBlZENvbnN0YW50VW5tYXBwZXJGb3IoZW50cmllcykge1xuICAgIGxldCByZXZlcnNlTWFwcGluZyA9IG51bGw7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIGluZGV4VG9NYXBwZWRDb25zdGFudFVubWFwcGVyKHZhbHVlKSB7XG4gICAgICAgIGlmIChyZXZlcnNlTWFwcGluZyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV2ZXJzZU1hcHBpbmcgPSBidWlsZFJldmVyc2VNYXBwaW5nKGVudHJpZXMpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNob2ljZUluZGV4ID0gT2JqZWN0LmlzKHZhbHVlLCAtMCkgPyByZXZlcnNlTWFwcGluZy5uZWdhdGl2ZVplcm9JbmRleCA6IHJldmVyc2VNYXBwaW5nLm1hcHBpbmcuZ2V0KHZhbHVlKTtcbiAgICAgICAgaWYgKGNob2ljZUluZGV4ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biB2YWx1ZSBlbmNvdW50ZXJlZCBjYW5ub3QgYmUgYnVpbHQgdXNpbmcgdGhpcyBtYXBUb0NvbnN0YW50Jyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNob2ljZUluZGV4O1xuICAgIH07XG59XG5leHBvcnRzLmluZGV4VG9NYXBwZWRDb25zdGFudFVubWFwcGVyRm9yID0gaW5kZXhUb01hcHBlZENvbnN0YW50VW5tYXBwZXJGb3I7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuaW5kZXhUb1ByaW50YWJsZUluZGV4VW5tYXBwZXIgPSBleHBvcnRzLmluZGV4VG9QcmludGFibGVJbmRleE1hcHBlciA9IHZvaWQgMDtcbmZ1bmN0aW9uIGluZGV4VG9QcmludGFibGVJbmRleE1hcHBlcih2KSB7XG4gICAgaWYgKHYgPCA5NSlcbiAgICAgICAgcmV0dXJuIHYgKyAweDIwO1xuICAgIGlmICh2IDw9IDB4N2UpXG4gICAgICAgIHJldHVybiB2IC0gOTU7XG4gICAgcmV0dXJuIHY7XG59XG5leHBvcnRzLmluZGV4VG9QcmludGFibGVJbmRleE1hcHBlciA9IGluZGV4VG9QcmludGFibGVJbmRleE1hcHBlcjtcbmZ1bmN0aW9uIGluZGV4VG9QcmludGFibGVJbmRleFVubWFwcGVyKHYpIHtcbiAgICBpZiAodiA+PSAweDIwICYmIHYgPD0gMHg3ZSlcbiAgICAgICAgcmV0dXJuIHYgLSAweDIwO1xuICAgIGlmICh2ID49IDAgJiYgdiA8PSAweDFmKVxuICAgICAgICByZXR1cm4gdiArIDk1O1xuICAgIHJldHVybiB2O1xufVxuZXhwb3J0cy5pbmRleFRvUHJpbnRhYmxlSW5kZXhVbm1hcHBlciA9IGluZGV4VG9QcmludGFibGVJbmRleFVubWFwcGVyO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmtleVZhbHVlUGFpcnNUb09iamVjdFVubWFwcGVyID0gZXhwb3J0cy5rZXlWYWx1ZVBhaXJzVG9PYmplY3RNYXBwZXIgPSB2b2lkIDA7XG5mdW5jdGlvbiBrZXlWYWx1ZVBhaXJzVG9PYmplY3RNYXBwZXIoaXRlbXMpIHtcbiAgICBjb25zdCBvYmogPSB7fTtcbiAgICBmb3IgKGNvbnN0IGtleVZhbHVlIG9mIGl0ZW1zKSB7XG4gICAgICAgIG9ialtrZXlWYWx1ZVswXV0gPSBrZXlWYWx1ZVsxXTtcbiAgICB9XG4gICAgcmV0dXJuIG9iajtcbn1cbmV4cG9ydHMua2V5VmFsdWVQYWlyc1RvT2JqZWN0TWFwcGVyID0ga2V5VmFsdWVQYWlyc1RvT2JqZWN0TWFwcGVyO1xuZnVuY3Rpb24gYnVpbGRJbnZhbGlkUHJvcGVydHlOYW1lRmlsdGVyKG9iaikge1xuICAgIHJldHVybiBmdW5jdGlvbiBpbnZhbGlkUHJvcGVydHlOYW1lRmlsdGVyKGtleSkge1xuICAgICAgICBjb25zdCBkZXNjcmlwdG9yID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmosIGtleSk7XG4gICAgICAgIHJldHVybiAoZGVzY3JpcHRvciA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICAgICAgICAhZGVzY3JpcHRvci5jb25maWd1cmFibGUgfHxcbiAgICAgICAgICAgICFkZXNjcmlwdG9yLmVudW1lcmFibGUgfHxcbiAgICAgICAgICAgICFkZXNjcmlwdG9yLndyaXRhYmxlIHx8XG4gICAgICAgICAgICBkZXNjcmlwdG9yLmdldCAhPT0gdW5kZWZpbmVkIHx8XG4gICAgICAgICAgICBkZXNjcmlwdG9yLnNldCAhPT0gdW5kZWZpbmVkKTtcbiAgICB9O1xufVxuZnVuY3Rpb24ga2V5VmFsdWVQYWlyc1RvT2JqZWN0VW5tYXBwZXIodmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnb2JqZWN0JyB8fCB2YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0luY29tcGF0aWJsZSBpbnN0YW5jZSByZWNlaXZlZDogc2hvdWxkIGJlIGEgbm9uLW51bGwgb2JqZWN0Jyk7XG4gICAgfVxuICAgIGlmICghKCdjb25zdHJ1Y3RvcicgaW4gdmFsdWUpIHx8IHZhbHVlLmNvbnN0cnVjdG9yICE9PSBPYmplY3QpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbmNvbXBhdGlibGUgaW5zdGFuY2UgcmVjZWl2ZWQ6IHNob3VsZCBiZSBvZiBleGFjdCB0eXBlIE9iamVjdCcpO1xuICAgIH1cbiAgICBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyh2YWx1ZSkubGVuZ3RoID4gMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0luY29tcGF0aWJsZSBpbnN0YW5jZSByZWNlaXZlZDogc2hvdWxkIGNvbnRhaW4gc3ltYm9scycpO1xuICAgIH1cbiAgICBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModmFsdWUpLmZpbmQoYnVpbGRJbnZhbGlkUHJvcGVydHlOYW1lRmlsdGVyKHZhbHVlKSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0luY29tcGF0aWJsZSBpbnN0YW5jZSByZWNlaXZlZDogc2hvdWxkIGNvbnRhaW4gb25seSBjL2UvdyBwcm9wZXJ0aWVzIHdpdGhvdXQgZ2V0L3NldCcpO1xuICAgIH1cbiAgICByZXR1cm4gT2JqZWN0LmVudHJpZXModmFsdWUpO1xufVxuZXhwb3J0cy5rZXlWYWx1ZVBhaXJzVG9PYmplY3RVbm1hcHBlciA9IGtleVZhbHVlUGFpcnNUb09iamVjdFVubWFwcGVyO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLm5hdFRvU3RyaW5naWZpZWROYXRVbm1hcHBlciA9IGV4cG9ydHMudHJ5UGFyc2VTdHJpbmdpZmllZE5hdCA9IGV4cG9ydHMubmF0VG9TdHJpbmdpZmllZE5hdE1hcHBlciA9IHZvaWQgMDtcbmZ1bmN0aW9uIG5hdFRvU3RyaW5naWZpZWROYXRNYXBwZXIob3B0aW9ucykge1xuICAgIGNvbnN0IFtzdHlsZSwgdl0gPSBvcHRpb25zO1xuICAgIHN3aXRjaCAoc3R5bGUpIHtcbiAgICAgICAgY2FzZSAnb2N0JzpcbiAgICAgICAgICAgIHJldHVybiBgMCR7TnVtYmVyKHYpLnRvU3RyaW5nKDgpfWA7XG4gICAgICAgIGNhc2UgJ2hleCc6XG4gICAgICAgICAgICByZXR1cm4gYDB4JHtOdW1iZXIodikudG9TdHJpbmcoMTYpfWA7XG4gICAgICAgIGNhc2UgJ2RlYyc6XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gYCR7dn1gO1xuICAgIH1cbn1cbmV4cG9ydHMubmF0VG9TdHJpbmdpZmllZE5hdE1hcHBlciA9IG5hdFRvU3RyaW5naWZpZWROYXRNYXBwZXI7XG5mdW5jdGlvbiB0cnlQYXJzZVN0cmluZ2lmaWVkTmF0KHN0cmluZ1ZhbHVlLCByYWRpeCkge1xuICAgIGNvbnN0IHBhcnNlZE5hdCA9IE51bWJlci5wYXJzZUludChzdHJpbmdWYWx1ZSwgcmFkaXgpO1xuICAgIGlmIChwYXJzZWROYXQudG9TdHJpbmcocmFkaXgpICE9PSBzdHJpbmdWYWx1ZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgdmFsdWUnKTtcbiAgICB9XG4gICAgcmV0dXJuIHBhcnNlZE5hdDtcbn1cbmV4cG9ydHMudHJ5UGFyc2VTdHJpbmdpZmllZE5hdCA9IHRyeVBhcnNlU3RyaW5naWZpZWROYXQ7XG5mdW5jdGlvbiBuYXRUb1N0cmluZ2lmaWVkTmF0VW5tYXBwZXIodmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnc3RyaW5nJykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgdHlwZScpO1xuICAgIH1cbiAgICBpZiAodmFsdWUubGVuZ3RoID49IDIgJiYgdmFsdWVbMF0gPT09ICcwJykge1xuICAgICAgICBpZiAodmFsdWVbMV0gPT09ICd4Jykge1xuICAgICAgICAgICAgcmV0dXJuIFsnaGV4JywgdHJ5UGFyc2VTdHJpbmdpZmllZE5hdCh2YWx1ZS5zdWJzdHIoMiksIDE2KV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFsnb2N0JywgdHJ5UGFyc2VTdHJpbmdpZmllZE5hdCh2YWx1ZS5zdWJzdHIoMSksIDgpXTtcbiAgICB9XG4gICAgcmV0dXJuIFsnZGVjJywgdHJ5UGFyc2VTdHJpbmdpZmllZE5hdCh2YWx1ZSwgMTApXTtcbn1cbmV4cG9ydHMubmF0VG9TdHJpbmdpZmllZE5hdFVubWFwcGVyID0gbmF0VG9TdHJpbmdpZmllZE5hdFVubWFwcGVyO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnBhdHRlcm5zVG9TdHJpbmdVbm1hcHBlckZvciA9IGV4cG9ydHMucGF0dGVybnNUb1N0cmluZ01hcHBlciA9IHZvaWQgMDtcbmNvbnN0IE1heExlbmd0aEZyb21NaW5MZW5ndGhfMSA9IHJlcXVpcmUoXCIuLi9oZWxwZXJzL01heExlbmd0aEZyb21NaW5MZW5ndGhcIik7XG5mdW5jdGlvbiBwYXR0ZXJuc1RvU3RyaW5nTWFwcGVyKHRhYikge1xuICAgIHJldHVybiB0YWIuam9pbignJyk7XG59XG5leHBvcnRzLnBhdHRlcm5zVG9TdHJpbmdNYXBwZXIgPSBwYXR0ZXJuc1RvU3RyaW5nTWFwcGVyO1xuZnVuY3Rpb24gcGF0dGVybnNUb1N0cmluZ1VubWFwcGVyRm9yKHBhdHRlcm5zQXJiLCBjb25zdHJhaW50cykge1xuICAgIHJldHVybiBmdW5jdGlvbiBwYXR0ZXJuc1RvU3RyaW5nVW5tYXBwZXIodmFsdWUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVW5zdXBwb3J0ZWQgdmFsdWUnKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtaW5MZW5ndGggPSBjb25zdHJhaW50cy5taW5MZW5ndGggIT09IHVuZGVmaW5lZCA/IGNvbnN0cmFpbnRzLm1pbkxlbmd0aCA6IDA7XG4gICAgICAgIGNvbnN0IG1heExlbmd0aCA9IGNvbnN0cmFpbnRzLm1heExlbmd0aCAhPT0gdW5kZWZpbmVkID8gY29uc3RyYWludHMubWF4TGVuZ3RoIDogTWF4TGVuZ3RoRnJvbU1pbkxlbmd0aF8xLm1heExlbmd0aEZyb21NaW5MZW5ndGgobWluTGVuZ3RoKTtcbiAgICAgICAgaWYgKHZhbHVlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgaWYgKG1pbkxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuYWJsZSB0byB1bm1hcCByZWNlaXZlZCBzdHJpbmcnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzdGFjayA9IFt7IGVuZEluZGV4Q2h1bmtzOiAwLCBuZXh0U3RhcnRJbmRleDogMSwgY2h1bmtzOiBbXSB9XTtcbiAgICAgICAgd2hpbGUgKHN0YWNrLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGNvbnN0IGxhc3QgPSBzdGFjay5wb3AoKTtcbiAgICAgICAgICAgIGZvciAobGV0IGluZGV4ID0gbGFzdC5uZXh0U3RhcnRJbmRleDsgaW5kZXggPD0gdmFsdWUubGVuZ3RoOyArK2luZGV4KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY2h1bmsgPSB2YWx1ZS5zdWJzdHJpbmcobGFzdC5lbmRJbmRleENodW5rcywgaW5kZXgpO1xuICAgICAgICAgICAgICAgIGlmIChwYXR0ZXJuc0FyYi5jYW5TaHJpbmtXaXRob3V0Q29udGV4dChjaHVuaykpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbmV3Q2h1bmtzID0gbGFzdC5jaHVua3MuY29uY2F0KFtjaHVua10pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaW5kZXggPT09IHZhbHVlLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5ld0NodW5rcy5sZW5ndGggPCBtaW5MZW5ndGggfHwgbmV3Q2h1bmtzLmxlbmd0aCA+IG1heExlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ld0NodW5rcztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBzdGFjay5wdXNoKHsgZW5kSW5kZXhDaHVua3M6IGxhc3QuZW5kSW5kZXhDaHVua3MsIG5leHRTdGFydEluZGV4OiBpbmRleCArIDEsIGNodW5rczogbGFzdC5jaHVua3MgfSk7XG4gICAgICAgICAgICAgICAgICAgIHN0YWNrLnB1c2goeyBlbmRJbmRleENodW5rczogaW5kZXgsIG5leHRTdGFydEluZGV4OiBpbmRleCArIDEsIGNodW5rczogbmV3Q2h1bmtzIH0pO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmFibGUgdG8gdW5tYXAgcmVjZWl2ZWQgc3RyaW5nJyk7XG4gICAgfTtcbn1cbmV4cG9ydHMucGF0dGVybnNUb1N0cmluZ1VubWFwcGVyRm9yID0gcGF0dGVybnNUb1N0cmluZ1VubWFwcGVyRm9yO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnN0cmluZ1RvQmFzZTY0VW5tYXBwZXIgPSBleHBvcnRzLnN0cmluZ1RvQmFzZTY0TWFwcGVyID0gdm9pZCAwO1xuZnVuY3Rpb24gc3RyaW5nVG9CYXNlNjRNYXBwZXIocykge1xuICAgIHN3aXRjaCAocy5sZW5ndGggJSA0KSB7XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIHJldHVybiBzO1xuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICByZXR1cm4gYCR7c309YDtcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgcmV0dXJuIGAke3N9PT1gO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIHMuc2xpY2UoMSk7XG4gICAgfVxufVxuZXhwb3J0cy5zdHJpbmdUb0Jhc2U2NE1hcHBlciA9IHN0cmluZ1RvQmFzZTY0TWFwcGVyO1xuZnVuY3Rpb24gc3RyaW5nVG9CYXNlNjRVbm1hcHBlcih2YWx1ZSkge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdzdHJpbmcnIHx8IHZhbHVlLmxlbmd0aCAlIDQgIT09IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHN0cmluZyByZWNlaXZlZCcpO1xuICAgIH1cbiAgICBjb25zdCBsYXN0VHJhaWxpbmdJbmRleCA9IHZhbHVlLmluZGV4T2YoJz0nKTtcbiAgICBpZiAobGFzdFRyYWlsaW5nSW5kZXggPT09IC0xKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgY29uc3QgbnVtVHJhaWxpbmdzID0gdmFsdWUubGVuZ3RoIC0gbGFzdFRyYWlsaW5nSW5kZXg7XG4gICAgaWYgKG51bVRyYWlsaW5ncyA+IDIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgdW5tYXAgdGhlIHBhc3NlZCB2YWx1ZScpO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWUuc3Vic3RyaW5nKDAsIGxhc3RUcmFpbGluZ0luZGV4KTtcbn1cbmV4cG9ydHMuc3RyaW5nVG9CYXNlNjRVbm1hcHBlciA9IHN0cmluZ1RvQmFzZTY0VW5tYXBwZXI7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMudGltZVRvRGF0ZVVubWFwcGVyID0gZXhwb3J0cy50aW1lVG9EYXRlTWFwcGVyID0gdm9pZCAwO1xuZnVuY3Rpb24gdGltZVRvRGF0ZU1hcHBlcih0aW1lKSB7XG4gICAgcmV0dXJuIG5ldyBEYXRlKHRpbWUpO1xufVxuZXhwb3J0cy50aW1lVG9EYXRlTWFwcGVyID0gdGltZVRvRGF0ZU1hcHBlcjtcbmZ1bmN0aW9uIHRpbWVUb0RhdGVVbm1hcHBlcih2YWx1ZSkge1xuICAgIGlmICghKHZhbHVlIGluc3RhbmNlb2YgRGF0ZSkgfHwgdmFsdWUuY29uc3RydWN0b3IgIT09IERhdGUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdOb3QgYSB2YWxpZCB2YWx1ZSBmb3IgZGF0ZSB1bm1hcHBlcicpO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWUuZ2V0VGltZSgpO1xufVxuZXhwb3J0cy50aW1lVG9EYXRlVW5tYXBwZXIgPSB0aW1lVG9EYXRlVW5tYXBwZXI7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuYnVpbGRWYWx1ZXNBbmRTZXBhcmF0ZUtleXNUb09iamVjdFVubWFwcGVyID0gZXhwb3J0cy5idWlsZFZhbHVlc0FuZFNlcGFyYXRlS2V5c1RvT2JqZWN0TWFwcGVyID0gdm9pZCAwO1xuZnVuY3Rpb24gYnVpbGRWYWx1ZXNBbmRTZXBhcmF0ZUtleXNUb09iamVjdE1hcHBlcihrZXlzLCBub0tleVZhbHVlKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIHZhbHVlc0FuZFNlcGFyYXRlS2V5c1RvT2JqZWN0TWFwcGVyKGdzKSB7XG4gICAgICAgIGNvbnN0IG9iaiA9IHt9O1xuICAgICAgICBmb3IgKGxldCBpZHggPSAwOyBpZHggIT09IGtleXMubGVuZ3RoOyArK2lkeCkge1xuICAgICAgICAgICAgY29uc3QgdmFsdWVXcmFwcGVyID0gZ3NbaWR4XTtcbiAgICAgICAgICAgIGlmICh2YWx1ZVdyYXBwZXIgIT09IG5vS2V5VmFsdWUpIHtcbiAgICAgICAgICAgICAgICBvYmpba2V5c1tpZHhdXSA9IHZhbHVlV3JhcHBlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH07XG59XG5leHBvcnRzLmJ1aWxkVmFsdWVzQW5kU2VwYXJhdGVLZXlzVG9PYmplY3RNYXBwZXIgPSBidWlsZFZhbHVlc0FuZFNlcGFyYXRlS2V5c1RvT2JqZWN0TWFwcGVyO1xuZnVuY3Rpb24gYnVpbGRWYWx1ZXNBbmRTZXBhcmF0ZUtleXNUb09iamVjdFVubWFwcGVyKGtleXMsIG5vS2V5VmFsdWUpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gdmFsdWVzQW5kU2VwYXJhdGVLZXlzVG9PYmplY3RVbm1hcHBlcih2YWx1ZSkge1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnb2JqZWN0JyB8fCB2YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbmNvbXBhdGlibGUgaW5zdGFuY2UgcmVjZWl2ZWQ6IHNob3VsZCBiZSBhIG5vbi1udWxsIG9iamVjdCcpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghKCdjb25zdHJ1Y3RvcicgaW4gdmFsdWUpIHx8IHZhbHVlLmNvbnN0cnVjdG9yICE9PSBPYmplY3QpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW5jb21wYXRpYmxlIGluc3RhbmNlIHJlY2VpdmVkOiBzaG91bGQgYmUgb2YgZXhhY3QgdHlwZSBPYmplY3QnKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgZXh0cmFjdGVkUHJvcGVydGllc0NvdW50ID0gMDtcbiAgICAgICAgY29uc3QgZXh0cmFjdGVkVmFsdWVzID0gW107XG4gICAgICAgIGZvciAobGV0IGlkeCA9IDA7IGlkeCAhPT0ga2V5cy5sZW5ndGg7ICsraWR4KSB7XG4gICAgICAgICAgICBjb25zdCBkZXNjcmlwdG9yID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih2YWx1ZSwga2V5c1tpZHhdKTtcbiAgICAgICAgICAgIGlmIChkZXNjcmlwdG9yICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWRlc2NyaXB0b3IuY29uZmlndXJhYmxlIHx8ICFkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgIWRlc2NyaXB0b3Iud3JpdGFibGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbmNvbXBhdGlibGUgaW5zdGFuY2UgcmVjZWl2ZWQ6IHNob3VsZCBjb250YWluIG9ubHkgYy9lL3cgcHJvcGVydGllcycpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZGVzY3JpcHRvci5nZXQgIT09IHVuZGVmaW5lZCB8fCBkZXNjcmlwdG9yLnNldCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW5jb21wYXRpYmxlIGluc3RhbmNlIHJlY2VpdmVkOiBzaG91bGQgY29udGFpbiBvbmx5IG5vIGdldC9zZXQgcHJvcGVydGllcycpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICArK2V4dHJhY3RlZFByb3BlcnRpZXNDb3VudDtcbiAgICAgICAgICAgICAgICBleHRyYWN0ZWRWYWx1ZXMucHVzaChkZXNjcmlwdG9yLnZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGV4dHJhY3RlZFZhbHVlcy5wdXNoKG5vS2V5VmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG5hbWVQcm9wZXJ0aWVzQ291bnQgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh2YWx1ZSkubGVuZ3RoO1xuICAgICAgICBjb25zdCBzeW1ib2xQcm9wZXJ0aWVzQ291bnQgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHZhbHVlKS5sZW5ndGg7XG4gICAgICAgIGlmIChleHRyYWN0ZWRQcm9wZXJ0aWVzQ291bnQgIT09IG5hbWVQcm9wZXJ0aWVzQ291bnQgKyBzeW1ib2xQcm9wZXJ0aWVzQ291bnQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW5jb21wYXRpYmxlIGluc3RhbmNlIHJlY2VpdmVkOiBzaG91bGQgbm90IGNvbnRhaW4gZXh0cmEgcHJvcGVydGllcycpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBleHRyYWN0ZWRWYWx1ZXM7XG4gICAgfTtcbn1cbmV4cG9ydHMuYnVpbGRWYWx1ZXNBbmRTZXBhcmF0ZUtleXNUb09iamVjdFVubWFwcGVyID0gYnVpbGRWYWx1ZXNBbmRTZXBhcmF0ZUtleXNUb09iamVjdFVubWFwcGVyO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnNlbnRlbmNlc1RvUGFyYWdyYXBoVW5tYXBwZXIgPSBleHBvcnRzLnNlbnRlbmNlc1RvUGFyYWdyYXBoTWFwcGVyID0gZXhwb3J0cy53b3Jkc1RvU2VudGVuY2VVbm1hcHBlckZvciA9IGV4cG9ydHMud29yZHNUb1NlbnRlbmNlTWFwcGVyID0gZXhwb3J0cy53b3Jkc1RvSm9pbmVkU3RyaW5nVW5tYXBwZXJGb3IgPSBleHBvcnRzLndvcmRzVG9Kb2luZWRTdHJpbmdNYXBwZXIgPSB2b2lkIDA7XG5mdW5jdGlvbiB3b3Jkc1RvSm9pbmVkU3RyaW5nTWFwcGVyKHdvcmRzKSB7XG4gICAgcmV0dXJuIHdvcmRzLm1hcCgodykgPT4gKHdbdy5sZW5ndGggLSAxXSA9PT0gJywnID8gdy5zdWJzdHIoMCwgdy5sZW5ndGggLSAxKSA6IHcpKS5qb2luKCcgJyk7XG59XG5leHBvcnRzLndvcmRzVG9Kb2luZWRTdHJpbmdNYXBwZXIgPSB3b3Jkc1RvSm9pbmVkU3RyaW5nTWFwcGVyO1xuZnVuY3Rpb24gd29yZHNUb0pvaW5lZFN0cmluZ1VubWFwcGVyRm9yKHdvcmRzQXJiaXRyYXJ5KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIHdvcmRzVG9Kb2luZWRTdHJpbmdVbm1hcHBlcih2YWx1ZSkge1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbnN1cHBvcnRlZCB0eXBlJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgd29yZHMgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCBjYW5kaWRhdGUgb2YgdmFsdWUuc3BsaXQoJyAnKSkge1xuICAgICAgICAgICAgaWYgKHdvcmRzQXJiaXRyYXJ5LmNhblNocmlua1dpdGhvdXRDb250ZXh0KGNhbmRpZGF0ZSkpXG4gICAgICAgICAgICAgICAgd29yZHMucHVzaChjYW5kaWRhdGUpO1xuICAgICAgICAgICAgZWxzZSBpZiAod29yZHNBcmJpdHJhcnkuY2FuU2hyaW5rV2l0aG91dENvbnRleHQoY2FuZGlkYXRlICsgJywnKSlcbiAgICAgICAgICAgICAgICB3b3Jkcy5wdXNoKGNhbmRpZGF0ZSArICcsJyk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbnN1cHBvcnRlZCB3b3JkJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHdvcmRzO1xuICAgIH07XG59XG5leHBvcnRzLndvcmRzVG9Kb2luZWRTdHJpbmdVbm1hcHBlckZvciA9IHdvcmRzVG9Kb2luZWRTdHJpbmdVbm1hcHBlckZvcjtcbmZ1bmN0aW9uIHdvcmRzVG9TZW50ZW5jZU1hcHBlcih3b3Jkcykge1xuICAgIGxldCBzZW50ZW5jZSA9IHdvcmRzLmpvaW4oJyAnKTtcbiAgICBpZiAoc2VudGVuY2Vbc2VudGVuY2UubGVuZ3RoIC0gMV0gPT09ICcsJykge1xuICAgICAgICBzZW50ZW5jZSA9IHNlbnRlbmNlLnN1YnN0cigwLCBzZW50ZW5jZS5sZW5ndGggLSAxKTtcbiAgICB9XG4gICAgcmV0dXJuIHNlbnRlbmNlWzBdLnRvVXBwZXJDYXNlKCkgKyBzZW50ZW5jZS5zdWJzdHJpbmcoMSkgKyAnLic7XG59XG5leHBvcnRzLndvcmRzVG9TZW50ZW5jZU1hcHBlciA9IHdvcmRzVG9TZW50ZW5jZU1hcHBlcjtcbmZ1bmN0aW9uIHdvcmRzVG9TZW50ZW5jZVVubWFwcGVyRm9yKHdvcmRzQXJiaXRyYXJ5KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIHdvcmRzVG9TZW50ZW5jZVVubWFwcGVyKHZhbHVlKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vuc3VwcG9ydGVkIHR5cGUnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodmFsdWUubGVuZ3RoIDwgMiB8fFxuICAgICAgICAgICAgdmFsdWVbdmFsdWUubGVuZ3RoIC0gMV0gIT09ICcuJyB8fFxuICAgICAgICAgICAgdmFsdWVbdmFsdWUubGVuZ3RoIC0gMl0gPT09ICcsJyB8fFxuICAgICAgICAgICAgdmFsdWVbMF0udG9Mb3dlckNhc2UoKS50b1VwcGVyQ2FzZSgpICE9PSB2YWx1ZVswXSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbnN1cHBvcnRlZCB2YWx1ZScpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGFkYXB0ZWRWYWx1ZSA9IHZhbHVlWzBdLnRvTG93ZXJDYXNlKCkgKyB2YWx1ZS5zdWJzdHJpbmcoMSwgdmFsdWUubGVuZ3RoIC0gMSk7XG4gICAgICAgIGNvbnN0IHdvcmRzID0gW107XG4gICAgICAgIGNvbnN0IGNhbmRpZGF0ZXMgPSBhZGFwdGVkVmFsdWUuc3BsaXQoJyAnKTtcbiAgICAgICAgZm9yIChsZXQgaWR4ID0gMDsgaWR4ICE9PSBjYW5kaWRhdGVzLmxlbmd0aDsgKytpZHgpIHtcbiAgICAgICAgICAgIGNvbnN0IGNhbmRpZGF0ZSA9IGNhbmRpZGF0ZXNbaWR4XTtcbiAgICAgICAgICAgIGlmICh3b3Jkc0FyYml0cmFyeS5jYW5TaHJpbmtXaXRob3V0Q29udGV4dChjYW5kaWRhdGUpKVxuICAgICAgICAgICAgICAgIHdvcmRzLnB1c2goY2FuZGlkYXRlKTtcbiAgICAgICAgICAgIGVsc2UgaWYgKGlkeCA9PT0gY2FuZGlkYXRlcy5sZW5ndGggLSAxICYmIHdvcmRzQXJiaXRyYXJ5LmNhblNocmlua1dpdGhvdXRDb250ZXh0KGNhbmRpZGF0ZSArICcsJykpXG4gICAgICAgICAgICAgICAgd29yZHMucHVzaChjYW5kaWRhdGUgKyAnLCcpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVW5zdXBwb3J0ZWQgd29yZCcpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB3b3JkcztcbiAgICB9O1xufVxuZXhwb3J0cy53b3Jkc1RvU2VudGVuY2VVbm1hcHBlckZvciA9IHdvcmRzVG9TZW50ZW5jZVVubWFwcGVyRm9yO1xuZnVuY3Rpb24gc2VudGVuY2VzVG9QYXJhZ3JhcGhNYXBwZXIoc2VudGVuY2VzKSB7XG4gICAgcmV0dXJuIHNlbnRlbmNlcy5qb2luKCcgJyk7XG59XG5leHBvcnRzLnNlbnRlbmNlc1RvUGFyYWdyYXBoTWFwcGVyID0gc2VudGVuY2VzVG9QYXJhZ3JhcGhNYXBwZXI7XG5mdW5jdGlvbiBzZW50ZW5jZXNUb1BhcmFncmFwaFVubWFwcGVyKHZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbnN1cHBvcnRlZCB0eXBlJyk7XG4gICAgfVxuICAgIGNvbnN0IHNlbnRlbmNlcyA9IHZhbHVlLnNwbGl0KCcuICcpO1xuICAgIGZvciAobGV0IGlkeCA9IDA7IGlkeCA8IHNlbnRlbmNlcy5sZW5ndGggLSAxOyArK2lkeCkge1xuICAgICAgICBzZW50ZW5jZXNbaWR4XSArPSAnLic7XG4gICAgfVxuICAgIHJldHVybiBzZW50ZW5jZXM7XG59XG5leHBvcnRzLnNlbnRlbmNlc1RvUGFyYWdyYXBoVW5tYXBwZXIgPSBzZW50ZW5jZXNUb1BhcmFncmFwaFVubWFwcGVyO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmFycmF5ID0gdm9pZCAwO1xuY29uc3QgQ29udmVydGVyc18xID0gcmVxdWlyZShcIi4uL2NoZWNrL2FyYml0cmFyeS9kZWZpbml0aW9uL0NvbnZlcnRlcnNcIik7XG5jb25zdCBBcnJheUFyYml0cmFyeV8xID0gcmVxdWlyZShcIi4vX2ludGVybmFscy9BcnJheUFyYml0cmFyeVwiKTtcbmNvbnN0IE1heExlbmd0aEZyb21NaW5MZW5ndGhfMSA9IHJlcXVpcmUoXCIuL19pbnRlcm5hbHMvaGVscGVycy9NYXhMZW5ndGhGcm9tTWluTGVuZ3RoXCIpO1xuZnVuY3Rpb24gYXJyYXkoYXJiLCAuLi5hcmdzKSB7XG4gICAgY29uc3QgbmV4dEFyYiA9IENvbnZlcnRlcnNfMS5jb252ZXJ0VG9OZXh0KGFyYik7XG4gICAgaWYgKGFyZ3NbMF0gPT09IHVuZGVmaW5lZClcbiAgICAgICAgcmV0dXJuIENvbnZlcnRlcnNfMS5jb252ZXJ0RnJvbU5leHQobmV3IEFycmF5QXJiaXRyYXJ5XzEuQXJyYXlBcmJpdHJhcnkobmV4dEFyYiwgMCwgTWF4TGVuZ3RoRnJvbU1pbkxlbmd0aF8xLm1heExlbmd0aEZyb21NaW5MZW5ndGgoMCkpKTtcbiAgICBpZiAodHlwZW9mIGFyZ3NbMF0gPT09ICdvYmplY3QnKSB7XG4gICAgICAgIGNvbnN0IG1pbkxlbmd0aCA9IGFyZ3NbMF0ubWluTGVuZ3RoIHx8IDA7XG4gICAgICAgIGNvbnN0IHNwZWNpZmllZE1heExlbmd0aCA9IGFyZ3NbMF0ubWF4TGVuZ3RoO1xuICAgICAgICBjb25zdCBtYXhMZW5ndGggPSBzcGVjaWZpZWRNYXhMZW5ndGggIT09IHVuZGVmaW5lZCA/IHNwZWNpZmllZE1heExlbmd0aCA6IE1heExlbmd0aEZyb21NaW5MZW5ndGhfMS5tYXhMZW5ndGhGcm9tTWluTGVuZ3RoKG1pbkxlbmd0aCk7XG4gICAgICAgIHJldHVybiBDb252ZXJ0ZXJzXzEuY29udmVydEZyb21OZXh0KG5ldyBBcnJheUFyYml0cmFyeV8xLkFycmF5QXJiaXRyYXJ5KG5leHRBcmIsIG1pbkxlbmd0aCwgbWF4TGVuZ3RoKSk7XG4gICAgfVxuICAgIGlmIChhcmdzWzFdICE9PSB1bmRlZmluZWQpXG4gICAgICAgIHJldHVybiBDb252ZXJ0ZXJzXzEuY29udmVydEZyb21OZXh0KG5ldyBBcnJheUFyYml0cmFyeV8xLkFycmF5QXJiaXRyYXJ5KG5leHRBcmIsIGFyZ3NbMF0sIGFyZ3NbMV0pKTtcbiAgICByZXR1cm4gQ29udmVydGVyc18xLmNvbnZlcnRGcm9tTmV4dChuZXcgQXJyYXlBcmJpdHJhcnlfMS5BcnJheUFyYml0cmFyeShuZXh0QXJiLCAwLCBhcmdzWzBdKSk7XG59XG5leHBvcnRzLmFycmF5ID0gYXJyYXk7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuYXNjaWkgPSB2b2lkIDA7XG5jb25zdCBDaGFyYWN0ZXJBcmJpdHJhcnlCdWlsZGVyXzEgPSByZXF1aXJlKFwiLi9faW50ZXJuYWxzL2J1aWxkZXJzL0NoYXJhY3RlckFyYml0cmFyeUJ1aWxkZXJcIik7XG5jb25zdCBJbmRleFRvUHJpbnRhYmxlSW5kZXhfMSA9IHJlcXVpcmUoXCIuL19pbnRlcm5hbHMvbWFwcGVycy9JbmRleFRvUHJpbnRhYmxlSW5kZXhcIik7XG5mdW5jdGlvbiBhc2NpaSgpIHtcbiAgICByZXR1cm4gQ2hhcmFjdGVyQXJiaXRyYXJ5QnVpbGRlcl8xLmJ1aWxkQ2hhcmFjdGVyQXJiaXRyYXJ5KDB4MDAsIDB4N2YsIEluZGV4VG9QcmludGFibGVJbmRleF8xLmluZGV4VG9QcmludGFibGVJbmRleE1hcHBlciwgSW5kZXhUb1ByaW50YWJsZUluZGV4XzEuaW5kZXhUb1ByaW50YWJsZUluZGV4VW5tYXBwZXIpO1xufVxuZXhwb3J0cy5hc2NpaSA9IGFzY2lpO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmFzY2lpU3RyaW5nID0gdm9pZCAwO1xuY29uc3QgQ29udmVydGVyc18xID0gcmVxdWlyZShcIi4uL2NoZWNrL2FyYml0cmFyeS9kZWZpbml0aW9uL0NvbnZlcnRlcnNcIik7XG5jb25zdCBhcnJheV8xID0gcmVxdWlyZShcIi4vYXJyYXlcIik7XG5jb25zdCBhc2NpaV8xID0gcmVxdWlyZShcIi4vYXNjaWlcIik7XG5jb25zdCBTdHJpbmdDb25zdHJhaW50c0V4dHJhY3Rvcl8xID0gcmVxdWlyZShcIi4vX2ludGVybmFscy9oZWxwZXJzL1N0cmluZ0NvbnN0cmFpbnRzRXh0cmFjdG9yXCIpO1xuY29uc3QgQ29kZVBvaW50c1RvU3RyaW5nXzEgPSByZXF1aXJlKFwiLi9faW50ZXJuYWxzL21hcHBlcnMvQ29kZVBvaW50c1RvU3RyaW5nXCIpO1xuZnVuY3Rpb24gYXNjaWlTdHJpbmcoLi4uYXJncykge1xuICAgIGNvbnN0IGNvbnN0cmFpbnRzID0gU3RyaW5nQ29uc3RyYWludHNFeHRyYWN0b3JfMS5leHRyYWN0U3RyaW5nQ29uc3RyYWludHMoYXJncyk7XG4gICAgcmV0dXJuIENvbnZlcnRlcnNfMS5jb252ZXJ0RnJvbU5leHQoQ29udmVydGVyc18xLmNvbnZlcnRUb05leHQoYXJyYXlfMS5hcnJheShhc2NpaV8xLmFzY2lpKCksIGNvbnN0cmFpbnRzKSkubWFwKENvZGVQb2ludHNUb1N0cmluZ18xLmNvZGVQb2ludHNUb1N0cmluZ01hcHBlciwgQ29kZVBvaW50c1RvU3RyaW5nXzEuY29kZVBvaW50c1RvU3RyaW5nVW5tYXBwZXIpKTtcbn1cbmV4cG9ydHMuYXNjaWlTdHJpbmcgPSBhc2NpaVN0cmluZztcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5iYXNlNjQgPSB2b2lkIDA7XG5jb25zdCBDaGFyYWN0ZXJBcmJpdHJhcnlCdWlsZGVyXzEgPSByZXF1aXJlKFwiLi9faW50ZXJuYWxzL2J1aWxkZXJzL0NoYXJhY3RlckFyYml0cmFyeUJ1aWxkZXJcIik7XG5mdW5jdGlvbiBiYXNlNjRNYXBwZXIodikge1xuICAgIGlmICh2IDwgMjYpXG4gICAgICAgIHJldHVybiB2ICsgNjU7XG4gICAgaWYgKHYgPCA1MilcbiAgICAgICAgcmV0dXJuIHYgKyA5NyAtIDI2O1xuICAgIGlmICh2IDwgNjIpXG4gICAgICAgIHJldHVybiB2ICsgNDggLSA1MjtcbiAgICByZXR1cm4gdiA9PT0gNjIgPyA0MyA6IDQ3O1xufVxuZnVuY3Rpb24gYmFzZTY0VW5tYXBwZXIodikge1xuICAgIGlmICh2ID49IDY1ICYmIHYgPD0gOTApXG4gICAgICAgIHJldHVybiB2IC0gNjU7XG4gICAgaWYgKHYgPj0gOTcgJiYgdiA8PSAxMjIpXG4gICAgICAgIHJldHVybiB2IC0gOTcgKyAyNjtcbiAgICBpZiAodiA+PSA0OCAmJiB2IDw9IDU3KVxuICAgICAgICByZXR1cm4gdiAtIDQ4ICsgNTI7XG4gICAgcmV0dXJuIHYgPT09IDQzID8gNjIgOiB2ID09PSA0NyA/IDYzIDogLTE7XG59XG5mdW5jdGlvbiBiYXNlNjQoKSB7XG4gICAgcmV0dXJuIENoYXJhY3RlckFyYml0cmFyeUJ1aWxkZXJfMS5idWlsZENoYXJhY3RlckFyYml0cmFyeSgwLCA2MywgYmFzZTY0TWFwcGVyLCBiYXNlNjRVbm1hcHBlcik7XG59XG5leHBvcnRzLmJhc2U2NCA9IGJhc2U2NDtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5iYXNlNjRTdHJpbmcgPSB2b2lkIDA7XG5jb25zdCBDb252ZXJ0ZXJzXzEgPSByZXF1aXJlKFwiLi4vY2hlY2svYXJiaXRyYXJ5L2RlZmluaXRpb24vQ29udmVydGVyc1wiKTtcbmNvbnN0IGFycmF5XzEgPSByZXF1aXJlKFwiLi9hcnJheVwiKTtcbmNvbnN0IGJhc2U2NF8xID0gcmVxdWlyZShcIi4vYmFzZTY0XCIpO1xuY29uc3QgTWF4TGVuZ3RoRnJvbU1pbkxlbmd0aF8xID0gcmVxdWlyZShcIi4vX2ludGVybmFscy9oZWxwZXJzL01heExlbmd0aEZyb21NaW5MZW5ndGhcIik7XG5jb25zdCBTdHJpbmdDb25zdHJhaW50c0V4dHJhY3Rvcl8xID0gcmVxdWlyZShcIi4vX2ludGVybmFscy9oZWxwZXJzL1N0cmluZ0NvbnN0cmFpbnRzRXh0cmFjdG9yXCIpO1xuY29uc3QgQ29kZVBvaW50c1RvU3RyaW5nXzEgPSByZXF1aXJlKFwiLi9faW50ZXJuYWxzL21hcHBlcnMvQ29kZVBvaW50c1RvU3RyaW5nXCIpO1xuY29uc3QgU3RyaW5nVG9CYXNlNjRfMSA9IHJlcXVpcmUoXCIuL19pbnRlcm5hbHMvbWFwcGVycy9TdHJpbmdUb0Jhc2U2NFwiKTtcbmZ1bmN0aW9uIGV4dHJhY3RNaW5NYXhDb25zdHJhaW50cyhhcmdzKSB7XG4gICAgY29uc3QgY29uc3RyYWludHMgPSBTdHJpbmdDb25zdHJhaW50c0V4dHJhY3Rvcl8xLmV4dHJhY3RTdHJpbmdDb25zdHJhaW50cyhhcmdzKTtcbiAgICBjb25zdCBtaW5MZW5ndGggPSBjb25zdHJhaW50cy5taW5MZW5ndGggIT09IHVuZGVmaW5lZCA/IGNvbnN0cmFpbnRzLm1pbkxlbmd0aCA6IDA7XG4gICAgY29uc3QgbWF4TGVuZ3RoID0gY29uc3RyYWludHMubWF4TGVuZ3RoICE9PSB1bmRlZmluZWQgPyBjb25zdHJhaW50cy5tYXhMZW5ndGggOiBNYXhMZW5ndGhGcm9tTWluTGVuZ3RoXzEubWF4TGVuZ3RoRnJvbU1pbkxlbmd0aChtaW5MZW5ndGgpO1xuICAgIHJldHVybiB7IG1pbkxlbmd0aCwgbWF4TGVuZ3RoIH07XG59XG5mdW5jdGlvbiBiYXNlNjRTdHJpbmcoLi4uYXJncykge1xuICAgIGNvbnN0IGNvbnN0cmFpbnRzID0gZXh0cmFjdE1pbk1heENvbnN0cmFpbnRzKGFyZ3MpO1xuICAgIGNvbnN0IHVuc2NhbGVkTWluTGVuZ3RoID0gY29uc3RyYWludHMubWluTGVuZ3RoO1xuICAgIGNvbnN0IHVuc2NhbGVkTWF4TGVuZ3RoID0gY29uc3RyYWludHMubWF4TGVuZ3RoO1xuICAgIGNvbnN0IG1pbkxlbmd0aCA9IHVuc2NhbGVkTWluTGVuZ3RoICsgMyAtICgodW5zY2FsZWRNaW5MZW5ndGggKyAzKSAlIDQpO1xuICAgIGNvbnN0IG1heExlbmd0aCA9IHVuc2NhbGVkTWF4TGVuZ3RoIC0gKHVuc2NhbGVkTWF4TGVuZ3RoICUgNCk7XG4gICAgaWYgKG1pbkxlbmd0aCA+IG1heExlbmd0aClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNaW5pbWFsIGxlbmd0aCBzaG91bGQgYmUgaW5mZXJpb3Igb3IgZXF1YWwgdG8gbWF4aW1hbCBsZW5ndGgnKTtcbiAgICBpZiAobWluTGVuZ3RoICUgNCAhPT0gMClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNaW5pbWFsIGxlbmd0aCBvZiBiYXNlNjQgc3RyaW5ncyBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgNCcpO1xuICAgIGlmIChtYXhMZW5ndGggJSA0ICE9PSAwKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ01heGltYWwgbGVuZ3RoIG9mIGJhc2U2NCBzdHJpbmdzIG11c3QgYmUgYSBtdWx0aXBsZSBvZiA0Jyk7XG4gICAgcmV0dXJuIENvbnZlcnRlcnNfMS5jb252ZXJ0RnJvbU5leHQoQ29udmVydGVyc18xLmNvbnZlcnRUb05leHQoYXJyYXlfMS5hcnJheShiYXNlNjRfMS5iYXNlNjQoKSwgeyBtaW5MZW5ndGgsIG1heExlbmd0aCB9KSlcbiAgICAgICAgLm1hcChDb2RlUG9pbnRzVG9TdHJpbmdfMS5jb2RlUG9pbnRzVG9TdHJpbmdNYXBwZXIsIENvZGVQb2ludHNUb1N0cmluZ18xLmNvZGVQb2ludHNUb1N0cmluZ1VubWFwcGVyKVxuICAgICAgICAubWFwKFN0cmluZ1RvQmFzZTY0XzEuc3RyaW5nVG9CYXNlNjRNYXBwZXIsIFN0cmluZ1RvQmFzZTY0XzEuc3RyaW5nVG9CYXNlNjRVbm1hcHBlcikpO1xufVxuZXhwb3J0cy5iYXNlNjRTdHJpbmcgPSBiYXNlNjRTdHJpbmc7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuYmlnSW50ID0gdm9pZCAwO1xuY29uc3QgQ29udmVydGVyc18xID0gcmVxdWlyZShcIi4uL2NoZWNrL2FyYml0cmFyeS9kZWZpbml0aW9uL0NvbnZlcnRlcnNcIik7XG5jb25zdCBCaWdJbnRBcmJpdHJhcnlfMSA9IHJlcXVpcmUoXCIuL19pbnRlcm5hbHMvQmlnSW50QXJiaXRyYXJ5XCIpO1xuZnVuY3Rpb24gYnVpbGRDb21wbGV0ZUJpZ0ludENvbnN0cmFpbnRzKGNvbnN0cmFpbnRzKSB7XG4gICAgY29uc3QgRGVmYXVsdFBvdyA9IDI1NjtcbiAgICBjb25zdCBEZWZhdWx0TWluID0gQmlnSW50KC0xKSA8PCBCaWdJbnQoRGVmYXVsdFBvdyAtIDEpO1xuICAgIGNvbnN0IERlZmF1bHRNYXggPSAoQmlnSW50KDEpIDw8IEJpZ0ludChEZWZhdWx0UG93IC0gMSkpIC0gQmlnSW50KDEpO1xuICAgIGNvbnN0IG1pbiA9IGNvbnN0cmFpbnRzLm1pbjtcbiAgICBjb25zdCBtYXggPSBjb25zdHJhaW50cy5tYXg7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgbWluOiBtaW4gIT09IHVuZGVmaW5lZCA/IG1pbiA6IERlZmF1bHRNaW4gLSAobWF4ICE9PSB1bmRlZmluZWQgJiYgbWF4IDwgQmlnSW50KDApID8gbWF4ICogbWF4IDogQmlnSW50KDApKSxcbiAgICAgICAgbWF4OiBtYXggIT09IHVuZGVmaW5lZCA/IG1heCA6IERlZmF1bHRNYXggKyAobWluICE9PSB1bmRlZmluZWQgJiYgbWluID4gQmlnSW50KDApID8gbWluICogbWluIDogQmlnSW50KDApKSxcbiAgICB9O1xufVxuZnVuY3Rpb24gZXh0cmFjdEJpZ0ludENvbnN0cmFpbnRzKGFyZ3MpIHtcbiAgICBpZiAoYXJnc1swXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiB7fTtcbiAgICB9XG4gICAgaWYgKGFyZ3NbMV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjb25zdCBjb25zdHJhaW50cyA9IGFyZ3NbMF07XG4gICAgICAgIHJldHVybiBjb25zdHJhaW50cztcbiAgICB9XG4gICAgcmV0dXJuIHsgbWluOiBhcmdzWzBdLCBtYXg6IGFyZ3NbMV0gfTtcbn1cbmZ1bmN0aW9uIGJpZ0ludCguLi5hcmdzKSB7XG4gICAgY29uc3QgY29uc3RyYWludHMgPSBidWlsZENvbXBsZXRlQmlnSW50Q29uc3RyYWludHMoZXh0cmFjdEJpZ0ludENvbnN0cmFpbnRzKGFyZ3MpKTtcbiAgICBpZiAoY29uc3RyYWludHMubWluID4gY29uc3RyYWludHMubWF4KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignZmMuYmlnSW50IGV4cGVjdHMgbWF4IHRvIGJlIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byBtaW4nKTtcbiAgICB9XG4gICAgY29uc3QgYXJiID0gbmV3IEJpZ0ludEFyYml0cmFyeV8xLkJpZ0ludEFyYml0cmFyeShjb25zdHJhaW50cy5taW4sIGNvbnN0cmFpbnRzLm1heCk7XG4gICAgcmV0dXJuIENvbnZlcnRlcnNfMS5jb252ZXJ0RnJvbU5leHRXaXRoU2hydW5rT25jZShhcmIsIGFyYi5kZWZhdWx0VGFyZ2V0KCkpO1xufVxuZXhwb3J0cy5iaWdJbnQgPSBiaWdJbnQ7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuYmlnSW50TiA9IHZvaWQgMDtcbmNvbnN0IENvbnZlcnRlcnNfMSA9IHJlcXVpcmUoXCIuLi9jaGVjay9hcmJpdHJhcnkvZGVmaW5pdGlvbi9Db252ZXJ0ZXJzXCIpO1xuY29uc3QgQmlnSW50QXJiaXRyYXJ5XzEgPSByZXF1aXJlKFwiLi9faW50ZXJuYWxzL0JpZ0ludEFyYml0cmFyeVwiKTtcbmZ1bmN0aW9uIGJpZ0ludE4obikge1xuICAgIGlmIChuIDwgMSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ZjLmJpZ0ludE4gZXhwZWN0cyByZXF1ZXN0ZWQgbnVtYmVyIG9mIGJpdHMgdG8gYmUgc3VwZXJpb3Igb3IgZXF1YWwgdG8gMScpO1xuICAgIH1cbiAgICBjb25zdCBtaW4gPSBCaWdJbnQoLTEpIDw8IEJpZ0ludChuIC0gMSk7XG4gICAgY29uc3QgbWF4ID0gKEJpZ0ludCgxKSA8PCBCaWdJbnQobiAtIDEpKSAtIEJpZ0ludCgxKTtcbiAgICBjb25zdCBhcmIgPSBuZXcgQmlnSW50QXJiaXRyYXJ5XzEuQmlnSW50QXJiaXRyYXJ5KG1pbiwgbWF4KTtcbiAgICByZXR1cm4gQ29udmVydGVyc18xLmNvbnZlcnRGcm9tTmV4dFdpdGhTaHJ1bmtPbmNlKGFyYiwgYXJiLmRlZmF1bHRUYXJnZXQoKSk7XG59XG5leHBvcnRzLmJpZ0ludE4gPSBiaWdJbnROO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmJpZ1VpbnQgPSB2b2lkIDA7XG5jb25zdCBDb252ZXJ0ZXJzXzEgPSByZXF1aXJlKFwiLi4vY2hlY2svYXJiaXRyYXJ5L2RlZmluaXRpb24vQ29udmVydGVyc1wiKTtcbmNvbnN0IEJpZ0ludEFyYml0cmFyeV8xID0gcmVxdWlyZShcIi4vX2ludGVybmFscy9CaWdJbnRBcmJpdHJhcnlcIik7XG5mdW5jdGlvbiBjb21wdXRlRGVmYXVsdE1heCgpIHtcbiAgICByZXR1cm4gKEJpZ0ludCgxKSA8PCBCaWdJbnQoMjU2KSkgLSBCaWdJbnQoMSk7XG59XG5mdW5jdGlvbiBiaWdVaW50KGNvbnN0cmFpbnRzKSB7XG4gICAgY29uc3QgcmVxdWVzdGVkTWF4ID0gdHlwZW9mIGNvbnN0cmFpbnRzID09PSAnb2JqZWN0JyA/IGNvbnN0cmFpbnRzLm1heCA6IGNvbnN0cmFpbnRzO1xuICAgIGNvbnN0IG1heCA9IHJlcXVlc3RlZE1heCAhPT0gdW5kZWZpbmVkID8gcmVxdWVzdGVkTWF4IDogY29tcHV0ZURlZmF1bHRNYXgoKTtcbiAgICBpZiAobWF4IDwgMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ZjLmJpZ1VpbnQgZXhwZWN0cyBtYXggdG8gYmUgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIHplcm8nKTtcbiAgICB9XG4gICAgY29uc3QgYXJiID0gbmV3IEJpZ0ludEFyYml0cmFyeV8xLkJpZ0ludEFyYml0cmFyeShCaWdJbnQoMCksIG1heCk7XG4gICAgcmV0dXJuIENvbnZlcnRlcnNfMS5jb252ZXJ0RnJvbU5leHRXaXRoU2hydW5rT25jZShhcmIsIGFyYi5kZWZhdWx0VGFyZ2V0KCkpO1xufVxuZXhwb3J0cy5iaWdVaW50ID0gYmlnVWludDtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5iaWdVaW50TiA9IHZvaWQgMDtcbmNvbnN0IENvbnZlcnRlcnNfMSA9IHJlcXVpcmUoXCIuLi9jaGVjay9hcmJpdHJhcnkvZGVmaW5pdGlvbi9Db252ZXJ0ZXJzXCIpO1xuY29uc3QgQmlnSW50QXJiaXRyYXJ5XzEgPSByZXF1aXJlKFwiLi9faW50ZXJuYWxzL0JpZ0ludEFyYml0cmFyeVwiKTtcbmZ1bmN0aW9uIGJpZ1VpbnROKG4pIHtcbiAgICBpZiAobiA8IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdmYy5iaWdVaW50TiBleHBlY3RzIHJlcXVlc3RlZCBudW1iZXIgb2YgYml0cyB0byBiZSBzdXBlcmlvciBvciBlcXVhbCB0byAwJyk7XG4gICAgfVxuICAgIGNvbnN0IG1pbiA9IEJpZ0ludCgwKTtcbiAgICBjb25zdCBtYXggPSAoQmlnSW50KDEpIDw8IEJpZ0ludChuKSkgLSBCaWdJbnQoMSk7XG4gICAgY29uc3QgYXJiID0gbmV3IEJpZ0ludEFyYml0cmFyeV8xLkJpZ0ludEFyYml0cmFyeShtaW4sIG1heCk7XG4gICAgcmV0dXJuIENvbnZlcnRlcnNfMS5jb252ZXJ0RnJvbU5leHRXaXRoU2hydW5rT25jZShhcmIsIGFyYi5kZWZhdWx0VGFyZ2V0KCkpO1xufVxuZXhwb3J0cy5iaWdVaW50TiA9IGJpZ1VpbnROO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmJvb2xlYW4gPSB2b2lkIDA7XG5jb25zdCBDb252ZXJ0ZXJzXzEgPSByZXF1aXJlKFwiLi4vY2hlY2svYXJiaXRyYXJ5L2RlZmluaXRpb24vQ29udmVydGVyc1wiKTtcbmNvbnN0IGludGVnZXJfMSA9IHJlcXVpcmUoXCIuL2ludGVnZXJcIik7XG5mdW5jdGlvbiBib29sZWFuTWFwcGVyKHYpIHtcbiAgICByZXR1cm4gdiA9PT0gMTtcbn1cbmZ1bmN0aW9uIGJvb2xlYW5Vbm1hcHBlcih2KSB7XG4gICAgaWYgKHR5cGVvZiB2ICE9PSAnYm9vbGVhbicpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVW5zdXBwb3J0ZWQgaW5wdXQgdHlwZScpO1xuICAgIHJldHVybiB2ID09PSB0cnVlID8gMSA6IDA7XG59XG5mdW5jdGlvbiBib29sZWFuKCkge1xuICAgIHJldHVybiBDb252ZXJ0ZXJzXzEuY29udmVydEZyb21OZXh0KENvbnZlcnRlcnNfMS5jb252ZXJ0VG9OZXh0KGludGVnZXJfMS5pbnRlZ2VyKHsgbWluOiAwLCBtYXg6IDEgfSkpXG4gICAgICAgIC5tYXAoYm9vbGVhbk1hcHBlciwgYm9vbGVhblVubWFwcGVyKVxuICAgICAgICAubm9CaWFzKCkpO1xufVxuZXhwb3J0cy5ib29sZWFuID0gYm9vbGVhbjtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5jaGFyID0gdm9pZCAwO1xuY29uc3QgQ2hhcmFjdGVyQXJiaXRyYXJ5QnVpbGRlcl8xID0gcmVxdWlyZShcIi4vX2ludGVybmFscy9idWlsZGVycy9DaGFyYWN0ZXJBcmJpdHJhcnlCdWlsZGVyXCIpO1xuZnVuY3Rpb24gaWRlbnRpdHkodikge1xuICAgIHJldHVybiB2O1xufVxuZnVuY3Rpb24gY2hhcigpIHtcbiAgICByZXR1cm4gQ2hhcmFjdGVyQXJiaXRyYXJ5QnVpbGRlcl8xLmJ1aWxkQ2hhcmFjdGVyQXJiaXRyYXJ5KDB4MjAsIDB4N2UsIGlkZW50aXR5LCBpZGVudGl0eSk7XG59XG5leHBvcnRzLmNoYXIgPSBjaGFyO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmNoYXIxNmJpdHMgPSB2b2lkIDA7XG5jb25zdCBDaGFyYWN0ZXJBcmJpdHJhcnlCdWlsZGVyXzEgPSByZXF1aXJlKFwiLi9faW50ZXJuYWxzL2J1aWxkZXJzL0NoYXJhY3RlckFyYml0cmFyeUJ1aWxkZXJcIik7XG5jb25zdCBJbmRleFRvUHJpbnRhYmxlSW5kZXhfMSA9IHJlcXVpcmUoXCIuL19pbnRlcm5hbHMvbWFwcGVycy9JbmRleFRvUHJpbnRhYmxlSW5kZXhcIik7XG5mdW5jdGlvbiBjaGFyMTZiaXRzKCkge1xuICAgIHJldHVybiBDaGFyYWN0ZXJBcmJpdHJhcnlCdWlsZGVyXzEuYnVpbGRDaGFyYWN0ZXJBcmJpdHJhcnkoMHgwMDAwLCAweGZmZmYsIEluZGV4VG9QcmludGFibGVJbmRleF8xLmluZGV4VG9QcmludGFibGVJbmRleE1hcHBlciwgSW5kZXhUb1ByaW50YWJsZUluZGV4XzEuaW5kZXhUb1ByaW50YWJsZUluZGV4VW5tYXBwZXIpO1xufVxuZXhwb3J0cy5jaGFyMTZiaXRzID0gY2hhcjE2Yml0cztcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5jbG9uZSA9IHZvaWQgMDtcbmNvbnN0IENvbnZlcnRlcnNfMSA9IHJlcXVpcmUoXCIuLi9jaGVjay9hcmJpdHJhcnkvZGVmaW5pdGlvbi9Db252ZXJ0ZXJzXCIpO1xuY29uc3QgQ2xvbmVBcmJpdHJhcnlfMSA9IHJlcXVpcmUoXCIuL19pbnRlcm5hbHMvQ2xvbmVBcmJpdHJhcnlcIik7XG5mdW5jdGlvbiBjbG9uZShhcmIsIG51bVZhbHVlcykge1xuICAgIHJldHVybiBDb252ZXJ0ZXJzXzEuY29udmVydEZyb21OZXh0KG5ldyBDbG9uZUFyYml0cmFyeV8xLkNsb25lQXJiaXRyYXJ5KENvbnZlcnRlcnNfMS5jb252ZXJ0VG9OZXh0KGFyYiksIG51bVZhbHVlcykpO1xufVxuZXhwb3J0cy5jbG9uZSA9IGNsb25lO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmNsb25lZENvbnN0YW50ID0gdm9pZCAwO1xuY29uc3QgY29uc3RhbnRfMSA9IHJlcXVpcmUoXCIuL2NvbnN0YW50XCIpO1xuZXhwb3J0cy5jbG9uZWRDb25zdGFudCA9IGNvbnN0YW50XzEuY29uc3RhbnQ7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuY29tcGFyZUJvb2xlYW5GdW5jID0gdm9pZCAwO1xuY29uc3QgQ29tcGFyZUZ1bmN0aW9uQXJiaXRyYXJ5QnVpbGRlcl8xID0gcmVxdWlyZShcIi4vX2ludGVybmFscy9idWlsZGVycy9Db21wYXJlRnVuY3Rpb25BcmJpdHJhcnlCdWlsZGVyXCIpO1xuZnVuY3Rpb24gY29tcGFyZUJvb2xlYW5GdW5jKCkge1xuICAgIHJldHVybiBDb21wYXJlRnVuY3Rpb25BcmJpdHJhcnlCdWlsZGVyXzEuYnVpbGRDb21wYXJlRnVuY3Rpb25BcmJpdHJhcnkoT2JqZWN0LmFzc2lnbigoaEEsIGhCKSA9PiBoQSA8IGhCLCB7XG4gICAgICAgIHRvU3RyaW5nKCkge1xuICAgICAgICAgICAgcmV0dXJuICcoaEEsIGhCKSA9PiBoQSA8IGhCJztcbiAgICAgICAgfSxcbiAgICB9KSk7XG59XG5leHBvcnRzLmNvbXBhcmVCb29sZWFuRnVuYyA9IGNvbXBhcmVCb29sZWFuRnVuYztcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5jb21wYXJlRnVuYyA9IHZvaWQgMDtcbmNvbnN0IENvbXBhcmVGdW5jdGlvbkFyYml0cmFyeUJ1aWxkZXJfMSA9IHJlcXVpcmUoXCIuL19pbnRlcm5hbHMvYnVpbGRlcnMvQ29tcGFyZUZ1bmN0aW9uQXJiaXRyYXJ5QnVpbGRlclwiKTtcbmZ1bmN0aW9uIGNvbXBhcmVGdW5jKCkge1xuICAgIHJldHVybiBDb21wYXJlRnVuY3Rpb25BcmJpdHJhcnlCdWlsZGVyXzEuYnVpbGRDb21wYXJlRnVuY3Rpb25BcmJpdHJhcnkoT2JqZWN0LmFzc2lnbigoaEEsIGhCKSA9PiBoQSAtIGhCLCB7XG4gICAgICAgIHRvU3RyaW5nKCkge1xuICAgICAgICAgICAgcmV0dXJuICcoaEEsIGhCKSA9PiBoQSAtIGhCJztcbiAgICAgICAgfSxcbiAgICB9KSk7XG59XG5leHBvcnRzLmNvbXBhcmVGdW5jID0gY29tcGFyZUZ1bmM7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuY29uc3RhbnQgPSB2b2lkIDA7XG5jb25zdCBDb252ZXJ0ZXJzXzEgPSByZXF1aXJlKFwiLi4vY2hlY2svYXJiaXRyYXJ5L2RlZmluaXRpb24vQ29udmVydGVyc1wiKTtcbmNvbnN0IENvbnN0YW50QXJiaXRyYXJ5XzEgPSByZXF1aXJlKFwiLi9faW50ZXJuYWxzL0NvbnN0YW50QXJiaXRyYXJ5XCIpO1xuZnVuY3Rpb24gY29uc3RhbnQodmFsdWUpIHtcbiAgICByZXR1cm4gQ29udmVydGVyc18xLmNvbnZlcnRGcm9tTmV4dChuZXcgQ29uc3RhbnRBcmJpdHJhcnlfMS5Db25zdGFudEFyYml0cmFyeShbdmFsdWVdKSk7XG59XG5leHBvcnRzLmNvbnN0YW50ID0gY29uc3RhbnQ7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuY29uc3RhbnRGcm9tID0gdm9pZCAwO1xuY29uc3QgQ29udmVydGVyc18xID0gcmVxdWlyZShcIi4uL2NoZWNrL2FyYml0cmFyeS9kZWZpbml0aW9uL0NvbnZlcnRlcnNcIik7XG5jb25zdCBDb25zdGFudEFyYml0cmFyeV8xID0gcmVxdWlyZShcIi4vX2ludGVybmFscy9Db25zdGFudEFyYml0cmFyeVwiKTtcbmZ1bmN0aW9uIGNvbnN0YW50RnJvbSguLi52YWx1ZXMpIHtcbiAgICBpZiAodmFsdWVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ZjLmNvbnN0YW50RnJvbSBleHBlY3RzIGF0IGxlYXN0IG9uZSBwYXJhbWV0ZXInKTtcbiAgICB9XG4gICAgcmV0dXJuIENvbnZlcnRlcnNfMS5jb252ZXJ0RnJvbU5leHQobmV3IENvbnN0YW50QXJiaXRyYXJ5XzEuQ29uc3RhbnRBcmJpdHJhcnkodmFsdWVzKSk7XG59XG5leHBvcnRzLmNvbnN0YW50RnJvbSA9IGNvbnN0YW50RnJvbTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5jb250ZXh0ID0gdm9pZCAwO1xuY29uc3Qgc3ltYm9sc18xID0gcmVxdWlyZShcIi4uL2NoZWNrL3N5bWJvbHNcIik7XG5jb25zdCBjb25zdGFudF8xID0gcmVxdWlyZShcIi4vY29uc3RhbnRcIik7XG5jbGFzcyBDb250ZXh0SW1wbGVtIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5yZWNlaXZlZExvZ3MgPSBbXTtcbiAgICB9XG4gICAgbG9nKGRhdGEpIHtcbiAgICAgICAgdGhpcy5yZWNlaXZlZExvZ3MucHVzaChkYXRhKTtcbiAgICB9XG4gICAgc2l6ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVjZWl2ZWRMb2dzLmxlbmd0aDtcbiAgICB9XG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh7IGxvZ3M6IHRoaXMucmVjZWl2ZWRMb2dzIH0pO1xuICAgIH1cbiAgICBbc3ltYm9sc18xLmNsb25lTWV0aG9kXSgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBDb250ZXh0SW1wbGVtKCk7XG4gICAgfVxufVxuZnVuY3Rpb24gY29udGV4dCgpIHtcbiAgICByZXR1cm4gY29uc3RhbnRfMS5jb25zdGFudChuZXcgQ29udGV4dEltcGxlbSgpKTtcbn1cbmV4cG9ydHMuY29udGV4dCA9IGNvbnRleHQ7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZGF0ZSA9IHZvaWQgMDtcbmNvbnN0IENvbnZlcnRlcnNfMSA9IHJlcXVpcmUoXCIuLi9jaGVjay9hcmJpdHJhcnkvZGVmaW5pdGlvbi9Db252ZXJ0ZXJzXCIpO1xuY29uc3QgaW50ZWdlcl8xID0gcmVxdWlyZShcIi4vaW50ZWdlclwiKTtcbmNvbnN0IFRpbWVUb0RhdGVfMSA9IHJlcXVpcmUoXCIuL19pbnRlcm5hbHMvbWFwcGVycy9UaW1lVG9EYXRlXCIpO1xuZnVuY3Rpb24gZGF0ZShjb25zdHJhaW50cykge1xuICAgIGNvbnN0IGludE1pbiA9IGNvbnN0cmFpbnRzICYmIGNvbnN0cmFpbnRzLm1pbiAhPT0gdW5kZWZpbmVkID8gY29uc3RyYWludHMubWluLmdldFRpbWUoKSA6IC04NjQwMDAwMDAwMDAwMDAwO1xuICAgIGNvbnN0IGludE1heCA9IGNvbnN0cmFpbnRzICYmIGNvbnN0cmFpbnRzLm1heCAhPT0gdW5kZWZpbmVkID8gY29uc3RyYWludHMubWF4LmdldFRpbWUoKSA6IDg2NDAwMDAwMDAwMDAwMDA7XG4gICAgaWYgKE51bWJlci5pc05hTihpbnRNaW4pKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ZjLmRhdGUgbWluIG11c3QgYmUgdmFsaWQgaW5zdGFuY2Ugb2YgRGF0ZScpO1xuICAgIGlmIChOdW1iZXIuaXNOYU4oaW50TWF4KSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdmYy5kYXRlIG1heCBtdXN0IGJlIHZhbGlkIGluc3RhbmNlIG9mIERhdGUnKTtcbiAgICBpZiAoaW50TWluID4gaW50TWF4KVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ZjLmRhdGUgbWF4IG11c3QgYmUgZ3JlYXRlciBvciBlcXVhbCB0byBtaW4nKTtcbiAgICByZXR1cm4gQ29udmVydGVyc18xLmNvbnZlcnRGcm9tTmV4dChDb252ZXJ0ZXJzXzEuY29udmVydFRvTmV4dChpbnRlZ2VyXzEuaW50ZWdlcihpbnRNaW4sIGludE1heCkpLm1hcChUaW1lVG9EYXRlXzEudGltZVRvRGF0ZU1hcHBlciwgVGltZVRvRGF0ZV8xLnRpbWVUb0RhdGVVbm1hcHBlcikpO1xufVxuZXhwb3J0cy5kYXRlID0gZGF0ZTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5kZWR1cCA9IHZvaWQgMDtcbmNvbnN0IGNsb25lXzEgPSByZXF1aXJlKFwiLi9jbG9uZVwiKTtcbmV4cG9ydHMuZGVkdXAgPSBjbG9uZV8xLmNsb25lO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmRpY3Rpb25hcnkgPSB2b2lkIDA7XG5jb25zdCBDb252ZXJ0ZXJzXzEgPSByZXF1aXJlKFwiLi4vY2hlY2svYXJiaXRyYXJ5L2RlZmluaXRpb24vQ29udmVydGVyc1wiKTtcbmNvbnN0IHNldF8xID0gcmVxdWlyZShcIi4vc2V0XCIpO1xuY29uc3QgdHVwbGVfMSA9IHJlcXVpcmUoXCIuL3R1cGxlXCIpO1xuY29uc3QgS2V5VmFsdWVQYWlyc1RvT2JqZWN0XzEgPSByZXF1aXJlKFwiLi9faW50ZXJuYWxzL21hcHBlcnMvS2V5VmFsdWVQYWlyc1RvT2JqZWN0XCIpO1xuZnVuY3Rpb24gZGljdGlvbmFyeShrZXlBcmIsIHZhbHVlQXJiKSB7XG4gICAgcmV0dXJuIENvbnZlcnRlcnNfMS5jb252ZXJ0RnJvbU5leHQoQ29udmVydGVyc18xLmNvbnZlcnRUb05leHQoc2V0XzEuc2V0KHR1cGxlXzEudHVwbGUoa2V5QXJiLCB2YWx1ZUFyYiksIHsgY29tcGFyZTogKHQxLCB0MikgPT4gdDFbMF0gPT09IHQyWzBdIH0pKS5tYXAoS2V5VmFsdWVQYWlyc1RvT2JqZWN0XzEua2V5VmFsdWVQYWlyc1RvT2JqZWN0TWFwcGVyLCBLZXlWYWx1ZVBhaXJzVG9PYmplY3RfMS5rZXlWYWx1ZVBhaXJzVG9PYmplY3RVbm1hcHBlcikpO1xufVxuZXhwb3J0cy5kaWN0aW9uYXJ5ID0gZGljdGlvbmFyeTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5mYWxzeSA9IHZvaWQgMDtcbmNvbnN0IGNvbnN0YW50RnJvbV8xID0gcmVxdWlyZShcIi4vY29uc3RhbnRGcm9tXCIpO1xuZnVuY3Rpb24gZmFsc3koY29uc3RyYWludHMpIHtcbiAgICBpZiAoIWNvbnN0cmFpbnRzIHx8ICFjb25zdHJhaW50cy53aXRoQmlnSW50KSB7XG4gICAgICAgIHJldHVybiBjb25zdGFudEZyb21fMS5jb25zdGFudEZyb20oZmFsc2UsIG51bGwsIHVuZGVmaW5lZCwgMCwgJycsIE5hTik7XG4gICAgfVxuICAgIHJldHVybiBjb25zdGFudEZyb21fMS5jb25zdGFudEZyb20oZmFsc2UsIG51bGwsIHVuZGVmaW5lZCwgMCwgJycsIE5hTiwgQmlnSW50KDApKTtcbn1cbmV4cG9ydHMuZmFsc3kgPSBmYWxzeTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5mbG9hdDMyQXJyYXkgPSB2b2lkIDA7XG5jb25zdCBGbG9hdGluZ1BvaW50QXJiaXRyYXJ5XzEgPSByZXF1aXJlKFwiLi4vY2hlY2svYXJiaXRyYXJ5L0Zsb2F0aW5nUG9pbnRBcmJpdHJhcnlcIik7XG5jb25zdCBhcnJheV8xID0gcmVxdWlyZShcIi4vYXJyYXlcIik7XG5mdW5jdGlvbiBmbG9hdDMyQXJyYXkoY29uc3RyYWludHMgPSB7fSkge1xuICAgIHJldHVybiBhcnJheV8xLmFycmF5KEZsb2F0aW5nUG9pbnRBcmJpdHJhcnlfMS5mbG9hdChPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGNvbnN0cmFpbnRzKSwgeyBuZXh0OiB0cnVlIH0pKSwgY29uc3RyYWludHMpLm1hcCgoZGF0YSkgPT4gRmxvYXQzMkFycmF5LmZyb20oZGF0YSkpO1xufVxuZXhwb3J0cy5mbG9hdDMyQXJyYXkgPSBmbG9hdDMyQXJyYXk7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZmxvYXQ2NEFycmF5ID0gdm9pZCAwO1xuY29uc3QgRmxvYXRpbmdQb2ludEFyYml0cmFyeV8xID0gcmVxdWlyZShcIi4uL2NoZWNrL2FyYml0cmFyeS9GbG9hdGluZ1BvaW50QXJiaXRyYXJ5XCIpO1xuY29uc3QgYXJyYXlfMSA9IHJlcXVpcmUoXCIuL2FycmF5XCIpO1xuZnVuY3Rpb24gZmxvYXQ2NEFycmF5KGNvbnN0cmFpbnRzID0ge30pIHtcbiAgICByZXR1cm4gYXJyYXlfMS5hcnJheShGbG9hdGluZ1BvaW50QXJiaXRyYXJ5XzEuZG91YmxlKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgY29uc3RyYWludHMpLCB7IG5leHQ6IHRydWUgfSkpLCBjb25zdHJhaW50cykubWFwKChkYXRhKSA9PiBGbG9hdDY0QXJyYXkuZnJvbShkYXRhKSk7XG59XG5leHBvcnRzLmZsb2F0NjRBcnJheSA9IGZsb2F0NjRBcnJheTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5mcmVxdWVuY3kgPSB2b2lkIDA7XG5jb25zdCBGcmVxdWVuY3lBcmJpdHJhcnlfMSA9IHJlcXVpcmUoXCIuL19pbnRlcm5hbHMvRnJlcXVlbmN5QXJiaXRyYXJ5XCIpO1xuZnVuY3Rpb24gaXNGcmVxdWVuY3lDb250cmFpbnRzKHBhcmFtKSB7XG4gICAgcmV0dXJuIHBhcmFtICE9IG51bGwgJiYgdHlwZW9mIHBhcmFtID09PSAnb2JqZWN0JyAmJiAhKCdhcmJpdHJhcnknIGluIHBhcmFtKTtcbn1cbmZ1bmN0aW9uIGZyZXF1ZW5jeSguLi5hcmdzKSB7XG4gICAgY29uc3QgbGFiZWwgPSAnZmMuZnJlcXVlbmN5JztcbiAgICBjb25zdCBjb25zdHJhaW50cyA9IGFyZ3NbMF07XG4gICAgaWYgKGlzRnJlcXVlbmN5Q29udHJhaW50cyhjb25zdHJhaW50cykpIHtcbiAgICAgICAgcmV0dXJuIEZyZXF1ZW5jeUFyYml0cmFyeV8xLkZyZXF1ZW5jeUFyYml0cmFyeS5mcm9tT2xkKGFyZ3Muc2xpY2UoMSksIGNvbnN0cmFpbnRzLCBsYWJlbCk7XG4gICAgfVxuICAgIHJldHVybiBGcmVxdWVuY3lBcmJpdHJhcnlfMS5GcmVxdWVuY3lBcmJpdHJhcnkuZnJvbU9sZChhcmdzLCB7fSwgbGFiZWwpO1xufVxuZXhwb3J0cy5mcmVxdWVuY3kgPSBmcmVxdWVuY3k7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZnVsbFVuaWNvZGUgPSB2b2lkIDA7XG5jb25zdCBDaGFyYWN0ZXJBcmJpdHJhcnlCdWlsZGVyXzEgPSByZXF1aXJlKFwiLi9faW50ZXJuYWxzL2J1aWxkZXJzL0NoYXJhY3RlckFyYml0cmFyeUJ1aWxkZXJcIik7XG5jb25zdCBJbmRleFRvUHJpbnRhYmxlSW5kZXhfMSA9IHJlcXVpcmUoXCIuL19pbnRlcm5hbHMvbWFwcGVycy9JbmRleFRvUHJpbnRhYmxlSW5kZXhcIik7XG5jb25zdCBnYXBTaXplID0gMHhkZmZmICsgMSAtIDB4ZDgwMDtcbmZ1bmN0aW9uIHVuaWNvZGVNYXBwZXIodikge1xuICAgIGlmICh2IDwgMHhkODAwKVxuICAgICAgICByZXR1cm4gSW5kZXhUb1ByaW50YWJsZUluZGV4XzEuaW5kZXhUb1ByaW50YWJsZUluZGV4TWFwcGVyKHYpO1xuICAgIHJldHVybiB2ICsgZ2FwU2l6ZTtcbn1cbmZ1bmN0aW9uIHVuaWNvZGVVbm1hcHBlcih2KSB7XG4gICAgaWYgKHYgPCAweGQ4MDApXG4gICAgICAgIHJldHVybiBJbmRleFRvUHJpbnRhYmxlSW5kZXhfMS5pbmRleFRvUHJpbnRhYmxlSW5kZXhVbm1hcHBlcih2KTtcbiAgICBpZiAodiA8PSAweGRmZmYpXG4gICAgICAgIHJldHVybiAtMTtcbiAgICByZXR1cm4gdiAtIGdhcFNpemU7XG59XG5mdW5jdGlvbiBmdWxsVW5pY29kZSgpIHtcbiAgICByZXR1cm4gQ2hhcmFjdGVyQXJiaXRyYXJ5QnVpbGRlcl8xLmJ1aWxkQ2hhcmFjdGVyQXJiaXRyYXJ5KDB4MDAwMCwgMHgxMGZmZmYgLSBnYXBTaXplLCB1bmljb2RlTWFwcGVyLCB1bmljb2RlVW5tYXBwZXIpO1xufVxuZXhwb3J0cy5mdWxsVW5pY29kZSA9IGZ1bGxVbmljb2RlO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmZ1bGxVbmljb2RlU3RyaW5nID0gdm9pZCAwO1xuY29uc3QgQ29udmVydGVyc18xID0gcmVxdWlyZShcIi4uL2NoZWNrL2FyYml0cmFyeS9kZWZpbml0aW9uL0NvbnZlcnRlcnNcIik7XG5jb25zdCBhcnJheV8xID0gcmVxdWlyZShcIi4vYXJyYXlcIik7XG5jb25zdCBmdWxsVW5pY29kZV8xID0gcmVxdWlyZShcIi4vZnVsbFVuaWNvZGVcIik7XG5jb25zdCBTdHJpbmdDb25zdHJhaW50c0V4dHJhY3Rvcl8xID0gcmVxdWlyZShcIi4vX2ludGVybmFscy9oZWxwZXJzL1N0cmluZ0NvbnN0cmFpbnRzRXh0cmFjdG9yXCIpO1xuY29uc3QgQ29kZVBvaW50c1RvU3RyaW5nXzEgPSByZXF1aXJlKFwiLi9faW50ZXJuYWxzL21hcHBlcnMvQ29kZVBvaW50c1RvU3RyaW5nXCIpO1xuZnVuY3Rpb24gZnVsbFVuaWNvZGVTdHJpbmcoLi4uYXJncykge1xuICAgIGNvbnN0IGNvbnN0cmFpbnRzID0gU3RyaW5nQ29uc3RyYWludHNFeHRyYWN0b3JfMS5leHRyYWN0U3RyaW5nQ29uc3RyYWludHMoYXJncyk7XG4gICAgcmV0dXJuIENvbnZlcnRlcnNfMS5jb252ZXJ0RnJvbU5leHQoQ29udmVydGVyc18xLmNvbnZlcnRUb05leHQoYXJyYXlfMS5hcnJheShmdWxsVW5pY29kZV8xLmZ1bGxVbmljb2RlKCksIGNvbnN0cmFpbnRzKSkubWFwKENvZGVQb2ludHNUb1N0cmluZ18xLmNvZGVQb2ludHNUb1N0cmluZ01hcHBlciwgQ29kZVBvaW50c1RvU3RyaW5nXzEuY29kZVBvaW50c1RvU3RyaW5nVW5tYXBwZXIpKTtcbn1cbmV4cG9ydHMuZnVsbFVuaWNvZGVTdHJpbmcgPSBmdWxsVW5pY29kZVN0cmluZztcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5mdW5jID0gdm9pZCAwO1xuY29uc3QgaGFzaF8xID0gcmVxdWlyZShcIi4uL3V0aWxzL2hhc2hcIik7XG5jb25zdCBzdHJpbmdpZnlfMSA9IHJlcXVpcmUoXCIuLi91dGlscy9zdHJpbmdpZnlcIik7XG5jb25zdCBzeW1ib2xzXzEgPSByZXF1aXJlKFwiLi4vY2hlY2svc3ltYm9sc1wiKTtcbmNvbnN0IGFycmF5XzEgPSByZXF1aXJlKFwiLi9hcnJheVwiKTtcbmNvbnN0IGludGVnZXJfMSA9IHJlcXVpcmUoXCIuL2ludGVnZXJcIik7XG5jb25zdCB0dXBsZV8xID0gcmVxdWlyZShcIi4vdHVwbGVcIik7XG5jb25zdCBUZXh0RXNjYXBlcl8xID0gcmVxdWlyZShcIi4uL2NoZWNrL2FyYml0cmFyeS9oZWxwZXJzL1RleHRFc2NhcGVyXCIpO1xuZnVuY3Rpb24gZnVuYyhhcmIpIHtcbiAgICByZXR1cm4gdHVwbGVfMS50dXBsZShhcnJheV8xLmFycmF5KGFyYiwgeyBtaW5MZW5ndGg6IDEgfSksIGludGVnZXJfMS5pbnRlZ2VyKCkubm9TaHJpbmsoKSkubWFwKChbb3V0cywgc2VlZF0pID0+IHtcbiAgICAgICAgY29uc3QgcHJvZHVjZXIgPSAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCByZWNvcmRlZCA9IHt9O1xuICAgICAgICAgICAgY29uc3QgZiA9ICguLi5hcmdzKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVwciA9IHN0cmluZ2lmeV8xLnN0cmluZ2lmeShhcmdzKTtcbiAgICAgICAgICAgICAgICBjb25zdCB2YWwgPSBvdXRzW2hhc2hfMS5oYXNoKGAke3NlZWR9JHtyZXByfWApICUgb3V0cy5sZW5ndGhdO1xuICAgICAgICAgICAgICAgIHJlY29yZGVkW3JlcHJdID0gdmFsO1xuICAgICAgICAgICAgICAgIHJldHVybiBzeW1ib2xzXzEuaGFzQ2xvbmVNZXRob2QodmFsKSA/IHZhbFtzeW1ib2xzXzEuY2xvbmVNZXRob2RdKCkgOiB2YWw7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZnVuY3Rpb24gcHJldHR5UHJpbnQoc3RyaW5naWZpZWRPdXRzKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2VlblZhbHVlcyA9IE9iamVjdC5rZXlzKHJlY29yZGVkKVxuICAgICAgICAgICAgICAgICAgICAuc29ydCgpXG4gICAgICAgICAgICAgICAgICAgIC5tYXAoKGspID0+IGAke2t9ID0+ICR7c3RyaW5naWZ5XzEuc3RyaW5naWZ5KHJlY29yZGVkW2tdKX1gKVxuICAgICAgICAgICAgICAgICAgICAubWFwKChsaW5lKSA9PiBgLyogJHtUZXh0RXNjYXBlcl8xLmVzY2FwZUZvck11bHRpbGluZUNvbW1lbnRzKGxpbmUpfSAqL2ApO1xuICAgICAgICAgICAgICAgIHJldHVybiBgZnVuY3Rpb24oLi4uYXJncykge1xuICAvLyBXaXRoIGhhc2ggYW5kIHN0cmluZ2lmeSBjb21pbmcgZnJvbSBmYXN0LWNoZWNrJHtzZWVuVmFsdWVzLmxlbmd0aCAhPT0gMCA/IGBcXG4gICR7c2VlblZhbHVlcy5qb2luKCdcXG4gICcpfWAgOiAnJ31cbiAgY29uc3Qgb3V0cyA9ICR7c3RyaW5naWZpZWRPdXRzfTtcbiAgcmV0dXJuIG91dHNbaGFzaCgnJHtzZWVkfScgKyBzdHJpbmdpZnkoYXJncykpICUgb3V0cy5sZW5ndGhdO1xufWA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoZiwge1xuICAgICAgICAgICAgICAgIHRvU3RyaW5nOiB7IHZhbHVlOiAoKSA9PiBwcmV0dHlQcmludChzdHJpbmdpZnlfMS5zdHJpbmdpZnkob3V0cykpIH0sXG4gICAgICAgICAgICAgICAgW3N0cmluZ2lmeV8xLnRvU3RyaW5nTWV0aG9kXTogeyB2YWx1ZTogKCkgPT4gcHJldHR5UHJpbnQoc3RyaW5naWZ5XzEuc3RyaW5naWZ5KG91dHMpKSB9LFxuICAgICAgICAgICAgICAgIFtzdHJpbmdpZnlfMS5hc3luY1RvU3RyaW5nTWV0aG9kXTogeyB2YWx1ZTogYXN5bmMgKCkgPT4gcHJldHR5UHJpbnQoYXdhaXQgc3RyaW5naWZ5XzEuYXN5bmNTdHJpbmdpZnkob3V0cykpIH0sXG4gICAgICAgICAgICAgICAgW3N5bWJvbHNfMS5jbG9uZU1ldGhvZF06IHsgdmFsdWU6IHByb2R1Y2VyLCBjb25maWd1cmFibGU6IHRydWUgfSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gcHJvZHVjZXIoKTtcbiAgICB9KTtcbn1cbmV4cG9ydHMuZnVuYyA9IGZ1bmM7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZ2VuZXJpY1R1cGxlID0gdm9pZCAwO1xuY29uc3QgQ29udmVydGVyc18xID0gcmVxdWlyZShcIi4uL2NoZWNrL2FyYml0cmFyeS9kZWZpbml0aW9uL0NvbnZlcnRlcnNcIik7XG5jb25zdCBUdXBsZUFyYml0cmFyeV8xID0gcmVxdWlyZShcIi4vX2ludGVybmFscy9UdXBsZUFyYml0cmFyeVwiKTtcbmZ1bmN0aW9uIGdlbmVyaWNUdXBsZShhcmJzKSB7XG4gICAgY29uc3QgbmV4dEFyYnMgPSBhcmJzLm1hcCgoYXJiKSA9PiBDb252ZXJ0ZXJzXzEuY29udmVydFRvTmV4dChhcmIpKTtcbiAgICByZXR1cm4gQ29udmVydGVyc18xLmNvbnZlcnRGcm9tTmV4dChuZXcgVHVwbGVBcmJpdHJhcnlfMS5UdXBsZUFyYml0cmFyeShuZXh0QXJicykpO1xufVxuZXhwb3J0cy5nZW5lcmljVHVwbGUgPSBnZW5lcmljVHVwbGU7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuaGV4YSA9IHZvaWQgMDtcbmNvbnN0IENoYXJhY3RlckFyYml0cmFyeUJ1aWxkZXJfMSA9IHJlcXVpcmUoXCIuL19pbnRlcm5hbHMvYnVpbGRlcnMvQ2hhcmFjdGVyQXJiaXRyYXJ5QnVpbGRlclwiKTtcbmZ1bmN0aW9uIGhleGFNYXBwZXIodikge1xuICAgIHJldHVybiB2IDwgMTBcbiAgICAgICAgPyB2ICsgNDhcbiAgICAgICAgOiB2ICsgOTcgLSAxMDtcbn1cbmZ1bmN0aW9uIGhleGFVbm1hcHBlcih2KSB7XG4gICAgcmV0dXJuIHYgPCA1OFxuICAgICAgICA/IHYgLSA0OFxuICAgICAgICA6IHYgPCAxMDNcbiAgICAgICAgICAgID8gdiAtIDk3ICsgMTBcbiAgICAgICAgICAgIDogLTE7XG59XG5mdW5jdGlvbiBoZXhhKCkge1xuICAgIHJldHVybiBDaGFyYWN0ZXJBcmJpdHJhcnlCdWlsZGVyXzEuYnVpbGRDaGFyYWN0ZXJBcmJpdHJhcnkoMCwgMTUsIGhleGFNYXBwZXIsIGhleGFVbm1hcHBlcik7XG59XG5leHBvcnRzLmhleGEgPSBoZXhhO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmhleGFTdHJpbmcgPSB2b2lkIDA7XG5jb25zdCBDb252ZXJ0ZXJzXzEgPSByZXF1aXJlKFwiLi4vY2hlY2svYXJiaXRyYXJ5L2RlZmluaXRpb24vQ29udmVydGVyc1wiKTtcbmNvbnN0IGFycmF5XzEgPSByZXF1aXJlKFwiLi9hcnJheVwiKTtcbmNvbnN0IGhleGFfMSA9IHJlcXVpcmUoXCIuL2hleGFcIik7XG5jb25zdCBTdHJpbmdDb25zdHJhaW50c0V4dHJhY3Rvcl8xID0gcmVxdWlyZShcIi4vX2ludGVybmFscy9oZWxwZXJzL1N0cmluZ0NvbnN0cmFpbnRzRXh0cmFjdG9yXCIpO1xuY29uc3QgQ29kZVBvaW50c1RvU3RyaW5nXzEgPSByZXF1aXJlKFwiLi9faW50ZXJuYWxzL21hcHBlcnMvQ29kZVBvaW50c1RvU3RyaW5nXCIpO1xuZnVuY3Rpb24gaGV4YVN0cmluZyguLi5hcmdzKSB7XG4gICAgY29uc3QgY29uc3RyYWludHMgPSBTdHJpbmdDb25zdHJhaW50c0V4dHJhY3Rvcl8xLmV4dHJhY3RTdHJpbmdDb25zdHJhaW50cyhhcmdzKTtcbiAgICByZXR1cm4gQ29udmVydGVyc18xLmNvbnZlcnRGcm9tTmV4dChDb252ZXJ0ZXJzXzEuY29udmVydFRvTmV4dChhcnJheV8xLmFycmF5KGhleGFfMS5oZXhhKCksIGNvbnN0cmFpbnRzKSkubWFwKENvZGVQb2ludHNUb1N0cmluZ18xLmNvZGVQb2ludHNUb1N0cmluZ01hcHBlciwgQ29kZVBvaW50c1RvU3RyaW5nXzEuY29kZVBvaW50c1RvU3RyaW5nVW5tYXBwZXIpKTtcbn1cbmV4cG9ydHMuaGV4YVN0cmluZyA9IGhleGFTdHJpbmc7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuaW5maW5pdGVTdHJlYW0gPSB2b2lkIDA7XG5jb25zdCBDb252ZXJ0ZXJzXzEgPSByZXF1aXJlKFwiLi4vY2hlY2svYXJiaXRyYXJ5L2RlZmluaXRpb24vQ29udmVydGVyc1wiKTtcbmNvbnN0IFN0cmVhbUFyYml0cmFyeV8xID0gcmVxdWlyZShcIi4vX2ludGVybmFscy9TdHJlYW1BcmJpdHJhcnlcIik7XG5mdW5jdGlvbiBpbmZpbml0ZVN0cmVhbShhcmIpIHtcbiAgICByZXR1cm4gQ29udmVydGVyc18xLmNvbnZlcnRGcm9tTmV4dChuZXcgU3RyZWFtQXJiaXRyYXJ5XzEuU3RyZWFtQXJiaXRyYXJ5KENvbnZlcnRlcnNfMS5jb252ZXJ0VG9OZXh0KGFyYikpKTtcbn1cbmV4cG9ydHMuaW5maW5pdGVTdHJlYW0gPSBpbmZpbml0ZVN0cmVhbTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5pbnQxNkFycmF5ID0gdm9pZCAwO1xuY29uc3QgaW50ZWdlcl8xID0gcmVxdWlyZShcIi4vaW50ZWdlclwiKTtcbmNvbnN0IFR5cGVkSW50QXJyYXlBcmJpdHJhcnlCdWlsZGVyXzEgPSByZXF1aXJlKFwiLi9faW50ZXJuYWxzL2J1aWxkZXJzL1R5cGVkSW50QXJyYXlBcmJpdHJhcnlCdWlsZGVyXCIpO1xuZnVuY3Rpb24gaW50MTZBcnJheShjb25zdHJhaW50cyA9IHt9KSB7XG4gICAgcmV0dXJuIFR5cGVkSW50QXJyYXlBcmJpdHJhcnlCdWlsZGVyXzEudHlwZWRJbnRBcnJheUFyYml0cmFyeUFyYml0cmFyeUJ1aWxkZXIoY29uc3RyYWludHMsIC0zMjc2OCwgMzI3NjcsIEludDE2QXJyYXksIGludGVnZXJfMS5pbnRlZ2VyKTtcbn1cbmV4cG9ydHMuaW50MTZBcnJheSA9IGludDE2QXJyYXk7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuaW50MzJBcnJheSA9IHZvaWQgMDtcbmNvbnN0IGludGVnZXJfMSA9IHJlcXVpcmUoXCIuL2ludGVnZXJcIik7XG5jb25zdCBUeXBlZEludEFycmF5QXJiaXRyYXJ5QnVpbGRlcl8xID0gcmVxdWlyZShcIi4vX2ludGVybmFscy9idWlsZGVycy9UeXBlZEludEFycmF5QXJiaXRyYXJ5QnVpbGRlclwiKTtcbmZ1bmN0aW9uIGludDMyQXJyYXkoY29uc3RyYWludHMgPSB7fSkge1xuICAgIHJldHVybiBUeXBlZEludEFycmF5QXJiaXRyYXJ5QnVpbGRlcl8xLnR5cGVkSW50QXJyYXlBcmJpdHJhcnlBcmJpdHJhcnlCdWlsZGVyKGNvbnN0cmFpbnRzLCAtMHg4MDAwMDAwMCwgMHg3ZmZmZmZmZiwgSW50MzJBcnJheSwgaW50ZWdlcl8xLmludGVnZXIpO1xufVxuZXhwb3J0cy5pbnQzMkFycmF5ID0gaW50MzJBcnJheTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5pbnQ4QXJyYXkgPSB2b2lkIDA7XG5jb25zdCBpbnRlZ2VyXzEgPSByZXF1aXJlKFwiLi9pbnRlZ2VyXCIpO1xuY29uc3QgVHlwZWRJbnRBcnJheUFyYml0cmFyeUJ1aWxkZXJfMSA9IHJlcXVpcmUoXCIuL19pbnRlcm5hbHMvYnVpbGRlcnMvVHlwZWRJbnRBcnJheUFyYml0cmFyeUJ1aWxkZXJcIik7XG5mdW5jdGlvbiBpbnQ4QXJyYXkoY29uc3RyYWludHMgPSB7fSkge1xuICAgIHJldHVybiBUeXBlZEludEFycmF5QXJiaXRyYXJ5QnVpbGRlcl8xLnR5cGVkSW50QXJyYXlBcmJpdHJhcnlBcmJpdHJhcnlCdWlsZGVyKGNvbnN0cmFpbnRzLCAtMTI4LCAxMjcsIEludDhBcnJheSwgaW50ZWdlcl8xLmludGVnZXIpO1xufVxuZXhwb3J0cy5pbnQ4QXJyYXkgPSBpbnQ4QXJyYXk7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuaW50ZWdlciA9IHZvaWQgMDtcbmNvbnN0IENvbnZlcnRlcnNfMSA9IHJlcXVpcmUoXCIuLi9jaGVjay9hcmJpdHJhcnkvZGVmaW5pdGlvbi9Db252ZXJ0ZXJzXCIpO1xuY29uc3QgSW50ZWdlckFyYml0cmFyeV8xID0gcmVxdWlyZShcIi4vX2ludGVybmFscy9JbnRlZ2VyQXJiaXRyYXJ5XCIpO1xuZnVuY3Rpb24gYnVpbGRDb21wbGV0ZUludGVnZXJDb25zdHJhaW50cyhjb25zdHJhaW50cykge1xuICAgIGNvbnN0IG1pbiA9IGNvbnN0cmFpbnRzLm1pbiAhPT0gdW5kZWZpbmVkID8gY29uc3RyYWludHMubWluIDogLTB4ODAwMDAwMDA7XG4gICAgY29uc3QgbWF4ID0gY29uc3RyYWludHMubWF4ICE9PSB1bmRlZmluZWQgPyBjb25zdHJhaW50cy5tYXggOiAweDdmZmZmZmZmO1xuICAgIHJldHVybiB7IG1pbiwgbWF4IH07XG59XG5mdW5jdGlvbiBleHRyYWN0SW50ZWdlckNvbnN0cmFpbnRzKGFyZ3MpIHtcbiAgICBpZiAoYXJnc1swXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiB7fTtcbiAgICB9XG4gICAgaWYgKGFyZ3NbMV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjb25zdCBzYXJncyA9IGFyZ3M7XG4gICAgICAgIGlmICh0eXBlb2Ygc2FyZ3NbMF0gPT09ICdudW1iZXInKVxuICAgICAgICAgICAgcmV0dXJuIHsgbWF4OiBzYXJnc1swXSB9O1xuICAgICAgICByZXR1cm4gc2FyZ3NbMF07XG4gICAgfVxuICAgIGNvbnN0IHNhcmdzID0gYXJncztcbiAgICByZXR1cm4geyBtaW46IHNhcmdzWzBdLCBtYXg6IHNhcmdzWzFdIH07XG59XG5mdW5jdGlvbiBpbnRlZ2VyKC4uLmFyZ3MpIHtcbiAgICBjb25zdCBjb25zdHJhaW50cyA9IGJ1aWxkQ29tcGxldGVJbnRlZ2VyQ29uc3RyYWludHMoZXh0cmFjdEludGVnZXJDb25zdHJhaW50cyhhcmdzKSk7XG4gICAgaWYgKGNvbnN0cmFpbnRzLm1pbiA+IGNvbnN0cmFpbnRzLm1heCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ZjLmludGVnZXIgbWF4aW11bSB2YWx1ZSBzaG91bGQgYmUgZXF1YWwgb3IgZ3JlYXRlciB0aGFuIHRoZSBtaW5pbXVtIG9uZScpO1xuICAgIH1cbiAgICBjb25zdCBhcmIgPSBuZXcgSW50ZWdlckFyYml0cmFyeV8xLkludGVnZXJBcmJpdHJhcnkoY29uc3RyYWludHMubWluLCBjb25zdHJhaW50cy5tYXgpO1xuICAgIHJldHVybiBDb252ZXJ0ZXJzXzEuY29udmVydEZyb21OZXh0V2l0aFNocnVua09uY2UoYXJiLCBhcmIuZGVmYXVsdFRhcmdldCgpKTtcbn1cbmV4cG9ydHMuaW50ZWdlciA9IGludGVnZXI7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuaXBWNCA9IHZvaWQgMDtcbmNvbnN0IENvbnZlcnRlcnNfMSA9IHJlcXVpcmUoXCIuLi9jaGVjay9hcmJpdHJhcnkvZGVmaW5pdGlvbi9Db252ZXJ0ZXJzXCIpO1xuY29uc3QgbmF0XzEgPSByZXF1aXJlKFwiLi9uYXRcIik7XG5jb25zdCB0dXBsZV8xID0gcmVxdWlyZShcIi4vdHVwbGVcIik7XG5jb25zdCBOYXRUb1N0cmluZ2lmaWVkTmF0XzEgPSByZXF1aXJlKFwiLi9faW50ZXJuYWxzL21hcHBlcnMvTmF0VG9TdHJpbmdpZmllZE5hdFwiKTtcbmZ1bmN0aW9uIGRvdEpvaW5lck1hcHBlcihkYXRhKSB7XG4gICAgcmV0dXJuIGRhdGEuam9pbignLicpO1xufVxuZnVuY3Rpb24gZG90Sm9pbmVyVW5tYXBwZXIodmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnc3RyaW5nJykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgdHlwZScpO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWUuc3BsaXQoJy4nKS5tYXAoKHYpID0+IE5hdFRvU3RyaW5naWZpZWROYXRfMS50cnlQYXJzZVN0cmluZ2lmaWVkTmF0KHYsIDEwKSk7XG59XG5mdW5jdGlvbiBpcFY0KCkge1xuICAgIHJldHVybiBDb252ZXJ0ZXJzXzEuY29udmVydEZyb21OZXh0KENvbnZlcnRlcnNfMS5jb252ZXJ0VG9OZXh0KHR1cGxlXzEudHVwbGUobmF0XzEubmF0KDI1NSksIG5hdF8xLm5hdCgyNTUpLCBuYXRfMS5uYXQoMjU1KSwgbmF0XzEubmF0KDI1NSkpKS5tYXAoZG90Sm9pbmVyTWFwcGVyLCBkb3RKb2luZXJVbm1hcHBlcikpO1xufVxuZXhwb3J0cy5pcFY0ID0gaXBWNDtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5pcFY0RXh0ZW5kZWQgPSB2b2lkIDA7XG5jb25zdCBvbmVvZl8xID0gcmVxdWlyZShcIi4vb25lb2ZcIik7XG5jb25zdCB0dXBsZV8xID0gcmVxdWlyZShcIi4vdHVwbGVcIik7XG5jb25zdCBTdHJpbmdpZmllZE5hdEFyYml0cmFyeUJ1aWxkZXJfMSA9IHJlcXVpcmUoXCIuL19pbnRlcm5hbHMvYnVpbGRlcnMvU3RyaW5naWZpZWROYXRBcmJpdHJhcnlCdWlsZGVyXCIpO1xuY29uc3QgQ29udmVydGVyc18xID0gcmVxdWlyZShcIi4uL2NoZWNrL2FyYml0cmFyeS9kZWZpbml0aW9uL0NvbnZlcnRlcnNcIik7XG5mdW5jdGlvbiBkb3RKb2luZXJNYXBwZXIoZGF0YSkge1xuICAgIHJldHVybiBkYXRhLmpvaW4oJy4nKTtcbn1cbmZ1bmN0aW9uIGRvdEpvaW5lclVubWFwcGVyKHZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHR5cGUnKTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlLnNwbGl0KCcuJyk7XG59XG5mdW5jdGlvbiBpcFY0RXh0ZW5kZWQoKSB7XG4gICAgcmV0dXJuIG9uZW9mXzEub25lb2YoQ29udmVydGVyc18xLmNvbnZlcnRGcm9tTmV4dChDb252ZXJ0ZXJzXzEuY29udmVydFRvTmV4dCh0dXBsZV8xLnR1cGxlKFN0cmluZ2lmaWVkTmF0QXJiaXRyYXJ5QnVpbGRlcl8xLmJ1aWxkU3RyaW5naWZpZWROYXRBcmJpdHJhcnkoMjU1KSwgU3RyaW5naWZpZWROYXRBcmJpdHJhcnlCdWlsZGVyXzEuYnVpbGRTdHJpbmdpZmllZE5hdEFyYml0cmFyeSgyNTUpLCBTdHJpbmdpZmllZE5hdEFyYml0cmFyeUJ1aWxkZXJfMS5idWlsZFN0cmluZ2lmaWVkTmF0QXJiaXRyYXJ5KDI1NSksIFN0cmluZ2lmaWVkTmF0QXJiaXRyYXJ5QnVpbGRlcl8xLmJ1aWxkU3RyaW5naWZpZWROYXRBcmJpdHJhcnkoMjU1KSkpLm1hcChkb3RKb2luZXJNYXBwZXIsIGRvdEpvaW5lclVubWFwcGVyKSksIENvbnZlcnRlcnNfMS5jb252ZXJ0RnJvbU5leHQoQ29udmVydGVyc18xLmNvbnZlcnRUb05leHQodHVwbGVfMS50dXBsZShTdHJpbmdpZmllZE5hdEFyYml0cmFyeUJ1aWxkZXJfMS5idWlsZFN0cmluZ2lmaWVkTmF0QXJiaXRyYXJ5KDI1NSksIFN0cmluZ2lmaWVkTmF0QXJiaXRyYXJ5QnVpbGRlcl8xLmJ1aWxkU3RyaW5naWZpZWROYXRBcmJpdHJhcnkoMjU1KSwgU3RyaW5naWZpZWROYXRBcmJpdHJhcnlCdWlsZGVyXzEuYnVpbGRTdHJpbmdpZmllZE5hdEFyYml0cmFyeSg2NTUzNSkpKS5tYXAoZG90Sm9pbmVyTWFwcGVyLCBkb3RKb2luZXJVbm1hcHBlcikpLCBDb252ZXJ0ZXJzXzEuY29udmVydEZyb21OZXh0KENvbnZlcnRlcnNfMS5jb252ZXJ0VG9OZXh0KHR1cGxlXzEudHVwbGUoU3RyaW5naWZpZWROYXRBcmJpdHJhcnlCdWlsZGVyXzEuYnVpbGRTdHJpbmdpZmllZE5hdEFyYml0cmFyeSgyNTUpLCBTdHJpbmdpZmllZE5hdEFyYml0cmFyeUJ1aWxkZXJfMS5idWlsZFN0cmluZ2lmaWVkTmF0QXJiaXRyYXJ5KDE2Nzc3MjE1KSkpLm1hcChkb3RKb2luZXJNYXBwZXIsIGRvdEpvaW5lclVubWFwcGVyKSksIFN0cmluZ2lmaWVkTmF0QXJiaXRyYXJ5QnVpbGRlcl8xLmJ1aWxkU3RyaW5naWZpZWROYXRBcmJpdHJhcnkoNDI5NDk2NzI5NSkpO1xufVxuZXhwb3J0cy5pcFY0RXh0ZW5kZWQgPSBpcFY0RXh0ZW5kZWQ7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuaXBWNiA9IHZvaWQgMDtcbmNvbnN0IGFycmF5XzEgPSByZXF1aXJlKFwiLi9hcnJheVwiKTtcbmNvbnN0IENvbnZlcnRlcnNfMSA9IHJlcXVpcmUoXCIuLi9jaGVjay9hcmJpdHJhcnkvZGVmaW5pdGlvbi9Db252ZXJ0ZXJzXCIpO1xuY29uc3Qgb25lb2ZfMSA9IHJlcXVpcmUoXCIuL29uZW9mXCIpO1xuY29uc3QgaGV4YVN0cmluZ18xID0gcmVxdWlyZShcIi4vaGV4YVN0cmluZ1wiKTtcbmNvbnN0IHR1cGxlXzEgPSByZXF1aXJlKFwiLi90dXBsZVwiKTtcbmNvbnN0IGlwVjRfMSA9IHJlcXVpcmUoXCIuL2lwVjRcIik7XG5jb25zdCBFbnRpdGllc1RvSVB2Nl8xID0gcmVxdWlyZShcIi4vX2ludGVybmFscy9tYXBwZXJzL0VudGl0aWVzVG9JUHY2XCIpO1xuZnVuY3Rpb24gaDE2c1RvbDMyTWFwcGVyKFthLCBiXSkge1xuICAgIHJldHVybiBgJHthfToke2J9YDtcbn1cbmZ1bmN0aW9uIGgxNnNUb2wzMlVubWFwcGVyKHZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ3N0cmluZycpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCB0eXBlJyk7XG4gICAgaWYgKCF2YWx1ZS5pbmNsdWRlcygnOicpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgdmFsdWUnKTtcbiAgICByZXR1cm4gdmFsdWUuc3BsaXQoJzonLCAyKTtcbn1cbmZ1bmN0aW9uIGlwVjYoKSB7XG4gICAgY29uc3QgaDE2QXJiID0gaGV4YVN0cmluZ18xLmhleGFTdHJpbmcoeyBtaW5MZW5ndGg6IDEsIG1heExlbmd0aDogNCB9KTtcbiAgICBjb25zdCBsczMyQXJiID0gb25lb2ZfMS5vbmVvZihDb252ZXJ0ZXJzXzEuY29udmVydEZyb21OZXh0KENvbnZlcnRlcnNfMS5jb252ZXJ0VG9OZXh0KHR1cGxlXzEudHVwbGUoaDE2QXJiLCBoMTZBcmIpKS5tYXAoaDE2c1RvbDMyTWFwcGVyLCBoMTZzVG9sMzJVbm1hcHBlcikpLCBpcFY0XzEuaXBWNCgpKTtcbiAgICByZXR1cm4gb25lb2ZfMS5vbmVvZihDb252ZXJ0ZXJzXzEuY29udmVydEZyb21OZXh0KENvbnZlcnRlcnNfMS5jb252ZXJ0VG9OZXh0KHR1cGxlXzEudHVwbGUoYXJyYXlfMS5hcnJheShoMTZBcmIsIHsgbWluTGVuZ3RoOiA2LCBtYXhMZW5ndGg6IDYgfSksIGxzMzJBcmIpKS5tYXAoRW50aXRpZXNUb0lQdjZfMS5mdWxseVNwZWNpZmllZE1hcHBlciwgRW50aXRpZXNUb0lQdjZfMS5mdWxseVNwZWNpZmllZFVubWFwcGVyKSksIENvbnZlcnRlcnNfMS5jb252ZXJ0RnJvbU5leHQoQ29udmVydGVyc18xLmNvbnZlcnRUb05leHQodHVwbGVfMS50dXBsZShhcnJheV8xLmFycmF5KGgxNkFyYiwgeyBtaW5MZW5ndGg6IDUsIG1heExlbmd0aDogNSB9KSwgbHMzMkFyYikpLm1hcChFbnRpdGllc1RvSVB2Nl8xLm9ubHlUcmFpbGluZ01hcHBlciwgRW50aXRpZXNUb0lQdjZfMS5vbmx5VHJhaWxpbmdVbm1hcHBlcikpLCBDb252ZXJ0ZXJzXzEuY29udmVydEZyb21OZXh0KENvbnZlcnRlcnNfMS5jb252ZXJ0VG9OZXh0KHR1cGxlXzEudHVwbGUoYXJyYXlfMS5hcnJheShoMTZBcmIsIHsgbWluTGVuZ3RoOiAwLCBtYXhMZW5ndGg6IDEgfSksIGFycmF5XzEuYXJyYXkoaDE2QXJiLCB7IG1pbkxlbmd0aDogNCwgbWF4TGVuZ3RoOiA0IH0pLCBsczMyQXJiKSkubWFwKEVudGl0aWVzVG9JUHY2XzEubXVsdGlUcmFpbGluZ01hcHBlciwgRW50aXRpZXNUb0lQdjZfMS5tdWx0aVRyYWlsaW5nVW5tYXBwZXIpKSwgQ29udmVydGVyc18xLmNvbnZlcnRGcm9tTmV4dChDb252ZXJ0ZXJzXzEuY29udmVydFRvTmV4dCh0dXBsZV8xLnR1cGxlKGFycmF5XzEuYXJyYXkoaDE2QXJiLCB7IG1pbkxlbmd0aDogMCwgbWF4TGVuZ3RoOiAyIH0pLCBhcnJheV8xLmFycmF5KGgxNkFyYiwgeyBtaW5MZW5ndGg6IDMsIG1heExlbmd0aDogMyB9KSwgbHMzMkFyYikpLm1hcChFbnRpdGllc1RvSVB2Nl8xLm11bHRpVHJhaWxpbmdNYXBwZXIsIEVudGl0aWVzVG9JUHY2XzEubXVsdGlUcmFpbGluZ1VubWFwcGVyKSksIENvbnZlcnRlcnNfMS5jb252ZXJ0RnJvbU5leHQoQ29udmVydGVyc18xLmNvbnZlcnRUb05leHQodHVwbGVfMS50dXBsZShhcnJheV8xLmFycmF5KGgxNkFyYiwgeyBtaW5MZW5ndGg6IDAsIG1heExlbmd0aDogMyB9KSwgYXJyYXlfMS5hcnJheShoMTZBcmIsIHsgbWluTGVuZ3RoOiAyLCBtYXhMZW5ndGg6IDIgfSksIGxzMzJBcmIpKS5tYXAoRW50aXRpZXNUb0lQdjZfMS5tdWx0aVRyYWlsaW5nTWFwcGVyLCBFbnRpdGllc1RvSVB2Nl8xLm11bHRpVHJhaWxpbmdVbm1hcHBlcikpLCBDb252ZXJ0ZXJzXzEuY29udmVydEZyb21OZXh0KENvbnZlcnRlcnNfMS5jb252ZXJ0VG9OZXh0KHR1cGxlXzEudHVwbGUoYXJyYXlfMS5hcnJheShoMTZBcmIsIHsgbWluTGVuZ3RoOiAwLCBtYXhMZW5ndGg6IDQgfSksIGgxNkFyYiwgbHMzMkFyYikpLm1hcChFbnRpdGllc1RvSVB2Nl8xLm11bHRpVHJhaWxpbmdNYXBwZXJPbmUsIEVudGl0aWVzVG9JUHY2XzEubXVsdGlUcmFpbGluZ1VubWFwcGVyT25lKSksIENvbnZlcnRlcnNfMS5jb252ZXJ0RnJvbU5leHQoQ29udmVydGVyc18xLmNvbnZlcnRUb05leHQodHVwbGVfMS50dXBsZShhcnJheV8xLmFycmF5KGgxNkFyYiwgeyBtaW5MZW5ndGg6IDAsIG1heExlbmd0aDogNSB9KSwgbHMzMkFyYikpLm1hcChFbnRpdGllc1RvSVB2Nl8xLnNpbmdsZVRyYWlsaW5nTWFwcGVyLCBFbnRpdGllc1RvSVB2Nl8xLnNpbmdsZVRyYWlsaW5nVW5tYXBwZXIpKSwgQ29udmVydGVyc18xLmNvbnZlcnRGcm9tTmV4dChDb252ZXJ0ZXJzXzEuY29udmVydFRvTmV4dCh0dXBsZV8xLnR1cGxlKGFycmF5XzEuYXJyYXkoaDE2QXJiLCB7IG1pbkxlbmd0aDogMCwgbWF4TGVuZ3RoOiA2IH0pLCBoMTZBcmIpKS5tYXAoRW50aXRpZXNUb0lQdjZfMS5zaW5nbGVUcmFpbGluZ01hcHBlciwgRW50aXRpZXNUb0lQdjZfMS5zaW5nbGVUcmFpbGluZ1VubWFwcGVyKSksIENvbnZlcnRlcnNfMS5jb252ZXJ0RnJvbU5leHQoQ29udmVydGVyc18xLmNvbnZlcnRUb05leHQodHVwbGVfMS50dXBsZShhcnJheV8xLmFycmF5KGgxNkFyYiwgeyBtaW5MZW5ndGg6IDAsIG1heExlbmd0aDogNyB9KSkpLm1hcChFbnRpdGllc1RvSVB2Nl8xLm5vVHJhaWxpbmdNYXBwZXIsIEVudGl0aWVzVG9JUHY2XzEubm9UcmFpbGluZ1VubWFwcGVyKSkpO1xufVxuZXhwb3J0cy5pcFY2ID0gaXBWNjtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5sZXRyZWMgPSB2b2lkIDA7XG5jb25zdCBMYXp5QXJiaXRyYXJ5XzEgPSByZXF1aXJlKFwiLi9faW50ZXJuYWxzL0xhenlBcmJpdHJhcnlcIik7XG5jb25zdCBDb252ZXJ0ZXJzXzEgPSByZXF1aXJlKFwiLi4vY2hlY2svYXJiaXRyYXJ5L2RlZmluaXRpb24vQ29udmVydGVyc1wiKTtcbmZ1bmN0aW9uIGxldHJlYyhidWlsZGVyKSB7XG4gICAgY29uc3QgbGF6eUFyYnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIGNvbnN0IHRpZSA9IChrZXkpID0+IHtcbiAgICAgICAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobGF6eUFyYnMsIGtleSkpIHtcbiAgICAgICAgICAgIGxhenlBcmJzW2tleV0gPSBuZXcgTGF6eUFyYml0cmFyeV8xLkxhenlBcmJpdHJhcnkoU3RyaW5nKGtleSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBDb252ZXJ0ZXJzXzEuY29udmVydEZyb21OZXh0KGxhenlBcmJzW2tleV0pO1xuICAgIH07XG4gICAgY29uc3Qgc3RyaWN0QXJicyA9IGJ1aWxkZXIodGllKTtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBzdHJpY3RBcmJzKSB7XG4gICAgICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHN0cmljdEFyYnMsIGtleSkpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGxhenlBdEtleSA9IGxhenlBcmJzW2tleV07XG4gICAgICAgIGNvbnN0IGxhenlBcmIgPSBsYXp5QXRLZXkgIT09IHVuZGVmaW5lZCA/IGxhenlBdEtleSA6IG5ldyBMYXp5QXJiaXRyYXJ5XzEuTGF6eUFyYml0cmFyeShrZXkpO1xuICAgICAgICBsYXp5QXJiLnVuZGVybHlpbmcgPSBDb252ZXJ0ZXJzXzEuY29udmVydFRvTmV4dChzdHJpY3RBcmJzW2tleV0pO1xuICAgICAgICBsYXp5QXJic1trZXldID0gbGF6eUFyYjtcbiAgICB9XG4gICAgcmV0dXJuIHN0cmljdEFyYnM7XG59XG5leHBvcnRzLmxldHJlYyA9IGxldHJlYztcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5sb3JlbSA9IHZvaWQgMDtcbmNvbnN0IGFycmF5XzEgPSByZXF1aXJlKFwiLi9hcnJheVwiKTtcbmNvbnN0IGNvbnN0YW50XzEgPSByZXF1aXJlKFwiLi9jb25zdGFudFwiKTtcbmNvbnN0IGZyZXF1ZW5jeV8xID0gcmVxdWlyZShcIi4vZnJlcXVlbmN5XCIpO1xuY29uc3QgV29yZHNUb0xvcmVtXzEgPSByZXF1aXJlKFwiLi9faW50ZXJuYWxzL21hcHBlcnMvV29yZHNUb0xvcmVtXCIpO1xuY29uc3QgQ29udmVydGVyc18xID0gcmVxdWlyZShcIi4uL2NoZWNrL2FyYml0cmFyeS9kZWZpbml0aW9uL0NvbnZlcnRlcnNcIik7XG5jb25zdCBoID0gKHYsIHcpID0+IHtcbiAgICByZXR1cm4geyBhcmJpdHJhcnk6IGNvbnN0YW50XzEuY29uc3RhbnQodiksIHdlaWdodDogdyB9O1xufTtcbmZ1bmN0aW9uIGxvcmVtV29yZCgpIHtcbiAgICByZXR1cm4gZnJlcXVlbmN5XzEuZnJlcXVlbmN5KGgoJ25vbicsIDYpLCBoKCdhZGlwaXNjaW5nJywgNSksIGgoJ2xpZ3VsYScsIDUpLCBoKCdlbmltJywgNSksIGgoJ3BlbGxlbnRlc3F1ZScsIDUpLCBoKCdpbicsIDUpLCBoKCdhdWd1ZScsIDUpLCBoKCdldCcsIDUpLCBoKCdudWxsYScsIDUpLCBoKCdsb3JlbScsIDQpLCBoKCdzaXQnLCA0KSwgaCgnc2VkJywgNCksIGgoJ2RpYW0nLCA0KSwgaCgnZmVybWVudHVtJywgNCksIGgoJ3V0JywgNCksIGgoJ2V1JywgNCksIGgoJ2FsaXF1YW0nLCA0KSwgaCgnbWF1cmlzJywgNCksIGgoJ3ZpdGFlJywgNCksIGgoJ2ZlbGlzJywgNCksIGgoJ2lwc3VtJywgMyksIGgoJ2RvbG9yJywgMyksIGgoJ2FtZXQsJywgMyksIGgoJ2VsaXQnLCAzKSwgaCgnZXVpc21vZCcsIDMpLCBoKCdtaScsIDMpLCBoKCdvcmNpJywgMyksIGgoJ2VyYXQnLCAzKSwgaCgncHJhZXNlbnQnLCAzKSwgaCgnZWdlc3RhcycsIDMpLCBoKCdsZW8nLCAzKSwgaCgndmVsJywgMyksIGgoJ3NhcGllbicsIDMpLCBoKCdpbnRlZ2VyJywgMyksIGgoJ2N1cmFiaXR1cicsIDMpLCBoKCdjb252YWxsaXMnLCAzKSwgaCgncHVydXMnLCAzKSwgaCgncmlzdXMnLCAyKSwgaCgnc3VzcGVuZGlzc2UnLCAyKSwgaCgnbGVjdHVzJywgMiksIGgoJ25lYywnLCAyKSwgaCgndWx0cmljaWVzJywgMiksIGgoJ3NlZCwnLCAyKSwgaCgnY3JhcycsIDIpLCBoKCdlbGVtZW50dW0nLCAyKSwgaCgndWx0cmljZXMnLCAyKSwgaCgnbWFlY2VuYXMnLCAyKSwgaCgnbWFzc2EsJywgMiksIGgoJ3Zhcml1cycsIDIpLCBoKCdhLCcsIDIpLCBoKCdzZW1wZXInLCAyKSwgaCgncHJvaW4nLCAyKSwgaCgnbmVjJywgMiksIGgoJ25pc2wnLCAyKSwgaCgnYW1ldCcsIDIpLCBoKCdkdWlzJywgMiksIGgoJ2Nvbmd1ZScsIDIpLCBoKCdsaWJlcm8nLCAyKSwgaCgndmVzdGlidWx1bScsIDIpLCBoKCdwZWRlJywgMiksIGgoJ2JsYW5kaXQnLCAyKSwgaCgnc29kYWxlcycsIDIpLCBoKCdhbnRlJywgMiksIGgoJ25pYmgnLCAyKSwgaCgnYWMnLCAyKSwgaCgnYWVuZWFuJywgMiksIGgoJ21hc3NhJywgMiksIGgoJ3N1c2NpcGl0JywgMiksIGgoJ3NvbGxpY2l0dWRpbicsIDIpLCBoKCdmdXNjZScsIDIpLCBoKCd0ZW1wdXMnLCAyKSwgaCgnYWxpcXVhbSwnLCAyKSwgaCgnbnVuYycsIDIpLCBoKCd1bGxhbWNvcnBlcicsIDIpLCBoKCdyaG9uY3VzJywgMiksIGgoJ21ldHVzJywgMiksIGgoJ2ZhdWNpYnVzLCcsIDIpLCBoKCdqdXN0bycsIDIpLCBoKCdtYWduYScsIDIpLCBoKCdhdCcsIDIpLCBoKCd0aW5jaWR1bnQnLCAyKSwgaCgnY29uc2VjdGV0dXInLCAxKSwgaCgndG9ydG9yLCcsIDEpLCBoKCdkaWduaXNzaW0nLCAxKSwgaCgnY29uZ3VlLCcsIDEpLCBoKCdub24sJywgMSksIGgoJ3BvcnR0aXRvciwnLCAxKSwgaCgnbm9udW1teScsIDEpLCBoKCdtb2xlc3RpZSwnLCAxKSwgaCgnZXN0JywgMSksIGgoJ2VsZWlmZW5kJywgMSksIGgoJ21pLCcsIDEpLCBoKCdhcmN1JywgMSksIGgoJ3NjZWxlcmlzcXVlJywgMSksIGgoJ3ZpdGFlLCcsIDEpLCBoKCdjb25zZXF1YXQnLCAxKSwgaCgnaW4sJywgMSksIGgoJ3ByZXRpdW0nLCAxKSwgaCgndm9sdXRwYXQnLCAxKSwgaCgncGhhcmV0cmEnLCAxKSwgaCgndGVtcG9yJywgMSksIGgoJ2JpYmVuZHVtJywgMSksIGgoJ29kaW8nLCAxKSwgaCgnZHVpJywgMSksIGgoJ3ByaW1pcycsIDEpLCBoKCdmYXVjaWJ1cycsIDEpLCBoKCdsdWN0dXMnLCAxKSwgaCgncG9zdWVyZScsIDEpLCBoKCdjdWJpbGlhJywgMSksIGgoJ2N1cmFlLCcsIDEpLCBoKCdoZW5kcmVyaXQnLCAxKSwgaCgndmVsaXQnLCAxKSwgaCgnbWF1cmlzLCcsIDEpLCBoKCdncmF2aWRhJywgMSksIGgoJ29ybmFyZScsIDEpLCBoKCd1dCwnLCAxKSwgaCgncHVsdmluYXInLCAxKSwgaCgndmFyaXVzLCcsIDEpLCBoKCd0dXJwaXMnLCAxKSwgaCgnbmliaCwnLCAxKSwgaCgnZXJvcycsIDEpLCBoKCdpZCcsIDEpLCBoKCdhbGlxdWV0JywgMSksIGgoJ3F1aXMnLCAxKSwgaCgnbG9ib3J0aXMnLCAxKSwgaCgnY29uc2VjdGV0dWVyJywgMSksIGgoJ21vcmJpJywgMSksIGgoJ3ZlaGljdWxhJywgMSksIGgoJ3RvcnRvcicsIDEpLCBoKCd0ZWxsdXMsJywgMSksIGgoJ2lkLCcsIDEpLCBoKCdldSwnLCAxKSwgaCgncXVhbScsIDEpLCBoKCdmZXVnaWF0LCcsIDEpLCBoKCdwb3N1ZXJlLCcsIDEpLCBoKCdpYWN1bGlzJywgMSksIGgoJ2xlY3R1cywnLCAxKSwgaCgndHJpc3RpcXVlJywgMSksIGgoJ21vbGxpcywnLCAxKSwgaCgnbmlzbCwnLCAxKSwgaCgndnVscHV0YXRlJywgMSksIGgoJ3NlbScsIDEpLCBoKCd2aXZhbXVzJywgMSksIGgoJ3BsYWNlcmF0JywgMSksIGgoJ2ltcGVyZGlldCcsIDEpLCBoKCdjdXJzdXMnLCAxKSwgaCgncnV0cnVtJywgMSksIGgoJ2lhY3VsaXMsJywgMSksIGgoJ2F1Z3VlLCcsIDEpLCBoKCdsYWN1cycsIDEpKTtcbn1cbmZ1bmN0aW9uIGxvcmVtKC4uLmFyZ3MpIHtcbiAgICBjb25zdCBtYXhXb3Jkc0NvdW50ID0gdHlwZW9mIGFyZ3NbMF0gPT09ICdvYmplY3QnID8gYXJnc1swXS5tYXhDb3VudCA6IGFyZ3NbMF07XG4gICAgY29uc3Qgc2VudGVuY2VzTW9kZSA9IHR5cGVvZiBhcmdzWzBdID09PSAnb2JqZWN0JyA/IGFyZ3NbMF0ubW9kZSA9PT0gJ3NlbnRlbmNlcycgOiBhcmdzWzFdO1xuICAgIGNvbnN0IG1heENvdW50ID0gbWF4V29yZHNDb3VudCAhPT0gdW5kZWZpbmVkID8gbWF4V29yZHNDb3VudCA6IDU7XG4gICAgaWYgKG1heENvdW50IDwgMSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGxvcmVtIGhhcyB0byBwcm9kdWNlIGF0IGxlYXN0IG9uZSB3b3JkL3NlbnRlbmNlYCk7XG4gICAgfVxuICAgIGNvbnN0IHdvcmRBcmJpdHJhcnkgPSBsb3JlbVdvcmQoKTtcbiAgICBjb25zdCB3b3JkQXJiaXRyYXJ5TmV4dCA9IENvbnZlcnRlcnNfMS5jb252ZXJ0VG9OZXh0KHdvcmRBcmJpdHJhcnkpO1xuICAgIGlmIChzZW50ZW5jZXNNb2RlKSB7XG4gICAgICAgIGNvbnN0IHNlbnRlbmNlID0gQ29udmVydGVyc18xLmNvbnZlcnRUb05leHQoYXJyYXlfMS5hcnJheSh3b3JkQXJiaXRyYXJ5LCB7IG1pbkxlbmd0aDogMSB9KSkubWFwKFdvcmRzVG9Mb3JlbV8xLndvcmRzVG9TZW50ZW5jZU1hcHBlciwgV29yZHNUb0xvcmVtXzEud29yZHNUb1NlbnRlbmNlVW5tYXBwZXJGb3Iod29yZEFyYml0cmFyeU5leHQpKTtcbiAgICAgICAgcmV0dXJuIENvbnZlcnRlcnNfMS5jb252ZXJ0RnJvbU5leHQoQ29udmVydGVyc18xLmNvbnZlcnRUb05leHQoYXJyYXlfMS5hcnJheShDb252ZXJ0ZXJzXzEuY29udmVydEZyb21OZXh0KHNlbnRlbmNlKSwgeyBtaW5MZW5ndGg6IDEsIG1heExlbmd0aDogbWF4Q291bnQgfSkpLm1hcChXb3Jkc1RvTG9yZW1fMS5zZW50ZW5jZXNUb1BhcmFncmFwaE1hcHBlciwgV29yZHNUb0xvcmVtXzEuc2VudGVuY2VzVG9QYXJhZ3JhcGhVbm1hcHBlcikpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIENvbnZlcnRlcnNfMS5jb252ZXJ0RnJvbU5leHQoQ29udmVydGVyc18xLmNvbnZlcnRUb05leHQoYXJyYXlfMS5hcnJheSh3b3JkQXJiaXRyYXJ5LCB7IG1pbkxlbmd0aDogMSwgbWF4TGVuZ3RoOiBtYXhDb3VudCB9KSkubWFwKFdvcmRzVG9Mb3JlbV8xLndvcmRzVG9Kb2luZWRTdHJpbmdNYXBwZXIsIFdvcmRzVG9Mb3JlbV8xLndvcmRzVG9Kb2luZWRTdHJpbmdVbm1hcHBlckZvcih3b3JkQXJiaXRyYXJ5TmV4dCkpKTtcbiAgICB9XG59XG5leHBvcnRzLmxvcmVtID0gbG9yZW07XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMubWFwVG9Db25zdGFudCA9IHZvaWQgMDtcbmNvbnN0IENvbnZlcnRlcnNfMSA9IHJlcXVpcmUoXCIuLi9jaGVjay9hcmJpdHJhcnkvZGVmaW5pdGlvbi9Db252ZXJ0ZXJzXCIpO1xuY29uc3QgbmF0XzEgPSByZXF1aXJlKFwiLi9uYXRcIik7XG5jb25zdCBJbmRleFRvTWFwcGVkQ29uc3RhbnRfMSA9IHJlcXVpcmUoXCIuL19pbnRlcm5hbHMvbWFwcGVycy9JbmRleFRvTWFwcGVkQ29uc3RhbnRcIik7XG5mdW5jdGlvbiBjb21wdXRlTnVtQ2hvaWNlcyhvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMubGVuZ3RoID09PSAwKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGZjLm1hcFRvQ29uc3RhbnQgZXhwZWN0cyBhdCBsZWFzdCBvbmUgb3B0aW9uYCk7XG4gICAgbGV0IG51bUNob2ljZXMgPSAwO1xuICAgIGZvciAobGV0IGlkeCA9IDA7IGlkeCAhPT0gb3B0aW9ucy5sZW5ndGg7ICsraWR4KSB7XG4gICAgICAgIGlmIChvcHRpb25zW2lkeF0ubnVtIDwgMClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgZmMubWFwVG9Db25zdGFudCBleHBlY3RzIGFsbCBvcHRpb25zIHRvIGhhdmUgYSBudW1iZXIgb2YgZW50cmllcyBncmVhdGVyIG9yIGVxdWFsIHRvIHplcm9gKTtcbiAgICAgICAgbnVtQ2hvaWNlcyArPSBvcHRpb25zW2lkeF0ubnVtO1xuICAgIH1cbiAgICBpZiAobnVtQ2hvaWNlcyA9PT0gMClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBmYy5tYXBUb0NvbnN0YW50IGV4cGVjdHMgYXQgbGVhc3Qgb25lIGNob2ljZSBhbW9uZyBvcHRpb25zYCk7XG4gICAgcmV0dXJuIG51bUNob2ljZXM7XG59XG5mdW5jdGlvbiBtYXBUb0NvbnN0YW50KC4uLmVudHJpZXMpIHtcbiAgICBjb25zdCBudW1DaG9pY2VzID0gY29tcHV0ZU51bUNob2ljZXMoZW50cmllcyk7XG4gICAgcmV0dXJuIENvbnZlcnRlcnNfMS5jb252ZXJ0RnJvbU5leHQoQ29udmVydGVyc18xLmNvbnZlcnRUb05leHQobmF0XzEubmF0KHsgbWF4OiBudW1DaG9pY2VzIC0gMSB9KSkubWFwKEluZGV4VG9NYXBwZWRDb25zdGFudF8xLmluZGV4VG9NYXBwZWRDb25zdGFudE1hcHBlckZvcihlbnRyaWVzKSwgSW5kZXhUb01hcHBlZENvbnN0YW50XzEuaW5kZXhUb01hcHBlZENvbnN0YW50VW5tYXBwZXJGb3IoZW50cmllcykpKTtcbn1cbmV4cG9ydHMubWFwVG9Db25zdGFudCA9IG1hcFRvQ29uc3RhbnQ7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMubWF4U2FmZUludGVnZXIgPSB2b2lkIDA7XG5jb25zdCBDb252ZXJ0ZXJzXzEgPSByZXF1aXJlKFwiLi4vY2hlY2svYXJiaXRyYXJ5L2RlZmluaXRpb24vQ29udmVydGVyc1wiKTtcbmNvbnN0IEludGVnZXJBcmJpdHJhcnlfMSA9IHJlcXVpcmUoXCIuL19pbnRlcm5hbHMvSW50ZWdlckFyYml0cmFyeVwiKTtcbmZ1bmN0aW9uIG1heFNhZmVJbnRlZ2VyKCkge1xuICAgIGNvbnN0IGFyYiA9IG5ldyBJbnRlZ2VyQXJiaXRyYXJ5XzEuSW50ZWdlckFyYml0cmFyeShOdW1iZXIuTUlOX1NBRkVfSU5URUdFUiwgTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIpO1xuICAgIHJldHVybiBDb252ZXJ0ZXJzXzEuY29udmVydEZyb21OZXh0V2l0aFNocnVua09uY2UoYXJiLCBhcmIuZGVmYXVsdFRhcmdldCgpKTtcbn1cbmV4cG9ydHMubWF4U2FmZUludGVnZXIgPSBtYXhTYWZlSW50ZWdlcjtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5tYXhTYWZlTmF0ID0gdm9pZCAwO1xuY29uc3QgQ29udmVydGVyc18xID0gcmVxdWlyZShcIi4uL2NoZWNrL2FyYml0cmFyeS9kZWZpbml0aW9uL0NvbnZlcnRlcnNcIik7XG5jb25zdCBJbnRlZ2VyQXJiaXRyYXJ5XzEgPSByZXF1aXJlKFwiLi9faW50ZXJuYWxzL0ludGVnZXJBcmJpdHJhcnlcIik7XG5mdW5jdGlvbiBtYXhTYWZlTmF0KCkge1xuICAgIGNvbnN0IGFyYiA9IG5ldyBJbnRlZ2VyQXJiaXRyYXJ5XzEuSW50ZWdlckFyYml0cmFyeSgwLCBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUik7XG4gICAgcmV0dXJuIENvbnZlcnRlcnNfMS5jb252ZXJ0RnJvbU5leHRXaXRoU2hydW5rT25jZShhcmIsIGFyYi5kZWZhdWx0VGFyZ2V0KCkpO1xufVxuZXhwb3J0cy5tYXhTYWZlTmF0ID0gbWF4U2FmZU5hdDtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5tZW1vID0gdm9pZCAwO1xubGV0IGNvbnRleHRSZW1haW5pbmdEZXB0aCA9IDEwO1xuZnVuY3Rpb24gbWVtbyhidWlsZGVyKSB7XG4gICAgY29uc3QgcHJldmlvdXMgPSB7fTtcbiAgICByZXR1cm4gKChtYXhEZXB0aCkgPT4ge1xuICAgICAgICBjb25zdCBuID0gbWF4RGVwdGggIT09IHVuZGVmaW5lZCA/IG1heERlcHRoIDogY29udGV4dFJlbWFpbmluZ0RlcHRoO1xuICAgICAgICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChwcmV2aW91cywgbikpIHtcbiAgICAgICAgICAgIGNvbnN0IHByZXYgPSBjb250ZXh0UmVtYWluaW5nRGVwdGg7XG4gICAgICAgICAgICBjb250ZXh0UmVtYWluaW5nRGVwdGggPSBuIC0gMTtcbiAgICAgICAgICAgIHByZXZpb3VzW25dID0gYnVpbGRlcihuKTtcbiAgICAgICAgICAgIGNvbnRleHRSZW1haW5pbmdEZXB0aCA9IHByZXY7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHByZXZpb3VzW25dO1xuICAgIH0pO1xufVxuZXhwb3J0cy5tZW1vID0gbWVtbztcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5taXhlZENhc2UgPSB2b2lkIDA7XG5jb25zdCBDb252ZXJ0ZXJzXzEgPSByZXF1aXJlKFwiLi4vY2hlY2svYXJiaXRyYXJ5L2RlZmluaXRpb24vQ29udmVydGVyc1wiKTtcbmNvbnN0IE1peGVkQ2FzZUFyYml0cmFyeV8xID0gcmVxdWlyZShcIi4vX2ludGVybmFscy9NaXhlZENhc2VBcmJpdHJhcnlcIik7XG5mdW5jdGlvbiBkZWZhdWx0VG9nZ2xlQ2FzZShyYXdDaGFyKSB7XG4gICAgY29uc3QgdXBwZXIgPSByYXdDaGFyLnRvVXBwZXJDYXNlKCk7XG4gICAgaWYgKHVwcGVyICE9PSByYXdDaGFyKVxuICAgICAgICByZXR1cm4gdXBwZXI7XG4gICAgcmV0dXJuIHJhd0NoYXIudG9Mb3dlckNhc2UoKTtcbn1cbmZ1bmN0aW9uIG1peGVkQ2FzZShzdHJpbmdBcmIsIGNvbnN0cmFpbnRzKSB7XG4gICAgaWYgKHR5cGVvZiBCaWdJbnQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgbWl4ZWRDYXNlIHJlcXVpcmVzIEJpZ0ludCBzdXBwb3J0YCk7XG4gICAgfVxuICAgIGNvbnN0IHRvZ2dsZUNhc2UgPSAoY29uc3RyYWludHMgJiYgY29uc3RyYWludHMudG9nZ2xlQ2FzZSkgfHwgZGVmYXVsdFRvZ2dsZUNhc2U7XG4gICAgcmV0dXJuIENvbnZlcnRlcnNfMS5jb252ZXJ0RnJvbU5leHQobmV3IE1peGVkQ2FzZUFyYml0cmFyeV8xLk1peGVkQ2FzZUFyYml0cmFyeShDb252ZXJ0ZXJzXzEuY29udmVydFRvTmV4dChzdHJpbmdBcmIpLCB0b2dnbGVDYXNlKSk7XG59XG5leHBvcnRzLm1peGVkQ2FzZSA9IG1peGVkQ2FzZTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5uYXQgPSB2b2lkIDA7XG5jb25zdCBDb252ZXJ0ZXJzXzEgPSByZXF1aXJlKFwiLi4vY2hlY2svYXJiaXRyYXJ5L2RlZmluaXRpb24vQ29udmVydGVyc1wiKTtcbmNvbnN0IEludGVnZXJBcmJpdHJhcnlfMSA9IHJlcXVpcmUoXCIuL19pbnRlcm5hbHMvSW50ZWdlckFyYml0cmFyeVwiKTtcbmZ1bmN0aW9uIG5hdChhcmcpIHtcbiAgICBjb25zdCBtYXggPSB0eXBlb2YgYXJnID09PSAnbnVtYmVyJyA/IGFyZyA6IGFyZyAmJiBhcmcubWF4ICE9PSB1bmRlZmluZWQgPyBhcmcubWF4IDogMHg3ZmZmZmZmZjtcbiAgICBpZiAobWF4IDwgMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ZjLm5hdCB2YWx1ZSBzaG91bGQgYmUgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIDAnKTtcbiAgICB9XG4gICAgY29uc3QgYXJiID0gbmV3IEludGVnZXJBcmJpdHJhcnlfMS5JbnRlZ2VyQXJiaXRyYXJ5KDAsIG1heCk7XG4gICAgcmV0dXJuIENvbnZlcnRlcnNfMS5jb252ZXJ0RnJvbU5leHRXaXRoU2hydW5rT25jZShhcmIsIGFyYi5kZWZhdWx0VGFyZ2V0KCkpO1xufVxuZXhwb3J0cy5uYXQgPSBuYXQ7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMub25lb2YgPSB2b2lkIDA7XG5jb25zdCBGcmVxdWVuY3lBcmJpdHJhcnlfMSA9IHJlcXVpcmUoXCIuL19pbnRlcm5hbHMvRnJlcXVlbmN5QXJiaXRyYXJ5XCIpO1xuZnVuY3Rpb24gaXNPbmVPZkNvbnRyYWludHMocGFyYW0pIHtcbiAgICByZXR1cm4gcGFyYW0gIT0gbnVsbCAmJiB0eXBlb2YgcGFyYW0gPT09ICdvYmplY3QnICYmICEoJ2dlbmVyYXRlJyBpbiBwYXJhbSk7XG59XG5mdW5jdGlvbiBvbmVvZiguLi5hcmdzKSB7XG4gICAgY29uc3QgY29uc3RyYWludHMgPSBhcmdzWzBdO1xuICAgIGlmIChpc09uZU9mQ29udHJhaW50cyhjb25zdHJhaW50cykpIHtcbiAgICAgICAgY29uc3Qgd2VpZ2h0ZWRBcmJzID0gYXJncy5zbGljZSgxKS5tYXAoKGFyYml0cmFyeSkgPT4gKHsgYXJiaXRyYXJ5LCB3ZWlnaHQ6IDEgfSkpO1xuICAgICAgICByZXR1cm4gRnJlcXVlbmN5QXJiaXRyYXJ5XzEuRnJlcXVlbmN5QXJiaXRyYXJ5LmZyb21PbGQod2VpZ2h0ZWRBcmJzLCBjb25zdHJhaW50cywgJ2ZjLm9uZW9mJyk7XG4gICAgfVxuICAgIGNvbnN0IHdlaWdodGVkQXJicyA9IGFyZ3MubWFwKChhcmJpdHJhcnkpID0+ICh7IGFyYml0cmFyeSwgd2VpZ2h0OiAxIH0pKTtcbiAgICByZXR1cm4gRnJlcXVlbmN5QXJiaXRyYXJ5XzEuRnJlcXVlbmN5QXJiaXRyYXJ5LmZyb21PbGQod2VpZ2h0ZWRBcmJzLCB7fSwgJ2ZjLm9uZW9mJyk7XG59XG5leHBvcnRzLm9uZW9mID0gb25lb2Y7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMub3B0aW9uID0gdm9pZCAwO1xuY29uc3QgY29uc3RhbnRfMSA9IHJlcXVpcmUoXCIuL2NvbnN0YW50XCIpO1xuY29uc3QgRnJlcXVlbmN5QXJiaXRyYXJ5XzEgPSByZXF1aXJlKFwiLi9faW50ZXJuYWxzL0ZyZXF1ZW5jeUFyYml0cmFyeVwiKTtcbmZ1bmN0aW9uIGV4dHJhY3RPcHRpb25Db25zdHJhaW50cyhjb25zdHJhaW50cykge1xuICAgIGlmICh0eXBlb2YgY29uc3RyYWludHMgPT09ICdudW1iZXInKVxuICAgICAgICByZXR1cm4geyBmcmVxOiBjb25zdHJhaW50cyB9O1xuICAgIGlmICghY29uc3RyYWludHMpXG4gICAgICAgIHJldHVybiB7fTtcbiAgICByZXR1cm4gY29uc3RyYWludHM7XG59XG5mdW5jdGlvbiBvcHRpb24oYXJiLCByYXdDb25zdHJhaW50cykge1xuICAgIGNvbnN0IGNvbnN0cmFpbnRzID0gZXh0cmFjdE9wdGlvbkNvbnN0cmFpbnRzKHJhd0NvbnN0cmFpbnRzKTtcbiAgICBjb25zdCBmcmVxID0gY29uc3RyYWludHMuZnJlcSA9PSBudWxsID8gNSA6IGNvbnN0cmFpbnRzLmZyZXE7XG4gICAgY29uc3QgbmlsVmFsdWUgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoY29uc3RyYWludHMsICduaWwnKSA/IGNvbnN0cmFpbnRzLm5pbCA6IG51bGw7XG4gICAgY29uc3QgbmlsQXJiID0gY29uc3RhbnRfMS5jb25zdGFudChuaWxWYWx1ZSk7XG4gICAgY29uc3Qgd2VpZ2h0ZWRBcmJzID0gW1xuICAgICAgICB7IGFyYml0cmFyeTogbmlsQXJiLCB3ZWlnaHQ6IDEsIGZhbGxiYWNrVmFsdWU6IHsgZGVmYXVsdDogbmlsVmFsdWUgfSB9LFxuICAgICAgICB7IGFyYml0cmFyeTogYXJiLCB3ZWlnaHQ6IGZyZXEgfSxcbiAgICBdO1xuICAgIGNvbnN0IGZyZXF1ZW5jeUNvbnN0cmFpbnRzID0ge1xuICAgICAgICB3aXRoQ3Jvc3NTaHJpbms6IHRydWUsXG4gICAgICAgIGRlcHRoRmFjdG9yOiBjb25zdHJhaW50cy5kZXB0aEZhY3RvcixcbiAgICAgICAgbWF4RGVwdGg6IGNvbnN0cmFpbnRzLm1heERlcHRoLFxuICAgICAgICBkZXB0aElkZW50aWZpZXI6IGNvbnN0cmFpbnRzLmRlcHRoSWRlbnRpZmllcixcbiAgICB9O1xuICAgIHJldHVybiBGcmVxdWVuY3lBcmJpdHJhcnlfMS5GcmVxdWVuY3lBcmJpdHJhcnkuZnJvbU9sZCh3ZWlnaHRlZEFyYnMsIGZyZXF1ZW5jeUNvbnN0cmFpbnRzLCAnZmMub3B0aW9uJyk7XG59XG5leHBvcnRzLm9wdGlvbiA9IG9wdGlvbjtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5yZWNvcmQgPSB2b2lkIDA7XG5jb25zdCBQYXJ0aWFsUmVjb3JkQXJiaXRyYXJ5QnVpbGRlcl8xID0gcmVxdWlyZShcIi4vX2ludGVybmFscy9idWlsZGVycy9QYXJ0aWFsUmVjb3JkQXJiaXRyYXJ5QnVpbGRlclwiKTtcbmZ1bmN0aW9uIHJlY29yZChyZWNvcmRNb2RlbCwgY29uc3RyYWludHMpIHtcbiAgICBpZiAoY29uc3RyYWludHMgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gUGFydGlhbFJlY29yZEFyYml0cmFyeUJ1aWxkZXJfMS5idWlsZFBhcnRpYWxSZWNvcmRBcmJpdHJhcnkocmVjb3JkTW9kZWwsIHVuZGVmaW5lZCk7XG4gICAgfVxuICAgIGlmICgnd2l0aERlbGV0ZWRLZXlzJyBpbiBjb25zdHJhaW50cyAmJiAncmVxdWlyZWRLZXlzJyBpbiBjb25zdHJhaW50cykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHJlcXVpcmVkS2V5cyBhbmQgd2l0aERlbGV0ZWRLZXlzIGNhbm5vdCBiZSB1c2VkIHRvZ2V0aGVyIGluIGZjLnJlY29yZGApO1xuICAgIH1cbiAgICBjb25zdCByZXF1aXJlRGVsZXRlZEtleXMgPSAoJ3JlcXVpcmVkS2V5cycgaW4gY29uc3RyYWludHMgJiYgY29uc3RyYWludHMucmVxdWlyZWRLZXlzICE9PSB1bmRlZmluZWQpIHx8XG4gICAgICAgICgnd2l0aERlbGV0ZWRLZXlzJyBpbiBjb25zdHJhaW50cyAmJiAhIWNvbnN0cmFpbnRzLndpdGhEZWxldGVkS2V5cyk7XG4gICAgaWYgKCFyZXF1aXJlRGVsZXRlZEtleXMpIHtcbiAgICAgICAgcmV0dXJuIFBhcnRpYWxSZWNvcmRBcmJpdHJhcnlCdWlsZGVyXzEuYnVpbGRQYXJ0aWFsUmVjb3JkQXJiaXRyYXJ5KHJlY29yZE1vZGVsLCB1bmRlZmluZWQpO1xuICAgIH1cbiAgICBjb25zdCByZXF1aXJlZEtleXMgPSAoJ3JlcXVpcmVkS2V5cycgaW4gY29uc3RyYWludHMgPyBjb25zdHJhaW50cy5yZXF1aXJlZEtleXMgOiB1bmRlZmluZWQpIHx8IFtdO1xuICAgIGZvciAobGV0IGlkeCA9IDA7IGlkeCAhPT0gcmVxdWlyZWRLZXlzLmxlbmd0aDsgKytpZHgpIHtcbiAgICAgICAgY29uc3QgZGVzY3JpcHRvciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IocmVjb3JkTW9kZWwsIHJlcXVpcmVkS2V5c1tpZHhdKTtcbiAgICAgICAgaWYgKGRlc2NyaXB0b3IgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGByZXF1aXJlZEtleXMgY2Fubm90IHJlZmVyZW5jZSBrZXlzIHRoYXQgaGF2ZSBub3QgYmVlbiBkZWZpbmVkIGluIHJlY29yZE1vZGVsYCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFkZXNjcmlwdG9yLmVudW1lcmFibGUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgcmVxdWlyZWRLZXlzIGNhbm5vdCByZWZlcmVuY2Uga2V5cyB0aGF0IGhhdmUgYXJlIGVudW1lcmFibGUgaW4gcmVjb3JkTW9kZWxgKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gUGFydGlhbFJlY29yZEFyYml0cmFyeUJ1aWxkZXJfMS5idWlsZFBhcnRpYWxSZWNvcmRBcmJpdHJhcnkocmVjb3JkTW9kZWwsIHJlcXVpcmVkS2V5cyk7XG59XG5leHBvcnRzLnJlY29yZCA9IHJlY29yZDtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5zY2hlZHVsZXJGb3IgPSBleHBvcnRzLnNjaGVkdWxlciA9IHZvaWQgMDtcbmNvbnN0IENvbnZlcnRlcnNfMSA9IHJlcXVpcmUoXCIuLi9jaGVjay9hcmJpdHJhcnkvZGVmaW5pdGlvbi9Db252ZXJ0ZXJzXCIpO1xuY29uc3QgQnVpbGRTY2hlZHVsZXJGb3JfMSA9IHJlcXVpcmUoXCIuL19pbnRlcm5hbHMvaGVscGVycy9CdWlsZFNjaGVkdWxlckZvclwiKTtcbmNvbnN0IFNjaGVkdWxlckFyYml0cmFyeV8xID0gcmVxdWlyZShcIi4vX2ludGVybmFscy9TY2hlZHVsZXJBcmJpdHJhcnlcIik7XG5mdW5jdGlvbiBzY2hlZHVsZXIoY29uc3RyYWludHMpIHtcbiAgICBjb25zdCB7IGFjdCA9IChmKSA9PiBmKCkgfSA9IGNvbnN0cmFpbnRzIHx8IHt9O1xuICAgIHJldHVybiBDb252ZXJ0ZXJzXzEuY29udmVydEZyb21OZXh0KG5ldyBTY2hlZHVsZXJBcmJpdHJhcnlfMS5TY2hlZHVsZXJBcmJpdHJhcnkoYWN0KSk7XG59XG5leHBvcnRzLnNjaGVkdWxlciA9IHNjaGVkdWxlcjtcbmZ1bmN0aW9uIHNjaGVkdWxlckZvcihjdXN0b21PcmRlcmluZ09yQ29uc3RyYWludHMsIGNvbnN0cmFpbnRzT3JVbmRlZmluZWQpIHtcbiAgICBjb25zdCB7IGFjdCA9IChmKSA9PiBmKCkgfSA9IEFycmF5LmlzQXJyYXkoY3VzdG9tT3JkZXJpbmdPckNvbnN0cmFpbnRzKVxuICAgICAgICA/IGNvbnN0cmFpbnRzT3JVbmRlZmluZWQgfHwge31cbiAgICAgICAgOiBjdXN0b21PcmRlcmluZ09yQ29uc3RyYWludHMgfHwge307XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoY3VzdG9tT3JkZXJpbmdPckNvbnN0cmFpbnRzKSkge1xuICAgICAgICByZXR1cm4gQnVpbGRTY2hlZHVsZXJGb3JfMS5idWlsZFNjaGVkdWxlckZvcihhY3QsIGN1c3RvbU9yZGVyaW5nT3JDb25zdHJhaW50cyk7XG4gICAgfVxuICAgIHJldHVybiBmdW5jdGlvbiAoX3N0cnMsIC4uLm9yZGVyaW5nKSB7XG4gICAgICAgIHJldHVybiBCdWlsZFNjaGVkdWxlckZvcl8xLmJ1aWxkU2NoZWR1bGVyRm9yKGFjdCwgb3JkZXJpbmcpO1xuICAgIH07XG59XG5leHBvcnRzLnNjaGVkdWxlckZvciA9IHNjaGVkdWxlckZvcjtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5zZXQgPSB2b2lkIDA7XG5jb25zdCBBcnJheUFyYml0cmFyeV8xID0gcmVxdWlyZShcIi4vX2ludGVybmFscy9BcnJheUFyYml0cmFyeVwiKTtcbmNvbnN0IENvbnZlcnRlcnNfMSA9IHJlcXVpcmUoXCIuLi9jaGVjay9hcmJpdHJhcnkvZGVmaW5pdGlvbi9Db252ZXJ0ZXJzXCIpO1xuY29uc3QgTWF4TGVuZ3RoRnJvbU1pbkxlbmd0aF8xID0gcmVxdWlyZShcIi4vX2ludGVybmFscy9oZWxwZXJzL01heExlbmd0aEZyb21NaW5MZW5ndGhcIik7XG5mdW5jdGlvbiBidWlsZENvbXBsZXRlU2V0Q29uc3RyYWludHMoY29uc3RyYWludHMpIHtcbiAgICBjb25zdCBtaW5MZW5ndGggPSBjb25zdHJhaW50cy5taW5MZW5ndGggIT09IHVuZGVmaW5lZCA/IGNvbnN0cmFpbnRzLm1pbkxlbmd0aCA6IDA7XG4gICAgY29uc3QgbWF4TGVuZ3RoID0gY29uc3RyYWludHMubWF4TGVuZ3RoICE9PSB1bmRlZmluZWQgPyBjb25zdHJhaW50cy5tYXhMZW5ndGggOiBNYXhMZW5ndGhGcm9tTWluTGVuZ3RoXzEubWF4TGVuZ3RoRnJvbU1pbkxlbmd0aChtaW5MZW5ndGgpO1xuICAgIGNvbnN0IGNvbXBhcmUgPSBjb25zdHJhaW50cy5jb21wYXJlICE9PSB1bmRlZmluZWQgPyBjb25zdHJhaW50cy5jb21wYXJlIDogKGEsIGIpID0+IGEgPT09IGI7XG4gICAgcmV0dXJuIHsgbWluTGVuZ3RoLCBtYXhMZW5ndGgsIGNvbXBhcmUgfTtcbn1cbmZ1bmN0aW9uIGV4dHJhY3RTZXRDb25zdHJhaW50cyhhcmdzKSB7XG4gICAgaWYgKGFyZ3NbMF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4ge307XG4gICAgfVxuICAgIGlmIChhcmdzWzFdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY29uc3Qgc2FyZ3MgPSBhcmdzO1xuICAgICAgICBpZiAodHlwZW9mIHNhcmdzWzBdID09PSAnbnVtYmVyJylcbiAgICAgICAgICAgIHJldHVybiB7IG1heExlbmd0aDogc2FyZ3NbMF0gfTtcbiAgICAgICAgaWYgKHR5cGVvZiBzYXJnc1swXSA9PT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgICAgIHJldHVybiB7IGNvbXBhcmU6IHNhcmdzWzBdIH07XG4gICAgICAgIHJldHVybiBzYXJnc1swXTtcbiAgICB9XG4gICAgaWYgKGFyZ3NbMl0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjb25zdCBzYXJncyA9IGFyZ3M7XG4gICAgICAgIGlmICh0eXBlb2Ygc2FyZ3NbMV0gPT09ICdudW1iZXInKVxuICAgICAgICAgICAgcmV0dXJuIHsgbWluTGVuZ3RoOiBzYXJnc1swXSwgbWF4TGVuZ3RoOiBzYXJnc1sxXSB9O1xuICAgICAgICByZXR1cm4geyBtYXhMZW5ndGg6IHNhcmdzWzBdLCBjb21wYXJlOiBzYXJnc1sxXSB9O1xuICAgIH1cbiAgICBjb25zdCBzYXJncyA9IGFyZ3M7XG4gICAgcmV0dXJuIHsgbWluTGVuZ3RoOiBzYXJnc1swXSwgbWF4TGVuZ3RoOiBzYXJnc1sxXSwgY29tcGFyZTogc2FyZ3NbMl0gfTtcbn1cbmZ1bmN0aW9uIHNldChhcmIsIC4uLmFyZ3MpIHtcbiAgICBjb25zdCBjb25zdHJhaW50cyA9IGJ1aWxkQ29tcGxldGVTZXRDb25zdHJhaW50cyhleHRyYWN0U2V0Q29uc3RyYWludHMoYXJncykpO1xuICAgIGNvbnN0IG1pbkxlbmd0aCA9IGNvbnN0cmFpbnRzLm1pbkxlbmd0aDtcbiAgICBjb25zdCBtYXhMZW5ndGggPSBjb25zdHJhaW50cy5tYXhMZW5ndGg7XG4gICAgY29uc3QgY29tcGFyZSA9IGNvbnN0cmFpbnRzLmNvbXBhcmU7XG4gICAgY29uc3QgbmV4dEFyYiA9IENvbnZlcnRlcnNfMS5jb252ZXJ0VG9OZXh0KGFyYik7XG4gICAgY29uc3QgYXJyYXlBcmIgPSBDb252ZXJ0ZXJzXzEuY29udmVydEZyb21OZXh0KG5ldyBBcnJheUFyYml0cmFyeV8xLkFycmF5QXJiaXRyYXJ5KG5leHRBcmIsIG1pbkxlbmd0aCwgbWF4TGVuZ3RoLCBjb21wYXJlKSk7XG4gICAgaWYgKG1pbkxlbmd0aCA9PT0gMClcbiAgICAgICAgcmV0dXJuIGFycmF5QXJiO1xuICAgIHJldHVybiBhcnJheUFyYi5maWx0ZXIoKHRhYikgPT4gdGFiLmxlbmd0aCA+PSBtaW5MZW5ndGgpO1xufVxuZXhwb3J0cy5zZXQgPSBzZXQ7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuc3RyaW5nID0gdm9pZCAwO1xuY29uc3QgQ29udmVydGVyc18xID0gcmVxdWlyZShcIi4uL2NoZWNrL2FyYml0cmFyeS9kZWZpbml0aW9uL0NvbnZlcnRlcnNcIik7XG5jb25zdCBhcnJheV8xID0gcmVxdWlyZShcIi4vYXJyYXlcIik7XG5jb25zdCBjaGFyXzEgPSByZXF1aXJlKFwiLi9jaGFyXCIpO1xuY29uc3QgU3RyaW5nQ29uc3RyYWludHNFeHRyYWN0b3JfMSA9IHJlcXVpcmUoXCIuL19pbnRlcm5hbHMvaGVscGVycy9TdHJpbmdDb25zdHJhaW50c0V4dHJhY3RvclwiKTtcbmNvbnN0IENvZGVQb2ludHNUb1N0cmluZ18xID0gcmVxdWlyZShcIi4vX2ludGVybmFscy9tYXBwZXJzL0NvZGVQb2ludHNUb1N0cmluZ1wiKTtcbmZ1bmN0aW9uIHN0cmluZyguLi5hcmdzKSB7XG4gICAgY29uc3QgY29uc3RyYWludHMgPSBTdHJpbmdDb25zdHJhaW50c0V4dHJhY3Rvcl8xLmV4dHJhY3RTdHJpbmdDb25zdHJhaW50cyhhcmdzKTtcbiAgICByZXR1cm4gQ29udmVydGVyc18xLmNvbnZlcnRGcm9tTmV4dChDb252ZXJ0ZXJzXzEuY29udmVydFRvTmV4dChhcnJheV8xLmFycmF5KGNoYXJfMS5jaGFyKCksIGNvbnN0cmFpbnRzKSkubWFwKENvZGVQb2ludHNUb1N0cmluZ18xLmNvZGVQb2ludHNUb1N0cmluZ01hcHBlciwgQ29kZVBvaW50c1RvU3RyaW5nXzEuY29kZVBvaW50c1RvU3RyaW5nVW5tYXBwZXIpKTtcbn1cbmV4cG9ydHMuc3RyaW5nID0gc3RyaW5nO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnN0cmluZzE2Yml0cyA9IHZvaWQgMDtcbmNvbnN0IENvbnZlcnRlcnNfMSA9IHJlcXVpcmUoXCIuLi9jaGVjay9hcmJpdHJhcnkvZGVmaW5pdGlvbi9Db252ZXJ0ZXJzXCIpO1xuY29uc3QgYXJyYXlfMSA9IHJlcXVpcmUoXCIuL2FycmF5XCIpO1xuY29uc3QgY2hhcjE2Yml0c18xID0gcmVxdWlyZShcIi4vY2hhcjE2Yml0c1wiKTtcbmNvbnN0IFN0cmluZ0NvbnN0cmFpbnRzRXh0cmFjdG9yXzEgPSByZXF1aXJlKFwiLi9faW50ZXJuYWxzL2hlbHBlcnMvU3RyaW5nQ29uc3RyYWludHNFeHRyYWN0b3JcIik7XG5jb25zdCBDaGFyc1RvU3RyaW5nXzEgPSByZXF1aXJlKFwiLi9faW50ZXJuYWxzL21hcHBlcnMvQ2hhcnNUb1N0cmluZ1wiKTtcbmZ1bmN0aW9uIHN0cmluZzE2Yml0cyguLi5hcmdzKSB7XG4gICAgY29uc3QgY29uc3RyYWludHMgPSBTdHJpbmdDb25zdHJhaW50c0V4dHJhY3Rvcl8xLmV4dHJhY3RTdHJpbmdDb25zdHJhaW50cyhhcmdzKTtcbiAgICByZXR1cm4gQ29udmVydGVyc18xLmNvbnZlcnRGcm9tTmV4dChDb252ZXJ0ZXJzXzEuY29udmVydFRvTmV4dChhcnJheV8xLmFycmF5KGNoYXIxNmJpdHNfMS5jaGFyMTZiaXRzKCksIGNvbnN0cmFpbnRzKSkubWFwKENoYXJzVG9TdHJpbmdfMS5jaGFyc1RvU3RyaW5nTWFwcGVyLCBDaGFyc1RvU3RyaW5nXzEuY2hhcnNUb1N0cmluZ1VubWFwcGVyKSk7XG59XG5leHBvcnRzLnN0cmluZzE2Yml0cyA9IHN0cmluZzE2Yml0cztcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5zdHJpbmdPZiA9IHZvaWQgMDtcbmNvbnN0IENvbnZlcnRlcnNfMSA9IHJlcXVpcmUoXCIuLi9jaGVjay9hcmJpdHJhcnkvZGVmaW5pdGlvbi9Db252ZXJ0ZXJzXCIpO1xuY29uc3QgYXJyYXlfMSA9IHJlcXVpcmUoXCIuL2FycmF5XCIpO1xuY29uc3QgU3RyaW5nQ29uc3RyYWludHNFeHRyYWN0b3JfMSA9IHJlcXVpcmUoXCIuL19pbnRlcm5hbHMvaGVscGVycy9TdHJpbmdDb25zdHJhaW50c0V4dHJhY3RvclwiKTtcbmNvbnN0IFBhdHRlcm5zVG9TdHJpbmdfMSA9IHJlcXVpcmUoXCIuL19pbnRlcm5hbHMvbWFwcGVycy9QYXR0ZXJuc1RvU3RyaW5nXCIpO1xuZnVuY3Rpb24gc3RyaW5nT2YoY2hhckFyYiwgLi4uYXJncykge1xuICAgIGNvbnN0IGNvbnN0cmFpbnRzID0gU3RyaW5nQ29uc3RyYWludHNFeHRyYWN0b3JfMS5leHRyYWN0U3RyaW5nQ29uc3RyYWludHMoYXJncyk7XG4gICAgcmV0dXJuIENvbnZlcnRlcnNfMS5jb252ZXJ0RnJvbU5leHQoQ29udmVydGVyc18xLmNvbnZlcnRUb05leHQoYXJyYXlfMS5hcnJheShjaGFyQXJiLCBjb25zdHJhaW50cykpLm1hcChQYXR0ZXJuc1RvU3RyaW5nXzEucGF0dGVybnNUb1N0cmluZ01hcHBlciwgUGF0dGVybnNUb1N0cmluZ18xLnBhdHRlcm5zVG9TdHJpbmdVbm1hcHBlckZvcihDb252ZXJ0ZXJzXzEuY29udmVydFRvTmV4dChjaGFyQXJiKSwgY29uc3RyYWludHMpKSk7XG59XG5leHBvcnRzLnN0cmluZ09mID0gc3RyaW5nT2Y7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMudHVwbGUgPSB2b2lkIDA7XG5jb25zdCBDb252ZXJ0ZXJzXzEgPSByZXF1aXJlKFwiLi4vY2hlY2svYXJiaXRyYXJ5L2RlZmluaXRpb24vQ29udmVydGVyc1wiKTtcbmNvbnN0IFR1cGxlQXJiaXRyYXJ5XzEgPSByZXF1aXJlKFwiLi9faW50ZXJuYWxzL1R1cGxlQXJiaXRyYXJ5XCIpO1xuZnVuY3Rpb24gdHVwbGUoLi4uYXJicykge1xuICAgIGNvbnN0IG5leHRBcmJzID0gYXJicy5tYXAoKGFyYikgPT4gQ29udmVydGVyc18xLmNvbnZlcnRUb05leHQoYXJiKSk7XG4gICAgcmV0dXJuIENvbnZlcnRlcnNfMS5jb252ZXJ0RnJvbU5leHQobmV3IFR1cGxlQXJiaXRyYXJ5XzEuVHVwbGVBcmJpdHJhcnkobmV4dEFyYnMpKTtcbn1cbmV4cG9ydHMudHVwbGUgPSB0dXBsZTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy51aW50MTZBcnJheSA9IHZvaWQgMDtcbmNvbnN0IGludGVnZXJfMSA9IHJlcXVpcmUoXCIuL2ludGVnZXJcIik7XG5jb25zdCBUeXBlZEludEFycmF5QXJiaXRyYXJ5QnVpbGRlcl8xID0gcmVxdWlyZShcIi4vX2ludGVybmFscy9idWlsZGVycy9UeXBlZEludEFycmF5QXJiaXRyYXJ5QnVpbGRlclwiKTtcbmZ1bmN0aW9uIHVpbnQxNkFycmF5KGNvbnN0cmFpbnRzID0ge30pIHtcbiAgICByZXR1cm4gVHlwZWRJbnRBcnJheUFyYml0cmFyeUJ1aWxkZXJfMS50eXBlZEludEFycmF5QXJiaXRyYXJ5QXJiaXRyYXJ5QnVpbGRlcihjb25zdHJhaW50cywgMCwgNjU1MzUsIFVpbnQxNkFycmF5LCBpbnRlZ2VyXzEuaW50ZWdlcik7XG59XG5leHBvcnRzLnVpbnQxNkFycmF5ID0gdWludDE2QXJyYXk7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMudWludDMyQXJyYXkgPSB2b2lkIDA7XG5jb25zdCBpbnRlZ2VyXzEgPSByZXF1aXJlKFwiLi9pbnRlZ2VyXCIpO1xuY29uc3QgVHlwZWRJbnRBcnJheUFyYml0cmFyeUJ1aWxkZXJfMSA9IHJlcXVpcmUoXCIuL19pbnRlcm5hbHMvYnVpbGRlcnMvVHlwZWRJbnRBcnJheUFyYml0cmFyeUJ1aWxkZXJcIik7XG5mdW5jdGlvbiB1aW50MzJBcnJheShjb25zdHJhaW50cyA9IHt9KSB7XG4gICAgcmV0dXJuIFR5cGVkSW50QXJyYXlBcmJpdHJhcnlCdWlsZGVyXzEudHlwZWRJbnRBcnJheUFyYml0cmFyeUFyYml0cmFyeUJ1aWxkZXIoY29uc3RyYWludHMsIDAsIDB4ZmZmZmZmZmYsIFVpbnQzMkFycmF5LCBpbnRlZ2VyXzEuaW50ZWdlcik7XG59XG5leHBvcnRzLnVpbnQzMkFycmF5ID0gdWludDMyQXJyYXk7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMudWludDhBcnJheSA9IHZvaWQgMDtcbmNvbnN0IGludGVnZXJfMSA9IHJlcXVpcmUoXCIuL2ludGVnZXJcIik7XG5jb25zdCBUeXBlZEludEFycmF5QXJiaXRyYXJ5QnVpbGRlcl8xID0gcmVxdWlyZShcIi4vX2ludGVybmFscy9idWlsZGVycy9UeXBlZEludEFycmF5QXJiaXRyYXJ5QnVpbGRlclwiKTtcbmZ1bmN0aW9uIHVpbnQ4QXJyYXkoY29uc3RyYWludHMgPSB7fSkge1xuICAgIHJldHVybiBUeXBlZEludEFycmF5QXJiaXRyYXJ5QnVpbGRlcl8xLnR5cGVkSW50QXJyYXlBcmJpdHJhcnlBcmJpdHJhcnlCdWlsZGVyKGNvbnN0cmFpbnRzLCAwLCAyNTUsIFVpbnQ4QXJyYXksIGludGVnZXJfMS5pbnRlZ2VyKTtcbn1cbmV4cG9ydHMudWludDhBcnJheSA9IHVpbnQ4QXJyYXk7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMudWludDhDbGFtcGVkQXJyYXkgPSB2b2lkIDA7XG5jb25zdCBpbnRlZ2VyXzEgPSByZXF1aXJlKFwiLi9pbnRlZ2VyXCIpO1xuY29uc3QgVHlwZWRJbnRBcnJheUFyYml0cmFyeUJ1aWxkZXJfMSA9IHJlcXVpcmUoXCIuL19pbnRlcm5hbHMvYnVpbGRlcnMvVHlwZWRJbnRBcnJheUFyYml0cmFyeUJ1aWxkZXJcIik7XG5mdW5jdGlvbiB1aW50OENsYW1wZWRBcnJheShjb25zdHJhaW50cyA9IHt9KSB7XG4gICAgcmV0dXJuIFR5cGVkSW50QXJyYXlBcmJpdHJhcnlCdWlsZGVyXzEudHlwZWRJbnRBcnJheUFyYml0cmFyeUFyYml0cmFyeUJ1aWxkZXIoY29uc3RyYWludHMsIDAsIDI1NSwgVWludDhDbGFtcGVkQXJyYXksIGludGVnZXJfMS5pbnRlZ2VyKTtcbn1cbmV4cG9ydHMudWludDhDbGFtcGVkQXJyYXkgPSB1aW50OENsYW1wZWRBcnJheTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy51bmljb2RlID0gdm9pZCAwO1xuY29uc3QgQ2hhcmFjdGVyQXJiaXRyYXJ5QnVpbGRlcl8xID0gcmVxdWlyZShcIi4vX2ludGVybmFscy9idWlsZGVycy9DaGFyYWN0ZXJBcmJpdHJhcnlCdWlsZGVyXCIpO1xuY29uc3QgSW5kZXhUb1ByaW50YWJsZUluZGV4XzEgPSByZXF1aXJlKFwiLi9faW50ZXJuYWxzL21hcHBlcnMvSW5kZXhUb1ByaW50YWJsZUluZGV4XCIpO1xuY29uc3QgZ2FwU2l6ZSA9IDB4ZGZmZiArIDEgLSAweGQ4MDA7XG5mdW5jdGlvbiB1bmljb2RlTWFwcGVyKHYpIHtcbiAgICBpZiAodiA8IDB4ZDgwMClcbiAgICAgICAgcmV0dXJuIEluZGV4VG9QcmludGFibGVJbmRleF8xLmluZGV4VG9QcmludGFibGVJbmRleE1hcHBlcih2KTtcbiAgICByZXR1cm4gdiArIGdhcFNpemU7XG59XG5mdW5jdGlvbiB1bmljb2RlVW5tYXBwZXIodikge1xuICAgIGlmICh2IDwgMHhkODAwKVxuICAgICAgICByZXR1cm4gSW5kZXhUb1ByaW50YWJsZUluZGV4XzEuaW5kZXhUb1ByaW50YWJsZUluZGV4VW5tYXBwZXIodik7XG4gICAgaWYgKHYgPD0gMHhkZmZmKVxuICAgICAgICByZXR1cm4gLTE7XG4gICAgcmV0dXJuIHYgLSBnYXBTaXplO1xufVxuZnVuY3Rpb24gdW5pY29kZSgpIHtcbiAgICByZXR1cm4gQ2hhcmFjdGVyQXJiaXRyYXJ5QnVpbGRlcl8xLmJ1aWxkQ2hhcmFjdGVyQXJiaXRyYXJ5KDB4MDAwMCwgMHhmZmZmIC0gZ2FwU2l6ZSwgdW5pY29kZU1hcHBlciwgdW5pY29kZVVubWFwcGVyKTtcbn1cbmV4cG9ydHMudW5pY29kZSA9IHVuaWNvZGU7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMudW5pY29kZVN0cmluZyA9IHZvaWQgMDtcbmNvbnN0IENvbnZlcnRlcnNfMSA9IHJlcXVpcmUoXCIuLi9jaGVjay9hcmJpdHJhcnkvZGVmaW5pdGlvbi9Db252ZXJ0ZXJzXCIpO1xuY29uc3QgYXJyYXlfMSA9IHJlcXVpcmUoXCIuL2FycmF5XCIpO1xuY29uc3QgdW5pY29kZV8xID0gcmVxdWlyZShcIi4vdW5pY29kZVwiKTtcbmNvbnN0IFN0cmluZ0NvbnN0cmFpbnRzRXh0cmFjdG9yXzEgPSByZXF1aXJlKFwiLi9faW50ZXJuYWxzL2hlbHBlcnMvU3RyaW5nQ29uc3RyYWludHNFeHRyYWN0b3JcIik7XG5jb25zdCBDb2RlUG9pbnRzVG9TdHJpbmdfMSA9IHJlcXVpcmUoXCIuL19pbnRlcm5hbHMvbWFwcGVycy9Db2RlUG9pbnRzVG9TdHJpbmdcIik7XG5mdW5jdGlvbiB1bmljb2RlU3RyaW5nKC4uLmFyZ3MpIHtcbiAgICBjb25zdCBjb25zdHJhaW50cyA9IFN0cmluZ0NvbnN0cmFpbnRzRXh0cmFjdG9yXzEuZXh0cmFjdFN0cmluZ0NvbnN0cmFpbnRzKGFyZ3MpO1xuICAgIHJldHVybiBDb252ZXJ0ZXJzXzEuY29udmVydEZyb21OZXh0KENvbnZlcnRlcnNfMS5jb252ZXJ0VG9OZXh0KGFycmF5XzEuYXJyYXkodW5pY29kZV8xLnVuaWNvZGUoKSwgY29uc3RyYWludHMpKS5tYXAoQ29kZVBvaW50c1RvU3RyaW5nXzEuY29kZVBvaW50c1RvU3RyaW5nTWFwcGVyLCBDb2RlUG9pbnRzVG9TdHJpbmdfMS5jb2RlUG9pbnRzVG9TdHJpbmdVbm1hcHBlcikpO1xufVxuZXhwb3J0cy51bmljb2RlU3RyaW5nID0gdW5pY29kZVN0cmluZztcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5kb3VibGVOZXh0ID0gZXhwb3J0cy5pbmRleFRvRG91YmxlID0gZXhwb3J0cy5kb3VibGVUb0luZGV4ID0gZXhwb3J0cy5kZWNvbXBvc2VEb3VibGUgPSB2b2lkIDA7XG5jb25zdCBBcnJheUludDY0XzEgPSByZXF1aXJlKFwiLi9oZWxwZXJzL0FycmF5SW50NjRcIik7XG5jb25zdCBBcnJheUludDY0QXJiaXRyYXJ5XzEgPSByZXF1aXJlKFwiLi9oZWxwZXJzL0FycmF5SW50NjRBcmJpdHJhcnlcIik7XG5jb25zdCBJTkRFWF9QT1NJVElWRV9JTkZJTklUWSA9IHsgc2lnbjogMSwgZGF0YTogWzIxNDY0MzUwNzIsIDBdIH07XG5jb25zdCBJTkRFWF9ORUdBVElWRV9JTkZJTklUWSA9IHsgc2lnbjogLTEsIGRhdGE6IFsyMTQ2NDM1MDcyLCAxXSB9O1xuZnVuY3Rpb24gZGVjb21wb3NlRG91YmxlKGQpIHtcbiAgICBjb25zdCBtYXhTaWduaWZpY2FuZCA9IDIgLSBOdW1iZXIuRVBTSUxPTjtcbiAgICBmb3IgKGxldCBleHBvbmVudCA9IC0xMDIyOyBleHBvbmVudCAhPT0gMTAyNDsgKytleHBvbmVudCkge1xuICAgICAgICBjb25zdCBwb3dFeHBvbmVudCA9IDIgKiogZXhwb25lbnQ7XG4gICAgICAgIGNvbnN0IG1heEZvckV4cG9uZW50ID0gbWF4U2lnbmlmaWNhbmQgKiBwb3dFeHBvbmVudDtcbiAgICAgICAgaWYgKE1hdGguYWJzKGQpIDw9IG1heEZvckV4cG9uZW50KSB7XG4gICAgICAgICAgICByZXR1cm4geyBleHBvbmVudCwgc2lnbmlmaWNhbmQ6IGQgLyBwb3dFeHBvbmVudCB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7IGV4cG9uZW50OiBOdW1iZXIuTmFOLCBzaWduaWZpY2FuZDogTnVtYmVyLk5hTiB9O1xufVxuZXhwb3J0cy5kZWNvbXBvc2VEb3VibGUgPSBkZWNvbXBvc2VEb3VibGU7XG5mdW5jdGlvbiBwb3NpdGl2ZU51bWJlclRvSW50NjQobikge1xuICAgIHJldHVybiBbfn4obiAvIDB4MTAwMDAwMDAwKSwgbiA+Pj4gMF07XG59XG5mdW5jdGlvbiBpbmRleEluRG91YmxlRnJvbURlY29tcChleHBvbmVudCwgc2lnbmlmaWNhbmQpIHtcbiAgICBpZiAoZXhwb25lbnQgPT09IC0xMDIyKSB7XG4gICAgICAgIGNvbnN0IHJlc2NhbGVkU2lnbmlmaWNhbmQgPSBzaWduaWZpY2FuZCAqIDIgKiogNTI7XG4gICAgICAgIHJldHVybiBwb3NpdGl2ZU51bWJlclRvSW50NjQocmVzY2FsZWRTaWduaWZpY2FuZCk7XG4gICAgfVxuICAgIGNvbnN0IHJlc2NhbGVkU2lnbmlmaWNhbmQgPSAoc2lnbmlmaWNhbmQgLSAxKSAqIDIgKiogNTI7XG4gICAgY29uc3QgZXhwb25lbnRPbmx5SGlnaCA9IChleHBvbmVudCArIDEwMjMpICogMiAqKiAyMDtcbiAgICBjb25zdCBpbmRleCA9IHBvc2l0aXZlTnVtYmVyVG9JbnQ2NChyZXNjYWxlZFNpZ25pZmljYW5kKTtcbiAgICBpbmRleFswXSArPSBleHBvbmVudE9ubHlIaWdoO1xuICAgIHJldHVybiBpbmRleDtcbn1cbmZ1bmN0aW9uIGRvdWJsZVRvSW5kZXgoZCkge1xuICAgIGlmIChkID09PSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFkpIHtcbiAgICAgICAgcmV0dXJuIEFycmF5SW50NjRfMS5jbG9uZTY0KElOREVYX1BPU0lUSVZFX0lORklOSVRZKTtcbiAgICB9XG4gICAgaWYgKGQgPT09IE51bWJlci5ORUdBVElWRV9JTkZJTklUWSkge1xuICAgICAgICByZXR1cm4gQXJyYXlJbnQ2NF8xLmNsb25lNjQoSU5ERVhfTkVHQVRJVkVfSU5GSU5JVFkpO1xuICAgIH1cbiAgICBjb25zdCBkZWNvbXAgPSBkZWNvbXBvc2VEb3VibGUoZCk7XG4gICAgY29uc3QgZXhwb25lbnQgPSBkZWNvbXAuZXhwb25lbnQ7XG4gICAgY29uc3Qgc2lnbmlmaWNhbmQgPSBkZWNvbXAuc2lnbmlmaWNhbmQ7XG4gICAgaWYgKGQgPiAwIHx8IChkID09PSAwICYmIDEgLyBkID09PSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFkpKSB7XG4gICAgICAgIHJldHVybiB7IHNpZ246IDEsIGRhdGE6IGluZGV4SW5Eb3VibGVGcm9tRGVjb21wKGV4cG9uZW50LCBzaWduaWZpY2FuZCkgfTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGNvbnN0IGluZGV4T3Bwb3NpdGUgPSBpbmRleEluRG91YmxlRnJvbURlY29tcChleHBvbmVudCwgLXNpZ25pZmljYW5kKTtcbiAgICAgICAgaWYgKGluZGV4T3Bwb3NpdGVbMV0gPT09IDB4ZmZmZmZmZmYpIHtcbiAgICAgICAgICAgIGluZGV4T3Bwb3NpdGVbMF0gKz0gMTtcbiAgICAgICAgICAgIGluZGV4T3Bwb3NpdGVbMV0gPSAwO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaW5kZXhPcHBvc2l0ZVsxXSArPSAxO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IHNpZ246IC0xLCBkYXRhOiBpbmRleE9wcG9zaXRlIH07XG4gICAgfVxufVxuZXhwb3J0cy5kb3VibGVUb0luZGV4ID0gZG91YmxlVG9JbmRleDtcbmZ1bmN0aW9uIGluZGV4VG9Eb3VibGUoaW5kZXgpIHtcbiAgICBpZiAoaW5kZXguc2lnbiA9PT0gLTEpIHtcbiAgICAgICAgY29uc3QgaW5kZXhPcHBvc2l0ZSA9IHsgc2lnbjogMSwgZGF0YTogW2luZGV4LmRhdGFbMF0sIGluZGV4LmRhdGFbMV1dIH07XG4gICAgICAgIGlmIChpbmRleE9wcG9zaXRlLmRhdGFbMV0gPT09IDApIHtcbiAgICAgICAgICAgIGluZGV4T3Bwb3NpdGUuZGF0YVswXSAtPSAxO1xuICAgICAgICAgICAgaW5kZXhPcHBvc2l0ZS5kYXRhWzFdID0gMHhmZmZmZmZmZjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGluZGV4T3Bwb3NpdGUuZGF0YVsxXSAtPSAxO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAtaW5kZXhUb0RvdWJsZShpbmRleE9wcG9zaXRlKTtcbiAgICB9XG4gICAgaWYgKEFycmF5SW50NjRfMS5pc0VxdWFsNjQoaW5kZXgsIElOREVYX1BPU0lUSVZFX0lORklOSVRZKSkge1xuICAgICAgICByZXR1cm4gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZO1xuICAgIH1cbiAgICBpZiAoaW5kZXguZGF0YVswXSA8IDB4MjAwMDAwKSB7XG4gICAgICAgIHJldHVybiAoaW5kZXguZGF0YVswXSAqIDB4MTAwMDAwMDAwICsgaW5kZXguZGF0YVsxXSkgKiAyICoqIC0xMDc0O1xuICAgIH1cbiAgICBjb25zdCBwb3N0SW5kZXhIaWdoID0gaW5kZXguZGF0YVswXSAtIDB4MjAwMDAwO1xuICAgIGNvbnN0IGV4cG9uZW50ID0gLTEwMjEgKyAocG9zdEluZGV4SGlnaCA+PiAyMCk7XG4gICAgY29uc3Qgc2lnbmlmaWNhbmQgPSAxICsgKChwb3N0SW5kZXhIaWdoICYgMHhmZmZmZikgKiAyICoqIDMyICsgaW5kZXguZGF0YVsxXSkgKiBOdW1iZXIuRVBTSUxPTjtcbiAgICByZXR1cm4gc2lnbmlmaWNhbmQgKiAyICoqIGV4cG9uZW50O1xufVxuZXhwb3J0cy5pbmRleFRvRG91YmxlID0gaW5kZXhUb0RvdWJsZTtcbmZ1bmN0aW9uIHNhZmVEb3VibGVUb0luZGV4KGQsIGNvbnN0cmFpbnRzTGFiZWwpIHtcbiAgICBpZiAoTnVtYmVyLmlzTmFOKGQpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignZmMuZG91YmxlTmV4dCBjb25zdHJhaW50cy4nICsgY29uc3RyYWludHNMYWJlbCArICcgbXVzdCBiZSBhIDMyLWJpdCBmbG9hdCcpO1xuICAgIH1cbiAgICByZXR1cm4gZG91YmxlVG9JbmRleChkKTtcbn1cbmZ1bmN0aW9uIGRvdWJsZU5leHQoY29uc3RyYWludHMgPSB7fSkge1xuICAgIGNvbnN0IHsgbm9EZWZhdWx0SW5maW5pdHkgPSBmYWxzZSwgbm9OYU4gPSBmYWxzZSwgbWluID0gbm9EZWZhdWx0SW5maW5pdHkgPyAtTnVtYmVyLk1BWF9WQUxVRSA6IE51bWJlci5ORUdBVElWRV9JTkZJTklUWSwgbWF4ID0gbm9EZWZhdWx0SW5maW5pdHkgPyBOdW1iZXIuTUFYX1ZBTFVFIDogTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZLCB9ID0gY29uc3RyYWludHM7XG4gICAgY29uc3QgbWluSW5kZXggPSBzYWZlRG91YmxlVG9JbmRleChtaW4sICdtaW4nKTtcbiAgICBjb25zdCBtYXhJbmRleCA9IHNhZmVEb3VibGVUb0luZGV4KG1heCwgJ21heCcpO1xuICAgIGlmIChBcnJheUludDY0XzEuaXNTdHJpY3RseVNtYWxsZXI2NChtYXhJbmRleCwgbWluSW5kZXgpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignZmMuZG91YmxlTmV4dCBjb25zdHJhaW50cy5taW4gbXVzdCBiZSBzbWFsbGVyIG9yIGVxdWFsIHRvIGNvbnN0cmFpbnRzLm1heCcpO1xuICAgIH1cbiAgICBpZiAobm9OYU4pIHtcbiAgICAgICAgcmV0dXJuIEFycmF5SW50NjRBcmJpdHJhcnlfMS5hcnJheUludDY0KG1pbkluZGV4LCBtYXhJbmRleCkubWFwKGluZGV4VG9Eb3VibGUpO1xuICAgIH1cbiAgICBjb25zdCBwb3NpdGl2ZU1heElkeCA9IEFycmF5SW50NjRfMS5pc1N0cmljdGx5UG9zaXRpdmU2NChtYXhJbmRleCk7XG4gICAgY29uc3QgbWluSW5kZXhXaXRoTmFOID0gcG9zaXRpdmVNYXhJZHggPyBtaW5JbmRleCA6IEFycmF5SW50NjRfMS5zdWJzdHJhY3Q2NChtaW5JbmRleCwgQXJyYXlJbnQ2NF8xLlVuaXQ2NCk7XG4gICAgY29uc3QgbWF4SW5kZXhXaXRoTmFOID0gcG9zaXRpdmVNYXhJZHggPyBBcnJheUludDY0XzEuYWRkNjQobWF4SW5kZXgsIEFycmF5SW50NjRfMS5Vbml0NjQpIDogbWF4SW5kZXg7XG4gICAgcmV0dXJuIEFycmF5SW50NjRBcmJpdHJhcnlfMS5hcnJheUludDY0KG1pbkluZGV4V2l0aE5hTiwgbWF4SW5kZXhXaXRoTmFOKS5tYXAoKGluZGV4KSA9PiB7XG4gICAgICAgIGlmIChBcnJheUludDY0XzEuaXNTdHJpY3RseVNtYWxsZXI2NChtYXhJbmRleCwgaW5kZXgpIHx8IEFycmF5SW50NjRfMS5pc1N0cmljdGx5U21hbGxlcjY0KGluZGV4LCBtaW5JbmRleCkpXG4gICAgICAgICAgICByZXR1cm4gTnVtYmVyLk5hTjtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgcmV0dXJuIGluZGV4VG9Eb3VibGUoaW5kZXgpO1xuICAgIH0pO1xufVxuZXhwb3J0cy5kb3VibGVOZXh0ID0gZG91YmxlTmV4dDtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5lbWFpbEFkZHJlc3MgPSB2b2lkIDA7XG5jb25zdCBhcnJheV8xID0gcmVxdWlyZShcIi4uLy4uL2FyYml0cmFyeS9hcnJheVwiKTtcbmNvbnN0IFNwZWNpZmljQ2hhcmFjdGVyUmFuZ2VfMSA9IHJlcXVpcmUoXCIuL2hlbHBlcnMvU3BlY2lmaWNDaGFyYWN0ZXJSYW5nZVwiKTtcbmNvbnN0IEhvc3RBcmJpdHJhcnlfMSA9IHJlcXVpcmUoXCIuL0hvc3RBcmJpdHJhcnlcIik7XG5jb25zdCBzdHJpbmdPZl8xID0gcmVxdWlyZShcIi4uLy4uL2FyYml0cmFyeS9zdHJpbmdPZlwiKTtcbmNvbnN0IHR1cGxlXzEgPSByZXF1aXJlKFwiLi4vLi4vYXJiaXRyYXJ5L3R1cGxlXCIpO1xuZnVuY3Rpb24gZW1haWxBZGRyZXNzKCkge1xuICAgIGNvbnN0IG90aGVycyA9IFsnIScsICcjJywgJyQnLCAnJScsICcmJywgXCInXCIsICcqJywgJysnLCAnLScsICcvJywgJz0nLCAnPycsICdeJywgJ18nLCAnYCcsICd7JywgJ3wnLCAnfScsICd+J107XG4gICAgY29uc3QgYXRleHRBcmIgPSBTcGVjaWZpY0NoYXJhY3RlclJhbmdlXzEuYnVpbGRMb3dlckFscGhhTnVtZXJpY0FyYihvdGhlcnMpO1xuICAgIGNvbnN0IGxvY2FsUGFydEFyYiA9IGFycmF5XzEuYXJyYXkoc3RyaW5nT2ZfMS5zdHJpbmdPZihhdGV4dEFyYiwgeyBtaW5MZW5ndGg6IDEsIG1heExlbmd0aDogMTAgfSksIHsgbWluTGVuZ3RoOiAxLCBtYXhMZW5ndGg6IDUgfSlcbiAgICAgICAgLm1hcCgoYSkgPT4gYS5qb2luKCcuJykpXG4gICAgICAgIC5maWx0ZXIoKGxwKSA9PiBscC5sZW5ndGggPD0gNjQpO1xuICAgIHJldHVybiB0dXBsZV8xLnR1cGxlKGxvY2FsUGFydEFyYiwgSG9zdEFyYml0cmFyeV8xLmRvbWFpbigpKS5tYXAoKFtscCwgZF0pID0+IGAke2xwfUAke2R9YCk7XG59XG5leHBvcnRzLmVtYWlsQWRkcmVzcyA9IGVtYWlsQWRkcmVzcztcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5mbG9hdE5leHQgPSBleHBvcnRzLmluZGV4VG9GbG9hdCA9IGV4cG9ydHMuZmxvYXRUb0luZGV4ID0gZXhwb3J0cy5kZWNvbXBvc2VGbG9hdCA9IGV4cG9ydHMuRVBTSUxPTl8zMiA9IGV4cG9ydHMuTUFYX1ZBTFVFXzMyID0gZXhwb3J0cy5NSU5fVkFMVUVfMzIgPSB2b2lkIDA7XG5jb25zdCBpbnRlZ2VyXzEgPSByZXF1aXJlKFwiLi4vLi4vYXJiaXRyYXJ5L2ludGVnZXJcIik7XG5leHBvcnRzLk1JTl9WQUxVRV8zMiA9IDIgKiogLTEyNiAqIDIgKiogLTIzO1xuZXhwb3J0cy5NQVhfVkFMVUVfMzIgPSAyICoqIDEyNyAqICgxICsgKDIgKiogMjMgLSAxKSAvIDIgKiogMjMpO1xuZXhwb3J0cy5FUFNJTE9OXzMyID0gMiAqKiAtMjM7XG5jb25zdCBJTkRFWF9QT1NJVElWRV9JTkZJTklUWSA9IDIxMzkwOTUwNDA7XG5jb25zdCBJTkRFWF9ORUdBVElWRV9JTkZJTklUWSA9IC0yMTM5MDk1MDQxO1xuZnVuY3Rpb24gZGVjb21wb3NlRmxvYXQoZikge1xuICAgIGNvbnN0IG1heFNpZ25pZmljYW5kID0gMSArICgyICoqIDIzIC0gMSkgLyAyICoqIDIzO1xuICAgIGZvciAobGV0IGV4cG9uZW50ID0gLTEyNjsgZXhwb25lbnQgIT09IDEyODsgKytleHBvbmVudCkge1xuICAgICAgICBjb25zdCBwb3dFeHBvbmVudCA9IDIgKiogZXhwb25lbnQ7XG4gICAgICAgIGNvbnN0IG1heEZvckV4cG9uZW50ID0gbWF4U2lnbmlmaWNhbmQgKiBwb3dFeHBvbmVudDtcbiAgICAgICAgaWYgKE1hdGguYWJzKGYpIDw9IG1heEZvckV4cG9uZW50KSB7XG4gICAgICAgICAgICByZXR1cm4geyBleHBvbmVudCwgc2lnbmlmaWNhbmQ6IGYgLyBwb3dFeHBvbmVudCB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7IGV4cG9uZW50OiBOdW1iZXIuTmFOLCBzaWduaWZpY2FuZDogTnVtYmVyLk5hTiB9O1xufVxuZXhwb3J0cy5kZWNvbXBvc2VGbG9hdCA9IGRlY29tcG9zZUZsb2F0O1xuZnVuY3Rpb24gaW5kZXhJbkZsb2F0RnJvbURlY29tcChleHBvbmVudCwgc2lnbmlmaWNhbmQpIHtcbiAgICBpZiAoZXhwb25lbnQgPT09IC0xMjYpIHtcbiAgICAgICAgcmV0dXJuIHNpZ25pZmljYW5kICogMHg4MDAwMDA7XG4gICAgfVxuICAgIHJldHVybiAoZXhwb25lbnQgKyAxMjcpICogMHg4MDAwMDAgKyAoc2lnbmlmaWNhbmQgLSAxKSAqIDB4ODAwMDAwO1xufVxuZnVuY3Rpb24gZmxvYXRUb0luZGV4KGYpIHtcbiAgICBpZiAoZiA9PT0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZKSB7XG4gICAgICAgIHJldHVybiBJTkRFWF9QT1NJVElWRV9JTkZJTklUWTtcbiAgICB9XG4gICAgaWYgKGYgPT09IE51bWJlci5ORUdBVElWRV9JTkZJTklUWSkge1xuICAgICAgICByZXR1cm4gSU5ERVhfTkVHQVRJVkVfSU5GSU5JVFk7XG4gICAgfVxuICAgIGNvbnN0IGRlY29tcCA9IGRlY29tcG9zZUZsb2F0KGYpO1xuICAgIGNvbnN0IGV4cG9uZW50ID0gZGVjb21wLmV4cG9uZW50O1xuICAgIGNvbnN0IHNpZ25pZmljYW5kID0gZGVjb21wLnNpZ25pZmljYW5kO1xuICAgIGlmIChOdW1iZXIuaXNOYU4oZXhwb25lbnQpIHx8IE51bWJlci5pc05hTihzaWduaWZpY2FuZCkgfHwgIU51bWJlci5pc0ludGVnZXIoc2lnbmlmaWNhbmQgKiAweDgwMDAwMCkpIHtcbiAgICAgICAgcmV0dXJuIE51bWJlci5OYU47XG4gICAgfVxuICAgIGlmIChmID4gMCB8fCAoZiA9PT0gMCAmJiAxIC8gZiA9PT0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZKSkge1xuICAgICAgICByZXR1cm4gaW5kZXhJbkZsb2F0RnJvbURlY29tcChleHBvbmVudCwgc2lnbmlmaWNhbmQpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIC1pbmRleEluRmxvYXRGcm9tRGVjb21wKGV4cG9uZW50LCAtc2lnbmlmaWNhbmQpIC0gMTtcbiAgICB9XG59XG5leHBvcnRzLmZsb2F0VG9JbmRleCA9IGZsb2F0VG9JbmRleDtcbmZ1bmN0aW9uIGluZGV4VG9GbG9hdChpbmRleCkge1xuICAgIGlmIChpbmRleCA8IDApIHtcbiAgICAgICAgcmV0dXJuIC1pbmRleFRvRmxvYXQoLWluZGV4IC0gMSk7XG4gICAgfVxuICAgIGlmIChpbmRleCA9PT0gSU5ERVhfUE9TSVRJVkVfSU5GSU5JVFkpIHtcbiAgICAgICAgcmV0dXJuIE51bWJlci5QT1NJVElWRV9JTkZJTklUWTtcbiAgICB9XG4gICAgaWYgKGluZGV4IDwgMHgxMDAwMDAwKSB7XG4gICAgICAgIHJldHVybiBpbmRleCAqIDIgKiogLTE0OTtcbiAgICB9XG4gICAgY29uc3QgcG9zdEluZGV4ID0gaW5kZXggLSAweDEwMDAwMDA7XG4gICAgY29uc3QgZXhwb25lbnQgPSAtMTI1ICsgKHBvc3RJbmRleCA+PiAyMyk7XG4gICAgY29uc3Qgc2lnbmlmaWNhbmQgPSAxICsgKHBvc3RJbmRleCAmIDB4N2ZmZmZmKSAvIDB4ODAwMDAwO1xuICAgIHJldHVybiBzaWduaWZpY2FuZCAqIDIgKiogZXhwb25lbnQ7XG59XG5leHBvcnRzLmluZGV4VG9GbG9hdCA9IGluZGV4VG9GbG9hdDtcbmZ1bmN0aW9uIHNhZmVGbG9hdFRvSW5kZXgoZiwgY29uc3RyYWludHNMYWJlbCkge1xuICAgIGNvbnN0IGNvbnZlcnNpb25UcmljayA9ICd5b3UgY2FuIGNvbnZlcnQgYW55IGRvdWJsZSB0byBhIDMyLWJpdCBmbG9hdCBieSB1c2luZyBgbmV3IEZsb2F0MzJBcnJheShbbXlEb3VibGVdKVswXWAnO1xuICAgIGNvbnN0IGVycm9yTWVzc2FnZSA9ICdmYy5mbG9hdE5leHQgY29uc3RyYWludHMuJyArIGNvbnN0cmFpbnRzTGFiZWwgKyAnIG11c3QgYmUgYSAzMi1iaXQgZmxvYXQgLSAnICsgY29udmVyc2lvblRyaWNrO1xuICAgIGlmIChOdW1iZXIuaXNOYU4oZikgfHwgKE51bWJlci5pc0Zpbml0ZShmKSAmJiAoZiA8IC1leHBvcnRzLk1BWF9WQUxVRV8zMiB8fCBmID4gZXhwb3J0cy5NQVhfVkFMVUVfMzIpKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JNZXNzYWdlKTtcbiAgICB9XG4gICAgY29uc3QgaW5kZXggPSBmbG9hdFRvSW5kZXgoZik7XG4gICAgaWYgKCFOdW1iZXIuaXNJbnRlZ2VyKGluZGV4KSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JNZXNzYWdlKTtcbiAgICB9XG4gICAgcmV0dXJuIGluZGV4O1xufVxuZnVuY3Rpb24gZmxvYXROZXh0KGNvbnN0cmFpbnRzID0ge30pIHtcbiAgICBjb25zdCB7IG5vRGVmYXVsdEluZmluaXR5ID0gZmFsc2UsIG5vTmFOID0gZmFsc2UsIG1pbiA9IG5vRGVmYXVsdEluZmluaXR5ID8gLWV4cG9ydHMuTUFYX1ZBTFVFXzMyIDogTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZLCBtYXggPSBub0RlZmF1bHRJbmZpbml0eSA/IGV4cG9ydHMuTUFYX1ZBTFVFXzMyIDogTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZLCB9ID0gY29uc3RyYWludHM7XG4gICAgY29uc3QgbWluSW5kZXggPSBzYWZlRmxvYXRUb0luZGV4KG1pbiwgJ21pbicpO1xuICAgIGNvbnN0IG1heEluZGV4ID0gc2FmZUZsb2F0VG9JbmRleChtYXgsICdtYXgnKTtcbiAgICBpZiAobWluSW5kZXggPiBtYXhJbmRleCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ZjLmZsb2F0TmV4dCBjb25zdHJhaW50cy5taW4gbXVzdCBiZSBzbWFsbGVyIG9yIGVxdWFsIHRvIGNvbnN0cmFpbnRzLm1heCcpO1xuICAgIH1cbiAgICBpZiAobm9OYU4pIHtcbiAgICAgICAgcmV0dXJuIGludGVnZXJfMS5pbnRlZ2VyKHsgbWluOiBtaW5JbmRleCwgbWF4OiBtYXhJbmRleCB9KS5tYXAoaW5kZXhUb0Zsb2F0KTtcbiAgICB9XG4gICAgY29uc3QgbWluSW5kZXhXaXRoTmFOID0gbWF4SW5kZXggPiAwID8gbWluSW5kZXggOiBtaW5JbmRleCAtIDE7XG4gICAgY29uc3QgbWF4SW5kZXhXaXRoTmFOID0gbWF4SW5kZXggPiAwID8gbWF4SW5kZXggKyAxIDogbWF4SW5kZXg7XG4gICAgcmV0dXJuIGludGVnZXJfMS5pbnRlZ2VyKHsgbWluOiBtaW5JbmRleFdpdGhOYU4sIG1heDogbWF4SW5kZXhXaXRoTmFOIH0pLm1hcCgoaW5kZXgpID0+IHtcbiAgICAgICAgaWYgKGluZGV4ID4gbWF4SW5kZXggfHwgaW5kZXggPCBtaW5JbmRleClcbiAgICAgICAgICAgIHJldHVybiBOdW1iZXIuTmFOO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICByZXR1cm4gaW5kZXhUb0Zsb2F0KGluZGV4KTtcbiAgICB9KTtcbn1cbmV4cG9ydHMuZmxvYXROZXh0ID0gZmxvYXROZXh0O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmRvdWJsZSA9IGV4cG9ydHMuZmxvYXQgPSB2b2lkIDA7XG5jb25zdCBEb3VibGVOZXh0QXJiaXRyYXJ5XzEgPSByZXF1aXJlKFwiLi9Eb3VibGVOZXh0QXJiaXRyYXJ5XCIpO1xuY29uc3QgRmxvYXROZXh0QXJiaXRyYXJ5XzEgPSByZXF1aXJlKFwiLi9GbG9hdE5leHRBcmJpdHJhcnlcIik7XG5jb25zdCBpbnRlZ2VyXzEgPSByZXF1aXJlKFwiLi4vLi4vYXJiaXRyYXJ5L2ludGVnZXJcIik7XG5jb25zdCB0dXBsZV8xID0gcmVxdWlyZShcIi4uLy4uL2FyYml0cmFyeS90dXBsZVwiKTtcbmZ1bmN0aW9uIG5leHQobikge1xuICAgIHJldHVybiBpbnRlZ2VyXzEuaW50ZWdlcigwLCAoMSA8PCBuKSAtIDEpO1xufVxuY29uc3QgZmxvYXRJbnRlcm5hbCA9ICgpID0+IHtcbiAgICByZXR1cm4gbmV4dCgyNCkubWFwKCh2KSA9PiB2IC8gKDEgPDwgMjQpKTtcbn07XG5mdW5jdGlvbiBmbG9hdCguLi5hcmdzKSB7XG4gICAgaWYgKHR5cGVvZiBhcmdzWzBdID09PSAnb2JqZWN0Jykge1xuICAgICAgICBpZiAoYXJnc1swXS5uZXh0KSB7XG4gICAgICAgICAgICByZXR1cm4gRmxvYXROZXh0QXJiaXRyYXJ5XzEuZmxvYXROZXh0KGFyZ3NbMF0pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1pbiA9IGFyZ3NbMF0ubWluICE9PSB1bmRlZmluZWQgPyBhcmdzWzBdLm1pbiA6IDA7XG4gICAgICAgIGNvbnN0IG1heCA9IGFyZ3NbMF0ubWF4ICE9PSB1bmRlZmluZWQgPyBhcmdzWzBdLm1heCA6IDE7XG4gICAgICAgIHJldHVybiAoZmxvYXRJbnRlcm5hbCgpXG4gICAgICAgICAgICAubWFwKCh2KSA9PiBtaW4gKyB2ICogKG1heCAtIG1pbikpXG4gICAgICAgICAgICAuZmlsdGVyKChnKSA9PiBnICE9PSBtYXggfHwgZyA9PT0gbWluKSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjb25zdCBhID0gYXJnc1swXTtcbiAgICAgICAgY29uc3QgYiA9IGFyZ3NbMV07XG4gICAgICAgIGlmIChhID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICByZXR1cm4gZmxvYXRJbnRlcm5hbCgpO1xuICAgICAgICBpZiAoYiA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgcmV0dXJuIChmbG9hdEludGVybmFsKClcbiAgICAgICAgICAgICAgICAubWFwKCh2KSA9PiB2ICogYSlcbiAgICAgICAgICAgICAgICAuZmlsdGVyKChnKSA9PiBnICE9PSBhIHx8IGcgPT09IDApKTtcbiAgICAgICAgcmV0dXJuIChmbG9hdEludGVybmFsKClcbiAgICAgICAgICAgIC5tYXAoKHYpID0+IGEgKyB2ICogKGIgLSBhKSlcbiAgICAgICAgICAgIC5maWx0ZXIoKGcpID0+IGcgIT09IGIgfHwgZyA9PT0gYSkpO1xuICAgIH1cbn1cbmV4cG9ydHMuZmxvYXQgPSBmbG9hdDtcbmNvbnN0IGRvdWJsZUZhY3RvciA9IE1hdGgucG93KDIsIDI3KTtcbmNvbnN0IGRvdWJsZURpdmlzb3IgPSBNYXRoLnBvdygyLCAtNTMpO1xuY29uc3QgZG91YmxlSW50ZXJuYWwgPSAoKSA9PiB7XG4gICAgcmV0dXJuIHR1cGxlXzEudHVwbGUobmV4dCgyNiksIG5leHQoMjcpKS5tYXAoKHYpID0+ICh2WzBdICogZG91YmxlRmFjdG9yICsgdlsxXSkgKiBkb3VibGVEaXZpc29yKTtcbn07XG5mdW5jdGlvbiBkb3VibGUoLi4uYXJncykge1xuICAgIGlmICh0eXBlb2YgYXJnc1swXSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgaWYgKGFyZ3NbMF0ubmV4dCkge1xuICAgICAgICAgICAgcmV0dXJuIERvdWJsZU5leHRBcmJpdHJhcnlfMS5kb3VibGVOZXh0KGFyZ3NbMF0pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1pbiA9IGFyZ3NbMF0ubWluICE9PSB1bmRlZmluZWQgPyBhcmdzWzBdLm1pbiA6IDA7XG4gICAgICAgIGNvbnN0IG1heCA9IGFyZ3NbMF0ubWF4ICE9PSB1bmRlZmluZWQgPyBhcmdzWzBdLm1heCA6IDE7XG4gICAgICAgIHJldHVybiAoZG91YmxlSW50ZXJuYWwoKVxuICAgICAgICAgICAgLm1hcCgodikgPT4gbWluICsgdiAqIChtYXggLSBtaW4pKVxuICAgICAgICAgICAgLmZpbHRlcigoZykgPT4gZyAhPT0gbWF4IHx8IGcgPT09IG1pbikpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgY29uc3QgYSA9IGFyZ3NbMF07XG4gICAgICAgIGNvbnN0IGIgPSBhcmdzWzFdO1xuICAgICAgICBpZiAoYSA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgcmV0dXJuIGRvdWJsZUludGVybmFsKCk7XG4gICAgICAgIGlmIChiID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICByZXR1cm4gKGRvdWJsZUludGVybmFsKClcbiAgICAgICAgICAgICAgICAubWFwKCh2KSA9PiB2ICogYSlcbiAgICAgICAgICAgICAgICAuZmlsdGVyKChnKSA9PiBnICE9PSBhIHx8IGcgPT09IDApKTtcbiAgICAgICAgcmV0dXJuIChkb3VibGVJbnRlcm5hbCgpXG4gICAgICAgICAgICAubWFwKCh2KSA9PiBhICsgdiAqIChiIC0gYSkpXG4gICAgICAgICAgICAuZmlsdGVyKChnKSA9PiBnICE9PSBiIHx8IGcgPT09IGEpKTtcbiAgICB9XG59XG5leHBvcnRzLmRvdWJsZSA9IGRvdWJsZTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5ob3N0VXNlckluZm8gPSBleHBvcnRzLmRvbWFpbiA9IGV4cG9ydHMuZmlsdGVySW52YWxpZFN1YmRvbWFpbkxhYmVsID0gdm9pZCAwO1xuY29uc3QgYXJyYXlfMSA9IHJlcXVpcmUoXCIuLi8uLi9hcmJpdHJhcnkvYXJyYXlcIik7XG5jb25zdCBTcGVjaWZpY0NoYXJhY3RlclJhbmdlXzEgPSByZXF1aXJlKFwiLi9oZWxwZXJzL1NwZWNpZmljQ2hhcmFjdGVyUmFuZ2VcIik7XG5jb25zdCBvcHRpb25fMSA9IHJlcXVpcmUoXCIuLi8uLi9hcmJpdHJhcnkvb3B0aW9uXCIpO1xuY29uc3Qgc3RyaW5nT2ZfMSA9IHJlcXVpcmUoXCIuLi8uLi9hcmJpdHJhcnkvc3RyaW5nT2ZcIik7XG5jb25zdCB0dXBsZV8xID0gcmVxdWlyZShcIi4uLy4uL2FyYml0cmFyeS90dXBsZVwiKTtcbmZ1bmN0aW9uIGZpbHRlckludmFsaWRTdWJkb21haW5MYWJlbChzdWJkb21haW5MYWJlbCkge1xuICAgIGlmIChzdWJkb21haW5MYWJlbC5sZW5ndGggPiA2Mykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiAoc3ViZG9tYWluTGFiZWwubGVuZ3RoIDwgNCB8fFxuICAgICAgICBzdWJkb21haW5MYWJlbFswXSAhPT0gJ3gnIHx8XG4gICAgICAgIHN1YmRvbWFpbkxhYmVsWzFdICE9PSAnbicgfHxcbiAgICAgICAgc3ViZG9tYWluTGFiZWxbMl0gIT09ICctJyB8fFxuICAgICAgICBzdWJkb21haW5MYWJlbFszXSAhPT0gJy0nKTtcbn1cbmV4cG9ydHMuZmlsdGVySW52YWxpZFN1YmRvbWFpbkxhYmVsID0gZmlsdGVySW52YWxpZFN1YmRvbWFpbkxhYmVsO1xuZnVuY3Rpb24gc3ViZG9tYWluTGFiZWwoKSB7XG4gICAgY29uc3QgYWxwaGFOdW1lcmljQXJiID0gU3BlY2lmaWNDaGFyYWN0ZXJSYW5nZV8xLmJ1aWxkTG93ZXJBbHBoYU51bWVyaWNBcmIoW10pO1xuICAgIGNvbnN0IGFscGhhTnVtZXJpY0h5cGhlbkFyYiA9IFNwZWNpZmljQ2hhcmFjdGVyUmFuZ2VfMS5idWlsZExvd2VyQWxwaGFOdW1lcmljQXJiKFsnLSddKTtcbiAgICByZXR1cm4gdHVwbGVfMS50dXBsZShhbHBoYU51bWVyaWNBcmIsIG9wdGlvbl8xLm9wdGlvbih0dXBsZV8xLnR1cGxlKHN0cmluZ09mXzEuc3RyaW5nT2YoYWxwaGFOdW1lcmljSHlwaGVuQXJiLCB7IG1heExlbmd0aDogNjEgfSksIGFscGhhTnVtZXJpY0FyYikpKVxuICAgICAgICAubWFwKChbZiwgZF0pID0+IChkID09PSBudWxsID8gZiA6IGAke2Z9JHtkWzBdfSR7ZFsxXX1gKSlcbiAgICAgICAgLmZpbHRlcihmaWx0ZXJJbnZhbGlkU3ViZG9tYWluTGFiZWwpO1xufVxuZnVuY3Rpb24gZG9tYWluKCkge1xuICAgIGNvbnN0IGFscGhhTnVtZXJpY0FyYiA9IFNwZWNpZmljQ2hhcmFjdGVyUmFuZ2VfMS5idWlsZExvd2VyQWxwaGFBcmIoW10pO1xuICAgIGNvbnN0IHB1YmxpY1N1ZmZpeEFyYiA9IHN0cmluZ09mXzEuc3RyaW5nT2YoYWxwaGFOdW1lcmljQXJiLCB7IG1pbkxlbmd0aDogMiwgbWF4TGVuZ3RoOiAxMCB9KTtcbiAgICByZXR1cm4gKHR1cGxlXzEudHVwbGUoYXJyYXlfMS5hcnJheShzdWJkb21haW5MYWJlbCgpLCB7IG1pbkxlbmd0aDogMSwgbWF4TGVuZ3RoOiA1IH0pLCBwdWJsaWNTdWZmaXhBcmIpXG4gICAgICAgIC5tYXAoKFttaWQsIGV4dF0pID0+IGAke21pZC5qb2luKCcuJyl9LiR7ZXh0fWApXG4gICAgICAgIC5maWx0ZXIoKGQpID0+IGQubGVuZ3RoIDw9IDI1NSkpO1xufVxuZXhwb3J0cy5kb21haW4gPSBkb21haW47XG5mdW5jdGlvbiBob3N0VXNlckluZm8oKSB7XG4gICAgY29uc3Qgb3RoZXJzID0gWyctJywgJy4nLCAnXycsICd+JywgJyEnLCAnJCcsICcmJywgXCInXCIsICcoJywgJyknLCAnKicsICcrJywgJywnLCAnOycsICc9JywgJzonXTtcbiAgICByZXR1cm4gc3RyaW5nT2ZfMS5zdHJpbmdPZihTcGVjaWZpY0NoYXJhY3RlclJhbmdlXzEuYnVpbGRBbHBoYU51bWVyaWNQZXJjZW50QXJiKG90aGVycykpO1xufVxuZXhwb3J0cy5ob3N0VXNlckluZm8gPSBob3N0VXNlckluZm87XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMudW5pY29kZUpzb24gPSBleHBvcnRzLmpzb24gPSBleHBvcnRzLnVuaWNvZGVKc29uT2JqZWN0ID0gZXhwb3J0cy5qc29uT2JqZWN0ID0gZXhwb3J0cy5vYmplY3QgPSBleHBvcnRzLmFueXRoaW5nID0gZXhwb3J0cy5ib3hBcmJpdHJhcnkgPSB2b2lkIDA7XG5jb25zdCBzdHJpbmdpZnlfMSA9IHJlcXVpcmUoXCIuLi8uLi91dGlscy9zdHJpbmdpZnlcIik7XG5jb25zdCBhcnJheV8xID0gcmVxdWlyZShcIi4uLy4uL2FyYml0cmFyeS9hcnJheVwiKTtcbmNvbnN0IGJvb2xlYW5fMSA9IHJlcXVpcmUoXCIuLi8uLi9hcmJpdHJhcnkvYm9vbGVhblwiKTtcbmNvbnN0IGNvbnN0YW50XzEgPSByZXF1aXJlKFwiLi4vLi4vYXJiaXRyYXJ5L2NvbnN0YW50XCIpO1xuY29uc3QgZGljdGlvbmFyeV8xID0gcmVxdWlyZShcIi4uLy4uL2FyYml0cmFyeS9kaWN0aW9uYXJ5XCIpO1xuY29uc3QgRmxvYXRpbmdQb2ludEFyYml0cmFyeV8xID0gcmVxdWlyZShcIi4vRmxvYXRpbmdQb2ludEFyYml0cmFyeVwiKTtcbmNvbnN0IGZyZXF1ZW5jeV8xID0gcmVxdWlyZShcIi4uLy4uL2FyYml0cmFyeS9mcmVxdWVuY3lcIik7XG5jb25zdCBtYXhTYWZlSW50ZWdlcl8xID0gcmVxdWlyZShcIi4uLy4uL2FyYml0cmFyeS9tYXhTYWZlSW50ZWdlclwiKTtcbmNvbnN0IG1lbW9fMSA9IHJlcXVpcmUoXCIuLi8uLi9hcmJpdHJhcnkvbWVtb1wiKTtcbmNvbnN0IG9uZW9mXzEgPSByZXF1aXJlKFwiLi4vLi4vYXJiaXRyYXJ5L29uZW9mXCIpO1xuY29uc3Qgc2V0XzEgPSByZXF1aXJlKFwiLi4vLi4vYXJiaXRyYXJ5L3NldFwiKTtcbmNvbnN0IHN0cmluZ18xID0gcmVxdWlyZShcIi4uLy4uL2FyYml0cmFyeS9zdHJpbmdcIik7XG5jb25zdCB1bmljb2RlU3RyaW5nXzEgPSByZXF1aXJlKFwiLi4vLi4vYXJiaXRyYXJ5L3VuaWNvZGVTdHJpbmdcIik7XG5jb25zdCB0dXBsZV8xID0gcmVxdWlyZShcIi4uLy4uL2FyYml0cmFyeS90dXBsZVwiKTtcbmNvbnN0IGJpZ0ludF8xID0gcmVxdWlyZShcIi4uLy4uL2FyYml0cmFyeS9iaWdJbnRcIik7XG5jb25zdCBkYXRlXzEgPSByZXF1aXJlKFwiLi4vLi4vYXJiaXRyYXJ5L2RhdGVcIik7XG5jb25zdCBmbG9hdDMyQXJyYXlfMSA9IHJlcXVpcmUoXCIuLi8uLi9hcmJpdHJhcnkvZmxvYXQzMkFycmF5XCIpO1xuY29uc3QgZmxvYXQ2NEFycmF5XzEgPSByZXF1aXJlKFwiLi4vLi4vYXJiaXRyYXJ5L2Zsb2F0NjRBcnJheVwiKTtcbmNvbnN0IGludDE2QXJyYXlfMSA9IHJlcXVpcmUoXCIuLi8uLi9hcmJpdHJhcnkvaW50MTZBcnJheVwiKTtcbmNvbnN0IGludDMyQXJyYXlfMSA9IHJlcXVpcmUoXCIuLi8uLi9hcmJpdHJhcnkvaW50MzJBcnJheVwiKTtcbmNvbnN0IGludDhBcnJheV8xID0gcmVxdWlyZShcIi4uLy4uL2FyYml0cmFyeS9pbnQ4QXJyYXlcIik7XG5jb25zdCB1aW50MTZBcnJheV8xID0gcmVxdWlyZShcIi4uLy4uL2FyYml0cmFyeS91aW50MTZBcnJheVwiKTtcbmNvbnN0IHVpbnQzMkFycmF5XzEgPSByZXF1aXJlKFwiLi4vLi4vYXJiaXRyYXJ5L3VpbnQzMkFycmF5XCIpO1xuY29uc3QgdWludDhBcnJheV8xID0gcmVxdWlyZShcIi4uLy4uL2FyYml0cmFyeS91aW50OEFycmF5XCIpO1xuY29uc3QgdWludDhDbGFtcGVkQXJyYXlfMSA9IHJlcXVpcmUoXCIuLi8uLi9hcmJpdHJhcnkvdWludDhDbGFtcGVkQXJyYXlcIik7XG5jb25zdCBTcGFyc2VBcnJheUFyYml0cmFyeV8xID0gcmVxdWlyZShcIi4vU3BhcnNlQXJyYXlBcmJpdHJhcnlcIik7XG5jb25zdCBLZXlWYWx1ZVBhaXJzVG9PYmplY3RfMSA9IHJlcXVpcmUoXCIuLi8uLi9hcmJpdHJhcnkvX2ludGVybmFscy9tYXBwZXJzL0tleVZhbHVlUGFpcnNUb09iamVjdFwiKTtcbmZ1bmN0aW9uIGJveEFyYml0cmFyeShhcmIpIHtcbiAgICByZXR1cm4gYXJiLm1hcCgodikgPT4ge1xuICAgICAgICBzd2l0Y2ggKHR5cGVvZiB2KSB7XG4gICAgICAgICAgICBjYXNlICdib29sZWFuJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEJvb2xlYW4odik7XG4gICAgICAgICAgICBjYXNlICdudW1iZXInOlxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgTnVtYmVyKHYpO1xuICAgICAgICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFN0cmluZyh2KTtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHY7XG4gICAgICAgIH1cbiAgICB9KTtcbn1cbmV4cG9ydHMuYm94QXJiaXRyYXJ5ID0gYm94QXJiaXRyYXJ5O1xuY2xhc3MgUXVhbGlmaWVkT2JqZWN0Q29uc3RyYWludHMge1xuICAgIGNvbnN0cnVjdG9yKGtleSwgdmFsdWVzLCBtYXhEZXB0aCwgbWF4S2V5cywgd2l0aFNldCwgd2l0aE1hcCwgd2l0aE9iamVjdFN0cmluZywgd2l0aE51bGxQcm90b3R5cGUsIHdpdGhCaWdJbnQsIHdpdGhEYXRlLCB3aXRoVHlwZWRBcnJheSwgd2l0aFNwYXJzZUFycmF5KSB7XG4gICAgICAgIHRoaXMua2V5ID0ga2V5O1xuICAgICAgICB0aGlzLnZhbHVlcyA9IHZhbHVlcztcbiAgICAgICAgdGhpcy5tYXhEZXB0aCA9IG1heERlcHRoO1xuICAgICAgICB0aGlzLm1heEtleXMgPSBtYXhLZXlzO1xuICAgICAgICB0aGlzLndpdGhTZXQgPSB3aXRoU2V0O1xuICAgICAgICB0aGlzLndpdGhNYXAgPSB3aXRoTWFwO1xuICAgICAgICB0aGlzLndpdGhPYmplY3RTdHJpbmcgPSB3aXRoT2JqZWN0U3RyaW5nO1xuICAgICAgICB0aGlzLndpdGhOdWxsUHJvdG90eXBlID0gd2l0aE51bGxQcm90b3R5cGU7XG4gICAgICAgIHRoaXMud2l0aEJpZ0ludCA9IHdpdGhCaWdJbnQ7XG4gICAgICAgIHRoaXMud2l0aERhdGUgPSB3aXRoRGF0ZTtcbiAgICAgICAgdGhpcy53aXRoVHlwZWRBcnJheSA9IHdpdGhUeXBlZEFycmF5O1xuICAgICAgICB0aGlzLndpdGhTcGFyc2VBcnJheSA9IHdpdGhTcGFyc2VBcnJheTtcbiAgICB9XG4gICAgc3RhdGljIGRlZmF1bHRWYWx1ZXMoKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICBib29sZWFuXzEuYm9vbGVhbigpLFxuICAgICAgICAgICAgbWF4U2FmZUludGVnZXJfMS5tYXhTYWZlSW50ZWdlcigpLFxuICAgICAgICAgICAgRmxvYXRpbmdQb2ludEFyYml0cmFyeV8xLmRvdWJsZSh7IG5leHQ6IHRydWUgfSksXG4gICAgICAgICAgICBzdHJpbmdfMS5zdHJpbmcoKSxcbiAgICAgICAgICAgIG9uZW9mXzEub25lb2Yoc3RyaW5nXzEuc3RyaW5nKCksIGNvbnN0YW50XzEuY29uc3RhbnQobnVsbCksIGNvbnN0YW50XzEuY29uc3RhbnQodW5kZWZpbmVkKSksXG4gICAgICAgIF07XG4gICAgfVxuICAgIHN0YXRpYyBib3hBcmJpdHJhcmllcyhhcmJzKSB7XG4gICAgICAgIHJldHVybiBhcmJzLm1hcCgoYXJiKSA9PiBib3hBcmJpdHJhcnkoYXJiKSk7XG4gICAgfVxuICAgIHN0YXRpYyBib3hBcmJpdHJhcmllc0lmTmVlZGVkKGFyYnMsIGJveEVuYWJsZWQpIHtcbiAgICAgICAgcmV0dXJuIGJveEVuYWJsZWQgPyBRdWFsaWZpZWRPYmplY3RDb25zdHJhaW50cy5ib3hBcmJpdHJhcmllcyhhcmJzKS5jb25jYXQoYXJicykgOiBhcmJzO1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbShzZXR0aW5ncyA9IHt9KSB7XG4gICAgICAgIGZ1bmN0aW9uIG9yRGVmYXVsdChvcHRpb25hbFZhbHVlLCBkZWZhdWx0VmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiBvcHRpb25hbFZhbHVlICE9PSB1bmRlZmluZWQgPyBvcHRpb25hbFZhbHVlIDogZGVmYXVsdFZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgUXVhbGlmaWVkT2JqZWN0Q29uc3RyYWludHMob3JEZWZhdWx0KHNldHRpbmdzLmtleSwgc3RyaW5nXzEuc3RyaW5nKCkpLCBRdWFsaWZpZWRPYmplY3RDb25zdHJhaW50cy5ib3hBcmJpdHJhcmllc0lmTmVlZGVkKG9yRGVmYXVsdChzZXR0aW5ncy52YWx1ZXMsIFF1YWxpZmllZE9iamVjdENvbnN0cmFpbnRzLmRlZmF1bHRWYWx1ZXMoKSksIG9yRGVmYXVsdChzZXR0aW5ncy53aXRoQm94ZWRWYWx1ZXMsIGZhbHNlKSksIG9yRGVmYXVsdChzZXR0aW5ncy5tYXhEZXB0aCwgMiksIG9yRGVmYXVsdChzZXR0aW5ncy5tYXhLZXlzLCA1KSwgb3JEZWZhdWx0KHNldHRpbmdzLndpdGhTZXQsIGZhbHNlKSwgb3JEZWZhdWx0KHNldHRpbmdzLndpdGhNYXAsIGZhbHNlKSwgb3JEZWZhdWx0KHNldHRpbmdzLndpdGhPYmplY3RTdHJpbmcsIGZhbHNlKSwgb3JEZWZhdWx0KHNldHRpbmdzLndpdGhOdWxsUHJvdG90eXBlLCBmYWxzZSksIG9yRGVmYXVsdChzZXR0aW5ncy53aXRoQmlnSW50LCBmYWxzZSksIG9yRGVmYXVsdChzZXR0aW5ncy53aXRoRGF0ZSwgZmFsc2UpLCBvckRlZmF1bHQoc2V0dGluZ3Mud2l0aFR5cGVkQXJyYXksIGZhbHNlKSwgb3JEZWZhdWx0KHNldHRpbmdzLndpdGhTcGFyc2VBcnJheSwgZmFsc2UpKTtcbiAgICB9XG59XG5jb25zdCBhbnl0aGluZ0ludGVybmFsID0gKGNvbnN0cmFpbnRzKSA9PiB7XG4gICAgY29uc3QgYXJiS2V5cyA9IGNvbnN0cmFpbnRzLndpdGhPYmplY3RTdHJpbmdcbiAgICAgICAgPyBtZW1vXzEubWVtbygobikgPT4gZnJlcXVlbmN5XzEuZnJlcXVlbmN5KHsgYXJiaXRyYXJ5OiBjb25zdHJhaW50cy5rZXksIHdlaWdodDogMTAgfSwgeyBhcmJpdHJhcnk6IGFueXRoaW5nQXJiKG4pLm1hcCgobykgPT4gc3RyaW5naWZ5XzEuc3RyaW5naWZ5KG8pKSwgd2VpZ2h0OiAxIH0pKVxuICAgICAgICA6IG1lbW9fMS5tZW1vKCgpID0+IGNvbnN0cmFpbnRzLmtleSk7XG4gICAgY29uc3QgYXJiaXRyYXJpZXNGb3JCYXNlID0gY29uc3RyYWludHMudmFsdWVzO1xuICAgIGNvbnN0IG1heERlcHRoID0gY29uc3RyYWludHMubWF4RGVwdGg7XG4gICAgY29uc3QgbWF4S2V5cyA9IGNvbnN0cmFpbnRzLm1heEtleXM7XG4gICAgY29uc3QgZW50cmllc09mID0gKGtleUFyYiwgdmFsdWVBcmIpID0+IHNldF8xLnNldCh0dXBsZV8xLnR1cGxlKGtleUFyYiwgdmFsdWVBcmIpLCB7IG1heExlbmd0aDogbWF4S2V5cywgY29tcGFyZTogKHQxLCB0MikgPT4gdDFbMF0gPT09IHQyWzBdIH0pO1xuICAgIGNvbnN0IG1hcE9mID0gKGthLCB2YSkgPT4gZW50cmllc09mKGthLCB2YSkubWFwKCh2KSA9PiBuZXcgTWFwKHYpKTtcbiAgICBjb25zdCBkaWN0T2YgPSAoa2EsIHZhKSA9PiBlbnRyaWVzT2Yoa2EsIHZhKS5tYXAoKHYpID0+IEtleVZhbHVlUGFpcnNUb09iamVjdF8xLmtleVZhbHVlUGFpcnNUb09iamVjdE1hcHBlcih2KSk7XG4gICAgY29uc3QgYmFzZUFyYiA9IG9uZW9mXzEub25lb2YoLi4uYXJiaXRyYXJpZXNGb3JCYXNlKTtcbiAgICBjb25zdCBhcnJheUJhc2VBcmIgPSBvbmVvZl8xLm9uZW9mKC4uLmFyYml0cmFyaWVzRm9yQmFzZS5tYXAoKGFyYikgPT4gYXJyYXlfMS5hcnJheShhcmIsIHsgbWF4TGVuZ3RoOiBtYXhLZXlzIH0pKSk7XG4gICAgY29uc3Qgb2JqZWN0QmFzZUFyYiA9IChuKSA9PiBvbmVvZl8xLm9uZW9mKC4uLmFyYml0cmFyaWVzRm9yQmFzZS5tYXAoKGFyYikgPT4gZGljdE9mKGFyYktleXMobiksIGFyYikpKTtcbiAgICBjb25zdCBzZXRCYXNlQXJiID0gKCkgPT4gb25lb2ZfMS5vbmVvZiguLi5hcmJpdHJhcmllc0ZvckJhc2UubWFwKChhcmIpID0+IHNldF8xLnNldChhcmIsIHsgbWF4TGVuZ3RoOiBtYXhLZXlzIH0pLm1hcCgodikgPT4gbmV3IFNldCh2KSkpKTtcbiAgICBjb25zdCBtYXBCYXNlQXJiID0gKG4pID0+IG9uZW9mXzEub25lb2YoLi4uYXJiaXRyYXJpZXNGb3JCYXNlLm1hcCgoYXJiKSA9PiBtYXBPZihhcmJLZXlzKG4pLCBhcmIpKSk7XG4gICAgY29uc3QgYXJyYXlBcmIgPSBtZW1vXzEubWVtbygobikgPT4gb25lb2ZfMS5vbmVvZihhcnJheUJhc2VBcmIsIGFycmF5XzEuYXJyYXkoYW55dGhpbmdBcmIobiksIHsgbWF4TGVuZ3RoOiBtYXhLZXlzIH0pKSk7XG4gICAgY29uc3Qgc2V0QXJiID0gbWVtb18xLm1lbW8oKG4pID0+IG9uZW9mXzEub25lb2Yoc2V0QmFzZUFyYigpLCBzZXRfMS5zZXQoYW55dGhpbmdBcmIobiksIHsgbWF4TGVuZ3RoOiBtYXhLZXlzIH0pLm1hcCgodikgPT4gbmV3IFNldCh2KSkpKTtcbiAgICBjb25zdCBtYXBBcmIgPSBtZW1vXzEubWVtbygobikgPT4gb25lb2ZfMS5vbmVvZihtYXBCYXNlQXJiKG4pLCBvbmVvZl8xLm9uZW9mKG1hcE9mKGFyYktleXMobiksIGFueXRoaW5nQXJiKG4pKSwgbWFwT2YoYW55dGhpbmdBcmIobiksIGFueXRoaW5nQXJiKG4pKSkpKTtcbiAgICBjb25zdCBvYmplY3RBcmIgPSBtZW1vXzEubWVtbygobikgPT4gb25lb2ZfMS5vbmVvZihvYmplY3RCYXNlQXJiKG4pLCBkaWN0T2YoYXJiS2V5cyhuKSwgYW55dGhpbmdBcmIobikpKSk7XG4gICAgY29uc3QgYW55dGhpbmdBcmIgPSBtZW1vXzEubWVtbygobikgPT4ge1xuICAgICAgICBpZiAobiA8PSAwKVxuICAgICAgICAgICAgcmV0dXJuIG9uZW9mXzEub25lb2YoYmFzZUFyYik7XG4gICAgICAgIHJldHVybiBvbmVvZl8xLm9uZW9mKGJhc2VBcmIsIGFycmF5QXJiKCksIG9iamVjdEFyYigpLCAuLi4oY29uc3RyYWludHMud2l0aE1hcCA/IFttYXBBcmIoKV0gOiBbXSksIC4uLihjb25zdHJhaW50cy53aXRoU2V0ID8gW3NldEFyYigpXSA6IFtdKSwgLi4uKGNvbnN0cmFpbnRzLndpdGhPYmplY3RTdHJpbmcgPyBbYW55dGhpbmdBcmIoKS5tYXAoKG8pID0+IHN0cmluZ2lmeV8xLnN0cmluZ2lmeShvKSldIDogW10pLCAuLi4oY29uc3RyYWludHMud2l0aE51bGxQcm90b3R5cGUgPyBbb2JqZWN0QXJiKCkubWFwKChvKSA9PiBPYmplY3QuYXNzaWduKE9iamVjdC5jcmVhdGUobnVsbCksIG8pKV0gOiBbXSksIC4uLihjb25zdHJhaW50cy53aXRoQmlnSW50ID8gW2JpZ0ludF8xLmJpZ0ludCgpXSA6IFtdKSwgLi4uKGNvbnN0cmFpbnRzLndpdGhEYXRlID8gW2RhdGVfMS5kYXRlKCldIDogW10pLCAuLi4oY29uc3RyYWludHMud2l0aFR5cGVkQXJyYXlcbiAgICAgICAgICAgID8gW1xuICAgICAgICAgICAgICAgIG9uZW9mXzEub25lb2YoaW50OEFycmF5XzEuaW50OEFycmF5KCksIHVpbnQ4QXJyYXlfMS51aW50OEFycmF5KCksIHVpbnQ4Q2xhbXBlZEFycmF5XzEudWludDhDbGFtcGVkQXJyYXkoKSwgaW50MTZBcnJheV8xLmludDE2QXJyYXkoKSwgdWludDE2QXJyYXlfMS51aW50MTZBcnJheSgpLCBpbnQzMkFycmF5XzEuaW50MzJBcnJheSgpLCB1aW50MzJBcnJheV8xLnVpbnQzMkFycmF5KCksIGZsb2F0MzJBcnJheV8xLmZsb2F0MzJBcnJheSgpLCBmbG9hdDY0QXJyYXlfMS5mbG9hdDY0QXJyYXkoKSksXG4gICAgICAgICAgICBdXG4gICAgICAgICAgICA6IFtdKSwgLi4uKGNvbnN0cmFpbnRzLndpdGhTcGFyc2VBcnJheSA/IFtTcGFyc2VBcnJheUFyYml0cmFyeV8xLnNwYXJzZUFycmF5KGFueXRoaW5nQXJiKCkpXSA6IFtdKSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIGFueXRoaW5nQXJiKG1heERlcHRoKTtcbn07XG5jb25zdCBvYmplY3RJbnRlcm5hbCA9IChjb25zdHJhaW50cykgPT4ge1xuICAgIHJldHVybiBkaWN0aW9uYXJ5XzEuZGljdGlvbmFyeShjb25zdHJhaW50cy5rZXksIGFueXRoaW5nSW50ZXJuYWwoY29uc3RyYWludHMpKTtcbn07XG5mdW5jdGlvbiBhbnl0aGluZyhjb25zdHJhaW50cykge1xuICAgIHJldHVybiBhbnl0aGluZ0ludGVybmFsKFF1YWxpZmllZE9iamVjdENvbnN0cmFpbnRzLmZyb20oY29uc3RyYWludHMpKTtcbn1cbmV4cG9ydHMuYW55dGhpbmcgPSBhbnl0aGluZztcbmZ1bmN0aW9uIG9iamVjdChjb25zdHJhaW50cykge1xuICAgIHJldHVybiBvYmplY3RJbnRlcm5hbChRdWFsaWZpZWRPYmplY3RDb25zdHJhaW50cy5mcm9tKGNvbnN0cmFpbnRzKSk7XG59XG5leHBvcnRzLm9iamVjdCA9IG9iamVjdDtcbmZ1bmN0aW9uIGpzb25TZXR0aW5ncyhzdHJpbmdBcmJpdHJhcnksIGNvbnN0cmFpbnRzKSB7XG4gICAgY29uc3Qga2V5ID0gc3RyaW5nQXJiaXRyYXJ5O1xuICAgIGNvbnN0IHZhbHVlcyA9IFtcbiAgICAgICAgYm9vbGVhbl8xLmJvb2xlYW4oKSxcbiAgICAgICAgbWF4U2FmZUludGVnZXJfMS5tYXhTYWZlSW50ZWdlcigpLFxuICAgICAgICBGbG9hdGluZ1BvaW50QXJiaXRyYXJ5XzEuZG91YmxlKHsgbmV4dDogdHJ1ZSwgbm9EZWZhdWx0SW5maW5pdHk6IHRydWUsIG5vTmFOOiB0cnVlIH0pLFxuICAgICAgICBzdHJpbmdBcmJpdHJhcnksXG4gICAgICAgIGNvbnN0YW50XzEuY29uc3RhbnQobnVsbCksXG4gICAgXTtcbiAgICByZXR1cm4gY29uc3RyYWludHMgIT0gbnVsbFxuICAgICAgICA/IHR5cGVvZiBjb25zdHJhaW50cyA9PT0gJ251bWJlcidcbiAgICAgICAgICAgID8geyBrZXksIHZhbHVlcywgbWF4RGVwdGg6IGNvbnN0cmFpbnRzIH1cbiAgICAgICAgICAgIDogeyBrZXksIHZhbHVlcywgbWF4RGVwdGg6IGNvbnN0cmFpbnRzLm1heERlcHRoIH1cbiAgICAgICAgOiB7IGtleSwgdmFsdWVzIH07XG59XG5mdW5jdGlvbiBqc29uT2JqZWN0KGNvbnN0cmFpbnRzKSB7XG4gICAgcmV0dXJuIGFueXRoaW5nKGpzb25TZXR0aW5ncyhzdHJpbmdfMS5zdHJpbmcoKSwgY29uc3RyYWludHMpKTtcbn1cbmV4cG9ydHMuanNvbk9iamVjdCA9IGpzb25PYmplY3Q7XG5mdW5jdGlvbiB1bmljb2RlSnNvbk9iamVjdChjb25zdHJhaW50cykge1xuICAgIHJldHVybiBhbnl0aGluZyhqc29uU2V0dGluZ3ModW5pY29kZVN0cmluZ18xLnVuaWNvZGVTdHJpbmcoKSwgY29uc3RyYWludHMpKTtcbn1cbmV4cG9ydHMudW5pY29kZUpzb25PYmplY3QgPSB1bmljb2RlSnNvbk9iamVjdDtcbmZ1bmN0aW9uIGpzb24oY29uc3RyYWludHMpIHtcbiAgICBjb25zdCBhcmIgPSBjb25zdHJhaW50cyAhPSBudWxsID8ganNvbk9iamVjdChjb25zdHJhaW50cykgOiBqc29uT2JqZWN0KCk7XG4gICAgcmV0dXJuIGFyYi5tYXAoSlNPTi5zdHJpbmdpZnkpO1xufVxuZXhwb3J0cy5qc29uID0ganNvbjtcbmZ1bmN0aW9uIHVuaWNvZGVKc29uKGNvbnN0cmFpbnRzKSB7XG4gICAgY29uc3QgYXJiID0gY29uc3RyYWludHMgIT0gbnVsbCA/IHVuaWNvZGVKc29uT2JqZWN0KGNvbnN0cmFpbnRzKSA6IHVuaWNvZGVKc29uT2JqZWN0KCk7XG4gICAgcmV0dXJuIGFyYi5tYXAoSlNPTi5zdHJpbmdpZnkpO1xufVxuZXhwb3J0cy51bmljb2RlSnNvbiA9IHVuaWNvZGVKc29uO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnNwYXJzZUFycmF5ID0gdm9pZCAwO1xuY29uc3QgbmF0XzEgPSByZXF1aXJlKFwiLi4vLi4vYXJiaXRyYXJ5L25hdFwiKTtcbmNvbnN0IHNldF8xID0gcmVxdWlyZShcIi4uLy4uL2FyYml0cmFyeS9zZXRcIik7XG5jb25zdCB0dXBsZV8xID0gcmVxdWlyZShcIi4uLy4uL2FyYml0cmFyeS90dXBsZVwiKTtcbmNvbnN0IE1heExlbmd0aEZyb21NaW5MZW5ndGhfMSA9IHJlcXVpcmUoXCIuLi8uLi9hcmJpdHJhcnkvX2ludGVybmFscy9oZWxwZXJzL01heExlbmd0aEZyb21NaW5MZW5ndGhcIik7XG5mdW5jdGlvbiBleHRyYWN0TWF4SW5kZXgoaW5kZXhlc0FuZFZhbHVlcykge1xuICAgIGxldCBtYXhJbmRleCA9IC0xO1xuICAgIGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggIT09IGluZGV4ZXNBbmRWYWx1ZXMubGVuZ3RoOyArK2luZGV4KSB7XG4gICAgICAgIG1heEluZGV4ID0gTWF0aC5tYXgobWF4SW5kZXgsIGluZGV4ZXNBbmRWYWx1ZXNbaW5kZXhdWzBdKTtcbiAgICB9XG4gICAgcmV0dXJuIG1heEluZGV4O1xufVxuZnVuY3Rpb24gYXJyYXlGcm9tSXRlbXMobGVuZ3RoLCBpbmRleGVzQW5kVmFsdWVzKSB7XG4gICAgY29uc3QgYXJyYXkgPSBBcnJheShsZW5ndGgpO1xuICAgIGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggIT09IGluZGV4ZXNBbmRWYWx1ZXMubGVuZ3RoOyArK2luZGV4KSB7XG4gICAgICAgIGNvbnN0IGl0ID0gaW5kZXhlc0FuZFZhbHVlc1tpbmRleF07XG4gICAgICAgIGlmIChpdFswXSA8IGxlbmd0aClcbiAgICAgICAgICAgIGFycmF5W2l0WzBdXSA9IGl0WzFdO1xuICAgIH1cbiAgICByZXR1cm4gYXJyYXk7XG59XG5mdW5jdGlvbiBzcGFyc2VBcnJheShhcmIsIGNvbnN0cmFpbnRzID0ge30pIHtcbiAgICBjb25zdCB7IG1pbk51bUVsZW1lbnRzID0gMCwgbWF4TnVtRWxlbWVudHMgPSBNYXhMZW5ndGhGcm9tTWluTGVuZ3RoXzEubWF4TGVuZ3RoRnJvbU1pbkxlbmd0aChtaW5OdW1FbGVtZW50cyksIG1heExlbmd0aCA9IE1hdGgubWluKE1heExlbmd0aEZyb21NaW5MZW5ndGhfMS5tYXhMZW5ndGhGcm9tTWluTGVuZ3RoKG1heE51bUVsZW1lbnRzKSwgNDI5NDk2NzI5NSksIG5vVHJhaWxpbmdIb2xlLCB9ID0gY29uc3RyYWludHM7XG4gICAgaWYgKG1pbk51bUVsZW1lbnRzID4gbWF4TGVuZ3RoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgVGhlIG1pbmltYWwgbnVtYmVyIG9mIG5vbi1ob2xlIGVsZW1lbnRzIGNhbm5vdCBiZSBoaWdoZXIgdGhhbiB0aGUgbWF4aW1hbCBsZW5ndGggb2YgdGhlIGFycmF5YCk7XG4gICAgfVxuICAgIGlmIChtaW5OdW1FbGVtZW50cyA+IG1heE51bUVsZW1lbnRzKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgVGhlIG1pbmltYWwgbnVtYmVyIG9mIG5vbi1ob2xlIGVsZW1lbnRzIGNhbm5vdCBiZSBoaWdoZXIgdGhhbiB0aGUgbWF4aW1hbCBudW1iZXIgb2Ygbm9uLWhvbGVzYCk7XG4gICAgfVxuICAgIGNvbnN0IHJlc3VsdGVkTWF4TnVtRWxlbWVudHMgPSBNYXRoLm1pbihtYXhOdW1FbGVtZW50cywgbWF4TGVuZ3RoKTtcbiAgICBpZiAobm9UcmFpbGluZ0hvbGUpIHtcbiAgICAgICAgY29uc3QgbWF4SW5kZXhBdXRob3JpemVkID0gTWF0aC5tYXgobWF4TGVuZ3RoIC0gMSwgMCk7XG4gICAgICAgIHJldHVybiBzZXRfMS5zZXQodHVwbGVfMS50dXBsZShuYXRfMS5uYXQobWF4SW5kZXhBdXRob3JpemVkKSwgYXJiKSwge1xuICAgICAgICAgICAgbWluTGVuZ3RoOiBtaW5OdW1FbGVtZW50cyxcbiAgICAgICAgICAgIG1heExlbmd0aDogcmVzdWx0ZWRNYXhOdW1FbGVtZW50cyxcbiAgICAgICAgICAgIGNvbXBhcmU6IChpdGVtQSwgaXRlbUIpID0+IGl0ZW1BWzBdID09PSBpdGVtQlswXSxcbiAgICAgICAgfSkubWFwKChpdGVtcykgPT4ge1xuICAgICAgICAgICAgY29uc3QgbGFzdEluZGV4ID0gZXh0cmFjdE1heEluZGV4KGl0ZW1zKTtcbiAgICAgICAgICAgIHJldHVybiBhcnJheUZyb21JdGVtcyhsYXN0SW5kZXggKyAxLCBpdGVtcyk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gc2V0XzEuc2V0KHR1cGxlXzEudHVwbGUobmF0XzEubmF0KG1heExlbmd0aCksIGFyYiksIHtcbiAgICAgICAgbWluTGVuZ3RoOiBtaW5OdW1FbGVtZW50cyArIDEsXG4gICAgICAgIG1heExlbmd0aDogcmVzdWx0ZWRNYXhOdW1FbGVtZW50cyArIDEsXG4gICAgICAgIGNvbXBhcmU6IChpdGVtQSwgaXRlbUIpID0+IGl0ZW1BWzBdID09PSBpdGVtQlswXSxcbiAgICB9KS5tYXAoKGl0ZW1zKSA9PiB7XG4gICAgICAgIGNvbnN0IGxlbmd0aCA9IGV4dHJhY3RNYXhJbmRleChpdGVtcyk7XG4gICAgICAgIHJldHVybiBhcnJheUZyb21JdGVtcyhsZW5ndGgsIGl0ZW1zKTtcbiAgICB9KTtcbn1cbmV4cG9ydHMuc3BhcnNlQXJyYXkgPSBzcGFyc2VBcnJheTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5zaHVmZmxlZFN1YmFycmF5ID0gZXhwb3J0cy5zdWJhcnJheSA9IHZvaWQgMDtcbmNvbnN0IFN0cmVhbV8xID0gcmVxdWlyZShcIi4uLy4uL3N0cmVhbS9TdHJlYW1cIik7XG5jb25zdCBBcmJpdHJhcnlfMSA9IHJlcXVpcmUoXCIuL2RlZmluaXRpb24vQXJiaXRyYXJ5XCIpO1xuY29uc3QgQmlhc2VkQXJiaXRyYXJ5V3JhcHBlcl8xID0gcmVxdWlyZShcIi4vZGVmaW5pdGlvbi9CaWFzZWRBcmJpdHJhcnlXcmFwcGVyXCIpO1xuY29uc3QgU2hyaW5rYWJsZV8xID0gcmVxdWlyZShcIi4vZGVmaW5pdGlvbi9TaHJpbmthYmxlXCIpO1xuY29uc3QgaW50ZWdlcl8xID0gcmVxdWlyZShcIi4uLy4uL2FyYml0cmFyeS9pbnRlZ2VyXCIpO1xuY29uc3QgTGF6eUl0ZXJhYmxlSXRlcmF0b3JfMSA9IHJlcXVpcmUoXCIuLi8uLi9zdHJlYW0vTGF6eUl0ZXJhYmxlSXRlcmF0b3JcIik7XG5jbGFzcyBTdWJhcnJheUFyYml0cmFyeSBleHRlbmRzIEFyYml0cmFyeV8xLkFyYml0cmFyeSB7XG4gICAgY29uc3RydWN0b3Iob3JpZ2luYWxBcnJheSwgaXNPcmRlcmVkLCBtaW5MZW5ndGgsIG1heExlbmd0aCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLm9yaWdpbmFsQXJyYXkgPSBvcmlnaW5hbEFycmF5O1xuICAgICAgICB0aGlzLmlzT3JkZXJlZCA9IGlzT3JkZXJlZDtcbiAgICAgICAgdGhpcy5taW5MZW5ndGggPSBtaW5MZW5ndGg7XG4gICAgICAgIHRoaXMubWF4TGVuZ3RoID0gbWF4TGVuZ3RoO1xuICAgICAgICBpZiAobWluTGVuZ3RoIDwgMCB8fCBtaW5MZW5ndGggPiBvcmlnaW5hbEFycmF5Lmxlbmd0aClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignZmMuKntzfFN9dWJhcnJheU9mIGV4cGVjdHMgdGhlIG1pbmltYWwgbGVuZ3RoIHRvIGJlIGJldHdlZW4gMCBhbmQgdGhlIHNpemUgb2YgdGhlIG9yaWdpbmFsIGFycmF5Jyk7XG4gICAgICAgIGlmIChtYXhMZW5ndGggPCAwIHx8IG1heExlbmd0aCA+IG9yaWdpbmFsQXJyYXkubGVuZ3RoKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdmYy4qe3N8U311YmFycmF5T2YgZXhwZWN0cyB0aGUgbWF4aW1hbCBsZW5ndGggdG8gYmUgYmV0d2VlbiAwIGFuZCB0aGUgc2l6ZSBvZiB0aGUgb3JpZ2luYWwgYXJyYXknKTtcbiAgICAgICAgaWYgKG1pbkxlbmd0aCA+IG1heExlbmd0aClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignZmMuKntzfFN9dWJhcnJheU9mIGV4cGVjdHMgdGhlIG1pbmltYWwgbGVuZ3RoIHRvIGJlIGluZmVyaW9yIG9yIGVxdWFsIHRvIHRoZSBtYXhpbWFsIGxlbmd0aCcpO1xuICAgICAgICB0aGlzLmxlbmd0aEFyYiA9IGludGVnZXJfMS5pbnRlZ2VyKG1pbkxlbmd0aCwgbWF4TGVuZ3RoKTtcbiAgICB9XG4gICAgd3JhcHBlcihpdGVtcywgaXRlbXNMZW5ndGhDb250ZXh0KSB7XG4gICAgICAgIHJldHVybiBuZXcgU2hyaW5rYWJsZV8xLlNocmlua2FibGUoaXRlbXMsICgpID0+IHRoaXMuc2hyaW5rSW1wbChpdGVtcywgaXRlbXNMZW5ndGhDb250ZXh0KS5tYXAoKGNvbnRleHR1YWxWYWx1ZSkgPT4gdGhpcy53cmFwcGVyKGNvbnRleHR1YWxWYWx1ZVswXSwgY29udGV4dHVhbFZhbHVlWzFdKSkpO1xuICAgIH1cbiAgICBnZW5lcmF0ZShtcm5nKSB7XG4gICAgICAgIGNvbnN0IHJlbWFpbmluZ0VsZW1lbnRzID0gdGhpcy5vcmlnaW5hbEFycmF5Lm1hcCgoX3YsIGlkeCkgPT4gaWR4KTtcbiAgICAgICAgY29uc3Qgc2l6ZSA9IHRoaXMubGVuZ3RoQXJiLmdlbmVyYXRlKG1ybmcpLnZhbHVlO1xuICAgICAgICBjb25zdCBpZHMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaWR4ID0gMDsgaWR4ICE9PSBzaXplOyArK2lkeCkge1xuICAgICAgICAgICAgY29uc3Qgc2VsZWN0ZWRJZEluZGV4ID0gbXJuZy5uZXh0SW50KDAsIHJlbWFpbmluZ0VsZW1lbnRzLmxlbmd0aCAtIDEpO1xuICAgICAgICAgICAgaWRzLnB1c2gocmVtYWluaW5nRWxlbWVudHNbc2VsZWN0ZWRJZEluZGV4XSk7XG4gICAgICAgICAgICByZW1haW5pbmdFbGVtZW50cy5zcGxpY2Uoc2VsZWN0ZWRJZEluZGV4LCAxKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5pc09yZGVyZWQpXG4gICAgICAgICAgICBpZHMuc29ydCgoYSwgYikgPT4gYSAtIGIpO1xuICAgICAgICByZXR1cm4gdGhpcy53cmFwcGVyKGlkcy5tYXAoKGkpID0+IHRoaXMub3JpZ2luYWxBcnJheVtpXSksIHVuZGVmaW5lZCk7XG4gICAgfVxuICAgIHNocmlua0ltcGwoaXRlbXMsIGl0ZW1zTGVuZ3RoQ29udGV4dCkge1xuICAgICAgICBpZiAoaXRlbXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gU3RyZWFtXzEuU3RyZWFtLm5pbCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmxlbmd0aEFyYlxuICAgICAgICAgICAgLmNvbnRleHR1YWxTaHJpbmsoaXRlbXMubGVuZ3RoLCBpdGVtc0xlbmd0aENvbnRleHQpXG4gICAgICAgICAgICAubWFwKChjb250ZXh0dWFsVmFsdWUpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgaXRlbXMuc2xpY2UoaXRlbXMubGVuZ3RoIC0gY29udGV4dHVhbFZhbHVlWzBdKSxcbiAgICAgICAgICAgICAgICBjb250ZXh0dWFsVmFsdWVbMV0sXG4gICAgICAgICAgICBdO1xuICAgICAgICB9KVxuICAgICAgICAgICAgLmpvaW4oaXRlbXMubGVuZ3RoID4gdGhpcy5taW5MZW5ndGhcbiAgICAgICAgICAgID8gTGF6eUl0ZXJhYmxlSXRlcmF0b3JfMS5tYWtlTGF6eSgoKSA9PiB0aGlzLnNocmlua0ltcGwoaXRlbXMuc2xpY2UoMSksIHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICAuZmlsdGVyKChjb250ZXh0dWFsVmFsdWUpID0+IHRoaXMubWluTGVuZ3RoIDw9IGNvbnRleHR1YWxWYWx1ZVswXS5sZW5ndGggKyAxKVxuICAgICAgICAgICAgICAgIC5tYXAoKGNvbnRleHR1YWxWYWx1ZSkgPT4gW1tpdGVtc1swXV0uY29uY2F0KGNvbnRleHR1YWxWYWx1ZVswXSksIHVuZGVmaW5lZF0pKVxuICAgICAgICAgICAgOiBTdHJlYW1fMS5TdHJlYW0ubmlsKCkpO1xuICAgIH1cbiAgICB3aXRoQmlhcyhmcmVxKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1pbkxlbmd0aCAhPT0gdGhpcy5tYXhMZW5ndGhcbiAgICAgICAgICAgID8gQmlhc2VkQXJiaXRyYXJ5V3JhcHBlcl8xLmJpYXNXcmFwcGVyKGZyZXEsIHRoaXMsIChvcmlnaW5hbEFyYml0cmFyeSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgU3ViYXJyYXlBcmJpdHJhcnkob3JpZ2luYWxBcmJpdHJhcnkub3JpZ2luYWxBcnJheSwgb3JpZ2luYWxBcmJpdHJhcnkuaXNPcmRlcmVkLCBvcmlnaW5hbEFyYml0cmFyeS5taW5MZW5ndGgsIG9yaWdpbmFsQXJiaXRyYXJ5Lm1pbkxlbmd0aCArXG4gICAgICAgICAgICAgICAgICAgIE1hdGguZmxvb3IoTWF0aC5sb2cob3JpZ2luYWxBcmJpdHJhcnkubWF4TGVuZ3RoIC0gb3JpZ2luYWxBcmJpdHJhcnkubWluTGVuZ3RoKSAvIE1hdGgubG9nKDIpKSk7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgOiB0aGlzO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHN1YmFycmF5KG9yaWdpbmFsQXJyYXksIC4uLmFyZ3MpIHtcbiAgICBpZiAodHlwZW9mIGFyZ3NbMF0gPT09ICdudW1iZXInICYmIHR5cGVvZiBhcmdzWzFdID09PSAnbnVtYmVyJykge1xuICAgICAgICByZXR1cm4gbmV3IFN1YmFycmF5QXJiaXRyYXJ5KG9yaWdpbmFsQXJyYXksIHRydWUsIGFyZ3NbMF0sIGFyZ3NbMV0pO1xuICAgIH1cbiAgICBjb25zdCBjdCA9IGFyZ3NbMF07XG4gICAgY29uc3QgbWluTGVuZ3RoID0gY3QgIT09IHVuZGVmaW5lZCAmJiBjdC5taW5MZW5ndGggIT09IHVuZGVmaW5lZCA/IGN0Lm1pbkxlbmd0aCA6IDA7XG4gICAgY29uc3QgbWF4TGVuZ3RoID0gY3QgIT09IHVuZGVmaW5lZCAmJiBjdC5tYXhMZW5ndGggIT09IHVuZGVmaW5lZCA/IGN0Lm1heExlbmd0aCA6IG9yaWdpbmFsQXJyYXkubGVuZ3RoO1xuICAgIHJldHVybiBuZXcgU3ViYXJyYXlBcmJpdHJhcnkob3JpZ2luYWxBcnJheSwgdHJ1ZSwgbWluTGVuZ3RoLCBtYXhMZW5ndGgpO1xufVxuZXhwb3J0cy5zdWJhcnJheSA9IHN1YmFycmF5O1xuZnVuY3Rpb24gc2h1ZmZsZWRTdWJhcnJheShvcmlnaW5hbEFycmF5LCAuLi5hcmdzKSB7XG4gICAgaWYgKHR5cGVvZiBhcmdzWzBdID09PSAnbnVtYmVyJyAmJiB0eXBlb2YgYXJnc1sxXSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTdWJhcnJheUFyYml0cmFyeShvcmlnaW5hbEFycmF5LCBmYWxzZSwgYXJnc1swXSwgYXJnc1sxXSk7XG4gICAgfVxuICAgIGNvbnN0IGN0ID0gYXJnc1swXTtcbiAgICBjb25zdCBtaW5MZW5ndGggPSBjdCAhPT0gdW5kZWZpbmVkICYmIGN0Lm1pbkxlbmd0aCAhPT0gdW5kZWZpbmVkID8gY3QubWluTGVuZ3RoIDogMDtcbiAgICBjb25zdCBtYXhMZW5ndGggPSBjdCAhPT0gdW5kZWZpbmVkICYmIGN0Lm1heExlbmd0aCAhPT0gdW5kZWZpbmVkID8gY3QubWF4TGVuZ3RoIDogb3JpZ2luYWxBcnJheS5sZW5ndGg7XG4gICAgcmV0dXJuIG5ldyBTdWJhcnJheUFyYml0cmFyeShvcmlnaW5hbEFycmF5LCBmYWxzZSwgbWluTGVuZ3RoLCBtYXhMZW5ndGgpO1xufVxuZXhwb3J0cy5zaHVmZmxlZFN1YmFycmF5ID0gc2h1ZmZsZWRTdWJhcnJheTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy51dWlkViA9IGV4cG9ydHMudXVpZCA9IHZvaWQgMDtcbmNvbnN0IGludGVnZXJfMSA9IHJlcXVpcmUoXCIuLi8uLi9hcmJpdHJhcnkvaW50ZWdlclwiKTtcbmNvbnN0IG5hdF8xID0gcmVxdWlyZShcIi4uLy4uL2FyYml0cmFyeS9uYXRcIik7XG5jb25zdCB0dXBsZV8xID0gcmVxdWlyZShcIi4uLy4uL2FyYml0cmFyeS90dXBsZVwiKTtcbmNvbnN0IHBhZEVpZ2h0ID0gKGFyYikgPT4gYXJiLm1hcCgobikgPT4gbi50b1N0cmluZygxNikucGFkU3RhcnQoOCwgJzAnKSk7XG5mdW5jdGlvbiB1dWlkKCkge1xuICAgIGNvbnN0IHBhZGRlZCA9IHBhZEVpZ2h0KG5hdF8xLm5hdCgweGZmZmZmZmZmKSk7XG4gICAgY29uc3Qgc2Vjb25kUGFkZGVkID0gcGFkRWlnaHQoaW50ZWdlcl8xLmludGVnZXIoMHgxMDAwMDAwMCwgMHg1ZmZmZmZmZikpO1xuICAgIGNvbnN0IHRoaXJkUGFkZGVkID0gcGFkRWlnaHQoaW50ZWdlcl8xLmludGVnZXIoMHg4MDAwMDAwMCwgMHhiZmZmZmZmZikpO1xuICAgIHJldHVybiB0dXBsZV8xLnR1cGxlKHBhZGRlZCwgc2Vjb25kUGFkZGVkLCB0aGlyZFBhZGRlZCwgcGFkZGVkKS5tYXAoKHQpID0+IHtcbiAgICAgICAgcmV0dXJuIGAke3RbMF19LSR7dFsxXS5zdWJzdHJpbmcoNCl9LSR7dFsxXS5zdWJzdHJpbmcoMCwgNCl9LSR7dFsyXS5zdWJzdHJpbmcoMCwgNCl9LSR7dFsyXS5zdWJzdHJpbmcoNCl9JHt0WzNdfWA7XG4gICAgfSk7XG59XG5leHBvcnRzLnV1aWQgPSB1dWlkO1xuZnVuY3Rpb24gdXVpZFYodmVyc2lvbk51bWJlcikge1xuICAgIGNvbnN0IHBhZGRlZCA9IHBhZEVpZ2h0KG5hdF8xLm5hdCgweGZmZmZmZmZmKSk7XG4gICAgY29uc3Qgc2Vjb25kUGFkZGVkID0gcGFkRWlnaHQobmF0XzEubmF0KDB4MGZmZmZmZmYpKTtcbiAgICBjb25zdCB0aGlyZFBhZGRlZCA9IHBhZEVpZ2h0KGludGVnZXJfMS5pbnRlZ2VyKDB4ODAwMDAwMDAsIDB4YmZmZmZmZmYpKTtcbiAgICByZXR1cm4gdHVwbGVfMS50dXBsZShwYWRkZWQsIHNlY29uZFBhZGRlZCwgdGhpcmRQYWRkZWQsIHBhZGRlZCkubWFwKCh0KSA9PiB7XG4gICAgICAgIHJldHVybiBgJHt0WzBdfS0ke3RbMV0uc3Vic3RyaW5nKDQpfS0ke3ZlcnNpb25OdW1iZXJ9JHt0WzFdLnN1YnN0cmluZygxLCA0KX0tJHt0WzJdLnN1YnN0cmluZygwLCA0KX0tJHt0WzJdLnN1YnN0cmluZyg0KX0ke3RbM119YDtcbiAgICB9KTtcbn1cbmV4cG9ydHMudXVpZFYgPSB1dWlkVjtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy53ZWJVcmwgPSBleHBvcnRzLndlYkZyYWdtZW50cyA9IGV4cG9ydHMud2ViUXVlcnlQYXJhbWV0ZXJzID0gZXhwb3J0cy53ZWJTZWdtZW50ID0gZXhwb3J0cy53ZWJBdXRob3JpdHkgPSB2b2lkIDA7XG5jb25zdCBhcnJheV8xID0gcmVxdWlyZShcIi4uLy4uL2FyYml0cmFyeS9hcnJheVwiKTtcbmNvbnN0IGNvbnN0YW50RnJvbV8xID0gcmVxdWlyZShcIi4uLy4uL2FyYml0cmFyeS9jb25zdGFudEZyb21cIik7XG5jb25zdCBjb25zdGFudF8xID0gcmVxdWlyZShcIi4uLy4uL2FyYml0cmFyeS9jb25zdGFudFwiKTtcbmNvbnN0IFNwZWNpZmljQ2hhcmFjdGVyUmFuZ2VfMSA9IHJlcXVpcmUoXCIuL2hlbHBlcnMvU3BlY2lmaWNDaGFyYWN0ZXJSYW5nZVwiKTtcbmNvbnN0IEhvc3RBcmJpdHJhcnlfMSA9IHJlcXVpcmUoXCIuL0hvc3RBcmJpdHJhcnlcIik7XG5jb25zdCBuYXRfMSA9IHJlcXVpcmUoXCIuLi8uLi9hcmJpdHJhcnkvbmF0XCIpO1xuY29uc3QgaXBWNF8xID0gcmVxdWlyZShcIi4uLy4uL2FyYml0cmFyeS9pcFY0XCIpO1xuY29uc3QgaXBWNEV4dGVuZGVkXzEgPSByZXF1aXJlKFwiLi4vLi4vYXJiaXRyYXJ5L2lwVjRFeHRlbmRlZFwiKTtcbmNvbnN0IGlwVjZfMSA9IHJlcXVpcmUoXCIuLi8uLi9hcmJpdHJhcnkvaXBWNlwiKTtcbmNvbnN0IG9uZW9mXzEgPSByZXF1aXJlKFwiLi4vLi4vYXJiaXRyYXJ5L29uZW9mXCIpO1xuY29uc3Qgb3B0aW9uXzEgPSByZXF1aXJlKFwiLi4vLi4vYXJiaXRyYXJ5L29wdGlvblwiKTtcbmNvbnN0IHN0cmluZ09mXzEgPSByZXF1aXJlKFwiLi4vLi4vYXJiaXRyYXJ5L3N0cmluZ09mXCIpO1xuY29uc3QgdHVwbGVfMSA9IHJlcXVpcmUoXCIuLi8uLi9hcmJpdHJhcnkvdHVwbGVcIik7XG5mdW5jdGlvbiB3ZWJBdXRob3JpdHkoY29uc3RyYWludHMpIHtcbiAgICBjb25zdCBjID0gY29uc3RyYWludHMgfHwge307XG4gICAgY29uc3QgaG9zdG5hbWVBcmJzID0gW0hvc3RBcmJpdHJhcnlfMS5kb21haW4oKV1cbiAgICAgICAgLmNvbmNhdChjLndpdGhJUHY0ID09PSB0cnVlID8gW2lwVjRfMS5pcFY0KCldIDogW10pXG4gICAgICAgIC5jb25jYXQoYy53aXRoSVB2NiA9PT0gdHJ1ZSA/IFtpcFY2XzEuaXBWNigpLm1hcCgoaXApID0+IGBbJHtpcH1dYCldIDogW10pXG4gICAgICAgIC5jb25jYXQoYy53aXRoSVB2NEV4dGVuZGVkID09PSB0cnVlID8gW2lwVjRFeHRlbmRlZF8xLmlwVjRFeHRlbmRlZCgpXSA6IFtdKTtcbiAgICByZXR1cm4gdHVwbGVfMS50dXBsZShjLndpdGhVc2VySW5mbyA9PT0gdHJ1ZSA/IG9wdGlvbl8xLm9wdGlvbihIb3N0QXJiaXRyYXJ5XzEuaG9zdFVzZXJJbmZvKCkpIDogY29uc3RhbnRfMS5jb25zdGFudChudWxsKSwgb25lb2ZfMS5vbmVvZiguLi5ob3N0bmFtZUFyYnMpLCBjLndpdGhQb3J0ID09PSB0cnVlID8gb3B0aW9uXzEub3B0aW9uKG5hdF8xLm5hdCg2NTUzNSkpIDogY29uc3RhbnRfMS5jb25zdGFudChudWxsKSkubWFwKChbdSwgaCwgcF0pID0+ICh1ID09PSBudWxsID8gJycgOiBgJHt1fUBgKSArIGggKyAocCA9PT0gbnVsbCA/ICcnIDogYDoke3B9YCkpO1xufVxuZXhwb3J0cy53ZWJBdXRob3JpdHkgPSB3ZWJBdXRob3JpdHk7XG5mdW5jdGlvbiB3ZWJTZWdtZW50KCkge1xuICAgIGNvbnN0IG90aGVycyA9IFsnLScsICcuJywgJ18nLCAnficsICchJywgJyQnLCAnJicsIFwiJ1wiLCAnKCcsICcpJywgJyonLCAnKycsICcsJywgJzsnLCAnPScsICc6JywgJ0AnXTtcbiAgICByZXR1cm4gc3RyaW5nT2ZfMS5zdHJpbmdPZihTcGVjaWZpY0NoYXJhY3RlclJhbmdlXzEuYnVpbGRBbHBoYU51bWVyaWNQZXJjZW50QXJiKG90aGVycykpO1xufVxuZXhwb3J0cy53ZWJTZWdtZW50ID0gd2ViU2VnbWVudDtcbmZ1bmN0aW9uIHVyaVF1ZXJ5T3JGcmFnbWVudCgpIHtcbiAgICBjb25zdCBvdGhlcnMgPSBbJy0nLCAnLicsICdfJywgJ34nLCAnIScsICckJywgJyYnLCBcIidcIiwgJygnLCAnKScsICcqJywgJysnLCAnLCcsICc7JywgJz0nLCAnOicsICdAJywgJy8nLCAnPyddO1xuICAgIHJldHVybiBzdHJpbmdPZl8xLnN0cmluZ09mKFNwZWNpZmljQ2hhcmFjdGVyUmFuZ2VfMS5idWlsZEFscGhhTnVtZXJpY1BlcmNlbnRBcmIob3RoZXJzKSk7XG59XG5mdW5jdGlvbiB3ZWJRdWVyeVBhcmFtZXRlcnMoKSB7XG4gICAgcmV0dXJuIHVyaVF1ZXJ5T3JGcmFnbWVudCgpO1xufVxuZXhwb3J0cy53ZWJRdWVyeVBhcmFtZXRlcnMgPSB3ZWJRdWVyeVBhcmFtZXRlcnM7XG5mdW5jdGlvbiB3ZWJGcmFnbWVudHMoKSB7XG4gICAgcmV0dXJuIHVyaVF1ZXJ5T3JGcmFnbWVudCgpO1xufVxuZXhwb3J0cy53ZWJGcmFnbWVudHMgPSB3ZWJGcmFnbWVudHM7XG5mdW5jdGlvbiB3ZWJVcmwoY29uc3RyYWludHMpIHtcbiAgICBjb25zdCBjID0gY29uc3RyYWludHMgfHwge307XG4gICAgY29uc3QgdmFsaWRTY2hlbWVzID0gYy52YWxpZFNjaGVtZXMgfHwgWydodHRwJywgJ2h0dHBzJ107XG4gICAgY29uc3Qgc2NoZW1lQXJiID0gY29uc3RhbnRGcm9tXzEuY29uc3RhbnRGcm9tKC4uLnZhbGlkU2NoZW1lcyk7XG4gICAgY29uc3QgYXV0aG9yaXR5QXJiID0gd2ViQXV0aG9yaXR5KGMuYXV0aG9yaXR5U2V0dGluZ3MpO1xuICAgIGNvbnN0IHBhdGhBcmIgPSBhcnJheV8xLmFycmF5KHdlYlNlZ21lbnQoKSkubWFwKChwKSA9PiBwLm1hcCgodikgPT4gYC8ke3Z9YCkuam9pbignJykpO1xuICAgIHJldHVybiB0dXBsZV8xLnR1cGxlKHNjaGVtZUFyYiwgYXV0aG9yaXR5QXJiLCBwYXRoQXJiLCBjLndpdGhRdWVyeVBhcmFtZXRlcnMgPT09IHRydWUgPyBvcHRpb25fMS5vcHRpb24od2ViUXVlcnlQYXJhbWV0ZXJzKCkpIDogY29uc3RhbnRfMS5jb25zdGFudChudWxsKSwgYy53aXRoRnJhZ21lbnRzID09PSB0cnVlID8gb3B0aW9uXzEub3B0aW9uKHdlYkZyYWdtZW50cygpKSA6IGNvbnN0YW50XzEuY29uc3RhbnQobnVsbCkpLm1hcCgoW3MsIGEsIHAsIHEsIGZdKSA9PiBgJHtzfTovLyR7YX0ke3B9JHtxID09PSBudWxsID8gJycgOiBgPyR7cX1gfSR7ZiA9PT0gbnVsbCA/ICcnIDogYCMke2Z9YH1gKTtcbn1cbmV4cG9ydHMud2ViVXJsID0gd2ViVXJsO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmFzc2VydElzQXJiaXRyYXJ5ID0gZXhwb3J0cy5BcmJpdHJhcnkgPSB2b2lkIDA7XG5jb25zdCBTaHJpbmthYmxlXzEgPSByZXF1aXJlKFwiLi9TaHJpbmthYmxlXCIpO1xuY2xhc3MgQXJiaXRyYXJ5IHtcbiAgICBmaWx0ZXIocmVmaW5lbWVudCkge1xuICAgICAgICByZXR1cm4gbmV3IEZpbHRlckFyYml0cmFyeSh0aGlzLCByZWZpbmVtZW50KTtcbiAgICB9XG4gICAgbWFwKG1hcHBlcikge1xuICAgICAgICByZXR1cm4gbmV3IE1hcEFyYml0cmFyeSh0aGlzLCBtYXBwZXIpO1xuICAgIH1cbiAgICBjaGFpbihmbWFwcGVyKSB7XG4gICAgICAgIHJldHVybiBuZXcgQ2hhaW5BcmJpdHJhcnkodGhpcywgZm1hcHBlcik7XG4gICAgfVxuICAgIG5vU2hyaW5rKCkge1xuICAgICAgICByZXR1cm4gbmV3IE5vU2hyaW5rQXJiaXRyYXJ5KHRoaXMpO1xuICAgIH1cbiAgICB3aXRoQmlhcyhfZnJlcSkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgbm9CaWFzKCkge1xuICAgICAgICByZXR1cm4gbmV3IE5vQmlhc0FyYml0cmFyeSh0aGlzKTtcbiAgICB9XG59XG5leHBvcnRzLkFyYml0cmFyeSA9IEFyYml0cmFyeTtcbmNsYXNzIENoYWluQXJiaXRyYXJ5IGV4dGVuZHMgQXJiaXRyYXJ5IHtcbiAgICBjb25zdHJ1Y3RvcihhcmIsIGZtYXBwZXIpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5hcmIgPSBhcmI7XG4gICAgICAgIHRoaXMuZm1hcHBlciA9IGZtYXBwZXI7XG4gICAgfVxuICAgIGdlbmVyYXRlKG1ybmcpIHtcbiAgICAgICAgY29uc3QgY2xvbmVkTXJuZyA9IG1ybmcuY2xvbmUoKTtcbiAgICAgICAgY29uc3Qgc3JjID0gdGhpcy5hcmIuZ2VuZXJhdGUobXJuZyk7XG4gICAgICAgIGNvbnN0IGRzdCA9IHRoaXMuZm1hcHBlcihzcmMudmFsdWUpLmdlbmVyYXRlKG1ybmcpO1xuICAgICAgICByZXR1cm4gQ2hhaW5BcmJpdHJhcnkuc2hyaW5rQ2hhaW4oY2xvbmVkTXJuZywgc3JjLCBkc3QsIHRoaXMuZm1hcHBlcik7XG4gICAgfVxuICAgIHdpdGhCaWFzKGZyZXEpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXJiLndpdGhCaWFzKGZyZXEpLmNoYWluKCh0KSA9PiB0aGlzLmZtYXBwZXIodCkud2l0aEJpYXMoZnJlcSkpO1xuICAgIH1cbiAgICBzdGF0aWMgc2hyaW5rQ2hhaW4obXJuZywgc3JjLCBkc3QsIGZtYXBwZXIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTaHJpbmthYmxlXzEuU2hyaW5rYWJsZShkc3QudmFsdWUsICgpID0+IHNyY1xuICAgICAgICAgICAgLnNocmluaygpXG4gICAgICAgICAgICAubWFwKCh2KSA9PiBDaGFpbkFyYml0cmFyeS5zaHJpbmtDaGFpbihtcm5nLmNsb25lKCksIHYsIGZtYXBwZXIodi52YWx1ZSkuZ2VuZXJhdGUobXJuZy5jbG9uZSgpKSwgZm1hcHBlcikpXG4gICAgICAgICAgICAuam9pbihkc3Quc2hyaW5rKCkpKTtcbiAgICB9XG59XG5jbGFzcyBNYXBBcmJpdHJhcnkgZXh0ZW5kcyBBcmJpdHJhcnkge1xuICAgIGNvbnN0cnVjdG9yKGFyYiwgbWFwcGVyKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuYXJiID0gYXJiO1xuICAgICAgICB0aGlzLm1hcHBlciA9IG1hcHBlcjtcbiAgICB9XG4gICAgZ2VuZXJhdGUobXJuZykge1xuICAgICAgICByZXR1cm4gdGhpcy5hcmIuZ2VuZXJhdGUobXJuZykubWFwKHRoaXMubWFwcGVyKTtcbiAgICB9XG4gICAgd2l0aEJpYXMoZnJlcSkge1xuICAgICAgICByZXR1cm4gdGhpcy5hcmIud2l0aEJpYXMoZnJlcSkubWFwKHRoaXMubWFwcGVyKTtcbiAgICB9XG59XG5jbGFzcyBGaWx0ZXJBcmJpdHJhcnkgZXh0ZW5kcyBBcmJpdHJhcnkge1xuICAgIGNvbnN0cnVjdG9yKGFyYiwgcmVmaW5lbWVudCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmFyYiA9IGFyYjtcbiAgICAgICAgdGhpcy5yZWZpbmVtZW50ID0gcmVmaW5lbWVudDtcbiAgICB9XG4gICAgZ2VuZXJhdGUobXJuZykge1xuICAgICAgICBsZXQgZyA9IHRoaXMuYXJiLmdlbmVyYXRlKG1ybmcpO1xuICAgICAgICB3aGlsZSAoIXRoaXMucmVmaW5lbWVudE9uU2hyaW5rYWJsZShnKSkge1xuICAgICAgICAgICAgZyA9IHRoaXMuYXJiLmdlbmVyYXRlKG1ybmcpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBnLmZpbHRlcih0aGlzLnJlZmluZW1lbnQpO1xuICAgIH1cbiAgICB3aXRoQmlhcyhmcmVxKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFyYi53aXRoQmlhcyhmcmVxKS5maWx0ZXIodGhpcy5yZWZpbmVtZW50KTtcbiAgICB9XG4gICAgcmVmaW5lbWVudE9uU2hyaW5rYWJsZShzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlZmluZW1lbnQocy52YWx1ZSk7XG4gICAgfVxufVxuY2xhc3MgTm9TaHJpbmtBcmJpdHJhcnkgZXh0ZW5kcyBBcmJpdHJhcnkge1xuICAgIGNvbnN0cnVjdG9yKGFyYikge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmFyYiA9IGFyYjtcbiAgICB9XG4gICAgZ2VuZXJhdGUobXJuZykge1xuICAgICAgICByZXR1cm4gbmV3IFNocmlua2FibGVfMS5TaHJpbmthYmxlKHRoaXMuYXJiLmdlbmVyYXRlKG1ybmcpLnZhbHVlKTtcbiAgICB9XG4gICAgd2l0aEJpYXMoZnJlcSkge1xuICAgICAgICByZXR1cm4gdGhpcy5hcmIud2l0aEJpYXMoZnJlcSkubm9TaHJpbmsoKTtcbiAgICB9XG59XG5jbGFzcyBOb0JpYXNBcmJpdHJhcnkgZXh0ZW5kcyBBcmJpdHJhcnkge1xuICAgIGNvbnN0cnVjdG9yKGFyYikge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmFyYiA9IGFyYjtcbiAgICB9XG4gICAgZ2VuZXJhdGUobXJuZykge1xuICAgICAgICByZXR1cm4gdGhpcy5hcmIuZ2VuZXJhdGUobXJuZyk7XG4gICAgfVxufVxuZnVuY3Rpb24gYXNzZXJ0SXNBcmJpdHJhcnkoaW5zdGFuY2UpIHtcbiAgICBpZiAodHlwZW9mIGluc3RhbmNlICE9PSAnb2JqZWN0JyB8fCBpbnN0YW5jZSA9PT0gbnVsbCB8fCAhKCdnZW5lcmF0ZScgaW4gaW5zdGFuY2UpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVW5leHBlY3RlZCB2YWx1ZSByZWNlaXZlZDogbm90IGFuIGluc3RhbmNlIG9mIEFyYml0cmFyeScpO1xuICAgIH1cbn1cbmV4cG9ydHMuYXNzZXJ0SXNBcmJpdHJhcnkgPSBhc3NlcnRJc0FyYml0cmFyeTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5BcmJpdHJhcnlXaXRoQ29udGV4dHVhbFNocmluayA9IHZvaWQgMDtcbmNvbnN0IEFyYml0cmFyeV8xID0gcmVxdWlyZShcIi4vQXJiaXRyYXJ5XCIpO1xuY29uc3QgU2hyaW5rYWJsZV8xID0gcmVxdWlyZShcIi4vU2hyaW5rYWJsZVwiKTtcbmZ1bmN0aW9uIHJlbW92ZUNvbnRleHRGcm9tQ29udGV4dHVhbFZhbHVlKGNvbnRleHR1YWxWYWx1ZSkge1xuICAgIHJldHVybiBjb250ZXh0dWFsVmFsdWVbMF07XG59XG5jbGFzcyBBcmJpdHJhcnlXaXRoQ29udGV4dHVhbFNocmluayBleHRlbmRzIEFyYml0cmFyeV8xLkFyYml0cmFyeSB7XG4gICAgY29udGV4dHVhbFNocmlua2FibGVGb3IodmFsdWUsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTaHJpbmthYmxlXzEuU2hyaW5rYWJsZSh2YWx1ZSwgKCkgPT4gdGhpcy5jb250ZXh0dWFsU2hyaW5rKHZhbHVlLCBjb250ZXh0KS5tYXAoKGNvbnRleHR1YWxWYWx1ZSkgPT4gdGhpcy5jb250ZXh0dWFsU2hyaW5rYWJsZUZvcihjb250ZXh0dWFsVmFsdWVbMF0sIGNvbnRleHR1YWxWYWx1ZVsxXSkpKTtcbiAgICB9XG4gICAgc2hyaW5rKHZhbHVlLCBzaHJ1bmtPbmNlKSB7XG4gICAgICAgIGNvbnN0IGNvbnRleHQgPSBzaHJ1bmtPbmNlID09PSB0cnVlID8gdGhpcy5zaHJ1bmtPbmNlQ29udGV4dCgpIDogdW5kZWZpbmVkO1xuICAgICAgICByZXR1cm4gdGhpcy5jb250ZXh0dWFsU2hyaW5rKHZhbHVlLCBjb250ZXh0KS5tYXAocmVtb3ZlQ29udGV4dEZyb21Db250ZXh0dWFsVmFsdWUpO1xuICAgIH1cbiAgICBzaHJpbmthYmxlRm9yKHZhbHVlLCBzaHJ1bmtPbmNlKSB7XG4gICAgICAgIHJldHVybiBuZXcgU2hyaW5rYWJsZV8xLlNocmlua2FibGUodmFsdWUsICgpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNocmluayh2YWx1ZSwgc2hydW5rT25jZSkubWFwKCh2YWx1ZSkgPT4gdGhpcy5zaHJpbmthYmxlRm9yKHZhbHVlLCB0cnVlKSk7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmV4cG9ydHMuQXJiaXRyYXJ5V2l0aENvbnRleHR1YWxTaHJpbmsgPSBBcmJpdHJhcnlXaXRoQ29udGV4dHVhbFNocmluaztcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5BcmJpdHJhcnlXaXRoU2hyaW5rID0gdm9pZCAwO1xuY29uc3QgQXJiaXRyYXJ5XzEgPSByZXF1aXJlKFwiLi9BcmJpdHJhcnlcIik7XG5jb25zdCBTaHJpbmthYmxlXzEgPSByZXF1aXJlKFwiLi9TaHJpbmthYmxlXCIpO1xuY2xhc3MgQXJiaXRyYXJ5V2l0aFNocmluayBleHRlbmRzIEFyYml0cmFyeV8xLkFyYml0cmFyeSB7XG4gICAgc2hyaW5rYWJsZUZvcih2YWx1ZSwgc2hydW5rT25jZSkge1xuICAgICAgICByZXR1cm4gbmV3IFNocmlua2FibGVfMS5TaHJpbmthYmxlKHZhbHVlLCAoKSA9PiB0aGlzLnNocmluayh2YWx1ZSwgc2hydW5rT25jZSA9PT0gdHJ1ZSkubWFwKCh2KSA9PiB0aGlzLnNocmlua2FibGVGb3IodiwgdHJ1ZSkpKTtcbiAgICB9XG59XG5leHBvcnRzLkFyYml0cmFyeVdpdGhTaHJpbmsgPSBBcmJpdHJhcnlXaXRoU2hyaW5rO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmJpYXNXcmFwcGVyID0gdm9pZCAwO1xuY29uc3QgQXJiaXRyYXJ5XzEgPSByZXF1aXJlKFwiLi9BcmJpdHJhcnlcIik7XG5jbGFzcyBCaWFzZWRBcmJpdHJhcnlXcmFwcGVyIGV4dGVuZHMgQXJiaXRyYXJ5XzEuQXJiaXRyYXJ5IHtcbiAgICBjb25zdHJ1Y3RvcihmcmVxLCBhcmIsIGJpYXNlZEFyYkJ1aWxkZXIpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5mcmVxID0gZnJlcTtcbiAgICAgICAgdGhpcy5hcmIgPSBhcmI7XG4gICAgICAgIHRoaXMuYmlhc2VkQXJiQnVpbGRlciA9IGJpYXNlZEFyYkJ1aWxkZXI7XG4gICAgfVxuICAgIGdlbmVyYXRlKG1ybmcpIHtcbiAgICAgICAgcmV0dXJuIG1ybmcubmV4dEludCgxLCB0aGlzLmZyZXEpID09PSAxID8gdGhpcy5iaWFzZWRBcmJCdWlsZGVyKHRoaXMuYXJiKS5nZW5lcmF0ZShtcm5nKSA6IHRoaXMuYXJiLmdlbmVyYXRlKG1ybmcpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGJpYXNXcmFwcGVyKGZyZXEsIGFyYiwgYmlhc2VkQXJiQnVpbGRlcikge1xuICAgIHJldHVybiBuZXcgQmlhc2VkQXJiaXRyYXJ5V3JhcHBlcihmcmVxLCBhcmIsIGJpYXNlZEFyYkJ1aWxkZXIpO1xufVxuZXhwb3J0cy5iaWFzV3JhcHBlciA9IGJpYXNXcmFwcGVyO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX2E7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkNvbnZlcnRlckZyb21OZXh0ID0gdm9pZCAwO1xuY29uc3QgQXJiaXRyYXJ5V2l0aENvbnRleHR1YWxTaHJpbmtfMSA9IHJlcXVpcmUoXCIuL0FyYml0cmFyeVdpdGhDb250ZXh0dWFsU2hyaW5rXCIpO1xuY29uc3QgQ29udmVydGVyVG9OZXh0XzEgPSByZXF1aXJlKFwiLi9Db252ZXJ0ZXJUb05leHRcIik7XG5jb25zdCBTaHJpbmthYmxlXzEgPSByZXF1aXJlKFwiLi9TaHJpbmthYmxlXCIpO1xuY29uc3QgaWRlbnRpZmllciA9ICdfX0NvbnZlcnRlckZyb21OZXh0X18nO1xuZnVuY3Rpb24gZnJvbU5leHRWYWx1ZVRvU2hyaW5rYWJsZUZvcihhcmIpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gZnJvbU5leHRWYWx1ZVRvU2hyaW5rYWJsZSh2KSB7XG4gICAgICAgIGNvbnN0IHZhbHVlXyA9IHYudmFsdWVfO1xuICAgICAgICBjb25zdCBzaHJpbmtlciA9ICgpID0+IGFyYi5zaHJpbmsodmFsdWVfLCB2LmNvbnRleHQpLm1hcChmcm9tTmV4dFZhbHVlVG9TaHJpbmthYmxlKTtcbiAgICAgICAgaWYgKCF2Lmhhc1RvQmVDbG9uZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgU2hyaW5rYWJsZV8xLlNocmlua2FibGUodmFsdWVfLCBzaHJpbmtlcik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBTaHJpbmthYmxlXzEuU2hyaW5rYWJsZSh2YWx1ZV8sIHNocmlua2VyLCAoKSA9PiB2LnZhbHVlKTtcbiAgICB9O1xufVxuY2xhc3MgQ29udmVydGVyRnJvbU5leHQgZXh0ZW5kcyBBcmJpdHJhcnlXaXRoQ29udGV4dHVhbFNocmlua18xLkFyYml0cmFyeVdpdGhDb250ZXh0dWFsU2hyaW5rIHtcbiAgICBjb25zdHJ1Y3RvcihhcmIsIGxlZ2FjeVNocnVua09uY2VDb250ZXh0LCBiaWFzRmFjdG9yID0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuYXJiID0gYXJiO1xuICAgICAgICB0aGlzLmxlZ2FjeVNocnVua09uY2VDb250ZXh0ID0gbGVnYWN5U2hydW5rT25jZUNvbnRleHQ7XG4gICAgICAgIHRoaXMuYmlhc0ZhY3RvciA9IGJpYXNGYWN0b3I7XG4gICAgICAgIHRoaXNbX2FdID0gdHJ1ZTtcbiAgICAgICAgdGhpcy50b1Nocmlua2FibGUgPSBmcm9tTmV4dFZhbHVlVG9TaHJpbmthYmxlRm9yKGFyYik7XG4gICAgfVxuICAgIHN0YXRpYyBpc0NvbnZlcnRlckZyb21OZXh0KGFyYikge1xuICAgICAgICByZXR1cm4gaWRlbnRpZmllciBpbiBhcmI7XG4gICAgfVxuICAgIHN0YXRpYyBjb252ZXJ0SWZOZWVkZWQoYXJiKSB7XG4gICAgICAgIGlmIChDb252ZXJ0ZXJUb05leHRfMS5Db252ZXJ0ZXJUb05leHQuaXNDb252ZXJ0ZXJUb05leHQoYXJiKSlcbiAgICAgICAgICAgIHJldHVybiBhcmIuYXJiO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICByZXR1cm4gbmV3IENvbnZlcnRlckZyb21OZXh0KGFyYik7XG4gICAgfVxuICAgIGdlbmVyYXRlKG1ybmcpIHtcbiAgICAgICAgY29uc3QgZyA9IHRoaXMuYXJiLmdlbmVyYXRlKG1ybmcsIHRoaXMuYmlhc0ZhY3Rvcik7XG4gICAgICAgIHJldHVybiB0aGlzLnRvU2hyaW5rYWJsZShnKTtcbiAgICB9XG4gICAgY29udGV4dHVhbFNocmluayh2YWx1ZSwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gdGhpcy5hcmIuc2hyaW5rKHZhbHVlLCBjb250ZXh0KS5tYXAoKHYpID0+IFt2LnZhbHVlXywgdi5jb250ZXh0XSk7XG4gICAgfVxuICAgIHNocnVua09uY2VDb250ZXh0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5sZWdhY3lTaHJ1bmtPbmNlQ29udGV4dDtcbiAgICB9XG4gICAgZmlsdGVyKHJlZmluZW1lbnQpIHtcbiAgICAgICAgcmV0dXJuIENvbnZlcnRlckZyb21OZXh0LmNvbnZlcnRJZk5lZWRlZCh0aGlzLmFyYi5maWx0ZXIocmVmaW5lbWVudCkpO1xuICAgIH1cbiAgICBtYXAobWFwcGVyKSB7XG4gICAgICAgIHJldHVybiBDb252ZXJ0ZXJGcm9tTmV4dC5jb252ZXJ0SWZOZWVkZWQodGhpcy5hcmIubWFwKG1hcHBlcikpO1xuICAgIH1cbiAgICBjaGFpbihmbWFwcGVyKSB7XG4gICAgICAgIHJldHVybiBDb252ZXJ0ZXJGcm9tTmV4dC5jb252ZXJ0SWZOZWVkZWQodGhpcy5hcmIuY2hhaW4oKHQpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGZtYXBwZWQgPSBmbWFwcGVyKHQpO1xuICAgICAgICAgICAgaWYgKENvbnZlcnRlckZyb21OZXh0LmlzQ29udmVydGVyRnJvbU5leHQoZm1hcHBlZCkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZtYXBwZWQuYXJiO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQ29udmVydGVyVG9OZXh0XzEuQ29udmVydGVyVG9OZXh0KGZtYXBwZWQpO1xuICAgICAgICB9KSk7XG4gICAgfVxuICAgIG5vU2hyaW5rKCkge1xuICAgICAgICByZXR1cm4gQ29udmVydGVyRnJvbU5leHQuY29udmVydElmTmVlZGVkKHRoaXMuYXJiLm5vU2hyaW5rKCkpO1xuICAgIH1cbiAgICB3aXRoQmlhcyhmcmVxKSB7XG4gICAgICAgIHJldHVybiBuZXcgQ29udmVydGVyRnJvbU5leHQodGhpcy5hcmIsIHRoaXMubGVnYWN5U2hydW5rT25jZUNvbnRleHQsIGZyZXEpO1xuICAgIH1cbiAgICBub0JpYXMoKSB7XG4gICAgICAgIHJldHVybiBDb252ZXJ0ZXJGcm9tTmV4dC5jb252ZXJ0SWZOZWVkZWQodGhpcy5hcmIubm9CaWFzKCkpO1xuICAgIH1cbn1cbmV4cG9ydHMuQ29udmVydGVyRnJvbU5leHQgPSBDb252ZXJ0ZXJGcm9tTmV4dDtcbl9hID0gaWRlbnRpZmllcjtcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9hO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Db252ZXJ0ZXJUb05leHQgPSB2b2lkIDA7XG5jb25zdCBTdHJlYW1fMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi9zdHJlYW0vU3RyZWFtXCIpO1xuY29uc3QgQ29udmVydGVyRnJvbU5leHRfMSA9IHJlcXVpcmUoXCIuL0NvbnZlcnRlckZyb21OZXh0XCIpO1xuY29uc3QgTmV4dEFyYml0cmFyeV8xID0gcmVxdWlyZShcIi4vTmV4dEFyYml0cmFyeVwiKTtcbmNvbnN0IE5leHRWYWx1ZV8xID0gcmVxdWlyZShcIi4vTmV4dFZhbHVlXCIpO1xuY29uc3QgaWRlbnRpZmllciA9ICdfX0NvbnZlcnRlclRvTmV4dF9fJztcbmZ1bmN0aW9uIGZyb21TaHJpbmthYmxlVG9OZXh0VmFsdWUoZykge1xuICAgIGlmICghZy5oYXNUb0JlQ2xvbmVkKSB7XG4gICAgICAgIHJldHVybiBuZXcgTmV4dFZhbHVlXzEuTmV4dFZhbHVlKGcudmFsdWVfLCBnKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBOZXh0VmFsdWVfMS5OZXh0VmFsdWUoZy52YWx1ZV8sIGcsICgpID0+IGcudmFsdWUpO1xufVxuY2xhc3MgQ29udmVydGVyVG9OZXh0IGV4dGVuZHMgTmV4dEFyYml0cmFyeV8xLk5leHRBcmJpdHJhcnkge1xuICAgIGNvbnN0cnVjdG9yKGFyYikge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmFyYiA9IGFyYjtcbiAgICAgICAgdGhpc1tfYV0gPSB0cnVlO1xuICAgIH1cbiAgICBzdGF0aWMgaXNDb252ZXJ0ZXJUb05leHQoYXJiKSB7XG4gICAgICAgIHJldHVybiBpZGVudGlmaWVyIGluIGFyYjtcbiAgICB9XG4gICAgc3RhdGljIGNvbnZlcnRJZk5lZWRlZChhcmIpIHtcbiAgICAgICAgaWYgKENvbnZlcnRlckZyb21OZXh0XzEuQ29udmVydGVyRnJvbU5leHQuaXNDb252ZXJ0ZXJGcm9tTmV4dChhcmIpKVxuICAgICAgICAgICAgcmV0dXJuIGFyYi5hcmI7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHJldHVybiBuZXcgQ29udmVydGVyVG9OZXh0KGFyYik7XG4gICAgfVxuICAgIGdlbmVyYXRlKG1ybmcsIGJpYXNGYWN0b3IpIHtcbiAgICAgICAgY29uc3QgZyA9IGJpYXNGYWN0b3IgIT09IHVuZGVmaW5lZCA/IHRoaXMuYXJiLndpdGhCaWFzKGJpYXNGYWN0b3IpLmdlbmVyYXRlKG1ybmcpIDogdGhpcy5hcmIuZ2VuZXJhdGUobXJuZyk7XG4gICAgICAgIHJldHVybiBmcm9tU2hyaW5rYWJsZVRvTmV4dFZhbHVlKGcpO1xuICAgIH1cbiAgICBjYW5TaHJpbmtXaXRob3V0Q29udGV4dChfdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBzaHJpbmsoX3ZhbHVlLCBjb250ZXh0KSB7XG4gICAgICAgIGlmICh0aGlzLmlzU2FmZUNvbnRleHQoY29udGV4dCkpIHtcbiAgICAgICAgICAgIHJldHVybiBjb250ZXh0LnNocmluaygpLm1hcChmcm9tU2hyaW5rYWJsZVRvTmV4dFZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gU3RyZWFtXzEuU3RyZWFtLm5pbCgpO1xuICAgIH1cbiAgICBpc1NhZmVDb250ZXh0KGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIChjb250ZXh0ICE9IG51bGwgJiYgdHlwZW9mIGNvbnRleHQgPT09ICdvYmplY3QnICYmICd2YWx1ZScgaW4gY29udGV4dCAmJiAnc2hyaW5rJyBpbiBjb250ZXh0KTtcbiAgICB9XG4gICAgZmlsdGVyKHJlZmluZW1lbnQpIHtcbiAgICAgICAgcmV0dXJuIENvbnZlcnRlclRvTmV4dC5jb252ZXJ0SWZOZWVkZWQodGhpcy5hcmIuZmlsdGVyKHJlZmluZW1lbnQpKTtcbiAgICB9XG4gICAgbWFwKG1hcHBlcikge1xuICAgICAgICByZXR1cm4gQ29udmVydGVyVG9OZXh0LmNvbnZlcnRJZk5lZWRlZCh0aGlzLmFyYi5tYXAobWFwcGVyKSk7XG4gICAgfVxuICAgIGNoYWluKGZtYXBwZXIpIHtcbiAgICAgICAgcmV0dXJuIENvbnZlcnRlclRvTmV4dC5jb252ZXJ0SWZOZWVkZWQodGhpcy5hcmIuY2hhaW4oKHQpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGZtYXBwZWQgPSBmbWFwcGVyKHQpO1xuICAgICAgICAgICAgaWYgKENvbnZlcnRlclRvTmV4dC5pc0NvbnZlcnRlclRvTmV4dChmbWFwcGVkKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZm1hcHBlZC5hcmI7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBDb252ZXJ0ZXJGcm9tTmV4dF8xLkNvbnZlcnRlckZyb21OZXh0KGZtYXBwZWQpO1xuICAgICAgICB9KSk7XG4gICAgfVxuICAgIG5vU2hyaW5rKCkge1xuICAgICAgICByZXR1cm4gQ29udmVydGVyVG9OZXh0LmNvbnZlcnRJZk5lZWRlZCh0aGlzLmFyYi5ub1NocmluaygpKTtcbiAgICB9XG4gICAgbm9CaWFzKCkge1xuICAgICAgICByZXR1cm4gQ29udmVydGVyVG9OZXh0LmNvbnZlcnRJZk5lZWRlZCh0aGlzLmFyYi5ub0JpYXMoKSk7XG4gICAgfVxufVxuZXhwb3J0cy5Db252ZXJ0ZXJUb05leHQgPSBDb252ZXJ0ZXJUb05leHQ7XG5fYSA9IGlkZW50aWZpZXI7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuY29udmVydFRvTmV4dCA9IGV4cG9ydHMuY29udmVydEZyb21OZXh0V2l0aFNocnVua09uY2UgPSBleHBvcnRzLmNvbnZlcnRGcm9tTmV4dCA9IHZvaWQgMDtcbmNvbnN0IEFyYml0cmFyeV8xID0gcmVxdWlyZShcIi4vQXJiaXRyYXJ5XCIpO1xuY29uc3QgQ29udmVydGVyRnJvbU5leHRfMSA9IHJlcXVpcmUoXCIuL0NvbnZlcnRlckZyb21OZXh0XCIpO1xuY29uc3QgQ29udmVydGVyVG9OZXh0XzEgPSByZXF1aXJlKFwiLi9Db252ZXJ0ZXJUb05leHRcIik7XG5jb25zdCBOZXh0QXJiaXRyYXJ5XzEgPSByZXF1aXJlKFwiLi9OZXh0QXJiaXRyYXJ5XCIpO1xuZnVuY3Rpb24gY29udmVydEZyb21OZXh0KGFyYikge1xuICAgIGlmIChDb252ZXJ0ZXJUb05leHRfMS5Db252ZXJ0ZXJUb05leHQuaXNDb252ZXJ0ZXJUb05leHQoYXJiKSkge1xuICAgICAgICByZXR1cm4gYXJiLmFyYjtcbiAgICB9XG4gICAgTmV4dEFyYml0cmFyeV8xLmFzc2VydElzTmV4dEFyYml0cmFyeShhcmIpO1xuICAgIHJldHVybiBuZXcgQ29udmVydGVyRnJvbU5leHRfMS5Db252ZXJ0ZXJGcm9tTmV4dChhcmIpO1xufVxuZXhwb3J0cy5jb252ZXJ0RnJvbU5leHQgPSBjb252ZXJ0RnJvbU5leHQ7XG5mdW5jdGlvbiBjb252ZXJ0RnJvbU5leHRXaXRoU2hydW5rT25jZShhcmIsIGxlZ2FjeVNocnVua09uY2VDb250ZXh0KSB7XG4gICAgaWYgKENvbnZlcnRlclRvTmV4dF8xLkNvbnZlcnRlclRvTmV4dC5pc0NvbnZlcnRlclRvTmV4dChhcmIpKSB7XG4gICAgICAgIGlmICghKCdjb250ZXh0dWFsU2hyaW5rJyBpbiBhcmIuYXJiKSB8fFxuICAgICAgICAgICAgISgnY29udGV4dHVhbFNocmlua2FibGVGb3InIGluIGFyYi5hcmIpIHx8XG4gICAgICAgICAgICAhKCdzaHJ1bmtPbmNlQ29udGV4dCcgaW4gYXJiLmFyYikgfHxcbiAgICAgICAgICAgICEoJ3NocmluaycgaW4gYXJiLmFyYikgfHxcbiAgICAgICAgICAgICEoJ3Nocmlua2FibGVGb3InIGluIGFyYi5hcmIpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvbnZlcnNpb24gcmVqZWN0ZWQ6IFVuZGVybHlpbmcgYXJiaXRyYXJ5IGlzIG5vdCBjb21wYXRpYmxlIHdpdGggQXJiaXRyYXJ5V2l0aENvbnRleHR1YWxTaHJpbmsnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXJiLmFyYjtcbiAgICB9XG4gICAgTmV4dEFyYml0cmFyeV8xLmFzc2VydElzTmV4dEFyYml0cmFyeShhcmIpO1xuICAgIHJldHVybiBuZXcgQ29udmVydGVyRnJvbU5leHRfMS5Db252ZXJ0ZXJGcm9tTmV4dChhcmIsIGxlZ2FjeVNocnVua09uY2VDb250ZXh0KTtcbn1cbmV4cG9ydHMuY29udmVydEZyb21OZXh0V2l0aFNocnVua09uY2UgPSBjb252ZXJ0RnJvbU5leHRXaXRoU2hydW5rT25jZTtcbmZ1bmN0aW9uIGNvbnZlcnRUb05leHQoYXJiKSB7XG4gICAgaWYgKENvbnZlcnRlckZyb21OZXh0XzEuQ29udmVydGVyRnJvbU5leHQuaXNDb252ZXJ0ZXJGcm9tTmV4dChhcmIpKSB7XG4gICAgICAgIHJldHVybiBhcmIuYXJiO1xuICAgIH1cbiAgICBBcmJpdHJhcnlfMS5hc3NlcnRJc0FyYml0cmFyeShhcmIpO1xuICAgIHJldHVybiBuZXcgQ29udmVydGVyVG9OZXh0XzEuQ29udmVydGVyVG9OZXh0KGFyYik7XG59XG5leHBvcnRzLmNvbnZlcnRUb05leHQgPSBjb252ZXJ0VG9OZXh0O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmFzc2VydElzTmV4dEFyYml0cmFyeSA9IGV4cG9ydHMuTmV4dEFyYml0cmFyeSA9IHZvaWQgMDtcbmNvbnN0IFN0cmVhbV8xID0gcmVxdWlyZShcIi4uLy4uLy4uL3N0cmVhbS9TdHJlYW1cIik7XG5jb25zdCBzeW1ib2xzXzEgPSByZXF1aXJlKFwiLi4vLi4vc3ltYm9sc1wiKTtcbmNvbnN0IE5leHRWYWx1ZV8xID0gcmVxdWlyZShcIi4vTmV4dFZhbHVlXCIpO1xuY2xhc3MgTmV4dEFyYml0cmFyeSB7XG4gICAgZmlsdGVyKHJlZmluZW1lbnQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBGaWx0ZXJBcmJpdHJhcnkodGhpcywgcmVmaW5lbWVudCk7XG4gICAgfVxuICAgIG1hcChtYXBwZXIsIHVubWFwcGVyKSB7XG4gICAgICAgIHJldHVybiBuZXcgTWFwQXJiaXRyYXJ5KHRoaXMsIG1hcHBlciwgdW5tYXBwZXIpO1xuICAgIH1cbiAgICBjaGFpbihjaGFpbmVyKSB7XG4gICAgICAgIHJldHVybiBuZXcgQ2hhaW5BcmJpdHJhcnkodGhpcywgY2hhaW5lcik7XG4gICAgfVxuICAgIG5vU2hyaW5rKCkge1xuICAgICAgICByZXR1cm4gbmV3IE5vU2hyaW5rQXJiaXRyYXJ5KHRoaXMpO1xuICAgIH1cbiAgICBub0JpYXMoKSB7XG4gICAgICAgIHJldHVybiBuZXcgTm9CaWFzQXJiaXRyYXJ5KHRoaXMpO1xuICAgIH1cbn1cbmV4cG9ydHMuTmV4dEFyYml0cmFyeSA9IE5leHRBcmJpdHJhcnk7XG5jbGFzcyBDaGFpbkFyYml0cmFyeSBleHRlbmRzIE5leHRBcmJpdHJhcnkge1xuICAgIGNvbnN0cnVjdG9yKGFyYiwgY2hhaW5lcikge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmFyYiA9IGFyYjtcbiAgICAgICAgdGhpcy5jaGFpbmVyID0gY2hhaW5lcjtcbiAgICB9XG4gICAgZ2VuZXJhdGUobXJuZywgYmlhc0ZhY3Rvcikge1xuICAgICAgICBjb25zdCBjbG9uZWRNcm5nID0gbXJuZy5jbG9uZSgpO1xuICAgICAgICBjb25zdCBzcmMgPSB0aGlzLmFyYi5nZW5lcmF0ZShtcm5nLCBiaWFzRmFjdG9yKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudmFsdWVDaGFpbmVyKHNyYywgbXJuZywgY2xvbmVkTXJuZywgYmlhc0ZhY3Rvcik7XG4gICAgfVxuICAgIGNhblNocmlua1dpdGhvdXRDb250ZXh0KHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgc2hyaW5rKHZhbHVlLCBjb250ZXh0KSB7XG4gICAgICAgIGlmICh0aGlzLmlzU2FmZUNvbnRleHQoY29udGV4dCkpIHtcbiAgICAgICAgICAgIHJldHVybiAoIWNvbnRleHQuc3RvcHBlZEZvck9yaWdpbmFsXG4gICAgICAgICAgICAgICAgPyB0aGlzLmFyYlxuICAgICAgICAgICAgICAgICAgICAuc2hyaW5rKGNvbnRleHQub3JpZ2luYWxWYWx1ZSwgY29udGV4dC5vcmlnaW5hbENvbnRleHQpXG4gICAgICAgICAgICAgICAgICAgIC5tYXAoKHYpID0+IHRoaXMudmFsdWVDaGFpbmVyKHYsIGNvbnRleHQuY2xvbmVkTXJuZy5jbG9uZSgpLCBjb250ZXh0LmNsb25lZE1ybmcsIGNvbnRleHQub3JpZ2luYWxCaWFzKSlcbiAgICAgICAgICAgICAgICA6IFN0cmVhbV8xLlN0cmVhbS5uaWwoKSkuam9pbihjb250ZXh0LmNoYWluZWRBcmJpdHJhcnkuc2hyaW5rKHZhbHVlLCBjb250ZXh0LmNoYWluZWRDb250ZXh0KS5tYXAoKGRzdCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IG5ld0NvbnRleHQgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGNvbnRleHQpLCB7IGNoYWluZWRDb250ZXh0OiBkc3QuY29udGV4dCwgc3RvcHBlZEZvck9yaWdpbmFsOiB0cnVlIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgTmV4dFZhbHVlXzEuTmV4dFZhbHVlKGRzdC52YWx1ZV8sIG5ld0NvbnRleHQpO1xuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBTdHJlYW1fMS5TdHJlYW0ubmlsKCk7XG4gICAgfVxuICAgIHZhbHVlQ2hhaW5lcih2LCBnZW5lcmF0ZU1ybmcsIGNsb25lZE1ybmcsIGJpYXNGYWN0b3IpIHtcbiAgICAgICAgY29uc3QgY2hhaW5lZEFyYml0cmFyeSA9IHRoaXMuY2hhaW5lcih2LnZhbHVlXyk7XG4gICAgICAgIGNvbnN0IGRzdCA9IGNoYWluZWRBcmJpdHJhcnkuZ2VuZXJhdGUoZ2VuZXJhdGVNcm5nLCBiaWFzRmFjdG9yKTtcbiAgICAgICAgY29uc3QgY29udGV4dCA9IHtcbiAgICAgICAgICAgIG9yaWdpbmFsQmlhczogYmlhc0ZhY3RvcixcbiAgICAgICAgICAgIG9yaWdpbmFsVmFsdWU6IHYudmFsdWVfLFxuICAgICAgICAgICAgb3JpZ2luYWxDb250ZXh0OiB2LmNvbnRleHQsXG4gICAgICAgICAgICBzdG9wcGVkRm9yT3JpZ2luYWw6IGZhbHNlLFxuICAgICAgICAgICAgY2hhaW5lZEFyYml0cmFyeSxcbiAgICAgICAgICAgIGNoYWluZWRDb250ZXh0OiBkc3QuY29udGV4dCxcbiAgICAgICAgICAgIGNsb25lZE1ybmcsXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBuZXcgTmV4dFZhbHVlXzEuTmV4dFZhbHVlKGRzdC52YWx1ZV8sIGNvbnRleHQpO1xuICAgIH1cbiAgICBpc1NhZmVDb250ZXh0KGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIChjb250ZXh0ICE9IG51bGwgJiZcbiAgICAgICAgICAgIHR5cGVvZiBjb250ZXh0ID09PSAnb2JqZWN0JyAmJlxuICAgICAgICAgICAgJ29yaWdpbmFsQmlhcycgaW4gY29udGV4dCAmJlxuICAgICAgICAgICAgJ29yaWdpbmFsVmFsdWUnIGluIGNvbnRleHQgJiZcbiAgICAgICAgICAgICdvcmlnaW5hbENvbnRleHQnIGluIGNvbnRleHQgJiZcbiAgICAgICAgICAgICdzdG9wcGVkRm9yT3JpZ2luYWwnIGluIGNvbnRleHQgJiZcbiAgICAgICAgICAgICdjaGFpbmVkQXJiaXRyYXJ5JyBpbiBjb250ZXh0ICYmXG4gICAgICAgICAgICAnY2hhaW5lZENvbnRleHQnIGluIGNvbnRleHQgJiZcbiAgICAgICAgICAgICdjbG9uZWRNcm5nJyBpbiBjb250ZXh0KTtcbiAgICB9XG59XG5jbGFzcyBNYXBBcmJpdHJhcnkgZXh0ZW5kcyBOZXh0QXJiaXRyYXJ5IHtcbiAgICBjb25zdHJ1Y3RvcihhcmIsIG1hcHBlciwgdW5tYXBwZXIpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5hcmIgPSBhcmI7XG4gICAgICAgIHRoaXMubWFwcGVyID0gbWFwcGVyO1xuICAgICAgICB0aGlzLnVubWFwcGVyID0gdW5tYXBwZXI7XG4gICAgICAgIHRoaXMuYmluZFZhbHVlTWFwcGVyID0gdGhpcy52YWx1ZU1hcHBlci5iaW5kKHRoaXMpO1xuICAgIH1cbiAgICBnZW5lcmF0ZShtcm5nLCBiaWFzRmFjdG9yKSB7XG4gICAgICAgIGNvbnN0IGcgPSB0aGlzLmFyYi5nZW5lcmF0ZShtcm5nLCBiaWFzRmFjdG9yKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudmFsdWVNYXBwZXIoZyk7XG4gICAgfVxuICAgIGNhblNocmlua1dpdGhvdXRDb250ZXh0KHZhbHVlKSB7XG4gICAgICAgIGlmICh0aGlzLnVubWFwcGVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdW5tYXBwZWQgPSB0aGlzLnVubWFwcGVyKHZhbHVlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5hcmIuY2FuU2hyaW5rV2l0aG91dENvbnRleHQodW5tYXBwZWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKF9lcnIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBzaHJpbmsodmFsdWUsIGNvbnRleHQpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNTYWZlQ29udGV4dChjb250ZXh0KSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYXJiLnNocmluayhjb250ZXh0Lm9yaWdpbmFsVmFsdWUsIGNvbnRleHQub3JpZ2luYWxDb250ZXh0KS5tYXAodGhpcy5iaW5kVmFsdWVNYXBwZXIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnVubWFwcGVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IHVubWFwcGVkID0gdGhpcy51bm1hcHBlcih2YWx1ZSk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hcmIuc2hyaW5rKHVubWFwcGVkLCB1bmRlZmluZWQpLm1hcCh0aGlzLmJpbmRWYWx1ZU1hcHBlcik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFN0cmVhbV8xLlN0cmVhbS5uaWwoKTtcbiAgICB9XG4gICAgbWFwcGVyV2l0aENsb25lSWZOZWVkZWQodikge1xuICAgICAgICBjb25zdCBzb3VyY2VWYWx1ZSA9IHYudmFsdWU7XG4gICAgICAgIGNvbnN0IG1hcHBlZFZhbHVlID0gdGhpcy5tYXBwZXIoc291cmNlVmFsdWUpO1xuICAgICAgICBpZiAodi5oYXNUb0JlQ2xvbmVkICYmXG4gICAgICAgICAgICAoKHR5cGVvZiBtYXBwZWRWYWx1ZSA9PT0gJ29iamVjdCcgJiYgbWFwcGVkVmFsdWUgIT09IG51bGwpIHx8IHR5cGVvZiBtYXBwZWRWYWx1ZSA9PT0gJ2Z1bmN0aW9uJykgJiZcbiAgICAgICAgICAgIE9iamVjdC5pc0V4dGVuc2libGUobWFwcGVkVmFsdWUpKSB7XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobWFwcGVkVmFsdWUsIHN5bWJvbHNfMS5jbG9uZU1ldGhvZCwgeyBnZXQ6ICgpID0+ICgpID0+IHRoaXMubWFwcGVyV2l0aENsb25lSWZOZWVkZWQodilbMF0gfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFttYXBwZWRWYWx1ZSwgc291cmNlVmFsdWVdO1xuICAgIH1cbiAgICB2YWx1ZU1hcHBlcih2KSB7XG4gICAgICAgIGNvbnN0IFttYXBwZWRWYWx1ZSwgc291cmNlVmFsdWVdID0gdGhpcy5tYXBwZXJXaXRoQ2xvbmVJZk5lZWRlZCh2KTtcbiAgICAgICAgY29uc3QgY29udGV4dCA9IHsgb3JpZ2luYWxWYWx1ZTogc291cmNlVmFsdWUsIG9yaWdpbmFsQ29udGV4dDogdi5jb250ZXh0IH07XG4gICAgICAgIHJldHVybiBuZXcgTmV4dFZhbHVlXzEuTmV4dFZhbHVlKG1hcHBlZFZhbHVlLCBjb250ZXh0KTtcbiAgICB9XG4gICAgaXNTYWZlQ29udGV4dChjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiAoY29udGV4dCAhPSBudWxsICYmXG4gICAgICAgICAgICB0eXBlb2YgY29udGV4dCA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgICAgICdvcmlnaW5hbFZhbHVlJyBpbiBjb250ZXh0ICYmXG4gICAgICAgICAgICAnb3JpZ2luYWxDb250ZXh0JyBpbiBjb250ZXh0KTtcbiAgICB9XG59XG5jbGFzcyBGaWx0ZXJBcmJpdHJhcnkgZXh0ZW5kcyBOZXh0QXJiaXRyYXJ5IHtcbiAgICBjb25zdHJ1Y3RvcihhcmIsIHJlZmluZW1lbnQpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5hcmIgPSBhcmI7XG4gICAgICAgIHRoaXMucmVmaW5lbWVudCA9IHJlZmluZW1lbnQ7XG4gICAgICAgIHRoaXMuYmluZFJlZmluZW1lbnRPblZhbHVlID0gdGhpcy5yZWZpbmVtZW50T25WYWx1ZS5iaW5kKHRoaXMpO1xuICAgIH1cbiAgICBnZW5lcmF0ZShtcm5nLCBiaWFzRmFjdG9yKSB7XG4gICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICBjb25zdCBnID0gdGhpcy5hcmIuZ2VuZXJhdGUobXJuZywgYmlhc0ZhY3Rvcik7XG4gICAgICAgICAgICBpZiAodGhpcy5yZWZpbmVtZW50T25WYWx1ZShnKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBnO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGNhblNocmlua1dpdGhvdXRDb250ZXh0KHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFyYi5jYW5TaHJpbmtXaXRob3V0Q29udGV4dCh2YWx1ZSkgJiYgdGhpcy5yZWZpbmVtZW50KHZhbHVlKTtcbiAgICB9XG4gICAgc2hyaW5rKHZhbHVlLCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFyYi5zaHJpbmsodmFsdWUsIGNvbnRleHQpLmZpbHRlcih0aGlzLmJpbmRSZWZpbmVtZW50T25WYWx1ZSk7XG4gICAgfVxuICAgIHJlZmluZW1lbnRPblZhbHVlKHYpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVmaW5lbWVudCh2LnZhbHVlKTtcbiAgICB9XG59XG5jbGFzcyBOb1Nocmlua0FyYml0cmFyeSBleHRlbmRzIE5leHRBcmJpdHJhcnkge1xuICAgIGNvbnN0cnVjdG9yKGFyYikge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmFyYiA9IGFyYjtcbiAgICB9XG4gICAgZ2VuZXJhdGUobXJuZywgYmlhc0ZhY3Rvcikge1xuICAgICAgICByZXR1cm4gdGhpcy5hcmIuZ2VuZXJhdGUobXJuZywgYmlhc0ZhY3Rvcik7XG4gICAgfVxuICAgIGNhblNocmlua1dpdGhvdXRDb250ZXh0KHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFyYi5jYW5TaHJpbmtXaXRob3V0Q29udGV4dCh2YWx1ZSk7XG4gICAgfVxuICAgIHNocmluayhfdmFsdWUsIF9jb250ZXh0KSB7XG4gICAgICAgIHJldHVybiBTdHJlYW1fMS5TdHJlYW0ubmlsKCk7XG4gICAgfVxuICAgIG5vU2hyaW5rKCkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG59XG5jbGFzcyBOb0JpYXNBcmJpdHJhcnkgZXh0ZW5kcyBOZXh0QXJiaXRyYXJ5IHtcbiAgICBjb25zdHJ1Y3RvcihhcmIpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5hcmIgPSBhcmI7XG4gICAgfVxuICAgIGdlbmVyYXRlKG1ybmcsIF9iaWFzRmFjdG9yKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFyYi5nZW5lcmF0ZShtcm5nLCB1bmRlZmluZWQpO1xuICAgIH1cbiAgICBjYW5TaHJpbmtXaXRob3V0Q29udGV4dCh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5hcmIuY2FuU2hyaW5rV2l0aG91dENvbnRleHQodmFsdWUpO1xuICAgIH1cbiAgICBzaHJpbmsodmFsdWUsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXJiLnNocmluayh2YWx1ZSwgY29udGV4dCk7XG4gICAgfVxuICAgIG5vQmlhcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxufVxuZnVuY3Rpb24gYXNzZXJ0SXNOZXh0QXJiaXRyYXJ5KGluc3RhbmNlKSB7XG4gICAgaWYgKHR5cGVvZiBpbnN0YW5jZSAhPT0gJ29iamVjdCcgfHxcbiAgICAgICAgaW5zdGFuY2UgPT09IG51bGwgfHxcbiAgICAgICAgISgnZ2VuZXJhdGUnIGluIGluc3RhbmNlKSB8fFxuICAgICAgICAhKCdzaHJpbmsnIGluIGluc3RhbmNlKSB8fFxuICAgICAgICAnc2hyaW5rYWJsZUZvcicgaW4gaW5zdGFuY2UpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmV4cGVjdGVkIHZhbHVlIHJlY2VpdmVkOiBub3QgYW4gaW5zdGFuY2Ugb2YgTmV4dEFyYml0cmFyeScpO1xuICAgIH1cbn1cbmV4cG9ydHMuYXNzZXJ0SXNOZXh0QXJiaXRyYXJ5ID0gYXNzZXJ0SXNOZXh0QXJiaXRyYXJ5O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLk5leHRWYWx1ZSA9IHZvaWQgMDtcbmNvbnN0IHN5bWJvbHNfMSA9IHJlcXVpcmUoXCIuLi8uLi9zeW1ib2xzXCIpO1xuY2xhc3MgTmV4dFZhbHVlIHtcbiAgICBjb25zdHJ1Y3Rvcih2YWx1ZV8sIGNvbnRleHQsIGN1c3RvbUdldFZhbHVlID0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRoaXMudmFsdWVfID0gdmFsdWVfO1xuICAgICAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICAgICAgICB0aGlzLmhhc1RvQmVDbG9uZWQgPSBjdXN0b21HZXRWYWx1ZSAhPT0gdW5kZWZpbmVkIHx8IHN5bWJvbHNfMS5oYXNDbG9uZU1ldGhvZCh2YWx1ZV8pO1xuICAgICAgICB0aGlzLnJlYWRPbmNlID0gZmFsc2U7XG4gICAgICAgIGlmICh0aGlzLmhhc1RvQmVDbG9uZWQpIHtcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAndmFsdWUnLCB7IGdldDogY3VzdG9tR2V0VmFsdWUgIT09IHVuZGVmaW5lZCA/IGN1c3RvbUdldFZhbHVlIDogdGhpcy5nZXRWYWx1ZSB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZV87XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0VmFsdWUoKSB7XG4gICAgICAgIGlmICh0aGlzLmhhc1RvQmVDbG9uZWQpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5yZWFkT25jZSkge1xuICAgICAgICAgICAgICAgIHRoaXMucmVhZE9uY2UgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnZhbHVlXztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLnZhbHVlX1tzeW1ib2xzXzEuY2xvbmVNZXRob2RdKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMudmFsdWVfO1xuICAgIH1cbn1cbmV4cG9ydHMuTmV4dFZhbHVlID0gTmV4dFZhbHVlO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlNocmlua2FibGUgPSB2b2lkIDA7XG5jb25zdCBTdHJlYW1fMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi9zdHJlYW0vU3RyZWFtXCIpO1xuY29uc3Qgc3ltYm9sc18xID0gcmVxdWlyZShcIi4uLy4uL3N5bWJvbHNcIik7XG5jbGFzcyBTaHJpbmthYmxlIHtcbiAgICBjb25zdHJ1Y3Rvcih2YWx1ZV8sIHNocmluayA9ICgpID0+IFN0cmVhbV8xLlN0cmVhbS5uaWwoKSwgY3VzdG9tR2V0VmFsdWUgPSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhpcy52YWx1ZV8gPSB2YWx1ZV87XG4gICAgICAgIHRoaXMuc2hyaW5rID0gc2hyaW5rO1xuICAgICAgICB0aGlzLmhhc1RvQmVDbG9uZWQgPSBjdXN0b21HZXRWYWx1ZSAhPT0gdW5kZWZpbmVkIHx8IHN5bWJvbHNfMS5oYXNDbG9uZU1ldGhvZCh2YWx1ZV8pO1xuICAgICAgICB0aGlzLnJlYWRPbmNlID0gZmFsc2U7XG4gICAgICAgIGlmICh0aGlzLmhhc1RvQmVDbG9uZWQpIHtcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAndmFsdWUnLCB7IGdldDogY3VzdG9tR2V0VmFsdWUgIT09IHVuZGVmaW5lZCA/IGN1c3RvbUdldFZhbHVlIDogdGhpcy5nZXRWYWx1ZSB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZV87XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0VmFsdWUoKSB7XG4gICAgICAgIGlmICghdGhpcy5yZWFkT25jZSkge1xuICAgICAgICAgICAgdGhpcy5yZWFkT25jZSA9IHRydWU7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy52YWx1ZV87XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMudmFsdWVfW3N5bWJvbHNfMS5jbG9uZU1ldGhvZF0oKTtcbiAgICB9XG4gICAgYXBwbHlNYXBwZXIobWFwcGVyKSB7XG4gICAgICAgIGlmICh0aGlzLmhhc1RvQmVDbG9uZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IG91dCA9IG1hcHBlcih0aGlzLnZhbHVlKTtcbiAgICAgICAgICAgIGlmIChvdXQgaW5zdGFuY2VvZiBPYmplY3QpIHtcbiAgICAgICAgICAgICAgICBvdXRbc3ltYm9sc18xLmNsb25lTWV0aG9kXSA9ICgpID0+IHRoaXMuYXBwbHlNYXBwZXIobWFwcGVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBvdXQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1hcHBlcih0aGlzLnZhbHVlKTtcbiAgICB9XG4gICAgbWFwKG1hcHBlcikge1xuICAgICAgICByZXR1cm4gbmV3IFNocmlua2FibGUodGhpcy5hcHBseU1hcHBlcihtYXBwZXIpLCAoKSA9PiB0aGlzLnNocmluaygpLm1hcCgodikgPT4gdi5tYXAobWFwcGVyKSkpO1xuICAgIH1cbiAgICBmaWx0ZXIocmVmaW5lbWVudCkge1xuICAgICAgICBjb25zdCByZWZpbmVtZW50T25TaHJpbmthYmxlID0gKHMpID0+IHtcbiAgICAgICAgICAgIHJldHVybiByZWZpbmVtZW50KHMudmFsdWVfKTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIG5ldyBTaHJpbmthYmxlKHRoaXMudmFsdWUsICgpID0+IHRoaXMuc2hyaW5rKClcbiAgICAgICAgICAgIC5maWx0ZXIocmVmaW5lbWVudE9uU2hyaW5rYWJsZSlcbiAgICAgICAgICAgIC5tYXAoKHYpID0+IHYuZmlsdGVyKHJlZmluZW1lbnQpKSk7XG4gICAgfVxufVxuZXhwb3J0cy5TaHJpbmthYmxlID0gU2hyaW5rYWJsZTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5sb2dMaWtlNjQgPSBleHBvcnRzLmhhbHZlNjQgPSBleHBvcnRzLmFkZDY0ID0gZXhwb3J0cy5uZWdhdGl2ZTY0ID0gZXhwb3J0cy5zdWJzdHJhY3Q2NCA9IGV4cG9ydHMuY2xvbmU2NCA9IGV4cG9ydHMuaXNTdHJpY3RseVNtYWxsZXI2NCA9IGV4cG9ydHMuaXNFcXVhbDY0ID0gZXhwb3J0cy5pc1N0cmljdGx5UG9zaXRpdmU2NCA9IGV4cG9ydHMuaXNTdHJpY3RseU5lZ2F0aXZlNjQgPSBleHBvcnRzLmlzWmVybzY0ID0gZXhwb3J0cy5Vbml0NjQgPSBleHBvcnRzLlplcm82NCA9IHZvaWQgMDtcbmV4cG9ydHMuWmVybzY0ID0geyBzaWduOiAxLCBkYXRhOiBbMCwgMF0gfTtcbmV4cG9ydHMuVW5pdDY0ID0geyBzaWduOiAxLCBkYXRhOiBbMCwgMV0gfTtcbmZ1bmN0aW9uIGlzWmVybzY0KGEpIHtcbiAgICByZXR1cm4gYS5kYXRhWzBdID09PSAwICYmIGEuZGF0YVsxXSA9PT0gMDtcbn1cbmV4cG9ydHMuaXNaZXJvNjQgPSBpc1plcm82NDtcbmZ1bmN0aW9uIGlzU3RyaWN0bHlOZWdhdGl2ZTY0KGEpIHtcbiAgICByZXR1cm4gYS5zaWduID09PSAtMSAmJiAhaXNaZXJvNjQoYSk7XG59XG5leHBvcnRzLmlzU3RyaWN0bHlOZWdhdGl2ZTY0ID0gaXNTdHJpY3RseU5lZ2F0aXZlNjQ7XG5mdW5jdGlvbiBpc1N0cmljdGx5UG9zaXRpdmU2NChhKSB7XG4gICAgcmV0dXJuIGEuc2lnbiA9PT0gMSAmJiAhaXNaZXJvNjQoYSk7XG59XG5leHBvcnRzLmlzU3RyaWN0bHlQb3NpdGl2ZTY0ID0gaXNTdHJpY3RseVBvc2l0aXZlNjQ7XG5mdW5jdGlvbiBpc0VxdWFsNjQoYSwgYikge1xuICAgIGlmIChhLmRhdGFbMF0gPT09IGIuZGF0YVswXSAmJiBhLmRhdGFbMV0gPT09IGIuZGF0YVsxXSkge1xuICAgICAgICByZXR1cm4gYS5zaWduID09PSBiLnNpZ24gfHwgKGEuZGF0YVswXSA9PT0gMCAmJiBhLmRhdGFbMV0gPT09IDApO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5leHBvcnRzLmlzRXF1YWw2NCA9IGlzRXF1YWw2NDtcbmZ1bmN0aW9uIGlzU3RyaWN0bHlTbWFsbGVyNjRJbnRlcm5hbChhLCBiKSB7XG4gICAgcmV0dXJuIGFbMF0gPCBiWzBdIHx8IChhWzBdID09PSBiWzBdICYmIGFbMV0gPCBiWzFdKTtcbn1cbmZ1bmN0aW9uIGlzU3RyaWN0bHlTbWFsbGVyNjQoYSwgYikge1xuICAgIGlmIChhLnNpZ24gPT09IGIuc2lnbikge1xuICAgICAgICByZXR1cm4gYS5zaWduID09PSAxXG4gICAgICAgICAgICA/IGlzU3RyaWN0bHlTbWFsbGVyNjRJbnRlcm5hbChhLmRhdGEsIGIuZGF0YSlcbiAgICAgICAgICAgIDogaXNTdHJpY3RseVNtYWxsZXI2NEludGVybmFsKGIuZGF0YSwgYS5kYXRhKTtcbiAgICB9XG4gICAgcmV0dXJuIGEuc2lnbiA9PT0gLTEgJiYgKCFpc1plcm82NChhKSB8fCAhaXNaZXJvNjQoYikpO1xufVxuZXhwb3J0cy5pc1N0cmljdGx5U21hbGxlcjY0ID0gaXNTdHJpY3RseVNtYWxsZXI2NDtcbmZ1bmN0aW9uIGNsb25lNjQoYSkge1xuICAgIHJldHVybiB7IHNpZ246IGEuc2lnbiwgZGF0YTogW2EuZGF0YVswXSwgYS5kYXRhWzFdXSB9O1xufVxuZXhwb3J0cy5jbG9uZTY0ID0gY2xvbmU2NDtcbmZ1bmN0aW9uIHN1YnN0cmFjdDY0RGF0YUludGVybmFsKGEsIGIpIHtcbiAgICBsZXQgcmVtaW5kZXJMb3cgPSAwO1xuICAgIGxldCBsb3cgPSBhWzFdIC0gYlsxXTtcbiAgICBpZiAobG93IDwgMCkge1xuICAgICAgICByZW1pbmRlckxvdyA9IDE7XG4gICAgICAgIGxvdyA9IGxvdyA+Pj4gMDtcbiAgICB9XG4gICAgcmV0dXJuIFthWzBdIC0gYlswXSAtIHJlbWluZGVyTG93LCBsb3ddO1xufVxuZnVuY3Rpb24gc3Vic3RyYWN0NjRJbnRlcm5hbChhLCBiKSB7XG4gICAgaWYgKGEuc2lnbiA9PT0gMSAmJiBiLnNpZ24gPT09IC0xKSB7XG4gICAgICAgIGNvbnN0IGxvdyA9IGEuZGF0YVsxXSArIGIuZGF0YVsxXTtcbiAgICAgICAgY29uc3QgaGlnaCA9IGEuZGF0YVswXSArIGIuZGF0YVswXSArIChsb3cgPiAweGZmZmZmZmZmID8gMSA6IDApO1xuICAgICAgICByZXR1cm4geyBzaWduOiAxLCBkYXRhOiBbaGlnaCA+Pj4gMCwgbG93ID4+PiAwXSB9O1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBzaWduOiAxLFxuICAgICAgICBkYXRhOiBhLnNpZ24gPT09IDEgPyBzdWJzdHJhY3Q2NERhdGFJbnRlcm5hbChhLmRhdGEsIGIuZGF0YSkgOiBzdWJzdHJhY3Q2NERhdGFJbnRlcm5hbChiLmRhdGEsIGEuZGF0YSksXG4gICAgfTtcbn1cbmZ1bmN0aW9uIHN1YnN0cmFjdDY0KGFycmF5SW50QSwgYXJyYXlJbnRCKSB7XG4gICAgaWYgKGlzU3RyaWN0bHlTbWFsbGVyNjQoYXJyYXlJbnRBLCBhcnJheUludEIpKSB7XG4gICAgICAgIGNvbnN0IG91dCA9IHN1YnN0cmFjdDY0SW50ZXJuYWwoYXJyYXlJbnRCLCBhcnJheUludEEpO1xuICAgICAgICBvdXQuc2lnbiA9IC0xO1xuICAgICAgICByZXR1cm4gb3V0O1xuICAgIH1cbiAgICByZXR1cm4gc3Vic3RyYWN0NjRJbnRlcm5hbChhcnJheUludEEsIGFycmF5SW50Qik7XG59XG5leHBvcnRzLnN1YnN0cmFjdDY0ID0gc3Vic3RyYWN0NjQ7XG5mdW5jdGlvbiBuZWdhdGl2ZTY0KGFycmF5SW50QSkge1xuICAgIHJldHVybiB7XG4gICAgICAgIHNpZ246IC1hcnJheUludEEuc2lnbixcbiAgICAgICAgZGF0YTogW2FycmF5SW50QS5kYXRhWzBdLCBhcnJheUludEEuZGF0YVsxXV0sXG4gICAgfTtcbn1cbmV4cG9ydHMubmVnYXRpdmU2NCA9IG5lZ2F0aXZlNjQ7XG5mdW5jdGlvbiBhZGQ2NChhcnJheUludEEsIGFycmF5SW50Qikge1xuICAgIGlmIChpc1plcm82NChhcnJheUludEIpKSB7XG4gICAgICAgIGlmIChpc1plcm82NChhcnJheUludEEpKSB7XG4gICAgICAgICAgICByZXR1cm4gY2xvbmU2NChleHBvcnRzLlplcm82NCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNsb25lNjQoYXJyYXlJbnRBKTtcbiAgICB9XG4gICAgcmV0dXJuIHN1YnN0cmFjdDY0KGFycmF5SW50QSwgbmVnYXRpdmU2NChhcnJheUludEIpKTtcbn1cbmV4cG9ydHMuYWRkNjQgPSBhZGQ2NDtcbmZ1bmN0aW9uIGhhbHZlNjQoYSkge1xuICAgIHJldHVybiB7XG4gICAgICAgIHNpZ246IGEuc2lnbixcbiAgICAgICAgZGF0YTogW01hdGguZmxvb3IoYS5kYXRhWzBdIC8gMiksIChhLmRhdGFbMF0gJSAyID09PSAxID8gMHg4MDAwMDAwMCA6IDApICsgTWF0aC5mbG9vcihhLmRhdGFbMV0gLyAyKV0sXG4gICAgfTtcbn1cbmV4cG9ydHMuaGFsdmU2NCA9IGhhbHZlNjQ7XG5mdW5jdGlvbiBsb2dMaWtlNjQoYSkge1xuICAgIHJldHVybiB7XG4gICAgICAgIHNpZ246IGEuc2lnbixcbiAgICAgICAgZGF0YTogWzAsIE1hdGguZmxvb3IoTWF0aC5sb2coYS5kYXRhWzBdICogMHgxMDAwMDAwMDAgKyBhLmRhdGFbMV0pIC8gTWF0aC5sb2coMikpXSxcbiAgICB9O1xufVxuZXhwb3J0cy5sb2dMaWtlNjQgPSBsb2dMaWtlNjQ7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuYXJyYXlJbnQ2NCA9IHZvaWQgMDtcbmNvbnN0IFN0cmVhbV8xID0gcmVxdWlyZShcIi4uLy4uLy4uL3N0cmVhbS9TdHJlYW1cIik7XG5jb25zdCBDb252ZXJ0ZXJzXzEgPSByZXF1aXJlKFwiLi4vZGVmaW5pdGlvbi9Db252ZXJ0ZXJzXCIpO1xuY29uc3QgTmV4dEFyYml0cmFyeV8xID0gcmVxdWlyZShcIi4uL2RlZmluaXRpb24vTmV4dEFyYml0cmFyeVwiKTtcbmNvbnN0IE5leHRWYWx1ZV8xID0gcmVxdWlyZShcIi4uL2RlZmluaXRpb24vTmV4dFZhbHVlXCIpO1xuY29uc3QgQXJyYXlJbnQ2NF8xID0gcmVxdWlyZShcIi4vQXJyYXlJbnQ2NFwiKTtcbmNsYXNzIEFycmF5SW50NjRBcmJpdHJhcnkgZXh0ZW5kcyBOZXh0QXJiaXRyYXJ5XzEuTmV4dEFyYml0cmFyeSB7XG4gICAgY29uc3RydWN0b3IobWluLCBtYXgpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5taW4gPSBtaW47XG4gICAgICAgIHRoaXMubWF4ID0gbWF4O1xuICAgICAgICB0aGlzLmJpYXNlZFJhbmdlcyA9IG51bGw7XG4gICAgfVxuICAgIGdlbmVyYXRlKG1ybmcsIGJpYXNGYWN0b3IpIHtcbiAgICAgICAgY29uc3QgcmFuZ2UgPSB0aGlzLmNvbXB1dGVHZW5lcmF0ZVJhbmdlKG1ybmcsIGJpYXNGYWN0b3IpO1xuICAgICAgICBjb25zdCB1bmNoZWNrZWRWYWx1ZSA9IG1ybmcubmV4dEFycmF5SW50KHJhbmdlLm1pbiwgcmFuZ2UubWF4KTtcbiAgICAgICAgaWYgKHVuY2hlY2tlZFZhbHVlLmRhdGEubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICB1bmNoZWNrZWRWYWx1ZS5kYXRhLnVuc2hpZnQoMCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBOZXh0VmFsdWVfMS5OZXh0VmFsdWUodW5jaGVja2VkVmFsdWUsIHVuZGVmaW5lZCk7XG4gICAgfVxuICAgIGNvbXB1dGVHZW5lcmF0ZVJhbmdlKG1ybmcsIGJpYXNGYWN0b3IpIHtcbiAgICAgICAgaWYgKGJpYXNGYWN0b3IgPT09IHVuZGVmaW5lZCB8fCBtcm5nLm5leHRJbnQoMSwgYmlhc0ZhY3RvcikgIT09IDEpIHtcbiAgICAgICAgICAgIHJldHVybiB7IG1pbjogdGhpcy5taW4sIG1heDogdGhpcy5tYXggfTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByYW5nZXMgPSB0aGlzLnJldHJpZXZlQmlhc2VkUmFuZ2VzKCk7XG4gICAgICAgIGlmIChyYW5nZXMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICByZXR1cm4gcmFuZ2VzWzBdO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGlkID0gbXJuZy5uZXh0SW50KC0yICogKHJhbmdlcy5sZW5ndGggLSAxKSwgcmFuZ2VzLmxlbmd0aCAtIDIpO1xuICAgICAgICByZXR1cm4gaWQgPCAwID8gcmFuZ2VzWzBdIDogcmFuZ2VzW2lkICsgMV07XG4gICAgfVxuICAgIGNhblNocmlua1dpdGhvdXRDb250ZXh0KHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IHVuc2FmZVZhbHVlID0gdmFsdWU7XG4gICAgICAgIHJldHVybiAodHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJlxuICAgICAgICAgICAgdmFsdWUgIT09IG51bGwgJiZcbiAgICAgICAgICAgICh1bnNhZmVWYWx1ZS5zaWduID09PSAtMSB8fCB1bnNhZmVWYWx1ZS5zaWduID09PSAxKSAmJlxuICAgICAgICAgICAgQXJyYXkuaXNBcnJheSh1bnNhZmVWYWx1ZS5kYXRhKSAmJlxuICAgICAgICAgICAgdW5zYWZlVmFsdWUuZGF0YS5sZW5ndGggPT09IDIgJiZcbiAgICAgICAgICAgICgoQXJyYXlJbnQ2NF8xLmlzU3RyaWN0bHlTbWFsbGVyNjQodGhpcy5taW4sIHVuc2FmZVZhbHVlKSAmJiBBcnJheUludDY0XzEuaXNTdHJpY3RseVNtYWxsZXI2NCh1bnNhZmVWYWx1ZSwgdGhpcy5tYXgpKSB8fFxuICAgICAgICAgICAgICAgIEFycmF5SW50NjRfMS5pc0VxdWFsNjQodGhpcy5taW4sIHVuc2FmZVZhbHVlKSB8fFxuICAgICAgICAgICAgICAgIEFycmF5SW50NjRfMS5pc0VxdWFsNjQodGhpcy5tYXgsIHVuc2FmZVZhbHVlKSkpO1xuICAgIH1cbiAgICBzaHJpbmtBcnJheUludDY0KHZhbHVlLCB0YXJnZXQsIHRyeVRhcmdldEFzYXApIHtcbiAgICAgICAgY29uc3QgcmVhbEdhcCA9IEFycmF5SW50NjRfMS5zdWJzdHJhY3Q2NCh2YWx1ZSwgdGFyZ2V0KTtcbiAgICAgICAgZnVuY3Rpb24qIHNocmlua0dlbigpIHtcbiAgICAgICAgICAgIGxldCBwcmV2aW91cyA9IHRyeVRhcmdldEFzYXAgPyB1bmRlZmluZWQgOiB0YXJnZXQ7XG4gICAgICAgICAgICBjb25zdCBnYXAgPSB0cnlUYXJnZXRBc2FwID8gcmVhbEdhcCA6IEFycmF5SW50NjRfMS5oYWx2ZTY0KHJlYWxHYXApO1xuICAgICAgICAgICAgZm9yIChsZXQgdG9yZW1vdmUgPSBnYXA7ICFBcnJheUludDY0XzEuaXNaZXJvNjQodG9yZW1vdmUpOyB0b3JlbW92ZSA9IEFycmF5SW50NjRfMS5oYWx2ZTY0KHRvcmVtb3ZlKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG5leHQgPSBBcnJheUludDY0XzEuc3Vic3RyYWN0NjQodmFsdWUsIHRvcmVtb3ZlKTtcbiAgICAgICAgICAgICAgICB5aWVsZCBuZXcgTmV4dFZhbHVlXzEuTmV4dFZhbHVlKG5leHQsIHByZXZpb3VzKTtcbiAgICAgICAgICAgICAgICBwcmV2aW91cyA9IG5leHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFN0cmVhbV8xLnN0cmVhbShzaHJpbmtHZW4oKSk7XG4gICAgfVxuICAgIHNocmluayhjdXJyZW50LCBjb250ZXh0KSB7XG4gICAgICAgIGlmICghQXJyYXlJbnQ2NEFyYml0cmFyeS5pc1ZhbGlkQ29udGV4dChjdXJyZW50LCBjb250ZXh0KSkge1xuICAgICAgICAgICAgY29uc3QgdGFyZ2V0ID0gdGhpcy5kZWZhdWx0VGFyZ2V0KCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zaHJpbmtBcnJheUludDY0KGN1cnJlbnQsIHRhcmdldCwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuaXNMYXN0Q2hhbmNlVHJ5KGN1cnJlbnQsIGNvbnRleHQpKSB7XG4gICAgICAgICAgICByZXR1cm4gU3RyZWFtXzEuU3RyZWFtLm9mKG5ldyBOZXh0VmFsdWVfMS5OZXh0VmFsdWUoY29udGV4dCwgdW5kZWZpbmVkKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuc2hyaW5rQXJyYXlJbnQ2NChjdXJyZW50LCBjb250ZXh0LCBmYWxzZSk7XG4gICAgfVxuICAgIGRlZmF1bHRUYXJnZXQoKSB7XG4gICAgICAgIGlmICghQXJyYXlJbnQ2NF8xLmlzU3RyaWN0bHlQb3NpdGl2ZTY0KHRoaXMubWluKSAmJiAhQXJyYXlJbnQ2NF8xLmlzU3RyaWN0bHlOZWdhdGl2ZTY0KHRoaXMubWF4KSkge1xuICAgICAgICAgICAgcmV0dXJuIEFycmF5SW50NjRfMS5aZXJvNjQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIEFycmF5SW50NjRfMS5pc1N0cmljdGx5TmVnYXRpdmU2NCh0aGlzLm1pbikgPyB0aGlzLm1heCA6IHRoaXMubWluO1xuICAgIH1cbiAgICBpc0xhc3RDaGFuY2VUcnkoY3VycmVudCwgY29udGV4dCkge1xuICAgICAgICBpZiAoQXJyYXlJbnQ2NF8xLmlzWmVybzY0KGN1cnJlbnQpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGN1cnJlbnQuc2lnbiA9PT0gMSkge1xuICAgICAgICAgICAgcmV0dXJuIEFycmF5SW50NjRfMS5pc0VxdWFsNjQoY3VycmVudCwgQXJyYXlJbnQ2NF8xLmFkZDY0KGNvbnRleHQsIEFycmF5SW50NjRfMS5Vbml0NjQpKSAmJiBBcnJheUludDY0XzEuaXNTdHJpY3RseVBvc2l0aXZlNjQoQXJyYXlJbnQ2NF8xLnN1YnN0cmFjdDY0KGN1cnJlbnQsIHRoaXMubWluKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gQXJyYXlJbnQ2NF8xLmlzRXF1YWw2NChjdXJyZW50LCBBcnJheUludDY0XzEuc3Vic3RyYWN0NjQoY29udGV4dCwgQXJyYXlJbnQ2NF8xLlVuaXQ2NCkpICYmIEFycmF5SW50NjRfMS5pc1N0cmljdGx5TmVnYXRpdmU2NChBcnJheUludDY0XzEuc3Vic3RyYWN0NjQoY3VycmVudCwgdGhpcy5tYXgpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzdGF0aWMgaXNWYWxpZENvbnRleHQoX2N1cnJlbnQsIGNvbnRleHQpIHtcbiAgICAgICAgaWYgKGNvbnRleHQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgY29udGV4dCAhPT0gJ29iamVjdCcgfHwgY29udGV4dCA9PT0gbnVsbCB8fCAhKCdzaWduJyBpbiBjb250ZXh0KSB8fCAhKCdkYXRhJyBpbiBjb250ZXh0KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGNvbnRleHQgdHlwZSBwYXNzZWQgdG8gQXJyYXlJbnQ2NEFyYml0cmFyeSAoIzEpYCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHJpZXZlQmlhc2VkUmFuZ2VzKCkge1xuICAgICAgICBpZiAodGhpcy5iaWFzZWRSYW5nZXMgIT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYmlhc2VkUmFuZ2VzO1xuICAgICAgICB9XG4gICAgICAgIGlmIChBcnJheUludDY0XzEuaXNFcXVhbDY0KHRoaXMubWluLCB0aGlzLm1heCkpIHtcbiAgICAgICAgICAgIHRoaXMuYmlhc2VkUmFuZ2VzID0gW3sgbWluOiB0aGlzLm1pbiwgbWF4OiB0aGlzLm1heCB9XTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmJpYXNlZFJhbmdlcztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtaW5TdHJpY3RseVNtYWxsZXJaZXJvID0gQXJyYXlJbnQ2NF8xLmlzU3RyaWN0bHlOZWdhdGl2ZTY0KHRoaXMubWluKTtcbiAgICAgICAgY29uc3QgbWF4U3RyaWN0bHlHcmVhdGVyWmVybyA9IEFycmF5SW50NjRfMS5pc1N0cmljdGx5UG9zaXRpdmU2NCh0aGlzLm1heCk7XG4gICAgICAgIGlmIChtaW5TdHJpY3RseVNtYWxsZXJaZXJvICYmIG1heFN0cmljdGx5R3JlYXRlclplcm8pIHtcbiAgICAgICAgICAgIGNvbnN0IGxvZ01pbiA9IEFycmF5SW50NjRfMS5sb2dMaWtlNjQodGhpcy5taW4pO1xuICAgICAgICAgICAgY29uc3QgbG9nTWF4ID0gQXJyYXlJbnQ2NF8xLmxvZ0xpa2U2NCh0aGlzLm1heCk7XG4gICAgICAgICAgICB0aGlzLmJpYXNlZFJhbmdlcyA9IFtcbiAgICAgICAgICAgICAgICB7IG1pbjogbG9nTWluLCBtYXg6IGxvZ01heCB9LFxuICAgICAgICAgICAgICAgIHsgbWluOiBBcnJheUludDY0XzEuc3Vic3RyYWN0NjQodGhpcy5tYXgsIGxvZ01heCksIG1heDogdGhpcy5tYXggfSxcbiAgICAgICAgICAgICAgICB7IG1pbjogdGhpcy5taW4sIG1heDogQXJyYXlJbnQ2NF8xLnN1YnN0cmFjdDY0KHRoaXMubWluLCBsb2dNaW4pIH0sXG4gICAgICAgICAgICBdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgbG9nR2FwID0gQXJyYXlJbnQ2NF8xLmxvZ0xpa2U2NChBcnJheUludDY0XzEuc3Vic3RyYWN0NjQodGhpcy5tYXgsIHRoaXMubWluKSk7XG4gICAgICAgICAgICBjb25zdCBhcmJDbG9zZVRvTWluID0geyBtaW46IHRoaXMubWluLCBtYXg6IEFycmF5SW50NjRfMS5hZGQ2NCh0aGlzLm1pbiwgbG9nR2FwKSB9O1xuICAgICAgICAgICAgY29uc3QgYXJiQ2xvc2VUb01heCA9IHsgbWluOiBBcnJheUludDY0XzEuc3Vic3RyYWN0NjQodGhpcy5tYXgsIGxvZ0dhcCksIG1heDogdGhpcy5tYXggfTtcbiAgICAgICAgICAgIHRoaXMuYmlhc2VkUmFuZ2VzID0gbWluU3RyaWN0bHlTbWFsbGVyWmVyb1xuICAgICAgICAgICAgICAgID8gW2FyYkNsb3NlVG9NYXgsIGFyYkNsb3NlVG9NaW5dXG4gICAgICAgICAgICAgICAgOiBbYXJiQ2xvc2VUb01pbiwgYXJiQ2xvc2VUb01heF07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuYmlhc2VkUmFuZ2VzO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGFycmF5SW50NjQobWluLCBtYXgpIHtcbiAgICBjb25zdCBhcmIgPSBuZXcgQXJyYXlJbnQ2NEFyYml0cmFyeShtaW4sIG1heCk7XG4gICAgcmV0dXJuIENvbnZlcnRlcnNfMS5jb252ZXJ0RnJvbU5leHRXaXRoU2hydW5rT25jZShhcmIsIGFyYi5kZWZhdWx0VGFyZ2V0KCkpO1xufVxuZXhwb3J0cy5hcnJheUludDY0ID0gYXJyYXlJbnQ2NDtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5idWlsZEFscGhhTnVtZXJpY1BlcmNlbnRBcmIgPSBleHBvcnRzLmJ1aWxkQWxwaGFOdW1lcmljQXJiID0gZXhwb3J0cy5idWlsZExvd2VyQWxwaGFOdW1lcmljQXJiID0gZXhwb3J0cy5idWlsZExvd2VyQWxwaGFBcmIgPSB2b2lkIDA7XG5jb25zdCBmdWxsVW5pY29kZV8xID0gcmVxdWlyZShcIi4uLy4uLy4uL2FyYml0cmFyeS9mdWxsVW5pY29kZVwiKTtcbmNvbnN0IGZyZXF1ZW5jeV8xID0gcmVxdWlyZShcIi4uLy4uLy4uL2FyYml0cmFyeS9mcmVxdWVuY3lcIik7XG5jb25zdCBtYXBUb0NvbnN0YW50XzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vYXJiaXRyYXJ5L21hcFRvQ29uc3RhbnRcIik7XG5jb25zdCBsb3dlckNhc2VNYXBwZXIgPSB7IG51bTogMjYsIGJ1aWxkOiAodikgPT4gU3RyaW5nLmZyb21DaGFyQ29kZSh2ICsgMHg2MSkgfTtcbmNvbnN0IHVwcGVyQ2FzZU1hcHBlciA9IHsgbnVtOiAyNiwgYnVpbGQ6ICh2KSA9PiBTdHJpbmcuZnJvbUNoYXJDb2RlKHYgKyAweDQxKSB9O1xuY29uc3QgbnVtZXJpY01hcHBlciA9IHsgbnVtOiAxMCwgYnVpbGQ6ICh2KSA9PiBTdHJpbmcuZnJvbUNoYXJDb2RlKHYgKyAweDMwKSB9O1xuY29uc3QgcGVyY2VudENoYXJBcmIgPSBmdWxsVW5pY29kZV8xLmZ1bGxVbmljb2RlKCkubWFwKChjKSA9PiB7XG4gICAgY29uc3QgZW5jb2RlZCA9IGVuY29kZVVSSUNvbXBvbmVudChjKTtcbiAgICByZXR1cm4gYyAhPT0gZW5jb2RlZCA/IGVuY29kZWQgOiBgJSR7Yy5jaGFyQ29kZUF0KDApLnRvU3RyaW5nKDE2KX1gO1xufSk7XG5jb25zdCBidWlsZExvd2VyQWxwaGFBcmIgPSAob3RoZXJzKSA9PiBtYXBUb0NvbnN0YW50XzEubWFwVG9Db25zdGFudChsb3dlckNhc2VNYXBwZXIsIHsgbnVtOiBvdGhlcnMubGVuZ3RoLCBidWlsZDogKHYpID0+IG90aGVyc1t2XSB9KTtcbmV4cG9ydHMuYnVpbGRMb3dlckFscGhhQXJiID0gYnVpbGRMb3dlckFscGhhQXJiO1xuY29uc3QgYnVpbGRMb3dlckFscGhhTnVtZXJpY0FyYiA9IChvdGhlcnMpID0+IG1hcFRvQ29uc3RhbnRfMS5tYXBUb0NvbnN0YW50KGxvd2VyQ2FzZU1hcHBlciwgbnVtZXJpY01hcHBlciwgeyBudW06IG90aGVycy5sZW5ndGgsIGJ1aWxkOiAodikgPT4gb3RoZXJzW3ZdIH0pO1xuZXhwb3J0cy5idWlsZExvd2VyQWxwaGFOdW1lcmljQXJiID0gYnVpbGRMb3dlckFscGhhTnVtZXJpY0FyYjtcbmNvbnN0IGJ1aWxkQWxwaGFOdW1lcmljQXJiID0gKG90aGVycykgPT4gbWFwVG9Db25zdGFudF8xLm1hcFRvQ29uc3RhbnQobG93ZXJDYXNlTWFwcGVyLCB1cHBlckNhc2VNYXBwZXIsIG51bWVyaWNNYXBwZXIsIHsgbnVtOiBvdGhlcnMubGVuZ3RoLCBidWlsZDogKHYpID0+IG90aGVyc1t2XSB9KTtcbmV4cG9ydHMuYnVpbGRBbHBoYU51bWVyaWNBcmIgPSBidWlsZEFscGhhTnVtZXJpY0FyYjtcbmNvbnN0IGJ1aWxkQWxwaGFOdW1lcmljUGVyY2VudEFyYiA9IChvdGhlcnMpID0+IGZyZXF1ZW5jeV8xLmZyZXF1ZW5jeSh7XG4gICAgd2VpZ2h0OiAxMCxcbiAgICBhcmJpdHJhcnk6IGV4cG9ydHMuYnVpbGRBbHBoYU51bWVyaWNBcmIob3RoZXJzKSxcbn0sIHtcbiAgICB3ZWlnaHQ6IDEsXG4gICAgYXJiaXRyYXJ5OiBwZXJjZW50Q2hhckFyYixcbn0pO1xuZXhwb3J0cy5idWlsZEFscGhhTnVtZXJpY1BlcmNlbnRBcmIgPSBidWlsZEFscGhhTnVtZXJpY1BlcmNlbnRBcmI7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZXNjYXBlRm9yTXVsdGlsaW5lQ29tbWVudHMgPSBleHBvcnRzLmVzY2FwZUZvclRlbXBsYXRlU3RyaW5nID0gdm9pZCAwO1xuZnVuY3Rpb24gZXNjYXBlRm9yVGVtcGxhdGVTdHJpbmcob3JpZ2luYWxUZXh0KSB7XG4gICAgcmV0dXJuIG9yaWdpbmFsVGV4dC5yZXBsYWNlKC8oWyRgXFxcXF0pL2csICdcXFxcJDEnKS5yZXBsYWNlKC9cXHIvZywgJ1xcXFxyJyk7XG59XG5leHBvcnRzLmVzY2FwZUZvclRlbXBsYXRlU3RyaW5nID0gZXNjYXBlRm9yVGVtcGxhdGVTdHJpbmc7XG5mdW5jdGlvbiBlc2NhcGVGb3JNdWx0aWxpbmVDb21tZW50cyhvcmlnaW5hbFRleHQpIHtcbiAgICByZXR1cm4gb3JpZ2luYWxUZXh0LnJlcGxhY2UoL1xcKlxcLy9nLCAnKlxcXFwvJyk7XG59XG5leHBvcnRzLmVzY2FwZUZvck11bHRpbGluZUNvbW1lbnRzID0gZXNjYXBlRm9yTXVsdGlsaW5lQ29tbWVudHM7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuc2NoZWR1bGVkTW9kZWxSdW4gPSBleHBvcnRzLmFzeW5jTW9kZWxSdW4gPSBleHBvcnRzLm1vZGVsUnVuID0gdm9pZCAwO1xuY29uc3QgU2NoZWR1bGVkQ29tbWFuZF8xID0gcmVxdWlyZShcIi4vY29tbWFuZHMvU2NoZWR1bGVkQ29tbWFuZFwiKTtcbmNvbnN0IGdlbmVyaWNNb2RlbFJ1biA9IChzLCBjbWRzLCBpbml0aWFsVmFsdWUsIHJ1bkNtZCwgdGhlbikgPT4ge1xuICAgIHJldHVybiBzLnRoZW4oKG8pID0+IHtcbiAgICAgICAgY29uc3QgeyBtb2RlbCwgcmVhbCB9ID0gbztcbiAgICAgICAgbGV0IHN0YXRlID0gaW5pdGlhbFZhbHVlO1xuICAgICAgICBmb3IgKGNvbnN0IGMgb2YgY21kcykge1xuICAgICAgICAgICAgc3RhdGUgPSB0aGVuKHN0YXRlLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJ1bkNtZChjLCBtb2RlbCwgcmVhbCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3RhdGU7XG4gICAgfSk7XG59O1xuY29uc3QgaW50ZXJuYWxNb2RlbFJ1biA9IChzLCBjbWRzKSA9PiB7XG4gICAgY29uc3QgdGhlbiA9IChfcCwgYykgPT4gYygpO1xuICAgIGNvbnN0IHNldHVwUHJvZHVjZXIgPSB7XG4gICAgICAgIHRoZW46IChmdW4pID0+IHtcbiAgICAgICAgICAgIGZ1bihzKCkpO1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfSxcbiAgICB9O1xuICAgIGNvbnN0IHJ1blN5bmMgPSAoY21kLCBtLCByKSA9PiB7XG4gICAgICAgIGlmIChjbWQuY2hlY2sobSkpXG4gICAgICAgICAgICBjbWQucnVuKG0sIHIpO1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH07XG4gICAgcmV0dXJuIGdlbmVyaWNNb2RlbFJ1bihzZXR1cFByb2R1Y2VyLCBjbWRzLCB1bmRlZmluZWQsIHJ1blN5bmMsIHRoZW4pO1xufTtcbmNvbnN0IGlzQXN5bmNTZXR1cCA9IChzKSA9PiB7XG4gICAgcmV0dXJuIHR5cGVvZiBzLnRoZW4gPT09ICdmdW5jdGlvbic7XG59O1xuY29uc3QgaW50ZXJuYWxBc3luY01vZGVsUnVuID0gYXN5bmMgKHMsIGNtZHMsIGRlZmF1bHRQcm9taXNlID0gUHJvbWlzZS5yZXNvbHZlKCkpID0+IHtcbiAgICBjb25zdCB0aGVuID0gKHAsIGMpID0+IHAudGhlbihjKTtcbiAgICBjb25zdCBzZXR1cFByb2R1Y2VyID0ge1xuICAgICAgICB0aGVuOiAoZnVuKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBvdXQgPSBzKCk7XG4gICAgICAgICAgICBpZiAoaXNBc3luY1NldHVwKG91dCkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG91dC50aGVuKGZ1bik7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZ1bihvdXQpO1xuICAgICAgICB9LFxuICAgIH07XG4gICAgY29uc3QgcnVuQXN5bmMgPSBhc3luYyAoY21kLCBtLCByKSA9PiB7XG4gICAgICAgIGlmIChhd2FpdCBjbWQuY2hlY2sobSkpXG4gICAgICAgICAgICBhd2FpdCBjbWQucnVuKG0sIHIpO1xuICAgIH07XG4gICAgcmV0dXJuIGF3YWl0IGdlbmVyaWNNb2RlbFJ1bihzZXR1cFByb2R1Y2VyLCBjbWRzLCBkZWZhdWx0UHJvbWlzZSwgcnVuQXN5bmMsIHRoZW4pO1xufTtcbmZ1bmN0aW9uIG1vZGVsUnVuKHMsIGNtZHMpIHtcbiAgICBpbnRlcm5hbE1vZGVsUnVuKHMsIGNtZHMpO1xufVxuZXhwb3J0cy5tb2RlbFJ1biA9IG1vZGVsUnVuO1xuYXN5bmMgZnVuY3Rpb24gYXN5bmNNb2RlbFJ1bihzLCBjbWRzKSB7XG4gICAgYXdhaXQgaW50ZXJuYWxBc3luY01vZGVsUnVuKHMsIGNtZHMpO1xufVxuZXhwb3J0cy5hc3luY01vZGVsUnVuID0gYXN5bmNNb2RlbFJ1bjtcbmFzeW5jIGZ1bmN0aW9uIHNjaGVkdWxlZE1vZGVsUnVuKHNjaGVkdWxlciwgcywgY21kcykge1xuICAgIGNvbnN0IHNjaGVkdWxlZENvbW1hbmRzID0gU2NoZWR1bGVkQ29tbWFuZF8xLnNjaGVkdWxlQ29tbWFuZHMoc2NoZWR1bGVyLCBjbWRzKTtcbiAgICBjb25zdCBvdXQgPSBpbnRlcm5hbEFzeW5jTW9kZWxSdW4ocywgc2NoZWR1bGVkQ29tbWFuZHMsIHNjaGVkdWxlci5zY2hlZHVsZShQcm9taXNlLnJlc29sdmUoKSwgJ3N0YXJ0TW9kZWwnKSk7XG4gICAgYXdhaXQgc2NoZWR1bGVyLndhaXRBbGwoKTtcbiAgICBhd2FpdCBvdXQ7XG59XG5leHBvcnRzLnNjaGVkdWxlZE1vZGVsUnVuID0gc2NoZWR1bGVkTW9kZWxSdW47XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuUmVwbGF5UGF0aCA9IHZvaWQgMDtcbmNsYXNzIFJlcGxheVBhdGgge1xuICAgIHN0YXRpYyBwYXJzZShyZXBsYXlQYXRoU3RyKSB7XG4gICAgICAgIGNvbnN0IFtzZXJpYWxpemVkQ291bnQsIHNlcmlhbGl6ZWRDaGFuZ2VzXSA9IHJlcGxheVBhdGhTdHIuc3BsaXQoJzonKTtcbiAgICAgICAgY29uc3QgY291bnRzID0gdGhpcy5wYXJzZUNvdW50cyhzZXJpYWxpemVkQ291bnQpO1xuICAgICAgICBjb25zdCBjaGFuZ2VzID0gdGhpcy5wYXJzZUNoYW5nZXMoc2VyaWFsaXplZENoYW5nZXMpO1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZU9jY3VyZW5jZXMoY291bnRzLCBjaGFuZ2VzKTtcbiAgICB9XG4gICAgc3RhdGljIHN0cmluZ2lmeShyZXBsYXlQYXRoKSB7XG4gICAgICAgIGNvbnN0IG9jY3VyZW5jZXMgPSB0aGlzLmNvdW50T2NjdXJlbmNlcyhyZXBsYXlQYXRoKTtcbiAgICAgICAgY29uc3Qgc2VyaWFsaXplZENvdW50ID0gdGhpcy5zdHJpbmdpZnlDb3VudHMob2NjdXJlbmNlcyk7XG4gICAgICAgIGNvbnN0IHNlcmlhbGl6ZWRDaGFuZ2VzID0gdGhpcy5zdHJpbmdpZnlDaGFuZ2VzKG9jY3VyZW5jZXMpO1xuICAgICAgICByZXR1cm4gYCR7c2VyaWFsaXplZENvdW50fToke3NlcmlhbGl6ZWRDaGFuZ2VzfWA7XG4gICAgfVxuICAgIHN0YXRpYyBpbnRUb0I2NChuKSB7XG4gICAgICAgIGlmIChuIDwgMjYpXG4gICAgICAgICAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShuICsgNjUpO1xuICAgICAgICBpZiAobiA8IDUyKVxuICAgICAgICAgICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUobiArIDk3IC0gMjYpO1xuICAgICAgICBpZiAobiA8IDYyKVxuICAgICAgICAgICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUobiArIDQ4IC0gNTIpO1xuICAgICAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShuID09PSA2MiA/IDQzIDogNDcpO1xuICAgIH1cbiAgICBzdGF0aWMgYjY0VG9JbnQoYykge1xuICAgICAgICBpZiAoYyA+PSAnYScpXG4gICAgICAgICAgICByZXR1cm4gYy5jaGFyQ29kZUF0KDApIC0gOTcgKyAyNjtcbiAgICAgICAgaWYgKGMgPj0gJ0EnKVxuICAgICAgICAgICAgcmV0dXJuIGMuY2hhckNvZGVBdCgwKSAtIDY1O1xuICAgICAgICBpZiAoYyA+PSAnMCcpXG4gICAgICAgICAgICByZXR1cm4gYy5jaGFyQ29kZUF0KDApIC0gNDggKyA1MjtcbiAgICAgICAgcmV0dXJuIGMgPT09ICcrJyA/IDYyIDogNjM7XG4gICAgfVxuICAgIHN0YXRpYyBjb3VudE9jY3VyZW5jZXMocmVwbGF5UGF0aCkge1xuICAgICAgICByZXR1cm4gcmVwbGF5UGF0aC5yZWR1Y2UoKGNvdW50cywgY3VyKSA9PiB7XG4gICAgICAgICAgICBpZiAoY291bnRzLmxlbmd0aCA9PT0gMCB8fCBjb3VudHNbY291bnRzLmxlbmd0aCAtIDFdLmNvdW50ID09PSA2NCB8fCBjb3VudHNbY291bnRzLmxlbmd0aCAtIDFdLnZhbHVlICE9PSBjdXIpXG4gICAgICAgICAgICAgICAgY291bnRzLnB1c2goeyB2YWx1ZTogY3VyLCBjb3VudDogMSB9KTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBjb3VudHNbY291bnRzLmxlbmd0aCAtIDFdLmNvdW50ICs9IDE7XG4gICAgICAgICAgICByZXR1cm4gY291bnRzO1xuICAgICAgICB9LCBbXSk7XG4gICAgfVxuICAgIHN0YXRpYyBwYXJzZU9jY3VyZW5jZXMoY291bnRzLCBjaGFuZ2VzKSB7XG4gICAgICAgIGNvbnN0IHJlcGxheVBhdGggPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaWR4ID0gMDsgaWR4ICE9PSBjb3VudHMubGVuZ3RoOyArK2lkeCkge1xuICAgICAgICAgICAgY29uc3QgY291bnQgPSBjb3VudHNbaWR4XTtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gY2hhbmdlc1tpZHhdO1xuICAgICAgICAgICAgZm9yIChsZXQgbnVtID0gMDsgbnVtICE9PSBjb3VudDsgKytudW0pXG4gICAgICAgICAgICAgICAgcmVwbGF5UGF0aC5wdXNoKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVwbGF5UGF0aDtcbiAgICB9XG4gICAgc3RhdGljIHN0cmluZ2lmeUNoYW5nZXMob2NjdXJlbmNlcykge1xuICAgICAgICBsZXQgc2VyaWFsaXplZENoYW5nZXMgPSAnJztcbiAgICAgICAgZm9yIChsZXQgaWR4ID0gMDsgaWR4IDwgb2NjdXJlbmNlcy5sZW5ndGg7IGlkeCArPSA2KSB7XG4gICAgICAgICAgICBjb25zdCBjaGFuZ2VzSW50ID0gb2NjdXJlbmNlc1xuICAgICAgICAgICAgICAgIC5zbGljZShpZHgsIGlkeCArIDYpXG4gICAgICAgICAgICAgICAgLnJlZHVjZVJpZ2h0KChwcmV2LCBjdXIpID0+IHByZXYgKiAyICsgKGN1ci52YWx1ZSA/IDEgOiAwKSwgMCk7XG4gICAgICAgICAgICBzZXJpYWxpemVkQ2hhbmdlcyArPSB0aGlzLmludFRvQjY0KGNoYW5nZXNJbnQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzZXJpYWxpemVkQ2hhbmdlcztcbiAgICB9XG4gICAgc3RhdGljIHBhcnNlQ2hhbmdlcyhzZXJpYWxpemVkQ2hhbmdlcykge1xuICAgICAgICBjb25zdCBjaGFuZ2VzSW50ID0gc2VyaWFsaXplZENoYW5nZXMuc3BsaXQoJycpLm1hcCgoYykgPT4gdGhpcy5iNjRUb0ludChjKSk7XG4gICAgICAgIGNvbnN0IGNoYW5nZXMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaWR4ID0gMDsgaWR4ICE9PSBjaGFuZ2VzSW50Lmxlbmd0aDsgKytpZHgpIHtcbiAgICAgICAgICAgIGxldCBjdXJyZW50ID0gY2hhbmdlc0ludFtpZHhdO1xuICAgICAgICAgICAgZm9yIChsZXQgbiA9IDA7IG4gIT09IDY7ICsrbiwgY3VycmVudCA+Pj0gMSkge1xuICAgICAgICAgICAgICAgIGNoYW5nZXMucHVzaChjdXJyZW50ICUgMiA9PT0gMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNoYW5nZXM7XG4gICAgfVxuICAgIHN0YXRpYyBzdHJpbmdpZnlDb3VudHMob2NjdXJlbmNlcykge1xuICAgICAgICByZXR1cm4gb2NjdXJlbmNlcy5tYXAoKHsgY291bnQgfSkgPT4gdGhpcy5pbnRUb0I2NChjb3VudCAtIDEpKS5qb2luKCcnKTtcbiAgICB9XG4gICAgc3RhdGljIHBhcnNlQ291bnRzKHNlcmlhbGl6ZWRDb3VudCkge1xuICAgICAgICByZXR1cm4gc2VyaWFsaXplZENvdW50LnNwbGl0KCcnKS5tYXAoKGMpID0+IHRoaXMuYjY0VG9JbnQoYykgKyAxKTtcbiAgICB9XG59XG5leHBvcnRzLlJlcGxheVBhdGggPSBSZXBsYXlQYXRoO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkNvbW1hbmRXcmFwcGVyID0gdm9pZCAwO1xuY29uc3Qgc3RyaW5naWZ5XzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vdXRpbHMvc3RyaW5naWZ5XCIpO1xuY29uc3Qgc3ltYm9sc18xID0gcmVxdWlyZShcIi4uLy4uL3N5bWJvbHNcIik7XG5jbGFzcyBDb21tYW5kV3JhcHBlciB7XG4gICAgY29uc3RydWN0b3IoY21kKSB7XG4gICAgICAgIHRoaXMuY21kID0gY21kO1xuICAgICAgICB0aGlzLmhhc1JhbiA9IGZhbHNlO1xuICAgICAgICBpZiAoc3RyaW5naWZ5XzEuaGFzVG9TdHJpbmdNZXRob2QoY21kKSkge1xuICAgICAgICAgICAgY29uc3QgbWV0aG9kID0gY21kW3N0cmluZ2lmeV8xLnRvU3RyaW5nTWV0aG9kXTtcbiAgICAgICAgICAgIHRoaXNbc3RyaW5naWZ5XzEudG9TdHJpbmdNZXRob2RdID0gZnVuY3Rpb24gdG9TdHJpbmdNZXRob2QoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1ldGhvZC5jYWxsKGNtZCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdHJpbmdpZnlfMS5oYXNBc3luY1RvU3RyaW5nTWV0aG9kKGNtZCkpIHtcbiAgICAgICAgICAgIGNvbnN0IG1ldGhvZCA9IGNtZFtzdHJpbmdpZnlfMS5hc3luY1RvU3RyaW5nTWV0aG9kXTtcbiAgICAgICAgICAgIHRoaXNbc3RyaW5naWZ5XzEuYXN5bmNUb1N0cmluZ01ldGhvZF0gPSBmdW5jdGlvbiBhc3luY1RvU3RyaW5nTWV0aG9kKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBtZXRob2QuY2FsbChjbWQpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjaGVjayhtKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNtZC5jaGVjayhtKTtcbiAgICB9XG4gICAgcnVuKG0sIHIpIHtcbiAgICAgICAgdGhpcy5oYXNSYW4gPSB0cnVlO1xuICAgICAgICByZXR1cm4gdGhpcy5jbWQucnVuKG0sIHIpO1xuICAgIH1cbiAgICBjbG9uZSgpIHtcbiAgICAgICAgaWYgKHN5bWJvbHNfMS5oYXNDbG9uZU1ldGhvZCh0aGlzLmNtZCkpXG4gICAgICAgICAgICByZXR1cm4gbmV3IENvbW1hbmRXcmFwcGVyKHRoaXMuY21kW3N5bWJvbHNfMS5jbG9uZU1ldGhvZF0oKSk7XG4gICAgICAgIHJldHVybiBuZXcgQ29tbWFuZFdyYXBwZXIodGhpcy5jbWQpO1xuICAgIH1cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY21kLnRvU3RyaW5nKCk7XG4gICAgfVxufVxuZXhwb3J0cy5Db21tYW5kV3JhcHBlciA9IENvbW1hbmRXcmFwcGVyO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmNvbW1hbmRzID0gdm9pZCAwO1xuY29uc3QgU3RyZWFtXzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vc3RyZWFtL1N0cmVhbVwiKTtcbmNvbnN0IEFyYml0cmFyeV8xID0gcmVxdWlyZShcIi4uLy4uL2FyYml0cmFyeS9kZWZpbml0aW9uL0FyYml0cmFyeVwiKTtcbmNvbnN0IFNocmlua2FibGVfMSA9IHJlcXVpcmUoXCIuLi8uLi9hcmJpdHJhcnkvZGVmaW5pdGlvbi9TaHJpbmthYmxlXCIpO1xuY29uc3QgbmF0XzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vYXJiaXRyYXJ5L25hdFwiKTtcbmNvbnN0IG9uZW9mXzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vYXJiaXRyYXJ5L29uZW9mXCIpO1xuY29uc3QgUmVwbGF5UGF0aF8xID0gcmVxdWlyZShcIi4uL1JlcGxheVBhdGhcIik7XG5jb25zdCBDb21tYW5kc0l0ZXJhYmxlXzEgPSByZXF1aXJlKFwiLi9Db21tYW5kc0l0ZXJhYmxlXCIpO1xuY29uc3QgQ29tbWFuZFdyYXBwZXJfMSA9IHJlcXVpcmUoXCIuL0NvbW1hbmRXcmFwcGVyXCIpO1xuY29uc3QgTGF6eUl0ZXJhYmxlSXRlcmF0b3JfMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi9zdHJlYW0vTGF6eUl0ZXJhYmxlSXRlcmF0b3JcIik7XG5jbGFzcyBDb21tYW5kc0FyYml0cmFyeSBleHRlbmRzIEFyYml0cmFyeV8xLkFyYml0cmFyeSB7XG4gICAgY29uc3RydWN0b3IoY29tbWFuZEFyYnMsIG1heENvbW1hbmRzLCBzb3VyY2VSZXBsYXlQYXRoLCBkaXNhYmxlUmVwbGF5TG9nKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuc291cmNlUmVwbGF5UGF0aCA9IHNvdXJjZVJlcGxheVBhdGg7XG4gICAgICAgIHRoaXMuZGlzYWJsZVJlcGxheUxvZyA9IGRpc2FibGVSZXBsYXlMb2c7XG4gICAgICAgIHRoaXMub25lQ29tbWFuZEFyYiA9IG9uZW9mXzEub25lb2YoLi4uY29tbWFuZEFyYnMpLm1hcCgoYykgPT4gbmV3IENvbW1hbmRXcmFwcGVyXzEuQ29tbWFuZFdyYXBwZXIoYykpO1xuICAgICAgICB0aGlzLmxlbmd0aEFyYiA9IG5hdF8xLm5hdChtYXhDb21tYW5kcyk7XG4gICAgICAgIHRoaXMucmVwbGF5UGF0aCA9IFtdO1xuICAgICAgICB0aGlzLnJlcGxheVBhdGhQb3NpdGlvbiA9IDA7XG4gICAgfVxuICAgIG1ldGFkYXRhRm9yUmVwbGF5KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kaXNhYmxlUmVwbGF5TG9nID8gJycgOiBgcmVwbGF5UGF0aD0ke0pTT04uc3RyaW5naWZ5KFJlcGxheVBhdGhfMS5SZXBsYXlQYXRoLnN0cmluZ2lmeSh0aGlzLnJlcGxheVBhdGgpKX1gO1xuICAgIH1cbiAgICB3cmFwcGVyKGl0ZW1zLCBzaHJ1bmtPbmNlKSB7XG4gICAgICAgIHJldHVybiBuZXcgU2hyaW5rYWJsZV8xLlNocmlua2FibGUobmV3IENvbW1hbmRzSXRlcmFibGVfMS5Db21tYW5kc0l0ZXJhYmxlKGl0ZW1zLm1hcCgocykgPT4gcy52YWx1ZV8pLCAoKSA9PiB0aGlzLm1ldGFkYXRhRm9yUmVwbGF5KCkpLCAoKSA9PiB0aGlzLnNocmlua0ltcGwoaXRlbXMsIHNocnVua09uY2UpLm1hcCgodikgPT4gdGhpcy53cmFwcGVyKHYsIHRydWUpKSk7XG4gICAgfVxuICAgIGdlbmVyYXRlKG1ybmcpIHtcbiAgICAgICAgY29uc3Qgc2l6ZSA9IHRoaXMubGVuZ3RoQXJiLmdlbmVyYXRlKG1ybmcpO1xuICAgICAgICBjb25zdCBpdGVtcyA9IEFycmF5KHNpemUudmFsdWVfKTtcbiAgICAgICAgZm9yIChsZXQgaWR4ID0gMDsgaWR4ICE9PSBzaXplLnZhbHVlXzsgKytpZHgpIHtcbiAgICAgICAgICAgIGNvbnN0IGl0ZW0gPSB0aGlzLm9uZUNvbW1hbmRBcmIuZ2VuZXJhdGUobXJuZyk7XG4gICAgICAgICAgICBpdGVtc1tpZHhdID0gaXRlbTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJlcGxheVBhdGhQb3NpdGlvbiA9IDA7XG4gICAgICAgIHJldHVybiB0aGlzLndyYXBwZXIoaXRlbXMsIGZhbHNlKTtcbiAgICB9XG4gICAgZmlsdGVyT25FeGVjdXRpb24oaXRlbXNSYXcpIHtcbiAgICAgICAgY29uc3QgaXRlbXMgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCBjIG9mIGl0ZW1zUmF3KSB7XG4gICAgICAgICAgICBpZiAoYy52YWx1ZV8uaGFzUmFuKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZXBsYXlQYXRoLnB1c2godHJ1ZSk7XG4gICAgICAgICAgICAgICAgaXRlbXMucHVzaChjKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICB0aGlzLnJlcGxheVBhdGgucHVzaChmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGl0ZW1zO1xuICAgIH1cbiAgICBmaWx0ZXJPblJlcGxheShpdGVtc1Jhdykge1xuICAgICAgICByZXR1cm4gaXRlbXNSYXcuZmlsdGVyKChjLCBpZHgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHN0YXRlID0gdGhpcy5yZXBsYXlQYXRoW3RoaXMucmVwbGF5UGF0aFBvc2l0aW9uICsgaWR4XTtcbiAgICAgICAgICAgIGlmIChzdGF0ZSA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVG9vIHNob3J0IHJlcGxheVBhdGhgKTtcbiAgICAgICAgICAgIGlmICghc3RhdGUgJiYgYy52YWx1ZV8uaGFzUmFuKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgTWlzbWF0Y2ggYmV0d2VlbiByZXBsYXlQYXRoIGFuZCByZWFsIGV4ZWN1dGlvbmApO1xuICAgICAgICAgICAgcmV0dXJuIHN0YXRlO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZmlsdGVyRm9yU2hyaW5rSW1wbChpdGVtc1Jhdykge1xuICAgICAgICBpZiAodGhpcy5yZXBsYXlQYXRoUG9zaXRpb24gPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMucmVwbGF5UGF0aCA9IHRoaXMuc291cmNlUmVwbGF5UGF0aCAhPT0gbnVsbCA/IFJlcGxheVBhdGhfMS5SZXBsYXlQYXRoLnBhcnNlKHRoaXMuc291cmNlUmVwbGF5UGF0aCkgOiBbXTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBpdGVtcyA9IHRoaXMucmVwbGF5UGF0aFBvc2l0aW9uIDwgdGhpcy5yZXBsYXlQYXRoLmxlbmd0aFxuICAgICAgICAgICAgPyB0aGlzLmZpbHRlck9uUmVwbGF5KGl0ZW1zUmF3KVxuICAgICAgICAgICAgOiB0aGlzLmZpbHRlck9uRXhlY3V0aW9uKGl0ZW1zUmF3KTtcbiAgICAgICAgdGhpcy5yZXBsYXlQYXRoUG9zaXRpb24gKz0gaXRlbXNSYXcubGVuZ3RoO1xuICAgICAgICByZXR1cm4gaXRlbXM7XG4gICAgfVxuICAgIHNocmlua0ltcGwoaXRlbXNSYXcsIHNocnVua09uY2UpIHtcbiAgICAgICAgY29uc3QgaXRlbXMgPSB0aGlzLmZpbHRlckZvclNocmlua0ltcGwoaXRlbXNSYXcpO1xuICAgICAgICBpZiAoaXRlbXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gU3RyZWFtXzEuU3RyZWFtLm5pbCgpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJvb3RTaHJpbmsgPSBzaHJ1bmtPbmNlXG4gICAgICAgICAgICA/IFN0cmVhbV8xLlN0cmVhbS5uaWwoKVxuICAgICAgICAgICAgOiBuZXcgU3RyZWFtXzEuU3RyZWFtKFtbXV1bU3ltYm9sLml0ZXJhdG9yXSgpKTtcbiAgICAgICAgY29uc3QgbmV4dFNocmlua3MgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgbnVtVG9LZWVwID0gMDsgbnVtVG9LZWVwICE9PSBpdGVtcy5sZW5ndGg7ICsrbnVtVG9LZWVwKSB7XG4gICAgICAgICAgICBuZXh0U2hyaW5rcy5wdXNoKExhenlJdGVyYWJsZUl0ZXJhdG9yXzEubWFrZUxhenkoKCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHNpemUgPSB0aGlzLmxlbmd0aEFyYi5jb250ZXh0dWFsU2hyaW5rYWJsZUZvcihpdGVtcy5sZW5ndGggLSAxIC0gbnVtVG9LZWVwKTtcbiAgICAgICAgICAgICAgICBjb25zdCBmaXhlZFN0YXJ0ID0gaXRlbXMuc2xpY2UoMCwgbnVtVG9LZWVwKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gc2l6ZS5zaHJpbmsoKS5tYXAoKGwpID0+IGZpeGVkU3RhcnQuY29uY2F0KGl0ZW1zLnNsaWNlKGl0ZW1zLmxlbmd0aCAtIChsLnZhbHVlICsgMSkpKSk7XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgaXRlbUF0ID0gMDsgaXRlbUF0ICE9PSBpdGVtcy5sZW5ndGg7ICsraXRlbUF0KSB7XG4gICAgICAgICAgICBuZXh0U2hyaW5rcy5wdXNoKExhenlJdGVyYWJsZUl0ZXJhdG9yXzEubWFrZUxhenkoKCkgPT4gaXRlbXNbaXRlbUF0XS5zaHJpbmsoKS5tYXAoKHYpID0+IGl0ZW1zLnNsaWNlKDAsIGl0ZW1BdCkuY29uY2F0KFt2XSwgaXRlbXMuc2xpY2UoaXRlbUF0ICsgMSkpKSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByb290U2hyaW5rLmpvaW4oLi4ubmV4dFNocmlua3MpLm1hcCgoc2hyaW5rYWJsZXMpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBzaHJpbmthYmxlcy5tYXAoKGMpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFNocmlua2FibGVfMS5TaHJpbmthYmxlKGMudmFsdWVfLmNsb25lKCksIGMuc2hyaW5rKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG59XG5mdW5jdGlvbiBjb21tYW5kcyhjb21tYW5kQXJicywgY29uc3RyYWludHMpIHtcbiAgICBjb25zdCBjb25maWcgPSBjb25zdHJhaW50cyA9PSBudWxsID8ge30gOiB0eXBlb2YgY29uc3RyYWludHMgPT09ICdudW1iZXInID8geyBtYXhDb21tYW5kczogY29uc3RyYWludHMgfSA6IGNvbnN0cmFpbnRzO1xuICAgIHJldHVybiBuZXcgQ29tbWFuZHNBcmJpdHJhcnkoY29tbWFuZEFyYnMsIGNvbmZpZy5tYXhDb21tYW5kcyAhPSBudWxsID8gY29uZmlnLm1heENvbW1hbmRzIDogMTAsIGNvbmZpZy5yZXBsYXlQYXRoICE9IG51bGwgPyBjb25maWcucmVwbGF5UGF0aCA6IG51bGwsICEhY29uZmlnLmRpc2FibGVSZXBsYXlMb2cpO1xufVxuZXhwb3J0cy5jb21tYW5kcyA9IGNvbW1hbmRzO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkNvbW1hbmRzSXRlcmFibGUgPSB2b2lkIDA7XG5jb25zdCBzeW1ib2xzXzEgPSByZXF1aXJlKFwiLi4vLi4vc3ltYm9sc1wiKTtcbmNsYXNzIENvbW1hbmRzSXRlcmFibGUge1xuICAgIGNvbnN0cnVjdG9yKGNvbW1hbmRzLCBtZXRhZGF0YUZvclJlcGxheSkge1xuICAgICAgICB0aGlzLmNvbW1hbmRzID0gY29tbWFuZHM7XG4gICAgICAgIHRoaXMubWV0YWRhdGFGb3JSZXBsYXkgPSBtZXRhZGF0YUZvclJlcGxheTtcbiAgICB9XG4gICAgW1N5bWJvbC5pdGVyYXRvcl0oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbW1hbmRzW1N5bWJvbC5pdGVyYXRvcl0oKTtcbiAgICB9XG4gICAgW3N5bWJvbHNfMS5jbG9uZU1ldGhvZF0oKSB7XG4gICAgICAgIHJldHVybiBuZXcgQ29tbWFuZHNJdGVyYWJsZSh0aGlzLmNvbW1hbmRzLm1hcCgoYykgPT4gYy5jbG9uZSgpKSwgdGhpcy5tZXRhZGF0YUZvclJlcGxheSk7XG4gICAgfVxuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICBjb25zdCBzZXJpYWxpemVkQ29tbWFuZHMgPSB0aGlzLmNvbW1hbmRzXG4gICAgICAgICAgICAuZmlsdGVyKChjKSA9PiBjLmhhc1JhbilcbiAgICAgICAgICAgIC5tYXAoKGMpID0+IGMudG9TdHJpbmcoKSlcbiAgICAgICAgICAgIC5qb2luKCcsJyk7XG4gICAgICAgIGNvbnN0IG1ldGFkYXRhID0gdGhpcy5tZXRhZGF0YUZvclJlcGxheSgpO1xuICAgICAgICByZXR1cm4gbWV0YWRhdGEubGVuZ3RoICE9PSAwID8gYCR7c2VyaWFsaXplZENvbW1hbmRzfSAvKiR7bWV0YWRhdGF9Ki9gIDogc2VyaWFsaXplZENvbW1hbmRzO1xuICAgIH1cbn1cbmV4cG9ydHMuQ29tbWFuZHNJdGVyYWJsZSA9IENvbW1hbmRzSXRlcmFibGU7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuc2NoZWR1bGVDb21tYW5kcyA9IGV4cG9ydHMuU2NoZWR1bGVkQ29tbWFuZCA9IHZvaWQgMDtcbmNsYXNzIFNjaGVkdWxlZENvbW1hbmQge1xuICAgIGNvbnN0cnVjdG9yKHMsIGNtZCkge1xuICAgICAgICB0aGlzLnMgPSBzO1xuICAgICAgICB0aGlzLmNtZCA9IGNtZDtcbiAgICB9XG4gICAgYXN5bmMgY2hlY2sobSkge1xuICAgICAgICBsZXQgZXJyb3IgPSBudWxsO1xuICAgICAgICBsZXQgY2hlY2tQYXNzZWQgPSBmYWxzZTtcbiAgICAgICAgY29uc3Qgc3RhdHVzID0gYXdhaXQgdGhpcy5zLnNjaGVkdWxlU2VxdWVuY2UoW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGxhYmVsOiBgY2hlY2tAJHt0aGlzLmNtZC50b1N0cmluZygpfWAsXG4gICAgICAgICAgICAgICAgYnVpbGRlcjogYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2hlY2tQYXNzZWQgPSBhd2FpdCBQcm9taXNlLnJlc29sdmUodGhpcy5jbWQuY2hlY2sobSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yID0gZXJyO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIF0pLnRhc2s7XG4gICAgICAgIGlmIChzdGF0dXMuZmF1bHR5KSB7XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2hlY2tQYXNzZWQ7XG4gICAgfVxuICAgIGFzeW5jIHJ1bihtLCByKSB7XG4gICAgICAgIGxldCBlcnJvciA9IG51bGw7XG4gICAgICAgIGNvbnN0IHN0YXR1cyA9IGF3YWl0IHRoaXMucy5zY2hlZHVsZVNlcXVlbmNlKFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBsYWJlbDogYHJ1bkAke3RoaXMuY21kLnRvU3RyaW5nKCl9YCxcbiAgICAgICAgICAgICAgICBidWlsZGVyOiBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLmNtZC5ydW4obSwgcik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3IgPSBlcnI7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgXSkudGFzaztcbiAgICAgICAgaWYgKHN0YXR1cy5mYXVsdHkpIHtcbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5TY2hlZHVsZWRDb21tYW5kID0gU2NoZWR1bGVkQ29tbWFuZDtcbmNvbnN0IHNjaGVkdWxlQ29tbWFuZHMgPSBmdW5jdGlvbiogKHMsIGNtZHMpIHtcbiAgICBmb3IgKGNvbnN0IGNtZCBvZiBjbWRzKSB7XG4gICAgICAgIHlpZWxkIG5ldyBTY2hlZHVsZWRDb21tYW5kKHMsIGNtZCk7XG4gICAgfVxufTtcbmV4cG9ydHMuc2NoZWR1bGVDb21tYW5kcyA9IHNjaGVkdWxlQ29tbWFuZHM7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMucHJlID0gdm9pZCAwO1xuY29uc3QgUHJlY29uZGl0aW9uRmFpbHVyZV8xID0gcmVxdWlyZShcIi4vUHJlY29uZGl0aW9uRmFpbHVyZVwiKTtcbmZ1bmN0aW9uIHByZShleHBlY3RUcnV0aHkpIHtcbiAgICBpZiAoIWV4cGVjdFRydXRoeSkge1xuICAgICAgICB0aHJvdyBuZXcgUHJlY29uZGl0aW9uRmFpbHVyZV8xLlByZWNvbmRpdGlvbkZhaWx1cmUoKTtcbiAgICB9XG59XG5leHBvcnRzLnByZSA9IHByZTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5QcmVjb25kaXRpb25GYWlsdXJlID0gdm9pZCAwO1xuY2xhc3MgUHJlY29uZGl0aW9uRmFpbHVyZSBleHRlbmRzIEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihpbnRlcnJ1cHRFeGVjdXRpb24gPSBmYWxzZSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmludGVycnVwdEV4ZWN1dGlvbiA9IGludGVycnVwdEV4ZWN1dGlvbjtcbiAgICAgICAgdGhpcy5mb290cHJpbnQgPSBQcmVjb25kaXRpb25GYWlsdXJlLlNoYXJlZEZvb3RQcmludDtcbiAgICB9XG4gICAgc3RhdGljIGlzRmFpbHVyZShlcnIpIHtcbiAgICAgICAgcmV0dXJuIGVyciAhPSBudWxsICYmIGVyci5mb290cHJpbnQgPT09IFByZWNvbmRpdGlvbkZhaWx1cmUuU2hhcmVkRm9vdFByaW50O1xuICAgIH1cbn1cbmV4cG9ydHMuUHJlY29uZGl0aW9uRmFpbHVyZSA9IFByZWNvbmRpdGlvbkZhaWx1cmU7XG5QcmVjb25kaXRpb25GYWlsdXJlLlNoYXJlZEZvb3RQcmludCA9IFN5bWJvbCgnZmFzdC1jaGVjay9QcmVjb25kaXRpb25GYWlsdXJlJyk7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuYXN5bmNQcm9wZXJ0eSA9IHZvaWQgMDtcbmNvbnN0IGdlbmVyaWNUdXBsZV8xID0gcmVxdWlyZShcIi4uLy4uL2FyYml0cmFyeS9nZW5lcmljVHVwbGVcIik7XG5jb25zdCBBc3luY1Byb3BlcnR5X2dlbmVyaWNfMSA9IHJlcXVpcmUoXCIuL0FzeW5jUHJvcGVydHkuZ2VuZXJpY1wiKTtcbmZ1bmN0aW9uIGFzeW5jUHJvcGVydHkoLi4uYXJncykge1xuICAgIGlmIChhcmdzLmxlbmd0aCA8IDIpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignYXN5bmNQcm9wZXJ0eSBleHBlY3RzIGF0IGxlYXN0IHR3byBwYXJhbWV0ZXJzJyk7XG4gICAgY29uc3QgYXJicyA9IGFyZ3Muc2xpY2UoMCwgYXJncy5sZW5ndGggLSAxKTtcbiAgICBjb25zdCBwID0gYXJnc1thcmdzLmxlbmd0aCAtIDFdO1xuICAgIHJldHVybiBuZXcgQXN5bmNQcm9wZXJ0eV9nZW5lcmljXzEuQXN5bmNQcm9wZXJ0eShnZW5lcmljVHVwbGVfMS5nZW5lcmljVHVwbGUoYXJicyksIHQgPT4gcCguLi50KSk7XG59XG5leHBvcnRzLmFzeW5jUHJvcGVydHkgPSBhc3luY1Byb3BlcnR5O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkFzeW5jUHJvcGVydHkgPSB2b2lkIDA7XG5jb25zdCBQcmVjb25kaXRpb25GYWlsdXJlXzEgPSByZXF1aXJlKFwiLi4vcHJlY29uZGl0aW9uL1ByZWNvbmRpdGlvbkZhaWx1cmVcIik7XG5jb25zdCBJUmF3UHJvcGVydHlfMSA9IHJlcXVpcmUoXCIuL0lSYXdQcm9wZXJ0eVwiKTtcbmNvbnN0IEdsb2JhbFBhcmFtZXRlcnNfMSA9IHJlcXVpcmUoXCIuLi9ydW5uZXIvY29uZmlndXJhdGlvbi9HbG9iYWxQYXJhbWV0ZXJzXCIpO1xuY29uc3QgQ29udmVydGVyRnJvbU5leHRfMSA9IHJlcXVpcmUoXCIuLi9hcmJpdHJhcnkvZGVmaW5pdGlvbi9Db252ZXJ0ZXJGcm9tTmV4dFwiKTtcbmNsYXNzIEFzeW5jUHJvcGVydHkge1xuICAgIGNvbnN0cnVjdG9yKGFyYiwgcHJlZGljYXRlKSB7XG4gICAgICAgIHRoaXMuYXJiID0gYXJiO1xuICAgICAgICB0aGlzLnByZWRpY2F0ZSA9IHByZWRpY2F0ZTtcbiAgICAgICAgdGhpcy5pc0FzeW5jID0gKCkgPT4gdHJ1ZTtcbiAgICAgICAgY29uc3QgeyBhc3luY0JlZm9yZUVhY2gsIGFzeW5jQWZ0ZXJFYWNoLCBiZWZvcmVFYWNoLCBhZnRlckVhY2ggfSA9IEdsb2JhbFBhcmFtZXRlcnNfMS5yZWFkQ29uZmlndXJlR2xvYmFsKCkgfHwge307XG4gICAgICAgIGlmIChhc3luY0JlZm9yZUVhY2ggIT09IHVuZGVmaW5lZCAmJiBiZWZvcmVFYWNoICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKCdHbG9iYWwgXCJhc3luY0JlZm9yZUVhY2hcIiBhbmQgXCJiZWZvcmVFYWNoXCIgcGFyYW1ldGVycyBjYW5cXCd0IGJlIHNldCBhdCB0aGUgc2FtZSB0aW1lIHdoZW4gcnVubmluZyBhc3luYyBwcm9wZXJ0aWVzJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFzeW5jQWZ0ZXJFYWNoICE9PSB1bmRlZmluZWQgJiYgYWZ0ZXJFYWNoICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKCdHbG9iYWwgXCJhc3luY0FmdGVyRWFjaFwiIGFuZCBcImFmdGVyRWFjaFwiIHBhcmFtZXRlcnMgY2FuXFwndCBiZSBzZXQgYXQgdGhlIHNhbWUgdGltZSB3aGVuIHJ1bm5pbmcgYXN5bmMgcHJvcGVydGllcycpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYmVmb3JlRWFjaEhvb2sgPSBhc3luY0JlZm9yZUVhY2ggfHwgYmVmb3JlRWFjaCB8fCBBc3luY1Byb3BlcnR5LmR1bW15SG9vaztcbiAgICAgICAgdGhpcy5hZnRlckVhY2hIb29rID0gYXN5bmNBZnRlckVhY2ggfHwgYWZ0ZXJFYWNoIHx8IEFzeW5jUHJvcGVydHkuZHVtbXlIb29rO1xuICAgIH1cbiAgICBnZW5lcmF0ZShtcm5nLCBydW5JZCkge1xuICAgICAgICBpZiAoQ29udmVydGVyRnJvbU5leHRfMS5Db252ZXJ0ZXJGcm9tTmV4dC5pc0NvbnZlcnRlckZyb21OZXh0KHRoaXMuYXJiKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYXJiLnRvU2hyaW5rYWJsZSh0aGlzLmFyYi5hcmIuZ2VuZXJhdGUobXJuZywgcnVuSWQgIT0gbnVsbCA/IElSYXdQcm9wZXJ0eV8xLnJ1bklkVG9GcmVxdWVuY3kocnVuSWQpIDogdW5kZWZpbmVkKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJ1bklkICE9IG51bGwgPyB0aGlzLmFyYi53aXRoQmlhcyhJUmF3UHJvcGVydHlfMS5ydW5JZFRvRnJlcXVlbmN5KHJ1bklkKSkuZ2VuZXJhdGUobXJuZykgOiB0aGlzLmFyYi5nZW5lcmF0ZShtcm5nKTtcbiAgICB9XG4gICAgYXN5bmMgcnVuKHYpIHtcbiAgICAgICAgYXdhaXQgdGhpcy5iZWZvcmVFYWNoSG9vaygpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3Qgb3V0cHV0ID0gYXdhaXQgdGhpcy5wcmVkaWNhdGUodik7XG4gICAgICAgICAgICByZXR1cm4gb3V0cHV0ID09IG51bGwgfHwgb3V0cHV0ID09PSB0cnVlID8gbnVsbCA6ICdQcm9wZXJ0eSBmYWlsZWQgYnkgcmV0dXJuaW5nIGZhbHNlJztcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBpZiAoUHJlY29uZGl0aW9uRmFpbHVyZV8xLlByZWNvbmRpdGlvbkZhaWx1cmUuaXNGYWlsdXJlKGVycikpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGVycjtcbiAgICAgICAgICAgIGlmIChlcnIgaW5zdGFuY2VvZiBFcnJvciAmJiBlcnIuc3RhY2spXG4gICAgICAgICAgICAgICAgcmV0dXJuIGAke2Vycn1cXG5cXG5TdGFjayB0cmFjZTogJHtlcnIuc3RhY2t9YDtcbiAgICAgICAgICAgIHJldHVybiBgJHtlcnJ9YDtcbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuYWZ0ZXJFYWNoSG9vaygpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGJlZm9yZUVhY2goaG9va0Z1bmN0aW9uKSB7XG4gICAgICAgIGNvbnN0IHByZXZpb3VzQmVmb3JlRWFjaEhvb2sgPSB0aGlzLmJlZm9yZUVhY2hIb29rO1xuICAgICAgICB0aGlzLmJlZm9yZUVhY2hIb29rID0gKCkgPT4gaG9va0Z1bmN0aW9uKHByZXZpb3VzQmVmb3JlRWFjaEhvb2spO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgYWZ0ZXJFYWNoKGhvb2tGdW5jdGlvbikge1xuICAgICAgICBjb25zdCBwcmV2aW91c0FmdGVyRWFjaEhvb2sgPSB0aGlzLmFmdGVyRWFjaEhvb2s7XG4gICAgICAgIHRoaXMuYWZ0ZXJFYWNoSG9vayA9ICgpID0+IGhvb2tGdW5jdGlvbihwcmV2aW91c0FmdGVyRWFjaEhvb2spO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG59XG5leHBvcnRzLkFzeW5jUHJvcGVydHkgPSBBc3luY1Byb3BlcnR5O1xuQXN5bmNQcm9wZXJ0eS5kdW1teUhvb2sgPSAoKSA9PiB7IH07XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuYXN5bmNQcm9wZXJ0eSA9IHZvaWQgMDtcbmNvbnN0IEFzeW5jUHJvcGVydHlfZ2VuZXJhdGVkXzEgPSByZXF1aXJlKFwiLi9Bc3luY1Byb3BlcnR5LmdlbmVyYXRlZFwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImFzeW5jUHJvcGVydHlcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIEFzeW5jUHJvcGVydHlfZ2VuZXJhdGVkXzEuYXN5bmNQcm9wZXJ0eTsgfSB9KTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5ydW5JZFRvRnJlcXVlbmN5ID0gdm9pZCAwO1xuY29uc3QgcnVuSWRUb0ZyZXF1ZW5jeSA9IChydW5JZCkgPT4gMiArIE1hdGguZmxvb3IoTWF0aC5sb2cocnVuSWQgKyAxKSAvIE1hdGgubG9nKDEwKSk7XG5leHBvcnRzLnJ1bklkVG9GcmVxdWVuY3kgPSBydW5JZFRvRnJlcXVlbmN5O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLklnbm9yZUVxdWFsVmFsdWVzUHJvcGVydHkgPSB2b2lkIDA7XG5jb25zdCBzdHJpbmdpZnlfMSA9IHJlcXVpcmUoXCIuLi8uLi91dGlscy9zdHJpbmdpZnlcIik7XG5jb25zdCBQcmVjb25kaXRpb25GYWlsdXJlXzEgPSByZXF1aXJlKFwiLi4vcHJlY29uZGl0aW9uL1ByZWNvbmRpdGlvbkZhaWx1cmVcIik7XG5mdW5jdGlvbiBmcm9tU3luY0NhY2hlZChjYWNoZWRWYWx1ZSkge1xuICAgIHJldHVybiBjYWNoZWRWYWx1ZSA9PT0gbnVsbCA/IG5ldyBQcmVjb25kaXRpb25GYWlsdXJlXzEuUHJlY29uZGl0aW9uRmFpbHVyZSgpIDogY2FjaGVkVmFsdWU7XG59XG5mdW5jdGlvbiBmcm9tQ2FjaGVkKC4uLmRhdGEpIHtcbiAgICBpZiAoZGF0YVsxXSlcbiAgICAgICAgcmV0dXJuIGRhdGFbMF0udGhlbihmcm9tU3luY0NhY2hlZCk7XG4gICAgcmV0dXJuIGZyb21TeW5jQ2FjaGVkKGRhdGFbMF0pO1xufVxuZnVuY3Rpb24gZnJvbUNhY2hlZFVuc2FmZShjYWNoZWRWYWx1ZSwgaXNBc3luYykge1xuICAgIHJldHVybiBmcm9tQ2FjaGVkKGNhY2hlZFZhbHVlLCBpc0FzeW5jKTtcbn1cbmNsYXNzIElnbm9yZUVxdWFsVmFsdWVzUHJvcGVydHkge1xuICAgIGNvbnN0cnVjdG9yKHByb3BlcnR5LCBza2lwUnVucykge1xuICAgICAgICB0aGlzLnByb3BlcnR5ID0gcHJvcGVydHk7XG4gICAgICAgIHRoaXMuc2tpcFJ1bnMgPSBza2lwUnVucztcbiAgICAgICAgdGhpcy5jb3ZlcmVkQ2FzZXMgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuaXNBc3luYyA9ICgpID0+IHRoaXMucHJvcGVydHkuaXNBc3luYygpO1xuICAgICAgICB0aGlzLmdlbmVyYXRlID0gKG1ybmcsIHJ1bklkKSA9PiB0aGlzLnByb3BlcnR5LmdlbmVyYXRlKG1ybmcsIHJ1bklkKTtcbiAgICAgICAgdGhpcy5ydW4gPSAodikgPT4ge1xuICAgICAgICAgICAgY29uc3Qgc3RyaW5naWZpZWRWYWx1ZSA9IHN0cmluZ2lmeV8xLnN0cmluZ2lmeSh2KTtcbiAgICAgICAgICAgIGlmICh0aGlzLmNvdmVyZWRDYXNlcy5oYXMoc3RyaW5naWZpZWRWYWx1ZSkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBsYXN0T3V0cHV0ID0gdGhpcy5jb3ZlcmVkQ2FzZXMuZ2V0KHN0cmluZ2lmaWVkVmFsdWUpO1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5za2lwUnVucykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbGFzdE91dHB1dDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZyb21DYWNoZWRVbnNhZmUobGFzdE91dHB1dCwgdGhpcy5wcm9wZXJ0eS5pc0FzeW5jKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgb3V0ID0gdGhpcy5wcm9wZXJ0eS5ydW4odik7XG4gICAgICAgICAgICB0aGlzLmNvdmVyZWRDYXNlcy5zZXQoc3RyaW5naWZpZWRWYWx1ZSwgb3V0KTtcbiAgICAgICAgICAgIHJldHVybiBvdXQ7XG4gICAgICAgIH07XG4gICAgfVxufVxuZXhwb3J0cy5JZ25vcmVFcXVhbFZhbHVlc1Byb3BlcnR5ID0gSWdub3JlRXF1YWxWYWx1ZXNQcm9wZXJ0eTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5wcm9wZXJ0eSA9IHZvaWQgMDtcbmNvbnN0IGdlbmVyaWNUdXBsZV8xID0gcmVxdWlyZShcIi4uLy4uL2FyYml0cmFyeS9nZW5lcmljVHVwbGVcIik7XG5jb25zdCBQcm9wZXJ0eV9nZW5lcmljXzEgPSByZXF1aXJlKFwiLi9Qcm9wZXJ0eS5nZW5lcmljXCIpO1xuZnVuY3Rpb24gcHJvcGVydHkoLi4uYXJncykge1xuICAgIGlmIChhcmdzLmxlbmd0aCA8IDIpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcigncHJvcGVydHkgZXhwZWN0cyBhdCBsZWFzdCB0d28gcGFyYW1ldGVycycpO1xuICAgIGNvbnN0IGFyYnMgPSBhcmdzLnNsaWNlKDAsIGFyZ3MubGVuZ3RoIC0gMSk7XG4gICAgY29uc3QgcCA9IGFyZ3NbYXJncy5sZW5ndGggLSAxXTtcbiAgICByZXR1cm4gbmV3IFByb3BlcnR5X2dlbmVyaWNfMS5Qcm9wZXJ0eShnZW5lcmljVHVwbGVfMS5nZW5lcmljVHVwbGUoYXJicyksIHQgPT4gcCguLi50KSk7XG59XG5leHBvcnRzLnByb3BlcnR5ID0gcHJvcGVydHk7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuUHJvcGVydHkgPSB2b2lkIDA7XG5jb25zdCBQcmVjb25kaXRpb25GYWlsdXJlXzEgPSByZXF1aXJlKFwiLi4vcHJlY29uZGl0aW9uL1ByZWNvbmRpdGlvbkZhaWx1cmVcIik7XG5jb25zdCBJUmF3UHJvcGVydHlfMSA9IHJlcXVpcmUoXCIuL0lSYXdQcm9wZXJ0eVwiKTtcbmNvbnN0IEdsb2JhbFBhcmFtZXRlcnNfMSA9IHJlcXVpcmUoXCIuLi9ydW5uZXIvY29uZmlndXJhdGlvbi9HbG9iYWxQYXJhbWV0ZXJzXCIpO1xuY29uc3QgQ29udmVydGVyRnJvbU5leHRfMSA9IHJlcXVpcmUoXCIuLi9hcmJpdHJhcnkvZGVmaW5pdGlvbi9Db252ZXJ0ZXJGcm9tTmV4dFwiKTtcbmNsYXNzIFByb3BlcnR5IHtcbiAgICBjb25zdHJ1Y3RvcihhcmIsIHByZWRpY2F0ZSkge1xuICAgICAgICB0aGlzLmFyYiA9IGFyYjtcbiAgICAgICAgdGhpcy5wcmVkaWNhdGUgPSBwcmVkaWNhdGU7XG4gICAgICAgIHRoaXMuaXNBc3luYyA9ICgpID0+IGZhbHNlO1xuICAgICAgICBjb25zdCB7IGJlZm9yZUVhY2ggPSBQcm9wZXJ0eS5kdW1teUhvb2ssIGFmdGVyRWFjaCA9IFByb3BlcnR5LmR1bW15SG9vaywgYXN5bmNCZWZvcmVFYWNoLCBhc3luY0FmdGVyRWFjaCwgfSA9IEdsb2JhbFBhcmFtZXRlcnNfMS5yZWFkQ29uZmlndXJlR2xvYmFsKCkgfHwge307XG4gICAgICAgIGlmIChhc3luY0JlZm9yZUVhY2ggIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgRXJyb3IoJ1wiYXN5bmNCZWZvcmVFYWNoXCIgY2FuXFwndCBiZSBzZXQgd2hlbiBydW5uaW5nIHN5bmNocm9ub3VzIHByb3BlcnRpZXMnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYXN5bmNBZnRlckVhY2ggIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgRXJyb3IoJ1wiYXN5bmNBZnRlckVhY2hcIiBjYW5cXCd0IGJlIHNldCB3aGVuIHJ1bm5pbmcgc3luY2hyb25vdXMgcHJvcGVydGllcycpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYmVmb3JlRWFjaEhvb2sgPSBiZWZvcmVFYWNoO1xuICAgICAgICB0aGlzLmFmdGVyRWFjaEhvb2sgPSBhZnRlckVhY2g7XG4gICAgfVxuICAgIGdlbmVyYXRlKG1ybmcsIHJ1bklkKSB7XG4gICAgICAgIGlmIChDb252ZXJ0ZXJGcm9tTmV4dF8xLkNvbnZlcnRlckZyb21OZXh0LmlzQ29udmVydGVyRnJvbU5leHQodGhpcy5hcmIpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hcmIudG9TaHJpbmthYmxlKHRoaXMuYXJiLmFyYi5nZW5lcmF0ZShtcm5nLCBydW5JZCAhPSBudWxsID8gSVJhd1Byb3BlcnR5XzEucnVuSWRUb0ZyZXF1ZW5jeShydW5JZCkgOiB1bmRlZmluZWQpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcnVuSWQgIT0gbnVsbCA/IHRoaXMuYXJiLndpdGhCaWFzKElSYXdQcm9wZXJ0eV8xLnJ1bklkVG9GcmVxdWVuY3kocnVuSWQpKS5nZW5lcmF0ZShtcm5nKSA6IHRoaXMuYXJiLmdlbmVyYXRlKG1ybmcpO1xuICAgIH1cbiAgICBydW4odikge1xuICAgICAgICB0aGlzLmJlZm9yZUVhY2hIb29rKCk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBvdXRwdXQgPSB0aGlzLnByZWRpY2F0ZSh2KTtcbiAgICAgICAgICAgIHJldHVybiBvdXRwdXQgPT0gbnVsbCB8fCBvdXRwdXQgPT09IHRydWUgPyBudWxsIDogJ1Byb3BlcnR5IGZhaWxlZCBieSByZXR1cm5pbmcgZmFsc2UnO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIGlmIChQcmVjb25kaXRpb25GYWlsdXJlXzEuUHJlY29uZGl0aW9uRmFpbHVyZS5pc0ZhaWx1cmUoZXJyKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZXJyO1xuICAgICAgICAgICAgaWYgKGVyciBpbnN0YW5jZW9mIEVycm9yICYmIGVyci5zdGFjaylcbiAgICAgICAgICAgICAgICByZXR1cm4gYCR7ZXJyfVxcblxcblN0YWNrIHRyYWNlOiAke2Vyci5zdGFja31gO1xuICAgICAgICAgICAgcmV0dXJuIGAke2Vycn1gO1xuICAgICAgICB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgdGhpcy5hZnRlckVhY2hIb29rKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYmVmb3JlRWFjaChob29rRnVuY3Rpb24pIHtcbiAgICAgICAgY29uc3QgcHJldmlvdXNCZWZvcmVFYWNoSG9vayA9IHRoaXMuYmVmb3JlRWFjaEhvb2s7XG4gICAgICAgIHRoaXMuYmVmb3JlRWFjaEhvb2sgPSAoKSA9PiBob29rRnVuY3Rpb24ocHJldmlvdXNCZWZvcmVFYWNoSG9vayk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBhZnRlckVhY2goaG9va0Z1bmN0aW9uKSB7XG4gICAgICAgIGNvbnN0IHByZXZpb3VzQWZ0ZXJFYWNoSG9vayA9IHRoaXMuYWZ0ZXJFYWNoSG9vaztcbiAgICAgICAgdGhpcy5hZnRlckVhY2hIb29rID0gKCkgPT4gaG9va0Z1bmN0aW9uKHByZXZpb3VzQWZ0ZXJFYWNoSG9vayk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbn1cbmV4cG9ydHMuUHJvcGVydHkgPSBQcm9wZXJ0eTtcblByb3BlcnR5LmR1bW15SG9vayA9ICgpID0+IHsgfTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5wcm9wZXJ0eSA9IHZvaWQgMDtcbmNvbnN0IFByb3BlcnR5X2dlbmVyYXRlZF8xID0gcmVxdWlyZShcIi4vUHJvcGVydHkuZ2VuZXJhdGVkXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwicHJvcGVydHlcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFByb3BlcnR5X2dlbmVyYXRlZF8xLnByb3BlcnR5OyB9IH0pO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlNraXBBZnRlclByb3BlcnR5ID0gdm9pZCAwO1xuY29uc3QgUHJlY29uZGl0aW9uRmFpbHVyZV8xID0gcmVxdWlyZShcIi4uL3ByZWNvbmRpdGlvbi9QcmVjb25kaXRpb25GYWlsdXJlXCIpO1xuY2xhc3MgU2tpcEFmdGVyUHJvcGVydHkge1xuICAgIGNvbnN0cnVjdG9yKHByb3BlcnR5LCBnZXRUaW1lLCB0aW1lTGltaXQsIGludGVycnVwdEV4ZWN1dGlvbikge1xuICAgICAgICB0aGlzLnByb3BlcnR5ID0gcHJvcGVydHk7XG4gICAgICAgIHRoaXMuZ2V0VGltZSA9IGdldFRpbWU7XG4gICAgICAgIHRoaXMuaW50ZXJydXB0RXhlY3V0aW9uID0gaW50ZXJydXB0RXhlY3V0aW9uO1xuICAgICAgICB0aGlzLmlzQXN5bmMgPSAoKSA9PiB0aGlzLnByb3BlcnR5LmlzQXN5bmMoKTtcbiAgICAgICAgdGhpcy5nZW5lcmF0ZSA9IChtcm5nLCBydW5JZCkgPT4gdGhpcy5wcm9wZXJ0eS5nZW5lcmF0ZShtcm5nLCBydW5JZCk7XG4gICAgICAgIHRoaXMucnVuID0gKHYpID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLmdldFRpbWUoKSA+PSB0aGlzLnNraXBBZnRlclRpbWUpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwcmVjb25kaXRpb25GYWlsdXJlID0gbmV3IFByZWNvbmRpdGlvbkZhaWx1cmVfMS5QcmVjb25kaXRpb25GYWlsdXJlKHRoaXMuaW50ZXJydXB0RXhlY3V0aW9uKTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5pc0FzeW5jKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShwcmVjb25kaXRpb25GYWlsdXJlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwcmVjb25kaXRpb25GYWlsdXJlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLnByb3BlcnR5LnJ1bih2KTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5za2lwQWZ0ZXJUaW1lID0gdGhpcy5nZXRUaW1lKCkgKyB0aW1lTGltaXQ7XG4gICAgfVxufVxuZXhwb3J0cy5Ta2lwQWZ0ZXJQcm9wZXJ0eSA9IFNraXBBZnRlclByb3BlcnR5O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlRpbWVvdXRQcm9wZXJ0eSA9IHZvaWQgMDtcbmNvbnN0IHRpbWVvdXRBZnRlciA9ICh0aW1lTXMpID0+IHtcbiAgICBsZXQgdGltZW91dEhhbmRsZSA9IG51bGw7XG4gICAgY29uc3QgcHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICAgIHRpbWVvdXRIYW5kbGUgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIHJlc29sdmUoYFByb3BlcnR5IHRpbWVvdXQ6IGV4Y2VlZGVkIGxpbWl0IG9mICR7dGltZU1zfSBtaWxsaXNlY29uZHNgKTtcbiAgICAgICAgfSwgdGltZU1zKTtcbiAgICB9KTtcbiAgICByZXR1cm4ge1xuICAgICAgICBjbGVhcjogKCkgPT4gY2xlYXJUaW1lb3V0KHRpbWVvdXRIYW5kbGUpLFxuICAgICAgICBwcm9taXNlLFxuICAgIH07XG59O1xuY2xhc3MgVGltZW91dFByb3BlcnR5IHtcbiAgICBjb25zdHJ1Y3Rvcihwcm9wZXJ0eSwgdGltZU1zKSB7XG4gICAgICAgIHRoaXMucHJvcGVydHkgPSBwcm9wZXJ0eTtcbiAgICAgICAgdGhpcy50aW1lTXMgPSB0aW1lTXM7XG4gICAgICAgIHRoaXMuaXNBc3luYyA9ICgpID0+IHRydWU7XG4gICAgfVxuICAgIGdlbmVyYXRlKG1ybmcsIHJ1bklkKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnByb3BlcnR5LmdlbmVyYXRlKG1ybmcsIHJ1bklkKTtcbiAgICB9XG4gICAgYXN5bmMgcnVuKHYpIHtcbiAgICAgICAgY29uc3QgdCA9IHRpbWVvdXRBZnRlcih0aGlzLnRpbWVNcyk7XG4gICAgICAgIGNvbnN0IHByb3BSdW4gPSBQcm9taXNlLnJhY2UoW3RoaXMucHJvcGVydHkucnVuKHYpLCB0LnByb21pc2VdKTtcbiAgICAgICAgcHJvcFJ1bi50aGVuKHQuY2xlYXIsIHQuY2xlYXIpO1xuICAgICAgICByZXR1cm4gcHJvcFJ1bjtcbiAgICB9XG59XG5leHBvcnRzLlRpbWVvdXRQcm9wZXJ0eSA9IFRpbWVvdXRQcm9wZXJ0eTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5VbmJpYXNlZFByb3BlcnR5ID0gdm9pZCAwO1xuY2xhc3MgVW5iaWFzZWRQcm9wZXJ0eSB7XG4gICAgY29uc3RydWN0b3IocHJvcGVydHkpIHtcbiAgICAgICAgdGhpcy5wcm9wZXJ0eSA9IHByb3BlcnR5O1xuICAgICAgICB0aGlzLmlzQXN5bmMgPSAoKSA9PiB0aGlzLnByb3BlcnR5LmlzQXN5bmMoKTtcbiAgICAgICAgdGhpcy5nZW5lcmF0ZSA9IChtcm5nLCBfcnVuSWQpID0+IHRoaXMucHJvcGVydHkuZ2VuZXJhdGUobXJuZyk7XG4gICAgICAgIHRoaXMucnVuID0gKHYpID0+IHRoaXMucHJvcGVydHkucnVuKHYpO1xuICAgIH1cbn1cbmV4cG9ydHMuVW5iaWFzZWRQcm9wZXJ0eSA9IFVuYmlhc2VkUHJvcGVydHk7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZGVjb3JhdGVQcm9wZXJ0eSA9IHZvaWQgMDtcbmNvbnN0IFNraXBBZnRlclByb3BlcnR5XzEgPSByZXF1aXJlKFwiLi4vcHJvcGVydHkvU2tpcEFmdGVyUHJvcGVydHlcIik7XG5jb25zdCBUaW1lb3V0UHJvcGVydHlfMSA9IHJlcXVpcmUoXCIuLi9wcm9wZXJ0eS9UaW1lb3V0UHJvcGVydHlcIik7XG5jb25zdCBVbmJpYXNlZFByb3BlcnR5XzEgPSByZXF1aXJlKFwiLi4vcHJvcGVydHkvVW5iaWFzZWRQcm9wZXJ0eVwiKTtcbmNvbnN0IElnbm9yZUVxdWFsVmFsdWVzUHJvcGVydHlfMSA9IHJlcXVpcmUoXCIuLi9wcm9wZXJ0eS9JZ25vcmVFcXVhbFZhbHVlc1Byb3BlcnR5XCIpO1xuZnVuY3Rpb24gZGVjb3JhdGVQcm9wZXJ0eShyYXdQcm9wZXJ0eSwgcVBhcmFtcykge1xuICAgIGxldCBwcm9wID0gcmF3UHJvcGVydHk7XG4gICAgaWYgKHJhd1Byb3BlcnR5LmlzQXN5bmMoKSAmJiBxUGFyYW1zLnRpbWVvdXQgIT0gbnVsbCkge1xuICAgICAgICBwcm9wID0gbmV3IFRpbWVvdXRQcm9wZXJ0eV8xLlRpbWVvdXRQcm9wZXJ0eShwcm9wLCBxUGFyYW1zLnRpbWVvdXQpO1xuICAgIH1cbiAgICBpZiAocVBhcmFtcy51bmJpYXNlZCkge1xuICAgICAgICBwcm9wID0gbmV3IFVuYmlhc2VkUHJvcGVydHlfMS5VbmJpYXNlZFByb3BlcnR5KHByb3ApO1xuICAgIH1cbiAgICBpZiAocVBhcmFtcy5za2lwQWxsQWZ0ZXJUaW1lTGltaXQgIT0gbnVsbCkge1xuICAgICAgICBwcm9wID0gbmV3IFNraXBBZnRlclByb3BlcnR5XzEuU2tpcEFmdGVyUHJvcGVydHkocHJvcCwgRGF0ZS5ub3csIHFQYXJhbXMuc2tpcEFsbEFmdGVyVGltZUxpbWl0LCBmYWxzZSk7XG4gICAgfVxuICAgIGlmIChxUGFyYW1zLmludGVycnVwdEFmdGVyVGltZUxpbWl0ICE9IG51bGwpIHtcbiAgICAgICAgcHJvcCA9IG5ldyBTa2lwQWZ0ZXJQcm9wZXJ0eV8xLlNraXBBZnRlclByb3BlcnR5KHByb3AsIERhdGUubm93LCBxUGFyYW1zLmludGVycnVwdEFmdGVyVGltZUxpbWl0LCB0cnVlKTtcbiAgICB9XG4gICAgaWYgKHFQYXJhbXMuc2tpcEVxdWFsVmFsdWVzKSB7XG4gICAgICAgIHByb3AgPSBuZXcgSWdub3JlRXF1YWxWYWx1ZXNQcm9wZXJ0eV8xLklnbm9yZUVxdWFsVmFsdWVzUHJvcGVydHkocHJvcCwgdHJ1ZSk7XG4gICAgfVxuICAgIGlmIChxUGFyYW1zLmlnbm9yZUVxdWFsVmFsdWVzKSB7XG4gICAgICAgIHByb3AgPSBuZXcgSWdub3JlRXF1YWxWYWx1ZXNQcm9wZXJ0eV8xLklnbm9yZUVxdWFsVmFsdWVzUHJvcGVydHkocHJvcCwgZmFsc2UpO1xuICAgIH1cbiAgICByZXR1cm4gcHJvcDtcbn1cbmV4cG9ydHMuZGVjb3JhdGVQcm9wZXJ0eSA9IGRlY29yYXRlUHJvcGVydHk7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuYXNzZXJ0ID0gZXhwb3J0cy5jaGVjayA9IHZvaWQgMDtcbmNvbnN0IFN0cmVhbV8xID0gcmVxdWlyZShcIi4uLy4uL3N0cmVhbS9TdHJlYW1cIik7XG5jb25zdCBTaHJpbmthYmxlXzEgPSByZXF1aXJlKFwiLi4vYXJiaXRyYXJ5L2RlZmluaXRpb24vU2hyaW5rYWJsZVwiKTtcbmNvbnN0IEdsb2JhbFBhcmFtZXRlcnNfMSA9IHJlcXVpcmUoXCIuL2NvbmZpZ3VyYXRpb24vR2xvYmFsUGFyYW1ldGVyc1wiKTtcbmNvbnN0IFF1YWxpZmllZFBhcmFtZXRlcnNfMSA9IHJlcXVpcmUoXCIuL2NvbmZpZ3VyYXRpb24vUXVhbGlmaWVkUGFyYW1ldGVyc1wiKTtcbmNvbnN0IERlY29yYXRlUHJvcGVydHlfMSA9IHJlcXVpcmUoXCIuL0RlY29yYXRlUHJvcGVydHlcIik7XG5jb25zdCBSdW5uZXJJdGVyYXRvcl8xID0gcmVxdWlyZShcIi4vUnVubmVySXRlcmF0b3JcIik7XG5jb25zdCBTb3VyY2VWYWx1ZXNJdGVyYXRvcl8xID0gcmVxdWlyZShcIi4vU291cmNlVmFsdWVzSXRlcmF0b3JcIik7XG5jb25zdCBUb3NzZXJfMSA9IHJlcXVpcmUoXCIuL1Rvc3NlclwiKTtcbmNvbnN0IFBhdGhXYWxrZXJfMSA9IHJlcXVpcmUoXCIuL3V0aWxzL1BhdGhXYWxrZXJcIik7XG5jb25zdCBSdW5EZXRhaWxzRm9ybWF0dGVyXzEgPSByZXF1aXJlKFwiLi91dGlscy9SdW5EZXRhaWxzRm9ybWF0dGVyXCIpO1xuZnVuY3Rpb24gcnVuSXQocHJvcGVydHksIHNvdXJjZVZhbHVlcywgdmVyYm9zZSwgaW50ZXJydXB0ZWRBc0ZhaWx1cmUpIHtcbiAgICBjb25zdCBydW5uZXIgPSBuZXcgUnVubmVySXRlcmF0b3JfMS5SdW5uZXJJdGVyYXRvcihzb3VyY2VWYWx1ZXMsIHZlcmJvc2UsIGludGVycnVwdGVkQXNGYWlsdXJlKTtcbiAgICBmb3IgKGNvbnN0IHYgb2YgcnVubmVyKSB7XG4gICAgICAgIGNvbnN0IG91dCA9IHByb3BlcnR5LnJ1bih2KTtcbiAgICAgICAgcnVubmVyLmhhbmRsZVJlc3VsdChvdXQpO1xuICAgIH1cbiAgICByZXR1cm4gcnVubmVyLnJ1bkV4ZWN1dGlvbjtcbn1cbmFzeW5jIGZ1bmN0aW9uIGFzeW5jUnVuSXQocHJvcGVydHksIHNvdXJjZVZhbHVlcywgdmVyYm9zZSwgaW50ZXJydXB0ZWRBc0ZhaWx1cmUpIHtcbiAgICBjb25zdCBydW5uZXIgPSBuZXcgUnVubmVySXRlcmF0b3JfMS5SdW5uZXJJdGVyYXRvcihzb3VyY2VWYWx1ZXMsIHZlcmJvc2UsIGludGVycnVwdGVkQXNGYWlsdXJlKTtcbiAgICBmb3IgKGNvbnN0IHYgb2YgcnVubmVyKSB7XG4gICAgICAgIGNvbnN0IG91dCA9IGF3YWl0IHByb3BlcnR5LnJ1bih2KTtcbiAgICAgICAgcnVubmVyLmhhbmRsZVJlc3VsdChvdXQpO1xuICAgIH1cbiAgICByZXR1cm4gcnVubmVyLnJ1bkV4ZWN1dGlvbjtcbn1cbmZ1bmN0aW9uIHJ1bm5lclBhdGhXYWxrZXIodmFsdWVQcm9kdWNlcnMsIHBhdGgpIHtcbiAgICBjb25zdCBwYXRoUG9pbnRzID0gcGF0aC5zcGxpdCgnOicpO1xuICAgIGNvbnN0IHBhdGhTdHJlYW0gPSBTdHJlYW1fMS5zdHJlYW0odmFsdWVQcm9kdWNlcnMpXG4gICAgICAgIC5kcm9wKHBhdGhQb2ludHMubGVuZ3RoID4gMCA/ICtwYXRoUG9pbnRzWzBdIDogMClcbiAgICAgICAgLm1hcCgocHJvZHVjZXIpID0+IHByb2R1Y2VyKCkpO1xuICAgIGNvbnN0IGFkYXB0ZWRQYXRoID0gWycwJywgLi4ucGF0aFBvaW50cy5zbGljZSgxKV0uam9pbignOicpO1xuICAgIHJldHVybiBTdHJlYW1fMS5zdHJlYW0oUGF0aFdhbGtlcl8xLnBhdGhXYWxrKGFkYXB0ZWRQYXRoLCBwYXRoU3RyZWFtKSkubWFwKCh2KSA9PiAoKSA9PiB2KTtcbn1cbmZ1bmN0aW9uIGJ1aWxkSW5pdGlhbFZhbHVlcyh2YWx1ZVByb2R1Y2VycywgcVBhcmFtcykge1xuICAgIGNvbnN0IHJhd1ZhbHVlcyA9IHFQYXJhbXMucGF0aC5sZW5ndGggPT09IDAgPyBTdHJlYW1fMS5zdHJlYW0odmFsdWVQcm9kdWNlcnMpIDogcnVubmVyUGF0aFdhbGtlcih2YWx1ZVByb2R1Y2VycywgcVBhcmFtcy5wYXRoKTtcbiAgICBpZiAoIXFQYXJhbXMuZW5kT25GYWlsdXJlKVxuICAgICAgICByZXR1cm4gcmF3VmFsdWVzO1xuICAgIHJldHVybiByYXdWYWx1ZXMubWFwKChzaHJpbmthYmxlR2VuKSA9PiB7XG4gICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBzID0gc2hyaW5rYWJsZUdlbigpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBTaHJpbmthYmxlXzEuU2hyaW5rYWJsZShzLnZhbHVlXyk7XG4gICAgICAgIH07XG4gICAgfSk7XG59XG5mdW5jdGlvbiBjaGVjayhyYXdQcm9wZXJ0eSwgcGFyYW1zKSB7XG4gICAgaWYgKHJhd1Byb3BlcnR5ID09IG51bGwgfHwgcmF3UHJvcGVydHkuZ2VuZXJhdGUgPT0gbnVsbClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHByb3BlcnR5IGVuY291bnRlcmVkLCBwbGVhc2UgdXNlIGEgdmFsaWQgcHJvcGVydHknKTtcbiAgICBpZiAocmF3UHJvcGVydHkucnVuID09IG51bGwpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBwcm9wZXJ0eSBlbmNvdW50ZXJlZCwgcGxlYXNlIHVzZSBhIHZhbGlkIHByb3BlcnR5IG5vdCBhbiBhcmJpdHJhcnknKTtcbiAgICBjb25zdCBxUGFyYW1zID0gUXVhbGlmaWVkUGFyYW1ldGVyc18xLlF1YWxpZmllZFBhcmFtZXRlcnMucmVhZChPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIEdsb2JhbFBhcmFtZXRlcnNfMS5yZWFkQ29uZmlndXJlR2xvYmFsKCkpLCBwYXJhbXMpKTtcbiAgICBpZiAocVBhcmFtcy5yZXBvcnRlciAhPT0gbnVsbCAmJiBxUGFyYW1zLmFzeW5jUmVwb3J0ZXIgIT09IG51bGwpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBwYXJhbWV0ZXJzIGVuY291bnRlcmVkLCByZXBvcnRlciBhbmQgYXN5bmNSZXBvcnRlciBjYW5ub3QgYmUgc3BlY2lmaWVkIHRvZ2V0aGVyJyk7XG4gICAgaWYgKHFQYXJhbXMuYXN5bmNSZXBvcnRlciAhPT0gbnVsbCAmJiAhcmF3UHJvcGVydHkuaXNBc3luYygpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgcGFyYW1ldGVycyBlbmNvdW50ZXJlZCwgb25seSBhc3luY1Byb3BlcnR5IGNhbiBiZSB1c2VkIHdoZW4gYXN5bmNSZXBvcnRlciBzcGVjaWZpZWQnKTtcbiAgICBjb25zdCBwcm9wZXJ0eSA9IERlY29yYXRlUHJvcGVydHlfMS5kZWNvcmF0ZVByb3BlcnR5KHJhd1Byb3BlcnR5LCBxUGFyYW1zKTtcbiAgICBjb25zdCBnZW5lcmF0b3IgPSBUb3NzZXJfMS50b3NzKHByb3BlcnR5LCBxUGFyYW1zLnNlZWQsIHFQYXJhbXMucmFuZG9tVHlwZSwgcVBhcmFtcy5leGFtcGxlcyk7XG4gICAgY29uc3QgbWF4SW5pdGlhbEl0ZXJhdGlvbnMgPSBxUGFyYW1zLnBhdGguaW5kZXhPZignOicpID09PSAtMSA/IHFQYXJhbXMubnVtUnVucyA6IC0xO1xuICAgIGNvbnN0IG1heFNraXBzID0gcVBhcmFtcy5udW1SdW5zICogcVBhcmFtcy5tYXhTa2lwc1BlclJ1bjtcbiAgICBjb25zdCBpbml0aWFsVmFsdWVzID0gYnVpbGRJbml0aWFsVmFsdWVzKGdlbmVyYXRvciwgcVBhcmFtcyk7XG4gICAgY29uc3Qgc291cmNlVmFsdWVzID0gbmV3IFNvdXJjZVZhbHVlc0l0ZXJhdG9yXzEuU291cmNlVmFsdWVzSXRlcmF0b3IoaW5pdGlhbFZhbHVlcywgbWF4SW5pdGlhbEl0ZXJhdGlvbnMsIG1heFNraXBzKTtcbiAgICByZXR1cm4gcHJvcGVydHkuaXNBc3luYygpXG4gICAgICAgID8gYXN5bmNSdW5JdChwcm9wZXJ0eSwgc291cmNlVmFsdWVzLCBxUGFyYW1zLnZlcmJvc2UsIHFQYXJhbXMubWFya0ludGVycnVwdEFzRmFpbHVyZSkudGhlbigoZSkgPT4gZS50b1J1bkRldGFpbHMocVBhcmFtcy5zZWVkLCBxUGFyYW1zLnBhdGgsIG1heFNraXBzLCBxUGFyYW1zKSlcbiAgICAgICAgOiBydW5JdChwcm9wZXJ0eSwgc291cmNlVmFsdWVzLCBxUGFyYW1zLnZlcmJvc2UsIHFQYXJhbXMubWFya0ludGVycnVwdEFzRmFpbHVyZSkudG9SdW5EZXRhaWxzKHFQYXJhbXMuc2VlZCwgcVBhcmFtcy5wYXRoLCBtYXhTa2lwcywgcVBhcmFtcyk7XG59XG5leHBvcnRzLmNoZWNrID0gY2hlY2s7XG5mdW5jdGlvbiBhc3NlcnQocHJvcGVydHksIHBhcmFtcykge1xuICAgIGNvbnN0IG91dCA9IGNoZWNrKHByb3BlcnR5LCBwYXJhbXMpO1xuICAgIGlmIChwcm9wZXJ0eS5pc0FzeW5jKCkpXG4gICAgICAgIHJldHVybiBvdXQudGhlbihSdW5EZXRhaWxzRm9ybWF0dGVyXzEuYXN5bmNSZXBvcnRSdW5EZXRhaWxzKTtcbiAgICBlbHNlXG4gICAgICAgIFJ1bkRldGFpbHNGb3JtYXR0ZXJfMS5yZXBvcnRSdW5EZXRhaWxzKG91dCk7XG59XG5leHBvcnRzLmFzc2VydCA9IGFzc2VydDtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5SdW5uZXJJdGVyYXRvciA9IHZvaWQgMDtcbmNvbnN0IFJ1bkV4ZWN1dGlvbl8xID0gcmVxdWlyZShcIi4vcmVwb3J0ZXIvUnVuRXhlY3V0aW9uXCIpO1xuY2xhc3MgUnVubmVySXRlcmF0b3Ige1xuICAgIGNvbnN0cnVjdG9yKHNvdXJjZVZhbHVlcywgdmVyYm9zZSwgaW50ZXJydXB0ZWRBc0ZhaWx1cmUpIHtcbiAgICAgICAgdGhpcy5zb3VyY2VWYWx1ZXMgPSBzb3VyY2VWYWx1ZXM7XG4gICAgICAgIHRoaXMucnVuRXhlY3V0aW9uID0gbmV3IFJ1bkV4ZWN1dGlvbl8xLlJ1bkV4ZWN1dGlvbih2ZXJib3NlLCBpbnRlcnJ1cHRlZEFzRmFpbHVyZSk7XG4gICAgICAgIHRoaXMuY3VycmVudElkeCA9IC0xO1xuICAgICAgICB0aGlzLm5leHRWYWx1ZXMgPSBzb3VyY2VWYWx1ZXM7XG4gICAgfVxuICAgIFtTeW1ib2wuaXRlcmF0b3JdKCkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgbmV4dCgpIHtcbiAgICAgICAgY29uc3QgbmV4dFZhbHVlID0gdGhpcy5uZXh0VmFsdWVzLm5leHQoKTtcbiAgICAgICAgaWYgKG5leHRWYWx1ZS5kb25lIHx8IHRoaXMucnVuRXhlY3V0aW9uLmludGVycnVwdGVkKSB7XG4gICAgICAgICAgICByZXR1cm4geyBkb25lOiB0cnVlLCB2YWx1ZTogdW5kZWZpbmVkIH07XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jdXJyZW50U2hyaW5rYWJsZSA9IG5leHRWYWx1ZS52YWx1ZTtcbiAgICAgICAgKyt0aGlzLmN1cnJlbnRJZHg7XG4gICAgICAgIHJldHVybiB7IGRvbmU6IGZhbHNlLCB2YWx1ZTogbmV4dFZhbHVlLnZhbHVlLnZhbHVlXyB9O1xuICAgIH1cbiAgICBoYW5kbGVSZXN1bHQocmVzdWx0KSB7XG4gICAgICAgIGlmIChyZXN1bHQgIT0gbnVsbCAmJiB0eXBlb2YgcmVzdWx0ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgdGhpcy5ydW5FeGVjdXRpb24uZmFpbCh0aGlzLmN1cnJlbnRTaHJpbmthYmxlLnZhbHVlXywgdGhpcy5jdXJyZW50SWR4LCByZXN1bHQpO1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50SWR4ID0gLTE7XG4gICAgICAgICAgICB0aGlzLm5leHRWYWx1ZXMgPSB0aGlzLmN1cnJlbnRTaHJpbmthYmxlLnNocmluaygpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHJlc3VsdCAhPSBudWxsKSB7XG4gICAgICAgICAgICBpZiAoIXJlc3VsdC5pbnRlcnJ1cHRFeGVjdXRpb24pIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJ1bkV4ZWN1dGlvbi5za2lwKHRoaXMuY3VycmVudFNocmlua2FibGUudmFsdWVfKTtcbiAgICAgICAgICAgICAgICB0aGlzLnNvdXJjZVZhbHVlcy5za2lwcGVkT25lKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJ1bkV4ZWN1dGlvbi5pbnRlcnJ1cHQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMucnVuRXhlY3V0aW9uLnN1Y2Nlc3ModGhpcy5jdXJyZW50U2hyaW5rYWJsZS52YWx1ZV8pO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5SdW5uZXJJdGVyYXRvciA9IFJ1bm5lckl0ZXJhdG9yO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnN0YXRpc3RpY3MgPSBleHBvcnRzLnNhbXBsZSA9IHZvaWQgMDtcbmNvbnN0IFN0cmVhbV8xID0gcmVxdWlyZShcIi4uLy4uL3N0cmVhbS9TdHJlYW1cIik7XG5jb25zdCBQcm9wZXJ0eV9nZW5lcmljXzEgPSByZXF1aXJlKFwiLi4vcHJvcGVydHkvUHJvcGVydHkuZ2VuZXJpY1wiKTtcbmNvbnN0IFVuYmlhc2VkUHJvcGVydHlfMSA9IHJlcXVpcmUoXCIuLi9wcm9wZXJ0eS9VbmJpYXNlZFByb3BlcnR5XCIpO1xuY29uc3QgR2xvYmFsUGFyYW1ldGVyc18xID0gcmVxdWlyZShcIi4vY29uZmlndXJhdGlvbi9HbG9iYWxQYXJhbWV0ZXJzXCIpO1xuY29uc3QgUXVhbGlmaWVkUGFyYW1ldGVyc18xID0gcmVxdWlyZShcIi4vY29uZmlndXJhdGlvbi9RdWFsaWZpZWRQYXJhbWV0ZXJzXCIpO1xuY29uc3QgVG9zc2VyXzEgPSByZXF1aXJlKFwiLi9Ub3NzZXJcIik7XG5jb25zdCBQYXRoV2Fsa2VyXzEgPSByZXF1aXJlKFwiLi91dGlscy9QYXRoV2Fsa2VyXCIpO1xuZnVuY3Rpb24gdG9Qcm9wZXJ0eShnZW5lcmF0b3IsIHFQYXJhbXMpIHtcbiAgICBjb25zdCBwcm9wID0gIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChnZW5lcmF0b3IsICdpc0FzeW5jJylcbiAgICAgICAgPyBuZXcgUHJvcGVydHlfZ2VuZXJpY18xLlByb3BlcnR5KGdlbmVyYXRvciwgKCkgPT4gdHJ1ZSlcbiAgICAgICAgOiBnZW5lcmF0b3I7XG4gICAgcmV0dXJuIHFQYXJhbXMudW5iaWFzZWQgPT09IHRydWUgPyBuZXcgVW5iaWFzZWRQcm9wZXJ0eV8xLlVuYmlhc2VkUHJvcGVydHkocHJvcCkgOiBwcm9wO1xufVxuZnVuY3Rpb24gc3RyZWFtU2FtcGxlKGdlbmVyYXRvciwgcGFyYW1zKSB7XG4gICAgY29uc3QgZXh0ZW5kZWRQYXJhbXMgPSB0eXBlb2YgcGFyYW1zID09PSAnbnVtYmVyJ1xuICAgICAgICA/IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgR2xvYmFsUGFyYW1ldGVyc18xLnJlYWRDb25maWd1cmVHbG9iYWwoKSksIHsgbnVtUnVuczogcGFyYW1zIH0pIDogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBHbG9iYWxQYXJhbWV0ZXJzXzEucmVhZENvbmZpZ3VyZUdsb2JhbCgpKSwgcGFyYW1zKTtcbiAgICBjb25zdCBxUGFyYW1zID0gUXVhbGlmaWVkUGFyYW1ldGVyc18xLlF1YWxpZmllZFBhcmFtZXRlcnMucmVhZChleHRlbmRlZFBhcmFtcyk7XG4gICAgY29uc3QgdG9zc2VkVmFsdWVzID0gU3RyZWFtXzEuc3RyZWFtKFRvc3Nlcl8xLnRvc3ModG9Qcm9wZXJ0eShnZW5lcmF0b3IsIHFQYXJhbXMpLCBxUGFyYW1zLnNlZWQsIHFQYXJhbXMucmFuZG9tVHlwZSwgcVBhcmFtcy5leGFtcGxlcykpO1xuICAgIGlmIChxUGFyYW1zLnBhdGgubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiB0b3NzZWRWYWx1ZXMudGFrZShxUGFyYW1zLm51bVJ1bnMpLm1hcCgocykgPT4gcygpLnZhbHVlXyk7XG4gICAgfVxuICAgIHJldHVybiBTdHJlYW1fMS5zdHJlYW0oUGF0aFdhbGtlcl8xLnBhdGhXYWxrKHFQYXJhbXMucGF0aCwgdG9zc2VkVmFsdWVzLm1hcCgocykgPT4gcygpKSkpXG4gICAgICAgIC50YWtlKHFQYXJhbXMubnVtUnVucylcbiAgICAgICAgLm1hcCgocykgPT4gcy52YWx1ZV8pO1xufVxuZnVuY3Rpb24gc2FtcGxlKGdlbmVyYXRvciwgcGFyYW1zKSB7XG4gICAgcmV0dXJuIFsuLi5zdHJlYW1TYW1wbGUoZ2VuZXJhdG9yLCBwYXJhbXMpXTtcbn1cbmV4cG9ydHMuc2FtcGxlID0gc2FtcGxlO1xuZnVuY3Rpb24gc3RhdGlzdGljcyhnZW5lcmF0b3IsIGNsYXNzaWZ5LCBwYXJhbXMpIHtcbiAgICBjb25zdCBleHRlbmRlZFBhcmFtcyA9IHR5cGVvZiBwYXJhbXMgPT09ICdudW1iZXInXG4gICAgICAgID8gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBHbG9iYWxQYXJhbWV0ZXJzXzEucmVhZENvbmZpZ3VyZUdsb2JhbCgpKSwgeyBudW1SdW5zOiBwYXJhbXMgfSkgOiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIEdsb2JhbFBhcmFtZXRlcnNfMS5yZWFkQ29uZmlndXJlR2xvYmFsKCkpLCBwYXJhbXMpO1xuICAgIGNvbnN0IHFQYXJhbXMgPSBRdWFsaWZpZWRQYXJhbWV0ZXJzXzEuUXVhbGlmaWVkUGFyYW1ldGVycy5yZWFkKGV4dGVuZGVkUGFyYW1zKTtcbiAgICBjb25zdCByZWNvcmRlZCA9IHt9O1xuICAgIGZvciAoY29uc3QgZyBvZiBzdHJlYW1TYW1wbGUoZ2VuZXJhdG9yLCBwYXJhbXMpKSB7XG4gICAgICAgIGNvbnN0IG91dCA9IGNsYXNzaWZ5KGcpO1xuICAgICAgICBjb25zdCBjYXRlZ29yaWVzID0gQXJyYXkuaXNBcnJheShvdXQpID8gb3V0IDogW291dF07XG4gICAgICAgIGZvciAoY29uc3QgYyBvZiBjYXRlZ29yaWVzKSB7XG4gICAgICAgICAgICByZWNvcmRlZFtjXSA9IChyZWNvcmRlZFtjXSB8fCAwKSArIDE7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgZGF0YSA9IE9iamVjdC5lbnRyaWVzKHJlY29yZGVkKVxuICAgICAgICAuc29ydCgoYSwgYikgPT4gYlsxXSAtIGFbMV0pXG4gICAgICAgIC5tYXAoKGkpID0+IFtpWzBdLCBgJHsoKGlbMV0gKiAxMDAuMCkgLyBxUGFyYW1zLm51bVJ1bnMpLnRvRml4ZWQoMil9JWBdKTtcbiAgICBjb25zdCBsb25nZXN0TmFtZSA9IGRhdGEubWFwKChpKSA9PiBpWzBdLmxlbmd0aCkucmVkdWNlKChwLCBjKSA9PiBNYXRoLm1heChwLCBjKSwgMCk7XG4gICAgY29uc3QgbG9uZ2VzdFBlcmNlbnQgPSBkYXRhLm1hcCgoaSkgPT4gaVsxXS5sZW5ndGgpLnJlZHVjZSgocCwgYykgPT4gTWF0aC5tYXgocCwgYyksIDApO1xuICAgIGZvciAoY29uc3QgaXRlbSBvZiBkYXRhKSB7XG4gICAgICAgIHFQYXJhbXMubG9nZ2VyKGAke2l0ZW1bMF0ucGFkRW5kKGxvbmdlc3ROYW1lLCAnLicpfS4uJHtpdGVtWzFdLnBhZFN0YXJ0KGxvbmdlc3RQZXJjZW50LCAnLicpfWApO1xuICAgIH1cbn1cbmV4cG9ydHMuc3RhdGlzdGljcyA9IHN0YXRpc3RpY3M7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuU291cmNlVmFsdWVzSXRlcmF0b3IgPSB2b2lkIDA7XG5jbGFzcyBTb3VyY2VWYWx1ZXNJdGVyYXRvciB7XG4gICAgY29uc3RydWN0b3IoaW5pdGlhbFZhbHVlcywgbWF4SW5pdGlhbEl0ZXJhdGlvbnMsIHJlbWFpbmluZ1NraXBzKSB7XG4gICAgICAgIHRoaXMuaW5pdGlhbFZhbHVlcyA9IGluaXRpYWxWYWx1ZXM7XG4gICAgICAgIHRoaXMubWF4SW5pdGlhbEl0ZXJhdGlvbnMgPSBtYXhJbml0aWFsSXRlcmF0aW9ucztcbiAgICAgICAgdGhpcy5yZW1haW5pbmdTa2lwcyA9IHJlbWFpbmluZ1NraXBzO1xuICAgIH1cbiAgICBbU3ltYm9sLml0ZXJhdG9yXSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIG5leHQoKSB7XG4gICAgICAgIGlmICgtLXRoaXMubWF4SW5pdGlhbEl0ZXJhdGlvbnMgIT09IC0xICYmIHRoaXMucmVtYWluaW5nU2tpcHMgPj0gMCkge1xuICAgICAgICAgICAgY29uc3QgbiA9IHRoaXMuaW5pdGlhbFZhbHVlcy5uZXh0KCk7XG4gICAgICAgICAgICBpZiAoIW4uZG9uZSlcbiAgICAgICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogbi52YWx1ZSgpLCBkb25lOiBmYWxzZSB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IHZhbHVlOiB1bmRlZmluZWQsIGRvbmU6IHRydWUgfTtcbiAgICB9XG4gICAgc2tpcHBlZE9uZSgpIHtcbiAgICAgICAgLS10aGlzLnJlbWFpbmluZ1NraXBzO1xuICAgICAgICArK3RoaXMubWF4SW5pdGlhbEl0ZXJhdGlvbnM7XG4gICAgfVxufVxuZXhwb3J0cy5Tb3VyY2VWYWx1ZXNJdGVyYXRvciA9IFNvdXJjZVZhbHVlc0l0ZXJhdG9yO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnRvc3MgPSB2b2lkIDA7XG5jb25zdCBwdXJlX3JhbmRfMSA9IHJlcXVpcmUoXCJwdXJlLXJhbmRcIik7XG5jb25zdCBSYW5kb21fMSA9IHJlcXVpcmUoXCIuLi8uLi9yYW5kb20vZ2VuZXJhdG9yL1JhbmRvbVwiKTtcbmNvbnN0IFNocmlua2FibGVfMSA9IHJlcXVpcmUoXCIuLi9hcmJpdHJhcnkvZGVmaW5pdGlvbi9TaHJpbmthYmxlXCIpO1xuY29uc3QgUHVyZVJhbmRvbV8xID0gcmVxdWlyZShcIi4uLy4uL3JhbmRvbS9nZW5lcmF0b3IvUHVyZVJhbmRvbVwiKTtcbmZ1bmN0aW9uIGxhenlHZW5lcmF0ZShnZW5lcmF0b3IsIHJuZywgaWR4KSB7XG4gICAgcmV0dXJuICgpID0+IGdlbmVyYXRvci5nZW5lcmF0ZShuZXcgUmFuZG9tXzEuUmFuZG9tKHJuZyksIGlkeCk7XG59XG5mdW5jdGlvbiogdG9zcyhnZW5lcmF0b3IsIHNlZWQsIHJhbmRvbSwgZXhhbXBsZXMpIHtcbiAgICB5aWVsZCogZXhhbXBsZXMubWFwKChlKSA9PiAoKSA9PiBuZXcgU2hyaW5rYWJsZV8xLlNocmlua2FibGUoZSkpO1xuICAgIGxldCBpZHggPSAwO1xuICAgIGxldCBybmcgPSBQdXJlUmFuZG9tXzEuY29udmVydFRvUmFuZG9tR2VuZXJhdG9yKHJhbmRvbShzZWVkKSk7XG4gICAgZm9yICg7Oykge1xuICAgICAgICBybmcgPSBybmcuanVtcCA/IHJuZy5qdW1wKCkgOiBwdXJlX3JhbmRfMS5za2lwTihybmcsIDQyKTtcbiAgICAgICAgeWllbGQgbGF6eUdlbmVyYXRlKGdlbmVyYXRvciwgcm5nLCBpZHgrKyk7XG4gICAgfVxufVxuZXhwb3J0cy50b3NzID0gdG9zcztcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5yZXNldENvbmZpZ3VyZUdsb2JhbCA9IGV4cG9ydHMucmVhZENvbmZpZ3VyZUdsb2JhbCA9IGV4cG9ydHMuY29uZmlndXJlR2xvYmFsID0gdm9pZCAwO1xubGV0IGdsb2JhbFBhcmFtZXRlcnMgPSB7fTtcbmZ1bmN0aW9uIGNvbmZpZ3VyZUdsb2JhbChwYXJhbWV0ZXJzKSB7XG4gICAgZ2xvYmFsUGFyYW1ldGVycyA9IHBhcmFtZXRlcnM7XG59XG5leHBvcnRzLmNvbmZpZ3VyZUdsb2JhbCA9IGNvbmZpZ3VyZUdsb2JhbDtcbmZ1bmN0aW9uIHJlYWRDb25maWd1cmVHbG9iYWwoKSB7XG4gICAgcmV0dXJuIGdsb2JhbFBhcmFtZXRlcnM7XG59XG5leHBvcnRzLnJlYWRDb25maWd1cmVHbG9iYWwgPSByZWFkQ29uZmlndXJlR2xvYmFsO1xuZnVuY3Rpb24gcmVzZXRDb25maWd1cmVHbG9iYWwoKSB7XG4gICAgZ2xvYmFsUGFyYW1ldGVycyA9IHt9O1xufVxuZXhwb3J0cy5yZXNldENvbmZpZ3VyZUdsb2JhbCA9IHJlc2V0Q29uZmlndXJlR2xvYmFsO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlF1YWxpZmllZFBhcmFtZXRlcnMgPSB2b2lkIDA7XG5jb25zdCBwdXJlX3JhbmRfMSA9IHJlcXVpcmUoXCJwdXJlLXJhbmRcIik7XG5jb25zdCBWZXJib3NpdHlMZXZlbF8xID0gcmVxdWlyZShcIi4vVmVyYm9zaXR5TGV2ZWxcIik7XG5jbGFzcyBRdWFsaWZpZWRQYXJhbWV0ZXJzIHtcbiAgICBjb25zdHJ1Y3RvcihvcCkge1xuICAgICAgICBjb25zdCBwID0gb3AgfHwge307XG4gICAgICAgIHRoaXMuc2VlZCA9IFF1YWxpZmllZFBhcmFtZXRlcnMucmVhZFNlZWQocCk7XG4gICAgICAgIHRoaXMucmFuZG9tVHlwZSA9IFF1YWxpZmllZFBhcmFtZXRlcnMucmVhZFJhbmRvbVR5cGUocCk7XG4gICAgICAgIHRoaXMubnVtUnVucyA9IFF1YWxpZmllZFBhcmFtZXRlcnMucmVhZE51bVJ1bnMocCk7XG4gICAgICAgIHRoaXMudmVyYm9zZSA9IFF1YWxpZmllZFBhcmFtZXRlcnMucmVhZFZlcmJvc2UocCk7XG4gICAgICAgIHRoaXMubWF4U2tpcHNQZXJSdW4gPSBRdWFsaWZpZWRQYXJhbWV0ZXJzLnJlYWRPckRlZmF1bHQocCwgJ21heFNraXBzUGVyUnVuJywgMTAwKTtcbiAgICAgICAgdGhpcy50aW1lb3V0ID0gUXVhbGlmaWVkUGFyYW1ldGVycy5yZWFkT3JEZWZhdWx0KHAsICd0aW1lb3V0JywgbnVsbCk7XG4gICAgICAgIHRoaXMuc2tpcEFsbEFmdGVyVGltZUxpbWl0ID0gUXVhbGlmaWVkUGFyYW1ldGVycy5yZWFkT3JEZWZhdWx0KHAsICdza2lwQWxsQWZ0ZXJUaW1lTGltaXQnLCBudWxsKTtcbiAgICAgICAgdGhpcy5pbnRlcnJ1cHRBZnRlclRpbWVMaW1pdCA9IFF1YWxpZmllZFBhcmFtZXRlcnMucmVhZE9yRGVmYXVsdChwLCAnaW50ZXJydXB0QWZ0ZXJUaW1lTGltaXQnLCBudWxsKTtcbiAgICAgICAgdGhpcy5tYXJrSW50ZXJydXB0QXNGYWlsdXJlID0gUXVhbGlmaWVkUGFyYW1ldGVycy5yZWFkQm9vbGVhbihwLCAnbWFya0ludGVycnVwdEFzRmFpbHVyZScpO1xuICAgICAgICB0aGlzLnNraXBFcXVhbFZhbHVlcyA9IFF1YWxpZmllZFBhcmFtZXRlcnMucmVhZEJvb2xlYW4ocCwgJ3NraXBFcXVhbFZhbHVlcycpO1xuICAgICAgICB0aGlzLmlnbm9yZUVxdWFsVmFsdWVzID0gUXVhbGlmaWVkUGFyYW1ldGVycy5yZWFkQm9vbGVhbihwLCAnaWdub3JlRXF1YWxWYWx1ZXMnKTtcbiAgICAgICAgdGhpcy5sb2dnZXIgPSBRdWFsaWZpZWRQYXJhbWV0ZXJzLnJlYWRPckRlZmF1bHQocCwgJ2xvZ2dlcicsICh2KSA9PiB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyh2KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMucGF0aCA9IFF1YWxpZmllZFBhcmFtZXRlcnMucmVhZE9yRGVmYXVsdChwLCAncGF0aCcsICcnKTtcbiAgICAgICAgdGhpcy51bmJpYXNlZCA9IFF1YWxpZmllZFBhcmFtZXRlcnMucmVhZEJvb2xlYW4ocCwgJ3VuYmlhc2VkJyk7XG4gICAgICAgIHRoaXMuZXhhbXBsZXMgPSBRdWFsaWZpZWRQYXJhbWV0ZXJzLnJlYWRPckRlZmF1bHQocCwgJ2V4YW1wbGVzJywgW10pO1xuICAgICAgICB0aGlzLmVuZE9uRmFpbHVyZSA9IFF1YWxpZmllZFBhcmFtZXRlcnMucmVhZEJvb2xlYW4ocCwgJ2VuZE9uRmFpbHVyZScpO1xuICAgICAgICB0aGlzLnJlcG9ydGVyID0gUXVhbGlmaWVkUGFyYW1ldGVycy5yZWFkT3JEZWZhdWx0KHAsICdyZXBvcnRlcicsIG51bGwpO1xuICAgICAgICB0aGlzLmFzeW5jUmVwb3J0ZXIgPSBRdWFsaWZpZWRQYXJhbWV0ZXJzLnJlYWRPckRlZmF1bHQocCwgJ2FzeW5jUmVwb3J0ZXInLCBudWxsKTtcbiAgICB9XG4gICAgdG9QYXJhbWV0ZXJzKCkge1xuICAgICAgICBjb25zdCBvclVuZGVmaW5lZCA9ICh2YWx1ZSkgPT4gKHZhbHVlICE9PSBudWxsID8gdmFsdWUgOiB1bmRlZmluZWQpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc2VlZDogdGhpcy5zZWVkLFxuICAgICAgICAgICAgcmFuZG9tVHlwZTogdGhpcy5yYW5kb21UeXBlLFxuICAgICAgICAgICAgbnVtUnVuczogdGhpcy5udW1SdW5zLFxuICAgICAgICAgICAgbWF4U2tpcHNQZXJSdW46IHRoaXMubWF4U2tpcHNQZXJSdW4sXG4gICAgICAgICAgICB0aW1lb3V0OiBvclVuZGVmaW5lZCh0aGlzLnRpbWVvdXQpLFxuICAgICAgICAgICAgc2tpcEFsbEFmdGVyVGltZUxpbWl0OiBvclVuZGVmaW5lZCh0aGlzLnNraXBBbGxBZnRlclRpbWVMaW1pdCksXG4gICAgICAgICAgICBpbnRlcnJ1cHRBZnRlclRpbWVMaW1pdDogb3JVbmRlZmluZWQodGhpcy5pbnRlcnJ1cHRBZnRlclRpbWVMaW1pdCksXG4gICAgICAgICAgICBtYXJrSW50ZXJydXB0QXNGYWlsdXJlOiB0aGlzLm1hcmtJbnRlcnJ1cHRBc0ZhaWx1cmUsXG4gICAgICAgICAgICBza2lwRXF1YWxWYWx1ZXM6IHRoaXMuc2tpcEVxdWFsVmFsdWVzLFxuICAgICAgICAgICAgaWdub3JlRXF1YWxWYWx1ZXM6IHRoaXMuaWdub3JlRXF1YWxWYWx1ZXMsXG4gICAgICAgICAgICBwYXRoOiB0aGlzLnBhdGgsXG4gICAgICAgICAgICBsb2dnZXI6IHRoaXMubG9nZ2VyLFxuICAgICAgICAgICAgdW5iaWFzZWQ6IHRoaXMudW5iaWFzZWQsXG4gICAgICAgICAgICB2ZXJib3NlOiB0aGlzLnZlcmJvc2UsXG4gICAgICAgICAgICBleGFtcGxlczogdGhpcy5leGFtcGxlcyxcbiAgICAgICAgICAgIGVuZE9uRmFpbHVyZTogdGhpcy5lbmRPbkZhaWx1cmUsXG4gICAgICAgICAgICByZXBvcnRlcjogb3JVbmRlZmluZWQodGhpcy5yZXBvcnRlciksXG4gICAgICAgICAgICBhc3luY1JlcG9ydGVyOiBvclVuZGVmaW5lZCh0aGlzLmFzeW5jUmVwb3J0ZXIpLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBzdGF0aWMgcmVhZChvcCkge1xuICAgICAgICByZXR1cm4gbmV3IFF1YWxpZmllZFBhcmFtZXRlcnMob3ApO1xuICAgIH1cbn1cbmV4cG9ydHMuUXVhbGlmaWVkUGFyYW1ldGVycyA9IFF1YWxpZmllZFBhcmFtZXRlcnM7XG5RdWFsaWZpZWRQYXJhbWV0ZXJzLnJlYWRTZWVkID0gKHApID0+IHtcbiAgICBpZiAocC5zZWVkID09IG51bGwpXG4gICAgICAgIHJldHVybiBEYXRlLm5vdygpIF4gKE1hdGgucmFuZG9tKCkgKiAweDEwMDAwMDAwMCk7XG4gICAgY29uc3Qgc2VlZDMyID0gcC5zZWVkIHwgMDtcbiAgICBpZiAocC5zZWVkID09PSBzZWVkMzIpXG4gICAgICAgIHJldHVybiBzZWVkMzI7XG4gICAgY29uc3QgZ2FwID0gcC5zZWVkIC0gc2VlZDMyO1xuICAgIHJldHVybiBzZWVkMzIgXiAoZ2FwICogMHgxMDAwMDAwMDApO1xufTtcblF1YWxpZmllZFBhcmFtZXRlcnMucmVhZFJhbmRvbVR5cGUgPSAocCkgPT4ge1xuICAgIGlmIChwLnJhbmRvbVR5cGUgPT0gbnVsbClcbiAgICAgICAgcmV0dXJuIHB1cmVfcmFuZF8xLmRlZmF1bHQueG9yc2hpZnQxMjhwbHVzO1xuICAgIGlmICh0eXBlb2YgcC5yYW5kb21UeXBlID09PSAnc3RyaW5nJykge1xuICAgICAgICBzd2l0Y2ggKHAucmFuZG9tVHlwZSkge1xuICAgICAgICAgICAgY2FzZSAnbWVyc2VubmUnOlxuICAgICAgICAgICAgICAgIHJldHVybiBwdXJlX3JhbmRfMS5kZWZhdWx0Lm1lcnNlbm5lO1xuICAgICAgICAgICAgY2FzZSAnY29uZ3J1ZW50aWFsJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gcHVyZV9yYW5kXzEuZGVmYXVsdC5jb25ncnVlbnRpYWw7XG4gICAgICAgICAgICBjYXNlICdjb25ncnVlbnRpYWwzMic6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHB1cmVfcmFuZF8xLmRlZmF1bHQuY29uZ3J1ZW50aWFsMzI7XG4gICAgICAgICAgICBjYXNlICd4b3JzaGlmdDEyOHBsdXMnOlxuICAgICAgICAgICAgICAgIHJldHVybiBwdXJlX3JhbmRfMS5kZWZhdWx0LnhvcnNoaWZ0MTI4cGx1cztcbiAgICAgICAgICAgIGNhc2UgJ3hvcm9zaGlybzEyOHBsdXMnOlxuICAgICAgICAgICAgICAgIHJldHVybiBwdXJlX3JhbmRfMS5kZWZhdWx0Lnhvcm9zaGlybzEyOHBsdXM7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCByYW5kb20gc3BlY2lmaWVkOiAnJHtwLnJhbmRvbVR5cGV9J2ApO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBwLnJhbmRvbVR5cGU7XG59O1xuUXVhbGlmaWVkUGFyYW1ldGVycy5yZWFkTnVtUnVucyA9IChwKSA9PiB7XG4gICAgY29uc3QgZGVmYXVsdFZhbHVlID0gMTAwO1xuICAgIGlmIChwLm51bVJ1bnMgIT0gbnVsbClcbiAgICAgICAgcmV0dXJuIHAubnVtUnVucztcbiAgICBpZiAocC5udW1fcnVucyAhPSBudWxsKVxuICAgICAgICByZXR1cm4gcC5udW1fcnVucztcbiAgICByZXR1cm4gZGVmYXVsdFZhbHVlO1xufTtcblF1YWxpZmllZFBhcmFtZXRlcnMucmVhZFZlcmJvc2UgPSAocCkgPT4ge1xuICAgIGlmIChwLnZlcmJvc2UgPT0gbnVsbClcbiAgICAgICAgcmV0dXJuIFZlcmJvc2l0eUxldmVsXzEuVmVyYm9zaXR5TGV2ZWwuTm9uZTtcbiAgICBpZiAodHlwZW9mIHAudmVyYm9zZSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgIHJldHVybiBwLnZlcmJvc2UgPT09IHRydWUgPyBWZXJib3NpdHlMZXZlbF8xLlZlcmJvc2l0eUxldmVsLlZlcmJvc2UgOiBWZXJib3NpdHlMZXZlbF8xLlZlcmJvc2l0eUxldmVsLk5vbmU7XG4gICAgfVxuICAgIGlmIChwLnZlcmJvc2UgPD0gVmVyYm9zaXR5TGV2ZWxfMS5WZXJib3NpdHlMZXZlbC5Ob25lKSB7XG4gICAgICAgIHJldHVybiBWZXJib3NpdHlMZXZlbF8xLlZlcmJvc2l0eUxldmVsLk5vbmU7XG4gICAgfVxuICAgIGlmIChwLnZlcmJvc2UgPj0gVmVyYm9zaXR5TGV2ZWxfMS5WZXJib3NpdHlMZXZlbC5WZXJ5VmVyYm9zZSkge1xuICAgICAgICByZXR1cm4gVmVyYm9zaXR5TGV2ZWxfMS5WZXJib3NpdHlMZXZlbC5WZXJ5VmVyYm9zZTtcbiAgICB9XG4gICAgcmV0dXJuIHAudmVyYm9zZSB8IDA7XG59O1xuUXVhbGlmaWVkUGFyYW1ldGVycy5yZWFkQm9vbGVhbiA9IChwLCBrZXkpID0+IHBba2V5XSA9PT0gdHJ1ZTtcblF1YWxpZmllZFBhcmFtZXRlcnMucmVhZE9yRGVmYXVsdCA9IChwLCBrZXksIGRlZmF1bHRWYWx1ZSkgPT4ge1xuICAgIGNvbnN0IHZhbHVlID0gcFtrZXldO1xuICAgIHJldHVybiB2YWx1ZSAhPSBudWxsID8gdmFsdWUgOiBkZWZhdWx0VmFsdWU7XG59O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlZlcmJvc2l0eUxldmVsID0gdm9pZCAwO1xudmFyIFZlcmJvc2l0eUxldmVsO1xuKGZ1bmN0aW9uIChWZXJib3NpdHlMZXZlbCkge1xuICAgIFZlcmJvc2l0eUxldmVsW1ZlcmJvc2l0eUxldmVsW1wiTm9uZVwiXSA9IDBdID0gXCJOb25lXCI7XG4gICAgVmVyYm9zaXR5TGV2ZWxbVmVyYm9zaXR5TGV2ZWxbXCJWZXJib3NlXCJdID0gMV0gPSBcIlZlcmJvc2VcIjtcbiAgICBWZXJib3NpdHlMZXZlbFtWZXJib3NpdHlMZXZlbFtcIlZlcnlWZXJib3NlXCJdID0gMl0gPSBcIlZlcnlWZXJib3NlXCI7XG59KShWZXJib3NpdHlMZXZlbCA9IGV4cG9ydHMuVmVyYm9zaXR5TGV2ZWwgfHwgKGV4cG9ydHMuVmVyYm9zaXR5TGV2ZWwgPSB7fSkpO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkV4ZWN1dGlvblN0YXR1cyA9IHZvaWQgMDtcbnZhciBFeGVjdXRpb25TdGF0dXM7XG4oZnVuY3Rpb24gKEV4ZWN1dGlvblN0YXR1cykge1xuICAgIEV4ZWN1dGlvblN0YXR1c1tFeGVjdXRpb25TdGF0dXNbXCJTdWNjZXNzXCJdID0gMF0gPSBcIlN1Y2Nlc3NcIjtcbiAgICBFeGVjdXRpb25TdGF0dXNbRXhlY3V0aW9uU3RhdHVzW1wiU2tpcHBlZFwiXSA9IC0xXSA9IFwiU2tpcHBlZFwiO1xuICAgIEV4ZWN1dGlvblN0YXR1c1tFeGVjdXRpb25TdGF0dXNbXCJGYWlsdXJlXCJdID0gMV0gPSBcIkZhaWx1cmVcIjtcbn0pKEV4ZWN1dGlvblN0YXR1cyA9IGV4cG9ydHMuRXhlY3V0aW9uU3RhdHVzIHx8IChleHBvcnRzLkV4ZWN1dGlvblN0YXR1cyA9IHt9KSk7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuUnVuRXhlY3V0aW9uID0gdm9pZCAwO1xuY29uc3QgVmVyYm9zaXR5TGV2ZWxfMSA9IHJlcXVpcmUoXCIuLi9jb25maWd1cmF0aW9uL1ZlcmJvc2l0eUxldmVsXCIpO1xuY29uc3QgRXhlY3V0aW9uU3RhdHVzXzEgPSByZXF1aXJlKFwiLi9FeGVjdXRpb25TdGF0dXNcIik7XG5jbGFzcyBSdW5FeGVjdXRpb24ge1xuICAgIGNvbnN0cnVjdG9yKHZlcmJvc2l0eSwgaW50ZXJydXB0ZWRBc0ZhaWx1cmUpIHtcbiAgICAgICAgdGhpcy52ZXJib3NpdHkgPSB2ZXJib3NpdHk7XG4gICAgICAgIHRoaXMuaW50ZXJydXB0ZWRBc0ZhaWx1cmUgPSBpbnRlcnJ1cHRlZEFzRmFpbHVyZTtcbiAgICAgICAgdGhpcy5pc1N1Y2Nlc3MgPSAoKSA9PiB0aGlzLnBhdGhUb0ZhaWx1cmUgPT0gbnVsbDtcbiAgICAgICAgdGhpcy5maXJzdEZhaWx1cmUgPSAoKSA9PiAodGhpcy5wYXRoVG9GYWlsdXJlID8gK3RoaXMucGF0aFRvRmFpbHVyZS5zcGxpdCgnOicpWzBdIDogLTEpO1xuICAgICAgICB0aGlzLm51bVNocmlua3MgPSAoKSA9PiAodGhpcy5wYXRoVG9GYWlsdXJlID8gdGhpcy5wYXRoVG9GYWlsdXJlLnNwbGl0KCc6JykubGVuZ3RoIC0gMSA6IDApO1xuICAgICAgICB0aGlzLnJvb3RFeGVjdXRpb25UcmVlcyA9IFtdO1xuICAgICAgICB0aGlzLmN1cnJlbnRMZXZlbEV4ZWN1dGlvblRyZWVzID0gdGhpcy5yb290RXhlY3V0aW9uVHJlZXM7XG4gICAgICAgIHRoaXMuZmFpbHVyZSA9IG51bGw7XG4gICAgICAgIHRoaXMubnVtU2tpcHMgPSAwO1xuICAgICAgICB0aGlzLm51bVN1Y2Nlc3NlcyA9IDA7XG4gICAgICAgIHRoaXMuaW50ZXJydXB0ZWQgPSBmYWxzZTtcbiAgICB9XG4gICAgYXBwZW5kRXhlY3V0aW9uVHJlZShzdGF0dXMsIHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRUcmVlID0geyBzdGF0dXMsIHZhbHVlLCBjaGlsZHJlbjogW10gfTtcbiAgICAgICAgdGhpcy5jdXJyZW50TGV2ZWxFeGVjdXRpb25UcmVlcy5wdXNoKGN1cnJlbnRUcmVlKTtcbiAgICAgICAgcmV0dXJuIGN1cnJlbnRUcmVlO1xuICAgIH1cbiAgICBmYWlsKHZhbHVlLCBpZCwgbWVzc2FnZSkge1xuICAgICAgICBpZiAodGhpcy52ZXJib3NpdHkgPj0gVmVyYm9zaXR5TGV2ZWxfMS5WZXJib3NpdHlMZXZlbC5WZXJib3NlKSB7XG4gICAgICAgICAgICBjb25zdCBjdXJyZW50VHJlZSA9IHRoaXMuYXBwZW5kRXhlY3V0aW9uVHJlZShFeGVjdXRpb25TdGF0dXNfMS5FeGVjdXRpb25TdGF0dXMuRmFpbHVyZSwgdmFsdWUpO1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50TGV2ZWxFeGVjdXRpb25UcmVlcyA9IGN1cnJlbnRUcmVlLmNoaWxkcmVuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnBhdGhUb0ZhaWx1cmUgPT0gbnVsbClcbiAgICAgICAgICAgIHRoaXMucGF0aFRvRmFpbHVyZSA9IGAke2lkfWA7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHRoaXMucGF0aFRvRmFpbHVyZSArPSBgOiR7aWR9YDtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICB0aGlzLmZhaWx1cmUgPSBtZXNzYWdlO1xuICAgIH1cbiAgICBza2lwKHZhbHVlKSB7XG4gICAgICAgIGlmICh0aGlzLnZlcmJvc2l0eSA+PSBWZXJib3NpdHlMZXZlbF8xLlZlcmJvc2l0eUxldmVsLlZlcnlWZXJib3NlKSB7XG4gICAgICAgICAgICB0aGlzLmFwcGVuZEV4ZWN1dGlvblRyZWUoRXhlY3V0aW9uU3RhdHVzXzEuRXhlY3V0aW9uU3RhdHVzLlNraXBwZWQsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5wYXRoVG9GYWlsdXJlID09IG51bGwpIHtcbiAgICAgICAgICAgICsrdGhpcy5udW1Ta2lwcztcbiAgICAgICAgfVxuICAgIH1cbiAgICBzdWNjZXNzKHZhbHVlKSB7XG4gICAgICAgIGlmICh0aGlzLnZlcmJvc2l0eSA+PSBWZXJib3NpdHlMZXZlbF8xLlZlcmJvc2l0eUxldmVsLlZlcnlWZXJib3NlKSB7XG4gICAgICAgICAgICB0aGlzLmFwcGVuZEV4ZWN1dGlvblRyZWUoRXhlY3V0aW9uU3RhdHVzXzEuRXhlY3V0aW9uU3RhdHVzLlN1Y2Nlc3MsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5wYXRoVG9GYWlsdXJlID09IG51bGwpIHtcbiAgICAgICAgICAgICsrdGhpcy5udW1TdWNjZXNzZXM7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaW50ZXJydXB0KCkge1xuICAgICAgICB0aGlzLmludGVycnVwdGVkID0gdHJ1ZTtcbiAgICB9XG4gICAgZXh0cmFjdEZhaWx1cmVzKCkge1xuICAgICAgICBpZiAodGhpcy5pc1N1Y2Nlc3MoKSkge1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGZhaWx1cmVzID0gW107XG4gICAgICAgIGxldCBjdXJzb3IgPSB0aGlzLnJvb3RFeGVjdXRpb25UcmVlcztcbiAgICAgICAgd2hpbGUgKGN1cnNvci5sZW5ndGggPiAwICYmIGN1cnNvcltjdXJzb3IubGVuZ3RoIC0gMV0uc3RhdHVzID09PSBFeGVjdXRpb25TdGF0dXNfMS5FeGVjdXRpb25TdGF0dXMuRmFpbHVyZSkge1xuICAgICAgICAgICAgY29uc3QgZmFpbHVyZVRyZWUgPSBjdXJzb3JbY3Vyc29yLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgZmFpbHVyZXMucHVzaChmYWlsdXJlVHJlZS52YWx1ZSk7XG4gICAgICAgICAgICBjdXJzb3IgPSBmYWlsdXJlVHJlZS5jaGlsZHJlbjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFpbHVyZXM7XG4gICAgfVxuICAgIHRvUnVuRGV0YWlscyhzZWVkLCBiYXNlUGF0aCwgbWF4U2tpcHMsIHFQYXJhbXMpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzU3VjY2VzcygpKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGZhaWxlZDogdHJ1ZSxcbiAgICAgICAgICAgICAgICBpbnRlcnJ1cHRlZDogdGhpcy5pbnRlcnJ1cHRlZCxcbiAgICAgICAgICAgICAgICBudW1SdW5zOiB0aGlzLmZpcnN0RmFpbHVyZSgpICsgMSAtIHRoaXMubnVtU2tpcHMsXG4gICAgICAgICAgICAgICAgbnVtU2tpcHM6IHRoaXMubnVtU2tpcHMsXG4gICAgICAgICAgICAgICAgbnVtU2hyaW5rczogdGhpcy5udW1TaHJpbmtzKCksXG4gICAgICAgICAgICAgICAgc2VlZCxcbiAgICAgICAgICAgICAgICBjb3VudGVyZXhhbXBsZTogdGhpcy52YWx1ZSxcbiAgICAgICAgICAgICAgICBjb3VudGVyZXhhbXBsZVBhdGg6IFJ1bkV4ZWN1dGlvbi5tZXJnZVBhdGhzKGJhc2VQYXRoLCB0aGlzLnBhdGhUb0ZhaWx1cmUpLFxuICAgICAgICAgICAgICAgIGVycm9yOiB0aGlzLmZhaWx1cmUsXG4gICAgICAgICAgICAgICAgZmFpbHVyZXM6IHRoaXMuZXh0cmFjdEZhaWx1cmVzKCksXG4gICAgICAgICAgICAgICAgZXhlY3V0aW9uU3VtbWFyeTogdGhpcy5yb290RXhlY3V0aW9uVHJlZXMsXG4gICAgICAgICAgICAgICAgdmVyYm9zZTogdGhpcy52ZXJib3NpdHksXG4gICAgICAgICAgICAgICAgcnVuQ29uZmlndXJhdGlvbjogcVBhcmFtcy50b1BhcmFtZXRlcnMoKSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZmFpbGVkID0gdGhpcy5udW1Ta2lwcyA+IG1heFNraXBzIHx8ICh0aGlzLmludGVycnVwdGVkICYmIHRoaXMuaW50ZXJydXB0ZWRBc0ZhaWx1cmUpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZmFpbGVkLFxuICAgICAgICAgICAgaW50ZXJydXB0ZWQ6IHRoaXMuaW50ZXJydXB0ZWQsXG4gICAgICAgICAgICBudW1SdW5zOiB0aGlzLm51bVN1Y2Nlc3NlcyxcbiAgICAgICAgICAgIG51bVNraXBzOiB0aGlzLm51bVNraXBzLFxuICAgICAgICAgICAgbnVtU2hyaW5rczogMCxcbiAgICAgICAgICAgIHNlZWQsXG4gICAgICAgICAgICBjb3VudGVyZXhhbXBsZTogbnVsbCxcbiAgICAgICAgICAgIGNvdW50ZXJleGFtcGxlUGF0aDogbnVsbCxcbiAgICAgICAgICAgIGVycm9yOiBudWxsLFxuICAgICAgICAgICAgZmFpbHVyZXM6IFtdLFxuICAgICAgICAgICAgZXhlY3V0aW9uU3VtbWFyeTogdGhpcy5yb290RXhlY3V0aW9uVHJlZXMsXG4gICAgICAgICAgICB2ZXJib3NlOiB0aGlzLnZlcmJvc2l0eSxcbiAgICAgICAgICAgIHJ1bkNvbmZpZ3VyYXRpb246IHFQYXJhbXMudG9QYXJhbWV0ZXJzKCksXG4gICAgICAgIH07XG4gICAgfVxufVxuZXhwb3J0cy5SdW5FeGVjdXRpb24gPSBSdW5FeGVjdXRpb247XG5SdW5FeGVjdXRpb24ubWVyZ2VQYXRocyA9IChvZmZzZXRQYXRoLCBwYXRoKSA9PiB7XG4gICAgaWYgKG9mZnNldFBhdGgubGVuZ3RoID09PSAwKVxuICAgICAgICByZXR1cm4gcGF0aDtcbiAgICBjb25zdCBvZmZzZXRJdGVtcyA9IG9mZnNldFBhdGguc3BsaXQoJzonKTtcbiAgICBjb25zdCByZW1haW5pbmdJdGVtcyA9IHBhdGguc3BsaXQoJzonKTtcbiAgICBjb25zdCBtaWRkbGUgPSArb2Zmc2V0SXRlbXNbb2Zmc2V0SXRlbXMubGVuZ3RoIC0gMV0gKyArcmVtYWluaW5nSXRlbXNbMF07XG4gICAgcmV0dXJuIFsuLi5vZmZzZXRJdGVtcy5zbGljZSgwLCBvZmZzZXRJdGVtcy5sZW5ndGggLSAxKSwgYCR7bWlkZGxlfWAsIC4uLnJlbWFpbmluZ0l0ZW1zLnNsaWNlKDEpXS5qb2luKCc6Jyk7XG59O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnBhdGhXYWxrID0gdm9pZCAwO1xuY29uc3QgU3RyZWFtXzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vc3RyZWFtL1N0cmVhbVwiKTtcbmZ1bmN0aW9uIHBhdGhXYWxrKHBhdGgsIGluaXRpYWxWYWx1ZXMpIHtcbiAgICBsZXQgdmFsdWVzID0gU3RyZWFtXzEuc3RyZWFtKGluaXRpYWxWYWx1ZXMpO1xuICAgIGNvbnN0IHNlZ21lbnRzID0gcGF0aC5zcGxpdCgnOicpLm1hcCgodGV4dCkgPT4gK3RleHQpO1xuICAgIGlmIChzZWdtZW50cy5sZW5ndGggPT09IDApXG4gICAgICAgIHJldHVybiB2YWx1ZXM7XG4gICAgaWYgKCFzZWdtZW50cy5ldmVyeSgodikgPT4gIU51bWJlci5pc05hTih2KSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmFibGUgdG8gcmVwbGF5LCBnb3QgaW52YWxpZCBwYXRoPSR7cGF0aH1gKTtcbiAgICB9XG4gICAgdmFsdWVzID0gdmFsdWVzLmRyb3Aoc2VnbWVudHNbMF0pO1xuICAgIGZvciAoY29uc3QgcyBvZiBzZWdtZW50cy5zbGljZSgxKSkge1xuICAgICAgICBjb25zdCB2YWx1ZVRvU2hyaW5rID0gdmFsdWVzLmdldE50aE9yTGFzdCgwKTtcbiAgICAgICAgaWYgKHZhbHVlVG9TaHJpbmsgPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmFibGUgdG8gcmVwbGF5LCBnb3Qgd3JvbmcgcGF0aD0ke3BhdGh9YCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFsdWVzID0gdmFsdWVUb1Nocmluay5zaHJpbmsoKS5kcm9wKHMpO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWVzO1xufVxuZXhwb3J0cy5wYXRoV2FsayA9IHBhdGhXYWxrO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmFzeW5jRGVmYXVsdFJlcG9ydE1lc3NhZ2UgPSBleHBvcnRzLmRlZmF1bHRSZXBvcnRNZXNzYWdlID0gZXhwb3J0cy5hc3luY1JlcG9ydFJ1bkRldGFpbHMgPSBleHBvcnRzLnJlcG9ydFJ1bkRldGFpbHMgPSB2b2lkIDA7XG5jb25zdCBzdHJpbmdpZnlfMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi91dGlscy9zdHJpbmdpZnlcIik7XG5jb25zdCBWZXJib3NpdHlMZXZlbF8xID0gcmVxdWlyZShcIi4uL2NvbmZpZ3VyYXRpb24vVmVyYm9zaXR5TGV2ZWxcIik7XG5jb25zdCBFeGVjdXRpb25TdGF0dXNfMSA9IHJlcXVpcmUoXCIuLi9yZXBvcnRlci9FeGVjdXRpb25TdGF0dXNcIik7XG5mdW5jdGlvbiBmb3JtYXRIaW50cyhoaW50cykge1xuICAgIGlmIChoaW50cy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgcmV0dXJuIGBIaW50OiAke2hpbnRzWzBdfWA7XG4gICAgfVxuICAgIHJldHVybiBoaW50cy5tYXAoKGgsIGlkeCkgPT4gYEhpbnQgKCR7aWR4ICsgMX0pOiAke2h9YCkuam9pbignXFxuJyk7XG59XG5mdW5jdGlvbiBmb3JtYXRGYWlsdXJlcyhmYWlsdXJlcywgc3RyaW5naWZ5T25lKSB7XG4gICAgcmV0dXJuIGBFbmNvdW50ZXJlZCBmYWlsdXJlcyB3ZXJlOlxcbi0gJHtmYWlsdXJlcy5tYXAoc3RyaW5naWZ5T25lKS5qb2luKCdcXG4tICcpfWA7XG59XG5mdW5jdGlvbiBmb3JtYXRFeGVjdXRpb25TdW1tYXJ5KGV4ZWN1dGlvblRyZWVzLCBzdHJpbmdpZnlPbmUpIHtcbiAgICBjb25zdCBzdW1tYXJ5TGluZXMgPSBbXTtcbiAgICBjb25zdCByZW1haW5pbmdUcmVlc0FuZERlcHRoID0gW107XG4gICAgZm9yIChjb25zdCB0cmVlIG9mIGV4ZWN1dGlvblRyZWVzLnNsaWNlKCkucmV2ZXJzZSgpKSB7XG4gICAgICAgIHJlbWFpbmluZ1RyZWVzQW5kRGVwdGgucHVzaCh7IGRlcHRoOiAxLCB0cmVlIH0pO1xuICAgIH1cbiAgICB3aGlsZSAocmVtYWluaW5nVHJlZXNBbmREZXB0aC5sZW5ndGggIT09IDApIHtcbiAgICAgICAgY29uc3QgY3VycmVudFRyZWVBbmREZXB0aCA9IHJlbWFpbmluZ1RyZWVzQW5kRGVwdGgucG9wKCk7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRUcmVlID0gY3VycmVudFRyZWVBbmREZXB0aC50cmVlO1xuICAgICAgICBjb25zdCBjdXJyZW50RGVwdGggPSBjdXJyZW50VHJlZUFuZERlcHRoLmRlcHRoO1xuICAgICAgICBjb25zdCBzdGF0dXNJY29uID0gY3VycmVudFRyZWUuc3RhdHVzID09PSBFeGVjdXRpb25TdGF0dXNfMS5FeGVjdXRpb25TdGF0dXMuU3VjY2Vzc1xuICAgICAgICAgICAgPyAnXFx4MWJbMzJtXFx1MjIxQVxceDFiWzBtJ1xuICAgICAgICAgICAgOiBjdXJyZW50VHJlZS5zdGF0dXMgPT09IEV4ZWN1dGlvblN0YXR1c18xLkV4ZWN1dGlvblN0YXR1cy5GYWlsdXJlXG4gICAgICAgICAgICAgICAgPyAnXFx4MWJbMzFtXFx4RDdcXHgxYlswbSdcbiAgICAgICAgICAgICAgICA6ICdcXHgxYlszM20hXFx4MWJbMG0nO1xuICAgICAgICBjb25zdCBsZWZ0UGFkZGluZyA9IEFycmF5KGN1cnJlbnREZXB0aCkuam9pbignLiAnKTtcbiAgICAgICAgc3VtbWFyeUxpbmVzLnB1c2goYCR7bGVmdFBhZGRpbmd9JHtzdGF0dXNJY29ufSAke3N0cmluZ2lmeU9uZShjdXJyZW50VHJlZS52YWx1ZSl9YCk7XG4gICAgICAgIGZvciAoY29uc3QgdHJlZSBvZiBjdXJyZW50VHJlZS5jaGlsZHJlbi5zbGljZSgpLnJldmVyc2UoKSkge1xuICAgICAgICAgICAgcmVtYWluaW5nVHJlZXNBbmREZXB0aC5wdXNoKHsgZGVwdGg6IGN1cnJlbnREZXB0aCArIDEsIHRyZWUgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGBFeGVjdXRpb24gc3VtbWFyeTpcXG4ke3N1bW1hcnlMaW5lcy5qb2luKCdcXG4nKX1gO1xufVxuZnVuY3Rpb24gcHJlRm9ybWF0VG9vTWFueVNraXBwZWQob3V0LCBzdHJpbmdpZnlPbmUpIHtcbiAgICBjb25zdCBtZXNzYWdlID0gYEZhaWxlZCB0byBydW4gcHJvcGVydHksIHRvbyBtYW55IHByZS1jb25kaXRpb24gZmFpbHVyZXMgZW5jb3VudGVyZWRcXG57IHNlZWQ6ICR7b3V0LnNlZWR9IH1cXG5cXG5SYW4gJHtvdXQubnVtUnVuc30gdGltZShzKVxcblNraXBwZWQgJHtvdXQubnVtU2tpcHN9IHRpbWUocylgO1xuICAgIGxldCBkZXRhaWxzID0gbnVsbDtcbiAgICBjb25zdCBoaW50cyA9IFtcbiAgICAgICAgJ1RyeSB0byByZWR1Y2UgdGhlIG51bWJlciBvZiByZWplY3RlZCB2YWx1ZXMgYnkgY29tYmluaW5nIG1hcCwgZmxhdE1hcCBhbmQgYnVpbHQtaW4gYXJiaXRyYXJpZXMnLFxuICAgICAgICAnSW5jcmVhc2UgZmFpbHVyZSB0b2xlcmFuY2UgYnkgc2V0dGluZyBtYXhTa2lwc1BlclJ1biB0byBhbiBoaWdoZXIgdmFsdWUnLFxuICAgIF07XG4gICAgaWYgKG91dC52ZXJib3NlID49IFZlcmJvc2l0eUxldmVsXzEuVmVyYm9zaXR5TGV2ZWwuVmVyeVZlcmJvc2UpIHtcbiAgICAgICAgZGV0YWlscyA9IGZvcm1hdEV4ZWN1dGlvblN1bW1hcnkob3V0LmV4ZWN1dGlvblN1bW1hcnksIHN0cmluZ2lmeU9uZSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBoaW50cy5wdXNoKCdFbmFibGUgdmVyYm9zZSBtb2RlIGF0IGxldmVsIFZlcnlWZXJib3NlIGluIG9yZGVyIHRvIGNoZWNrIGFsbCBnZW5lcmF0ZWQgdmFsdWVzIGFuZCB0aGVpciBhc3NvY2lhdGVkIHN0YXR1cycpO1xuICAgIH1cbiAgICByZXR1cm4geyBtZXNzYWdlLCBkZXRhaWxzLCBoaW50cyB9O1xufVxuZnVuY3Rpb24gcHJlRm9ybWF0RmFpbHVyZShvdXQsIHN0cmluZ2lmeU9uZSkge1xuICAgIGNvbnN0IG1lc3NhZ2UgPSBgUHJvcGVydHkgZmFpbGVkIGFmdGVyICR7b3V0Lm51bVJ1bnN9IHRlc3RzXFxueyBzZWVkOiAke291dC5zZWVkfSwgcGF0aDogXCIke291dC5jb3VudGVyZXhhbXBsZVBhdGh9XCIsIGVuZE9uRmFpbHVyZTogdHJ1ZSB9XFxuQ291bnRlcmV4YW1wbGU6ICR7c3RyaW5naWZ5T25lKG91dC5jb3VudGVyZXhhbXBsZSl9XFxuU2hydW5rICR7b3V0Lm51bVNocmlua3N9IHRpbWUocylcXG5Hb3QgZXJyb3I6ICR7b3V0LmVycm9yfWA7XG4gICAgbGV0IGRldGFpbHMgPSBudWxsO1xuICAgIGNvbnN0IGhpbnRzID0gW107XG4gICAgaWYgKG91dC52ZXJib3NlID49IFZlcmJvc2l0eUxldmVsXzEuVmVyYm9zaXR5TGV2ZWwuVmVyeVZlcmJvc2UpIHtcbiAgICAgICAgZGV0YWlscyA9IGZvcm1hdEV4ZWN1dGlvblN1bW1hcnkob3V0LmV4ZWN1dGlvblN1bW1hcnksIHN0cmluZ2lmeU9uZSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKG91dC52ZXJib3NlID09PSBWZXJib3NpdHlMZXZlbF8xLlZlcmJvc2l0eUxldmVsLlZlcmJvc2UpIHtcbiAgICAgICAgZGV0YWlscyA9IGZvcm1hdEZhaWx1cmVzKG91dC5mYWlsdXJlcywgc3RyaW5naWZ5T25lKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGhpbnRzLnB1c2goJ0VuYWJsZSB2ZXJib3NlIG1vZGUgaW4gb3JkZXIgdG8gaGF2ZSB0aGUgbGlzdCBvZiBhbGwgZmFpbGluZyB2YWx1ZXMgZW5jb3VudGVyZWQgZHVyaW5nIHRoZSBydW4nKTtcbiAgICB9XG4gICAgcmV0dXJuIHsgbWVzc2FnZSwgZGV0YWlscywgaGludHMgfTtcbn1cbmZ1bmN0aW9uIHByZUZvcm1hdEVhcmx5SW50ZXJydXB0ZWQob3V0LCBzdHJpbmdpZnlPbmUpIHtcbiAgICBjb25zdCBtZXNzYWdlID0gYFByb3BlcnR5IGludGVycnVwdGVkIGFmdGVyICR7b3V0Lm51bVJ1bnN9IHRlc3RzXFxueyBzZWVkOiAke291dC5zZWVkfSB9YDtcbiAgICBsZXQgZGV0YWlscyA9IG51bGw7XG4gICAgY29uc3QgaGludHMgPSBbXTtcbiAgICBpZiAob3V0LnZlcmJvc2UgPj0gVmVyYm9zaXR5TGV2ZWxfMS5WZXJib3NpdHlMZXZlbC5WZXJ5VmVyYm9zZSkge1xuICAgICAgICBkZXRhaWxzID0gZm9ybWF0RXhlY3V0aW9uU3VtbWFyeShvdXQuZXhlY3V0aW9uU3VtbWFyeSwgc3RyaW5naWZ5T25lKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGhpbnRzLnB1c2goJ0VuYWJsZSB2ZXJib3NlIG1vZGUgYXQgbGV2ZWwgVmVyeVZlcmJvc2UgaW4gb3JkZXIgdG8gY2hlY2sgYWxsIGdlbmVyYXRlZCB2YWx1ZXMgYW5kIHRoZWlyIGFzc29jaWF0ZWQgc3RhdHVzJyk7XG4gICAgfVxuICAgIHJldHVybiB7IG1lc3NhZ2UsIGRldGFpbHMsIGhpbnRzIH07XG59XG5mdW5jdGlvbiBkZWZhdWx0UmVwb3J0TWVzc2FnZUludGVybmFsKG91dCwgc3RyaW5naWZ5T25lKSB7XG4gICAgaWYgKCFvdXQuZmFpbGVkKVxuICAgICAgICByZXR1cm47XG4gICAgY29uc3QgeyBtZXNzYWdlLCBkZXRhaWxzLCBoaW50cyB9ID0gb3V0LmNvdW50ZXJleGFtcGxlUGF0aCA9PT0gbnVsbFxuICAgICAgICA/IG91dC5pbnRlcnJ1cHRlZFxuICAgICAgICAgICAgPyBwcmVGb3JtYXRFYXJseUludGVycnVwdGVkKG91dCwgc3RyaW5naWZ5T25lKVxuICAgICAgICAgICAgOiBwcmVGb3JtYXRUb29NYW55U2tpcHBlZChvdXQsIHN0cmluZ2lmeU9uZSlcbiAgICAgICAgOiBwcmVGb3JtYXRGYWlsdXJlKG91dCwgc3RyaW5naWZ5T25lKTtcbiAgICBsZXQgZXJyb3JNZXNzYWdlID0gbWVzc2FnZTtcbiAgICBpZiAoZGV0YWlscyAhPSBudWxsKVxuICAgICAgICBlcnJvck1lc3NhZ2UgKz0gYFxcblxcbiR7ZGV0YWlsc31gO1xuICAgIGlmIChoaW50cy5sZW5ndGggPiAwKVxuICAgICAgICBlcnJvck1lc3NhZ2UgKz0gYFxcblxcbiR7Zm9ybWF0SGludHMoaGludHMpfWA7XG4gICAgcmV0dXJuIGVycm9yTWVzc2FnZTtcbn1cbmZ1bmN0aW9uIGRlZmF1bHRSZXBvcnRNZXNzYWdlKG91dCkge1xuICAgIHJldHVybiBkZWZhdWx0UmVwb3J0TWVzc2FnZUludGVybmFsKG91dCwgc3RyaW5naWZ5XzEuc3RyaW5naWZ5KTtcbn1cbmV4cG9ydHMuZGVmYXVsdFJlcG9ydE1lc3NhZ2UgPSBkZWZhdWx0UmVwb3J0TWVzc2FnZTtcbmFzeW5jIGZ1bmN0aW9uIGFzeW5jRGVmYXVsdFJlcG9ydE1lc3NhZ2Uob3V0KSB7XG4gICAgY29uc3QgcGVuZGluZ1N0cmluZ2lmaWVkcyA9IFtdO1xuICAgIGZ1bmN0aW9uIHN0cmluZ2lmeU9uZSh2YWx1ZSkge1xuICAgICAgICBjb25zdCBzdHJpbmdpZmllZCA9IHN0cmluZ2lmeV8xLnBvc3NpYmx5QXN5bmNTdHJpbmdpZnkodmFsdWUpO1xuICAgICAgICBpZiAodHlwZW9mIHN0cmluZ2lmaWVkID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgcmV0dXJuIHN0cmluZ2lmaWVkO1xuICAgICAgICB9XG4gICAgICAgIHBlbmRpbmdTdHJpbmdpZmllZHMucHVzaChQcm9taXNlLmFsbChbdmFsdWUsIHN0cmluZ2lmaWVkXSkpO1xuICAgICAgICByZXR1cm4gJ1xcdTIwMjYnO1xuICAgIH1cbiAgICBjb25zdCBmaXJzdFRyeU1lc3NhZ2UgPSBkZWZhdWx0UmVwb3J0TWVzc2FnZUludGVybmFsKG91dCwgc3RyaW5naWZ5T25lKTtcbiAgICBpZiAocGVuZGluZ1N0cmluZ2lmaWVkcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIGZpcnN0VHJ5TWVzc2FnZTtcbiAgICB9XG4gICAgY29uc3QgcmVnaXN0ZXJlZFZhbHVlcyA9IG5ldyBNYXAoYXdhaXQgUHJvbWlzZS5hbGwocGVuZGluZ1N0cmluZ2lmaWVkcykpO1xuICAgIGZ1bmN0aW9uIHN0cmluZ2lmeVNlY29uZCh2YWx1ZSkge1xuICAgICAgICBjb25zdCBhc3luY1N0cmluZ2lmaWVkSWZSZWdpc3RlcmVkID0gcmVnaXN0ZXJlZFZhbHVlcy5nZXQodmFsdWUpO1xuICAgICAgICBpZiAoYXN5bmNTdHJpbmdpZmllZElmUmVnaXN0ZXJlZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gYXN5bmNTdHJpbmdpZmllZElmUmVnaXN0ZXJlZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3RyaW5naWZ5XzEuc3RyaW5naWZ5KHZhbHVlKTtcbiAgICB9XG4gICAgcmV0dXJuIGRlZmF1bHRSZXBvcnRNZXNzYWdlSW50ZXJuYWwob3V0LCBzdHJpbmdpZnlTZWNvbmQpO1xufVxuZXhwb3J0cy5hc3luY0RlZmF1bHRSZXBvcnRNZXNzYWdlID0gYXN5bmNEZWZhdWx0UmVwb3J0TWVzc2FnZTtcbmZ1bmN0aW9uIHRocm93SWZGYWlsZWQob3V0KSB7XG4gICAgaWYgKCFvdXQuZmFpbGVkKVxuICAgICAgICByZXR1cm47XG4gICAgdGhyb3cgbmV3IEVycm9yKGRlZmF1bHRSZXBvcnRNZXNzYWdlKG91dCkpO1xufVxuYXN5bmMgZnVuY3Rpb24gYXN5bmNUaHJvd0lmRmFpbGVkKG91dCkge1xuICAgIGlmICghb3V0LmZhaWxlZClcbiAgICAgICAgcmV0dXJuO1xuICAgIHRocm93IG5ldyBFcnJvcihhd2FpdCBhc3luY0RlZmF1bHRSZXBvcnRNZXNzYWdlKG91dCkpO1xufVxuZnVuY3Rpb24gcmVwb3J0UnVuRGV0YWlscyhvdXQpIHtcbiAgICBpZiAob3V0LnJ1bkNvbmZpZ3VyYXRpb24uYXN5bmNSZXBvcnRlcilcbiAgICAgICAgcmV0dXJuIG91dC5ydW5Db25maWd1cmF0aW9uLmFzeW5jUmVwb3J0ZXIob3V0KTtcbiAgICBlbHNlIGlmIChvdXQucnVuQ29uZmlndXJhdGlvbi5yZXBvcnRlcilcbiAgICAgICAgcmV0dXJuIG91dC5ydW5Db25maWd1cmF0aW9uLnJlcG9ydGVyKG91dCk7XG4gICAgZWxzZVxuICAgICAgICByZXR1cm4gdGhyb3dJZkZhaWxlZChvdXQpO1xufVxuZXhwb3J0cy5yZXBvcnRSdW5EZXRhaWxzID0gcmVwb3J0UnVuRGV0YWlscztcbmFzeW5jIGZ1bmN0aW9uIGFzeW5jUmVwb3J0UnVuRGV0YWlscyhvdXQpIHtcbiAgICBpZiAob3V0LnJ1bkNvbmZpZ3VyYXRpb24uYXN5bmNSZXBvcnRlcilcbiAgICAgICAgcmV0dXJuIG91dC5ydW5Db25maWd1cmF0aW9uLmFzeW5jUmVwb3J0ZXIob3V0KTtcbiAgICBlbHNlIGlmIChvdXQucnVuQ29uZmlndXJhdGlvbi5yZXBvcnRlcilcbiAgICAgICAgcmV0dXJuIG91dC5ydW5Db25maWd1cmF0aW9uLnJlcG9ydGVyKG91dCk7XG4gICAgZWxzZVxuICAgICAgICByZXR1cm4gYXN5bmNUaHJvd0lmRmFpbGVkKG91dCk7XG59XG5leHBvcnRzLmFzeW5jUmVwb3J0UnVuRGV0YWlscyA9IGFzeW5jUmVwb3J0UnVuRGV0YWlscztcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5jbG9uZUlmTmVlZGVkID0gZXhwb3J0cy5oYXNDbG9uZU1ldGhvZCA9IGV4cG9ydHMuY2xvbmVNZXRob2QgPSB2b2lkIDA7XG5leHBvcnRzLmNsb25lTWV0aG9kID0gU3ltYm9sKCdmYXN0LWNoZWNrL2Nsb25lTWV0aG9kJyk7XG5mdW5jdGlvbiBoYXNDbG9uZU1ldGhvZChpbnN0YW5jZSkge1xuICAgIHJldHVybiAoaW5zdGFuY2UgIT09IG51bGwgJiZcbiAgICAgICAgKHR5cGVvZiBpbnN0YW5jZSA9PT0gJ29iamVjdCcgfHwgdHlwZW9mIGluc3RhbmNlID09PSAnZnVuY3Rpb24nKSAmJlxuICAgICAgICBleHBvcnRzLmNsb25lTWV0aG9kIGluIGluc3RhbmNlICYmXG4gICAgICAgIHR5cGVvZiBpbnN0YW5jZVtleHBvcnRzLmNsb25lTWV0aG9kXSA9PT0gJ2Z1bmN0aW9uJyk7XG59XG5leHBvcnRzLmhhc0Nsb25lTWV0aG9kID0gaGFzQ2xvbmVNZXRob2Q7XG5mdW5jdGlvbiBjbG9uZUlmTmVlZGVkKGluc3RhbmNlKSB7XG4gICAgcmV0dXJuIGhhc0Nsb25lTWV0aG9kKGluc3RhbmNlKSA/IGluc3RhbmNlW2V4cG9ydHMuY2xvbmVNZXRob2RdKCkgOiBpbnN0YW5jZTtcbn1cbmV4cG9ydHMuY2xvbmVJZk5lZWRlZCA9IGNsb25lSWZOZWVkZWQ7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuc2h1ZmZsZWRTdWJhcnJheSA9IGV4cG9ydHMuZGVkdXAgPSBleHBvcnRzLmNsb25lID0gZXhwb3J0cy5mcmVxdWVuY3kgPSBleHBvcnRzLm9uZW9mID0gZXhwb3J0cy5vcHRpb24gPSBleHBvcnRzLm1hcFRvQ29uc3RhbnQgPSBleHBvcnRzLmNsb25lZENvbnN0YW50ID0gZXhwb3J0cy5jb25zdGFudEZyb20gPSBleHBvcnRzLmNvbnN0YW50ID0gZXhwb3J0cy5sb3JlbSA9IGV4cG9ydHMuYmFzZTY0U3RyaW5nID0gZXhwb3J0cy5oZXhhU3RyaW5nID0gZXhwb3J0cy5mdWxsVW5pY29kZVN0cmluZyA9IGV4cG9ydHMudW5pY29kZVN0cmluZyA9IGV4cG9ydHMuc3RyaW5nT2YgPSBleHBvcnRzLnN0cmluZzE2Yml0cyA9IGV4cG9ydHMuYXNjaWlTdHJpbmcgPSBleHBvcnRzLnN0cmluZyA9IGV4cG9ydHMubWl4ZWRDYXNlID0gZXhwb3J0cy5iYXNlNjQgPSBleHBvcnRzLmhleGEgPSBleHBvcnRzLmZ1bGxVbmljb2RlID0gZXhwb3J0cy51bmljb2RlID0gZXhwb3J0cy5jaGFyMTZiaXRzID0gZXhwb3J0cy5hc2NpaSA9IGV4cG9ydHMuY2hhciA9IGV4cG9ydHMuYmlnVWludCA9IGV4cG9ydHMuYmlnSW50ID0gZXhwb3J0cy5iaWdVaW50TiA9IGV4cG9ydHMuYmlnSW50TiA9IGV4cG9ydHMubWF4U2FmZU5hdCA9IGV4cG9ydHMubWF4U2FmZUludGVnZXIgPSBleHBvcnRzLm5hdCA9IGV4cG9ydHMuaW50ZWdlciA9IGV4cG9ydHMuZG91YmxlID0gZXhwb3J0cy5mbG9hdCA9IGV4cG9ydHMuZmFsc3kgPSBleHBvcnRzLmJvb2xlYW4gPSBleHBvcnRzLmFzeW5jUHJvcGVydHkgPSBleHBvcnRzLnByb3BlcnR5ID0gZXhwb3J0cy5QcmVjb25kaXRpb25GYWlsdXJlID0gZXhwb3J0cy5wcmUgPSBleHBvcnRzLmFzc2VydCA9IGV4cG9ydHMuY2hlY2sgPSBleHBvcnRzLnN0YXRpc3RpY3MgPSBleHBvcnRzLnNhbXBsZSA9IGV4cG9ydHMuX19jb21taXRIYXNoID0gZXhwb3J0cy5fX3ZlcnNpb24gPSBleHBvcnRzLl9fdHlwZSA9IHZvaWQgMDtcbmV4cG9ydHMuQXJiaXRyYXJ5ID0gZXhwb3J0cy5zY2hlZHVsZXJGb3IgPSBleHBvcnRzLnNjaGVkdWxlciA9IGV4cG9ydHMuY29tbWFuZHMgPSBleHBvcnRzLnNjaGVkdWxlZE1vZGVsUnVuID0gZXhwb3J0cy5tb2RlbFJ1biA9IGV4cG9ydHMuYXN5bmNNb2RlbFJ1biA9IGV4cG9ydHMuZmxvYXQ2NEFycmF5ID0gZXhwb3J0cy5mbG9hdDMyQXJyYXkgPSBleHBvcnRzLnVpbnQzMkFycmF5ID0gZXhwb3J0cy5pbnQzMkFycmF5ID0gZXhwb3J0cy51aW50MTZBcnJheSA9IGV4cG9ydHMuaW50MTZBcnJheSA9IGV4cG9ydHMudWludDhDbGFtcGVkQXJyYXkgPSBleHBvcnRzLnVpbnQ4QXJyYXkgPSBleHBvcnRzLmludDhBcnJheSA9IGV4cG9ydHMudXVpZFYgPSBleHBvcnRzLnV1aWQgPSBleHBvcnRzLmVtYWlsQWRkcmVzcyA9IGV4cG9ydHMud2ViVXJsID0gZXhwb3J0cy53ZWJRdWVyeVBhcmFtZXRlcnMgPSBleHBvcnRzLndlYkZyYWdtZW50cyA9IGV4cG9ydHMud2ViU2VnbWVudCA9IGV4cG9ydHMud2ViQXV0aG9yaXR5ID0gZXhwb3J0cy5kb21haW4gPSBleHBvcnRzLmlwVjYgPSBleHBvcnRzLmlwVjRFeHRlbmRlZCA9IGV4cG9ydHMuaXBWNCA9IGV4cG9ydHMuZGF0ZSA9IGV4cG9ydHMuY29udGV4dCA9IGV4cG9ydHMuZnVuYyA9IGV4cG9ydHMuY29tcGFyZUZ1bmMgPSBleHBvcnRzLmNvbXBhcmVCb29sZWFuRnVuYyA9IGV4cG9ydHMubWVtbyA9IGV4cG9ydHMubGV0cmVjID0gZXhwb3J0cy51bmljb2RlSnNvbk9iamVjdCA9IGV4cG9ydHMudW5pY29kZUpzb24gPSBleHBvcnRzLmpzb25PYmplY3QgPSBleHBvcnRzLmpzb24gPSBleHBvcnRzLm9iamVjdCA9IGV4cG9ydHMuYW55dGhpbmcgPSBleHBvcnRzLmRpY3Rpb25hcnkgPSBleHBvcnRzLnJlY29yZCA9IGV4cG9ydHMuZ2VuZXJpY1R1cGxlID0gZXhwb3J0cy50dXBsZSA9IGV4cG9ydHMuc2V0ID0gZXhwb3J0cy5pbmZpbml0ZVN0cmVhbSA9IGV4cG9ydHMuc3BhcnNlQXJyYXkgPSBleHBvcnRzLmFycmF5ID0gZXhwb3J0cy5zdWJhcnJheSA9IHZvaWQgMDtcbmV4cG9ydHMuc3RyZWFtID0gZXhwb3J0cy5TdHJlYW0gPSBleHBvcnRzLlJhbmRvbSA9IGV4cG9ydHMuRXhlY3V0aW9uU3RhdHVzID0gZXhwb3J0cy5yZXNldENvbmZpZ3VyZUdsb2JhbCA9IGV4cG9ydHMucmVhZENvbmZpZ3VyZUdsb2JhbCA9IGV4cG9ydHMuY29uZmlndXJlR2xvYmFsID0gZXhwb3J0cy5WZXJib3NpdHlMZXZlbCA9IGV4cG9ydHMuaGFzaCA9IGV4cG9ydHMuYXN5bmNEZWZhdWx0UmVwb3J0TWVzc2FnZSA9IGV4cG9ydHMuZGVmYXVsdFJlcG9ydE1lc3NhZ2UgPSBleHBvcnRzLmFzeW5jU3RyaW5naWZ5ID0gZXhwb3J0cy5zdHJpbmdpZnkgPSBleHBvcnRzLmhhc0FzeW5jVG9TdHJpbmdNZXRob2QgPSBleHBvcnRzLmFzeW5jVG9TdHJpbmdNZXRob2QgPSBleHBvcnRzLmhhc1RvU3RyaW5nTWV0aG9kID0gZXhwb3J0cy50b1N0cmluZ01ldGhvZCA9IGV4cG9ydHMuY29udmVydFRvTmV4dCA9IGV4cG9ydHMuY29udmVydEZyb21OZXh0V2l0aFNocnVua09uY2UgPSBleHBvcnRzLmNvbnZlcnRGcm9tTmV4dCA9IGV4cG9ydHMuaGFzQ2xvbmVNZXRob2QgPSBleHBvcnRzLmNsb25lSWZOZWVkZWQgPSBleHBvcnRzLmNsb25lTWV0aG9kID0gZXhwb3J0cy5OZXh0VmFsdWUgPSBleHBvcnRzLlNocmlua2FibGUgPSBleHBvcnRzLkFyYml0cmFyeVdpdGhDb250ZXh0dWFsU2hyaW5rID0gZXhwb3J0cy5BcmJpdHJhcnlXaXRoU2hyaW5rID0gZXhwb3J0cy5OZXh0QXJiaXRyYXJ5ID0gdm9pZCAwO1xuY29uc3QgUHJlXzEgPSByZXF1aXJlKFwiLi9jaGVjay9wcmVjb25kaXRpb24vUHJlXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwicHJlXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBQcmVfMS5wcmU7IH0gfSk7XG5jb25zdCBBc3luY1Byb3BlcnR5XzEgPSByZXF1aXJlKFwiLi9jaGVjay9wcm9wZXJ0eS9Bc3luY1Byb3BlcnR5XCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiYXN5bmNQcm9wZXJ0eVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gQXN5bmNQcm9wZXJ0eV8xLmFzeW5jUHJvcGVydHk7IH0gfSk7XG5jb25zdCBQcm9wZXJ0eV8xID0gcmVxdWlyZShcIi4vY2hlY2svcHJvcGVydHkvUHJvcGVydHlcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJwcm9wZXJ0eVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gUHJvcGVydHlfMS5wcm9wZXJ0eTsgfSB9KTtcbmNvbnN0IFJ1bm5lcl8xID0gcmVxdWlyZShcIi4vY2hlY2svcnVubmVyL1J1bm5lclwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImFzc2VydFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gUnVubmVyXzEuYXNzZXJ0OyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiY2hlY2tcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFJ1bm5lcl8xLmNoZWNrOyB9IH0pO1xuY29uc3QgU2FtcGxlcl8xID0gcmVxdWlyZShcIi4vY2hlY2svcnVubmVyL1NhbXBsZXJcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJzYW1wbGVcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFNhbXBsZXJfMS5zYW1wbGU7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJzdGF0aXN0aWNzXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBTYW1wbGVyXzEuc3RhdGlzdGljczsgfSB9KTtcbmNvbnN0IGFycmF5XzEgPSByZXF1aXJlKFwiLi9hcmJpdHJhcnkvYXJyYXlcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJhcnJheVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gYXJyYXlfMS5hcnJheTsgfSB9KTtcbmNvbnN0IGJpZ0ludF8xID0gcmVxdWlyZShcIi4vYXJiaXRyYXJ5L2JpZ0ludFwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImJpZ0ludFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gYmlnSW50XzEuYmlnSW50OyB9IH0pO1xuY29uc3QgYmlnSW50Tl8xID0gcmVxdWlyZShcIi4vYXJiaXRyYXJ5L2JpZ0ludE5cIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJiaWdJbnROXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBiaWdJbnROXzEuYmlnSW50TjsgfSB9KTtcbmNvbnN0IGJpZ1VpbnRfMSA9IHJlcXVpcmUoXCIuL2FyYml0cmFyeS9iaWdVaW50XCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiYmlnVWludFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gYmlnVWludF8xLmJpZ1VpbnQ7IH0gfSk7XG5jb25zdCBiaWdVaW50Tl8xID0gcmVxdWlyZShcIi4vYXJiaXRyYXJ5L2JpZ1VpbnROXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiYmlnVWludE5cIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGJpZ1VpbnROXzEuYmlnVWludE47IH0gfSk7XG5jb25zdCBib29sZWFuXzEgPSByZXF1aXJlKFwiLi9hcmJpdHJhcnkvYm9vbGVhblwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImJvb2xlYW5cIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGJvb2xlYW5fMS5ib29sZWFuOyB9IH0pO1xuY29uc3QgZmFsc3lfMSA9IHJlcXVpcmUoXCIuL2FyYml0cmFyeS9mYWxzeVwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImZhbHN5XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBmYWxzeV8xLmZhbHN5OyB9IH0pO1xuY29uc3QgYXNjaWlfMSA9IHJlcXVpcmUoXCIuL2FyYml0cmFyeS9hc2NpaVwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImFzY2lpXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBhc2NpaV8xLmFzY2lpOyB9IH0pO1xuY29uc3QgYmFzZTY0XzEgPSByZXF1aXJlKFwiLi9hcmJpdHJhcnkvYmFzZTY0XCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiYmFzZTY0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBiYXNlNjRfMS5iYXNlNjQ7IH0gfSk7XG5jb25zdCBjaGFyXzEgPSByZXF1aXJlKFwiLi9hcmJpdHJhcnkvY2hhclwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImNoYXJcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNoYXJfMS5jaGFyOyB9IH0pO1xuY29uc3QgY2hhcjE2Yml0c18xID0gcmVxdWlyZShcIi4vYXJiaXRyYXJ5L2NoYXIxNmJpdHNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJjaGFyMTZiaXRzXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjaGFyMTZiaXRzXzEuY2hhcjE2Yml0czsgfSB9KTtcbmNvbnN0IGZ1bGxVbmljb2RlXzEgPSByZXF1aXJlKFwiLi9hcmJpdHJhcnkvZnVsbFVuaWNvZGVcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJmdWxsVW5pY29kZVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZnVsbFVuaWNvZGVfMS5mdWxsVW5pY29kZTsgfSB9KTtcbmNvbnN0IGhleGFfMSA9IHJlcXVpcmUoXCIuL2FyYml0cmFyeS9oZXhhXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiaGV4YVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaGV4YV8xLmhleGE7IH0gfSk7XG5jb25zdCB1bmljb2RlXzEgPSByZXF1aXJlKFwiLi9hcmJpdHJhcnkvdW5pY29kZVwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInVuaWNvZGVcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHVuaWNvZGVfMS51bmljb2RlOyB9IH0pO1xuY29uc3QgY2xvbmVkQ29uc3RhbnRfMSA9IHJlcXVpcmUoXCIuL2FyYml0cmFyeS9jbG9uZWRDb25zdGFudFwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImNsb25lZENvbnN0YW50XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjbG9uZWRDb25zdGFudF8xLmNsb25lZENvbnN0YW50OyB9IH0pO1xuY29uc3QgY29uc3RhbnRfMSA9IHJlcXVpcmUoXCIuL2FyYml0cmFyeS9jb25zdGFudFwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImNvbnN0YW50XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjb25zdGFudF8xLmNvbnN0YW50OyB9IH0pO1xuY29uc3QgY29uc3RhbnRGcm9tXzEgPSByZXF1aXJlKFwiLi9hcmJpdHJhcnkvY29uc3RhbnRGcm9tXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiY29uc3RhbnRGcm9tXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjb25zdGFudEZyb21fMS5jb25zdGFudEZyb207IH0gfSk7XG5jb25zdCBjb250ZXh0XzEgPSByZXF1aXJlKFwiLi9hcmJpdHJhcnkvY29udGV4dFwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImNvbnRleHRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvbnRleHRfMS5jb250ZXh0OyB9IH0pO1xuY29uc3QgZGF0ZV8xID0gcmVxdWlyZShcIi4vYXJiaXRyYXJ5L2RhdGVcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJkYXRlXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBkYXRlXzEuZGF0ZTsgfSB9KTtcbmNvbnN0IGNsb25lXzEgPSByZXF1aXJlKFwiLi9hcmJpdHJhcnkvY2xvbmVcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJjbG9uZVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY2xvbmVfMS5jbG9uZTsgfSB9KTtcbmNvbnN0IGRlZHVwXzEgPSByZXF1aXJlKFwiLi9hcmJpdHJhcnkvZGVkdXBcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJkZWR1cFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZGVkdXBfMS5kZWR1cDsgfSB9KTtcbmNvbnN0IEFyYml0cmFyeV8xID0gcmVxdWlyZShcIi4vY2hlY2svYXJiaXRyYXJ5L2RlZmluaXRpb24vQXJiaXRyYXJ5XCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQXJiaXRyYXJ5XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBBcmJpdHJhcnlfMS5BcmJpdHJhcnk7IH0gfSk7XG5jb25zdCBTaHJpbmthYmxlXzEgPSByZXF1aXJlKFwiLi9jaGVjay9hcmJpdHJhcnkvZGVmaW5pdGlvbi9TaHJpbmthYmxlXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiU2hyaW5rYWJsZVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gU2hyaW5rYWJsZV8xLlNocmlua2FibGU7IH0gfSk7XG5jb25zdCBkaWN0aW9uYXJ5XzEgPSByZXF1aXJlKFwiLi9hcmJpdHJhcnkvZGljdGlvbmFyeVwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImRpY3Rpb25hcnlcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGRpY3Rpb25hcnlfMS5kaWN0aW9uYXJ5OyB9IH0pO1xuY29uc3QgRW1haWxBcmJpdHJhcnlfMSA9IHJlcXVpcmUoXCIuL2NoZWNrL2FyYml0cmFyeS9FbWFpbEFyYml0cmFyeVwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImVtYWlsQWRkcmVzc1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gRW1haWxBcmJpdHJhcnlfMS5lbWFpbEFkZHJlc3M7IH0gfSk7XG5jb25zdCBGbG9hdGluZ1BvaW50QXJiaXRyYXJ5XzEgPSByZXF1aXJlKFwiLi9jaGVjay9hcmJpdHJhcnkvRmxvYXRpbmdQb2ludEFyYml0cmFyeVwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImRvdWJsZVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gRmxvYXRpbmdQb2ludEFyYml0cmFyeV8xLmRvdWJsZTsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImZsb2F0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBGbG9hdGluZ1BvaW50QXJiaXRyYXJ5XzEuZmxvYXQ7IH0gfSk7XG5jb25zdCBmcmVxdWVuY3lfMSA9IHJlcXVpcmUoXCIuL2FyYml0cmFyeS9mcmVxdWVuY3lcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJmcmVxdWVuY3lcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGZyZXF1ZW5jeV8xLmZyZXF1ZW5jeTsgfSB9KTtcbmNvbnN0IGNvbXBhcmVCb29sZWFuRnVuY18xID0gcmVxdWlyZShcIi4vYXJiaXRyYXJ5L2NvbXBhcmVCb29sZWFuRnVuY1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImNvbXBhcmVCb29sZWFuRnVuY1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY29tcGFyZUJvb2xlYW5GdW5jXzEuY29tcGFyZUJvb2xlYW5GdW5jOyB9IH0pO1xuY29uc3QgY29tcGFyZUZ1bmNfMSA9IHJlcXVpcmUoXCIuL2FyYml0cmFyeS9jb21wYXJlRnVuY1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImNvbXBhcmVGdW5jXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjb21wYXJlRnVuY18xLmNvbXBhcmVGdW5jOyB9IH0pO1xuY29uc3QgZnVuY18xID0gcmVxdWlyZShcIi4vYXJiaXRyYXJ5L2Z1bmNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJmdW5jXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBmdW5jXzEuZnVuYzsgfSB9KTtcbmNvbnN0IEhvc3RBcmJpdHJhcnlfMSA9IHJlcXVpcmUoXCIuL2NoZWNrL2FyYml0cmFyeS9Ib3N0QXJiaXRyYXJ5XCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZG9tYWluXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBIb3N0QXJiaXRyYXJ5XzEuZG9tYWluOyB9IH0pO1xuY29uc3QgaW50ZWdlcl8xID0gcmVxdWlyZShcIi4vYXJiaXRyYXJ5L2ludGVnZXJcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJpbnRlZ2VyXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBpbnRlZ2VyXzEuaW50ZWdlcjsgfSB9KTtcbmNvbnN0IG1heFNhZmVJbnRlZ2VyXzEgPSByZXF1aXJlKFwiLi9hcmJpdHJhcnkvbWF4U2FmZUludGVnZXJcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJtYXhTYWZlSW50ZWdlclwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbWF4U2FmZUludGVnZXJfMS5tYXhTYWZlSW50ZWdlcjsgfSB9KTtcbmNvbnN0IG1heFNhZmVOYXRfMSA9IHJlcXVpcmUoXCIuL2FyYml0cmFyeS9tYXhTYWZlTmF0XCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwibWF4U2FmZU5hdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbWF4U2FmZU5hdF8xLm1heFNhZmVOYXQ7IH0gfSk7XG5jb25zdCBuYXRfMSA9IHJlcXVpcmUoXCIuL2FyYml0cmFyeS9uYXRcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJuYXRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG5hdF8xLm5hdDsgfSB9KTtcbmNvbnN0IGlwVjRfMSA9IHJlcXVpcmUoXCIuL2FyYml0cmFyeS9pcFY0XCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiaXBWNFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaXBWNF8xLmlwVjQ7IH0gfSk7XG5jb25zdCBpcFY0RXh0ZW5kZWRfMSA9IHJlcXVpcmUoXCIuL2FyYml0cmFyeS9pcFY0RXh0ZW5kZWRcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJpcFY0RXh0ZW5kZWRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGlwVjRFeHRlbmRlZF8xLmlwVjRFeHRlbmRlZDsgfSB9KTtcbmNvbnN0IGlwVjZfMSA9IHJlcXVpcmUoXCIuL2FyYml0cmFyeS9pcFY2XCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiaXBWNlwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaXBWNl8xLmlwVjY7IH0gfSk7XG5jb25zdCBsZXRyZWNfMSA9IHJlcXVpcmUoXCIuL2FyYml0cmFyeS9sZXRyZWNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJsZXRyZWNcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGxldHJlY18xLmxldHJlYzsgfSB9KTtcbmNvbnN0IGxvcmVtXzEgPSByZXF1aXJlKFwiLi9hcmJpdHJhcnkvbG9yZW1cIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJsb3JlbVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbG9yZW1fMS5sb3JlbTsgfSB9KTtcbmNvbnN0IG1hcFRvQ29uc3RhbnRfMSA9IHJlcXVpcmUoXCIuL2FyYml0cmFyeS9tYXBUb0NvbnN0YW50XCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwibWFwVG9Db25zdGFudFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbWFwVG9Db25zdGFudF8xLm1hcFRvQ29uc3RhbnQ7IH0gfSk7XG5jb25zdCBtZW1vXzEgPSByZXF1aXJlKFwiLi9hcmJpdHJhcnkvbWVtb1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIm1lbW9cIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG1lbW9fMS5tZW1vOyB9IH0pO1xuY29uc3QgbWl4ZWRDYXNlXzEgPSByZXF1aXJlKFwiLi9hcmJpdHJhcnkvbWl4ZWRDYXNlXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwibWl4ZWRDYXNlXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBtaXhlZENhc2VfMS5taXhlZENhc2U7IH0gfSk7XG5jb25zdCBPYmplY3RBcmJpdHJhcnlfMSA9IHJlcXVpcmUoXCIuL2NoZWNrL2FyYml0cmFyeS9PYmplY3RBcmJpdHJhcnlcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJhbnl0aGluZ1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gT2JqZWN0QXJiaXRyYXJ5XzEuYW55dGhpbmc7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJqc29uXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBPYmplY3RBcmJpdHJhcnlfMS5qc29uOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwianNvbk9iamVjdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gT2JqZWN0QXJiaXRyYXJ5XzEuanNvbk9iamVjdDsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIm9iamVjdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gT2JqZWN0QXJiaXRyYXJ5XzEub2JqZWN0OyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwidW5pY29kZUpzb25cIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIE9iamVjdEFyYml0cmFyeV8xLnVuaWNvZGVKc29uOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwidW5pY29kZUpzb25PYmplY3RcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIE9iamVjdEFyYml0cmFyeV8xLnVuaWNvZGVKc29uT2JqZWN0OyB9IH0pO1xuY29uc3Qgb25lb2ZfMSA9IHJlcXVpcmUoXCIuL2FyYml0cmFyeS9vbmVvZlwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIm9uZW9mXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBvbmVvZl8xLm9uZW9mOyB9IH0pO1xuY29uc3Qgb3B0aW9uXzEgPSByZXF1aXJlKFwiLi9hcmJpdHJhcnkvb3B0aW9uXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwib3B0aW9uXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBvcHRpb25fMS5vcHRpb247IH0gfSk7XG5jb25zdCByZWNvcmRfMSA9IHJlcXVpcmUoXCIuL2FyYml0cmFyeS9yZWNvcmRcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJyZWNvcmRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHJlY29yZF8xLnJlY29yZDsgfSB9KTtcbmNvbnN0IHNldF8xID0gcmVxdWlyZShcIi4vYXJiaXRyYXJ5L3NldFwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInNldFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gc2V0XzEuc2V0OyB9IH0pO1xuY29uc3QgaW5maW5pdGVTdHJlYW1fMSA9IHJlcXVpcmUoXCIuL2FyYml0cmFyeS9pbmZpbml0ZVN0cmVhbVwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImluZmluaXRlU3RyZWFtXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBpbmZpbml0ZVN0cmVhbV8xLmluZmluaXRlU3RyZWFtOyB9IH0pO1xuY29uc3QgYXNjaWlTdHJpbmdfMSA9IHJlcXVpcmUoXCIuL2FyYml0cmFyeS9hc2NpaVN0cmluZ1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImFzY2lpU3RyaW5nXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBhc2NpaVN0cmluZ18xLmFzY2lpU3RyaW5nOyB9IH0pO1xuY29uc3QgYmFzZTY0U3RyaW5nXzEgPSByZXF1aXJlKFwiLi9hcmJpdHJhcnkvYmFzZTY0U3RyaW5nXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiYmFzZTY0U3RyaW5nXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBiYXNlNjRTdHJpbmdfMS5iYXNlNjRTdHJpbmc7IH0gfSk7XG5jb25zdCBmdWxsVW5pY29kZVN0cmluZ18xID0gcmVxdWlyZShcIi4vYXJiaXRyYXJ5L2Z1bGxVbmljb2RlU3RyaW5nXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZnVsbFVuaWNvZGVTdHJpbmdcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGZ1bGxVbmljb2RlU3RyaW5nXzEuZnVsbFVuaWNvZGVTdHJpbmc7IH0gfSk7XG5jb25zdCBoZXhhU3RyaW5nXzEgPSByZXF1aXJlKFwiLi9hcmJpdHJhcnkvaGV4YVN0cmluZ1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImhleGFTdHJpbmdcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGhleGFTdHJpbmdfMS5oZXhhU3RyaW5nOyB9IH0pO1xuY29uc3Qgc3RyaW5nXzEgPSByZXF1aXJlKFwiLi9hcmJpdHJhcnkvc3RyaW5nXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwic3RyaW5nXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBzdHJpbmdfMS5zdHJpbmc7IH0gfSk7XG5jb25zdCBzdHJpbmcxNmJpdHNfMSA9IHJlcXVpcmUoXCIuL2FyYml0cmFyeS9zdHJpbmcxNmJpdHNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJzdHJpbmcxNmJpdHNcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHN0cmluZzE2Yml0c18xLnN0cmluZzE2Yml0czsgfSB9KTtcbmNvbnN0IHN0cmluZ09mXzEgPSByZXF1aXJlKFwiLi9hcmJpdHJhcnkvc3RyaW5nT2ZcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJzdHJpbmdPZlwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gc3RyaW5nT2ZfMS5zdHJpbmdPZjsgfSB9KTtcbmNvbnN0IHVuaWNvZGVTdHJpbmdfMSA9IHJlcXVpcmUoXCIuL2FyYml0cmFyeS91bmljb2RlU3RyaW5nXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwidW5pY29kZVN0cmluZ1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdW5pY29kZVN0cmluZ18xLnVuaWNvZGVTdHJpbmc7IH0gfSk7XG5jb25zdCBTdWJhcnJheUFyYml0cmFyeV8xID0gcmVxdWlyZShcIi4vY2hlY2svYXJiaXRyYXJ5L1N1YmFycmF5QXJiaXRyYXJ5XCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwic2h1ZmZsZWRTdWJhcnJheVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gU3ViYXJyYXlBcmJpdHJhcnlfMS5zaHVmZmxlZFN1YmFycmF5OyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwic3ViYXJyYXlcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFN1YmFycmF5QXJiaXRyYXJ5XzEuc3ViYXJyYXk7IH0gfSk7XG5jb25zdCBnZW5lcmljVHVwbGVfMSA9IHJlcXVpcmUoXCIuL2FyYml0cmFyeS9nZW5lcmljVHVwbGVcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJnZW5lcmljVHVwbGVcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGdlbmVyaWNUdXBsZV8xLmdlbmVyaWNUdXBsZTsgfSB9KTtcbmNvbnN0IHR1cGxlXzEgPSByZXF1aXJlKFwiLi9hcmJpdHJhcnkvdHVwbGVcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJ0dXBsZVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdHVwbGVfMS50dXBsZTsgfSB9KTtcbmNvbnN0IFV1aWRBcmJpdHJhcnlfMSA9IHJlcXVpcmUoXCIuL2NoZWNrL2FyYml0cmFyeS9VdWlkQXJiaXRyYXJ5XCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwidXVpZFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gVXVpZEFyYml0cmFyeV8xLnV1aWQ7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJ1dWlkVlwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gVXVpZEFyYml0cmFyeV8xLnV1aWRWOyB9IH0pO1xuY29uc3QgV2ViQXJiaXRyYXJ5XzEgPSByZXF1aXJlKFwiLi9jaGVjay9hcmJpdHJhcnkvV2ViQXJiaXRyYXJ5XCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwid2ViQXV0aG9yaXR5XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBXZWJBcmJpdHJhcnlfMS53ZWJBdXRob3JpdHk7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJ3ZWJGcmFnbWVudHNcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFdlYkFyYml0cmFyeV8xLndlYkZyYWdtZW50czsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIndlYlF1ZXJ5UGFyYW1ldGVyc1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gV2ViQXJiaXRyYXJ5XzEud2ViUXVlcnlQYXJhbWV0ZXJzOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwid2ViU2VnbWVudFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gV2ViQXJiaXRyYXJ5XzEud2ViU2VnbWVudDsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIndlYlVybFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gV2ViQXJiaXRyYXJ5XzEud2ViVXJsOyB9IH0pO1xuY29uc3QgQ29tbWFuZHNBcmJpdHJhcnlfMSA9IHJlcXVpcmUoXCIuL2NoZWNrL21vZGVsL2NvbW1hbmRzL0NvbW1hbmRzQXJiaXRyYXJ5XCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiY29tbWFuZHNcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIENvbW1hbmRzQXJiaXRyYXJ5XzEuY29tbWFuZHM7IH0gfSk7XG5jb25zdCBNb2RlbFJ1bm5lcl8xID0gcmVxdWlyZShcIi4vY2hlY2svbW9kZWwvTW9kZWxSdW5uZXJcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJhc3luY01vZGVsUnVuXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBNb2RlbFJ1bm5lcl8xLmFzeW5jTW9kZWxSdW47IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJtb2RlbFJ1blwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gTW9kZWxSdW5uZXJfMS5tb2RlbFJ1bjsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInNjaGVkdWxlZE1vZGVsUnVuXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBNb2RlbFJ1bm5lcl8xLnNjaGVkdWxlZE1vZGVsUnVuOyB9IH0pO1xuY29uc3QgUmFuZG9tXzEgPSByZXF1aXJlKFwiLi9yYW5kb20vZ2VuZXJhdG9yL1JhbmRvbVwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlJhbmRvbVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gUmFuZG9tXzEuUmFuZG9tOyB9IH0pO1xuY29uc3QgR2xvYmFsUGFyYW1ldGVyc18xID0gcmVxdWlyZShcIi4vY2hlY2svcnVubmVyL2NvbmZpZ3VyYXRpb24vR2xvYmFsUGFyYW1ldGVyc1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImNvbmZpZ3VyZUdsb2JhbFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gR2xvYmFsUGFyYW1ldGVyc18xLmNvbmZpZ3VyZUdsb2JhbDsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInJlYWRDb25maWd1cmVHbG9iYWxcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIEdsb2JhbFBhcmFtZXRlcnNfMS5yZWFkQ29uZmlndXJlR2xvYmFsOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwicmVzZXRDb25maWd1cmVHbG9iYWxcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIEdsb2JhbFBhcmFtZXRlcnNfMS5yZXNldENvbmZpZ3VyZUdsb2JhbDsgfSB9KTtcbmNvbnN0IFZlcmJvc2l0eUxldmVsXzEgPSByZXF1aXJlKFwiLi9jaGVjay9ydW5uZXIvY29uZmlndXJhdGlvbi9WZXJib3NpdHlMZXZlbFwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlZlcmJvc2l0eUxldmVsXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBWZXJib3NpdHlMZXZlbF8xLlZlcmJvc2l0eUxldmVsOyB9IH0pO1xuY29uc3QgRXhlY3V0aW9uU3RhdHVzXzEgPSByZXF1aXJlKFwiLi9jaGVjay9ydW5uZXIvcmVwb3J0ZXIvRXhlY3V0aW9uU3RhdHVzXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiRXhlY3V0aW9uU3RhdHVzXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBFeGVjdXRpb25TdGF0dXNfMS5FeGVjdXRpb25TdGF0dXM7IH0gfSk7XG5jb25zdCBzeW1ib2xzXzEgPSByZXF1aXJlKFwiLi9jaGVjay9zeW1ib2xzXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiY2xvbmVNZXRob2RcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHN5bWJvbHNfMS5jbG9uZU1ldGhvZDsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImNsb25lSWZOZWVkZWRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHN5bWJvbHNfMS5jbG9uZUlmTmVlZGVkOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiaGFzQ2xvbmVNZXRob2RcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHN5bWJvbHNfMS5oYXNDbG9uZU1ldGhvZDsgfSB9KTtcbmNvbnN0IFN0cmVhbV8xID0gcmVxdWlyZShcIi4vc3RyZWFtL1N0cmVhbVwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlN0cmVhbVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gU3RyZWFtXzEuU3RyZWFtOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwic3RyZWFtXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBTdHJlYW1fMS5zdHJlYW07IH0gfSk7XG5jb25zdCBoYXNoXzEgPSByZXF1aXJlKFwiLi91dGlscy9oYXNoXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiaGFzaFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaGFzaF8xLmhhc2g7IH0gfSk7XG5jb25zdCBzdHJpbmdpZnlfMSA9IHJlcXVpcmUoXCIuL3V0aWxzL3N0cmluZ2lmeVwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInN0cmluZ2lmeVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gc3RyaW5naWZ5XzEuc3RyaW5naWZ5OyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiYXN5bmNTdHJpbmdpZnlcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHN0cmluZ2lmeV8xLmFzeW5jU3RyaW5naWZ5OyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwidG9TdHJpbmdNZXRob2RcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHN0cmluZ2lmeV8xLnRvU3RyaW5nTWV0aG9kOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiaGFzVG9TdHJpbmdNZXRob2RcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHN0cmluZ2lmeV8xLmhhc1RvU3RyaW5nTWV0aG9kOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiYXN5bmNUb1N0cmluZ01ldGhvZFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gc3RyaW5naWZ5XzEuYXN5bmNUb1N0cmluZ01ldGhvZDsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImhhc0FzeW5jVG9TdHJpbmdNZXRob2RcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHN0cmluZ2lmeV8xLmhhc0FzeW5jVG9TdHJpbmdNZXRob2Q7IH0gfSk7XG5jb25zdCBzY2hlZHVsZXJfMSA9IHJlcXVpcmUoXCIuL2FyYml0cmFyeS9zY2hlZHVsZXJcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJzY2hlZHVsZXJcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHNjaGVkdWxlcl8xLnNjaGVkdWxlcjsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInNjaGVkdWxlckZvclwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gc2NoZWR1bGVyXzEuc2NoZWR1bGVyRm9yOyB9IH0pO1xuY29uc3QgUnVuRGV0YWlsc0Zvcm1hdHRlcl8xID0gcmVxdWlyZShcIi4vY2hlY2svcnVubmVyL3V0aWxzL1J1bkRldGFpbHNGb3JtYXR0ZXJcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJkZWZhdWx0UmVwb3J0TWVzc2FnZVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gUnVuRGV0YWlsc0Zvcm1hdHRlcl8xLmRlZmF1bHRSZXBvcnRNZXNzYWdlOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiYXN5bmNEZWZhdWx0UmVwb3J0TWVzc2FnZVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gUnVuRGV0YWlsc0Zvcm1hdHRlcl8xLmFzeW5jRGVmYXVsdFJlcG9ydE1lc3NhZ2U7IH0gfSk7XG5jb25zdCBBcmJpdHJhcnlXaXRoU2hyaW5rXzEgPSByZXF1aXJlKFwiLi9jaGVjay9hcmJpdHJhcnkvZGVmaW5pdGlvbi9BcmJpdHJhcnlXaXRoU2hyaW5rXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQXJiaXRyYXJ5V2l0aFNocmlua1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gQXJiaXRyYXJ5V2l0aFNocmlua18xLkFyYml0cmFyeVdpdGhTaHJpbms7IH0gfSk7XG5jb25zdCBBcmJpdHJhcnlXaXRoQ29udGV4dHVhbFNocmlua18xID0gcmVxdWlyZShcIi4vY2hlY2svYXJiaXRyYXJ5L2RlZmluaXRpb24vQXJiaXRyYXJ5V2l0aENvbnRleHR1YWxTaHJpbmtcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJBcmJpdHJhcnlXaXRoQ29udGV4dHVhbFNocmlua1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gQXJiaXRyYXJ5V2l0aENvbnRleHR1YWxTaHJpbmtfMS5BcmJpdHJhcnlXaXRoQ29udGV4dHVhbFNocmluazsgfSB9KTtcbmNvbnN0IFByZWNvbmRpdGlvbkZhaWx1cmVfMSA9IHJlcXVpcmUoXCIuL2NoZWNrL3ByZWNvbmRpdGlvbi9QcmVjb25kaXRpb25GYWlsdXJlXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiUHJlY29uZGl0aW9uRmFpbHVyZVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gUHJlY29uZGl0aW9uRmFpbHVyZV8xLlByZWNvbmRpdGlvbkZhaWx1cmU7IH0gfSk7XG5jb25zdCBpbnQ4QXJyYXlfMSA9IHJlcXVpcmUoXCIuL2FyYml0cmFyeS9pbnQ4QXJyYXlcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJpbnQ4QXJyYXlcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGludDhBcnJheV8xLmludDhBcnJheTsgfSB9KTtcbmNvbnN0IGludDE2QXJyYXlfMSA9IHJlcXVpcmUoXCIuL2FyYml0cmFyeS9pbnQxNkFycmF5XCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiaW50MTZBcnJheVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaW50MTZBcnJheV8xLmludDE2QXJyYXk7IH0gfSk7XG5jb25zdCBpbnQzMkFycmF5XzEgPSByZXF1aXJlKFwiLi9hcmJpdHJhcnkvaW50MzJBcnJheVwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImludDMyQXJyYXlcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGludDMyQXJyYXlfMS5pbnQzMkFycmF5OyB9IH0pO1xuY29uc3QgdWludDhBcnJheV8xID0gcmVxdWlyZShcIi4vYXJiaXRyYXJ5L3VpbnQ4QXJyYXlcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJ1aW50OEFycmF5XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB1aW50OEFycmF5XzEudWludDhBcnJheTsgfSB9KTtcbmNvbnN0IHVpbnQ4Q2xhbXBlZEFycmF5XzEgPSByZXF1aXJlKFwiLi9hcmJpdHJhcnkvdWludDhDbGFtcGVkQXJyYXlcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJ1aW50OENsYW1wZWRBcnJheVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdWludDhDbGFtcGVkQXJyYXlfMS51aW50OENsYW1wZWRBcnJheTsgfSB9KTtcbmNvbnN0IHVpbnQxNkFycmF5XzEgPSByZXF1aXJlKFwiLi9hcmJpdHJhcnkvdWludDE2QXJyYXlcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJ1aW50MTZBcnJheVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdWludDE2QXJyYXlfMS51aW50MTZBcnJheTsgfSB9KTtcbmNvbnN0IHVpbnQzMkFycmF5XzEgPSByZXF1aXJlKFwiLi9hcmJpdHJhcnkvdWludDMyQXJyYXlcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJ1aW50MzJBcnJheVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdWludDMyQXJyYXlfMS51aW50MzJBcnJheTsgfSB9KTtcbmNvbnN0IGZsb2F0MzJBcnJheV8xID0gcmVxdWlyZShcIi4vYXJiaXRyYXJ5L2Zsb2F0MzJBcnJheVwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImZsb2F0MzJBcnJheVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZmxvYXQzMkFycmF5XzEuZmxvYXQzMkFycmF5OyB9IH0pO1xuY29uc3QgZmxvYXQ2NEFycmF5XzEgPSByZXF1aXJlKFwiLi9hcmJpdHJhcnkvZmxvYXQ2NEFycmF5XCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZmxvYXQ2NEFycmF5XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBmbG9hdDY0QXJyYXlfMS5mbG9hdDY0QXJyYXk7IH0gfSk7XG5jb25zdCBTcGFyc2VBcnJheUFyYml0cmFyeV8xID0gcmVxdWlyZShcIi4vY2hlY2svYXJiaXRyYXJ5L1NwYXJzZUFycmF5QXJiaXRyYXJ5XCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwic3BhcnNlQXJyYXlcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFNwYXJzZUFycmF5QXJiaXRyYXJ5XzEuc3BhcnNlQXJyYXk7IH0gfSk7XG5jb25zdCBOZXh0QXJiaXRyYXJ5XzEgPSByZXF1aXJlKFwiLi9jaGVjay9hcmJpdHJhcnkvZGVmaW5pdGlvbi9OZXh0QXJiaXRyYXJ5XCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiTmV4dEFyYml0cmFyeVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gTmV4dEFyYml0cmFyeV8xLk5leHRBcmJpdHJhcnk7IH0gfSk7XG5jb25zdCBOZXh0VmFsdWVfMSA9IHJlcXVpcmUoXCIuL2NoZWNrL2FyYml0cmFyeS9kZWZpbml0aW9uL05leHRWYWx1ZVwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIk5leHRWYWx1ZVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gTmV4dFZhbHVlXzEuTmV4dFZhbHVlOyB9IH0pO1xuY29uc3QgQ29udmVydGVyc18xID0gcmVxdWlyZShcIi4vY2hlY2svYXJiaXRyYXJ5L2RlZmluaXRpb24vQ29udmVydGVyc1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImNvbnZlcnRGcm9tTmV4dFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gQ29udmVydGVyc18xLmNvbnZlcnRGcm9tTmV4dDsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImNvbnZlcnRGcm9tTmV4dFdpdGhTaHJ1bmtPbmNlXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBDb252ZXJ0ZXJzXzEuY29udmVydEZyb21OZXh0V2l0aFNocnVua09uY2U7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJjb252ZXJ0VG9OZXh0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBDb252ZXJ0ZXJzXzEuY29udmVydFRvTmV4dDsgfSB9KTtcbmNvbnN0IF9fdHlwZSA9ICdjb21tb25qcyc7XG5leHBvcnRzLl9fdHlwZSA9IF9fdHlwZTtcbmNvbnN0IF9fdmVyc2lvbiA9ICcyLjE3LjAnO1xuZXhwb3J0cy5fX3ZlcnNpb24gPSBfX3ZlcnNpb247XG5jb25zdCBfX2NvbW1pdEhhc2ggPSAnYjcwNjRhMjE0MTJlYjllNjhlZGIzYWVjZTc0ZDQ1NTIyYzgwYmM3Nyc7XG5leHBvcnRzLl9fY29tbWl0SGFzaCA9IF9fY29tbWl0SGFzaDtcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH0pO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX2V4cG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9fZXhwb3J0U3RhcikgfHwgZnVuY3Rpb24obSwgZXhwb3J0cykge1xuICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKHAgIT09IFwiZGVmYXVsdFwiICYmICFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZXhwb3J0cywgcCkpIF9fY3JlYXRlQmluZGluZyhleHBvcnRzLCBtLCBwKTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBmYyA9IHJlcXVpcmUoXCIuL2Zhc3QtY2hlY2stZGVmYXVsdFwiKTtcbmV4cG9ydHMuZGVmYXVsdCA9IGZjO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2Zhc3QtY2hlY2stZGVmYXVsdFwiKSwgZXhwb3J0cyk7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuY29udmVydFRvUmFuZG9tR2VuZXJhdG9yID0gdm9pZCAwO1xuY2xhc3MgQ29udmVydGVkUmFuZG9tR2VuZXJhdG9yIHtcbiAgICBjb25zdHJ1Y3RvcihybmcpIHtcbiAgICAgICAgdGhpcy5ybmcgPSBybmc7XG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5ybmcuanVtcCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdGhpcy5qdW1wID0gZnVuY3Rpb24ganVtcCgpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBvdXQgPSB0aGlzLmp1bXAoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IENvbnZlcnRlZFJhbmRvbUdlbmVyYXRvcihvdXQpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRoaXMudW5zYWZlSnVtcCA9IGZ1bmN0aW9uIHVuc2FmZUp1bXAoKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgb3V0ID0gdGhpcy5qdW1wKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5ybmcgPSBvdXQ7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIG1pbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucm5nLm1pbigpO1xuICAgIH1cbiAgICBtYXgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJuZy5tYXgoKTtcbiAgICB9XG4gICAgY2xvbmUoKSB7XG4gICAgICAgIHJldHVybiBuZXcgQ29udmVydGVkUmFuZG9tR2VuZXJhdG9yKHRoaXMucm5nKTtcbiAgICB9XG4gICAgbmV4dCgpIHtcbiAgICAgICAgY29uc3Qgb3V0ID0gdGhpcy5ybmcubmV4dCgpO1xuICAgICAgICByZXR1cm4gW291dFswXSwgbmV3IENvbnZlcnRlZFJhbmRvbUdlbmVyYXRvcihvdXRbMV0pXTtcbiAgICB9XG4gICAgdW5zYWZlTmV4dCgpIHtcbiAgICAgICAgY29uc3Qgb3V0ID0gdGhpcy5ybmcubmV4dCgpO1xuICAgICAgICB0aGlzLnJuZyA9IG91dFsxXTtcbiAgICAgICAgcmV0dXJuIG91dFswXTtcbiAgICB9XG59XG5mdW5jdGlvbiBjb252ZXJ0VG9SYW5kb21HZW5lcmF0b3Iocm5nKSB7XG4gICAgaWYgKCdjbG9uZScgaW4gcm5nICYmICd1bnNhZmVOZXh0JyBpbiBybmcpIHtcbiAgICAgICAgcmV0dXJuIHJuZztcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBDb252ZXJ0ZWRSYW5kb21HZW5lcmF0b3Iocm5nKTtcbn1cbmV4cG9ydHMuY29udmVydFRvUmFuZG9tR2VuZXJhdG9yID0gY29udmVydFRvUmFuZG9tR2VuZXJhdG9yO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlJhbmRvbSA9IHZvaWQgMDtcbmNvbnN0IHB1cmVfcmFuZF8xID0gcmVxdWlyZShcInB1cmUtcmFuZFwiKTtcbmNvbnN0IFB1cmVSYW5kb21fMSA9IHJlcXVpcmUoXCIuL1B1cmVSYW5kb21cIik7XG5jbGFzcyBSYW5kb20ge1xuICAgIGNvbnN0cnVjdG9yKHNvdXJjZVJuZykge1xuICAgICAgICB0aGlzLmludGVybmFsUm5nID0gUHVyZVJhbmRvbV8xLmNvbnZlcnRUb1JhbmRvbUdlbmVyYXRvcihzb3VyY2VSbmcpLmNsb25lKCk7XG4gICAgfVxuICAgIGNsb25lKCkge1xuICAgICAgICByZXR1cm4gbmV3IFJhbmRvbSh0aGlzLmludGVybmFsUm5nKTtcbiAgICB9XG4gICAgbmV4dChiaXRzKSB7XG4gICAgICAgIHJldHVybiBwdXJlX3JhbmRfMS51bnNhZmVVbmlmb3JtSW50RGlzdHJpYnV0aW9uKDAsICgxIDw8IGJpdHMpIC0gMSwgdGhpcy5pbnRlcm5hbFJuZyk7XG4gICAgfVxuICAgIG5leHRCb29sZWFuKCkge1xuICAgICAgICByZXR1cm4gcHVyZV9yYW5kXzEudW5zYWZlVW5pZm9ybUludERpc3RyaWJ1dGlvbigwLCAxLCB0aGlzLmludGVybmFsUm5nKSA9PSAxO1xuICAgIH1cbiAgICBuZXh0SW50KG1pbiwgbWF4KSB7XG4gICAgICAgIHJldHVybiBwdXJlX3JhbmRfMS51bnNhZmVVbmlmb3JtSW50RGlzdHJpYnV0aW9uKG1pbiA9PSBudWxsID8gUmFuZG9tLk1JTl9JTlQgOiBtaW4sIG1heCA9PSBudWxsID8gUmFuZG9tLk1BWF9JTlQgOiBtYXgsIHRoaXMuaW50ZXJuYWxSbmcpO1xuICAgIH1cbiAgICBuZXh0QmlnSW50KG1pbiwgbWF4KSB7XG4gICAgICAgIHJldHVybiBwdXJlX3JhbmRfMS51bnNhZmVVbmlmb3JtQmlnSW50RGlzdHJpYnV0aW9uKG1pbiwgbWF4LCB0aGlzLmludGVybmFsUm5nKTtcbiAgICB9XG4gICAgbmV4dEFycmF5SW50KG1pbiwgbWF4KSB7XG4gICAgICAgIHJldHVybiBwdXJlX3JhbmRfMS51bnNhZmVVbmlmb3JtQXJyYXlJbnREaXN0cmlidXRpb24obWluLCBtYXgsIHRoaXMuaW50ZXJuYWxSbmcpO1xuICAgIH1cbiAgICBuZXh0RG91YmxlKCkge1xuICAgICAgICBjb25zdCBhID0gdGhpcy5uZXh0KDI2KTtcbiAgICAgICAgY29uc3QgYiA9IHRoaXMubmV4dCgyNyk7XG4gICAgICAgIHJldHVybiAoYSAqIFJhbmRvbS5EQkxfRkFDVE9SICsgYikgKiBSYW5kb20uREJMX0RJVklTT1I7XG4gICAgfVxufVxuZXhwb3J0cy5SYW5kb20gPSBSYW5kb207XG5SYW5kb20uTUlOX0lOVCA9IDB4ODAwMDAwMDAgfCAwO1xuUmFuZG9tLk1BWF9JTlQgPSAweDdmZmZmZmZmIHwgMDtcblJhbmRvbS5EQkxfRkFDVE9SID0gTWF0aC5wb3coMiwgMjcpO1xuUmFuZG9tLkRCTF9ESVZJU09SID0gTWF0aC5wb3coMiwgLTUzKTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5tYWtlTGF6eSA9IHZvaWQgMDtcbmNsYXNzIExhenlJdGVyYWJsZUl0ZXJhdG9yIHtcbiAgICBjb25zdHJ1Y3Rvcihwcm9kdWNlcikge1xuICAgICAgICB0aGlzLnByb2R1Y2VyID0gcHJvZHVjZXI7XG4gICAgfVxuICAgIFtTeW1ib2wuaXRlcmF0b3JdKCkge1xuICAgICAgICBpZiAodGhpcy5pdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLml0ID0gdGhpcy5wcm9kdWNlcigpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLml0O1xuICAgIH1cbiAgICBuZXh0KCkge1xuICAgICAgICBpZiAodGhpcy5pdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLml0ID0gdGhpcy5wcm9kdWNlcigpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLml0Lm5leHQoKTtcbiAgICB9XG59XG5mdW5jdGlvbiBtYWtlTGF6eShwcm9kdWNlcikge1xuICAgIHJldHVybiBuZXcgTGF6eUl0ZXJhYmxlSXRlcmF0b3IocHJvZHVjZXIpO1xufVxuZXhwb3J0cy5tYWtlTGF6eSA9IG1ha2VMYXp5O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnN0cmVhbSA9IGV4cG9ydHMuU3RyZWFtID0gdm9pZCAwO1xuY29uc3QgU3RyZWFtSGVscGVyc18xID0gcmVxdWlyZShcIi4vU3RyZWFtSGVscGVyc1wiKTtcbmNsYXNzIFN0cmVhbSB7XG4gICAgY29uc3RydWN0b3IoZykge1xuICAgICAgICB0aGlzLmcgPSBnO1xuICAgIH1cbiAgICBzdGF0aWMgbmlsKCkge1xuICAgICAgICByZXR1cm4gbmV3IFN0cmVhbShTdHJlYW1IZWxwZXJzXzEubmlsSGVscGVyKCkpO1xuICAgIH1cbiAgICBzdGF0aWMgb2YoLi4uZWxlbWVudHMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTdHJlYW0oZWxlbWVudHNbU3ltYm9sLml0ZXJhdG9yXSgpKTtcbiAgICB9XG4gICAgbmV4dCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZy5uZXh0KCk7XG4gICAgfVxuICAgIFtTeW1ib2wuaXRlcmF0b3JdKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nO1xuICAgIH1cbiAgICBtYXAoZikge1xuICAgICAgICByZXR1cm4gbmV3IFN0cmVhbShTdHJlYW1IZWxwZXJzXzEubWFwSGVscGVyKHRoaXMuZywgZikpO1xuICAgIH1cbiAgICBmbGF0TWFwKGYpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTdHJlYW0oU3RyZWFtSGVscGVyc18xLmZsYXRNYXBIZWxwZXIodGhpcy5nLCBmKSk7XG4gICAgfVxuICAgIGRyb3BXaGlsZShmKSB7XG4gICAgICAgIGxldCBmb3VuZEVsaWdpYmxlID0gZmFsc2U7XG4gICAgICAgIGZ1bmN0aW9uKiBoZWxwZXIodikge1xuICAgICAgICAgICAgaWYgKGZvdW5kRWxpZ2libGUgfHwgIWYodikpIHtcbiAgICAgICAgICAgICAgICBmb3VuZEVsaWdpYmxlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB5aWVsZCB2O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmZsYXRNYXAoaGVscGVyKTtcbiAgICB9XG4gICAgZHJvcChuKSB7XG4gICAgICAgIGxldCBpZHggPSAwO1xuICAgICAgICBmdW5jdGlvbiBoZWxwZXIoKSB7XG4gICAgICAgICAgICByZXR1cm4gaWR4KysgPCBuO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmRyb3BXaGlsZShoZWxwZXIpO1xuICAgIH1cbiAgICB0YWtlV2hpbGUoZikge1xuICAgICAgICByZXR1cm4gbmV3IFN0cmVhbShTdHJlYW1IZWxwZXJzXzEudGFrZVdoaWxlSGVscGVyKHRoaXMuZywgZikpO1xuICAgIH1cbiAgICB0YWtlKG4pIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTdHJlYW0oU3RyZWFtSGVscGVyc18xLnRha2VOSGVscGVyKHRoaXMuZywgbikpO1xuICAgIH1cbiAgICBmaWx0ZXIoZikge1xuICAgICAgICByZXR1cm4gbmV3IFN0cmVhbShTdHJlYW1IZWxwZXJzXzEuZmlsdGVySGVscGVyKHRoaXMuZywgZikpO1xuICAgIH1cbiAgICBldmVyeShmKSB7XG4gICAgICAgIGZvciAoY29uc3QgdiBvZiB0aGlzLmcpIHtcbiAgICAgICAgICAgIGlmICghZih2KSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaGFzKGYpIHtcbiAgICAgICAgZm9yIChjb25zdCB2IG9mIHRoaXMuZykge1xuICAgICAgICAgICAgaWYgKGYodikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gW3RydWUsIHZdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbZmFsc2UsIG51bGxdO1xuICAgIH1cbiAgICBqb2luKC4uLm90aGVycykge1xuICAgICAgICByZXR1cm4gbmV3IFN0cmVhbShTdHJlYW1IZWxwZXJzXzEuam9pbkhlbHBlcih0aGlzLmcsIG90aGVycykpO1xuICAgIH1cbiAgICBnZXROdGhPckxhc3QobnRoKSB7XG4gICAgICAgIGxldCByZW1haW5pbmcgPSBudGg7XG4gICAgICAgIGxldCBsYXN0ID0gbnVsbDtcbiAgICAgICAgZm9yIChjb25zdCB2IG9mIHRoaXMuZykge1xuICAgICAgICAgICAgaWYgKHJlbWFpbmluZy0tID09PSAwKVxuICAgICAgICAgICAgICAgIHJldHVybiB2O1xuICAgICAgICAgICAgbGFzdCA9IHY7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxhc3Q7XG4gICAgfVxufVxuZXhwb3J0cy5TdHJlYW0gPSBTdHJlYW07XG5mdW5jdGlvbiBzdHJlYW0oZykge1xuICAgIHJldHVybiBuZXcgU3RyZWFtKGcpO1xufVxuZXhwb3J0cy5zdHJlYW0gPSBzdHJlYW07XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuam9pbkhlbHBlciA9IGV4cG9ydHMudGFrZVdoaWxlSGVscGVyID0gZXhwb3J0cy50YWtlTkhlbHBlciA9IGV4cG9ydHMuZmlsdGVySGVscGVyID0gZXhwb3J0cy5mbGF0TWFwSGVscGVyID0gZXhwb3J0cy5tYXBIZWxwZXIgPSBleHBvcnRzLm5pbEhlbHBlciA9IHZvaWQgMDtcbmNsYXNzIE5pbCB7XG4gICAgW1N5bWJvbC5pdGVyYXRvcl0oKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBuZXh0KHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB7IHZhbHVlLCBkb25lOiB0cnVlIH07XG4gICAgfVxufVxuTmlsLm5pbCA9IG5ldyBOaWwoKTtcbmZ1bmN0aW9uIG5pbEhlbHBlcigpIHtcbiAgICByZXR1cm4gTmlsLm5pbDtcbn1cbmV4cG9ydHMubmlsSGVscGVyID0gbmlsSGVscGVyO1xuZnVuY3Rpb24qIG1hcEhlbHBlcihnLCBmKSB7XG4gICAgZm9yIChjb25zdCB2IG9mIGcpIHtcbiAgICAgICAgeWllbGQgZih2KTtcbiAgICB9XG59XG5leHBvcnRzLm1hcEhlbHBlciA9IG1hcEhlbHBlcjtcbmZ1bmN0aW9uKiBmbGF0TWFwSGVscGVyKGcsIGYpIHtcbiAgICBmb3IgKGNvbnN0IHYgb2YgZykge1xuICAgICAgICB5aWVsZCogZih2KTtcbiAgICB9XG59XG5leHBvcnRzLmZsYXRNYXBIZWxwZXIgPSBmbGF0TWFwSGVscGVyO1xuZnVuY3Rpb24qIGZpbHRlckhlbHBlcihnLCBmKSB7XG4gICAgZm9yIChjb25zdCB2IG9mIGcpIHtcbiAgICAgICAgaWYgKGYodikpIHtcbiAgICAgICAgICAgIHlpZWxkIHY7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLmZpbHRlckhlbHBlciA9IGZpbHRlckhlbHBlcjtcbmZ1bmN0aW9uKiB0YWtlTkhlbHBlcihnLCBuKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgICAgY29uc3QgY3VyID0gZy5uZXh0KCk7XG4gICAgICAgIGlmIChjdXIuZG9uZSkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgeWllbGQgY3VyLnZhbHVlO1xuICAgIH1cbn1cbmV4cG9ydHMudGFrZU5IZWxwZXIgPSB0YWtlTkhlbHBlcjtcbmZ1bmN0aW9uKiB0YWtlV2hpbGVIZWxwZXIoZywgZikge1xuICAgIGxldCBjdXIgPSBnLm5leHQoKTtcbiAgICB3aGlsZSAoIWN1ci5kb25lICYmIGYoY3VyLnZhbHVlKSkge1xuICAgICAgICB5aWVsZCBjdXIudmFsdWU7XG4gICAgICAgIGN1ciA9IGcubmV4dCgpO1xuICAgIH1cbn1cbmV4cG9ydHMudGFrZVdoaWxlSGVscGVyID0gdGFrZVdoaWxlSGVscGVyO1xuZnVuY3Rpb24qIGpvaW5IZWxwZXIoZywgb3RoZXJzKSB7XG4gICAgZm9yIChsZXQgY3VyID0gZy5uZXh0KCk7ICFjdXIuZG9uZTsgY3VyID0gZy5uZXh0KCkpIHtcbiAgICAgICAgeWllbGQgY3VyLnZhbHVlO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IHMgb2Ygb3RoZXJzKSB7XG4gICAgICAgIGZvciAobGV0IGN1ciA9IHMubmV4dCgpOyAhY3VyLmRvbmU7IGN1ciA9IHMubmV4dCgpKSB7XG4gICAgICAgICAgICB5aWVsZCBjdXIudmFsdWU7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLmpvaW5IZWxwZXIgPSBqb2luSGVscGVyO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmhhc2ggPSB2b2lkIDA7XG5jb25zdCBjcmMzMlRhYmxlID0gW1xuICAgIDB4MDAwMDAwMDAsIDB4NzcwNzMwOTYsIDB4ZWUwZTYxMmMsIDB4OTkwOTUxYmEsIDB4MDc2ZGM0MTksIDB4NzA2YWY0OGYsIDB4ZTk2M2E1MzUsIDB4OWU2NDk1YTMsIDB4MGVkYjg4MzIsXG4gICAgMHg3OWRjYjhhNCwgMHhlMGQ1ZTkxZSwgMHg5N2QyZDk4OCwgMHgwOWI2NGMyYiwgMHg3ZWIxN2NiZCwgMHhlN2I4MmQwNywgMHg5MGJmMWQ5MSwgMHgxZGI3MTA2NCwgMHg2YWIwMjBmMixcbiAgICAweGYzYjk3MTQ4LCAweDg0YmU0MWRlLCAweDFhZGFkNDdkLCAweDZkZGRlNGViLCAweGY0ZDRiNTUxLCAweDgzZDM4NWM3LCAweDEzNmM5ODU2LCAweDY0NmJhOGMwLCAweGZkNjJmOTdhLFxuICAgIDB4OGE2NWM5ZWMsIDB4MTQwMTVjNGYsIDB4NjMwNjZjZDksIDB4ZmEwZjNkNjMsIDB4OGQwODBkZjUsIDB4M2I2ZTIwYzgsIDB4NGM2OTEwNWUsIDB4ZDU2MDQxZTQsIDB4YTI2NzcxNzIsXG4gICAgMHgzYzAzZTRkMSwgMHg0YjA0ZDQ0NywgMHhkMjBkODVmZCwgMHhhNTBhYjU2YiwgMHgzNWI1YThmYSwgMHg0MmIyOTg2YywgMHhkYmJiYzlkNiwgMHhhY2JjZjk0MCwgMHgzMmQ4NmNlMyxcbiAgICAweDQ1ZGY1Yzc1LCAweGRjZDYwZGNmLCAweGFiZDEzZDU5LCAweDI2ZDkzMGFjLCAweDUxZGUwMDNhLCAweGM4ZDc1MTgwLCAweGJmZDA2MTE2LCAweDIxYjRmNGI1LCAweDU2YjNjNDIzLFxuICAgIDB4Y2ZiYTk1OTksIDB4YjhiZGE1MGYsIDB4MjgwMmI4OWUsIDB4NWYwNTg4MDgsIDB4YzYwY2Q5YjIsIDB4YjEwYmU5MjQsIDB4MmY2ZjdjODcsIDB4NTg2ODRjMTEsIDB4YzE2MTFkYWIsXG4gICAgMHhiNjY2MmQzZCwgMHg3NmRjNDE5MCwgMHgwMWRiNzEwNiwgMHg5OGQyMjBiYywgMHhlZmQ1MTAyYSwgMHg3MWIxODU4OSwgMHgwNmI2YjUxZiwgMHg5ZmJmZTRhNSwgMHhlOGI4ZDQzMyxcbiAgICAweDc4MDdjOWEyLCAweDBmMDBmOTM0LCAweDk2MDlhODhlLCAweGUxMGU5ODE4LCAweDdmNmEwZGJiLCAweDA4NmQzZDJkLCAweDkxNjQ2Yzk3LCAweGU2NjM1YzAxLCAweDZiNmI1MWY0LFxuICAgIDB4MWM2YzYxNjIsIDB4ODU2NTMwZDgsIDB4ZjI2MjAwNGUsIDB4NmMwNjk1ZWQsIDB4MWIwMWE1N2IsIDB4ODIwOGY0YzEsIDB4ZjUwZmM0NTcsIDB4NjViMGQ5YzYsIDB4MTJiN2U5NTAsXG4gICAgMHg4YmJlYjhlYSwgMHhmY2I5ODg3YywgMHg2MmRkMWRkZiwgMHgxNWRhMmQ0OSwgMHg4Y2QzN2NmMywgMHhmYmQ0NGM2NSwgMHg0ZGIyNjE1OCwgMHgzYWI1NTFjZSwgMHhhM2JjMDA3NCxcbiAgICAweGQ0YmIzMGUyLCAweDRhZGZhNTQxLCAweDNkZDg5NWQ3LCAweGE0ZDFjNDZkLCAweGQzZDZmNGZiLCAweDQzNjllOTZhLCAweDM0NmVkOWZjLCAweGFkNjc4ODQ2LCAweGRhNjBiOGQwLFxuICAgIDB4NDQwNDJkNzMsIDB4MzMwMzFkZTUsIDB4YWEwYTRjNWYsIDB4ZGQwZDdjYzksIDB4NTAwNTcxM2MsIDB4MjcwMjQxYWEsIDB4YmUwYjEwMTAsIDB4YzkwYzIwODYsIDB4NTc2OGI1MjUsXG4gICAgMHgyMDZmODViMywgMHhiOTY2ZDQwOSwgMHhjZTYxZTQ5ZiwgMHg1ZWRlZjkwZSwgMHgyOWQ5Yzk5OCwgMHhiMGQwOTgyMiwgMHhjN2Q3YThiNCwgMHg1OWIzM2QxNywgMHgyZWI0MGQ4MSxcbiAgICAweGI3YmQ1YzNiLCAweGMwYmE2Y2FkLCAweGVkYjg4MzIwLCAweDlhYmZiM2I2LCAweDAzYjZlMjBjLCAweDc0YjFkMjlhLCAweGVhZDU0NzM5LCAweDlkZDI3N2FmLCAweDA0ZGIyNjE1LFxuICAgIDB4NzNkYzE2ODMsIDB4ZTM2MzBiMTIsIDB4OTQ2NDNiODQsIDB4MGQ2ZDZhM2UsIDB4N2E2YTVhYTgsIDB4ZTQwZWNmMGIsIDB4OTMwOWZmOWQsIDB4MGEwMGFlMjcsIDB4N2QwNzllYjEsXG4gICAgMHhmMDBmOTM0NCwgMHg4NzA4YTNkMiwgMHgxZTAxZjI2OCwgMHg2OTA2YzJmZSwgMHhmNzYyNTc1ZCwgMHg4MDY1NjdjYiwgMHgxOTZjMzY3MSwgMHg2ZTZiMDZlNywgMHhmZWQ0MWI3NixcbiAgICAweDg5ZDMyYmUwLCAweDEwZGE3YTVhLCAweDY3ZGQ0YWNjLCAweGY5YjlkZjZmLCAweDhlYmVlZmY5LCAweDE3YjdiZTQzLCAweDYwYjA4ZWQ1LCAweGQ2ZDZhM2U4LCAweGExZDE5MzdlLFxuICAgIDB4MzhkOGMyYzQsIDB4NGZkZmYyNTIsIDB4ZDFiYjY3ZjEsIDB4YTZiYzU3NjcsIDB4M2ZiNTA2ZGQsIDB4NDhiMjM2NGIsIDB4ZDgwZDJiZGEsIDB4YWYwYTFiNGMsIDB4MzYwMzRhZjYsXG4gICAgMHg0MTA0N2E2MCwgMHhkZjYwZWZjMywgMHhhODY3ZGY1NSwgMHgzMTZlOGVlZiwgMHg0NjY5YmU3OSwgMHhjYjYxYjM4YywgMHhiYzY2ODMxYSwgMHgyNTZmZDJhMCwgMHg1MjY4ZTIzNixcbiAgICAweGNjMGM3Nzk1LCAweGJiMGI0NzAzLCAweDIyMDIxNmI5LCAweDU1MDUyNjJmLCAweGM1YmEzYmJlLCAweGIyYmQwYjI4LCAweDJiYjQ1YTkyLCAweDVjYjM2YTA0LCAweGMyZDdmZmE3LFxuICAgIDB4YjVkMGNmMzEsIDB4MmNkOTllOGIsIDB4NWJkZWFlMWQsIDB4OWI2NGMyYjAsIDB4ZWM2M2YyMjYsIDB4NzU2YWEzOWMsIDB4MDI2ZDkzMGEsIDB4OWMwOTA2YTksIDB4ZWIwZTM2M2YsXG4gICAgMHg3MjA3Njc4NSwgMHgwNTAwNTcxMywgMHg5NWJmNGE4MiwgMHhlMmI4N2ExNCwgMHg3YmIxMmJhZSwgMHgwY2I2MWIzOCwgMHg5MmQyOGU5YiwgMHhlNWQ1YmUwZCwgMHg3Y2RjZWZiNyxcbiAgICAweDBiZGJkZjIxLCAweDg2ZDNkMmQ0LCAweGYxZDRlMjQyLCAweDY4ZGRiM2Y4LCAweDFmZGE4MzZlLCAweDgxYmUxNmNkLCAweGY2YjkyNjViLCAweDZmYjA3N2UxLCAweDE4Yjc0Nzc3LFxuICAgIDB4ODgwODVhZTYsIDB4ZmYwZjZhNzAsIDB4NjYwNjNiY2EsIDB4MTEwMTBiNWMsIDB4OGY2NTllZmYsIDB4Zjg2MmFlNjksIDB4NjE2YmZmZDMsIDB4MTY2Y2NmNDUsIDB4YTAwYWUyNzgsXG4gICAgMHhkNzBkZDJlZSwgMHg0ZTA0ODM1NCwgMHgzOTAzYjNjMiwgMHhhNzY3MjY2MSwgMHhkMDYwMTZmNywgMHg0OTY5NDc0ZCwgMHgzZTZlNzdkYiwgMHhhZWQxNmE0YSwgMHhkOWQ2NWFkYyxcbiAgICAweDQwZGYwYjY2LCAweDM3ZDgzYmYwLCAweGE5YmNhZTUzLCAweGRlYmI5ZWM1LCAweDQ3YjJjZjdmLCAweDMwYjVmZmU5LCAweGJkYmRmMjFjLCAweGNhYmFjMjhhLCAweDUzYjM5MzMwLFxuICAgIDB4MjRiNGEzYTYsIDB4YmFkMDM2MDUsIDB4Y2RkNzA2OTMsIDB4NTRkZTU3MjksIDB4MjNkOTY3YmYsIDB4YjM2NjdhMmUsIDB4YzQ2MTRhYjgsIDB4NWQ2ODFiMDIsIDB4MmE2ZjJiOTQsXG4gICAgMHhiNDBiYmUzNywgMHhjMzBjOGVhMSwgMHg1YTA1ZGYxYiwgMHgyZDAyZWY4ZCxcbl07XG5mdW5jdGlvbiBoYXNoKHJlcHIpIHtcbiAgICBsZXQgY3JjID0gMHhmZmZmZmZmZjtcbiAgICBmb3IgKGxldCBpZHggPSAwOyBpZHggPCByZXByLmxlbmd0aDsgKytpZHgpIHtcbiAgICAgICAgY29uc3QgYyA9IHJlcHIuY2hhckNvZGVBdChpZHgpO1xuICAgICAgICBpZiAoYyA8IDB4ODApIHtcbiAgICAgICAgICAgIGNyYyA9IGNyYzMyVGFibGVbKGNyYyAmIDB4ZmYpIF4gY10gXiAoY3JjID4+IDgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGMgPCAweDgwMCkge1xuICAgICAgICAgICAgY3JjID0gY3JjMzJUYWJsZVsoY3JjICYgMHhmZikgXiAoMTkyIHwgKChjID4+IDYpICYgMzEpKV0gXiAoY3JjID4+IDgpO1xuICAgICAgICAgICAgY3JjID0gY3JjMzJUYWJsZVsoY3JjICYgMHhmZikgXiAoMTI4IHwgKGMgJiA2MykpXSBeIChjcmMgPj4gOCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYyA+PSAweGQ4MDAgJiYgYyA8IDB4ZTAwMCkge1xuICAgICAgICAgICAgY29uc3QgY05leHQgPSByZXByLmNoYXJDb2RlQXQoKytpZHgpO1xuICAgICAgICAgICAgaWYgKGMgPj0gMHhkYzAwIHx8IGNOZXh0IDwgMHhkYzAwIHx8IGNOZXh0ID4gMHhkZmZmIHx8IE51bWJlci5pc05hTihjTmV4dCkpIHtcbiAgICAgICAgICAgICAgICBpZHggLT0gMTtcbiAgICAgICAgICAgICAgICBjcmMgPSBjcmMzMlRhYmxlWyhjcmMgJiAweGZmKSBeIDB4ZWZdIF4gKGNyYyA+PiA4KTtcbiAgICAgICAgICAgICAgICBjcmMgPSBjcmMzMlRhYmxlWyhjcmMgJiAweGZmKSBeIDB4YmZdIF4gKGNyYyA+PiA4KTtcbiAgICAgICAgICAgICAgICBjcmMgPSBjcmMzMlRhYmxlWyhjcmMgJiAweGZmKSBeIDB4YmRdIF4gKGNyYyA+PiA4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IGMxID0gKGMgJiAxMDIzKSArIDY0O1xuICAgICAgICAgICAgICAgIGNvbnN0IGMyID0gY05leHQgJiAxMDIzO1xuICAgICAgICAgICAgICAgIGNyYyA9IGNyYzMyVGFibGVbKGNyYyAmIDB4ZmYpIF4gKDI0MCB8ICgoYzEgPj4gOCkgJiA3KSldIF4gKGNyYyA+PiA4KTtcbiAgICAgICAgICAgICAgICBjcmMgPSBjcmMzMlRhYmxlWyhjcmMgJiAweGZmKSBeICgxMjggfCAoKGMxID4+IDIpICYgNjMpKV0gXiAoY3JjID4+IDgpO1xuICAgICAgICAgICAgICAgIGNyYyA9IGNyYzMyVGFibGVbKGNyYyAmIDB4ZmYpIF4gKDEyOCB8ICgoYzIgPj4gNikgJiAxNSkgfCAoKGMxICYgMykgPDwgNCkpXSBeIChjcmMgPj4gOCk7XG4gICAgICAgICAgICAgICAgY3JjID0gY3JjMzJUYWJsZVsoY3JjICYgMHhmZikgXiAoMTI4IHwgKGMyICYgNjMpKV0gXiAoY3JjID4+IDgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY3JjID0gY3JjMzJUYWJsZVsoY3JjICYgMHhmZikgXiAoMjI0IHwgKChjID4+IDEyKSAmIDE1KSldIF4gKGNyYyA+PiA4KTtcbiAgICAgICAgICAgIGNyYyA9IGNyYzMyVGFibGVbKGNyYyAmIDB4ZmYpIF4gKDEyOCB8ICgoYyA+PiA2KSAmIDYzKSldIF4gKGNyYyA+PiA4KTtcbiAgICAgICAgICAgIGNyYyA9IGNyYzMyVGFibGVbKGNyYyAmIDB4ZmYpIF4gKDEyOCB8IChjICYgNjMpKV0gXiAoY3JjID4+IDgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiAoY3JjIHwgMCkgKyAweDgwMDAwMDAwO1xufVxuZXhwb3J0cy5oYXNoID0gaGFzaDtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5hc3luY1N0cmluZ2lmeSA9IGV4cG9ydHMucG9zc2libHlBc3luY1N0cmluZ2lmeSA9IGV4cG9ydHMuc3RyaW5naWZ5ID0gZXhwb3J0cy5zdHJpbmdpZnlJbnRlcm5hbCA9IGV4cG9ydHMuaGFzQXN5bmNUb1N0cmluZ01ldGhvZCA9IGV4cG9ydHMuYXN5bmNUb1N0cmluZ01ldGhvZCA9IGV4cG9ydHMuaGFzVG9TdHJpbmdNZXRob2QgPSBleHBvcnRzLnRvU3RyaW5nTWV0aG9kID0gdm9pZCAwO1xuZXhwb3J0cy50b1N0cmluZ01ldGhvZCA9IFN5bWJvbCgnZmFzdC1jaGVjay90b1N0cmluZ01ldGhvZCcpO1xuZnVuY3Rpb24gaGFzVG9TdHJpbmdNZXRob2QoaW5zdGFuY2UpIHtcbiAgICByZXR1cm4gKGluc3RhbmNlICE9PSBudWxsICYmXG4gICAgICAgICh0eXBlb2YgaW5zdGFuY2UgPT09ICdvYmplY3QnIHx8IHR5cGVvZiBpbnN0YW5jZSA9PT0gJ2Z1bmN0aW9uJykgJiZcbiAgICAgICAgZXhwb3J0cy50b1N0cmluZ01ldGhvZCBpbiBpbnN0YW5jZSAmJlxuICAgICAgICB0eXBlb2YgaW5zdGFuY2VbZXhwb3J0cy50b1N0cmluZ01ldGhvZF0gPT09ICdmdW5jdGlvbicpO1xufVxuZXhwb3J0cy5oYXNUb1N0cmluZ01ldGhvZCA9IGhhc1RvU3RyaW5nTWV0aG9kO1xuZXhwb3J0cy5hc3luY1RvU3RyaW5nTWV0aG9kID0gU3ltYm9sKCdmYXN0LWNoZWNrL2FzeW5jVG9TdHJpbmdNZXRob2QnKTtcbmZ1bmN0aW9uIGhhc0FzeW5jVG9TdHJpbmdNZXRob2QoaW5zdGFuY2UpIHtcbiAgICByZXR1cm4gKGluc3RhbmNlICE9PSBudWxsICYmXG4gICAgICAgICh0eXBlb2YgaW5zdGFuY2UgPT09ICdvYmplY3QnIHx8IHR5cGVvZiBpbnN0YW5jZSA9PT0gJ2Z1bmN0aW9uJykgJiZcbiAgICAgICAgZXhwb3J0cy5hc3luY1RvU3RyaW5nTWV0aG9kIGluIGluc3RhbmNlICYmXG4gICAgICAgIHR5cGVvZiBpbnN0YW5jZVtleHBvcnRzLmFzeW5jVG9TdHJpbmdNZXRob2RdID09PSAnZnVuY3Rpb24nKTtcbn1cbmV4cG9ydHMuaGFzQXN5bmNUb1N0cmluZ01ldGhvZCA9IGhhc0FzeW5jVG9TdHJpbmdNZXRob2Q7XG5jb25zdCBmaW5kU3ltYm9sTmFtZVJlZ2V4ID0gL15TeW1ib2xcXCgoLiopXFwpJC87XG5mdW5jdGlvbiBnZXRTeW1ib2xEZXNjcmlwdGlvbihzKSB7XG4gICAgaWYgKHMuZGVzY3JpcHRpb24gIT09IHVuZGVmaW5lZClcbiAgICAgICAgcmV0dXJuIHMuZGVzY3JpcHRpb247XG4gICAgY29uc3QgbSA9IGZpbmRTeW1ib2xOYW1lUmVnZXguZXhlYyhTdHJpbmcocykpO1xuICAgIHJldHVybiBtICYmIG1bMV0ubGVuZ3RoID8gbVsxXSA6IG51bGw7XG59XG5mdW5jdGlvbiBzdHJpbmdpZnlOdW1iZXIobnVtVmFsdWUpIHtcbiAgICBzd2l0Y2ggKG51bVZhbHVlKSB7XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIHJldHVybiAxIC8gbnVtVmFsdWUgPT09IE51bWJlci5ORUdBVElWRV9JTkZJTklUWSA/ICctMCcgOiAnMCc7XG4gICAgICAgIGNhc2UgTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZOlxuICAgICAgICAgICAgcmV0dXJuICdOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFknO1xuICAgICAgICBjYXNlIE51bWJlci5QT1NJVElWRV9JTkZJTklUWTpcbiAgICAgICAgICAgIHJldHVybiAnTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZJztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBudW1WYWx1ZSA9PT0gbnVtVmFsdWUgPyBTdHJpbmcobnVtVmFsdWUpIDogJ051bWJlci5OYU4nO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGlzU3BhcnNlQXJyYXkoYXJyKSB7XG4gICAgbGV0IHByZXZpb3VzTnVtYmVyZWRJbmRleCA9IC0xO1xuICAgIGZvciAoY29uc3QgaW5kZXggaW4gYXJyKSB7XG4gICAgICAgIGNvbnN0IG51bWJlcmVkSW5kZXggPSBOdW1iZXIoaW5kZXgpO1xuICAgICAgICBpZiAobnVtYmVyZWRJbmRleCAhPT0gcHJldmlvdXNOdW1iZXJlZEluZGV4ICsgMSlcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICBwcmV2aW91c051bWJlcmVkSW5kZXggPSBudW1iZXJlZEluZGV4O1xuICAgIH1cbiAgICByZXR1cm4gcHJldmlvdXNOdW1iZXJlZEluZGV4ICsgMSAhPT0gYXJyLmxlbmd0aDtcbn1cbmZ1bmN0aW9uIHN0cmluZ2lmeUludGVybmFsKHZhbHVlLCBwcmV2aW91c1ZhbHVlcywgZ2V0QXN5bmNDb250ZW50KSB7XG4gICAgY29uc3QgY3VycmVudFZhbHVlcyA9IHByZXZpb3VzVmFsdWVzLmNvbmNhdChbdmFsdWVdKTtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnb2JqZWN0Jykge1xuICAgICAgICBpZiAocHJldmlvdXNWYWx1ZXMuaW5kZXhPZih2YWx1ZSkgIT09IC0xKSB7XG4gICAgICAgICAgICByZXR1cm4gJ1tjeWNsaWNdJztcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoaGFzQXN5bmNUb1N0cmluZ01ldGhvZCh2YWx1ZSkpIHtcbiAgICAgICAgY29uc3QgY29udGVudCA9IGdldEFzeW5jQ29udGVudCh2YWx1ZSk7XG4gICAgICAgIGlmIChjb250ZW50LnN0YXRlID09PSAnZnVsZmlsbGVkJykge1xuICAgICAgICAgICAgcmV0dXJuIGNvbnRlbnQudmFsdWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGhhc1RvU3RyaW5nTWV0aG9kKHZhbHVlKSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlW2V4cG9ydHMudG9TdHJpbmdNZXRob2RdKCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICB9XG4gICAgfVxuICAgIHN3aXRjaCAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSkge1xuICAgICAgICBjYXNlICdbb2JqZWN0IEFycmF5XSc6IHtcbiAgICAgICAgICAgIGNvbnN0IGFyciA9IHZhbHVlO1xuICAgICAgICAgICAgaWYgKGFyci5sZW5ndGggPj0gNTAgJiYgaXNTcGFyc2VBcnJheShhcnIpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYXNzaWdubWVudHMgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGluZGV4IGluIGFycikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIU51bWJlci5pc05hTihOdW1iZXIoaW5kZXgpKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGFzc2lnbm1lbnRzLnB1c2goYCR7aW5kZXh9OiR7c3RyaW5naWZ5SW50ZXJuYWwoYXJyW2luZGV4XSwgY3VycmVudFZhbHVlcywgZ2V0QXN5bmNDb250ZW50KX1gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFzc2lnbm1lbnRzLmxlbmd0aCAhPT0gMFxuICAgICAgICAgICAgICAgICAgICA/IGBPYmplY3QuYXNzaWduKEFycmF5KCR7YXJyLmxlbmd0aH0pLHske2Fzc2lnbm1lbnRzLmpvaW4oJywnKX19KWBcbiAgICAgICAgICAgICAgICAgICAgOiBgQXJyYXkoJHthcnIubGVuZ3RofSlgO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgc3RyaW5naWZpZWRBcnJheSA9IGFyci5tYXAoKHYpID0+IHN0cmluZ2lmeUludGVybmFsKHYsIGN1cnJlbnRWYWx1ZXMsIGdldEFzeW5jQ29udGVudCkpLmpvaW4oJywnKTtcbiAgICAgICAgICAgIHJldHVybiBhcnIubGVuZ3RoID09PSAwIHx8IGFyci5sZW5ndGggLSAxIGluIGFyciA/IGBbJHtzdHJpbmdpZmllZEFycmF5fV1gIDogYFske3N0cmluZ2lmaWVkQXJyYXl9LF1gO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgJ1tvYmplY3QgQmlnSW50XSc6XG4gICAgICAgICAgICByZXR1cm4gYCR7dmFsdWV9bmA7XG4gICAgICAgIGNhc2UgJ1tvYmplY3QgQm9vbGVhbl0nOlxuICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nID8gSlNPTi5zdHJpbmdpZnkodmFsdWUpIDogYG5ldyBCb29sZWFuKCR7SlNPTi5zdHJpbmdpZnkodmFsdWUpfSlgO1xuICAgICAgICBjYXNlICdbb2JqZWN0IERhdGVdJzoge1xuICAgICAgICAgICAgY29uc3QgZCA9IHZhbHVlO1xuICAgICAgICAgICAgcmV0dXJuIE51bWJlci5pc05hTihkLmdldFRpbWUoKSkgPyBgbmV3IERhdGUoTmFOKWAgOiBgbmV3IERhdGUoJHtKU09OLnN0cmluZ2lmeShkLnRvSVNPU3RyaW5nKCkpfSlgO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgJ1tvYmplY3QgTWFwXSc6XG4gICAgICAgICAgICByZXR1cm4gYG5ldyBNYXAoJHtzdHJpbmdpZnlJbnRlcm5hbChBcnJheS5mcm9tKHZhbHVlKSwgY3VycmVudFZhbHVlcywgZ2V0QXN5bmNDb250ZW50KX0pYDtcbiAgICAgICAgY2FzZSAnW29iamVjdCBOdWxsXSc6XG4gICAgICAgICAgICByZXR1cm4gYG51bGxgO1xuICAgICAgICBjYXNlICdbb2JqZWN0IE51bWJlcl0nOlxuICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgPyBzdHJpbmdpZnlOdW1iZXIodmFsdWUpIDogYG5ldyBOdW1iZXIoJHtzdHJpbmdpZnlOdW1iZXIoTnVtYmVyKHZhbHVlKSl9KWA7XG4gICAgICAgIGNhc2UgJ1tvYmplY3QgT2JqZWN0XSc6IHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdG9TdHJpbmdBY2Nlc3NvciA9IHZhbHVlLnRvU3RyaW5nO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdG9TdHJpbmdBY2Nlc3NvciA9PT0gJ2Z1bmN0aW9uJyAmJiB0b1N0cmluZ0FjY2Vzc29yICE9PSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZS50b1N0cmluZygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJ1tvYmplY3QgT2JqZWN0XSc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBtYXBwZXIgPSAoaykgPT4gYCR7ayA9PT0gJ19fcHJvdG9fXydcbiAgICAgICAgICAgICAgICA/ICdbXCJfX3Byb3RvX19cIl0nXG4gICAgICAgICAgICAgICAgOiB0eXBlb2YgayA9PT0gJ3N5bWJvbCdcbiAgICAgICAgICAgICAgICAgICAgPyBgWyR7c3RyaW5naWZ5SW50ZXJuYWwoaywgY3VycmVudFZhbHVlcywgZ2V0QXN5bmNDb250ZW50KX1dYFxuICAgICAgICAgICAgICAgICAgICA6IEpTT04uc3RyaW5naWZ5KGspfToke3N0cmluZ2lmeUludGVybmFsKHZhbHVlW2tdLCBjdXJyZW50VmFsdWVzLCBnZXRBc3luY0NvbnRlbnQpfWA7XG4gICAgICAgICAgICBjb25zdCBzdHJpbmdpZmllZFByb3BlcnRpZXMgPSBbXG4gICAgICAgICAgICAgICAgLi4uT2JqZWN0LmtleXModmFsdWUpLm1hcChtYXBwZXIpLFxuICAgICAgICAgICAgICAgIC4uLk9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHModmFsdWUpXG4gICAgICAgICAgICAgICAgICAgIC5maWx0ZXIoKHMpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZGVzY3JpcHRvciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodmFsdWUsIHMpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGVzY3JpcHRvciAmJiBkZXNjcmlwdG9yLmVudW1lcmFibGU7XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgLm1hcChtYXBwZXIpLFxuICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIGNvbnN0IHJhd1JlcHIgPSAneycgKyBzdHJpbmdpZmllZFByb3BlcnRpZXMuam9pbignLCcpICsgJ30nO1xuICAgICAgICAgICAgaWYgKE9iamVjdC5nZXRQcm90b3R5cGVPZih2YWx1ZSkgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmF3UmVwciA9PT0gJ3t9JyA/ICdPYmplY3QuY3JlYXRlKG51bGwpJyA6IGBPYmplY3QuYXNzaWduKE9iamVjdC5jcmVhdGUobnVsbCksJHtyYXdSZXByfSlgO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJhd1JlcHI7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAnW29iamVjdCBTZXRdJzpcbiAgICAgICAgICAgIHJldHVybiBgbmV3IFNldCgke3N0cmluZ2lmeUludGVybmFsKEFycmF5LmZyb20odmFsdWUpLCBjdXJyZW50VmFsdWVzLCBnZXRBc3luY0NvbnRlbnQpfSlgO1xuICAgICAgICBjYXNlICdbb2JqZWN0IFN0cmluZ10nOlxuICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgPyBKU09OLnN0cmluZ2lmeSh2YWx1ZSkgOiBgbmV3IFN0cmluZygke0pTT04uc3RyaW5naWZ5KHZhbHVlKX0pYDtcbiAgICAgICAgY2FzZSAnW29iamVjdCBTeW1ib2xdJzoge1xuICAgICAgICAgICAgY29uc3QgcyA9IHZhbHVlO1xuICAgICAgICAgICAgaWYgKFN5bWJvbC5rZXlGb3IocykgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBgU3ltYm9sLmZvcigke0pTT04uc3RyaW5naWZ5KFN5bWJvbC5rZXlGb3IocykpfSlgO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgZGVzYyA9IGdldFN5bWJvbERlc2NyaXB0aW9uKHMpO1xuICAgICAgICAgICAgaWYgKGRlc2MgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJ1N5bWJvbCgpJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGtub3duU3ltYm9sID0gZGVzYy5zdGFydHNXaXRoKCdTeW1ib2wuJykgJiYgU3ltYm9sW2Rlc2Muc3Vic3RyaW5nKDcpXTtcbiAgICAgICAgICAgIHJldHVybiBzID09PSBrbm93blN5bWJvbCA/IGRlc2MgOiBgU3ltYm9sKCR7SlNPTi5zdHJpbmdpZnkoZGVzYyl9KWA7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAnW29iamVjdCBQcm9taXNlXSc6IHtcbiAgICAgICAgICAgIGNvbnN0IHByb21pc2VDb250ZW50ID0gZ2V0QXN5bmNDb250ZW50KHZhbHVlKTtcbiAgICAgICAgICAgIHN3aXRjaCAocHJvbWlzZUNvbnRlbnQuc3RhdGUpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdmdWxmaWxsZWQnOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYFByb21pc2UucmVzb2x2ZSgke3N0cmluZ2lmeUludGVybmFsKHByb21pc2VDb250ZW50LnZhbHVlLCBjdXJyZW50VmFsdWVzLCBnZXRBc3luY0NvbnRlbnQpfSlgO1xuICAgICAgICAgICAgICAgIGNhc2UgJ3JlamVjdGVkJzpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGBQcm9taXNlLnJlamVjdCgke3N0cmluZ2lmeUludGVybmFsKHByb21pc2VDb250ZW50LnZhbHVlLCBjdXJyZW50VmFsdWVzLCBnZXRBc3luY0NvbnRlbnQpfSlgO1xuICAgICAgICAgICAgICAgIGNhc2UgJ3BlbmRpbmcnOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYG5ldyBQcm9taXNlKCgpID0+IHsvKnBlbmRpbmcqL30pYDtcbiAgICAgICAgICAgICAgICBjYXNlICd1bmtub3duJzpcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYG5ldyBQcm9taXNlKCgpID0+IHsvKnVua25vd24qL30pYDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXNlICdbb2JqZWN0IEVycm9yXSc6XG4gICAgICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgICAgICAgIHJldHVybiBgbmV3IEVycm9yKCR7c3RyaW5naWZ5SW50ZXJuYWwodmFsdWUubWVzc2FnZSwgY3VycmVudFZhbHVlcywgZ2V0QXN5bmNDb250ZW50KX0pYDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdbb2JqZWN0IFVuZGVmaW5lZF0nOlxuICAgICAgICAgICAgcmV0dXJuIGB1bmRlZmluZWRgO1xuICAgICAgICBjYXNlICdbb2JqZWN0IEludDhBcnJheV0nOlxuICAgICAgICBjYXNlICdbb2JqZWN0IFVpbnQ4QXJyYXldJzpcbiAgICAgICAgY2FzZSAnW29iamVjdCBVaW50OENsYW1wZWRBcnJheV0nOlxuICAgICAgICBjYXNlICdbb2JqZWN0IEludDE2QXJyYXldJzpcbiAgICAgICAgY2FzZSAnW29iamVjdCBVaW50MTZBcnJheV0nOlxuICAgICAgICBjYXNlICdbb2JqZWN0IEludDMyQXJyYXldJzpcbiAgICAgICAgY2FzZSAnW29iamVjdCBVaW50MzJBcnJheV0nOlxuICAgICAgICBjYXNlICdbb2JqZWN0IEZsb2F0MzJBcnJheV0nOlxuICAgICAgICBjYXNlICdbb2JqZWN0IEZsb2F0NjRBcnJheV0nOlxuICAgICAgICBjYXNlICdbb2JqZWN0IEJpZ0ludDY0QXJyYXldJzpcbiAgICAgICAgY2FzZSAnW29iamVjdCBCaWdVaW50NjRBcnJheV0nOiB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIEJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIEJ1ZmZlci5pc0J1ZmZlciA9PT0gJ2Z1bmN0aW9uJyAmJiBCdWZmZXIuaXNCdWZmZXIodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGBCdWZmZXIuZnJvbSgke3N0cmluZ2lmeUludGVybmFsKEFycmF5LmZyb20odmFsdWUudmFsdWVzKCkpLCBjdXJyZW50VmFsdWVzLCBnZXRBc3luY0NvbnRlbnQpfSlgO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgdmFsdWVQcm90b3R5cGUgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YodmFsdWUpO1xuICAgICAgICAgICAgY29uc3QgY2xhc3NOYW1lID0gdmFsdWVQcm90b3R5cGUgJiYgdmFsdWVQcm90b3R5cGUuY29uc3RydWN0b3IgJiYgdmFsdWVQcm90b3R5cGUuY29uc3RydWN0b3IubmFtZTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgY2xhc3NOYW1lID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHR5cGVkQXJyYXkgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZXNGcm9tVHlwZWRBcnIgPSB0eXBlZEFycmF5LnZhbHVlcygpO1xuICAgICAgICAgICAgICAgIHJldHVybiBgJHtjbGFzc05hbWV9LmZyb20oJHtzdHJpbmdpZnlJbnRlcm5hbChBcnJheS5mcm9tKHZhbHVlc0Zyb21UeXBlZEFyciksIGN1cnJlbnRWYWx1ZXMsIGdldEFzeW5jQ29udGVudCl9KWA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgICB0cnkge1xuICAgICAgICByZXR1cm4gdmFsdWUudG9TdHJpbmcoKTtcbiAgICB9XG4gICAgY2F0Y2ggKF9hKSB7XG4gICAgICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpO1xuICAgIH1cbn1cbmV4cG9ydHMuc3RyaW5naWZ5SW50ZXJuYWwgPSBzdHJpbmdpZnlJbnRlcm5hbDtcbmZ1bmN0aW9uIHN0cmluZ2lmeSh2YWx1ZSkge1xuICAgIHJldHVybiBzdHJpbmdpZnlJbnRlcm5hbCh2YWx1ZSwgW10sICgpID0+ICh7IHN0YXRlOiAndW5rbm93bicsIHZhbHVlOiB1bmRlZmluZWQgfSkpO1xufVxuZXhwb3J0cy5zdHJpbmdpZnkgPSBzdHJpbmdpZnk7XG5mdW5jdGlvbiBwb3NzaWJseUFzeW5jU3RyaW5naWZ5KHZhbHVlKSB7XG4gICAgY29uc3Qgc3RpbGxQZW5kaW5nTWFya2VyID0gU3ltYm9sKCk7XG4gICAgY29uc3QgcGVuZGluZ1Byb21pc2VzRm9yQ2FjaGUgPSBbXTtcbiAgICBjb25zdCBjYWNoZSA9IG5ldyBNYXAoKTtcbiAgICBmdW5jdGlvbiBjcmVhdGVEZWxheTAoKSB7XG4gICAgICAgIGxldCBoYW5kbGVJZCA9IG51bGw7XG4gICAgICAgIGNvbnN0IGNhbmNlbCA9ICgpID0+IHtcbiAgICAgICAgICAgIGlmIChoYW5kbGVJZCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dChoYW5kbGVJZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGRlbGF5ID0gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgICAgICAgIGhhbmRsZUlkID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgaGFuZGxlSWQgPSBudWxsO1xuICAgICAgICAgICAgICAgIHJlc29sdmUoc3RpbGxQZW5kaW5nTWFya2VyKTtcbiAgICAgICAgICAgIH0sIDApO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHsgZGVsYXksIGNhbmNlbCB9O1xuICAgIH1cbiAgICBjb25zdCB1bmtub3duU3RhdGUgPSB7IHN0YXRlOiAndW5rbm93bicsIHZhbHVlOiB1bmRlZmluZWQgfTtcbiAgICBjb25zdCBnZXRBc3luY0NvbnRlbnQgPSBmdW5jdGlvbiBnZXRBc3luY0NvbnRlbnQoZGF0YSkge1xuICAgICAgICBjb25zdCBjYWNoZUtleSA9IGRhdGE7XG4gICAgICAgIGlmIChjYWNoZS5oYXMoY2FjaGVLZXkpKSB7XG4gICAgICAgICAgICByZXR1cm4gY2FjaGUuZ2V0KGNhY2hlS2V5KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBkZWxheTAgPSBjcmVhdGVEZWxheTAoKTtcbiAgICAgICAgY29uc3QgcCA9IGV4cG9ydHMuYXN5bmNUb1N0cmluZ01ldGhvZCBpbiBkYXRhXG4gICAgICAgICAgICA/IFByb21pc2UucmVzb2x2ZSgpLnRoZW4oKCkgPT4gZGF0YVtleHBvcnRzLmFzeW5jVG9TdHJpbmdNZXRob2RdKCkpXG4gICAgICAgICAgICA6IGRhdGE7XG4gICAgICAgIHAuY2F0Y2goKCkgPT4geyB9KTtcbiAgICAgICAgcGVuZGluZ1Byb21pc2VzRm9yQ2FjaGUucHVzaChQcm9taXNlLnJhY2UoW3AsIGRlbGF5MC5kZWxheV0pLnRoZW4oKHN1Y2Nlc3NWYWx1ZSkgPT4ge1xuICAgICAgICAgICAgaWYgKHN1Y2Nlc3NWYWx1ZSA9PT0gc3RpbGxQZW5kaW5nTWFya2VyKVxuICAgICAgICAgICAgICAgIGNhY2hlLnNldChjYWNoZUtleSwgeyBzdGF0ZTogJ3BlbmRpbmcnLCB2YWx1ZTogdW5kZWZpbmVkIH0pO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIGNhY2hlLnNldChjYWNoZUtleSwgeyBzdGF0ZTogJ2Z1bGZpbGxlZCcsIHZhbHVlOiBzdWNjZXNzVmFsdWUgfSk7XG4gICAgICAgICAgICBkZWxheTAuY2FuY2VsKCk7XG4gICAgICAgIH0sIChlcnJvclZhbHVlKSA9PiB7XG4gICAgICAgICAgICBjYWNoZS5zZXQoY2FjaGVLZXksIHsgc3RhdGU6ICdyZWplY3RlZCcsIHZhbHVlOiBlcnJvclZhbHVlIH0pO1xuICAgICAgICAgICAgZGVsYXkwLmNhbmNlbCgpO1xuICAgICAgICB9KSk7XG4gICAgICAgIGNhY2hlLnNldChjYWNoZUtleSwgdW5rbm93blN0YXRlKTtcbiAgICAgICAgcmV0dXJuIHVua25vd25TdGF0ZTtcbiAgICB9O1xuICAgIGZ1bmN0aW9uIGxvb3AoKSB7XG4gICAgICAgIGNvbnN0IHN0cmluZ2lmaWVkVmFsdWUgPSBzdHJpbmdpZnlJbnRlcm5hbCh2YWx1ZSwgW10sIGdldEFzeW5jQ29udGVudCk7XG4gICAgICAgIGlmIChwZW5kaW5nUHJvbWlzZXNGb3JDYWNoZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBzdHJpbmdpZmllZFZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBQcm9taXNlLmFsbChwZW5kaW5nUHJvbWlzZXNGb3JDYWNoZS5zcGxpY2UoMCkpLnRoZW4obG9vcCk7XG4gICAgfVxuICAgIHJldHVybiBsb29wKCk7XG59XG5leHBvcnRzLnBvc3NpYmx5QXN5bmNTdHJpbmdpZnkgPSBwb3NzaWJseUFzeW5jU3RyaW5naWZ5O1xuYXN5bmMgZnVuY3Rpb24gYXN5bmNTdHJpbmdpZnkodmFsdWUpIHtcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHBvc3NpYmx5QXN5bmNTdHJpbmdpZnkodmFsdWUpKTtcbn1cbmV4cG9ydHMuYXN5bmNTdHJpbmdpZnkgPSBhc3luY1N0cmluZ2lmeTtcbiIsIlwidXNlIHN0cmljdFwiO1xuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbmV4cG9ydHMudW5pZm9ybUFycmF5SW50RGlzdHJpYnV0aW9uID0gdm9pZCAwO1xudmFyIFVuc2FmZVVuaWZvcm1BcnJheUludERpc3RyaWJ1dGlvbl8xID0gcmVxdWlyZShcIi4vVW5zYWZlVW5pZm9ybUFycmF5SW50RGlzdHJpYnV0aW9uXCIpO1xuZnVuY3Rpb24gdW5pZm9ybUFycmF5SW50RGlzdHJpYnV0aW9uKGZyb20sIHRvLCBybmcpIHtcbiAgICBpZiAocm5nICE9IG51bGwpIHtcbiAgICAgICAgdmFyIG5leHRSbmcgPSBybmcuY2xvbmUoKTtcbiAgICAgICAgcmV0dXJuIFtVbnNhZmVVbmlmb3JtQXJyYXlJbnREaXN0cmlidXRpb25fMS51bnNhZmVVbmlmb3JtQXJyYXlJbnREaXN0cmlidXRpb24oZnJvbSwgdG8sIG5leHRSbmcpLCBuZXh0Um5nXTtcbiAgICB9XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChybmcpIHtcbiAgICAgICAgdmFyIG5leHRSbmcgPSBybmcuY2xvbmUoKTtcbiAgICAgICAgcmV0dXJuIFtVbnNhZmVVbmlmb3JtQXJyYXlJbnREaXN0cmlidXRpb25fMS51bnNhZmVVbmlmb3JtQXJyYXlJbnREaXN0cmlidXRpb24oZnJvbSwgdG8sIG5leHRSbmcpLCBuZXh0Um5nXTtcbiAgICB9O1xufVxuZXhwb3J0cy51bmlmb3JtQXJyYXlJbnREaXN0cmlidXRpb24gPSB1bmlmb3JtQXJyYXlJbnREaXN0cmlidXRpb247XG4iLCJcInVzZSBzdHJpY3RcIjtcbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5leHBvcnRzLnVuaWZvcm1CaWdJbnREaXN0cmlidXRpb24gPSB2b2lkIDA7XG52YXIgVW5zYWZlVW5pZm9ybUJpZ0ludERpc3RyaWJ1dGlvbl8xID0gcmVxdWlyZShcIi4vVW5zYWZlVW5pZm9ybUJpZ0ludERpc3RyaWJ1dGlvblwiKTtcbmZ1bmN0aW9uIHVuaWZvcm1CaWdJbnREaXN0cmlidXRpb24oZnJvbSwgdG8sIHJuZykge1xuICAgIGlmIChybmcgIT0gbnVsbCkge1xuICAgICAgICB2YXIgbmV4dFJuZyA9IHJuZy5jbG9uZSgpO1xuICAgICAgICByZXR1cm4gW1Vuc2FmZVVuaWZvcm1CaWdJbnREaXN0cmlidXRpb25fMS51bnNhZmVVbmlmb3JtQmlnSW50RGlzdHJpYnV0aW9uKGZyb20sIHRvLCBuZXh0Um5nKSwgbmV4dFJuZ107XG4gICAgfVxuICAgIHJldHVybiBmdW5jdGlvbiAocm5nKSB7XG4gICAgICAgIHZhciBuZXh0Um5nID0gcm5nLmNsb25lKCk7XG4gICAgICAgIHJldHVybiBbVW5zYWZlVW5pZm9ybUJpZ0ludERpc3RyaWJ1dGlvbl8xLnVuc2FmZVVuaWZvcm1CaWdJbnREaXN0cmlidXRpb24oZnJvbSwgdG8sIG5leHRSbmcpLCBuZXh0Um5nXTtcbiAgICB9O1xufVxuZXhwb3J0cy51bmlmb3JtQmlnSW50RGlzdHJpYnV0aW9uID0gdW5pZm9ybUJpZ0ludERpc3RyaWJ1dGlvbjtcbiIsIlwidXNlIHN0cmljdFwiO1xuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbmV4cG9ydHMudW5pZm9ybUludERpc3RyaWJ1dGlvbiA9IHZvaWQgMDtcbnZhciBVbnNhZmVVbmlmb3JtSW50RGlzdHJpYnV0aW9uXzEgPSByZXF1aXJlKFwiLi9VbnNhZmVVbmlmb3JtSW50RGlzdHJpYnV0aW9uXCIpO1xuZnVuY3Rpb24gdW5pZm9ybUludERpc3RyaWJ1dGlvbihmcm9tLCB0bywgcm5nKSB7XG4gICAgaWYgKHJuZyAhPSBudWxsKSB7XG4gICAgICAgIHZhciBuZXh0Um5nID0gcm5nLmNsb25lKCk7XG4gICAgICAgIHJldHVybiBbVW5zYWZlVW5pZm9ybUludERpc3RyaWJ1dGlvbl8xLnVuc2FmZVVuaWZvcm1JbnREaXN0cmlidXRpb24oZnJvbSwgdG8sIG5leHRSbmcpLCBuZXh0Um5nXTtcbiAgICB9XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChybmcpIHtcbiAgICAgICAgdmFyIG5leHRSbmcgPSBybmcuY2xvbmUoKTtcbiAgICAgICAgcmV0dXJuIFtVbnNhZmVVbmlmb3JtSW50RGlzdHJpYnV0aW9uXzEudW5zYWZlVW5pZm9ybUludERpc3RyaWJ1dGlvbihmcm9tLCB0bywgbmV4dFJuZyksIG5leHRSbmddO1xuICAgIH07XG59XG5leHBvcnRzLnVuaWZvcm1JbnREaXN0cmlidXRpb24gPSB1bmlmb3JtSW50RGlzdHJpYnV0aW9uO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuZXhwb3J0cy51bnNhZmVVbmlmb3JtQXJyYXlJbnREaXN0cmlidXRpb24gPSB2b2lkIDA7XG52YXIgQXJyYXlJbnRfMSA9IHJlcXVpcmUoXCIuL2ludGVybmFscy9BcnJheUludFwiKTtcbnZhciBVbnNhZmVVbmlmb3JtQXJyYXlJbnREaXN0cmlidXRpb25JbnRlcm5hbF8xID0gcmVxdWlyZShcIi4vaW50ZXJuYWxzL1Vuc2FmZVVuaWZvcm1BcnJheUludERpc3RyaWJ1dGlvbkludGVybmFsXCIpO1xuZnVuY3Rpb24gdW5zYWZlVW5pZm9ybUFycmF5SW50RGlzdHJpYnV0aW9uKGZyb20sIHRvLCBybmcpIHtcbiAgICB2YXIgcmFuZ2VTaXplID0gQXJyYXlJbnRfMS50cmltQXJyYXlJbnRJbnBsYWNlKEFycmF5SW50XzEuYWRkT25lVG9Qb3NpdGl2ZUFycmF5SW50KEFycmF5SW50XzEuc3Vic3RyYWN0QXJyYXlJbnRUb05ldyh0bywgZnJvbSkpKTtcbiAgICB2YXIgZW1wdHlBcnJheUludERhdGEgPSByYW5nZVNpemUuZGF0YS5zbGljZSgwKTtcbiAgICB2YXIgZyA9IFVuc2FmZVVuaWZvcm1BcnJheUludERpc3RyaWJ1dGlvbkludGVybmFsXzEudW5zYWZlVW5pZm9ybUFycmF5SW50RGlzdHJpYnV0aW9uSW50ZXJuYWwoZW1wdHlBcnJheUludERhdGEsIHJhbmdlU2l6ZS5kYXRhLCBybmcpO1xuICAgIHJldHVybiBBcnJheUludF8xLnRyaW1BcnJheUludElucGxhY2UoQXJyYXlJbnRfMS5hZGRBcnJheUludFRvTmV3KHsgc2lnbjogMSwgZGF0YTogZyB9LCBmcm9tKSk7XG59XG5leHBvcnRzLnVuc2FmZVVuaWZvcm1BcnJheUludERpc3RyaWJ1dGlvbiA9IHVuc2FmZVVuaWZvcm1BcnJheUludERpc3RyaWJ1dGlvbjtcbiIsIlwidXNlIHN0cmljdFwiO1xuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbmV4cG9ydHMudW5zYWZlVW5pZm9ybUJpZ0ludERpc3RyaWJ1dGlvbiA9IHZvaWQgMDtcbmZ1bmN0aW9uIHVuc2FmZVVuaWZvcm1CaWdJbnREaXN0cmlidXRpb24oZnJvbSwgdG8sIHJuZykge1xuICAgIHZhciBkaWZmID0gdG8gLSBmcm9tICsgQmlnSW50KDEpO1xuICAgIHZhciBNaW5SbmcgPSBCaWdJbnQocm5nLm1pbigpKTtcbiAgICB2YXIgTnVtVmFsdWVzID0gQmlnSW50KHJuZy5tYXgoKSAtIHJuZy5taW4oKSArIDEpO1xuICAgIHZhciBGaW5hbE51bVZhbHVlcyA9IE51bVZhbHVlcztcbiAgICB2YXIgTnVtSXRlcmF0aW9ucyA9IEJpZ0ludCgxKTtcbiAgICB3aGlsZSAoRmluYWxOdW1WYWx1ZXMgPCBkaWZmKSB7XG4gICAgICAgIEZpbmFsTnVtVmFsdWVzICo9IE51bVZhbHVlcztcbiAgICAgICAgKytOdW1JdGVyYXRpb25zO1xuICAgIH1cbiAgICB2YXIgTWF4QWNjZXB0ZWRSYW5kb20gPSBGaW5hbE51bVZhbHVlcyAtIChGaW5hbE51bVZhbHVlcyAlIGRpZmYpO1xuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IEJpZ0ludCgwKTtcbiAgICAgICAgZm9yICh2YXIgbnVtID0gQmlnSW50KDApOyBudW0gIT09IE51bUl0ZXJhdGlvbnM7ICsrbnVtKSB7XG4gICAgICAgICAgICB2YXIgb3V0ID0gcm5nLnVuc2FmZU5leHQoKTtcbiAgICAgICAgICAgIHZhbHVlID0gTnVtVmFsdWVzICogdmFsdWUgKyAoQmlnSW50KG91dCkgLSBNaW5SbmcpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2YWx1ZSA8IE1heEFjY2VwdGVkUmFuZG9tKSB7XG4gICAgICAgICAgICB2YXIgaW5EaWZmID0gdmFsdWUgJSBkaWZmO1xuICAgICAgICAgICAgcmV0dXJuIGluRGlmZiArIGZyb207XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLnVuc2FmZVVuaWZvcm1CaWdJbnREaXN0cmlidXRpb24gPSB1bnNhZmVVbmlmb3JtQmlnSW50RGlzdHJpYnV0aW9uO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuZXhwb3J0cy51bnNhZmVVbmlmb3JtSW50RGlzdHJpYnV0aW9uID0gdm9pZCAwO1xudmFyIFVuc2FmZVVuaWZvcm1JbnREaXN0cmlidXRpb25JbnRlcm5hbF8xID0gcmVxdWlyZShcIi4vaW50ZXJuYWxzL1Vuc2FmZVVuaWZvcm1JbnREaXN0cmlidXRpb25JbnRlcm5hbFwiKTtcbnZhciBBcnJheUludF8xID0gcmVxdWlyZShcIi4vaW50ZXJuYWxzL0FycmF5SW50XCIpO1xudmFyIFVuc2FmZVVuaWZvcm1BcnJheUludERpc3RyaWJ1dGlvbkludGVybmFsXzEgPSByZXF1aXJlKFwiLi9pbnRlcm5hbHMvVW5zYWZlVW5pZm9ybUFycmF5SW50RGlzdHJpYnV0aW9uSW50ZXJuYWxcIik7XG52YXIgc2hhcmVkQSA9IHsgc2lnbjogMSwgZGF0YTogWzAsIDBdIH07XG52YXIgc2hhcmVkQiA9IHsgc2lnbjogMSwgZGF0YTogWzAsIDBdIH07XG52YXIgc2hhcmVkQyA9IHsgc2lnbjogMSwgZGF0YTogWzAsIDBdIH07XG52YXIgc2hhcmVkRGF0YSA9IFswLCAwXTtcbmZ1bmN0aW9uIHVuaWZvcm1MYXJnZUludEludGVybmFsKGZyb20sIHRvLCByYW5nZVNpemUsIHJuZykge1xuICAgIHZhciByYW5nZVNpemVBcnJheUludFZhbHVlID0gcmFuZ2VTaXplIDw9IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSXG4gICAgICAgID8gQXJyYXlJbnRfMS5mcm9tTnVtYmVyVG9BcnJheUludDY0KHNoYXJlZEMsIHJhbmdlU2l6ZSlcbiAgICAgICAgOiBBcnJheUludF8xLnN1YnN0cmFjdEFycmF5SW50NjQoc2hhcmVkQywgQXJyYXlJbnRfMS5mcm9tTnVtYmVyVG9BcnJheUludDY0KHNoYXJlZEEsIHRvKSwgQXJyYXlJbnRfMS5mcm9tTnVtYmVyVG9BcnJheUludDY0KHNoYXJlZEIsIGZyb20pKTtcbiAgICBpZiAocmFuZ2VTaXplQXJyYXlJbnRWYWx1ZS5kYXRhWzFdID09PSAweGZmZmZmZmZmKSB7XG4gICAgICAgIHJhbmdlU2l6ZUFycmF5SW50VmFsdWUuZGF0YVswXSArPSAxO1xuICAgICAgICByYW5nZVNpemVBcnJheUludFZhbHVlLmRhdGFbMV0gPSAwO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmFuZ2VTaXplQXJyYXlJbnRWYWx1ZS5kYXRhWzFdICs9IDE7XG4gICAgfVxuICAgIFVuc2FmZVVuaWZvcm1BcnJheUludERpc3RyaWJ1dGlvbkludGVybmFsXzEudW5zYWZlVW5pZm9ybUFycmF5SW50RGlzdHJpYnV0aW9uSW50ZXJuYWwoc2hhcmVkRGF0YSwgcmFuZ2VTaXplQXJyYXlJbnRWYWx1ZS5kYXRhLCBybmcpO1xuICAgIHJldHVybiBzaGFyZWREYXRhWzBdICogMHgxMDAwMDAwMDAgKyBzaGFyZWREYXRhWzFdICsgZnJvbTtcbn1cbmZ1bmN0aW9uIHVuc2FmZVVuaWZvcm1JbnREaXN0cmlidXRpb24oZnJvbSwgdG8sIHJuZykge1xuICAgIHZhciByYW5nZVNpemUgPSB0byAtIGZyb207XG4gICAgaWYgKHJhbmdlU2l6ZSA8PSAweGZmZmZmZmZmKSB7XG4gICAgICAgIHZhciBnID0gVW5zYWZlVW5pZm9ybUludERpc3RyaWJ1dGlvbkludGVybmFsXzEudW5zYWZlVW5pZm9ybUludERpc3RyaWJ1dGlvbkludGVybmFsKHJhbmdlU2l6ZSArIDEsIHJuZyk7XG4gICAgICAgIHJldHVybiBnICsgZnJvbTtcbiAgICB9XG4gICAgcmV0dXJuIHVuaWZvcm1MYXJnZUludEludGVybmFsKGZyb20sIHRvLCByYW5nZVNpemUsIHJuZyk7XG59XG5leHBvcnRzLnVuc2FmZVVuaWZvcm1JbnREaXN0cmlidXRpb24gPSB1bnNhZmVVbmlmb3JtSW50RGlzdHJpYnV0aW9uO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuZXhwb3J0cy5zdWJzdHJhY3RBcnJheUludDY0ID0gZXhwb3J0cy5mcm9tTnVtYmVyVG9BcnJheUludDY0ID0gZXhwb3J0cy50cmltQXJyYXlJbnRJbnBsYWNlID0gZXhwb3J0cy5zdWJzdHJhY3RBcnJheUludFRvTmV3ID0gZXhwb3J0cy5hZGRPbmVUb1Bvc2l0aXZlQXJyYXlJbnQgPSBleHBvcnRzLmFkZEFycmF5SW50VG9OZXcgPSB2b2lkIDA7XG5mdW5jdGlvbiBhZGRBcnJheUludFRvTmV3KGFycmF5SW50QSwgYXJyYXlJbnRCKSB7XG4gICAgaWYgKGFycmF5SW50QS5zaWduICE9PSBhcnJheUludEIuc2lnbikge1xuICAgICAgICByZXR1cm4gc3Vic3RyYWN0QXJyYXlJbnRUb05ldyhhcnJheUludEEsIHsgc2lnbjogLWFycmF5SW50Qi5zaWduLCBkYXRhOiBhcnJheUludEIuZGF0YSB9KTtcbiAgICB9XG4gICAgdmFyIGRhdGEgPSBbXTtcbiAgICB2YXIgcmVtaW5kZXIgPSAwO1xuICAgIHZhciBkYXRhQSA9IGFycmF5SW50QS5kYXRhO1xuICAgIHZhciBkYXRhQiA9IGFycmF5SW50Qi5kYXRhO1xuICAgIGZvciAodmFyIGluZGV4QSA9IGRhdGFBLmxlbmd0aCAtIDEsIGluZGV4QiA9IGRhdGFCLmxlbmd0aCAtIDE7IGluZGV4QSA+PSAwIHx8IGluZGV4QiA+PSAwOyAtLWluZGV4QSwgLS1pbmRleEIpIHtcbiAgICAgICAgdmFyIHZBID0gaW5kZXhBID49IDAgPyBkYXRhQVtpbmRleEFdIDogMDtcbiAgICAgICAgdmFyIHZCID0gaW5kZXhCID49IDAgPyBkYXRhQltpbmRleEJdIDogMDtcbiAgICAgICAgdmFyIGN1cnJlbnQgPSB2QSArIHZCICsgcmVtaW5kZXI7XG4gICAgICAgIGRhdGEucHVzaChjdXJyZW50ID4+PiAwKTtcbiAgICAgICAgcmVtaW5kZXIgPSB+fihjdXJyZW50IC8gMHgxMDAwMDAwMDApO1xuICAgIH1cbiAgICBpZiAocmVtaW5kZXIgIT09IDApIHtcbiAgICAgICAgZGF0YS5wdXNoKHJlbWluZGVyKTtcbiAgICB9XG4gICAgcmV0dXJuIHsgc2lnbjogYXJyYXlJbnRBLnNpZ24sIGRhdGE6IGRhdGEucmV2ZXJzZSgpIH07XG59XG5leHBvcnRzLmFkZEFycmF5SW50VG9OZXcgPSBhZGRBcnJheUludFRvTmV3O1xuZnVuY3Rpb24gYWRkT25lVG9Qb3NpdGl2ZUFycmF5SW50KGFycmF5SW50KSB7XG4gICAgYXJyYXlJbnQuc2lnbiA9IDE7XG4gICAgdmFyIGRhdGEgPSBhcnJheUludC5kYXRhO1xuICAgIGZvciAodmFyIGluZGV4ID0gZGF0YS5sZW5ndGggLSAxOyBpbmRleCA+PSAwOyAtLWluZGV4KSB7XG4gICAgICAgIGlmIChkYXRhW2luZGV4XSA9PT0gMHhmZmZmZmZmZikge1xuICAgICAgICAgICAgZGF0YVtpbmRleF0gPSAwO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZGF0YVtpbmRleF0gKz0gMTtcbiAgICAgICAgICAgIHJldHVybiBhcnJheUludDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBkYXRhLnVuc2hpZnQoMSk7XG4gICAgcmV0dXJuIGFycmF5SW50O1xufVxuZXhwb3J0cy5hZGRPbmVUb1Bvc2l0aXZlQXJyYXlJbnQgPSBhZGRPbmVUb1Bvc2l0aXZlQXJyYXlJbnQ7XG5mdW5jdGlvbiBpc1N0cmljdGx5U21hbGxlcihkYXRhQSwgZGF0YUIpIHtcbiAgICB2YXIgbWF4TGVuZ3RoID0gTWF0aC5tYXgoZGF0YUEubGVuZ3RoLCBkYXRhQi5sZW5ndGgpO1xuICAgIGZvciAodmFyIGluZGV4ID0gMDsgaW5kZXggPCBtYXhMZW5ndGg7ICsraW5kZXgpIHtcbiAgICAgICAgdmFyIGluZGV4QSA9IGluZGV4ICsgZGF0YUEubGVuZ3RoIC0gbWF4TGVuZ3RoO1xuICAgICAgICB2YXIgaW5kZXhCID0gaW5kZXggKyBkYXRhQi5sZW5ndGggLSBtYXhMZW5ndGg7XG4gICAgICAgIHZhciB2QSA9IGluZGV4QSA+PSAwID8gZGF0YUFbaW5kZXhBXSA6IDA7XG4gICAgICAgIHZhciB2QiA9IGluZGV4QiA+PSAwID8gZGF0YUJbaW5kZXhCXSA6IDA7XG4gICAgICAgIGlmICh2QSA8IHZCKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIGlmICh2QSA+IHZCKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBzdWJzdHJhY3RBcnJheUludFRvTmV3KGFycmF5SW50QSwgYXJyYXlJbnRCKSB7XG4gICAgaWYgKGFycmF5SW50QS5zaWduICE9PSBhcnJheUludEIuc2lnbikge1xuICAgICAgICByZXR1cm4gYWRkQXJyYXlJbnRUb05ldyhhcnJheUludEEsIHsgc2lnbjogLWFycmF5SW50Qi5zaWduLCBkYXRhOiBhcnJheUludEIuZGF0YSB9KTtcbiAgICB9XG4gICAgdmFyIGRhdGFBID0gYXJyYXlJbnRBLmRhdGE7XG4gICAgdmFyIGRhdGFCID0gYXJyYXlJbnRCLmRhdGE7XG4gICAgaWYgKGlzU3RyaWN0bHlTbWFsbGVyKGRhdGFBLCBkYXRhQikpIHtcbiAgICAgICAgdmFyIG91dCA9IHN1YnN0cmFjdEFycmF5SW50VG9OZXcoYXJyYXlJbnRCLCBhcnJheUludEEpO1xuICAgICAgICBvdXQuc2lnbiA9IC1vdXQuc2lnbjtcbiAgICAgICAgcmV0dXJuIG91dDtcbiAgICB9XG4gICAgdmFyIGRhdGEgPSBbXTtcbiAgICB2YXIgcmVtaW5kZXIgPSAwO1xuICAgIGZvciAodmFyIGluZGV4QSA9IGRhdGFBLmxlbmd0aCAtIDEsIGluZGV4QiA9IGRhdGFCLmxlbmd0aCAtIDE7IGluZGV4QSA+PSAwIHx8IGluZGV4QiA+PSAwOyAtLWluZGV4QSwgLS1pbmRleEIpIHtcbiAgICAgICAgdmFyIHZBID0gaW5kZXhBID49IDAgPyBkYXRhQVtpbmRleEFdIDogMDtcbiAgICAgICAgdmFyIHZCID0gaW5kZXhCID49IDAgPyBkYXRhQltpbmRleEJdIDogMDtcbiAgICAgICAgdmFyIGN1cnJlbnQgPSB2QSAtIHZCIC0gcmVtaW5kZXI7XG4gICAgICAgIGRhdGEucHVzaChjdXJyZW50ID4+PiAwKTtcbiAgICAgICAgcmVtaW5kZXIgPSBjdXJyZW50IDwgMCA/IDEgOiAwO1xuICAgIH1cbiAgICByZXR1cm4geyBzaWduOiBhcnJheUludEEuc2lnbiwgZGF0YTogZGF0YS5yZXZlcnNlKCkgfTtcbn1cbmV4cG9ydHMuc3Vic3RyYWN0QXJyYXlJbnRUb05ldyA9IHN1YnN0cmFjdEFycmF5SW50VG9OZXc7XG5mdW5jdGlvbiB0cmltQXJyYXlJbnRJbnBsYWNlKGFycmF5SW50KSB7XG4gICAgdmFyIGRhdGEgPSBhcnJheUludC5kYXRhO1xuICAgIHZhciBmaXJzdE5vblplcm8gPSAwO1xuICAgIGZvciAoOyBmaXJzdE5vblplcm8gIT09IGRhdGEubGVuZ3RoICYmIGRhdGFbZmlyc3ROb25aZXJvXSA9PT0gMDsgKytmaXJzdE5vblplcm8pIHsgfVxuICAgIGlmIChmaXJzdE5vblplcm8gPT09IGRhdGEubGVuZ3RoKSB7XG4gICAgICAgIGFycmF5SW50LnNpZ24gPSAxO1xuICAgICAgICBhcnJheUludC5kYXRhID0gWzBdO1xuICAgICAgICByZXR1cm4gYXJyYXlJbnQ7XG4gICAgfVxuICAgIGRhdGEuc3BsaWNlKDAsIGZpcnN0Tm9uWmVybyk7XG4gICAgcmV0dXJuIGFycmF5SW50O1xufVxuZXhwb3J0cy50cmltQXJyYXlJbnRJbnBsYWNlID0gdHJpbUFycmF5SW50SW5wbGFjZTtcbmZ1bmN0aW9uIGZyb21OdW1iZXJUb0FycmF5SW50NjQob3V0LCBuKSB7XG4gICAgaWYgKG4gPCAwKSB7XG4gICAgICAgIHZhciBwb3NOID0gLW47XG4gICAgICAgIG91dC5zaWduID0gLTE7XG4gICAgICAgIG91dC5kYXRhWzBdID0gfn4ocG9zTiAvIDB4MTAwMDAwMDAwKTtcbiAgICAgICAgb3V0LmRhdGFbMV0gPSBwb3NOID4+PiAwO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgb3V0LnNpZ24gPSAxO1xuICAgICAgICBvdXQuZGF0YVswXSA9IH5+KG4gLyAweDEwMDAwMDAwMCk7XG4gICAgICAgIG91dC5kYXRhWzFdID0gbiA+Pj4gMDtcbiAgICB9XG4gICAgcmV0dXJuIG91dDtcbn1cbmV4cG9ydHMuZnJvbU51bWJlclRvQXJyYXlJbnQ2NCA9IGZyb21OdW1iZXJUb0FycmF5SW50NjQ7XG5mdW5jdGlvbiBzdWJzdHJhY3RBcnJheUludDY0KG91dCwgYXJyYXlJbnRBLCBhcnJheUludEIpIHtcbiAgICB2YXIgbG93QSA9IGFycmF5SW50QS5kYXRhWzFdO1xuICAgIHZhciBoaWdoQSA9IGFycmF5SW50QS5kYXRhWzBdO1xuICAgIHZhciBzaWduQSA9IGFycmF5SW50QS5zaWduO1xuICAgIHZhciBsb3dCID0gYXJyYXlJbnRCLmRhdGFbMV07XG4gICAgdmFyIGhpZ2hCID0gYXJyYXlJbnRCLmRhdGFbMF07XG4gICAgdmFyIHNpZ25CID0gYXJyYXlJbnRCLnNpZ247XG4gICAgb3V0LnNpZ24gPSAxO1xuICAgIGlmIChzaWduQSA9PT0gMSAmJiBzaWduQiA9PT0gLTEpIHtcbiAgICAgICAgdmFyIGxvd18xID0gbG93QSArIGxvd0I7XG4gICAgICAgIHZhciBoaWdoID0gaGlnaEEgKyBoaWdoQiArIChsb3dfMSA+IDB4ZmZmZmZmZmYgPyAxIDogMCk7XG4gICAgICAgIG91dC5kYXRhWzBdID0gaGlnaCA+Pj4gMDtcbiAgICAgICAgb3V0LmRhdGFbMV0gPSBsb3dfMSA+Pj4gMDtcbiAgICAgICAgcmV0dXJuIG91dDtcbiAgICB9XG4gICAgdmFyIGxvd0ZpcnN0ID0gbG93QTtcbiAgICB2YXIgaGlnaEZpcnN0ID0gaGlnaEE7XG4gICAgdmFyIGxvd1NlY29uZCA9IGxvd0I7XG4gICAgdmFyIGhpZ2hTZWNvbmQgPSBoaWdoQjtcbiAgICBpZiAoc2lnbkEgPT09IC0xKSB7XG4gICAgICAgIGxvd0ZpcnN0ID0gbG93QjtcbiAgICAgICAgaGlnaEZpcnN0ID0gaGlnaEI7XG4gICAgICAgIGxvd1NlY29uZCA9IGxvd0E7XG4gICAgICAgIGhpZ2hTZWNvbmQgPSBoaWdoQTtcbiAgICB9XG4gICAgdmFyIHJlbWluZGVyTG93ID0gMDtcbiAgICB2YXIgbG93ID0gbG93Rmlyc3QgLSBsb3dTZWNvbmQ7XG4gICAgaWYgKGxvdyA8IDApIHtcbiAgICAgICAgcmVtaW5kZXJMb3cgPSAxO1xuICAgICAgICBsb3cgPSBsb3cgPj4+IDA7XG4gICAgfVxuICAgIG91dC5kYXRhWzBdID0gaGlnaEZpcnN0IC0gaGlnaFNlY29uZCAtIHJlbWluZGVyTG93O1xuICAgIG91dC5kYXRhWzFdID0gbG93O1xuICAgIHJldHVybiBvdXQ7XG59XG5leHBvcnRzLnN1YnN0cmFjdEFycmF5SW50NjQgPSBzdWJzdHJhY3RBcnJheUludDY0O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuZXhwb3J0cy51bnNhZmVVbmlmb3JtQXJyYXlJbnREaXN0cmlidXRpb25JbnRlcm5hbCA9IHZvaWQgMDtcbnZhciBVbnNhZmVVbmlmb3JtSW50RGlzdHJpYnV0aW9uSW50ZXJuYWxfMSA9IHJlcXVpcmUoXCIuL1Vuc2FmZVVuaWZvcm1JbnREaXN0cmlidXRpb25JbnRlcm5hbFwiKTtcbmZ1bmN0aW9uIHVuc2FmZVVuaWZvcm1BcnJheUludERpc3RyaWJ1dGlvbkludGVybmFsKG91dCwgcmFuZ2VTaXplLCBybmcpIHtcbiAgICB2YXIgcmFuZ2VMZW5ndGggPSByYW5nZVNpemUubGVuZ3RoO1xuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIGZvciAodmFyIGluZGV4ID0gMDsgaW5kZXggIT09IHJhbmdlTGVuZ3RoOyArK2luZGV4KSB7XG4gICAgICAgICAgICB2YXIgaW5kZXhSYW5nZVNpemUgPSBpbmRleCA9PT0gMCA/IHJhbmdlU2l6ZVswXSArIDEgOiAweDEwMDAwMDAwMDtcbiAgICAgICAgICAgIHZhciBnID0gVW5zYWZlVW5pZm9ybUludERpc3RyaWJ1dGlvbkludGVybmFsXzEudW5zYWZlVW5pZm9ybUludERpc3RyaWJ1dGlvbkludGVybmFsKGluZGV4UmFuZ2VTaXplLCBybmcpO1xuICAgICAgICAgICAgb3V0W2luZGV4XSA9IGc7XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCAhPT0gcmFuZ2VMZW5ndGg7ICsraW5kZXgpIHtcbiAgICAgICAgICAgIHZhciBjdXJyZW50ID0gb3V0W2luZGV4XTtcbiAgICAgICAgICAgIHZhciBjdXJyZW50SW5SYW5nZSA9IHJhbmdlU2l6ZVtpbmRleF07XG4gICAgICAgICAgICBpZiAoY3VycmVudCA8IGN1cnJlbnRJblJhbmdlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG91dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGN1cnJlbnQgPiBjdXJyZW50SW5SYW5nZSkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy51bnNhZmVVbmlmb3JtQXJyYXlJbnREaXN0cmlidXRpb25JbnRlcm5hbCA9IHVuc2FmZVVuaWZvcm1BcnJheUludERpc3RyaWJ1dGlvbkludGVybmFsO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuZXhwb3J0cy51bnNhZmVVbmlmb3JtSW50RGlzdHJpYnV0aW9uSW50ZXJuYWwgPSB2b2lkIDA7XG5mdW5jdGlvbiB1bnNhZmVVbmlmb3JtSW50RGlzdHJpYnV0aW9uSW50ZXJuYWwocmFuZ2VTaXplLCBybmcpIHtcbiAgICB2YXIgTWluUm5nID0gcm5nLm1pbigpO1xuICAgIHZhciBOdW1WYWx1ZXMgPSBybmcubWF4KCkgLSBybmcubWluKCkgKyAxO1xuICAgIGlmIChyYW5nZVNpemUgPD0gTnVtVmFsdWVzKSB7XG4gICAgICAgIHZhciBucm5nXzEgPSBybmc7XG4gICAgICAgIHZhciBNYXhBbGxvd2VkID0gTnVtVmFsdWVzIC0gKE51bVZhbHVlcyAlIHJhbmdlU2l6ZSk7XG4gICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICB2YXIgb3V0ID0gbnJuZ18xLnVuc2FmZU5leHQoKTtcbiAgICAgICAgICAgIHZhciBkZWx0YVYgPSBvdXQgLSBNaW5Sbmc7XG4gICAgICAgICAgICBpZiAoZGVsdGFWIDwgTWF4QWxsb3dlZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBkZWx0YVYgJSByYW5nZVNpemU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgdmFyIEZpbmFsTnVtVmFsdWVzID0gTnVtVmFsdWVzICogTnVtVmFsdWVzO1xuICAgIHZhciBOdW1JdGVyYXRpb25zID0gMjtcbiAgICB3aGlsZSAoRmluYWxOdW1WYWx1ZXMgPCByYW5nZVNpemUpIHtcbiAgICAgICAgRmluYWxOdW1WYWx1ZXMgKj0gTnVtVmFsdWVzO1xuICAgICAgICArK051bUl0ZXJhdGlvbnM7XG4gICAgfVxuICAgIHZhciBNYXhBY2NlcHRlZFJhbmRvbSA9IHJhbmdlU2l6ZSAqIE1hdGguZmxvb3IoKDEgKiBGaW5hbE51bVZhbHVlcykgLyByYW5nZVNpemUpO1xuICAgIHZhciBucm5nID0gcm5nO1xuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IDA7XG4gICAgICAgIGZvciAodmFyIG51bSA9IDA7IG51bSAhPT0gTnVtSXRlcmF0aW9uczsgKytudW0pIHtcbiAgICAgICAgICAgIHZhciBvdXQgPSBucm5nLnVuc2FmZU5leHQoKTtcbiAgICAgICAgICAgIHZhbHVlID0gTnVtVmFsdWVzICogdmFsdWUgKyAob3V0IC0gTWluUm5nKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodmFsdWUgPCBNYXhBY2NlcHRlZFJhbmRvbSkge1xuICAgICAgICAgICAgdmFyIGluRGlmZiA9IHZhbHVlIC0gcmFuZ2VTaXplICogTWF0aC5mbG9vcigoMSAqIHZhbHVlKSAvIHJhbmdlU2l6ZSk7XG4gICAgICAgICAgICByZXR1cm4gaW5EaWZmO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy51bnNhZmVVbmlmb3JtSW50RGlzdHJpYnV0aW9uSW50ZXJuYWwgPSB1bnNhZmVVbmlmb3JtSW50RGlzdHJpYnV0aW9uSW50ZXJuYWw7XG4iLCJcInVzZSBzdHJpY3RcIjtcbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5leHBvcnRzLmNvbmdydWVudGlhbDMyID0gZXhwb3J0cy5jb25ncnVlbnRpYWwgPSB2b2lkIDA7XG52YXIgTVVMVElQTElFUiA9IDB4MDAwMzQzZmQ7XG52YXIgSU5DUkVNRU5UID0gMHgwMDI2OWVjMztcbnZhciBNQVNLID0gMHhmZmZmZmZmZjtcbnZhciBNQVNLXzIgPSAoMSA8PCAzMSkgLSAxO1xudmFyIGNvbXB1dGVOZXh0U2VlZCA9IGZ1bmN0aW9uIChzZWVkKSB7XG4gICAgcmV0dXJuIChzZWVkICogTVVMVElQTElFUiArIElOQ1JFTUVOVCkgJiBNQVNLO1xufTtcbnZhciBjb21wdXRlVmFsdWVGcm9tTmV4dFNlZWQgPSBmdW5jdGlvbiAobmV4dHNlZWQpIHtcbiAgICByZXR1cm4gKG5leHRzZWVkICYgTUFTS18yKSA+PiAxNjtcbn07XG52YXIgTGluZWFyQ29uZ3J1ZW50aWFsID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBMaW5lYXJDb25ncnVlbnRpYWwoc2VlZCkge1xuICAgICAgICB0aGlzLnNlZWQgPSBzZWVkO1xuICAgIH1cbiAgICBMaW5lYXJDb25ncnVlbnRpYWwucHJvdG90eXBlLm1pbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIExpbmVhckNvbmdydWVudGlhbC5taW47XG4gICAgfTtcbiAgICBMaW5lYXJDb25ncnVlbnRpYWwucHJvdG90eXBlLm1heCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIExpbmVhckNvbmdydWVudGlhbC5tYXg7XG4gICAgfTtcbiAgICBMaW5lYXJDb25ncnVlbnRpYWwucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gbmV3IExpbmVhckNvbmdydWVudGlhbCh0aGlzLnNlZWQpO1xuICAgIH07XG4gICAgTGluZWFyQ29uZ3J1ZW50aWFsLnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgbmV4dFJuZyA9IG5ldyBMaW5lYXJDb25ncnVlbnRpYWwodGhpcy5zZWVkKTtcbiAgICAgICAgdmFyIG91dCA9IG5leHRSbmcudW5zYWZlTmV4dCgpO1xuICAgICAgICByZXR1cm4gW291dCwgbmV4dFJuZ107XG4gICAgfTtcbiAgICBMaW5lYXJDb25ncnVlbnRpYWwucHJvdG90eXBlLnVuc2FmZU5leHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuc2VlZCA9IGNvbXB1dGVOZXh0U2VlZCh0aGlzLnNlZWQpO1xuICAgICAgICByZXR1cm4gY29tcHV0ZVZhbHVlRnJvbU5leHRTZWVkKHRoaXMuc2VlZCk7XG4gICAgfTtcbiAgICBMaW5lYXJDb25ncnVlbnRpYWwubWluID0gMDtcbiAgICBMaW5lYXJDb25ncnVlbnRpYWwubWF4ID0gTWF0aC5wb3coMiwgMTUpIC0gMTtcbiAgICByZXR1cm4gTGluZWFyQ29uZ3J1ZW50aWFsO1xufSgpKTtcbnZhciBMaW5lYXJDb25ncnVlbnRpYWwzMiA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTGluZWFyQ29uZ3J1ZW50aWFsMzIoc2VlZCkge1xuICAgICAgICB0aGlzLnNlZWQgPSBzZWVkO1xuICAgIH1cbiAgICBMaW5lYXJDb25ncnVlbnRpYWwzMi5wcm90b3R5cGUubWluID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gTGluZWFyQ29uZ3J1ZW50aWFsMzIubWluO1xuICAgIH07XG4gICAgTGluZWFyQ29uZ3J1ZW50aWFsMzIucHJvdG90eXBlLm1heCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIExpbmVhckNvbmdydWVudGlhbDMyLm1heDtcbiAgICB9O1xuICAgIExpbmVhckNvbmdydWVudGlhbDMyLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBMaW5lYXJDb25ncnVlbnRpYWwzMih0aGlzLnNlZWQpO1xuICAgIH07XG4gICAgTGluZWFyQ29uZ3J1ZW50aWFsMzIucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBuZXh0Um5nID0gbmV3IExpbmVhckNvbmdydWVudGlhbDMyKHRoaXMuc2VlZCk7XG4gICAgICAgIHZhciBvdXQgPSBuZXh0Um5nLnVuc2FmZU5leHQoKTtcbiAgICAgICAgcmV0dXJuIFtvdXQsIG5leHRSbmddO1xuICAgIH07XG4gICAgTGluZWFyQ29uZ3J1ZW50aWFsMzIucHJvdG90eXBlLnVuc2FmZU5leHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBzMSA9IGNvbXB1dGVOZXh0U2VlZCh0aGlzLnNlZWQpO1xuICAgICAgICB2YXIgdjEgPSBjb21wdXRlVmFsdWVGcm9tTmV4dFNlZWQoczEpO1xuICAgICAgICB2YXIgczIgPSBjb21wdXRlTmV4dFNlZWQoczEpO1xuICAgICAgICB2YXIgdjIgPSBjb21wdXRlVmFsdWVGcm9tTmV4dFNlZWQoczIpO1xuICAgICAgICB0aGlzLnNlZWQgPSBjb21wdXRlTmV4dFNlZWQoczIpO1xuICAgICAgICB2YXIgdjMgPSBjb21wdXRlVmFsdWVGcm9tTmV4dFNlZWQodGhpcy5zZWVkKTtcbiAgICAgICAgdmFyIHZuZXh0ID0gdjMgKyAoKHYyICsgKHYxIDw8IDE1KSkgPDwgMTUpO1xuICAgICAgICByZXR1cm4gKCh2bmV4dCArIDB4ODAwMDAwMDApIHwgMCkgKyAweDgwMDAwMDAwO1xuICAgIH07XG4gICAgTGluZWFyQ29uZ3J1ZW50aWFsMzIubWluID0gMDtcbiAgICBMaW5lYXJDb25ncnVlbnRpYWwzMi5tYXggPSAweGZmZmZmZmZmO1xuICAgIHJldHVybiBMaW5lYXJDb25ncnVlbnRpYWwzMjtcbn0oKSk7XG52YXIgY29uZ3J1ZW50aWFsID0gZnVuY3Rpb24gKHNlZWQpIHtcbiAgICByZXR1cm4gbmV3IExpbmVhckNvbmdydWVudGlhbChzZWVkKTtcbn07XG5leHBvcnRzLmNvbmdydWVudGlhbCA9IGNvbmdydWVudGlhbDtcbnZhciBjb25ncnVlbnRpYWwzMiA9IGZ1bmN0aW9uIChzZWVkKSB7XG4gICAgcmV0dXJuIG5ldyBMaW5lYXJDb25ncnVlbnRpYWwzMihzZWVkKTtcbn07XG5leHBvcnRzLmNvbmdydWVudGlhbDMyID0gY29uZ3J1ZW50aWFsMzI7XG4iLCJcInVzZSBzdHJpY3RcIjtcbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG52YXIgTWVyc2VubmVUd2lzdGVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNZXJzZW5uZVR3aXN0ZXIoc3RhdGVzLCBpbmRleCkge1xuICAgICAgICB0aGlzLnN0YXRlcyA9IHN0YXRlcztcbiAgICAgICAgdGhpcy5pbmRleCA9IGluZGV4O1xuICAgIH1cbiAgICBNZXJzZW5uZVR3aXN0ZXIudHdpc3QgPSBmdW5jdGlvbiAocHJldikge1xuICAgICAgICB2YXIgbXQgPSBwcmV2LnNsaWNlKCk7XG4gICAgICAgIGZvciAodmFyIGlkeCA9IDA7IGlkeCAhPT0gTWVyc2VubmVUd2lzdGVyLk4gLSBNZXJzZW5uZVR3aXN0ZXIuTTsgKytpZHgpIHtcbiAgICAgICAgICAgIHZhciB5XzEgPSAobXRbaWR4XSAmIE1lcnNlbm5lVHdpc3Rlci5NQVNLX1VQUEVSKSArIChtdFtpZHggKyAxXSAmIE1lcnNlbm5lVHdpc3Rlci5NQVNLX0xPV0VSKTtcbiAgICAgICAgICAgIG10W2lkeF0gPSBtdFtpZHggKyBNZXJzZW5uZVR3aXN0ZXIuTV0gXiAoeV8xID4+PiAxKSBeICgtKHlfMSAmIDEpICYgTWVyc2VubmVUd2lzdGVyLkEpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIGlkeCA9IE1lcnNlbm5lVHdpc3Rlci5OIC0gTWVyc2VubmVUd2lzdGVyLk07IGlkeCAhPT0gTWVyc2VubmVUd2lzdGVyLk4gLSAxOyArK2lkeCkge1xuICAgICAgICAgICAgdmFyIHlfMiA9IChtdFtpZHhdICYgTWVyc2VubmVUd2lzdGVyLk1BU0tfVVBQRVIpICsgKG10W2lkeCArIDFdICYgTWVyc2VubmVUd2lzdGVyLk1BU0tfTE9XRVIpO1xuICAgICAgICAgICAgbXRbaWR4XSA9IG10W2lkeCArIE1lcnNlbm5lVHdpc3Rlci5NIC0gTWVyc2VubmVUd2lzdGVyLk5dIF4gKHlfMiA+Pj4gMSkgXiAoLSh5XzIgJiAxKSAmIE1lcnNlbm5lVHdpc3Rlci5BKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgeSA9IChtdFtNZXJzZW5uZVR3aXN0ZXIuTiAtIDFdICYgTWVyc2VubmVUd2lzdGVyLk1BU0tfVVBQRVIpICsgKG10WzBdICYgTWVyc2VubmVUd2lzdGVyLk1BU0tfTE9XRVIpO1xuICAgICAgICBtdFtNZXJzZW5uZVR3aXN0ZXIuTiAtIDFdID0gbXRbTWVyc2VubmVUd2lzdGVyLk0gLSAxXSBeICh5ID4+PiAxKSBeICgtKHkgJiAxKSAmIE1lcnNlbm5lVHdpc3Rlci5BKTtcbiAgICAgICAgcmV0dXJuIG10O1xuICAgIH07XG4gICAgTWVyc2VubmVUd2lzdGVyLnNlZWRlZCA9IGZ1bmN0aW9uIChzZWVkKSB7XG4gICAgICAgIHZhciBvdXQgPSBBcnJheShNZXJzZW5uZVR3aXN0ZXIuTik7XG4gICAgICAgIG91dFswXSA9IHNlZWQ7XG4gICAgICAgIGZvciAodmFyIGlkeCA9IDE7IGlkeCAhPT0gTWVyc2VubmVUd2lzdGVyLk47ICsraWR4KSB7XG4gICAgICAgICAgICB2YXIgeG9yZWQgPSBvdXRbaWR4IC0gMV0gXiAob3V0W2lkeCAtIDFdID4+PiAzMCk7XG4gICAgICAgICAgICBvdXRbaWR4XSA9IChNYXRoLmltdWwoTWVyc2VubmVUd2lzdGVyLkYsIHhvcmVkKSArIGlkeCkgfCAwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvdXQ7XG4gICAgfTtcbiAgICBNZXJzZW5uZVR3aXN0ZXIuZnJvbSA9IGZ1bmN0aW9uIChzZWVkKSB7XG4gICAgICAgIHJldHVybiBuZXcgTWVyc2VubmVUd2lzdGVyKE1lcnNlbm5lVHdpc3Rlci50d2lzdChNZXJzZW5uZVR3aXN0ZXIuc2VlZGVkKHNlZWQpKSwgMCk7XG4gICAgfTtcbiAgICBNZXJzZW5uZVR3aXN0ZXIucHJvdG90eXBlLm1pbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIE1lcnNlbm5lVHdpc3Rlci5taW47XG4gICAgfTtcbiAgICBNZXJzZW5uZVR3aXN0ZXIucHJvdG90eXBlLm1heCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIE1lcnNlbm5lVHdpc3Rlci5tYXg7XG4gICAgfTtcbiAgICBNZXJzZW5uZVR3aXN0ZXIucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gbmV3IE1lcnNlbm5lVHdpc3Rlcih0aGlzLnN0YXRlcywgdGhpcy5pbmRleCk7XG4gICAgfTtcbiAgICBNZXJzZW5uZVR3aXN0ZXIucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBuZXh0Um5nID0gbmV3IE1lcnNlbm5lVHdpc3Rlcih0aGlzLnN0YXRlcywgdGhpcy5pbmRleCk7XG4gICAgICAgIHZhciBvdXQgPSBuZXh0Um5nLnVuc2FmZU5leHQoKTtcbiAgICAgICAgcmV0dXJuIFtvdXQsIG5leHRSbmddO1xuICAgIH07XG4gICAgTWVyc2VubmVUd2lzdGVyLnByb3RvdHlwZS51bnNhZmVOZXh0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgeSA9IHRoaXMuc3RhdGVzW3RoaXMuaW5kZXhdO1xuICAgICAgICB5IF49IHRoaXMuc3RhdGVzW3RoaXMuaW5kZXhdID4+PiBNZXJzZW5uZVR3aXN0ZXIuVTtcbiAgICAgICAgeSBePSAoeSA8PCBNZXJzZW5uZVR3aXN0ZXIuUykgJiBNZXJzZW5uZVR3aXN0ZXIuQjtcbiAgICAgICAgeSBePSAoeSA8PCBNZXJzZW5uZVR3aXN0ZXIuVCkgJiBNZXJzZW5uZVR3aXN0ZXIuQztcbiAgICAgICAgeSBePSB5ID4+PiBNZXJzZW5uZVR3aXN0ZXIuTDtcbiAgICAgICAgaWYgKCsrdGhpcy5pbmRleCA+PSBNZXJzZW5uZVR3aXN0ZXIuTikge1xuICAgICAgICAgICAgdGhpcy5zdGF0ZXMgPSBNZXJzZW5uZVR3aXN0ZXIudHdpc3QodGhpcy5zdGF0ZXMpO1xuICAgICAgICAgICAgdGhpcy5pbmRleCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHkgPj4+IDA7XG4gICAgfTtcbiAgICBNZXJzZW5uZVR3aXN0ZXIubWluID0gMDtcbiAgICBNZXJzZW5uZVR3aXN0ZXIubWF4ID0gMHhmZmZmZmZmZjtcbiAgICBNZXJzZW5uZVR3aXN0ZXIuTiA9IDYyNDtcbiAgICBNZXJzZW5uZVR3aXN0ZXIuTSA9IDM5NztcbiAgICBNZXJzZW5uZVR3aXN0ZXIuUiA9IDMxO1xuICAgIE1lcnNlbm5lVHdpc3Rlci5BID0gMHg5OTA4YjBkZjtcbiAgICBNZXJzZW5uZVR3aXN0ZXIuRiA9IDE4MTI0MzMyNTM7XG4gICAgTWVyc2VubmVUd2lzdGVyLlUgPSAxMTtcbiAgICBNZXJzZW5uZVR3aXN0ZXIuUyA9IDc7XG4gICAgTWVyc2VubmVUd2lzdGVyLkIgPSAweDlkMmM1NjgwO1xuICAgIE1lcnNlbm5lVHdpc3Rlci5UID0gMTU7XG4gICAgTWVyc2VubmVUd2lzdGVyLkMgPSAweGVmYzYwMDAwO1xuICAgIE1lcnNlbm5lVHdpc3Rlci5MID0gMTg7XG4gICAgTWVyc2VubmVUd2lzdGVyLk1BU0tfTE9XRVIgPSBNYXRoLnBvdygyLCBNZXJzZW5uZVR3aXN0ZXIuUikgLSAxO1xuICAgIE1lcnNlbm5lVHdpc3Rlci5NQVNLX1VQUEVSID0gTWF0aC5wb3coMiwgTWVyc2VubmVUd2lzdGVyLlIpO1xuICAgIHJldHVybiBNZXJzZW5uZVR3aXN0ZXI7XG59KCkpO1xuZnVuY3Rpb24gZGVmYXVsdF8xKHNlZWQpIHtcbiAgICByZXR1cm4gTWVyc2VubmVUd2lzdGVyLmZyb20oc2VlZCk7XG59XG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IGRlZmF1bHRfMTtcbiIsIlwidXNlIHN0cmljdFwiO1xuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbmV4cG9ydHMuc2tpcE4gPSBleHBvcnRzLnVuc2FmZVNraXBOID0gZXhwb3J0cy5nZW5lcmF0ZU4gPSBleHBvcnRzLnVuc2FmZUdlbmVyYXRlTiA9IHZvaWQgMDtcbmZ1bmN0aW9uIHVuc2FmZUdlbmVyYXRlTihybmcsIG51bSkge1xuICAgIHZhciBvdXQgPSBbXTtcbiAgICBmb3IgKHZhciBpZHggPSAwOyBpZHggIT0gbnVtOyArK2lkeCkge1xuICAgICAgICBvdXQucHVzaChybmcudW5zYWZlTmV4dCgpKTtcbiAgICB9XG4gICAgcmV0dXJuIG91dDtcbn1cbmV4cG9ydHMudW5zYWZlR2VuZXJhdGVOID0gdW5zYWZlR2VuZXJhdGVOO1xuZnVuY3Rpb24gZ2VuZXJhdGVOKHJuZywgbnVtKSB7XG4gICAgdmFyIG5leHRSbmcgPSBybmcuY2xvbmUoKTtcbiAgICB2YXIgb3V0ID0gdW5zYWZlR2VuZXJhdGVOKG5leHRSbmcsIG51bSk7XG4gICAgcmV0dXJuIFtvdXQsIG5leHRSbmddO1xufVxuZXhwb3J0cy5nZW5lcmF0ZU4gPSBnZW5lcmF0ZU47XG5mdW5jdGlvbiB1bnNhZmVTa2lwTihybmcsIG51bSkge1xuICAgIGZvciAodmFyIGlkeCA9IDA7IGlkeCAhPSBudW07ICsraWR4KSB7XG4gICAgICAgIHJuZy51bnNhZmVOZXh0KCk7XG4gICAgfVxufVxuZXhwb3J0cy51bnNhZmVTa2lwTiA9IHVuc2FmZVNraXBOO1xuZnVuY3Rpb24gc2tpcE4ocm5nLCBudW0pIHtcbiAgICB2YXIgbmV4dFJuZyA9IHJuZy5jbG9uZSgpO1xuICAgIHVuc2FmZVNraXBOKG5leHRSbmcsIG51bSk7XG4gICAgcmV0dXJuIG5leHRSbmc7XG59XG5leHBvcnRzLnNraXBOID0gc2tpcE47XG4iLCJcInVzZSBzdHJpY3RcIjtcbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5leHBvcnRzLnhvcnNoaWZ0MTI4cGx1cyA9IHZvaWQgMDtcbnZhciBYb3JTaGlmdDEyOFBsdXMgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFhvclNoaWZ0MTI4UGx1cyhzMDEsIHMwMCwgczExLCBzMTApIHtcbiAgICAgICAgdGhpcy5zMDEgPSBzMDE7XG4gICAgICAgIHRoaXMuczAwID0gczAwO1xuICAgICAgICB0aGlzLnMxMSA9IHMxMTtcbiAgICAgICAgdGhpcy5zMTAgPSBzMTA7XG4gICAgfVxuICAgIFhvclNoaWZ0MTI4UGx1cy5wcm90b3R5cGUubWluID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gLTB4ODAwMDAwMDA7XG4gICAgfTtcbiAgICBYb3JTaGlmdDEyOFBsdXMucHJvdG90eXBlLm1heCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIDB4N2ZmZmZmZmY7XG4gICAgfTtcbiAgICBYb3JTaGlmdDEyOFBsdXMucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gbmV3IFhvclNoaWZ0MTI4UGx1cyh0aGlzLnMwMSwgdGhpcy5zMDAsIHRoaXMuczExLCB0aGlzLnMxMCk7XG4gICAgfTtcbiAgICBYb3JTaGlmdDEyOFBsdXMucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBuZXh0Um5nID0gbmV3IFhvclNoaWZ0MTI4UGx1cyh0aGlzLnMwMSwgdGhpcy5zMDAsIHRoaXMuczExLCB0aGlzLnMxMCk7XG4gICAgICAgIHZhciBvdXQgPSBuZXh0Um5nLnVuc2FmZU5leHQoKTtcbiAgICAgICAgcmV0dXJuIFtvdXQsIG5leHRSbmddO1xuICAgIH07XG4gICAgWG9yU2hpZnQxMjhQbHVzLnByb3RvdHlwZS51bnNhZmVOZXh0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYTAgPSB0aGlzLnMwMCBeICh0aGlzLnMwMCA8PCAyMyk7XG4gICAgICAgIHZhciBhMSA9IHRoaXMuczAxIF4gKCh0aGlzLnMwMSA8PCAyMykgfCAodGhpcy5zMDAgPj4+IDkpKTtcbiAgICAgICAgdmFyIGIwID0gYTAgXiB0aGlzLnMxMCBeICgoYTAgPj4+IDE4KSB8IChhMSA8PCAxNCkpIF4gKCh0aGlzLnMxMCA+Pj4gNSkgfCAodGhpcy5zMTEgPDwgMjcpKTtcbiAgICAgICAgdmFyIGIxID0gYTEgXiB0aGlzLnMxMSBeIChhMSA+Pj4gMTgpIF4gKHRoaXMuczExID4+PiA1KTtcbiAgICAgICAgdmFyIG91dCA9ICh0aGlzLnMwMCArIHRoaXMuczEwKSB8IDA7XG4gICAgICAgIHRoaXMuczAxID0gdGhpcy5zMTE7XG4gICAgICAgIHRoaXMuczAwID0gdGhpcy5zMTA7XG4gICAgICAgIHRoaXMuczExID0gYjE7XG4gICAgICAgIHRoaXMuczEwID0gYjA7XG4gICAgICAgIHJldHVybiBvdXQ7XG4gICAgfTtcbiAgICBYb3JTaGlmdDEyOFBsdXMucHJvdG90eXBlLmp1bXAgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBuZXh0Um5nID0gbmV3IFhvclNoaWZ0MTI4UGx1cyh0aGlzLnMwMSwgdGhpcy5zMDAsIHRoaXMuczExLCB0aGlzLnMxMCk7XG4gICAgICAgIG5leHRSbmcudW5zYWZlSnVtcCgpO1xuICAgICAgICByZXR1cm4gbmV4dFJuZztcbiAgICB9O1xuICAgIFhvclNoaWZ0MTI4UGx1cy5wcm90b3R5cGUudW5zYWZlSnVtcCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG5zMDEgPSAwO1xuICAgICAgICB2YXIgbnMwMCA9IDA7XG4gICAgICAgIHZhciBuczExID0gMDtcbiAgICAgICAgdmFyIG5zMTAgPSAwO1xuICAgICAgICB2YXIganVtcCA9IFsweDYzNWQyZGZmLCAweDhhNWNkNzg5LCAweDVjNDcyZjk2LCAweDEyMWZkMjE1XTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgIT09IDQ7ICsraSkge1xuICAgICAgICAgICAgZm9yICh2YXIgbWFzayA9IDE7IG1hc2s7IG1hc2sgPDw9IDEpIHtcbiAgICAgICAgICAgICAgICBpZiAoanVtcFtpXSAmIG1hc2spIHtcbiAgICAgICAgICAgICAgICAgICAgbnMwMSBePSB0aGlzLnMwMTtcbiAgICAgICAgICAgICAgICAgICAgbnMwMCBePSB0aGlzLnMwMDtcbiAgICAgICAgICAgICAgICAgICAgbnMxMSBePSB0aGlzLnMxMTtcbiAgICAgICAgICAgICAgICAgICAgbnMxMCBePSB0aGlzLnMxMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy51bnNhZmVOZXh0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zMDEgPSBuczAxO1xuICAgICAgICB0aGlzLnMwMCA9IG5zMDA7XG4gICAgICAgIHRoaXMuczExID0gbnMxMTtcbiAgICAgICAgdGhpcy5zMTAgPSBuczEwO1xuICAgIH07XG4gICAgcmV0dXJuIFhvclNoaWZ0MTI4UGx1cztcbn0oKSk7XG52YXIgeG9yc2hpZnQxMjhwbHVzID0gZnVuY3Rpb24gKHNlZWQpIHtcbiAgICByZXR1cm4gbmV3IFhvclNoaWZ0MTI4UGx1cygtMSwgfnNlZWQsIHNlZWQgfCAwLCAwKTtcbn07XG5leHBvcnRzLnhvcnNoaWZ0MTI4cGx1cyA9IHhvcnNoaWZ0MTI4cGx1cztcbiIsIlwidXNlIHN0cmljdFwiO1xuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbmV4cG9ydHMueG9yb3NoaXJvMTI4cGx1cyA9IHZvaWQgMDtcbnZhciBYb3JvU2hpcm8xMjhQbHVzID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBYb3JvU2hpcm8xMjhQbHVzKHMwMSwgczAwLCBzMTEsIHMxMCkge1xuICAgICAgICB0aGlzLnMwMSA9IHMwMTtcbiAgICAgICAgdGhpcy5zMDAgPSBzMDA7XG4gICAgICAgIHRoaXMuczExID0gczExO1xuICAgICAgICB0aGlzLnMxMCA9IHMxMDtcbiAgICB9XG4gICAgWG9yb1NoaXJvMTI4UGx1cy5wcm90b3R5cGUubWluID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gLTB4ODAwMDAwMDA7XG4gICAgfTtcbiAgICBYb3JvU2hpcm8xMjhQbHVzLnByb3RvdHlwZS5tYXggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAweDdmZmZmZmZmO1xuICAgIH07XG4gICAgWG9yb1NoaXJvMTI4UGx1cy5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBuZXcgWG9yb1NoaXJvMTI4UGx1cyh0aGlzLnMwMSwgdGhpcy5zMDAsIHRoaXMuczExLCB0aGlzLnMxMCk7XG4gICAgfTtcbiAgICBYb3JvU2hpcm8xMjhQbHVzLnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgbmV4dFJuZyA9IG5ldyBYb3JvU2hpcm8xMjhQbHVzKHRoaXMuczAxLCB0aGlzLnMwMCwgdGhpcy5zMTEsIHRoaXMuczEwKTtcbiAgICAgICAgdmFyIG91dCA9IG5leHRSbmcudW5zYWZlTmV4dCgpO1xuICAgICAgICByZXR1cm4gW291dCwgbmV4dFJuZ107XG4gICAgfTtcbiAgICBYb3JvU2hpcm8xMjhQbHVzLnByb3RvdHlwZS51bnNhZmVOZXh0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgb3V0ID0gKHRoaXMuczAwICsgdGhpcy5zMTApIHwgMDtcbiAgICAgICAgdmFyIGEwID0gdGhpcy5zMTAgXiB0aGlzLnMwMDtcbiAgICAgICAgdmFyIGExID0gdGhpcy5zMTEgXiB0aGlzLnMwMTtcbiAgICAgICAgdmFyIHMwMCA9IHRoaXMuczAwO1xuICAgICAgICB2YXIgczAxID0gdGhpcy5zMDE7XG4gICAgICAgIHRoaXMuczAwID0gKHMwMCA8PCAyNCkgXiAoczAxID4+PiA4KSBeIGEwIF4gKGEwIDw8IDE2KTtcbiAgICAgICAgdGhpcy5zMDEgPSAoczAxIDw8IDI0KSBeIChzMDAgPj4+IDgpIF4gYTEgXiAoKGExIDw8IDE2KSB8IChhMCA+Pj4gMTYpKTtcbiAgICAgICAgdGhpcy5zMTAgPSAoYTEgPDwgNSkgXiAoYTAgPj4+IDI3KTtcbiAgICAgICAgdGhpcy5zMTEgPSAoYTAgPDwgNSkgXiAoYTEgPj4+IDI3KTtcbiAgICAgICAgcmV0dXJuIG91dDtcbiAgICB9O1xuICAgIFhvcm9TaGlybzEyOFBsdXMucHJvdG90eXBlLmp1bXAgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBuZXh0Um5nID0gbmV3IFhvcm9TaGlybzEyOFBsdXModGhpcy5zMDEsIHRoaXMuczAwLCB0aGlzLnMxMSwgdGhpcy5zMTApO1xuICAgICAgICBuZXh0Um5nLnVuc2FmZUp1bXAoKTtcbiAgICAgICAgcmV0dXJuIG5leHRSbmc7XG4gICAgfTtcbiAgICBYb3JvU2hpcm8xMjhQbHVzLnByb3RvdHlwZS51bnNhZmVKdW1wID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgbnMwMSA9IDA7XG4gICAgICAgIHZhciBuczAwID0gMDtcbiAgICAgICAgdmFyIG5zMTEgPSAwO1xuICAgICAgICB2YXIgbnMxMCA9IDA7XG4gICAgICAgIHZhciBqdW1wID0gWzB4ZDhmNTU0YTUsIDB4ZGY5MDAyOTQsIDB4NGIzMjAxZmMsIDB4MTcwODY1ZGZdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSAhPT0gNDsgKytpKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBtYXNrID0gMTsgbWFzazsgbWFzayA8PD0gMSkge1xuICAgICAgICAgICAgICAgIGlmIChqdW1wW2ldICYgbWFzaykge1xuICAgICAgICAgICAgICAgICAgICBuczAxIF49IHRoaXMuczAxO1xuICAgICAgICAgICAgICAgICAgICBuczAwIF49IHRoaXMuczAwO1xuICAgICAgICAgICAgICAgICAgICBuczExIF49IHRoaXMuczExO1xuICAgICAgICAgICAgICAgICAgICBuczEwIF49IHRoaXMuczEwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLnVuc2FmZU5leHQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLnMwMSA9IG5zMDE7XG4gICAgICAgIHRoaXMuczAwID0gbnMwMDtcbiAgICAgICAgdGhpcy5zMTEgPSBuczExO1xuICAgICAgICB0aGlzLnMxMCA9IG5zMTA7XG4gICAgfTtcbiAgICByZXR1cm4gWG9yb1NoaXJvMTI4UGx1cztcbn0oKSk7XG52YXIgeG9yb3NoaXJvMTI4cGx1cyA9IGZ1bmN0aW9uIChzZWVkKSB7XG4gICAgcmV0dXJuIG5ldyBYb3JvU2hpcm8xMjhQbHVzKC0xLCB+c2VlZCwgc2VlZCB8IDAsIDApO1xufTtcbmV4cG9ydHMueG9yb3NoaXJvMTI4cGx1cyA9IHhvcm9zaGlybzEyOHBsdXM7XG4iLCJcInVzZSBzdHJpY3RcIjtcbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5leHBvcnRzLnVuc2FmZVVuaWZvcm1JbnREaXN0cmlidXRpb24gPSBleHBvcnRzLnVuc2FmZVVuaWZvcm1CaWdJbnREaXN0cmlidXRpb24gPSBleHBvcnRzLnVuc2FmZVVuaWZvcm1BcnJheUludERpc3RyaWJ1dGlvbiA9IGV4cG9ydHMudW5pZm9ybUludERpc3RyaWJ1dGlvbiA9IGV4cG9ydHMudW5pZm9ybUJpZ0ludERpc3RyaWJ1dGlvbiA9IGV4cG9ydHMudW5pZm9ybUFycmF5SW50RGlzdHJpYnV0aW9uID0gZXhwb3J0cy54b3Jvc2hpcm8xMjhwbHVzID0gZXhwb3J0cy54b3JzaGlmdDEyOHBsdXMgPSBleHBvcnRzLm1lcnNlbm5lID0gZXhwb3J0cy5jb25ncnVlbnRpYWwzMiA9IGV4cG9ydHMuY29uZ3J1ZW50aWFsID0gZXhwb3J0cy51bnNhZmVTa2lwTiA9IGV4cG9ydHMudW5zYWZlR2VuZXJhdGVOID0gZXhwb3J0cy5za2lwTiA9IGV4cG9ydHMuZ2VuZXJhdGVOID0gZXhwb3J0cy5fX2NvbW1pdEhhc2ggPSBleHBvcnRzLl9fdmVyc2lvbiA9IGV4cG9ydHMuX190eXBlID0gdm9pZCAwO1xudmFyIFJhbmRvbUdlbmVyYXRvcl8xID0gcmVxdWlyZShcIi4vZ2VuZXJhdG9yL1JhbmRvbUdlbmVyYXRvclwiKTtcbmV4cG9ydHMuZ2VuZXJhdGVOID0gUmFuZG9tR2VuZXJhdG9yXzEuZ2VuZXJhdGVOO1xuZXhwb3J0cy5za2lwTiA9IFJhbmRvbUdlbmVyYXRvcl8xLnNraXBOO1xuZXhwb3J0cy51bnNhZmVHZW5lcmF0ZU4gPSBSYW5kb21HZW5lcmF0b3JfMS51bnNhZmVHZW5lcmF0ZU47XG5leHBvcnRzLnVuc2FmZVNraXBOID0gUmFuZG9tR2VuZXJhdG9yXzEudW5zYWZlU2tpcE47XG52YXIgTGluZWFyQ29uZ3J1ZW50aWFsXzEgPSByZXF1aXJlKFwiLi9nZW5lcmF0b3IvTGluZWFyQ29uZ3J1ZW50aWFsXCIpO1xuZXhwb3J0cy5jb25ncnVlbnRpYWwgPSBMaW5lYXJDb25ncnVlbnRpYWxfMS5jb25ncnVlbnRpYWw7XG5leHBvcnRzLmNvbmdydWVudGlhbDMyID0gTGluZWFyQ29uZ3J1ZW50aWFsXzEuY29uZ3J1ZW50aWFsMzI7XG52YXIgTWVyc2VubmVUd2lzdGVyXzEgPSByZXF1aXJlKFwiLi9nZW5lcmF0b3IvTWVyc2VubmVUd2lzdGVyXCIpO1xuZXhwb3J0cy5tZXJzZW5uZSA9IE1lcnNlbm5lVHdpc3Rlcl8xW1wiZGVmYXVsdFwiXTtcbnZhciBYb3JTaGlmdF8xID0gcmVxdWlyZShcIi4vZ2VuZXJhdG9yL1hvclNoaWZ0XCIpO1xuZXhwb3J0cy54b3JzaGlmdDEyOHBsdXMgPSBYb3JTaGlmdF8xLnhvcnNoaWZ0MTI4cGx1cztcbnZhciBYb3JvU2hpcm9fMSA9IHJlcXVpcmUoXCIuL2dlbmVyYXRvci9Yb3JvU2hpcm9cIik7XG5leHBvcnRzLnhvcm9zaGlybzEyOHBsdXMgPSBYb3JvU2hpcm9fMS54b3Jvc2hpcm8xMjhwbHVzO1xudmFyIFVuaWZvcm1BcnJheUludERpc3RyaWJ1dGlvbl8xID0gcmVxdWlyZShcIi4vZGlzdHJpYnV0aW9uL1VuaWZvcm1BcnJheUludERpc3RyaWJ1dGlvblwiKTtcbmV4cG9ydHMudW5pZm9ybUFycmF5SW50RGlzdHJpYnV0aW9uID0gVW5pZm9ybUFycmF5SW50RGlzdHJpYnV0aW9uXzEudW5pZm9ybUFycmF5SW50RGlzdHJpYnV0aW9uO1xudmFyIFVuaWZvcm1CaWdJbnREaXN0cmlidXRpb25fMSA9IHJlcXVpcmUoXCIuL2Rpc3RyaWJ1dGlvbi9Vbmlmb3JtQmlnSW50RGlzdHJpYnV0aW9uXCIpO1xuZXhwb3J0cy51bmlmb3JtQmlnSW50RGlzdHJpYnV0aW9uID0gVW5pZm9ybUJpZ0ludERpc3RyaWJ1dGlvbl8xLnVuaWZvcm1CaWdJbnREaXN0cmlidXRpb247XG52YXIgVW5pZm9ybUludERpc3RyaWJ1dGlvbl8xID0gcmVxdWlyZShcIi4vZGlzdHJpYnV0aW9uL1VuaWZvcm1JbnREaXN0cmlidXRpb25cIik7XG5leHBvcnRzLnVuaWZvcm1JbnREaXN0cmlidXRpb24gPSBVbmlmb3JtSW50RGlzdHJpYnV0aW9uXzEudW5pZm9ybUludERpc3RyaWJ1dGlvbjtcbnZhciBVbnNhZmVVbmlmb3JtQXJyYXlJbnREaXN0cmlidXRpb25fMSA9IHJlcXVpcmUoXCIuL2Rpc3RyaWJ1dGlvbi9VbnNhZmVVbmlmb3JtQXJyYXlJbnREaXN0cmlidXRpb25cIik7XG5leHBvcnRzLnVuc2FmZVVuaWZvcm1BcnJheUludERpc3RyaWJ1dGlvbiA9IFVuc2FmZVVuaWZvcm1BcnJheUludERpc3RyaWJ1dGlvbl8xLnVuc2FmZVVuaWZvcm1BcnJheUludERpc3RyaWJ1dGlvbjtcbnZhciBVbnNhZmVVbmlmb3JtQmlnSW50RGlzdHJpYnV0aW9uXzEgPSByZXF1aXJlKFwiLi9kaXN0cmlidXRpb24vVW5zYWZlVW5pZm9ybUJpZ0ludERpc3RyaWJ1dGlvblwiKTtcbmV4cG9ydHMudW5zYWZlVW5pZm9ybUJpZ0ludERpc3RyaWJ1dGlvbiA9IFVuc2FmZVVuaWZvcm1CaWdJbnREaXN0cmlidXRpb25fMS51bnNhZmVVbmlmb3JtQmlnSW50RGlzdHJpYnV0aW9uO1xudmFyIFVuc2FmZVVuaWZvcm1JbnREaXN0cmlidXRpb25fMSA9IHJlcXVpcmUoXCIuL2Rpc3RyaWJ1dGlvbi9VbnNhZmVVbmlmb3JtSW50RGlzdHJpYnV0aW9uXCIpO1xuZXhwb3J0cy51bnNhZmVVbmlmb3JtSW50RGlzdHJpYnV0aW9uID0gVW5zYWZlVW5pZm9ybUludERpc3RyaWJ1dGlvbl8xLnVuc2FmZVVuaWZvcm1JbnREaXN0cmlidXRpb247XG52YXIgX190eXBlID0gJ2NvbW1vbmpzJztcbmV4cG9ydHMuX190eXBlID0gX190eXBlO1xudmFyIF9fdmVyc2lvbiA9ICc1LjAuMCc7XG5leHBvcnRzLl9fdmVyc2lvbiA9IF9fdmVyc2lvbjtcbnZhciBfX2NvbW1pdEhhc2ggPSAnNzQ0NTU1ODU1YTAxZTE1NTFhYjFjZjY3YTZlYTk3M2QxNDk2NDY2MSc7XG5leHBvcnRzLl9fY29tbWl0SGFzaCA9IF9fY29tbWl0SGFzaDtcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH0pO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX2V4cG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9fZXhwb3J0U3RhcikgfHwgZnVuY3Rpb24obSwgZXhwb3J0cykge1xuICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKHAgIT09IFwiZGVmYXVsdFwiICYmICFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZXhwb3J0cywgcCkpIF9fY3JlYXRlQmluZGluZyhleHBvcnRzLCBtLCBwKTtcbn07XG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xudmFyIHByYW5kID0gcmVxdWlyZShcIi4vcHVyZS1yYW5kLWRlZmF1bHRcIik7XG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IHByYW5kO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL3B1cmUtcmFuZC1kZWZhdWx0XCIpLCBleHBvcnRzKTtcbiIsIi8vIFRoZSBtb2R1bGUgY2FjaGVcbnZhciBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX18gPSB7fTtcblxuLy8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbmZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcblx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG5cdHZhciBjYWNoZWRNb2R1bGUgPSBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX19bbW9kdWxlSWRdO1xuXHRpZiAoY2FjaGVkTW9kdWxlICE9PSB1bmRlZmluZWQpIHtcblx0XHRyZXR1cm4gY2FjaGVkTW9kdWxlLmV4cG9ydHM7XG5cdH1cblx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcblx0dmFyIG1vZHVsZSA9IF9fd2VicGFja19tb2R1bGVfY2FjaGVfX1ttb2R1bGVJZF0gPSB7XG5cdFx0aWQ6IG1vZHVsZUlkLFxuXHRcdGxvYWRlZDogZmFsc2UsXG5cdFx0ZXhwb3J0czoge31cblx0fTtcblxuXHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cblx0X193ZWJwYWNrX21vZHVsZXNfX1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cblx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxuXHRtb2R1bGUubG9hZGVkID0gdHJ1ZTtcblxuXHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuXHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG59XG5cbiIsIl9fd2VicGFja19yZXF1aXJlX18uZyA9IChmdW5jdGlvbigpIHtcblx0aWYgKHR5cGVvZiBnbG9iYWxUaGlzID09PSAnb2JqZWN0JykgcmV0dXJuIGdsb2JhbFRoaXM7XG5cdHRyeSB7XG5cdFx0cmV0dXJuIHRoaXMgfHwgbmV3IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCk7XG5cdH0gY2F0Y2ggKGUpIHtcblx0XHRpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ29iamVjdCcpIHJldHVybiB3aW5kb3c7XG5cdH1cbn0pKCk7IiwiLy8gZGVmaW5lIF9fZXNNb2R1bGUgb24gZXhwb3J0c1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yID0gKGV4cG9ydHMpID0+IHtcblx0aWYodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnRvU3RyaW5nVGFnKSB7XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFN5bWJvbC50b1N0cmluZ1RhZywgeyB2YWx1ZTogJ01vZHVsZScgfSk7XG5cdH1cblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbn07IiwiX193ZWJwYWNrX3JlcXVpcmVfXy5ubWQgPSAobW9kdWxlKSA9PiB7XG5cdG1vZHVsZS5wYXRocyA9IFtdO1xuXHRpZiAoIW1vZHVsZS5jaGlsZHJlbikgbW9kdWxlLmNoaWxkcmVuID0gW107XG5cdHJldHVybiBtb2R1bGU7XG59OyIsIlwidXNlIHN0cmljdFwiO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmNvbnN0IHZpcyA9IHJlcXVpcmUoXCJsaXRzY3JpcHQvbGliL3Zpc3VhbGl6ZXJcIik7XHJcbmNvbnN0IGxlID0gcmVxdWlyZShcImxpdHMtZXh0cmFzXCIpO1xyXG5jb25zdCBweiA9IHJlcXVpcmUoXCIuLlwiKTtcclxuY29uc3QganAgPSByZXF1aXJlKFwiLi4vdGVzdC9qc29ucGFyc2VyXCIpO1xyXG5yZXF1aXJlKFwiLi4vdGVzdC9qc29udGVzdHNcIik7XHJcbnJlcXVpcmUoXCIuL3J1bi1qc29uLXRlc3RzLmxlc3NcIik7XHJcbnZpcy5yZWdpc3RlclZpc3VhbGl6ZXIoXCJydW4tanNvbi10ZXN0c1wiLCBsZS5ydW5UZXN0cyk7XHJcbnZpcy5yZWdpc3RlclZpc3VhbGl6ZXIoXCJqc29uLXBhcnNlclwiLCBwYXJzZUpzb24pO1xyXG5mdW5jdGlvbiBwYXJzZUpzb24ocGFyYW1zLCBwYXJlbnQpIHtcclxuICAgIHBhcmVudC5jbGFzc0xpc3QuYWRkKFwianNvbi1lZGl0b3JcIik7XHJcbiAgICBsZXQgdGEgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0ZXh0YXJlYScpO1xyXG4gICAgdGEuY29scyA9IDQwO1xyXG4gICAgdGEucm93cyA9IDEwO1xyXG4gICAgbGV0IHJlcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xyXG4gICAgcmVzLmNsYXNzTGlzdC5hZGQoXCJyZXN1bHRcIik7XHJcbiAgICBwYXJlbnQuYXBwZW5kKHRhLCByZXMpO1xyXG4gICAgdGEuYWRkRXZlbnRMaXN0ZW5lcihcImlucHV0XCIsIF8gPT4ge1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIHJlcy5pbm5lclRleHQgPSBKU09OLnN0cmluZ2lmeShqcC5wYXJzZUpzb24odGEudmFsdWUpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgaWYgKGUgaW5zdGFuY2VvZiBwei5QYXJzZUVycm9yKVxyXG4gICAgICAgICAgICAgICAgcmVzLmlubmVyVGV4dCA9IGUubWVzc2FnZTtcclxuICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgdGhyb3cgZTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxufVxyXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=