{
  "version": 3,
  "sources": ["../../../litscript/src/custom-elem.ts", "../../../lits-extras/src/test-reporter.ts", "../../../lits-extras/node_modules/zora/dist/bundle/index.js", "../../../lits-extras/src/tester.ts", "../../../lits-extras/src/test-runner.ts", "../../src/ref.ts", "../../src/error.ts", "../../src/input.ts", "../../src/result.ts", "../../src/utils.ts", "../../src/lexer.ts", "../../src/parser.ts", "../../src/arrayparsers.ts", "../../src/index.ts", "../../src/test/exprparser.ts", "../../node_modules/fast-check/lib/esm/check/precondition/PreconditionFailure.js", "../../node_modules/fast-check/lib/esm/check/precondition/Pre.js", "../../node_modules/fast-check/lib/esm/stream/StreamHelpers.js", "../../node_modules/fast-check/lib/esm/stream/Stream.js", "../../node_modules/fast-check/lib/esm/check/symbols.js", "../../node_modules/fast-check/lib/esm/check/arbitrary/definition/Shrinkable.js", "../../node_modules/fast-check/lib/esm/check/arbitrary/definition/Arbitrary.js", "../../node_modules/fast-check/lib/esm/check/arbitrary/definition/ArbitraryWithContextualShrink.js", "../../node_modules/fast-check/lib/esm/check/arbitrary/definition/NextValue.js", "../../node_modules/fast-check/lib/esm/check/arbitrary/definition/NextArbitrary.js", "../../node_modules/fast-check/lib/esm/check/arbitrary/definition/ConverterToNext.js", "../../node_modules/fast-check/lib/esm/check/arbitrary/definition/ConverterFromNext.js", "../../node_modules/fast-check/lib/esm/check/arbitrary/definition/Converters.js", "../../node_modules/fast-check/lib/esm/arbitrary/_internals/TupleArbitrary.js", "../../node_modules/fast-check/lib/esm/arbitrary/genericTuple.js", "../../node_modules/fast-check/lib/esm/check/property/IRawProperty.js", "../../node_modules/fast-check/lib/esm/check/runner/configuration/GlobalParameters.js", "../../node_modules/fast-check/lib/esm/check/property/AsyncProperty.generic.js", "../../node_modules/fast-check/lib/esm/check/property/AsyncProperty.generated.js", "../../node_modules/fast-check/lib/esm/check/property/AsyncProperty.js", "../../node_modules/fast-check/lib/esm/check/property/Property.generic.js", "../../node_modules/fast-check/lib/esm/check/property/Property.generated.js", "../../node_modules/fast-check/lib/esm/check/property/Property.js", "../../node_modules/pure-rand/lib/esm/generator/RandomGenerator.js", "../../node_modules/pure-rand/lib/esm/generator/LinearCongruential.js", "../../node_modules/pure-rand/lib/esm/generator/MersenneTwister.js", "../../node_modules/pure-rand/lib/esm/generator/XorShift.js", "../../node_modules/pure-rand/lib/esm/generator/XoroShiro.js", "../../node_modules/pure-rand/lib/esm/distribution/internals/ArrayInt.js", "../../node_modules/pure-rand/lib/esm/distribution/internals/UnsafeUniformIntDistributionInternal.js", "../../node_modules/pure-rand/lib/esm/distribution/internals/UnsafeUniformArrayIntDistributionInternal.js", "../../node_modules/pure-rand/lib/esm/distribution/UnsafeUniformArrayIntDistribution.js", "../../node_modules/pure-rand/lib/esm/distribution/UniformArrayIntDistribution.js", "../../node_modules/pure-rand/lib/esm/distribution/UnsafeUniformBigIntDistribution.js", "../../node_modules/pure-rand/lib/esm/distribution/UniformBigIntDistribution.js", "../../node_modules/pure-rand/lib/esm/distribution/UnsafeUniformIntDistribution.js", "../../node_modules/pure-rand/lib/esm/distribution/UniformIntDistribution.js", "../../node_modules/pure-rand/lib/esm/pure-rand-default.js", "../../node_modules/pure-rand/lib/esm/pure-rand.js", "../../node_modules/fast-check/lib/esm/check/runner/configuration/VerbosityLevel.js", "../../node_modules/fast-check/lib/esm/check/runner/configuration/QualifiedParameters.js", "../../node_modules/fast-check/lib/esm/check/property/SkipAfterProperty.js", "../../node_modules/fast-check/lib/esm/check/property/TimeoutProperty.js", "../../node_modules/fast-check/lib/esm/check/property/UnbiasedProperty.js", "../../node_modules/fast-check/lib/esm/utils/stringify.js", "../../node_modules/fast-check/lib/esm/check/property/IgnoreEqualValuesProperty.js", "../../node_modules/fast-check/lib/esm/check/runner/DecorateProperty.js", "../../node_modules/fast-check/lib/esm/check/runner/reporter/ExecutionStatus.js", "../../node_modules/fast-check/lib/esm/check/runner/reporter/RunExecution.js", "../../node_modules/fast-check/lib/esm/check/runner/RunnerIterator.js", "../../node_modules/fast-check/lib/esm/check/runner/SourceValuesIterator.js", "../../node_modules/fast-check/lib/esm/random/generator/PureRandom.js", "../../node_modules/fast-check/lib/esm/random/generator/Random.js", "../../node_modules/fast-check/lib/esm/check/runner/Tosser.js", "../../node_modules/fast-check/lib/esm/check/runner/utils/PathWalker.js", "../../node_modules/fast-check/lib/esm/check/runner/utils/RunDetailsFormatter.js", "../../node_modules/fast-check/lib/esm/check/runner/Runner.js", "../../node_modules/fast-check/lib/esm/check/runner/Sampler.js", "../../node_modules/fast-check/lib/esm/arbitrary/_internals/helpers/BiasNumericRange.js", "../../node_modules/fast-check/lib/esm/arbitrary/_internals/helpers/ShrinkInteger.js", "../../node_modules/fast-check/lib/esm/arbitrary/_internals/IntegerArbitrary.js", "../../node_modules/fast-check/lib/esm/arbitrary/integer.js", "../../node_modules/fast-check/lib/esm/stream/LazyIterableIterator.js", "../../node_modules/fast-check/lib/esm/arbitrary/_internals/helpers/BuildCompareFilter.js", "../../node_modules/fast-check/lib/esm/arbitrary/_internals/ArrayArbitrary.js", "../../node_modules/fast-check/lib/esm/arbitrary/_internals/helpers/MaxLengthFromMinLength.js", "../../node_modules/fast-check/lib/esm/arbitrary/array.js", "../../node_modules/fast-check/lib/esm/arbitrary/_internals/helpers/ShrinkBigInt.js", "../../node_modules/fast-check/lib/esm/arbitrary/_internals/BigIntArbitrary.js", "../../node_modules/fast-check/lib/esm/arbitrary/bigInt.js", "../../node_modules/fast-check/lib/esm/arbitrary/bigIntN.js", "../../node_modules/fast-check/lib/esm/arbitrary/bigUint.js", "../../node_modules/fast-check/lib/esm/arbitrary/bigUintN.js", "../../node_modules/fast-check/lib/esm/arbitrary/boolean.js", "../../node_modules/fast-check/lib/esm/arbitrary/_internals/ConstantArbitrary.js", "../../node_modules/fast-check/lib/esm/arbitrary/constantFrom.js", "../../node_modules/fast-check/lib/esm/arbitrary/falsy.js", "../../node_modules/fast-check/lib/esm/arbitrary/_internals/mappers/IndexToCharString.js", "../../node_modules/fast-check/lib/esm/arbitrary/_internals/builders/CharacterArbitraryBuilder.js", "../../node_modules/fast-check/lib/esm/arbitrary/_internals/mappers/IndexToPrintableIndex.js", "../../node_modules/fast-check/lib/esm/arbitrary/ascii.js", "../../node_modules/fast-check/lib/esm/arbitrary/base64.js", "../../node_modules/fast-check/lib/esm/arbitrary/char.js", "../../node_modules/fast-check/lib/esm/arbitrary/char16bits.js", "../../node_modules/fast-check/lib/esm/arbitrary/fullUnicode.js", "../../node_modules/fast-check/lib/esm/arbitrary/hexa.js", "../../node_modules/fast-check/lib/esm/arbitrary/unicode.js", "../../node_modules/fast-check/lib/esm/arbitrary/constant.js", "../../node_modules/fast-check/lib/esm/arbitrary/clonedConstant.js", "../../node_modules/fast-check/lib/esm/arbitrary/context.js", "../../node_modules/fast-check/lib/esm/arbitrary/_internals/mappers/TimeToDate.js", "../../node_modules/fast-check/lib/esm/arbitrary/date.js", "../../node_modules/fast-check/lib/esm/arbitrary/_internals/CloneArbitrary.js", "../../node_modules/fast-check/lib/esm/arbitrary/clone.js", "../../node_modules/fast-check/lib/esm/arbitrary/dedup.js", "../../node_modules/fast-check/lib/esm/arbitrary/set.js", "../../node_modules/fast-check/lib/esm/arbitrary/tuple.js", "../../node_modules/fast-check/lib/esm/arbitrary/_internals/mappers/KeyValuePairsToObject.js", "../../node_modules/fast-check/lib/esm/arbitrary/dictionary.js", "../../node_modules/fast-check/lib/esm/arbitrary/_internals/helpers/DepthContext.js", "../../node_modules/fast-check/lib/esm/arbitrary/_internals/FrequencyArbitrary.js", "../../node_modules/fast-check/lib/esm/arbitrary/frequency.js", "../../node_modules/fast-check/lib/esm/arbitrary/nat.js", "../../node_modules/fast-check/lib/esm/arbitrary/_internals/mappers/IndexToMappedConstant.js", "../../node_modules/fast-check/lib/esm/arbitrary/mapToConstant.js", "../../node_modules/fast-check/lib/esm/check/arbitrary/helpers/SpecificCharacterRange.js", "../../node_modules/fast-check/lib/esm/arbitrary/option.js", "../../node_modules/fast-check/lib/esm/arbitrary/_internals/helpers/StringConstraintsExtractor.js", "../../node_modules/fast-check/lib/esm/arbitrary/_internals/mappers/PatternsToString.js", "../../node_modules/fast-check/lib/esm/arbitrary/stringOf.js", "../../node_modules/fast-check/lib/esm/check/arbitrary/HostArbitrary.js", "../../node_modules/fast-check/lib/esm/check/arbitrary/EmailArbitrary.js", "../../node_modules/fast-check/lib/esm/check/arbitrary/helpers/ArrayInt64.js", "../../node_modules/fast-check/lib/esm/check/arbitrary/helpers/ArrayInt64Arbitrary.js", "../../node_modules/fast-check/lib/esm/check/arbitrary/DoubleNextArbitrary.js", "../../node_modules/fast-check/lib/esm/check/arbitrary/FloatNextArbitrary.js", "../../node_modules/fast-check/lib/esm/check/arbitrary/FloatingPointArbitrary.js", "../../node_modules/fast-check/lib/esm/check/arbitrary/helpers/TextEscaper.js", "../../node_modules/fast-check/lib/esm/utils/hash.js", "../../node_modules/fast-check/lib/esm/arbitrary/_internals/builders/CompareFunctionArbitraryBuilder.js", "../../node_modules/fast-check/lib/esm/arbitrary/compareBooleanFunc.js", "../../node_modules/fast-check/lib/esm/arbitrary/compareFunc.js", "../../node_modules/fast-check/lib/esm/arbitrary/func.js", "../../node_modules/fast-check/lib/esm/arbitrary/maxSafeInteger.js", "../../node_modules/fast-check/lib/esm/arbitrary/maxSafeNat.js", "../../node_modules/fast-check/lib/esm/arbitrary/_internals/mappers/NatToStringifiedNat.js", "../../node_modules/fast-check/lib/esm/arbitrary/ipV4.js", "../../node_modules/fast-check/lib/esm/arbitrary/oneof.js", "../../node_modules/fast-check/lib/esm/arbitrary/_internals/builders/StringifiedNatArbitraryBuilder.js", "../../node_modules/fast-check/lib/esm/arbitrary/ipV4Extended.js", "../../node_modules/fast-check/lib/esm/arbitrary/_internals/mappers/CodePointsToString.js", "../../node_modules/fast-check/lib/esm/arbitrary/hexaString.js", "../../node_modules/fast-check/lib/esm/arbitrary/_internals/mappers/EntitiesToIPv6.js", "../../node_modules/fast-check/lib/esm/arbitrary/ipV6.js", "../../node_modules/fast-check/lib/esm/arbitrary/_internals/LazyArbitrary.js", "../../node_modules/fast-check/lib/esm/arbitrary/letrec.js", "../../node_modules/fast-check/lib/esm/arbitrary/_internals/mappers/WordsToLorem.js", "../../node_modules/fast-check/lib/esm/arbitrary/lorem.js", "../../node_modules/fast-check/lib/esm/arbitrary/memo.js", "../../node_modules/fast-check/lib/esm/arbitrary/_internals/MixedCaseArbitrary.js", "../../node_modules/fast-check/lib/esm/arbitrary/mixedCase.js", "../../node_modules/fast-check/lib/esm/arbitrary/string.js", "../../node_modules/fast-check/lib/esm/arbitrary/unicodeString.js", "../../node_modules/fast-check/lib/esm/arbitrary/float32Array.js", "../../node_modules/fast-check/lib/esm/arbitrary/float64Array.js", "../../node_modules/fast-check/lib/esm/arbitrary/_internals/builders/TypedIntArrayArbitraryBuilder.js", "../../node_modules/fast-check/lib/esm/arbitrary/int16Array.js", "../../node_modules/fast-check/lib/esm/arbitrary/int32Array.js", "../../node_modules/fast-check/lib/esm/arbitrary/int8Array.js", "../../node_modules/fast-check/lib/esm/arbitrary/uint16Array.js", "../../node_modules/fast-check/lib/esm/arbitrary/uint32Array.js", "../../node_modules/fast-check/lib/esm/arbitrary/uint8Array.js", "../../node_modules/fast-check/lib/esm/arbitrary/uint8ClampedArray.js", "../../node_modules/fast-check/lib/esm/check/arbitrary/SparseArrayArbitrary.js", "../../node_modules/fast-check/lib/esm/check/arbitrary/ObjectArbitrary.js", "../../node_modules/fast-check/lib/esm/arbitrary/_internals/helpers/EnumerableKeysExtractor.js", "../../node_modules/fast-check/lib/esm/arbitrary/_internals/mappers/ValuesAndSeparateKeysToObject.js", "../../node_modules/fast-check/lib/esm/arbitrary/_internals/builders/PartialRecordArbitraryBuilder.js", "../../node_modules/fast-check/lib/esm/arbitrary/record.js", "../../node_modules/fast-check/lib/esm/arbitrary/_internals/StreamArbitrary.js", "../../node_modules/fast-check/lib/esm/arbitrary/infiniteStream.js", "../../node_modules/fast-check/lib/esm/arbitrary/asciiString.js", "../../node_modules/fast-check/lib/esm/arbitrary/_internals/mappers/StringToBase64.js", "../../node_modules/fast-check/lib/esm/arbitrary/base64String.js", "../../node_modules/fast-check/lib/esm/arbitrary/fullUnicodeString.js", "../../node_modules/fast-check/lib/esm/arbitrary/_internals/mappers/CharsToString.js", "../../node_modules/fast-check/lib/esm/arbitrary/string16bits.js", "../../node_modules/fast-check/lib/esm/check/arbitrary/definition/BiasedArbitraryWrapper.js", "../../node_modules/fast-check/lib/esm/check/arbitrary/SubarrayArbitrary.js", "../../node_modules/fast-check/lib/esm/check/arbitrary/UuidArbitrary.js", "../../node_modules/fast-check/lib/esm/check/arbitrary/WebArbitrary.js", "../../node_modules/fast-check/lib/esm/check/model/ReplayPath.js", "../../node_modules/fast-check/lib/esm/check/model/commands/CommandsIterable.js", "../../node_modules/fast-check/lib/esm/check/model/commands/CommandWrapper.js", "../../node_modules/fast-check/lib/esm/check/model/commands/CommandsArbitrary.js", "../../node_modules/fast-check/lib/esm/check/model/commands/ScheduledCommand.js", "../../node_modules/fast-check/lib/esm/check/model/ModelRunner.js", "../../node_modules/fast-check/lib/esm/arbitrary/_internals/implementations/SchedulerImplem.js", "../../node_modules/fast-check/lib/esm/arbitrary/_internals/helpers/BuildSchedulerFor.js", "../../node_modules/fast-check/lib/esm/arbitrary/_internals/SchedulerArbitrary.js", "../../node_modules/fast-check/lib/esm/arbitrary/scheduler.js", "../../node_modules/fast-check/lib/esm/check/arbitrary/definition/ArbitraryWithShrink.js", "../../node_modules/fast-check/lib/esm/fast-check-default.js", "../../node_modules/fast-check/lib/esm/fast-check.js", "../../src/test/exprtests.ts", "../../src/components/run-expr-tests.ts"],
  "sourcesContent": ["/**\r\n * # Dynamic Content with Web Components\r\n * \r\n * Visualizers are removed in LiTScript version 2. The recommended alternative\r\n * is to use [web components][] as a substitute. They can be inserted to \r\n * markdown as easily and have other benefits:\r\n* \r\n *   *  [Shadow DOM][] isolates styles from the parent document. This prevents \r\n *      CSS rules from spilling into the main page.\r\n * \r\n *   *  You don't have to register your components with LiTScript. The web\r\n *      component API handles that.\r\n * \r\n *   *  It's simpler to add parameters to the components using HTML attributes.\r\n * \r\n *   *  You can use JS frameworks such as [Lit][] to create your components.\r\n * \r\n * To help write web components in LiTScript, we provide a base class for custom\r\n * elements. It handles attaching the shadow DOM and loading styles into the\r\n * component. Below is an example how you can use it:\r\n * ```typescript\r\n *  // Import root style file. LiTScript will bundle this into file: \r\n *  // ${outDir}/dist/my-element.css\r\n *  import \"my-element.css\"\r\n * \r\n *  export abstract class MyElement extends StyledElement {\r\n *      constructor() {\r\n *          // Give the name of the root CSS file as argument to the inherited\r\n *          // constructor. The base class will insert a <link> tag inside the \r\n *          // component that loads the styles.\r\n *          super(\"my-element\")\r\n *          // Initialize your component here. Add your elements under the \r\n *          // inherited body element.\r\n *      }\r\n * \r\n *      protected override connect() {\r\n *          // Called when the element is attached to the DOM. Call code that\r\n *          // you want to perform here.\r\n *      }\r\n *  }\r\n *  // Register your custom element.\r\n *  customElements.define(\"my-element\", MyElement)\r\n * ```\r\n * \r\n * Now you can import your component in the [front matter][] of any other file\r\n * and insert it at any location.\r\n * ```json\r\n * ---\r\n * { \"modules\": [ \"path/to/my-element\" ] }\r\n * ---\r\n * \r\n * # Here is My Component\r\n * \r\n * <my-element />\r\n * ```\r\n * \r\n * [web components]: https://developer.mozilla.org/en-US/docs/Web/API/Web_components\r\n * [Shadow DOM]: https://developer.mozilla.org/en-US/docs/Web/API/Web_components/Using_shadow_DOM\r\n * [front matter]: templates/front-matter.html\r\n * [Lit]: https://lit.dev/\r\n * \r\n * ## CustomElement Class\r\n * \r\n * The base class for custom elements extends HTMLElement DOM class and attaches\r\n * a shadow root into it.\r\n */\r\nexport abstract class CustomElement extends HTMLElement {\r\n    protected root: ShadowRoot\r\n    /**\r\n     * The flag that tells whether the component has been attached to DOM.\r\n     */    \r\n    private connected: boolean\r\n    /**\r\n     * Constructor attaches the shadow DOM and clears the `connected` flag.\r\n     */\r\n    constructor() {\r\n        super();\r\n        this.root  = this.attachShadow({ mode: 'open' })\r\n        this.connected = false\r\n    }\r\n    /**\r\n     * This method is called when the component is attached to DOM. It checks\r\n     * whether we have already connected our functionality. If not we call the\r\n     * abstract `connect` method and set the `connected` flag.\r\n     */\r\n    connectedCallback() {\r\n        if (!this.connected) {\r\n            this.connect()\r\n            this.connected = true\r\n        }\r\n    }\r\n    /**\r\n     * Override this method to run code when the component is connected.\r\n     */\r\n    protected abstract connect()\r\n}\r\n/**\r\n * ## StyledElement Class\r\n * \r\n * The styled element inherits from custom element and adds stylesheet reference\r\n * to the shadow DOM. It also adds a `div` that is the new body of the element.\r\n */\r\nexport abstract class StyledElement extends CustomElement {\r\n    protected body: HTMLElement\r\n    /**\r\n     * Constructor attaches the shadow DOM and creates `<link>` tag under it\r\n     * that refers to the CSS file. Then it creates the `body` div under the\r\n     * shadow root. You can add your own elements under it.\r\n     */\r\n    constructor(cssRoot: string) {\r\n        super()\r\n        let link = document.createElement('link')\r\n        link.setAttribute('rel', 'stylesheet')\r\n        let src = (document.currentScript as HTMLScriptElement).src\r\n        let path = src.substring(0, src.lastIndexOf(\"/\"))\r\n        link.setAttribute('href', `${path}/${cssRoot}.css`)\r\n        this.root.appendChild(link)\r\n        this.body = document.createElement('div')\r\n        this.root.appendChild(this.body)\r\n    }\r\n}", "import * as zora from 'zora'\r\n\r\nexport interface Assertion {\r\n    name: string\r\n    pass?: boolean\r\n}\r\n\r\nexport interface Test extends Assertion {\r\n    error?: Error\r\n    passes: number\r\n    fails: number\r\n    duration: number\r\n    tests: Test[]\r\n    assertions: Assertion[]\r\n}\r\n\r\nfunction createTest(name: string): Test {\r\n    return {\r\n        name,\r\n        passes: 0,\r\n        fails: 0,\r\n        duration: 0,\r\n        tests: [],\r\n        assertions: []\r\n    }\r\n}\r\n\r\nexport function createReporter(name: string, render: (rootTest: Test) => void):\r\n    (stream: zora.TestHarness) => Promise<void> {\r\n    let rootTest = createTest(name)\r\n    let teststack: Test[] = [rootTest]\r\n    return async (stream: zora.TestHarness): Promise<void> => {\r\n        for await (let message of stream) {\r\n            switch (message.type) {\r\n                case zora.MessageType.TEST_START:\r\n                    let newtest = createTest((message as zora.StartTestMessage)\r\n                        .data.description)\r\n                    teststack[teststack.length - 1].tests.push(newtest)\r\n                    teststack.push(newtest)\r\n                    break\r\n                case zora.MessageType.TEST_END:\r\n                    let ztest = message.data as zora.Test\r\n                    let test = teststack.pop()\r\n                    test.pass = ztest.pass\r\n                    test.passes = ztest.successCount\r\n                    test.fails = ztest.failureCount\r\n                    test.error = ztest.error\r\n                    test.duration = ztest.executionTime\r\n                    render(rootTest)\r\n                    break\r\n                case zora.MessageType.ASSERTION:\r\n                    let zass = message.data as zora.AssertionResult\r\n                    teststack[teststack.length - 1].assertions.push({\r\n                        name: zass.description,\r\n                        pass: zass.pass\r\n                    })\r\n                    break\r\n                case zora.MessageType.BAIL_OUT:\r\n                    teststack[teststack.length - 1].error =\r\n                        (message as zora.BailoutMessage).data\r\n                    render(rootTest)\r\n                    break\r\n            }\r\n        }\r\n    }\r\n}", "'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nconst startTestMessage = (test, offset) => ({\n    type: \"TEST_START\" /* TEST_START */,\n    data: test,\n    offset\n});\nconst assertionMessage = (assertion, offset) => ({\n    type: \"ASSERTION\" /* ASSERTION */,\n    data: assertion,\n    offset\n});\nconst endTestMessage = (test, offset) => ({\n    type: \"TEST_END\" /* TEST_END */,\n    data: test,\n    offset\n});\nconst bailout = (error, offset) => ({\n    type: \"BAIL_OUT\" /* BAIL_OUT */,\n    data: error,\n    offset\n});\n\nconst delegateToCounter = (counter) => (target) => Object.defineProperties(target, {\n    skipCount: {\n        get() {\n            return counter.skipCount;\n        }\n    },\n    failureCount: {\n        get() {\n            return counter.failureCount;\n        }\n    },\n    successCount: {\n        get() {\n            return counter.successCount;\n        }\n    },\n    count: {\n        get() {\n            return counter.count;\n        }\n    }\n});\nconst counter = () => {\n    let success = 0;\n    let failure = 0;\n    let skip = 0;\n    return Object.defineProperties({\n        update(assertion) {\n            const { pass, skip: isSkipped } = assertion;\n            if (isSkipped) {\n                skip++;\n            }\n            else if (!isAssertionResult(assertion)) {\n                skip += assertion.skipCount;\n                success += assertion.successCount;\n                failure += assertion.failureCount;\n            }\n            else if (pass) {\n                success++;\n            }\n            else {\n                failure++;\n            }\n        }\n    }, {\n        successCount: {\n            get() {\n                return success;\n            }\n        },\n        failureCount: {\n            get() {\n                return failure;\n            }\n        },\n        skipCount: {\n            get() {\n                return skip;\n            }\n        },\n        count: {\n            get() {\n                return skip + success + failure;\n            }\n        }\n    });\n};\n\nconst defaultTestOptions = Object.freeze({\n    offset: 0,\n    skip: false,\n    runOnly: false\n});\nconst noop = () => {\n};\nconst TesterPrototype = {\n    [Symbol.asyncIterator]: async function* () {\n        await this.routine;\n        for (const assertion of this.assertions) {\n            if (assertion[Symbol.asyncIterator]) {\n                // Sub test\n                yield startTestMessage({ description: assertion.description }, this.offset);\n                yield* assertion;\n                if (assertion.error !== null) {\n                    // Bubble up the error and return\n                    this.error = assertion.error;\n                    this.pass = false;\n                    return;\n                }\n            }\n            yield assertionMessage(assertion, this.offset);\n            this.pass = this.pass && assertion.pass;\n            this.counter.update(assertion);\n        }\n        return this.error !== null ?\n            yield bailout(this.error, this.offset) :\n            yield endTestMessage(this, this.offset);\n    }\n};\nconst testerLikeProvider = (BaseProto = TesterPrototype) => (assertions, routine, offset) => {\n    const testCounter = counter();\n    const withTestCounter = delegateToCounter(testCounter);\n    let pass = true;\n    return withTestCounter(Object.create(BaseProto, {\n        routine: {\n            value: routine\n        },\n        assertions: {\n            value: assertions\n        },\n        offset: {\n            value: offset\n        },\n        counter: {\n            value: testCounter\n        },\n        length: {\n            get() {\n                return assertions.length;\n            }\n        },\n        pass: {\n            enumerable: true,\n            get() {\n                return pass;\n            },\n            set(val) {\n                pass = val;\n            }\n        }\n    }));\n};\nconst testerFactory = testerLikeProvider();\n\nconst tester = (description, spec, { offset = 0, skip = false, runOnly = false } = defaultTestOptions) => {\n    let executionTime = 0;\n    let error = null;\n    let done = false;\n    const assertions = [];\n    const collect = item => {\n        if (done) {\n            throw new Error(`test \"${description}\" \ntried to collect an assertion after it has run to its completion. \nYou might have forgotten to wait for an asynchronous task to complete\n------\n${spec.toString()}\n`);\n        }\n        assertions.push(item);\n    };\n    const specFunction = skip === true ? noop : function zora_spec_fn() {\n        return spec(assert(collect, offset, runOnly));\n    };\n    const testRoutine = (async function () {\n        try {\n            const start = Date.now();\n            const result = await specFunction();\n            executionTime = Date.now() - start;\n            return result;\n        }\n        catch (e) {\n            error = e;\n        }\n        finally {\n            done = true;\n        }\n    })();\n    return Object.defineProperties(testerFactory(assertions, testRoutine, offset), {\n        error: {\n            get() {\n                return error;\n            },\n            set(val) {\n                error = val;\n            }\n        },\n        executionTime: {\n            enumerable: true,\n            get() {\n                return executionTime;\n            }\n        },\n        skip: {\n            value: skip\n        },\n        description: {\n            enumerable: true,\n            value: description\n        }\n    });\n};\n\n// do not edit .js files directly - edit src/index.jst\n\n\n\nvar fastDeepEqual = function equal(a, b) {\n  if (a === b) return true;\n\n  if (a && b && typeof a == 'object' && typeof b == 'object') {\n    if (a.constructor !== b.constructor) return false;\n\n    var length, i, keys;\n    if (Array.isArray(a)) {\n      length = a.length;\n      if (length != b.length) return false;\n      for (i = length; i-- !== 0;)\n        if (!equal(a[i], b[i])) return false;\n      return true;\n    }\n\n\n\n    if (a.constructor === RegExp) return a.source === b.source && a.flags === b.flags;\n    if (a.valueOf !== Object.prototype.valueOf) return a.valueOf() === b.valueOf();\n    if (a.toString !== Object.prototype.toString) return a.toString() === b.toString();\n\n    keys = Object.keys(a);\n    length = keys.length;\n    if (length !== Object.keys(b).length) return false;\n\n    for (i = length; i-- !== 0;)\n      if (!Object.prototype.hasOwnProperty.call(b, keys[i])) return false;\n\n    for (i = length; i-- !== 0;) {\n      var key = keys[i];\n\n      if (!equal(a[key], b[key])) return false;\n    }\n\n    return true;\n  }\n\n  // true if both NaN, false otherwise\n  return a!==a && b!==b;\n};\n\nconst isAssertionResult = (result) => {\n    return 'operator' in result;\n};\nconst specFnRegexp = /zora_spec_fn/;\nconst zoraInternal = /zora\\/dist\\/bundle/;\nconst filterStackLine = l => (l && !zoraInternal.test(l) && !l.startsWith('Error') || specFnRegexp.test(l));\nconst getAssertionLocation = () => {\n    const err = new Error();\n    const stack = (err.stack || '')\n        .split('\\n')\n        .map(l => l.trim())\n        .filter(filterStackLine);\n    const userLandIndex = stack.findIndex(l => specFnRegexp.test(l));\n    const stackline = userLandIndex >= 1 ? stack[userLandIndex - 1] : (stack[0] || 'N/A');\n    return stackline\n        .replace(/^at|^@/, '');\n};\nconst assertMethodHook = (fn) => function (...args) {\n    // @ts-ignore\n    return this.collect(fn(...args));\n};\nconst aliasMethodHook = (methodName) => function (...args) {\n    return this[methodName](...args);\n};\nconst unbindAssert = (target) => Object.fromEntries([...Object.keys(AssertPrototype), 'collect']\n    .map((methodName) => [methodName, (...args) => target[methodName](...args)]));\nconst AssertPrototype = {\n    equal: assertMethodHook((actual, expected, description = 'should be equivalent') => ({\n        pass: fastDeepEqual(actual, expected),\n        actual,\n        expected,\n        description,\n        operator: \"equal\" /* EQUAL */\n    })),\n    equals: aliasMethodHook('equal'),\n    eq: aliasMethodHook('equal'),\n    deepEqual: aliasMethodHook('equal'),\n    same: aliasMethodHook('equal'),\n    notEqual: assertMethodHook((actual, expected, description = 'should not be equivalent') => ({\n        pass: !fastDeepEqual(actual, expected),\n        actual,\n        expected,\n        description,\n        operator: \"notEqual\" /* NOT_EQUAL */\n    })),\n    notEquals: aliasMethodHook('notEqual'),\n    notEq: aliasMethodHook('notEqual'),\n    notDeepEqual: aliasMethodHook('notEqual'),\n    is: assertMethodHook((actual, expected, description = 'should be the same') => ({\n        pass: Object.is(actual, expected),\n        actual,\n        expected,\n        description,\n        operator: \"is\" /* IS */\n    })),\n    isNot: assertMethodHook((actual, expected, description = 'should not be the same') => ({\n        pass: !Object.is(actual, expected),\n        actual,\n        expected,\n        description,\n        operator: \"isNot\" /* IS_NOT */\n    })),\n    notSame: aliasMethodHook('isNot'),\n    ok: assertMethodHook((actual, description = 'should be truthy') => ({\n        pass: Boolean(actual),\n        actual,\n        expected: 'truthy value',\n        description,\n        operator: \"ok\" /* OK */\n    })),\n    truthy: aliasMethodHook('ok'),\n    notOk: assertMethodHook((actual, description = 'should be falsy') => ({\n        pass: !Boolean(actual),\n        actual,\n        expected: 'falsy value',\n        description,\n        operator: \"notOk\" /* NOT_OK */\n    })),\n    falsy: aliasMethodHook('notOk'),\n    fail: assertMethodHook((description = 'fail called') => ({\n        pass: false,\n        actual: 'fail called',\n        expected: 'fail not called',\n        description,\n        operator: \"fail\" /* FAIL */\n    })),\n    throws: assertMethodHook((func, expected, description) => {\n        let caught;\n        let pass;\n        let actual;\n        if (typeof expected === 'string') {\n            [expected, description] = [description, expected];\n        }\n        try {\n            func();\n        }\n        catch (err) {\n            caught = { error: err };\n        }\n        pass = caught !== undefined;\n        actual = caught && caught.error;\n        if (expected instanceof RegExp) {\n            pass = expected.test(actual) || expected.test(actual && actual.message);\n            actual = actual && actual.message || actual;\n            expected = String(expected);\n        }\n        else if (typeof expected === 'function' && caught) {\n            pass = actual instanceof expected;\n            actual = actual.constructor;\n        }\n        return {\n            pass,\n            actual,\n            expected,\n            description: description || 'should throw',\n            operator: \"throws\" /* THROWS */\n        };\n    }),\n    doesNotThrow: assertMethodHook((func, expected, description) => {\n        let caught;\n        if (typeof expected === 'string') {\n            [expected, description] = [description, expected];\n        }\n        try {\n            func();\n        }\n        catch (err) {\n            caught = { error: err };\n        }\n        return {\n            pass: caught === undefined,\n            expected: 'no thrown error',\n            actual: caught && caught.error,\n            operator: \"doesNotThrow\" /* DOES_NOT_THROW */,\n            description: description || 'should not throw'\n        };\n    })\n};\nconst assert = (collect, offset, runOnly = false) => {\n    const actualCollect = item => {\n        if (!item.pass) {\n            item.at = getAssertionLocation();\n        }\n        collect(item);\n        return item;\n    };\n    const test = (description, spec, opts) => {\n        const options = Object.assign({}, defaultTestOptions, opts, { offset: offset + 1, runOnly });\n        const subTest = tester(description, spec, options);\n        collect(subTest);\n        return subTest.routine;\n    };\n    const skip = (description, spec, opts) => {\n        return test(description, spec, Object.assign({}, opts, { skip: true }));\n    };\n    // @ts-ignore\n    return {\n        ...unbindAssert(Object.create(AssertPrototype, { collect: { value: actualCollect } })),\n        test(description, spec, opts = {}) {\n            if (runOnly) {\n                return skip(description, spec, opts);\n            }\n            return test(description, spec, opts);\n        },\n        skip(description, spec = noop, opts = {}) {\n            return skip(description, spec, opts);\n        },\n        only(description, spec, opts = {}) {\n            const specFn = runOnly === false ? _ => {\n                throw new Error(`Can not use \"only\" method when not in run only mode`);\n            } : spec;\n            return test(description, specFn, opts);\n        }\n    };\n};\n\nconst map = (fn) => async function* (stream) {\n    for await (const m of stream) {\n        yield fn(m);\n    }\n};\n// ! it mutates the underlying structure yet it is more efficient regarding performances\nconst flatten = map((m) => {\n    m.offset = 0;\n    return m;\n});\nconst isAssertionResult$1 = (result) => {\n    return 'operator' in result;\n};\nconst stringifySymbol = (key, value) => {\n    if (typeof value === 'symbol') {\n        return value.toString();\n    }\n    return value;\n};\n\n// @ts-ignore\nconst flatDiagnostic = ({ pass, description, ...rest }) => rest;\nconst Tap = {\n    print(message, offset = 0) {\n        this.log(message.padStart(message.length + (offset * 4))); // 4 white space used as indent (see tap-parser)\n    },\n    printYAML(obj, offset = 0) {\n        const YAMLOffset = offset + 0.5;\n        this.print('---', YAMLOffset);\n        for (const [prop, value] of Object.entries(obj)) {\n            this.print(`${prop}: ${JSON.stringify(value, stringifySymbol)}`, YAMLOffset + 0.5);\n        }\n        this.print('...', YAMLOffset);\n    },\n    printComment(comment, offset = 0) {\n        this.print(`# ${comment}`, offset);\n    },\n    printBailOut(message) {\n        this.print('Bail out! Unhandled error.');\n    },\n    printTestStart(message) {\n        const { data: { description }, offset } = message;\n        this.printComment(description, offset);\n    },\n    printTestEnd(message) {\n        // do nothing\n    },\n    printAssertion(message) {\n        const { data, offset } = message;\n        const { pass, description } = data;\n        const label = pass === true ? 'ok' : 'not ok';\n        if (isAssertionResult$1(data)) {\n            const id = this.nextId();\n            this.print(`${label} ${id} - ${description}`, offset);\n            if (pass === false) {\n                this.printYAML(flatDiagnostic(data), offset);\n            }\n        }\n        else if (data.skip) {\n            const id = this.nextId();\n            this.print(`${pass ? 'ok' : 'not ok'} ${id} - ${description} # SKIP`, offset);\n        }\n    },\n    printSummary(endMessage) {\n        this.print('', 0);\n        this.printComment(endMessage.data.pass ? 'ok' : 'not ok', 0);\n        this.printComment(`success: ${endMessage.data.successCount}`, 0);\n        this.printComment(`skipped: ${endMessage.data.skipCount}`, 0);\n        this.printComment(`failure: ${endMessage.data.failureCount}`, 0);\n    },\n    async report(stream) {\n        const src = flatten(stream);\n        let lastMessage = null;\n        this.print('TAP version 13');\n        for await (const message of src) {\n            lastMessage = message;\n            switch (message.type) {\n                case \"TEST_START\" /* TEST_START */:\n                    this.printTestStart(message);\n                    break;\n                case \"ASSERTION\" /* ASSERTION */:\n                    this.printAssertion(message);\n                    break;\n                case \"BAIL_OUT\" /* BAIL_OUT */:\n                    this.printBailOut(message);\n                    throw message.data;\n            }\n        }\n        this.print(`1..${lastMessage.data.count}`, 0);\n        this.printSummary(lastMessage);\n    }\n};\nconst factory = (log) => {\n    let i = 0;\n    return Object.create(Tap, {\n        nextId: {\n            enumerable: true,\n            value: () => {\n                return ++i;\n            }\n        },\n        log: { value: log }\n    });\n};\n\nconst indentedDiagnostic = ({ expected, pass, description, actual, operator, at = 'N/A', ...rest }) => ({\n    wanted: expected,\n    found: actual,\n    at,\n    operator,\n    ...rest\n});\nconst id = function* () {\n    let i = 0;\n    while (true) {\n        yield ++i;\n    }\n};\nconst idGen = () => {\n    let stack = [id()];\n    return {\n        [Symbol.iterator]() {\n            return this;\n        },\n        next() {\n            return stack[0].next();\n        },\n        fork() {\n            stack.unshift(id());\n        },\n        merge() {\n            stack.shift();\n        }\n    };\n};\nconst IndentedTap = Object.assign({}, Tap, {\n    printTestStart(message) {\n        const { data: { description }, offset } = message;\n        this.printComment(`Subtest: ${description}`, offset);\n    },\n    printAssertion(message) {\n        const { data, offset } = message;\n        const { pass, description } = data;\n        const label = pass === true ? 'ok' : 'not ok';\n        const id = this.nextId();\n        if (isAssertionResult$1(data)) {\n            this.print(`${label} ${id} - ${description}`, offset);\n            if (pass === false) {\n                this.printYAML(indentedDiagnostic(data), offset);\n            }\n        }\n        else {\n            const comment = data.skip === true ? 'SKIP' : `${data.executionTime}ms`;\n            this.print(`${pass ? 'ok' : 'not ok'} ${id} - ${description} # ${comment}`, message.offset);\n        }\n    },\n    printTestEnd(message) {\n        const length = message.data.length;\n        const { offset } = message;\n        this.print(`1..${length}`, offset);\n    }\n});\nconst factory$1 = (log) => {\n    const id = idGen();\n    return Object.create(IndentedTap, {\n        nextId: {\n            enumerable: true,\n            value: () => {\n                return id.next().value;\n            }\n        },\n        report: {\n            enumerable: true,\n            value: async function (stream) {\n                this.print('TAP version 13');\n                let lastMessage = null;\n                for await (const message of stream) {\n                    lastMessage = message;\n                    switch (message.type) {\n                        case \"TEST_START\" /* TEST_START */:\n                            id.fork();\n                            this.printTestStart(message);\n                            break;\n                        case \"ASSERTION\" /* ASSERTION */:\n                            this.printAssertion(message);\n                            break;\n                        case \"TEST_END\" /* TEST_END */:\n                            id.merge();\n                            this.printTestEnd(message);\n                            break;\n                        case \"BAIL_OUT\" /* BAIL_OUT */:\n                            this.printBailOut(message);\n                            throw message.data;\n                    }\n                }\n                this.printSummary(lastMessage);\n            }\n        },\n        log: { value: log }\n    });\n};\n\nconst report = (factory) => (logger = console) => {\n    const log = logger.log.bind(logger);\n    return async (stream) => factory(log).report(stream);\n};\nconst tapReporter = report(factory);\nconst indentedTapReporter = report(factory$1);\n\n//@ts-ignore\nconst mochaTapLike = indentedTapReporter();\n//@ts-ignore\nconst tapeTapLike = tapReporter();\n\nconst harnessFactory = ({ runOnly = false, indent = false } = {\n    runOnly: false,\n    indent: false\n}) => {\n    const tests = [];\n    const rootOffset = 0;\n    const collect = item => tests.push(item);\n    const api = assert(collect, rootOffset, runOnly);\n    let error = null;\n    const factory = testerLikeProvider(Object.assign(api, TesterPrototype, {\n        report: async function (reporter) {\n            const rep = reporter || (indent ? mochaTapLike : tapeTapLike);\n            return rep(this);\n        }\n    }));\n    return Object.defineProperties(factory(tests, Promise.resolve(), rootOffset), {\n        error: {\n            get() {\n                return error;\n            },\n            set(val) {\n                error = val;\n            }\n        }\n    });\n};\n\nconst findConfigurationFlag = (name) => {\n    if (typeof process !== 'undefined') {\n        return process.env[name] === 'true';\n        // @ts-ignore\n    }\n    else if (typeof Deno !== 'undefined') {\n        // @ts-ignore\n        return Deno.env.get(name) === 'true';\n        // @ts-ignore\n    }\n    else if (typeof window !== 'undefined') {\n        // @ts-ignore\n        return Boolean(window[name]);\n    }\n    return false;\n};\nconst defaultTestHarness = harnessFactory({\n    runOnly: findConfigurationFlag('RUN_ONLY')\n});\nlet autoStart = true;\nlet indent = findConfigurationFlag('INDENT');\nconst rootTest = defaultTestHarness.test.bind(defaultTestHarness);\nrootTest.indent = () => {\n    console.warn('indent function is deprecated, use \"INDENT\" configuration flag instead');\n    indent = true;\n};\nconst test = rootTest;\nconst skip = defaultTestHarness.skip.bind(defaultTestHarness);\nconst only = defaultTestHarness.only.bind(defaultTestHarness);\nrootTest.skip = skip;\nconst equal = defaultTestHarness.equal.bind(defaultTestHarness);\nconst equals = equal;\nconst eq = equal;\nconst deepEqual = equal;\nconst notEqual = defaultTestHarness.notEqual.bind(defaultTestHarness);\nconst notEquals = notEqual;\nconst notEq = notEqual;\nconst notDeepEqual = notEqual;\nconst is = defaultTestHarness.is.bind(defaultTestHarness);\nconst same = is;\nconst isNot = defaultTestHarness.isNot.bind(defaultTestHarness);\nconst notSame = isNot;\nconst ok = defaultTestHarness.ok.bind(defaultTestHarness);\nconst truthy = ok;\nconst notOk = defaultTestHarness.notOk.bind(defaultTestHarness);\nconst falsy = notOk;\nconst fail = defaultTestHarness.fail.bind(defaultTestHarness);\nconst throws = defaultTestHarness.throws.bind(defaultTestHarness);\nconst doesNotThrow = defaultTestHarness.doesNotThrow.bind(defaultTestHarness);\nconst createHarness = (opts = {}) => {\n    autoStart = false;\n    return harnessFactory(opts);\n};\nconst start = () => {\n    if (autoStart) {\n        defaultTestHarness.report(indent ? mochaTapLike : tapeTapLike);\n    }\n};\n// on next tick start reporting\n// @ts-ignore\nif (typeof window === 'undefined') {\n    setTimeout(start, 0);\n}\nelse {\n    // @ts-ignore\n    window.addEventListener('load', start);\n}\n\nexports.AssertPrototype = AssertPrototype;\nexports.createHarness = createHarness;\nexports.deepEqual = deepEqual;\nexports.doesNotThrow = doesNotThrow;\nexports.eq = eq;\nexports.equal = equal;\nexports.equals = equals;\nexports.fail = fail;\nexports.falsy = falsy;\nexports.is = is;\nexports.isNot = isNot;\nexports.mochaTapLike = mochaTapLike;\nexports.notDeepEqual = notDeepEqual;\nexports.notEq = notEq;\nexports.notEqual = notEqual;\nexports.notEquals = notEquals;\nexports.notOk = notOk;\nexports.notSame = notSame;\nexports.ok = ok;\nexports.only = only;\nexports.same = same;\nexports.skip = skip;\nexports.tapeTapLike = tapeTapLike;\nexports.test = test;\nexports.throws = throws;\nexports.truthy = truthy;\n", "import * as zora from 'zora'\r\nexport { Assert } from 'zora'\r\n\r\nlet harness = zora.createHarness()\r\nif (typeof window === 'undefined')\r\n    setTimeout(runTests, 0)\r\n\r\nexport function getHarness(): zora.TestHarness{\r\n    return harness\r\n}\r\n\r\nasync function runTests() {\r\n    try {\r\n        await harness.report(zora.mochaTapLike)\r\n    }\r\n    catch(e) {\r\n        harness.pass = false\r\n        if (e instanceof Error) {\r\n            console.error(e.name + \" exception thrown: \" + e.message)\r\n            console.error(e.stack)\r\n        }\r\n    }\r\n    if (harness.pass)\r\n        console.log('Tests PASSED')\r\n    else\r\n        console.log('Tests FAILED')\r\n    process.exit(harness.pass ? 0 : 1)\r\n}\r\n\r\nexport function test(description: string, spec: zora.SpecFunction, \r\n    options?: object): Promise<zora.TestResult> {\r\n    return harness.test(description, spec, options)\r\n}", "import * as tr from './test-reporter'\r\nimport * as tester from './tester'\r\n\r\nexport class TestRunner extends HTMLElement {\r\n    private body: HTMLElement\r\n    private connected: boolean\r\n    private styles = /*css*/`\r\n        .test-runner {\r\n            font-family: var(--sans-font);\r\n            font-size: 1rem;\r\n            overflow: auto;\r\n        }    \r\n        .test-runner .summary {\r\n            font-weight: bolder;\r\n        }\r\n        .test-runner .summary .count {\r\n            margin-left: 12px;\r\n        }\r\n        .test-runner pre {\r\n            background-color: #fff0f0;\r\n        }`\r\n\r\n    constructor() {\r\n        super();\r\n        let shadow = this.attachShadow({ mode: 'open' })\r\n        let sheet = new CSSStyleSheet()\r\n        sheet.replaceSync(this.styles)\r\n        shadow.adoptedStyleSheets = [ sheet ]\r\n        this.body = this.elem('div', \"test-runner\")\r\n        shadow.appendChild(this.body)\r\n        this.connected = false\r\n    }\r\n\r\n    connectedCallback() {\r\n        if (this.connected)\r\n            return\r\n        this.connected = true\r\n        let name = this.getAttribute(\"name\")\r\n        this.runTests(name)\r\n    }\r\n    \r\n    runTests(name: string) {\r\n        tester.getHarness().report(tr.createReporter(name, status => {\r\n            while (this.body.firstChild)\r\n                this.body.firstChild.remove()\r\n            this.body.appendChild(this.testStatus(status))\r\n        }))\r\n    }\r\n    \r\n    elem<K extends keyof HTMLElementTagNameMap>(tagName: K, cls?: string,\r\n        text?: string): HTMLElement {\r\n        let res = document.createElement(tagName)\r\n        if (cls)\r\n            res.classList.add(cls)\r\n        if (text)\r\n            res.innerText = text\r\n        return res\r\n    }\r\n    \r\n    statusIcon(assertion: tr.Assertion): string {\r\n        return assertion.pass ? \"\u2705\" : \"\u274C\"\r\n    }\r\n\r\n    testStyle(test: tr.Test) {\r\n        return test.pass ? '#f8fff8' : '#fff8f8'\r\n    }\r\n\r\n    testStatus(rootTest: tr.Test): HTMLElement {\r\n        let vis = this.elem(\"div\",\"test-visualizer\")\r\n        vis.style.backgroundColor = this.testStyle(rootTest)\r\n        let sum = this.elem(\"div\", \"summary\", `${this.statusIcon(rootTest)} ${\r\n            rootTest.name}`)\r\n        sum.appendChild(this.elem(\"span\", \"count\", `Pass: ${rootTest.passes}`))\r\n        sum.appendChild(this.elem(\"span\", \"count\", `Fail: ${rootTest.fails}`))\r\n        vis.appendChild(sum)\r\n        vis.appendChild(this.testList(rootTest.tests))\r\n        return vis\r\n    }\r\n\r\n    testList(tests: tr.Test[]): HTMLElement {\r\n        let lst = this.elem(\"ol\", \"test-list\")\r\n        for (let i = 0; i < tests.length; i++)\r\n            lst.appendChild(this.test(tests[i]))\r\n        return lst\r\n    }\r\n\r\n    assertion(assertion: tr.Assertion): HTMLElement {\r\n        return this.elem(\"li\", undefined, `${this.statusIcon(assertion)} ${\r\n            assertion.name}`)\r\n    }\r\n\r\n    assertions(assertions: tr.Assertion[]): HTMLElement {\r\n        let det = this.elem(\"details\")\r\n        det.appendChild(\r\n            this.elem(\"summary\", undefined, `${assertions.length} assertions`))\r\n        let ol = this.elem(\"ol\")\r\n        for (let i = 0; i < assertions.length; i++) \r\n            ol.appendChild(this.assertion(assertions[i]))\r\n        det.appendChild(ol)\r\n        return det\r\n    }\r\n\r\n    test(test: tr.Test): HTMLElement {\r\n        if (test.error)\r\n            return this.bailedOutTest(test)\r\n        let li = this.elem(\"li\", undefined, \r\n            `${this.statusIcon(test)} ${test.name} in ${test.duration}ms`)\r\n        if (test.assertions)\r\n            li.appendChild(this.assertions(test.assertions))\r\n        if (test.tests)\r\n            li.appendChild(this.testList(test.tests))\r\n        return li\r\n    }\r\n\r\n    bailedOutTest(test: tr.Test): HTMLElement {\r\n        let res = this.elem(\"li\")\r\n        res.innerHTML =\r\n            `${this.statusIcon(test)} ${test.name} threw <b>${\r\n                test.error.name}</b> exception:\r\n            <br/><b>${test.error.message}</b>\r\n            <pre>${test.error.stack}</pre>`\r\n        return res\r\n    }\r\n}\r\n\r\ncustomElements.define('test-runner', TestRunner)", "/**\r\n * # Reference Cells\r\n * \r\n * `Ref<T>` class provides a simple reference cell, which can be used\r\n * as a surrogate for a parser that is defined later on. We can define \r\n * a _reference_ to parser, but we don't have to give the target right\r\n * away. When composing parsers we can use the `forwardRef` function\r\n * to pass a reference to any combinator expecting a `Parser<T, S>`.\r\n * Of course, we have to eventually assign a real parser as the target\r\n * of the reference before running the parser.     \r\n */\r\nexport class Ref<T> {\r\n    private _target: T | null = null\r\n    /**\r\n     * Constructing a reference. The target value is optional.\r\n     */\r\n    constructor(value?: T) {\r\n        if (value)\r\n            this._target = value\r\n    }\r\n    /**\r\n     * Get the target of the reference. If no target is set, a \r\n     * `ReferenceError` is thrown.\r\n     */\r\n    get target(): T {\r\n        if (this._target)\r\n            return this._target\r\n        throw ReferenceError(\"Target not set.\")\r\n    }\r\n    /**\r\n     * Set the target.\r\n     */\r\n    set target(value: T) {\r\n        this._target = value\r\n    }\r\n}", "/**\r\n * # Error Reporting\r\n *\r\n * We define a custom Error class for parsing errors.\r\n * \r\n * The possible sources of errors are defined in the enumeration below.\r\n */\r\nexport enum ErrorSource {\r\n    Input = \"Input\",\r\n    Lexer = \"Lexer\",\r\n    Parser = \"Parsing\"\r\n}\r\n/**\r\n * The ParseError class contains information about the parsing error in\r\n * an easily accessible form.\r\n */\r\nexport class ParseError extends Error {\r\n    constructor(\r\n        /**\r\n         * The source of the error.\r\n         */\r\n        readonly source: ErrorSource,\r\n        /**\r\n         * The position where the error happened.\r\n         */\r\n        readonly position: number,\r\n        /**\r\n         * Input found at `position`.\r\n         */\r\n        readonly found: string, \r\n        /**\r\n         * Input expected at `position`. There can be multiple terminals.\r\n         */\r\n        readonly expected: string[] = []) {\r\n        /**\r\n         * Constructor formats the error message using the parameters provided.\r\n         */\r\n        super(`${source} error at position ${position + 1}.\\n` +\r\n            `\\tFound: \"${found}\"\\n` +\r\n            `\\tExpected: ${expected.map(s => `\"${s}\"`).join(\", \")}`);\r\n    }\r\n}", "/**\r\n * # Parser Input\r\n * \r\n * Parsers input is a stream of data of type `S`. The input is represented by \r\n * an abstract interface which provides the `next()` method to iterate through \r\n * the stream. \r\n */\r\nexport interface ParserInput<S> {\r\n    /**\r\n     * Position in the input stream is represented by a number. The number has \r\n     * to increase as input is consumed, but not necessarily linearly. \r\n     * Backtracking is done by setting the `position` explicitly.\r\n     */\r\n    position: number\r\n    /**\r\n     * Return the next item in the stream. Note that there is no explicit\r\n     * flag that tells when we have gone past the last item. Instead, the input\r\n     * implementations add a special `EOF` item at the end. Parsers should \r\n     * recognize it and terminate before the stream is exhausted.\r\n     */\r\n    next(): S\r\n    /**\r\n     * The latest item read from the stream is cached for efficiency.\r\n     */\r\n    readonly current: S\r\n    /**\r\n     * User-managed state can be carried along the parsing. State is needed \r\n     * especially with context-sensitive grammars. The input stores a reference \r\n     * to `any` data that can be modified by special combinators: `getState`, \r\n     * `setState`, `mutateState`, etc.\r\n     */\r\n    state: any\r\n}\r\n/**\r\n * ## Array Input\r\n * \r\n * Arrays are the most common input data type. Therefore we provide a generic\r\n * implementation for them. Array items may have any type `S`. The class is \r\n * not exported outside the module. Users can create it using the `arrayInput` \r\n * function.\r\n */\r\nclass ArrayInput<S> implements ParserInput<S> {\r\n    /**\r\n     * Inherited properties.\r\n     */\r\n    position: number\r\n    current: S\r\n    state: any\r\n    eof: S\r\n    /**\r\n     * Wrapped array.\r\n     */\r\n    private array: S[];\r\n    /**\r\n     * We set the position initially to -1 to indicate that no input has been\r\n     * consumed. The current item is `undefined`.\r\n     */\r\n    constructor(array: S[], eof: S) {\r\n        this.array = array\r\n        this.position = -1\r\n        this.current = <S><unknown>undefined\r\n        this.eof = eof\r\n    }\r\n    /**\r\n     * Return the next item in the array. Update `position` and\r\n     * `current` fields. \r\n     */\r\n    next(): S {\r\n        let pos = this.position + 1\r\n        if (pos >= this.array.length)\r\n            return this.eof\r\n        this.position = pos\r\n        this.current = this.array[pos]\r\n        return this.current\r\n    }\r\n}\r\n\r\n/**\r\n * ## Exported Functions\r\n * \r\n * Create a ParserInput wrapper for an array.\r\n */\r\nexport function arrayInput<S>(array: S[], eof: S): ParserInput<S> {\r\n    return new ArrayInput<S>(array, eof);\r\n}", "/**\r\n * # Parser Result\r\n * \r\n * The result of a parser function is a discriminated union that\r\n * represents either success or failure. In both cases need the \r\n * `position` field to indicate where in the input stream we are. \r\n * This is field is defined in the base interface.\r\n */\r\ninterface Position {\r\n    position: number\r\n}\r\n/**\r\n * When parsing succeeds we return the the `Ok<T>` object. It contains\r\n * the `result` returned by the parser. Type parameter `T` indicates \r\n * its type. \r\n */\r\ninterface Ok<T> extends Position {\r\n    kind: \"ok\"\r\n    result: T\r\n}\r\n/**\r\n * When parsing fails we return the `Fail` object. It does not have a \r\n * result, but information about the input `found` and input `expected`. \r\n */\r\ninterface Fail extends Position {\r\n    kind: \"fail\"\r\n    found: string\r\n    expected: string[]\r\n}\r\n/**\r\n * The actual result type is a discriminated union of the `Ok<T>` and \r\n * `Fail` objects.\r\n */\r\nexport type ParseResult<T> = Ok<T> | Fail\r\n\r\n/**\r\n * ## Helper Functions\r\n * \r\n * The `joinExpected` function concatenates the list of expected\r\n * inputs from the `other` failed parse result into the `expected` \r\n * array of the first one.  \r\n */\r\nexport function joinExpected(result: Fail, other: Fail) {\r\n    if (other.expected.length > 0)\r\n        result.expected = result.expected.concat(other.expected)\r\n}\r\n/**\r\n * This function formats the array of expected inputs as a string for\r\n * printing.\r\n */\r\nexport function expectedAsCsv(result: Fail): string {\r\n        return result.expected.map(s => `\"${s}\"`).join(\", \")\r\n}\r\n\r\n/**\r\n * ## Constructor Functions\r\n * \r\n * The following function is used to construct an `Ok<T>` result. \r\n */\r\nexport function succeeded<T>(pos: number, res: T): ParseResult<T> {\r\n    return {\r\n        kind: \"ok\",\r\n        position: pos, \r\n        result: res\r\n    }\r\n}\r\n/**\r\n * The next one constructs a `Fail` result.\r\n */\r\nexport function failed<T>(pos: number, fnd: string, exp: string[] = []): ParseResult<T> {\r\n    return {\r\n        kind: \"fail\",\r\n        position: pos, \r\n        found: fnd, \r\n        expected: exp\r\n    }\r\n}", "/**\r\n * # Utility Functions\r\n * \r\n * This module contains general functions used elsewhere in the library.\r\n * \r\n * The first function initializes an object from an array of `[string, any]`\r\n * pairs. It is used to populate an object dynamically.\r\n */\r\nexport function initObject(members: [string, any][]): any {\r\n    let res: any = {}\r\n    for (let i = 0; i < members.length; i++) {\r\n        let [m, v] = members[i];\r\n        res[m] = v\r\n    }\r\n    return res\r\n}\r\n/**\r\n * The `escapeWhitespace` function helps printing strings containing whitespace\r\n * characters. It replaces them with their escape codes.\r\n */\r\nexport function escapeWhitespace(text: string): string {\r\n    return text.replace(\"\\n\", \"\\\\n\").replace(\"\\r\", \"\\\\r\").replace(\"\\t\", \"\\\\t\");\r\n}", "/**\r\n * # Lexical Analyzer\r\n * \r\n * [Lexical analyzer][lexer], also known as lexer or scanner, is a program that \r\n * converts sequence of characters into a sequence of _tokens_. It simplifies \r\n * and speeds up parsing because the parser does not have to recognize low level \r\n * patterns such as whitespace, keywords, identifiers, or numbers. Instead, the \r\n * parser can focus on the high level grammar and structure of the input.\r\n * \r\n * A lexer is usually implemented using a [deterministic finite automaton][dfa],\r\n * and the DFA is typically represented by a regular expression. This is a \r\n * natural choice for us too, as Javascript natively supports them.\r\n * \r\n * [lexer]: https://en.wikipedia.org/wiki/Lexical_analysis\r\n * [dfa]: https://en.wikipedia.org/wiki/Deterministic_finite_automaton \r\n */\r\nimport * as inp from \"./input\"\r\nimport * as utils from \"./utils\"\r\nimport * as err from \"./error\"\r\n\r\n/**\r\n * ## Recognizing a Token\r\n * \r\n * The mapping from regular expressions to tokens is defined using the \r\n * `TokenMatcher<S>` interface. A token can be of any type `S`, although usually \r\n * an enumeration is used.\r\n */\r\ninterface TokenMatcher<S> {\r\n    regex: RegExp\r\n    token: S\r\n}\r\n/**\r\n * ## Representing a Token\r\n * \r\n * When a token is recognized it is wrapped in a `Token<S>` object. This \r\n * contains also the recognized string for error reporting and diagnostics.\r\n */\r\nexport class Token<S> {\r\n    constructor(readonly token: S, readonly text: string) { }\r\n    /**\r\n     * We override the `toString` function so we can output a token \r\n     * to screen.\r\n     */\r\n    toString() {\r\n        return this.text ? utils.escapeWhitespace(this.text) : this.token\r\n    }\r\n}\r\n/**\r\n * ## Lexer\r\n * \r\n * The lexer itself is a simple class that contains all the TokenMatchers and\r\n * recognizes the next token in a string.\r\n */\r\nexport class Lexer<S> {\r\n    private matchers: TokenMatcher<S>[]\r\n    /**\r\n     * The constructor adds two flags to the regular expressions given as \r\n     * arguments. The `y` flag makes the search sticky so that it scans the\r\n     * input string from the position indicated by the `lastIndex` property.\r\n     * The `u` flag makes the search support unicode characters.\r\n     */\r\n    constructor(...tokens: [RegExp, S][]) {\r\n        this.matchers = tokens.map(t => ({\r\n            regex: new RegExp(t[0], \"yu\"),\r\n            token: t[1]\r\n        }))\r\n    }\r\n    /**\r\n     * We check matchers one-by-one in the order they were given to\r\n     * recognize the token in the given position. If none of the matchers\r\n     * succeed, we return `null`.\r\n     */\r\n    matchToken(input: string, pos: number): Token<S> | null {\r\n        for (let i = 0; i < this.matchers.length; i++) {\r\n            let matcher = this.matchers[i]\r\n            matcher.regex.lastIndex = pos\r\n            let match = matcher.regex.exec(input)\r\n            if (match != null)\r\n                return new Token<S>(matcher.token, match[0])\r\n        }\r\n        return null\r\n    }\r\n}\r\n/**\r\n * ## Lexer as Input\r\n * \r\n * We can integrate lexing directly into the parsing process by implementing \r\n * the `ParserInput` interface for any token. We don't expose `LexerInput` \r\n * class outside the module. It can be created with the `lexerInput` function.\r\n */\r\nclass LexerInput<S> implements inp.ParserInput<Token<S>> {\r\n    /**\r\n     * We define the fields of the `ParserInput` interface.\r\n     */\r\n    position: number\r\n    current: Token<S>\r\n    state: any\r\n    /**\r\n     * We also need to store the input string and the lexer used. These we\r\n     * get as an argument.\r\n     */\r\n    private input: string\r\n    private lexer: Lexer<S>\r\n    /**\r\n     * To avoid recognizing the same token multiple times as the parser\r\n     * backtracks, we store all the tokens we have matched so far in \r\n     * an array.\r\n     */\r\n    private tokens: Token<S>[]\r\n    /**\r\n     * We store the result designating end of the input.\r\n     */\r\n    private eof: Token<S>\r\n    /**\r\n     * Create an input stream for given string and lexer. Initialize the\r\n     * instance variables.\r\n     */\r\n    constructor(input: string, lexer: Lexer<S>, eof: Token<S>) {\r\n        this.input = input\r\n        this.lexer = lexer\r\n        this.tokens = new Array<Token<S>>(input.length)\r\n        this.position = -1\r\n        this.eof = eof\r\n        this.current = this.eof\r\n    }\r\n    /**\r\n     * The iterator implementation is fairly straightforward. We need to make \r\n     * sure that the state variables `position` and `current` are kept in sync \r\n     * while we advance in the input string. We must also do a lookup in the \r\n     * cach\u00E9 before calling the lexer to recognize the token. If the lexer finds \r\n     * a match, we update the cach\u00E9. If the lexer cannot recognize the next \r\n     * token, we throw a `ParseError`.\r\n     */\r\n    next(): Token<S> {\r\n        let pos = this.position\r\n        pos += this.tokens[pos] ? this.tokens[pos].text.length : 1\r\n        if (pos >= this.input.length)\r\n            return this.eof\r\n        this.position = pos\r\n        let match = this.tokens[pos] || this.lexer.matchToken(this.input, pos)\r\n        if (!match)\r\n            throw new err.ParseError(err.ErrorSource.Lexer, pos,\r\n                this.input.substr(pos, 10) + \"...\", [\"<valid token>\"])\r\n        this.tokens[pos] = match\r\n        this.current = match\r\n        return match\r\n    }\r\n}\r\n/**\r\n * Create an input stream for given `text` string using the given `lexer`.\r\n */\r\nexport function lexerInput<S>(text: string, lexer: Lexer<S>, eof: Token<S>):\r\n    inp.ParserInput<Token<S>> {\r\n    return new LexerInput<S>(text, lexer, eof)\r\n}", "/**\r\n * # Parser Monad and Basic Combinators\r\n * \r\n * This module defines the basic types and combinators for the parser monad. \r\n * To learn about monadic parsers refer to the list of literature in the \r\n * [Wikipedia page](https://en.wikipedia.org/wiki/Parser_combinator).\r\n */\r\nimport * as inp from \"./input\"\r\nimport * as pr from \"./result\"\r\nimport * as lex from \"./lexer\"\r\nimport * as ref from \"./ref\"\r\nimport * as utils from \"./utils\"\r\nimport * as err from \"./error\"\r\n/**\r\n * \r\n * ## Parsing Function\r\n * \r\n * `Parse<T, S>` type represents a parsing function whics takes a \r\n * `ParserInput<S>` stream as an argument and returns a `ParseResult<T>` object. \r\n * The type of value to be parsed and the type of terminals in the input stream \r\n * are given as type parameters `T` and `S`.\r\n */\r\nexport type Parse<T, S> = (input: inp.ParserInput<S>) => pr.ParseResult<T>\r\n/**\r\n * ## Parser Class\r\n * \r\n * The central type in the Parzec library is the `Parser<T, S>` class. It wraps\r\n * a parsing function and provides the core combinators to combine parsers in \r\n * various ways.\r\n */\r\nexport class Parser<T, S> {\r\n    /**\r\n     * Constructor wraps the parsing function.\r\n     */\r\n    constructor(readonly parse: Parse<T, S>) { }\r\n    /**\r\n     * The monadic bind that corresponds to Haskell's `>>=` operator. Runs \r\n     * `this` parser, and if it succeeds, feeds its result to the `binder` \r\n     * function that returns a new Parser. This is the basic operation that is \r\n     * used in other combinators to glue parsers together.\r\n     */\r\n    bind<U>(binder: (value: T) => Parser<U, S>): Parser<U, S> {\r\n        return new Parser(input => {\r\n            let pos = input.position\r\n            let res1 = this.parse(input)\r\n            if (res1.kind == \"ok\") {\r\n                let res2 = binder(res1.result).parse(input)\r\n                if (res2.kind == \"fail\" && pos !== input.position)\r\n                    input.position = pos // backtrack\r\n                return res2\r\n            }\r\n            return res1\r\n        })\r\n    }\r\n    /**\r\n     * The sequence operator. Runs `this` parser, and if it succeeds, runs the \r\n     * `other` parser ignoring the result of `this` one.\r\n     */\r\n    seq<U>(other: Parser<U, S>): Parser<U, S> {\r\n        return this.bind(_ => other)\r\n    }\r\n    /**\r\n     * Map result of the parser to another value. This function implements a \r\n     * [_functor_](https://en.wikipedia.org/wiki/Functor) which is a superclass \r\n     * of monad.\r\n     */\r\n    map<U>(mapper: (value: T) => U): Parser<U, S> {\r\n        return this.bind(x => mret(mapper(x))) as Parser<U, S>\r\n    }\r\n    /**\r\n     * ## Conditional Parsing\r\n     * \r\n     * The ordered choice operation. Creates a parser that first runs `this` \r\n     * parser, and if that fails, runs the `other` one. Corresponds to the `/` \r\n     * operation in [PEG grammars](https://en.wikipedia.org/wiki/Parsing_expression_grammar).\r\n     */\r\n    or<U>(other: Parser<U, S>): Parser<T | U, S> {\r\n        return new Parser(input => {\r\n            let pos = input.position;\r\n            let res1 = this.parse(input) as pr.ParseResult<T | U>\r\n            if (res1.kind == \"ok\")\r\n                return res1\r\n            if (res1.position > pos)\r\n                return res1\r\n            let res2 = other.parse(input)\r\n            if (res2.kind == \"ok\")\r\n                return res2\r\n            pr.joinExpected(res2, res1)\r\n            return res2\r\n        })\r\n    }\r\n    /**\r\n     * Parse an optional value, if the parser fails then the default value is \r\n     * returned.\r\n     */\r\n    optional(defaultValue: T): Parser<T, S> {\r\n        return this.or(mret(defaultValue))\r\n    }\r\n    /**\r\n     * Parse an optional reference value, if the parser fails then null is \r\n     * returned.\r\n     */\r\n    optionalRef(): Parser<T | null, S> {\r\n        return this.or(mret(null))\r\n    }\r\n    /**\r\n     * Runs parser and checks that it succeeds and that the result it returns\r\n     * satisfies a given predicate.\r\n     */\r\n    where(predicate: (value: T) => boolean): Parser<T, S> {\r\n        return this.bind(x =>\r\n            predicate(x) ? mret(x) : fail(`${x}`, \"predicate\"))\r\n    }\r\n    /**\r\n     * ## Parsing Multiple Items\r\n     * \r\n     * Creates a parser that will run `this` parser zero or more times. The \r\n     * results of the input parser are added to an array.\r\n     */\r\n    zeroOrMore(): Parser<T[], S> {\r\n        return new Parser(input => {\r\n            let list: T[] = []\r\n            while (true) {\r\n                let pos = input.position\r\n                let res = this.parse(input)\r\n                if (res.kind == \"fail\")\r\n                    return res.position > pos ?\r\n                        res : pr.succeeded(res.position, list)\r\n                list.push(res.result)\r\n            }\r\n        })\r\n    }\r\n    /**\r\n     * Creates a parser that runs `this` parser one or more times.\r\n     */\r\n    oneOrMore(): Parser<T[], S> {\r\n        return new Parser(input => {\r\n            let res = this.parse(input)\r\n            if (res.kind == \"fail\")\r\n                return res\r\n            let list = [res.result]\r\n            while (true) {\r\n                let pos = input.position\r\n                res = this.parse(input)\r\n                if (res.kind == \"fail\")\r\n                    return res.position > pos ? \r\n                        res : pr.succeeded(res.position, list)\r\n                list.push(res.result)\r\n            }\r\n        })\r\n    }\r\n    /**\r\n     * Parsing succeeds if `this` parser succeeds from `min` to `max` times.\r\n     */\r\n    occurrences(min: number, max: number): Parser<T[], S> {\r\n        return this.zeroOrMore().bind(list => {\r\n            let cnt = list.length\r\n            return cnt >= min && cnt <= max ?\r\n                mret(list) :\r\n                fail(`${cnt} occurrences`, `${min}-${max} occurrences`)\r\n        })\r\n    }\r\n    /**\r\n     * ## Lookahead & Backtracking\r\n     * \r\n     * Check that `this` parser succeeds without consuming any input. \r\n     * Corresponds to the `&` operator in PEG grammars.\r\n     */\r\n    and(): Parser<T, S> {\r\n        return new Parser(input => {\r\n            let pos = input.position\r\n            let res = this.parse(input)\r\n            input.position = pos\r\n            return res\r\n        })\r\n    }\r\n    /**\r\n     * Check that `this` parser fails without consuming any input. Corresponds \r\n     * to the `!` operator in PEG grammars.\r\n     */\r\n    not(): Parser<T, S> {\r\n        return new Parser(input => {\r\n            let pos = input.position\r\n            let res = this.parse(input)\r\n            input.position = pos\r\n            if (res.kind == \"ok\") {\r\n                let found = `${res.result}`\r\n                return pr.failed(res.position, found, [\"not \" + found])\r\n            }\r\n            return pr.succeeded(res.position, <T><unknown>undefined)\r\n        })\r\n    }\r\n    /**\r\n     * Bactrack to the current input position, even if the given parser fails\r\n     * and has advanced the input position. Normally we do not bactrack when a\r\n     * parser has advanced in the input. Doing so would loose the position where\r\n     * the parsing failed and make error messages more vague. Sometimes, \r\n     * however, we need more input lookahead. In these cases, you can use the \r\n     * backtrack operation to retry the next rule.\r\n     */\r\n    backtrack(): Parser<T, S> {\r\n        return new Parser(input => {\r\n            let pos = input.position\r\n            let res = this.parse(input)\r\n            if (res.kind == \"fail\" && res.position > pos)\r\n                res.position = pos\r\n            return res\r\n        })\r\n    }\r\n    /**\r\n     * ## Error Reporting and Debugging\r\n     * \r\n     * Give a human-readable name to the \"thing\" that the given parser matches. \r\n     * This name is reported as expected value, if the parsing fails.\r\n     */\r\n    expect(expected: string): Parser<T, S> {\r\n        if (!parserDebug.errorMessages)\r\n            return this\r\n        let resParser = new Parser((input: inp.ParserInput<S>) => {\r\n            let res = this.parse(input)\r\n            if (res.kind == \"fail\")\r\n                res.expected.push(expected)\r\n            return res\r\n        })\r\n        return parserDebug.debugging ? resParser.trace(expected) : resParser\r\n    }\r\n    /**\r\n     * Attach debugging information to a parser. To trace which rules are \r\n     * triggered during parsing, you can add debugging info to any parser. This \r\n     * combinator produces a hierarchical tree of parser invocations which \r\n     * includes information about input symbol and its position. If debugging \r\n     * is disabled, this function does nothing.\r\n     */\r\n    trace(ruleName: string): Parser<T, S> {\r\n        if (!parserDebug.debugging)\r\n            return this;\r\n        return new Parser(input => {\r\n            parserDebug.write(`${ruleName} called with input '${input.current}'.`)\r\n            parserDebug.indent()\r\n            let res = this.parse(input)\r\n            parserDebug.rulesEvaluated++\r\n            parserDebug.unindent()\r\n            parserDebug.write((res.kind == \"ok\" ?\r\n                `${ruleName} SUCCEEDED with value '${\r\n                    utils.escapeWhitespace(`${res.result}`)}'` :\r\n                `${ruleName} FAILED with value '${\r\n                    utils.escapeWhitespace(`${res.found}`)\r\n                    }'. Expected values: ${pr.expectedAsCsv(res)}`) +\r\n                ` at position ${res.position}`)\r\n            return res\r\n        })\r\n    }\r\n}\r\n/**\r\n * ## Debugging Options\r\n * \r\n * The following object contains the global settings that control the parser \r\n * reporting. \r\n */\r\nexport const parserDebug = {\r\n    /** \r\n     * When `debugging` flag is on parsers count the number of rules evaluated \r\n     * during their operation. The `rulesEvaluated` field contains this \r\n     * information. \r\n     */\r\n    debugging: false,\r\n    rulesEvaluated: 0,\r\n    /**\r\n     * If errorMessages flag is turned off, the expected information will not be \r\n     * available in parse errors. This speeds up the parsing nominally.\r\n     */\r\n    errorMessages: true,\r\n    /**\r\n     * The current indentation level in the debugging output is stored in this \r\n     * field.\r\n     */\r\n    indentation: 0,\r\n    /**\r\n     * Indent the debug output by one level.\r\n     */\r\n    indent() {\r\n        this.indentation++\r\n    },\r\n    /**\r\n     * Unndent the debug output by one level.\r\n     */\r\n    unindent() {\r\n        this.indentation--\r\n    },\r\n    /**\r\n     * Write a string to the debug output.\r\n     */\r\n    write(text: string) {\r\n        let tabs = \"  \".repeat(this.indentation)\r\n        console.log(tabs + text)\r\n    }\r\n}\r\n\r\n/**\r\n * ## Main Functions\r\n * \r\n * Attempt to parse an input with a given parser. Takes a Parser and a \r\n * ParserInput as arguments and return a ParseResult.\r\n */\r\nexport function tryParse<T, S>(parser: Parser<T, S>, input: inp.ParserInput<S>):\r\n    pr.ParseResult<T> {\r\n    parserDebug.rulesEvaluated = 0\r\n    let res = parser.parse(input)\r\n    if (parserDebug.debugging)\r\n        console.info(\"Number of rules evaluated: \" + parserDebug.rulesEvaluated)\r\n    return res\r\n}\r\n/**\r\n * Parse an input using a given parser, or throw an exception, if parsing fails.\r\n */\r\nexport function parse<T, S>(parser: Parser<T, S>, input: inp.ParserInput<S>): T {\r\n    var res = tryParse(parser, input)\r\n    if (res.kind == \"fail\")\r\n        throw new err.ParseError(err.ErrorSource.Parser, res.position, \r\n            res.found, res.expected)\r\n    return res.result\r\n}\r\n/**\r\n * ## Monadic Returns\r\n * \r\n * Create a parser that always succeeds and returns the given value without \r\n * consuming any input. This function implements the monadic return, that is, \r\n * it lifts a value to the parser monad.\r\n */\r\nexport function mret<T, S>(value: T): Parser<T, S> {\r\n    return new Parser(input => pr.succeeded(input.position, value))\r\n}\r\n/**\r\n * Create a parser that always fails. The terminals reported as\r\n * found or expected are given as an argument.\r\n */\r\nexport function fail<T, S>(found: string, ...expected: string[]): Parser<T, S> {\r\n    return new Parser(input => pr.failed(input.position, found, expected))\r\n}\r\n/**\r\n * ## Parsing Terminals\r\n * \r\n * Creates a parser that reads one terminal from the input and returns it, if it \r\n * satisfies the given predicate; otherwise the parser fails.\r\n */\r\nexport function satisfy<T>(predicate: (value: T) => boolean): Parser<T, T> {\r\n    return new Parser(input => {\r\n        let pos = input.position\r\n        let item = input.next()\r\n        if (predicate(item))\r\n            return pr.succeeded(input.position, item)\r\n        input.position = pos\r\n        return pr.failed<T>(input.position, `${item}`)\r\n    })\r\n}\r\n/**\r\n * Creates a parser that reads one terminal from the input and returns it, if it\r\n * does **not** satisfy a given predicate.\r\n */\r\nexport function notSatisfy<T>(predicate: (value: T) => boolean): Parser<T, T> {\r\n    return satisfy(x => !predicate(x))\r\n}\r\n/**\r\n * Any of the given parsers must succeed. The operation is the same \r\n * as the `or` combinator generalized to arbitrary number of choices.\r\n */\r\nexport function any<T, S>(...parsers: Parser<T, S>[]): Parser<T, S> {\r\n    if (parsers.length == 0)\r\n        throw Error(\"At least one parser must be given.\")\r\n    return new Parser(input => {\r\n        let res: pr.ParseResult<T> | null = null\r\n        let i = 0\r\n        let pos = input.position\r\n        do {\r\n            let r = parsers[i++].parse(input)\r\n            if (r.kind == \"ok\")\r\n                return r\r\n            if (r.position > pos)\r\n                return r\r\n            if (res == null)\r\n                res = r\r\n            else\r\n                pr.joinExpected(res, r)\r\n        }\r\n        while (i < parsers.length)\r\n        return res\r\n    })\r\n}\r\n/** \r\n * Peek next symbol in the input stream without changing the position.\r\n */\r\nexport function peek<S>(): Parser<S, S> {\r\n    return new Parser(input => {\r\n        let pos = input.position\r\n        let next = input.next()\r\n        input.position = pos\r\n        return pr.succeeded(pos, next)\r\n    })\r\n}\r\n/**\r\n * Select a parser to be used based on the next symbol in the input. This \r\n * function is an alternative to the the \"any\" combinator. It reduces \r\n * backtracking when the parser to be applied can be deduced from the next \r\n * symbol.\r\n */\r\nexport function choose<T, S>(selector: (input: S) => Parser<T, S>):\r\n    Parser<T, S> {\r\n    return peek<S>().bind(selector)\r\n}\r\n/**\r\n * ## Getting Current Position\r\n * \r\n * A parser that returns the current position of the input. This is useful\r\n * when binding parsers together and you want to know the position where you\r\n * currently are. The position can be also used for backtracking.\r\n */\r\nexport function position<S>(): Parser<number, S> {\r\n    return new Parser(input => pr.succeeded(input.position, input.position))\r\n}\r\n/**\r\n * ## User-Managed State\r\n * \r\n * Get the current satellite state stored in the input.\r\n */\r\nexport function getState<T, S>(): Parser<T, S> {\r\n    return new Parser(input => pr.succeeded(input.position, <T>input.state))\r\n}\r\n/**\r\n * Set the current satellite state stored in the input. The new state\r\n * is not given explicitly. Rather, a funcion which returns the new\r\n * state is specified.\r\n */\r\nexport function setState<T, S>(newValue: () => T): Parser<T, S> {\r\n    return new Parser(input =>\r\n        pr.succeeded(input.position, input.state = newValue()))\r\n}\r\n/**\r\n * Mutate the satellite state stored in the input. The mutation is done\r\n * with a function given as an argument. \r\n */\r\nexport function mutateState<T, S>(mutate: (state: T) => void): Parser<T, S> {\r\n    return new Parser(input => {\r\n        mutate(input.state)\r\n        return pr.succeeded(input.position, input.state)\r\n    })\r\n}\r\n/**\r\n * Check that the current state matches a predicate. If not, the result parser \r\n * fails.\r\n */\r\nexport function checkState<T, S>(predicate: (state: T) => boolean): \r\n    Parser<T, S> {\r\n    return new Parser(input => predicate(input.state) ?\r\n        pr.succeeded(input.position, input.state) :\r\n        pr.failed(input.position, \"Matching predicate.\"))\r\n}\r\n/**\r\n * Clean up the current state after a parser has been executed. The clean-up \r\n * function is run regardless of whether the parser succeeds or fails.\r\n */\r\nexport function cleanupState<T, U, S>(parser: Parser<T, S>,\r\n    cleanup: (state: U) => void): Parser<T, S> {\r\n    return new Parser(input => {\r\n        let res = parser.parse(input)\r\n        cleanup(input.state)\r\n        return res\r\n    })\r\n}\r\n/**\r\n * ## Defining Mutually Recursive Parsers\r\n * \r\n * Often grammar rules are mutually recursive, which means that there is no way \r\n * to write them in an order where all the dependent rules are defined. In these \r\n * occasions, you can just create a _reference_ to a parser and set its \r\n * implementation later. To refer to the parser that is not yet defined, you can \r\n * use this function. \r\n */\r\nexport function forwardRef<T, S>(parser: ref.Ref<Parser<T, S>>): Parser<T, S> {\r\n    return new Parser(input => parser.target.parse(input))\r\n}\r\n/**\r\n * ## General Parsers\r\n * \r\n * The catch-all parser that will match any symbol read from the input.\r\n */\r\nexport function anything<T>(): Parser<T, T> {\r\n    return satisfy<T>(_ => true)\r\n}\r\n/**\r\n * Parser that succeeds if the symbol read from the input is equal (===) to\r\n * given parameter; otherwise parsing fails.\r\n */\r\nexport function is<T>(value: T): Parser<T, T> {\r\n    return satisfy<T>(x => x === value)\r\n}\r\n/**\r\n * Parse a specific token from the lexer input stream.\r\n */\r\nexport function token<T>(token: T): Parser<lex.Token<T>, lex.Token<T>> {\r\n    return satisfy<lex.Token<T>>(t => t.token === token)\r\n}\r\n/**\r\n * Helper function to create a terminal parser.\r\n */\r\nexport function terminal<T>(tok: T, name: string) {\r\n    return token(tok).expect(name)\r\n}", "/**\r\n * # Combinators for Parsing Arrays and Expressions\r\n * \r\n * This module contains additional combinators that are useful when parsing \r\n * sequences or expressions. They are adapted from the original \r\n * [Parsec](http://hackage.haskell.org/package/parsec-3.1.13.0/docs/Text-Parsec-Combinator.html)\r\n * library.\r\n */\r\nimport * as par from \"./parser\"\r\n/**\r\n * We use a trick described \r\n * [here](https://www.typescriptlang.org/docs/handbook/declaration-merging.html#module-augmentation)\r\n * to add the functions we define to the `Parser<T, S>` class.\r\n */\r\ndeclare module './parser' {\r\n    export interface Parser<T, S> {\r\n        oneOrMoreSeparatedBy<U>(separator: Parser<U, S>): Parser<T[], S>\r\n        zeroOrMoreSeparatedBy<U>(separator: Parser<U, S>): Parser<T[], S>\r\n        followedBy<U>(after: Parser<U, S>): Parser<T, S>\r\n        surroundedBy<U>(surround: Parser<U, S>): Parser<T, S>\r\n        bracketedBy<U, V>(open: Parser<U, S>, close: Parser<V, S>): Parser<T, S>\r\n        chainOneOrMore(operation: Parser<BinaryOp<T>, S>): Parser<T, S>\r\n        chainZeroOrMore(operation: Parser<BinaryOp<T>, S>, value: T):\r\n            Parser<T, S>\r\n    }\r\n}\r\n/**\r\n * Type definition for a binary function that has the same domain and range \r\n * type.\r\n */\r\nexport type BinaryOp<T> = (x: T, y: T) => T\r\n/**\r\n * ## Parsing Separated Lists\r\n * \r\n * Parse an array containing at least one element. The items of the array are \r\n * recognized by `parser`. The items are separated by input recognized by \r\n * `separator`. The function returns an array of parsed elements.\r\n */\r\npar.Parser.prototype.oneOrMoreSeparatedBy = function<T, U, S>(\r\n    this: par.Parser<T, S>, separator: par.Parser<U, S>): par.Parser<T[], S> {\r\n    return this.bind(\r\n        x => separator.seq(this).zeroOrMore().bind(\r\n        xs => par.mret([x].concat(xs))))\r\n}\r\n/**\r\n * Parse a potentially empty array. The items of the array are recognized by \r\n * `parser`. The items are separated by input recognized by `separator`.\r\n */\r\npar.Parser.prototype.zeroOrMoreSeparatedBy = function<T, U, S>(\r\n    this: par.Parser<T, S>, separator: par.Parser<U, S>): par.Parser<T[], S> {\r\n    return this.oneOrMoreSeparatedBy(separator).or(par.mret([]))\r\n}\r\n/**\r\n * ## Terminators & Brackets\r\n * \r\n * Parse item(s) followed by a terminator given in the `after` parser. The \r\n * result of `parser` is returned, and result of `after` is ignored.\r\n */\r\npar.Parser.prototype.followedBy = function<T, U, S>(this: par.Parser<T, S>,\r\n    after: par.Parser<U, S>): par.Parser<T, S> {\r\n    return this.bind(p => after.bind(_ => par.mret(p)))\r\n}\r\n/**\r\n * Parse item(s) surrounded by input recognized by the `surround` parser. The \r\n * result of `parser` is returned.\r\n */\r\npar.Parser.prototype.surroundedBy = function<T, U, S>(this: par.Parser<T, S>,\r\n    surround: par.Parser<U, S>): par.Parser<T, S> {\r\n    return surround.bind(\r\n        o => this.bind(\r\n        p => surround.bind(\r\n        c => par.mret(p))))\r\n}\r\n/**\r\n * Parse item(s) surrounded by an open and closing bracket. The result `parser` \r\n * is returned.\r\n */\r\npar.Parser.prototype.bracketedBy = function<T, U, V, S>(this: par.Parser<T, S>,\r\n    open: par.Parser<U, S>, close: par.Parser<V, S>): par.Parser<T, S> {\r\n    return open.bind(\r\n        o => this.bind(\r\n        p => close.bind(\r\n        c => par.mret(p))))\r\n}\r\n/**\r\n * ## Parsing Expressions\r\n * \r\n * Parse one or more occurrences of `parser`, separated by `operation`. \r\n * Return a value obtained by a left associative application of all functions \r\n * returned by `operation` to the values returned by `parser`. This parser can \r\n * for example be used to eliminate left recursion which typically occurs in \r\n * expression grammars.\r\n */\r\npar.Parser.prototype.chainOneOrMore = function<T, S>(this: par.Parser<T, S>,\r\n    operation: par.Parser<BinaryOp<T>, S>): par.Parser<T, S> {\r\n    return this.bind(\r\n        x => operation.bind(\r\n            f => this.bind(\r\n            y => par.mret([f, y] as [BinaryOp<T>, T]))).zeroOrMore().bind(\r\n        fys => par.mret(fys.reduce((z, [f, y]) => f(z, y), x))))\r\n}\r\n/**\r\n * Parse zero or more occurrences of `parser`, separated by `operation`. \r\n * Return a value obtained by a left associative application of all functions \r\n * returned by `operation` to the values returned by `parser`. If there are \r\n * zero occurrences of `parser`, the `value` is returned.\r\n */\r\npar.Parser.prototype.chainZeroOrMore = function<T, S>(this: par.Parser<T, S>,\r\n    operation: par.Parser<BinaryOp<T>, S>, value: T): par.Parser<T, S> {\r\n    return this.chainOneOrMore(operation).or(par.mret(value))\r\n}\r\n/**\r\n * Construct a parser for operator selection. Used typically in conjunction\r\n * with `chain*` functions.\r\n */\r\nexport function operators<T, U, S>(...ops: [par.Parser<T, S>, U][]): \r\n    par.Parser<U, S> {\r\n    return par.any(...ops.map(([p, o]) => p.map(_ => o)))\r\n}", "/**\r\n * ---\r\n * {\r\n *  \"modules\": [\r\n *      \"lits-extras\"\r\n *  ]\r\n * }\r\n * ---\r\n * # Library Structure\r\n * \r\n * Below is the dependency graph showing the module hierarchy. Note that it\r\n * shows also the testing modules which are not included in the published \r\n * package. You can jump to a module by clicking it in the diagram.\r\n * \r\n * <dependency-diagram url=\"../dependencies.json\" filter=\"src\\/(?!extras)\">\r\n * </dependency-diagram>\r\n * \r\n * ## Exports\r\n * \r\n * Parzec library consists of following modules. All of them are exported \r\n * outside the library.\r\n */\r\nexport * from './ref'\r\nexport * from './error'\r\nexport * from './input'\r\nexport * from './result'\r\nexport * from './error'\r\nexport * from './lexer'\r\nexport * from './parser'\r\nexport * from './arrayparsers'\r\nexport * from './utils'", "/**\r\n * # Parsing Arithmetic Expressions\r\n * \r\n * A common way to demonstrate parser construction is to use a grammar that\r\n * represents arithmetic expressions. We build a parser for simple expressions\r\n * that consist of addition, subtraction, multiplication, and division \r\n * operations.\r\n */\r\nimport * as pz from \"../\";\r\n\r\n/**\r\n * ## Tokens\r\n * \r\n * Tokens include numbers, parenthesis, operators, and whitespace.\r\n */\r\nexport enum ExprToken { \r\n    Number, OpenParen, CloseParen, Plus, Minus, Multiply, Divide, Whitespace, \r\n    EOF \r\n}\r\n/**\r\n * To turn on debugging, set on the following flag. It outputs evaluated\r\n * parsing rules, which helps understanding the operation.\r\n */\r\npz.parserDebug.debugging = false\r\n/**\r\n * ## Lexer\r\n * \r\n * The lexer can be constructed with a single expression. We specify the\r\n * regular expression that accepts a given token, and associate it to the \r\n * member of the enumeration defined above.\r\n */\r\nconst lexer = new pz.Lexer<ExprToken>(\r\n    [/-?\\d+(?:\\.\\d+)?(?:[eE][+-]?\\d+)?/, ExprToken.Number],\r\n    [/\\(/, ExprToken.OpenParen],\r\n    [/\\)/, ExprToken.CloseParen],\r\n    [/\\+/, ExprToken.Plus],\r\n    [/-/, ExprToken.Minus],\r\n    [/\\*/, ExprToken.Multiply],\r\n    [/\\//, ExprToken.Divide],\r\n    [/[\\t\\n\\r ]+/, ExprToken.Whitespace]);\r\n/**\r\n * ## Parser\r\n * \r\n * Parser is built from two kinds of parsing rules: ones that recognize \r\n * _terminals_ and others that recognize _nonterminals_.\r\n *\r\n * ### Terminals\r\n * \r\n * Terminal parsers recognize the tokens returned by the lexer. They are\r\n * straightforward to define.\r\n * \r\n * First we define a parser that skips any whitespace between the tokens.  \r\n */\r\nconst optws = pz.terminal(ExprToken.Whitespace, \"<whitespace>\").optionalRef()\r\n/**\r\n * Next we define parser for numbers. We convert the recognized text to `number`\r\n * type. We skip the trailing whitespace with the `followedBy` combinator.\r\n */\r\nconst number = pz.terminal(ExprToken.Number, \"<number>\")\r\n    .map(t => Number(t.text)).followedBy(optws)\r\n/**\r\n * Parenthesis and operators are all recognized the same way. Again, we skip the\r\n * trailing whitespace to keep the other rules simple.\r\n */\r\nconst openParen = pz.terminal(ExprToken.OpenParen, \"(\").followedBy(optws)\r\nconst closeParen = pz.terminal(ExprToken.CloseParen, \")\").followedBy(optws)\r\nconst plus = pz.terminal(ExprToken.Plus, \"+\").followedBy(optws)\r\nconst minus = pz.terminal(ExprToken.Minus, \"-\").followedBy(optws)\r\nconst multiply = pz.terminal(ExprToken.Multiply, \"*\").followedBy(optws)\r\nconst divide = pz.terminal(ExprToken.Divide, \"/\").followedBy(optws)\r\n/**\r\n * `eof` is a special terminal parser that recognizes end of input.\r\n */\r\nconst eof = pz.terminal(ExprToken.EOF, \"<end of input>\")\r\n/**\r\n * ### Nonterminals\r\n * \r\n * The abstract nodes in a syntax tree are called nonterminals. We define a \r\n * parser for each nonterminal. Since expressions can theoretically be\r\n * infinitely long, the parsers are recursive.\r\n * \r\n * First we define parsers for operators. We utilize the `operators` combinator\r\n * which is designed just for this purpose. These parsers calculate the result \r\n * of the operation, and return it to the parent parser.\r\n */\r\nconst addop = pz.operators(\r\n    [plus, (a: number, b: number) => a + b],\r\n    [minus, (a: number, b: number) => a - b])\r\nconst mulop = pz.operators(\r\n    [multiply, (a: number, b: number) => a * b],\r\n    [divide, (a: number, b: number) => a / b])\r\n/**\r\n * Terms are the results of multiplication or division operators. We define\r\n * the term parser as a reference as we need the factor parser in its \r\n * definition.\r\n */\r\nconst term = new pz.Ref<pz.Parser<number, pz.Token<ExprToken>>>()\r\n/**\r\n * Expressions consist of terms that are added or subtracted together. Note how\r\n * the grammar implicitly defines the precedence order as terms are recognized \r\n * before the expressions.\r\n */\r\nconst expr = pz.forwardRef(term).chainOneOrMore(addop)\r\n/**\r\n * To change the precedence order we uses parenthesis as usual. When an\r\n * expression is surrounded by parentehesis it becomes a factor which is \r\n * recognized before terms. So, a factor is either a number or an expression\r\n * in parenthesis.\r\n */\r\nconst factor = expr.bracketedBy(openParen, closeParen).or(number)\r\n/**\r\n * Now we can define the term as sequence of factors separated by multiplication\r\n * or division operators.\r\n */\r\nterm.target = factor.chainOneOrMore(mulop)\r\n/**\r\n * Last we define the root parser, which just skips any leading whitespace\r\n * before calling the expression parser. Whitespace in-between tokens is \r\n * skipped by terminal parsers.\r\n */\r\nconst rootExpr = optws.seq(expr).followedBy(eof)\r\n/**\r\n * ## Exported Parsing Function\r\n * \r\n * Now we can define the helper functions which parses an expression string and \r\n * calculates its value. To get a `ParserInput<ExprToken>` interface required \r\n * by the parser, we call the `lexerInput` function, which takes the lexer and \r\n * input expression as arguments.\r\n *\r\n * After that we can call the `parse` function which takes the root grammar\r\n * rule and the input as parameters.\r\n  */\r\nexport function evaluateExpression(expression: string): number {\r\n    return pz.parse(rootExpr, pz.lexerInput<ExprToken>(expression, lexer, \r\n        new pz.Token(ExprToken.EOF, \"<end of input>\")))\r\n}", "export class PreconditionFailure extends Error {\n    constructor(interruptExecution = false) {\n        super();\n        this.interruptExecution = interruptExecution;\n        this.footprint = PreconditionFailure.SharedFootPrint;\n    }\n    static isFailure(err) {\n        return err != null && err.footprint === PreconditionFailure.SharedFootPrint;\n    }\n}\nPreconditionFailure.SharedFootPrint = Symbol('fast-check/PreconditionFailure');\n", "import { PreconditionFailure } from './PreconditionFailure.js';\nexport function pre(expectTruthy) {\n    if (!expectTruthy) {\n        throw new PreconditionFailure();\n    }\n}\n", "class Nil {\n    [Symbol.iterator]() {\n        return this;\n    }\n    next(value) {\n        return { value, done: true };\n    }\n}\nNil.nil = new Nil();\nexport function nilHelper() {\n    return Nil.nil;\n}\nexport function* mapHelper(g, f) {\n    for (const v of g) {\n        yield f(v);\n    }\n}\nexport function* flatMapHelper(g, f) {\n    for (const v of g) {\n        yield* f(v);\n    }\n}\nexport function* filterHelper(g, f) {\n    for (const v of g) {\n        if (f(v)) {\n            yield v;\n        }\n    }\n}\nexport function* takeNHelper(g, n) {\n    for (let i = 0; i < n; ++i) {\n        const cur = g.next();\n        if (cur.done) {\n            break;\n        }\n        yield cur.value;\n    }\n}\nexport function* takeWhileHelper(g, f) {\n    let cur = g.next();\n    while (!cur.done && f(cur.value)) {\n        yield cur.value;\n        cur = g.next();\n    }\n}\nexport function* joinHelper(g, others) {\n    for (let cur = g.next(); !cur.done; cur = g.next()) {\n        yield cur.value;\n    }\n    for (const s of others) {\n        for (let cur = s.next(); !cur.done; cur = s.next()) {\n            yield cur.value;\n        }\n    }\n}\n", "import { filterHelper, flatMapHelper, joinHelper, mapHelper, nilHelper, takeNHelper, takeWhileHelper, } from './StreamHelpers.js';\nexport class Stream {\n    constructor(g) {\n        this.g = g;\n    }\n    static nil() {\n        return new Stream(nilHelper());\n    }\n    static of(...elements) {\n        return new Stream(elements[Symbol.iterator]());\n    }\n    next() {\n        return this.g.next();\n    }\n    [Symbol.iterator]() {\n        return this.g;\n    }\n    map(f) {\n        return new Stream(mapHelper(this.g, f));\n    }\n    flatMap(f) {\n        return new Stream(flatMapHelper(this.g, f));\n    }\n    dropWhile(f) {\n        let foundEligible = false;\n        function* helper(v) {\n            if (foundEligible || !f(v)) {\n                foundEligible = true;\n                yield v;\n            }\n        }\n        return this.flatMap(helper);\n    }\n    drop(n) {\n        let idx = 0;\n        function helper() {\n            return idx++ < n;\n        }\n        return this.dropWhile(helper);\n    }\n    takeWhile(f) {\n        return new Stream(takeWhileHelper(this.g, f));\n    }\n    take(n) {\n        return new Stream(takeNHelper(this.g, n));\n    }\n    filter(f) {\n        return new Stream(filterHelper(this.g, f));\n    }\n    every(f) {\n        for (const v of this.g) {\n            if (!f(v)) {\n                return false;\n            }\n        }\n        return true;\n    }\n    has(f) {\n        for (const v of this.g) {\n            if (f(v)) {\n                return [true, v];\n            }\n        }\n        return [false, null];\n    }\n    join(...others) {\n        return new Stream(joinHelper(this.g, others));\n    }\n    getNthOrLast(nth) {\n        let remaining = nth;\n        let last = null;\n        for (const v of this.g) {\n            if (remaining-- === 0)\n                return v;\n            last = v;\n        }\n        return last;\n    }\n}\nexport function stream(g) {\n    return new Stream(g);\n}\n", "export const cloneMethod = Symbol('fast-check/cloneMethod');\nexport function hasCloneMethod(instance) {\n    return (instance !== null &&\n        (typeof instance === 'object' || typeof instance === 'function') &&\n        cloneMethod in instance &&\n        typeof instance[cloneMethod] === 'function');\n}\nexport function cloneIfNeeded(instance) {\n    return hasCloneMethod(instance) ? instance[cloneMethod]() : instance;\n}\n", "import { Stream } from '../../../stream/Stream.js';\nimport { cloneMethod, hasCloneMethod } from '../../symbols.js';\nexport class Shrinkable {\n    constructor(value_, shrink = () => Stream.nil(), customGetValue = undefined) {\n        this.value_ = value_;\n        this.shrink = shrink;\n        this.hasToBeCloned = customGetValue !== undefined || hasCloneMethod(value_);\n        this.readOnce = false;\n        if (this.hasToBeCloned) {\n            Object.defineProperty(this, 'value', { get: customGetValue !== undefined ? customGetValue : this.getValue });\n        }\n        else {\n            this.value = value_;\n        }\n    }\n    getValue() {\n        if (!this.readOnce) {\n            this.readOnce = true;\n            return this.value_;\n        }\n        return this.value_[cloneMethod]();\n    }\n    applyMapper(mapper) {\n        if (this.hasToBeCloned) {\n            const out = mapper(this.value);\n            if (out instanceof Object) {\n                out[cloneMethod] = () => this.applyMapper(mapper);\n            }\n            return out;\n        }\n        return mapper(this.value);\n    }\n    map(mapper) {\n        return new Shrinkable(this.applyMapper(mapper), () => this.shrink().map((v) => v.map(mapper)));\n    }\n    filter(refinement) {\n        const refinementOnShrinkable = (s) => {\n            return refinement(s.value_);\n        };\n        return new Shrinkable(this.value, () => this.shrink()\n            .filter(refinementOnShrinkable)\n            .map((v) => v.filter(refinement)));\n    }\n}\n", "import { Shrinkable } from './Shrinkable.js';\nexport class Arbitrary {\n    filter(refinement) {\n        return new FilterArbitrary(this, refinement);\n    }\n    map(mapper) {\n        return new MapArbitrary(this, mapper);\n    }\n    chain(fmapper) {\n        return new ChainArbitrary(this, fmapper);\n    }\n    noShrink() {\n        return new NoShrinkArbitrary(this);\n    }\n    withBias(_freq) {\n        return this;\n    }\n    noBias() {\n        return new NoBiasArbitrary(this);\n    }\n}\nclass ChainArbitrary extends Arbitrary {\n    constructor(arb, fmapper) {\n        super();\n        this.arb = arb;\n        this.fmapper = fmapper;\n    }\n    generate(mrng) {\n        const clonedMrng = mrng.clone();\n        const src = this.arb.generate(mrng);\n        const dst = this.fmapper(src.value).generate(mrng);\n        return ChainArbitrary.shrinkChain(clonedMrng, src, dst, this.fmapper);\n    }\n    withBias(freq) {\n        return this.arb.withBias(freq).chain((t) => this.fmapper(t).withBias(freq));\n    }\n    static shrinkChain(mrng, src, dst, fmapper) {\n        return new Shrinkable(dst.value, () => src\n            .shrink()\n            .map((v) => ChainArbitrary.shrinkChain(mrng.clone(), v, fmapper(v.value).generate(mrng.clone()), fmapper))\n            .join(dst.shrink()));\n    }\n}\nclass MapArbitrary extends Arbitrary {\n    constructor(arb, mapper) {\n        super();\n        this.arb = arb;\n        this.mapper = mapper;\n    }\n    generate(mrng) {\n        return this.arb.generate(mrng).map(this.mapper);\n    }\n    withBias(freq) {\n        return this.arb.withBias(freq).map(this.mapper);\n    }\n}\nclass FilterArbitrary extends Arbitrary {\n    constructor(arb, refinement) {\n        super();\n        this.arb = arb;\n        this.refinement = refinement;\n    }\n    generate(mrng) {\n        let g = this.arb.generate(mrng);\n        while (!this.refinementOnShrinkable(g)) {\n            g = this.arb.generate(mrng);\n        }\n        return g.filter(this.refinement);\n    }\n    withBias(freq) {\n        return this.arb.withBias(freq).filter(this.refinement);\n    }\n    refinementOnShrinkable(s) {\n        return this.refinement(s.value);\n    }\n}\nclass NoShrinkArbitrary extends Arbitrary {\n    constructor(arb) {\n        super();\n        this.arb = arb;\n    }\n    generate(mrng) {\n        return new Shrinkable(this.arb.generate(mrng).value);\n    }\n    withBias(freq) {\n        return this.arb.withBias(freq).noShrink();\n    }\n}\nclass NoBiasArbitrary extends Arbitrary {\n    constructor(arb) {\n        super();\n        this.arb = arb;\n    }\n    generate(mrng) {\n        return this.arb.generate(mrng);\n    }\n}\nexport function assertIsArbitrary(instance) {\n    if (typeof instance !== 'object' || instance === null || !('generate' in instance)) {\n        throw new Error('Unexpected value received: not an instance of Arbitrary');\n    }\n}\n", "import { Arbitrary } from './Arbitrary.js';\nimport { Shrinkable } from './Shrinkable.js';\nfunction removeContextFromContextualValue(contextualValue) {\n    return contextualValue[0];\n}\nclass ArbitraryWithContextualShrink extends Arbitrary {\n    contextualShrinkableFor(value, context) {\n        return new Shrinkable(value, () => this.contextualShrink(value, context).map((contextualValue) => this.contextualShrinkableFor(contextualValue[0], contextualValue[1])));\n    }\n    shrink(value, shrunkOnce) {\n        const context = shrunkOnce === true ? this.shrunkOnceContext() : undefined;\n        return this.contextualShrink(value, context).map(removeContextFromContextualValue);\n    }\n    shrinkableFor(value, shrunkOnce) {\n        return new Shrinkable(value, () => {\n            return this.shrink(value, shrunkOnce).map((value) => this.shrinkableFor(value, true));\n        });\n    }\n}\nexport { ArbitraryWithContextualShrink };\n", "import { cloneMethod, hasCloneMethod } from '../../symbols.js';\nexport class NextValue {\n    constructor(value_, context, customGetValue = undefined) {\n        this.value_ = value_;\n        this.context = context;\n        this.hasToBeCloned = customGetValue !== undefined || hasCloneMethod(value_);\n        this.readOnce = false;\n        if (this.hasToBeCloned) {\n            Object.defineProperty(this, 'value', { get: customGetValue !== undefined ? customGetValue : this.getValue });\n        }\n        else {\n            this.value = value_;\n        }\n    }\n    getValue() {\n        if (this.hasToBeCloned) {\n            if (!this.readOnce) {\n                this.readOnce = true;\n                return this.value_;\n            }\n            return this.value_[cloneMethod]();\n        }\n        return this.value_;\n    }\n}\n", "import { Stream } from '../../../stream/Stream.js';\nimport { cloneMethod } from '../../symbols.js';\nimport { NextValue } from './NextValue.js';\nexport class NextArbitrary {\n    filter(refinement) {\n        return new FilterArbitrary(this, refinement);\n    }\n    map(mapper, unmapper) {\n        return new MapArbitrary(this, mapper, unmapper);\n    }\n    chain(chainer) {\n        return new ChainArbitrary(this, chainer);\n    }\n    noShrink() {\n        return new NoShrinkArbitrary(this);\n    }\n    noBias() {\n        return new NoBiasArbitrary(this);\n    }\n}\nclass ChainArbitrary extends NextArbitrary {\n    constructor(arb, chainer) {\n        super();\n        this.arb = arb;\n        this.chainer = chainer;\n    }\n    generate(mrng, biasFactor) {\n        const clonedMrng = mrng.clone();\n        const src = this.arb.generate(mrng, biasFactor);\n        return this.valueChainer(src, mrng, clonedMrng, biasFactor);\n    }\n    canShrinkWithoutContext(value) {\n        return false;\n    }\n    shrink(value, context) {\n        if (this.isSafeContext(context)) {\n            return (!context.stoppedForOriginal\n                ? this.arb\n                    .shrink(context.originalValue, context.originalContext)\n                    .map((v) => this.valueChainer(v, context.clonedMrng.clone(), context.clonedMrng, context.originalBias))\n                : Stream.nil()).join(context.chainedArbitrary.shrink(value, context.chainedContext).map((dst) => {\n                const newContext = Object.assign(Object.assign({}, context), { chainedContext: dst.context, stoppedForOriginal: true });\n                return new NextValue(dst.value_, newContext);\n            }));\n        }\n        return Stream.nil();\n    }\n    valueChainer(v, generateMrng, clonedMrng, biasFactor) {\n        const chainedArbitrary = this.chainer(v.value_);\n        const dst = chainedArbitrary.generate(generateMrng, biasFactor);\n        const context = {\n            originalBias: biasFactor,\n            originalValue: v.value_,\n            originalContext: v.context,\n            stoppedForOriginal: false,\n            chainedArbitrary,\n            chainedContext: dst.context,\n            clonedMrng,\n        };\n        return new NextValue(dst.value_, context);\n    }\n    isSafeContext(context) {\n        return (context != null &&\n            typeof context === 'object' &&\n            'originalBias' in context &&\n            'originalValue' in context &&\n            'originalContext' in context &&\n            'stoppedForOriginal' in context &&\n            'chainedArbitrary' in context &&\n            'chainedContext' in context &&\n            'clonedMrng' in context);\n    }\n}\nclass MapArbitrary extends NextArbitrary {\n    constructor(arb, mapper, unmapper) {\n        super();\n        this.arb = arb;\n        this.mapper = mapper;\n        this.unmapper = unmapper;\n        this.bindValueMapper = this.valueMapper.bind(this);\n    }\n    generate(mrng, biasFactor) {\n        const g = this.arb.generate(mrng, biasFactor);\n        return this.valueMapper(g);\n    }\n    canShrinkWithoutContext(value) {\n        if (this.unmapper !== undefined) {\n            try {\n                const unmapped = this.unmapper(value);\n                return this.arb.canShrinkWithoutContext(unmapped);\n            }\n            catch (_err) {\n                return false;\n            }\n        }\n        return false;\n    }\n    shrink(value, context) {\n        if (this.isSafeContext(context)) {\n            return this.arb.shrink(context.originalValue, context.originalContext).map(this.bindValueMapper);\n        }\n        if (this.unmapper !== undefined) {\n            const unmapped = this.unmapper(value);\n            return this.arb.shrink(unmapped, undefined).map(this.bindValueMapper);\n        }\n        return Stream.nil();\n    }\n    mapperWithCloneIfNeeded(v) {\n        const sourceValue = v.value;\n        const mappedValue = this.mapper(sourceValue);\n        if (v.hasToBeCloned &&\n            ((typeof mappedValue === 'object' && mappedValue !== null) || typeof mappedValue === 'function') &&\n            Object.isExtensible(mappedValue)) {\n            Object.defineProperty(mappedValue, cloneMethod, { get: () => () => this.mapperWithCloneIfNeeded(v)[0] });\n        }\n        return [mappedValue, sourceValue];\n    }\n    valueMapper(v) {\n        const [mappedValue, sourceValue] = this.mapperWithCloneIfNeeded(v);\n        const context = { originalValue: sourceValue, originalContext: v.context };\n        return new NextValue(mappedValue, context);\n    }\n    isSafeContext(context) {\n        return (context != null &&\n            typeof context === 'object' &&\n            'originalValue' in context &&\n            'originalContext' in context);\n    }\n}\nclass FilterArbitrary extends NextArbitrary {\n    constructor(arb, refinement) {\n        super();\n        this.arb = arb;\n        this.refinement = refinement;\n        this.bindRefinementOnValue = this.refinementOnValue.bind(this);\n    }\n    generate(mrng, biasFactor) {\n        while (true) {\n            const g = this.arb.generate(mrng, biasFactor);\n            if (this.refinementOnValue(g)) {\n                return g;\n            }\n        }\n    }\n    canShrinkWithoutContext(value) {\n        return this.arb.canShrinkWithoutContext(value) && this.refinement(value);\n    }\n    shrink(value, context) {\n        return this.arb.shrink(value, context).filter(this.bindRefinementOnValue);\n    }\n    refinementOnValue(v) {\n        return this.refinement(v.value);\n    }\n}\nclass NoShrinkArbitrary extends NextArbitrary {\n    constructor(arb) {\n        super();\n        this.arb = arb;\n    }\n    generate(mrng, biasFactor) {\n        return this.arb.generate(mrng, biasFactor);\n    }\n    canShrinkWithoutContext(value) {\n        return this.arb.canShrinkWithoutContext(value);\n    }\n    shrink(_value, _context) {\n        return Stream.nil();\n    }\n    noShrink() {\n        return this;\n    }\n}\nclass NoBiasArbitrary extends NextArbitrary {\n    constructor(arb) {\n        super();\n        this.arb = arb;\n    }\n    generate(mrng, _biasFactor) {\n        return this.arb.generate(mrng, undefined);\n    }\n    canShrinkWithoutContext(value) {\n        return this.arb.canShrinkWithoutContext(value);\n    }\n    shrink(value, context) {\n        return this.arb.shrink(value, context);\n    }\n    noBias() {\n        return this;\n    }\n}\nexport function assertIsNextArbitrary(instance) {\n    if (typeof instance !== 'object' ||\n        instance === null ||\n        !('generate' in instance) ||\n        !('shrink' in instance) ||\n        'shrinkableFor' in instance) {\n        throw new Error('Unexpected value received: not an instance of NextArbitrary');\n    }\n}\n", "var _a;\nimport { Stream } from '../../../stream/Stream.js';\nimport { ConverterFromNext } from './ConverterFromNext.js';\nimport { NextArbitrary } from './NextArbitrary.js';\nimport { NextValue } from './NextValue.js';\nconst identifier = '__ConverterToNext__';\nfunction fromShrinkableToNextValue(g) {\n    if (!g.hasToBeCloned) {\n        return new NextValue(g.value_, g);\n    }\n    return new NextValue(g.value_, g, () => g.value);\n}\nexport class ConverterToNext extends NextArbitrary {\n    constructor(arb) {\n        super();\n        this.arb = arb;\n        this[_a] = true;\n    }\n    static isConverterToNext(arb) {\n        return identifier in arb;\n    }\n    static convertIfNeeded(arb) {\n        if (ConverterFromNext.isConverterFromNext(arb))\n            return arb.arb;\n        else\n            return new ConverterToNext(arb);\n    }\n    generate(mrng, biasFactor) {\n        const g = biasFactor !== undefined ? this.arb.withBias(biasFactor).generate(mrng) : this.arb.generate(mrng);\n        return fromShrinkableToNextValue(g);\n    }\n    canShrinkWithoutContext(_value) {\n        return false;\n    }\n    shrink(_value, context) {\n        if (this.isSafeContext(context)) {\n            return context.shrink().map(fromShrinkableToNextValue);\n        }\n        return Stream.nil();\n    }\n    isSafeContext(context) {\n        return (context != null && typeof context === 'object' && 'value' in context && 'shrink' in context);\n    }\n    filter(refinement) {\n        return ConverterToNext.convertIfNeeded(this.arb.filter(refinement));\n    }\n    map(mapper) {\n        return ConverterToNext.convertIfNeeded(this.arb.map(mapper));\n    }\n    chain(fmapper) {\n        return ConverterToNext.convertIfNeeded(this.arb.chain((t) => {\n            const fmapped = fmapper(t);\n            if (ConverterToNext.isConverterToNext(fmapped))\n                return fmapped.arb;\n            else\n                return new ConverterFromNext(fmapped);\n        }));\n    }\n    noShrink() {\n        return ConverterToNext.convertIfNeeded(this.arb.noShrink());\n    }\n    noBias() {\n        return ConverterToNext.convertIfNeeded(this.arb.noBias());\n    }\n}\n_a = identifier;\n", "var _a;\nimport { ArbitraryWithContextualShrink } from './ArbitraryWithContextualShrink.js';\nimport { ConverterToNext } from './ConverterToNext.js';\nimport { Shrinkable } from './Shrinkable.js';\nconst identifier = '__ConverterFromNext__';\nfunction fromNextValueToShrinkableFor(arb) {\n    return function fromNextValueToShrinkable(v) {\n        const value_ = v.value_;\n        const shrinker = () => arb.shrink(value_, v.context).map(fromNextValueToShrinkable);\n        if (!v.hasToBeCloned) {\n            return new Shrinkable(value_, shrinker);\n        }\n        return new Shrinkable(value_, shrinker, () => v.value);\n    };\n}\nexport class ConverterFromNext extends ArbitraryWithContextualShrink {\n    constructor(arb, legacyShrunkOnceContext, biasFactor = undefined) {\n        super();\n        this.arb = arb;\n        this.legacyShrunkOnceContext = legacyShrunkOnceContext;\n        this.biasFactor = biasFactor;\n        this[_a] = true;\n        this.toShrinkable = fromNextValueToShrinkableFor(arb);\n    }\n    static isConverterFromNext(arb) {\n        return identifier in arb;\n    }\n    static convertIfNeeded(arb) {\n        if (ConverterToNext.isConverterToNext(arb))\n            return arb.arb;\n        else\n            return new ConverterFromNext(arb);\n    }\n    generate(mrng) {\n        const g = this.arb.generate(mrng, this.biasFactor);\n        return this.toShrinkable(g);\n    }\n    contextualShrink(value, context) {\n        return this.arb.shrink(value, context).map((v) => [v.value_, v.context]);\n    }\n    shrunkOnceContext() {\n        return this.legacyShrunkOnceContext;\n    }\n    filter(refinement) {\n        return ConverterFromNext.convertIfNeeded(this.arb.filter(refinement));\n    }\n    map(mapper) {\n        return ConverterFromNext.convertIfNeeded(this.arb.map(mapper));\n    }\n    chain(fmapper) {\n        return ConverterFromNext.convertIfNeeded(this.arb.chain((t) => {\n            const fmapped = fmapper(t);\n            if (ConverterFromNext.isConverterFromNext(fmapped))\n                return fmapped.arb;\n            else\n                return new ConverterToNext(fmapped);\n        }));\n    }\n    noShrink() {\n        return ConverterFromNext.convertIfNeeded(this.arb.noShrink());\n    }\n    withBias(freq) {\n        return new ConverterFromNext(this.arb, this.legacyShrunkOnceContext, freq);\n    }\n    noBias() {\n        return ConverterFromNext.convertIfNeeded(this.arb.noBias());\n    }\n}\n_a = identifier;\n", "import { assertIsArbitrary } from './Arbitrary.js';\nimport { ConverterFromNext } from './ConverterFromNext.js';\nimport { ConverterToNext } from './ConverterToNext.js';\nimport { assertIsNextArbitrary } from './NextArbitrary.js';\nexport function convertFromNext(arb) {\n    if (ConverterToNext.isConverterToNext(arb)) {\n        return arb.arb;\n    }\n    assertIsNextArbitrary(arb);\n    return new ConverterFromNext(arb);\n}\nexport function convertFromNextWithShrunkOnce(arb, legacyShrunkOnceContext) {\n    if (ConverterToNext.isConverterToNext(arb)) {\n        if (!('contextualShrink' in arb.arb) ||\n            !('contextualShrinkableFor' in arb.arb) ||\n            !('shrunkOnceContext' in arb.arb) ||\n            !('shrink' in arb.arb) ||\n            !('shrinkableFor' in arb.arb)) {\n            throw new Error('Conversion rejected: Underlying arbitrary is not compatible with ArbitraryWithContextualShrink');\n        }\n        return arb.arb;\n    }\n    assertIsNextArbitrary(arb);\n    return new ConverterFromNext(arb, legacyShrunkOnceContext);\n}\nexport function convertToNext(arb) {\n    if (ConverterFromNext.isConverterFromNext(arb)) {\n        return arb.arb;\n    }\n    assertIsArbitrary(arb);\n    return new ConverterToNext(arb);\n}\n", "import { Stream } from '../../stream/Stream.js';\nimport { cloneIfNeeded, cloneMethod } from '../../check/symbols.js';\nimport { NextArbitrary } from '../../check/arbitrary/definition/NextArbitrary.js';\nimport { NextValue } from '../../check/arbitrary/definition/NextValue.js';\nexport class TupleArbitrary extends NextArbitrary {\n    constructor(arbs) {\n        super();\n        this.arbs = arbs;\n        for (let idx = 0; idx !== arbs.length; ++idx) {\n            const arb = arbs[idx];\n            if (arb == null || arb.generate == null)\n                throw new Error(`Invalid parameter encountered at index ${idx}: expecting an Arbitrary`);\n        }\n    }\n    static makeItCloneable(vs, values) {\n        return Object.defineProperty(vs, cloneMethod, {\n            value: () => {\n                const cloned = [];\n                for (let idx = 0; idx !== values.length; ++idx) {\n                    cloned.push(values[idx].value);\n                }\n                TupleArbitrary.makeItCloneable(cloned, values);\n                return cloned;\n            },\n        });\n    }\n    static wrapper(values) {\n        let cloneable = false;\n        const vs = [];\n        const ctxs = [];\n        for (let idx = 0; idx !== values.length; ++idx) {\n            const v = values[idx];\n            cloneable = cloneable || v.hasToBeCloned;\n            vs.push(v.value);\n            ctxs.push(v.context);\n        }\n        if (cloneable) {\n            TupleArbitrary.makeItCloneable(vs, values);\n        }\n        return new NextValue(vs, ctxs);\n    }\n    generate(mrng, biasFactor) {\n        return TupleArbitrary.wrapper(this.arbs.map((a) => a.generate(mrng, biasFactor)));\n    }\n    canShrinkWithoutContext(value) {\n        if (!Array.isArray(value) || value.length !== this.arbs.length) {\n            return false;\n        }\n        for (let index = 0; index !== this.arbs.length; ++index) {\n            if (!this.arbs[index].canShrinkWithoutContext(value[index])) {\n                return false;\n            }\n        }\n        return true;\n    }\n    shrink(value, context) {\n        let s = Stream.nil();\n        const safeContext = Array.isArray(context) ? context : [];\n        for (let idx = 0; idx !== this.arbs.length; ++idx) {\n            const shrinksForIndex = this.arbs[idx]\n                .shrink(value[idx], safeContext[idx])\n                .map((v) => {\n                const nextValues = value.map((v, idx) => new NextValue(cloneIfNeeded(v), safeContext[idx]));\n                return nextValues\n                    .slice(0, idx)\n                    .concat([v])\n                    .concat(nextValues.slice(idx + 1));\n            })\n                .map((values) => TupleArbitrary.wrapper(values));\n            s = s.join(shrinksForIndex);\n        }\n        return s;\n    }\n}\n", "import { convertFromNext, convertToNext } from '../check/arbitrary/definition/Converters.js';\nimport { TupleArbitrary } from './_internals/TupleArbitrary.js';\nexport function genericTuple(arbs) {\n    const nextArbs = arbs.map((arb) => convertToNext(arb));\n    return convertFromNext(new TupleArbitrary(nextArbs));\n}\n", "export const runIdToFrequency = (runId) => 2 + Math.floor(Math.log(runId + 1) / Math.log(10));\n", "let globalParameters = {};\nexport function configureGlobal(parameters) {\n    globalParameters = parameters;\n}\nexport function readConfigureGlobal() {\n    return globalParameters;\n}\nexport function resetConfigureGlobal() {\n    globalParameters = {};\n}\n", "import { PreconditionFailure } from '../precondition/PreconditionFailure.js';\nimport { runIdToFrequency } from './IRawProperty.js';\nimport { readConfigureGlobal } from '../runner/configuration/GlobalParameters.js';\nimport { ConverterFromNext } from '../arbitrary/definition/ConverterFromNext.js';\nexport class AsyncProperty {\n    constructor(arb, predicate) {\n        this.arb = arb;\n        this.predicate = predicate;\n        this.isAsync = () => true;\n        const { asyncBeforeEach, asyncAfterEach, beforeEach, afterEach } = readConfigureGlobal() || {};\n        if (asyncBeforeEach !== undefined && beforeEach !== undefined) {\n            throw Error('Global \"asyncBeforeEach\" and \"beforeEach\" parameters can\\'t be set at the same time when running async properties');\n        }\n        if (asyncAfterEach !== undefined && afterEach !== undefined) {\n            throw Error('Global \"asyncAfterEach\" and \"afterEach\" parameters can\\'t be set at the same time when running async properties');\n        }\n        this.beforeEachHook = asyncBeforeEach || beforeEach || AsyncProperty.dummyHook;\n        this.afterEachHook = asyncAfterEach || afterEach || AsyncProperty.dummyHook;\n    }\n    generate(mrng, runId) {\n        if (ConverterFromNext.isConverterFromNext(this.arb)) {\n            return this.arb.toShrinkable(this.arb.arb.generate(mrng, runId != null ? runIdToFrequency(runId) : undefined));\n        }\n        return runId != null ? this.arb.withBias(runIdToFrequency(runId)).generate(mrng) : this.arb.generate(mrng);\n    }\n    async run(v) {\n        await this.beforeEachHook();\n        try {\n            const output = await this.predicate(v);\n            return output == null || output === true ? null : 'Property failed by returning false';\n        }\n        catch (err) {\n            if (PreconditionFailure.isFailure(err))\n                return err;\n            if (err instanceof Error && err.stack)\n                return `${err}\\n\\nStack trace: ${err.stack}`;\n            return `${err}`;\n        }\n        finally {\n            await this.afterEachHook();\n        }\n    }\n    beforeEach(hookFunction) {\n        const previousBeforeEachHook = this.beforeEachHook;\n        this.beforeEachHook = () => hookFunction(previousBeforeEachHook);\n        return this;\n    }\n    afterEach(hookFunction) {\n        const previousAfterEachHook = this.afterEachHook;\n        this.afterEachHook = () => hookFunction(previousAfterEachHook);\n        return this;\n    }\n}\nAsyncProperty.dummyHook = () => { };\n", "import { genericTuple } from '../../arbitrary/genericTuple.js';\nimport { AsyncProperty } from './AsyncProperty.generic.js';\nfunction asyncProperty(...args) {\n    if (args.length < 2)\n        throw new Error('asyncProperty expects at least two parameters');\n    const arbs = args.slice(0, args.length - 1);\n    const p = args[args.length - 1];\n    return new AsyncProperty(genericTuple(arbs), t => p(...t));\n}\nexport { asyncProperty };\n", "import { asyncProperty } from './AsyncProperty.generated.js';\nexport { asyncProperty };\n", "import { PreconditionFailure } from '../precondition/PreconditionFailure.js';\nimport { runIdToFrequency } from './IRawProperty.js';\nimport { readConfigureGlobal } from '../runner/configuration/GlobalParameters.js';\nimport { ConverterFromNext } from '../arbitrary/definition/ConverterFromNext.js';\nexport class Property {\n    constructor(arb, predicate) {\n        this.arb = arb;\n        this.predicate = predicate;\n        this.isAsync = () => false;\n        const { beforeEach = Property.dummyHook, afterEach = Property.dummyHook, asyncBeforeEach, asyncAfterEach, } = readConfigureGlobal() || {};\n        if (asyncBeforeEach !== undefined) {\n            throw Error('\"asyncBeforeEach\" can\\'t be set when running synchronous properties');\n        }\n        if (asyncAfterEach !== undefined) {\n            throw Error('\"asyncAfterEach\" can\\'t be set when running synchronous properties');\n        }\n        this.beforeEachHook = beforeEach;\n        this.afterEachHook = afterEach;\n    }\n    generate(mrng, runId) {\n        if (ConverterFromNext.isConverterFromNext(this.arb)) {\n            return this.arb.toShrinkable(this.arb.arb.generate(mrng, runId != null ? runIdToFrequency(runId) : undefined));\n        }\n        return runId != null ? this.arb.withBias(runIdToFrequency(runId)).generate(mrng) : this.arb.generate(mrng);\n    }\n    run(v) {\n        this.beforeEachHook();\n        try {\n            const output = this.predicate(v);\n            return output == null || output === true ? null : 'Property failed by returning false';\n        }\n        catch (err) {\n            if (PreconditionFailure.isFailure(err))\n                return err;\n            if (err instanceof Error && err.stack)\n                return `${err}\\n\\nStack trace: ${err.stack}`;\n            return `${err}`;\n        }\n        finally {\n            this.afterEachHook();\n        }\n    }\n    beforeEach(hookFunction) {\n        const previousBeforeEachHook = this.beforeEachHook;\n        this.beforeEachHook = () => hookFunction(previousBeforeEachHook);\n        return this;\n    }\n    afterEach(hookFunction) {\n        const previousAfterEachHook = this.afterEachHook;\n        this.afterEachHook = () => hookFunction(previousAfterEachHook);\n        return this;\n    }\n}\nProperty.dummyHook = () => { };\n", "import { genericTuple } from '../../arbitrary/genericTuple.js';\nimport { Property } from './Property.generic.js';\nfunction property(...args) {\n    if (args.length < 2)\n        throw new Error('property expects at least two parameters');\n    const arbs = args.slice(0, args.length - 1);\n    const p = args[args.length - 1];\n    return new Property(genericTuple(arbs), t => p(...t));\n}\nexport { property };\n", "import { property } from './Property.generated.js';\nexport { property };\n", "export function unsafeGenerateN(rng, num) {\n    var out = [];\n    for (var idx = 0; idx != num; ++idx) {\n        out.push(rng.unsafeNext());\n    }\n    return out;\n}\nexport function generateN(rng, num) {\n    var nextRng = rng.clone();\n    var out = unsafeGenerateN(nextRng, num);\n    return [out, nextRng];\n}\nexport function unsafeSkipN(rng, num) {\n    for (var idx = 0; idx != num; ++idx) {\n        rng.unsafeNext();\n    }\n}\nexport function skipN(rng, num) {\n    var nextRng = rng.clone();\n    unsafeSkipN(nextRng, num);\n    return nextRng;\n}\n", "var MULTIPLIER = 0x000343fd;\nvar INCREMENT = 0x00269ec3;\nvar MASK = 0xffffffff;\nvar MASK_2 = (1 << 31) - 1;\nvar computeNextSeed = function (seed) {\n    return (seed * MULTIPLIER + INCREMENT) & MASK;\n};\nvar computeValueFromNextSeed = function (nextseed) {\n    return (nextseed & MASK_2) >> 16;\n};\nvar LinearCongruential = (function () {\n    function LinearCongruential(seed) {\n        this.seed = seed;\n    }\n    LinearCongruential.prototype.min = function () {\n        return LinearCongruential.min;\n    };\n    LinearCongruential.prototype.max = function () {\n        return LinearCongruential.max;\n    };\n    LinearCongruential.prototype.clone = function () {\n        return new LinearCongruential(this.seed);\n    };\n    LinearCongruential.prototype.next = function () {\n        var nextRng = new LinearCongruential(this.seed);\n        var out = nextRng.unsafeNext();\n        return [out, nextRng];\n    };\n    LinearCongruential.prototype.unsafeNext = function () {\n        this.seed = computeNextSeed(this.seed);\n        return computeValueFromNextSeed(this.seed);\n    };\n    LinearCongruential.min = 0;\n    LinearCongruential.max = Math.pow(2, 15) - 1;\n    return LinearCongruential;\n}());\nvar LinearCongruential32 = (function () {\n    function LinearCongruential32(seed) {\n        this.seed = seed;\n    }\n    LinearCongruential32.prototype.min = function () {\n        return LinearCongruential32.min;\n    };\n    LinearCongruential32.prototype.max = function () {\n        return LinearCongruential32.max;\n    };\n    LinearCongruential32.prototype.clone = function () {\n        return new LinearCongruential32(this.seed);\n    };\n    LinearCongruential32.prototype.next = function () {\n        var nextRng = new LinearCongruential32(this.seed);\n        var out = nextRng.unsafeNext();\n        return [out, nextRng];\n    };\n    LinearCongruential32.prototype.unsafeNext = function () {\n        var s1 = computeNextSeed(this.seed);\n        var v1 = computeValueFromNextSeed(s1);\n        var s2 = computeNextSeed(s1);\n        var v2 = computeValueFromNextSeed(s2);\n        this.seed = computeNextSeed(s2);\n        var v3 = computeValueFromNextSeed(this.seed);\n        var vnext = v3 + ((v2 + (v1 << 15)) << 15);\n        return ((vnext + 0x80000000) | 0) + 0x80000000;\n    };\n    LinearCongruential32.min = 0;\n    LinearCongruential32.max = 0xffffffff;\n    return LinearCongruential32;\n}());\nexport var congruential = function (seed) {\n    return new LinearCongruential(seed);\n};\nexport var congruential32 = function (seed) {\n    return new LinearCongruential32(seed);\n};\n", "var MersenneTwister = (function () {\n    function MersenneTwister(states, index) {\n        this.states = states;\n        this.index = index;\n    }\n    MersenneTwister.twist = function (prev) {\n        var mt = prev.slice();\n        for (var idx = 0; idx !== MersenneTwister.N - MersenneTwister.M; ++idx) {\n            var y_1 = (mt[idx] & MersenneTwister.MASK_UPPER) + (mt[idx + 1] & MersenneTwister.MASK_LOWER);\n            mt[idx] = mt[idx + MersenneTwister.M] ^ (y_1 >>> 1) ^ (-(y_1 & 1) & MersenneTwister.A);\n        }\n        for (var idx = MersenneTwister.N - MersenneTwister.M; idx !== MersenneTwister.N - 1; ++idx) {\n            var y_2 = (mt[idx] & MersenneTwister.MASK_UPPER) + (mt[idx + 1] & MersenneTwister.MASK_LOWER);\n            mt[idx] = mt[idx + MersenneTwister.M - MersenneTwister.N] ^ (y_2 >>> 1) ^ (-(y_2 & 1) & MersenneTwister.A);\n        }\n        var y = (mt[MersenneTwister.N - 1] & MersenneTwister.MASK_UPPER) + (mt[0] & MersenneTwister.MASK_LOWER);\n        mt[MersenneTwister.N - 1] = mt[MersenneTwister.M - 1] ^ (y >>> 1) ^ (-(y & 1) & MersenneTwister.A);\n        return mt;\n    };\n    MersenneTwister.seeded = function (seed) {\n        var out = Array(MersenneTwister.N);\n        out[0] = seed;\n        for (var idx = 1; idx !== MersenneTwister.N; ++idx) {\n            var xored = out[idx - 1] ^ (out[idx - 1] >>> 30);\n            out[idx] = (Math.imul(MersenneTwister.F, xored) + idx) | 0;\n        }\n        return out;\n    };\n    MersenneTwister.from = function (seed) {\n        return new MersenneTwister(MersenneTwister.twist(MersenneTwister.seeded(seed)), 0);\n    };\n    MersenneTwister.prototype.min = function () {\n        return MersenneTwister.min;\n    };\n    MersenneTwister.prototype.max = function () {\n        return MersenneTwister.max;\n    };\n    MersenneTwister.prototype.clone = function () {\n        return new MersenneTwister(this.states, this.index);\n    };\n    MersenneTwister.prototype.next = function () {\n        var nextRng = new MersenneTwister(this.states, this.index);\n        var out = nextRng.unsafeNext();\n        return [out, nextRng];\n    };\n    MersenneTwister.prototype.unsafeNext = function () {\n        var y = this.states[this.index];\n        y ^= this.states[this.index] >>> MersenneTwister.U;\n        y ^= (y << MersenneTwister.S) & MersenneTwister.B;\n        y ^= (y << MersenneTwister.T) & MersenneTwister.C;\n        y ^= y >>> MersenneTwister.L;\n        if (++this.index >= MersenneTwister.N) {\n            this.states = MersenneTwister.twist(this.states);\n            this.index = 0;\n        }\n        return y >>> 0;\n    };\n    MersenneTwister.min = 0;\n    MersenneTwister.max = 0xffffffff;\n    MersenneTwister.N = 624;\n    MersenneTwister.M = 397;\n    MersenneTwister.R = 31;\n    MersenneTwister.A = 0x9908b0df;\n    MersenneTwister.F = 1812433253;\n    MersenneTwister.U = 11;\n    MersenneTwister.S = 7;\n    MersenneTwister.B = 0x9d2c5680;\n    MersenneTwister.T = 15;\n    MersenneTwister.C = 0xefc60000;\n    MersenneTwister.L = 18;\n    MersenneTwister.MASK_LOWER = Math.pow(2, MersenneTwister.R) - 1;\n    MersenneTwister.MASK_UPPER = Math.pow(2, MersenneTwister.R);\n    return MersenneTwister;\n}());\nexport default function (seed) {\n    return MersenneTwister.from(seed);\n}\n", "var XorShift128Plus = (function () {\n    function XorShift128Plus(s01, s00, s11, s10) {\n        this.s01 = s01;\n        this.s00 = s00;\n        this.s11 = s11;\n        this.s10 = s10;\n    }\n    XorShift128Plus.prototype.min = function () {\n        return -0x80000000;\n    };\n    XorShift128Plus.prototype.max = function () {\n        return 0x7fffffff;\n    };\n    XorShift128Plus.prototype.clone = function () {\n        return new XorShift128Plus(this.s01, this.s00, this.s11, this.s10);\n    };\n    XorShift128Plus.prototype.next = function () {\n        var nextRng = new XorShift128Plus(this.s01, this.s00, this.s11, this.s10);\n        var out = nextRng.unsafeNext();\n        return [out, nextRng];\n    };\n    XorShift128Plus.prototype.unsafeNext = function () {\n        var a0 = this.s00 ^ (this.s00 << 23);\n        var a1 = this.s01 ^ ((this.s01 << 23) | (this.s00 >>> 9));\n        var b0 = a0 ^ this.s10 ^ ((a0 >>> 18) | (a1 << 14)) ^ ((this.s10 >>> 5) | (this.s11 << 27));\n        var b1 = a1 ^ this.s11 ^ (a1 >>> 18) ^ (this.s11 >>> 5);\n        var out = (this.s00 + this.s10) | 0;\n        this.s01 = this.s11;\n        this.s00 = this.s10;\n        this.s11 = b1;\n        this.s10 = b0;\n        return out;\n    };\n    XorShift128Plus.prototype.jump = function () {\n        var nextRng = new XorShift128Plus(this.s01, this.s00, this.s11, this.s10);\n        nextRng.unsafeJump();\n        return nextRng;\n    };\n    XorShift128Plus.prototype.unsafeJump = function () {\n        var ns01 = 0;\n        var ns00 = 0;\n        var ns11 = 0;\n        var ns10 = 0;\n        var jump = [0x635d2dff, 0x8a5cd789, 0x5c472f96, 0x121fd215];\n        for (var i = 0; i !== 4; ++i) {\n            for (var mask = 1; mask; mask <<= 1) {\n                if (jump[i] & mask) {\n                    ns01 ^= this.s01;\n                    ns00 ^= this.s00;\n                    ns11 ^= this.s11;\n                    ns10 ^= this.s10;\n                }\n                this.unsafeNext();\n            }\n        }\n        this.s01 = ns01;\n        this.s00 = ns00;\n        this.s11 = ns11;\n        this.s10 = ns10;\n    };\n    return XorShift128Plus;\n}());\nexport var xorshift128plus = function (seed) {\n    return new XorShift128Plus(-1, ~seed, seed | 0, 0);\n};\n", "var XoroShiro128Plus = (function () {\n    function XoroShiro128Plus(s01, s00, s11, s10) {\n        this.s01 = s01;\n        this.s00 = s00;\n        this.s11 = s11;\n        this.s10 = s10;\n    }\n    XoroShiro128Plus.prototype.min = function () {\n        return -0x80000000;\n    };\n    XoroShiro128Plus.prototype.max = function () {\n        return 0x7fffffff;\n    };\n    XoroShiro128Plus.prototype.clone = function () {\n        return new XoroShiro128Plus(this.s01, this.s00, this.s11, this.s10);\n    };\n    XoroShiro128Plus.prototype.next = function () {\n        var nextRng = new XoroShiro128Plus(this.s01, this.s00, this.s11, this.s10);\n        var out = nextRng.unsafeNext();\n        return [out, nextRng];\n    };\n    XoroShiro128Plus.prototype.unsafeNext = function () {\n        var out = (this.s00 + this.s10) | 0;\n        var a0 = this.s10 ^ this.s00;\n        var a1 = this.s11 ^ this.s01;\n        var s00 = this.s00;\n        var s01 = this.s01;\n        this.s00 = (s00 << 24) ^ (s01 >>> 8) ^ a0 ^ (a0 << 16);\n        this.s01 = (s01 << 24) ^ (s00 >>> 8) ^ a1 ^ ((a1 << 16) | (a0 >>> 16));\n        this.s10 = (a1 << 5) ^ (a0 >>> 27);\n        this.s11 = (a0 << 5) ^ (a1 >>> 27);\n        return out;\n    };\n    XoroShiro128Plus.prototype.jump = function () {\n        var nextRng = new XoroShiro128Plus(this.s01, this.s00, this.s11, this.s10);\n        nextRng.unsafeJump();\n        return nextRng;\n    };\n    XoroShiro128Plus.prototype.unsafeJump = function () {\n        var ns01 = 0;\n        var ns00 = 0;\n        var ns11 = 0;\n        var ns10 = 0;\n        var jump = [0xd8f554a5, 0xdf900294, 0x4b3201fc, 0x170865df];\n        for (var i = 0; i !== 4; ++i) {\n            for (var mask = 1; mask; mask <<= 1) {\n                if (jump[i] & mask) {\n                    ns01 ^= this.s01;\n                    ns00 ^= this.s00;\n                    ns11 ^= this.s11;\n                    ns10 ^= this.s10;\n                }\n                this.unsafeNext();\n            }\n        }\n        this.s01 = ns01;\n        this.s00 = ns00;\n        this.s11 = ns11;\n        this.s10 = ns10;\n    };\n    return XoroShiro128Plus;\n}());\nexport var xoroshiro128plus = function (seed) {\n    return new XoroShiro128Plus(-1, ~seed, seed | 0, 0);\n};\n", "export function addArrayIntToNew(arrayIntA, arrayIntB) {\n    if (arrayIntA.sign !== arrayIntB.sign) {\n        return substractArrayIntToNew(arrayIntA, { sign: -arrayIntB.sign, data: arrayIntB.data });\n    }\n    var data = [];\n    var reminder = 0;\n    var dataA = arrayIntA.data;\n    var dataB = arrayIntB.data;\n    for (var indexA = dataA.length - 1, indexB = dataB.length - 1; indexA >= 0 || indexB >= 0; --indexA, --indexB) {\n        var vA = indexA >= 0 ? dataA[indexA] : 0;\n        var vB = indexB >= 0 ? dataB[indexB] : 0;\n        var current = vA + vB + reminder;\n        data.push(current >>> 0);\n        reminder = ~~(current / 0x100000000);\n    }\n    if (reminder !== 0) {\n        data.push(reminder);\n    }\n    return { sign: arrayIntA.sign, data: data.reverse() };\n}\nexport function addOneToPositiveArrayInt(arrayInt) {\n    arrayInt.sign = 1;\n    var data = arrayInt.data;\n    for (var index = data.length - 1; index >= 0; --index) {\n        if (data[index] === 0xffffffff) {\n            data[index] = 0;\n        }\n        else {\n            data[index] += 1;\n            return arrayInt;\n        }\n    }\n    data.unshift(1);\n    return arrayInt;\n}\nfunction isStrictlySmaller(dataA, dataB) {\n    var maxLength = Math.max(dataA.length, dataB.length);\n    for (var index = 0; index < maxLength; ++index) {\n        var indexA = index + dataA.length - maxLength;\n        var indexB = index + dataB.length - maxLength;\n        var vA = indexA >= 0 ? dataA[indexA] : 0;\n        var vB = indexB >= 0 ? dataB[indexB] : 0;\n        if (vA < vB)\n            return true;\n        if (vA > vB)\n            return false;\n    }\n    return false;\n}\nexport function substractArrayIntToNew(arrayIntA, arrayIntB) {\n    if (arrayIntA.sign !== arrayIntB.sign) {\n        return addArrayIntToNew(arrayIntA, { sign: -arrayIntB.sign, data: arrayIntB.data });\n    }\n    var dataA = arrayIntA.data;\n    var dataB = arrayIntB.data;\n    if (isStrictlySmaller(dataA, dataB)) {\n        var out = substractArrayIntToNew(arrayIntB, arrayIntA);\n        out.sign = -out.sign;\n        return out;\n    }\n    var data = [];\n    var reminder = 0;\n    for (var indexA = dataA.length - 1, indexB = dataB.length - 1; indexA >= 0 || indexB >= 0; --indexA, --indexB) {\n        var vA = indexA >= 0 ? dataA[indexA] : 0;\n        var vB = indexB >= 0 ? dataB[indexB] : 0;\n        var current = vA - vB - reminder;\n        data.push(current >>> 0);\n        reminder = current < 0 ? 1 : 0;\n    }\n    return { sign: arrayIntA.sign, data: data.reverse() };\n}\nexport function trimArrayIntInplace(arrayInt) {\n    var data = arrayInt.data;\n    var firstNonZero = 0;\n    for (; firstNonZero !== data.length && data[firstNonZero] === 0; ++firstNonZero) { }\n    if (firstNonZero === data.length) {\n        arrayInt.sign = 1;\n        arrayInt.data = [0];\n        return arrayInt;\n    }\n    data.splice(0, firstNonZero);\n    return arrayInt;\n}\nexport function fromNumberToArrayInt64(out, n) {\n    if (n < 0) {\n        var posN = -n;\n        out.sign = -1;\n        out.data[0] = ~~(posN / 0x100000000);\n        out.data[1] = posN >>> 0;\n    }\n    else {\n        out.sign = 1;\n        out.data[0] = ~~(n / 0x100000000);\n        out.data[1] = n >>> 0;\n    }\n    return out;\n}\nexport function substractArrayInt64(out, arrayIntA, arrayIntB) {\n    var lowA = arrayIntA.data[1];\n    var highA = arrayIntA.data[0];\n    var signA = arrayIntA.sign;\n    var lowB = arrayIntB.data[1];\n    var highB = arrayIntB.data[0];\n    var signB = arrayIntB.sign;\n    out.sign = 1;\n    if (signA === 1 && signB === -1) {\n        var low_1 = lowA + lowB;\n        var high = highA + highB + (low_1 > 0xffffffff ? 1 : 0);\n        out.data[0] = high >>> 0;\n        out.data[1] = low_1 >>> 0;\n        return out;\n    }\n    var lowFirst = lowA;\n    var highFirst = highA;\n    var lowSecond = lowB;\n    var highSecond = highB;\n    if (signA === -1) {\n        lowFirst = lowB;\n        highFirst = highB;\n        lowSecond = lowA;\n        highSecond = highA;\n    }\n    var reminderLow = 0;\n    var low = lowFirst - lowSecond;\n    if (low < 0) {\n        reminderLow = 1;\n        low = low >>> 0;\n    }\n    out.data[0] = highFirst - highSecond - reminderLow;\n    out.data[1] = low;\n    return out;\n}\n", "export function unsafeUniformIntDistributionInternal(rangeSize, rng) {\n    var MinRng = rng.min();\n    var NumValues = rng.max() - rng.min() + 1;\n    if (rangeSize <= NumValues) {\n        var nrng_1 = rng;\n        var MaxAllowed = NumValues - (NumValues % rangeSize);\n        while (true) {\n            var out = nrng_1.unsafeNext();\n            var deltaV = out - MinRng;\n            if (deltaV < MaxAllowed) {\n                return deltaV % rangeSize;\n            }\n        }\n    }\n    var FinalNumValues = NumValues * NumValues;\n    var NumIterations = 2;\n    while (FinalNumValues < rangeSize) {\n        FinalNumValues *= NumValues;\n        ++NumIterations;\n    }\n    var MaxAcceptedRandom = rangeSize * Math.floor((1 * FinalNumValues) / rangeSize);\n    var nrng = rng;\n    while (true) {\n        var value = 0;\n        for (var num = 0; num !== NumIterations; ++num) {\n            var out = nrng.unsafeNext();\n            value = NumValues * value + (out - MinRng);\n        }\n        if (value < MaxAcceptedRandom) {\n            var inDiff = value - rangeSize * Math.floor((1 * value) / rangeSize);\n            return inDiff;\n        }\n    }\n}\n", "import { unsafeUniformIntDistributionInternal } from './UnsafeUniformIntDistributionInternal.js';\nexport function unsafeUniformArrayIntDistributionInternal(out, rangeSize, rng) {\n    var rangeLength = rangeSize.length;\n    while (true) {\n        for (var index = 0; index !== rangeLength; ++index) {\n            var indexRangeSize = index === 0 ? rangeSize[0] + 1 : 0x100000000;\n            var g = unsafeUniformIntDistributionInternal(indexRangeSize, rng);\n            out[index] = g;\n        }\n        for (var index = 0; index !== rangeLength; ++index) {\n            var current = out[index];\n            var currentInRange = rangeSize[index];\n            if (current < currentInRange) {\n                return out;\n            }\n            else if (current > currentInRange) {\n                break;\n            }\n        }\n    }\n}\n", "import { addArrayIntToNew, addOneToPositiveArrayInt, substractArrayIntToNew, trimArrayIntInplace, } from './internals/ArrayInt.js';\nimport { unsafeUniformArrayIntDistributionInternal } from './internals/UnsafeUniformArrayIntDistributionInternal.js';\nexport function unsafeUniformArrayIntDistribution(from, to, rng) {\n    var rangeSize = trimArrayIntInplace(addOneToPositiveArrayInt(substractArrayIntToNew(to, from)));\n    var emptyArrayIntData = rangeSize.data.slice(0);\n    var g = unsafeUniformArrayIntDistributionInternal(emptyArrayIntData, rangeSize.data, rng);\n    return trimArrayIntInplace(addArrayIntToNew({ sign: 1, data: g }, from));\n}\n", "import { unsafeUniformArrayIntDistribution } from './UnsafeUniformArrayIntDistribution.js';\nfunction uniformArrayIntDistribution(from, to, rng) {\n    if (rng != null) {\n        var nextRng = rng.clone();\n        return [unsafeUniformArrayIntDistribution(from, to, nextRng), nextRng];\n    }\n    return function (rng) {\n        var nextRng = rng.clone();\n        return [unsafeUniformArrayIntDistribution(from, to, nextRng), nextRng];\n    };\n}\nexport { uniformArrayIntDistribution };\n", "export function unsafeUniformBigIntDistribution(from, to, rng) {\n    var diff = to - from + BigInt(1);\n    var MinRng = BigInt(rng.min());\n    var NumValues = BigInt(rng.max() - rng.min() + 1);\n    var FinalNumValues = NumValues;\n    var NumIterations = BigInt(1);\n    while (FinalNumValues < diff) {\n        FinalNumValues *= NumValues;\n        ++NumIterations;\n    }\n    var MaxAcceptedRandom = FinalNumValues - (FinalNumValues % diff);\n    while (true) {\n        var value = BigInt(0);\n        for (var num = BigInt(0); num !== NumIterations; ++num) {\n            var out = rng.unsafeNext();\n            value = NumValues * value + (BigInt(out) - MinRng);\n        }\n        if (value < MaxAcceptedRandom) {\n            var inDiff = value % diff;\n            return inDiff + from;\n        }\n    }\n}\n", "import { unsafeUniformBigIntDistribution } from './UnsafeUniformBigIntDistribution.js';\nfunction uniformBigIntDistribution(from, to, rng) {\n    if (rng != null) {\n        var nextRng = rng.clone();\n        return [unsafeUniformBigIntDistribution(from, to, nextRng), nextRng];\n    }\n    return function (rng) {\n        var nextRng = rng.clone();\n        return [unsafeUniformBigIntDistribution(from, to, nextRng), nextRng];\n    };\n}\nexport { uniformBigIntDistribution };\n", "import { unsafeUniformIntDistributionInternal } from './internals/UnsafeUniformIntDistributionInternal.js';\nimport { fromNumberToArrayInt64, substractArrayInt64 } from './internals/ArrayInt.js';\nimport { unsafeUniformArrayIntDistributionInternal } from './internals/UnsafeUniformArrayIntDistributionInternal.js';\nvar sharedA = { sign: 1, data: [0, 0] };\nvar sharedB = { sign: 1, data: [0, 0] };\nvar sharedC = { sign: 1, data: [0, 0] };\nvar sharedData = [0, 0];\nfunction uniformLargeIntInternal(from, to, rangeSize, rng) {\n    var rangeSizeArrayIntValue = rangeSize <= Number.MAX_SAFE_INTEGER\n        ? fromNumberToArrayInt64(sharedC, rangeSize)\n        : substractArrayInt64(sharedC, fromNumberToArrayInt64(sharedA, to), fromNumberToArrayInt64(sharedB, from));\n    if (rangeSizeArrayIntValue.data[1] === 0xffffffff) {\n        rangeSizeArrayIntValue.data[0] += 1;\n        rangeSizeArrayIntValue.data[1] = 0;\n    }\n    else {\n        rangeSizeArrayIntValue.data[1] += 1;\n    }\n    unsafeUniformArrayIntDistributionInternal(sharedData, rangeSizeArrayIntValue.data, rng);\n    return sharedData[0] * 0x100000000 + sharedData[1] + from;\n}\nexport function unsafeUniformIntDistribution(from, to, rng) {\n    var rangeSize = to - from;\n    if (rangeSize <= 0xffffffff) {\n        var g = unsafeUniformIntDistributionInternal(rangeSize + 1, rng);\n        return g + from;\n    }\n    return uniformLargeIntInternal(from, to, rangeSize, rng);\n}\n", "import { unsafeUniformIntDistribution } from './UnsafeUniformIntDistribution.js';\nfunction uniformIntDistribution(from, to, rng) {\n    if (rng != null) {\n        var nextRng = rng.clone();\n        return [unsafeUniformIntDistribution(from, to, nextRng), nextRng];\n    }\n    return function (rng) {\n        var nextRng = rng.clone();\n        return [unsafeUniformIntDistribution(from, to, nextRng), nextRng];\n    };\n}\nexport { uniformIntDistribution };\n", "import { generateN, skipN, unsafeGenerateN, unsafeSkipN } from './generator/RandomGenerator.js';\nimport { congruential, congruential32 } from './generator/LinearCongruential.js';\nimport mersenne from './generator/MersenneTwister.js';\nimport { xorshift128plus } from './generator/XorShift.js';\nimport { xoroshiro128plus } from './generator/XoroShiro.js';\nimport { uniformArrayIntDistribution } from './distribution/UniformArrayIntDistribution.js';\nimport { uniformBigIntDistribution } from './distribution/UniformBigIntDistribution.js';\nimport { uniformIntDistribution } from './distribution/UniformIntDistribution.js';\nimport { unsafeUniformArrayIntDistribution } from './distribution/UnsafeUniformArrayIntDistribution.js';\nimport { unsafeUniformBigIntDistribution } from './distribution/UnsafeUniformBigIntDistribution.js';\nimport { unsafeUniformIntDistribution } from './distribution/UnsafeUniformIntDistribution.js';\nvar __type = 'module';\nvar __version = '5.0.0';\nvar __commitHash = '744555855a01e1551ab1cf67a6ea973d14964661';\nexport { __type, __version, __commitHash, generateN, skipN, unsafeGenerateN, unsafeSkipN, congruential, congruential32, mersenne, xorshift128plus, xoroshiro128plus, uniformArrayIntDistribution, uniformBigIntDistribution, uniformIntDistribution, unsafeUniformArrayIntDistribution, unsafeUniformBigIntDistribution, unsafeUniformIntDistribution, };\n", "import * as prand from './pure-rand-default.js';\nexport default prand;\nexport * from './pure-rand-default.js';\n", "export var VerbosityLevel;\n(function (VerbosityLevel) {\n    VerbosityLevel[VerbosityLevel[\"None\"] = 0] = \"None\";\n    VerbosityLevel[VerbosityLevel[\"Verbose\"] = 1] = \"Verbose\";\n    VerbosityLevel[VerbosityLevel[\"VeryVerbose\"] = 2] = \"VeryVerbose\";\n})(VerbosityLevel || (VerbosityLevel = {}));\n", "import prand from 'pure-rand';\nimport { VerbosityLevel } from './VerbosityLevel.js';\nexport class QualifiedParameters {\n    constructor(op) {\n        const p = op || {};\n        this.seed = QualifiedParameters.readSeed(p);\n        this.randomType = QualifiedParameters.readRandomType(p);\n        this.numRuns = QualifiedParameters.readNumRuns(p);\n        this.verbose = QualifiedParameters.readVerbose(p);\n        this.maxSkipsPerRun = QualifiedParameters.readOrDefault(p, 'maxSkipsPerRun', 100);\n        this.timeout = QualifiedParameters.readOrDefault(p, 'timeout', null);\n        this.skipAllAfterTimeLimit = QualifiedParameters.readOrDefault(p, 'skipAllAfterTimeLimit', null);\n        this.interruptAfterTimeLimit = QualifiedParameters.readOrDefault(p, 'interruptAfterTimeLimit', null);\n        this.markInterruptAsFailure = QualifiedParameters.readBoolean(p, 'markInterruptAsFailure');\n        this.skipEqualValues = QualifiedParameters.readBoolean(p, 'skipEqualValues');\n        this.ignoreEqualValues = QualifiedParameters.readBoolean(p, 'ignoreEqualValues');\n        this.logger = QualifiedParameters.readOrDefault(p, 'logger', (v) => {\n            console.log(v);\n        });\n        this.path = QualifiedParameters.readOrDefault(p, 'path', '');\n        this.unbiased = QualifiedParameters.readBoolean(p, 'unbiased');\n        this.examples = QualifiedParameters.readOrDefault(p, 'examples', []);\n        this.endOnFailure = QualifiedParameters.readBoolean(p, 'endOnFailure');\n        this.reporter = QualifiedParameters.readOrDefault(p, 'reporter', null);\n        this.asyncReporter = QualifiedParameters.readOrDefault(p, 'asyncReporter', null);\n    }\n    toParameters() {\n        const orUndefined = (value) => (value !== null ? value : undefined);\n        return {\n            seed: this.seed,\n            randomType: this.randomType,\n            numRuns: this.numRuns,\n            maxSkipsPerRun: this.maxSkipsPerRun,\n            timeout: orUndefined(this.timeout),\n            skipAllAfterTimeLimit: orUndefined(this.skipAllAfterTimeLimit),\n            interruptAfterTimeLimit: orUndefined(this.interruptAfterTimeLimit),\n            markInterruptAsFailure: this.markInterruptAsFailure,\n            skipEqualValues: this.skipEqualValues,\n            ignoreEqualValues: this.ignoreEqualValues,\n            path: this.path,\n            logger: this.logger,\n            unbiased: this.unbiased,\n            verbose: this.verbose,\n            examples: this.examples,\n            endOnFailure: this.endOnFailure,\n            reporter: orUndefined(this.reporter),\n            asyncReporter: orUndefined(this.asyncReporter),\n        };\n    }\n    static read(op) {\n        return new QualifiedParameters(op);\n    }\n}\nQualifiedParameters.readSeed = (p) => {\n    if (p.seed == null)\n        return Date.now() ^ (Math.random() * 0x100000000);\n    const seed32 = p.seed | 0;\n    if (p.seed === seed32)\n        return seed32;\n    const gap = p.seed - seed32;\n    return seed32 ^ (gap * 0x100000000);\n};\nQualifiedParameters.readRandomType = (p) => {\n    if (p.randomType == null)\n        return prand.xorshift128plus;\n    if (typeof p.randomType === 'string') {\n        switch (p.randomType) {\n            case 'mersenne':\n                return prand.mersenne;\n            case 'congruential':\n                return prand.congruential;\n            case 'congruential32':\n                return prand.congruential32;\n            case 'xorshift128plus':\n                return prand.xorshift128plus;\n            case 'xoroshiro128plus':\n                return prand.xoroshiro128plus;\n            default:\n                throw new Error(`Invalid random specified: '${p.randomType}'`);\n        }\n    }\n    return p.randomType;\n};\nQualifiedParameters.readNumRuns = (p) => {\n    const defaultValue = 100;\n    if (p.numRuns != null)\n        return p.numRuns;\n    if (p.num_runs != null)\n        return p.num_runs;\n    return defaultValue;\n};\nQualifiedParameters.readVerbose = (p) => {\n    if (p.verbose == null)\n        return VerbosityLevel.None;\n    if (typeof p.verbose === 'boolean') {\n        return p.verbose === true ? VerbosityLevel.Verbose : VerbosityLevel.None;\n    }\n    if (p.verbose <= VerbosityLevel.None) {\n        return VerbosityLevel.None;\n    }\n    if (p.verbose >= VerbosityLevel.VeryVerbose) {\n        return VerbosityLevel.VeryVerbose;\n    }\n    return p.verbose | 0;\n};\nQualifiedParameters.readBoolean = (p, key) => p[key] === true;\nQualifiedParameters.readOrDefault = (p, key, defaultValue) => {\n    const value = p[key];\n    return value != null ? value : defaultValue;\n};\n", "import { PreconditionFailure } from '../precondition/PreconditionFailure.js';\nexport class SkipAfterProperty {\n    constructor(property, getTime, timeLimit, interruptExecution) {\n        this.property = property;\n        this.getTime = getTime;\n        this.interruptExecution = interruptExecution;\n        this.isAsync = () => this.property.isAsync();\n        this.generate = (mrng, runId) => this.property.generate(mrng, runId);\n        this.run = (v) => {\n            if (this.getTime() >= this.skipAfterTime) {\n                const preconditionFailure = new PreconditionFailure(this.interruptExecution);\n                if (this.isAsync()) {\n                    return Promise.resolve(preconditionFailure);\n                }\n                else {\n                    return preconditionFailure;\n                }\n            }\n            return this.property.run(v);\n        };\n        this.skipAfterTime = this.getTime() + timeLimit;\n    }\n}\n", "const timeoutAfter = (timeMs) => {\n    let timeoutHandle = null;\n    const promise = new Promise((resolve) => {\n        timeoutHandle = setTimeout(() => {\n            resolve(`Property timeout: exceeded limit of ${timeMs} milliseconds`);\n        }, timeMs);\n    });\n    return {\n        clear: () => clearTimeout(timeoutHandle),\n        promise,\n    };\n};\nexport class TimeoutProperty {\n    constructor(property, timeMs) {\n        this.property = property;\n        this.timeMs = timeMs;\n        this.isAsync = () => true;\n    }\n    generate(mrng, runId) {\n        return this.property.generate(mrng, runId);\n    }\n    async run(v) {\n        const t = timeoutAfter(this.timeMs);\n        const propRun = Promise.race([this.property.run(v), t.promise]);\n        propRun.then(t.clear, t.clear);\n        return propRun;\n    }\n}\n", "export class UnbiasedProperty {\n    constructor(property) {\n        this.property = property;\n        this.isAsync = () => this.property.isAsync();\n        this.generate = (mrng, _runId) => this.property.generate(mrng);\n        this.run = (v) => this.property.run(v);\n    }\n}\n", "export const toStringMethod = Symbol('fast-check/toStringMethod');\nexport function hasToStringMethod(instance) {\n    return (instance !== null &&\n        (typeof instance === 'object' || typeof instance === 'function') &&\n        toStringMethod in instance &&\n        typeof instance[toStringMethod] === 'function');\n}\nexport const asyncToStringMethod = Symbol('fast-check/asyncToStringMethod');\nexport function hasAsyncToStringMethod(instance) {\n    return (instance !== null &&\n        (typeof instance === 'object' || typeof instance === 'function') &&\n        asyncToStringMethod in instance &&\n        typeof instance[asyncToStringMethod] === 'function');\n}\nconst findSymbolNameRegex = /^Symbol\\((.*)\\)$/;\nfunction getSymbolDescription(s) {\n    if (s.description !== undefined)\n        return s.description;\n    const m = findSymbolNameRegex.exec(String(s));\n    return m && m[1].length ? m[1] : null;\n}\nfunction stringifyNumber(numValue) {\n    switch (numValue) {\n        case 0:\n            return 1 / numValue === Number.NEGATIVE_INFINITY ? '-0' : '0';\n        case Number.NEGATIVE_INFINITY:\n            return 'Number.NEGATIVE_INFINITY';\n        case Number.POSITIVE_INFINITY:\n            return 'Number.POSITIVE_INFINITY';\n        default:\n            return numValue === numValue ? String(numValue) : 'Number.NaN';\n    }\n}\nfunction isSparseArray(arr) {\n    let previousNumberedIndex = -1;\n    for (const index in arr) {\n        const numberedIndex = Number(index);\n        if (numberedIndex !== previousNumberedIndex + 1)\n            return true;\n        previousNumberedIndex = numberedIndex;\n    }\n    return previousNumberedIndex + 1 !== arr.length;\n}\nexport function stringifyInternal(value, previousValues, getAsyncContent) {\n    const currentValues = previousValues.concat([value]);\n    if (typeof value === 'object') {\n        if (previousValues.indexOf(value) !== -1) {\n            return '[cyclic]';\n        }\n    }\n    if (hasAsyncToStringMethod(value)) {\n        const content = getAsyncContent(value);\n        if (content.state === 'fulfilled') {\n            return content.value;\n        }\n    }\n    if (hasToStringMethod(value)) {\n        try {\n            return value[toStringMethod]();\n        }\n        catch (err) {\n        }\n    }\n    switch (Object.prototype.toString.call(value)) {\n        case '[object Array]': {\n            const arr = value;\n            if (arr.length >= 50 && isSparseArray(arr)) {\n                const assignments = [];\n                for (const index in arr) {\n                    if (!Number.isNaN(Number(index)))\n                        assignments.push(`${index}:${stringifyInternal(arr[index], currentValues, getAsyncContent)}`);\n                }\n                return assignments.length !== 0\n                    ? `Object.assign(Array(${arr.length}),{${assignments.join(',')}})`\n                    : `Array(${arr.length})`;\n            }\n            const stringifiedArray = arr.map((v) => stringifyInternal(v, currentValues, getAsyncContent)).join(',');\n            return arr.length === 0 || arr.length - 1 in arr ? `[${stringifiedArray}]` : `[${stringifiedArray},]`;\n        }\n        case '[object BigInt]':\n            return `${value}n`;\n        case '[object Boolean]':\n            return typeof value === 'boolean' ? JSON.stringify(value) : `new Boolean(${JSON.stringify(value)})`;\n        case '[object Date]': {\n            const d = value;\n            return Number.isNaN(d.getTime()) ? `new Date(NaN)` : `new Date(${JSON.stringify(d.toISOString())})`;\n        }\n        case '[object Map]':\n            return `new Map(${stringifyInternal(Array.from(value), currentValues, getAsyncContent)})`;\n        case '[object Null]':\n            return `null`;\n        case '[object Number]':\n            return typeof value === 'number' ? stringifyNumber(value) : `new Number(${stringifyNumber(Number(value))})`;\n        case '[object Object]': {\n            try {\n                const toStringAccessor = value.toString;\n                if (typeof toStringAccessor === 'function' && toStringAccessor !== Object.prototype.toString) {\n                    return value.toString();\n                }\n            }\n            catch (err) {\n                return '[object Object]';\n            }\n            const mapper = (k) => `${k === '__proto__'\n                ? '[\"__proto__\"]'\n                : typeof k === 'symbol'\n                    ? `[${stringifyInternal(k, currentValues, getAsyncContent)}]`\n                    : JSON.stringify(k)}:${stringifyInternal(value[k], currentValues, getAsyncContent)}`;\n            const stringifiedProperties = [\n                ...Object.keys(value).map(mapper),\n                ...Object.getOwnPropertySymbols(value)\n                    .filter((s) => {\n                    const descriptor = Object.getOwnPropertyDescriptor(value, s);\n                    return descriptor && descriptor.enumerable;\n                })\n                    .map(mapper),\n            ];\n            const rawRepr = '{' + stringifiedProperties.join(',') + '}';\n            if (Object.getPrototypeOf(value) === null) {\n                return rawRepr === '{}' ? 'Object.create(null)' : `Object.assign(Object.create(null),${rawRepr})`;\n            }\n            return rawRepr;\n        }\n        case '[object Set]':\n            return `new Set(${stringifyInternal(Array.from(value), currentValues, getAsyncContent)})`;\n        case '[object String]':\n            return typeof value === 'string' ? JSON.stringify(value) : `new String(${JSON.stringify(value)})`;\n        case '[object Symbol]': {\n            const s = value;\n            if (Symbol.keyFor(s) !== undefined) {\n                return `Symbol.for(${JSON.stringify(Symbol.keyFor(s))})`;\n            }\n            const desc = getSymbolDescription(s);\n            if (desc === null) {\n                return 'Symbol()';\n            }\n            const knownSymbol = desc.startsWith('Symbol.') && Symbol[desc.substring(7)];\n            return s === knownSymbol ? desc : `Symbol(${JSON.stringify(desc)})`;\n        }\n        case '[object Promise]': {\n            const promiseContent = getAsyncContent(value);\n            switch (promiseContent.state) {\n                case 'fulfilled':\n                    return `Promise.resolve(${stringifyInternal(promiseContent.value, currentValues, getAsyncContent)})`;\n                case 'rejected':\n                    return `Promise.reject(${stringifyInternal(promiseContent.value, currentValues, getAsyncContent)})`;\n                case 'pending':\n                    return `new Promise(() => {/*pending*/})`;\n                case 'unknown':\n                default:\n                    return `new Promise(() => {/*unknown*/})`;\n            }\n        }\n        case '[object Error]':\n            if (value instanceof Error) {\n                return `new Error(${stringifyInternal(value.message, currentValues, getAsyncContent)})`;\n            }\n            break;\n        case '[object Undefined]':\n            return `undefined`;\n        case '[object Int8Array]':\n        case '[object Uint8Array]':\n        case '[object Uint8ClampedArray]':\n        case '[object Int16Array]':\n        case '[object Uint16Array]':\n        case '[object Int32Array]':\n        case '[object Uint32Array]':\n        case '[object Float32Array]':\n        case '[object Float64Array]':\n        case '[object BigInt64Array]':\n        case '[object BigUint64Array]': {\n            if (typeof Buffer !== 'undefined' && typeof Buffer.isBuffer === 'function' && Buffer.isBuffer(value)) {\n                return `Buffer.from(${stringifyInternal(Array.from(value.values()), currentValues, getAsyncContent)})`;\n            }\n            const valuePrototype = Object.getPrototypeOf(value);\n            const className = valuePrototype && valuePrototype.constructor && valuePrototype.constructor.name;\n            if (typeof className === 'string') {\n                const typedArray = value;\n                const valuesFromTypedArr = typedArray.values();\n                return `${className}.from(${stringifyInternal(Array.from(valuesFromTypedArr), currentValues, getAsyncContent)})`;\n            }\n            break;\n        }\n    }\n    try {\n        return value.toString();\n    }\n    catch (_a) {\n        return Object.prototype.toString.call(value);\n    }\n}\nexport function stringify(value) {\n    return stringifyInternal(value, [], () => ({ state: 'unknown', value: undefined }));\n}\nexport function possiblyAsyncStringify(value) {\n    const stillPendingMarker = Symbol();\n    const pendingPromisesForCache = [];\n    const cache = new Map();\n    function createDelay0() {\n        let handleId = null;\n        const cancel = () => {\n            if (handleId !== null) {\n                clearTimeout(handleId);\n            }\n        };\n        const delay = new Promise((resolve) => {\n            handleId = setTimeout(() => {\n                handleId = null;\n                resolve(stillPendingMarker);\n            }, 0);\n        });\n        return { delay, cancel };\n    }\n    const unknownState = { state: 'unknown', value: undefined };\n    const getAsyncContent = function getAsyncContent(data) {\n        const cacheKey = data;\n        if (cache.has(cacheKey)) {\n            return cache.get(cacheKey);\n        }\n        const delay0 = createDelay0();\n        const p = asyncToStringMethod in data\n            ? Promise.resolve().then(() => data[asyncToStringMethod]())\n            : data;\n        p.catch(() => { });\n        pendingPromisesForCache.push(Promise.race([p, delay0.delay]).then((successValue) => {\n            if (successValue === stillPendingMarker)\n                cache.set(cacheKey, { state: 'pending', value: undefined });\n            else\n                cache.set(cacheKey, { state: 'fulfilled', value: successValue });\n            delay0.cancel();\n        }, (errorValue) => {\n            cache.set(cacheKey, { state: 'rejected', value: errorValue });\n            delay0.cancel();\n        }));\n        cache.set(cacheKey, unknownState);\n        return unknownState;\n    };\n    function loop() {\n        const stringifiedValue = stringifyInternal(value, [], getAsyncContent);\n        if (pendingPromisesForCache.length === 0) {\n            return stringifiedValue;\n        }\n        return Promise.all(pendingPromisesForCache.splice(0)).then(loop);\n    }\n    return loop();\n}\nexport async function asyncStringify(value) {\n    return Promise.resolve(possiblyAsyncStringify(value));\n}\n", "import { stringify } from '../../utils/stringify.js';\nimport { PreconditionFailure } from '../precondition/PreconditionFailure.js';\nfunction fromSyncCached(cachedValue) {\n    return cachedValue === null ? new PreconditionFailure() : cachedValue;\n}\nfunction fromCached(...data) {\n    if (data[1])\n        return data[0].then(fromSyncCached);\n    return fromSyncCached(data[0]);\n}\nfunction fromCachedUnsafe(cachedValue, isAsync) {\n    return fromCached(cachedValue, isAsync);\n}\nexport class IgnoreEqualValuesProperty {\n    constructor(property, skipRuns) {\n        this.property = property;\n        this.skipRuns = skipRuns;\n        this.coveredCases = new Map();\n        this.isAsync = () => this.property.isAsync();\n        this.generate = (mrng, runId) => this.property.generate(mrng, runId);\n        this.run = (v) => {\n            const stringifiedValue = stringify(v);\n            if (this.coveredCases.has(stringifiedValue)) {\n                const lastOutput = this.coveredCases.get(stringifiedValue);\n                if (!this.skipRuns) {\n                    return lastOutput;\n                }\n                return fromCachedUnsafe(lastOutput, this.property.isAsync());\n            }\n            const out = this.property.run(v);\n            this.coveredCases.set(stringifiedValue, out);\n            return out;\n        };\n    }\n}\n", "import { SkipAfterProperty } from '../property/SkipAfterProperty.js';\nimport { TimeoutProperty } from '../property/TimeoutProperty.js';\nimport { UnbiasedProperty } from '../property/UnbiasedProperty.js';\nimport { IgnoreEqualValuesProperty } from '../property/IgnoreEqualValuesProperty.js';\nexport function decorateProperty(rawProperty, qParams) {\n    let prop = rawProperty;\n    if (rawProperty.isAsync() && qParams.timeout != null) {\n        prop = new TimeoutProperty(prop, qParams.timeout);\n    }\n    if (qParams.unbiased) {\n        prop = new UnbiasedProperty(prop);\n    }\n    if (qParams.skipAllAfterTimeLimit != null) {\n        prop = new SkipAfterProperty(prop, Date.now, qParams.skipAllAfterTimeLimit, false);\n    }\n    if (qParams.interruptAfterTimeLimit != null) {\n        prop = new SkipAfterProperty(prop, Date.now, qParams.interruptAfterTimeLimit, true);\n    }\n    if (qParams.skipEqualValues) {\n        prop = new IgnoreEqualValuesProperty(prop, true);\n    }\n    if (qParams.ignoreEqualValues) {\n        prop = new IgnoreEqualValuesProperty(prop, false);\n    }\n    return prop;\n}\n", "export var ExecutionStatus;\n(function (ExecutionStatus) {\n    ExecutionStatus[ExecutionStatus[\"Success\"] = 0] = \"Success\";\n    ExecutionStatus[ExecutionStatus[\"Skipped\"] = -1] = \"Skipped\";\n    ExecutionStatus[ExecutionStatus[\"Failure\"] = 1] = \"Failure\";\n})(ExecutionStatus || (ExecutionStatus = {}));\n", "import { VerbosityLevel } from '../configuration/VerbosityLevel.js';\nimport { ExecutionStatus } from './ExecutionStatus.js';\nexport class RunExecution {\n    constructor(verbosity, interruptedAsFailure) {\n        this.verbosity = verbosity;\n        this.interruptedAsFailure = interruptedAsFailure;\n        this.isSuccess = () => this.pathToFailure == null;\n        this.firstFailure = () => (this.pathToFailure ? +this.pathToFailure.split(':')[0] : -1);\n        this.numShrinks = () => (this.pathToFailure ? this.pathToFailure.split(':').length - 1 : 0);\n        this.rootExecutionTrees = [];\n        this.currentLevelExecutionTrees = this.rootExecutionTrees;\n        this.failure = null;\n        this.numSkips = 0;\n        this.numSuccesses = 0;\n        this.interrupted = false;\n    }\n    appendExecutionTree(status, value) {\n        const currentTree = { status, value, children: [] };\n        this.currentLevelExecutionTrees.push(currentTree);\n        return currentTree;\n    }\n    fail(value, id, message) {\n        if (this.verbosity >= VerbosityLevel.Verbose) {\n            const currentTree = this.appendExecutionTree(ExecutionStatus.Failure, value);\n            this.currentLevelExecutionTrees = currentTree.children;\n        }\n        if (this.pathToFailure == null)\n            this.pathToFailure = `${id}`;\n        else\n            this.pathToFailure += `:${id}`;\n        this.value = value;\n        this.failure = message;\n    }\n    skip(value) {\n        if (this.verbosity >= VerbosityLevel.VeryVerbose) {\n            this.appendExecutionTree(ExecutionStatus.Skipped, value);\n        }\n        if (this.pathToFailure == null) {\n            ++this.numSkips;\n        }\n    }\n    success(value) {\n        if (this.verbosity >= VerbosityLevel.VeryVerbose) {\n            this.appendExecutionTree(ExecutionStatus.Success, value);\n        }\n        if (this.pathToFailure == null) {\n            ++this.numSuccesses;\n        }\n    }\n    interrupt() {\n        this.interrupted = true;\n    }\n    extractFailures() {\n        if (this.isSuccess()) {\n            return [];\n        }\n        const failures = [];\n        let cursor = this.rootExecutionTrees;\n        while (cursor.length > 0 && cursor[cursor.length - 1].status === ExecutionStatus.Failure) {\n            const failureTree = cursor[cursor.length - 1];\n            failures.push(failureTree.value);\n            cursor = failureTree.children;\n        }\n        return failures;\n    }\n    toRunDetails(seed, basePath, maxSkips, qParams) {\n        if (!this.isSuccess()) {\n            return {\n                failed: true,\n                interrupted: this.interrupted,\n                numRuns: this.firstFailure() + 1 - this.numSkips,\n                numSkips: this.numSkips,\n                numShrinks: this.numShrinks(),\n                seed,\n                counterexample: this.value,\n                counterexamplePath: RunExecution.mergePaths(basePath, this.pathToFailure),\n                error: this.failure,\n                failures: this.extractFailures(),\n                executionSummary: this.rootExecutionTrees,\n                verbose: this.verbosity,\n                runConfiguration: qParams.toParameters(),\n            };\n        }\n        const failed = this.numSkips > maxSkips || (this.interrupted && this.interruptedAsFailure);\n        return {\n            failed,\n            interrupted: this.interrupted,\n            numRuns: this.numSuccesses,\n            numSkips: this.numSkips,\n            numShrinks: 0,\n            seed,\n            counterexample: null,\n            counterexamplePath: null,\n            error: null,\n            failures: [],\n            executionSummary: this.rootExecutionTrees,\n            verbose: this.verbosity,\n            runConfiguration: qParams.toParameters(),\n        };\n    }\n}\nRunExecution.mergePaths = (offsetPath, path) => {\n    if (offsetPath.length === 0)\n        return path;\n    const offsetItems = offsetPath.split(':');\n    const remainingItems = path.split(':');\n    const middle = +offsetItems[offsetItems.length - 1] + +remainingItems[0];\n    return [...offsetItems.slice(0, offsetItems.length - 1), `${middle}`, ...remainingItems.slice(1)].join(':');\n};\n", "import { RunExecution } from './reporter/RunExecution.js';\nexport class RunnerIterator {\n    constructor(sourceValues, verbose, interruptedAsFailure) {\n        this.sourceValues = sourceValues;\n        this.runExecution = new RunExecution(verbose, interruptedAsFailure);\n        this.currentIdx = -1;\n        this.nextValues = sourceValues;\n    }\n    [Symbol.iterator]() {\n        return this;\n    }\n    next() {\n        const nextValue = this.nextValues.next();\n        if (nextValue.done || this.runExecution.interrupted) {\n            return { done: true, value: undefined };\n        }\n        this.currentShrinkable = nextValue.value;\n        ++this.currentIdx;\n        return { done: false, value: nextValue.value.value_ };\n    }\n    handleResult(result) {\n        if (result != null && typeof result === 'string') {\n            this.runExecution.fail(this.currentShrinkable.value_, this.currentIdx, result);\n            this.currentIdx = -1;\n            this.nextValues = this.currentShrinkable.shrink();\n        }\n        else if (result != null) {\n            if (!result.interruptExecution) {\n                this.runExecution.skip(this.currentShrinkable.value_);\n                this.sourceValues.skippedOne();\n            }\n            else {\n                this.runExecution.interrupt();\n            }\n        }\n        else {\n            this.runExecution.success(this.currentShrinkable.value_);\n        }\n    }\n}\n", "export class SourceValuesIterator {\n    constructor(initialValues, maxInitialIterations, remainingSkips) {\n        this.initialValues = initialValues;\n        this.maxInitialIterations = maxInitialIterations;\n        this.remainingSkips = remainingSkips;\n    }\n    [Symbol.iterator]() {\n        return this;\n    }\n    next() {\n        if (--this.maxInitialIterations !== -1 && this.remainingSkips >= 0) {\n            const n = this.initialValues.next();\n            if (!n.done)\n                return { value: n.value(), done: false };\n        }\n        return { value: undefined, done: true };\n    }\n    skippedOne() {\n        --this.remainingSkips;\n        ++this.maxInitialIterations;\n    }\n}\n", "class ConvertedRandomGenerator {\n    constructor(rng) {\n        this.rng = rng;\n        if (typeof this.rng.jump === 'function') {\n            this.jump = function jump() {\n                const out = this.jump();\n                return new ConvertedRandomGenerator(out);\n            };\n            this.unsafeJump = function unsafeJump() {\n                const out = this.jump();\n                this.rng = out;\n            };\n        }\n    }\n    min() {\n        return this.rng.min();\n    }\n    max() {\n        return this.rng.max();\n    }\n    clone() {\n        return new ConvertedRandomGenerator(this.rng);\n    }\n    next() {\n        const out = this.rng.next();\n        return [out[0], new ConvertedRandomGenerator(out[1])];\n    }\n    unsafeNext() {\n        const out = this.rng.next();\n        this.rng = out[1];\n        return out[0];\n    }\n}\nexport function convertToRandomGenerator(rng) {\n    if ('clone' in rng && 'unsafeNext' in rng) {\n        return rng;\n    }\n    return new ConvertedRandomGenerator(rng);\n}\n", "import { unsafeUniformArrayIntDistribution, unsafeUniformBigIntDistribution, unsafeUniformIntDistribution, } from 'pure-rand';\nimport { convertToRandomGenerator } from './PureRandom.js';\nexport class Random {\n    constructor(sourceRng) {\n        this.internalRng = convertToRandomGenerator(sourceRng).clone();\n    }\n    clone() {\n        return new Random(this.internalRng);\n    }\n    next(bits) {\n        return unsafeUniformIntDistribution(0, (1 << bits) - 1, this.internalRng);\n    }\n    nextBoolean() {\n        return unsafeUniformIntDistribution(0, 1, this.internalRng) == 1;\n    }\n    nextInt(min, max) {\n        return unsafeUniformIntDistribution(min == null ? Random.MIN_INT : min, max == null ? Random.MAX_INT : max, this.internalRng);\n    }\n    nextBigInt(min, max) {\n        return unsafeUniformBigIntDistribution(min, max, this.internalRng);\n    }\n    nextArrayInt(min, max) {\n        return unsafeUniformArrayIntDistribution(min, max, this.internalRng);\n    }\n    nextDouble() {\n        const a = this.next(26);\n        const b = this.next(27);\n        return (a * Random.DBL_FACTOR + b) * Random.DBL_DIVISOR;\n    }\n}\nRandom.MIN_INT = 0x80000000 | 0;\nRandom.MAX_INT = 0x7fffffff | 0;\nRandom.DBL_FACTOR = Math.pow(2, 27);\nRandom.DBL_DIVISOR = Math.pow(2, -53);\n", "import { skipN } from 'pure-rand';\nimport { Random } from '../../random/generator/Random.js';\nimport { Shrinkable } from '../arbitrary/definition/Shrinkable.js';\nimport { convertToRandomGenerator } from '../../random/generator/PureRandom.js';\nfunction lazyGenerate(generator, rng, idx) {\n    return () => generator.generate(new Random(rng), idx);\n}\nexport function* toss(generator, seed, random, examples) {\n    yield* examples.map((e) => () => new Shrinkable(e));\n    let idx = 0;\n    let rng = convertToRandomGenerator(random(seed));\n    for (;;) {\n        rng = rng.jump ? rng.jump() : skipN(rng, 42);\n        yield lazyGenerate(generator, rng, idx++);\n    }\n}\n", "import { stream } from '../../../stream/Stream.js';\nexport function pathWalk(path, initialValues) {\n    let values = stream(initialValues);\n    const segments = path.split(':').map((text) => +text);\n    if (segments.length === 0)\n        return values;\n    if (!segments.every((v) => !Number.isNaN(v))) {\n        throw new Error(`Unable to replay, got invalid path=${path}`);\n    }\n    values = values.drop(segments[0]);\n    for (const s of segments.slice(1)) {\n        const valueToShrink = values.getNthOrLast(0);\n        if (valueToShrink == null) {\n            throw new Error(`Unable to replay, got wrong path=${path}`);\n        }\n        values = valueToShrink.shrink().drop(s);\n    }\n    return values;\n}\n", "import { stringify, possiblyAsyncStringify } from '../../../utils/stringify.js';\nimport { VerbosityLevel } from '../configuration/VerbosityLevel.js';\nimport { ExecutionStatus } from '../reporter/ExecutionStatus.js';\nfunction formatHints(hints) {\n    if (hints.length === 1) {\n        return `Hint: ${hints[0]}`;\n    }\n    return hints.map((h, idx) => `Hint (${idx + 1}): ${h}`).join('\\n');\n}\nfunction formatFailures(failures, stringifyOne) {\n    return `Encountered failures were:\\n- ${failures.map(stringifyOne).join('\\n- ')}`;\n}\nfunction formatExecutionSummary(executionTrees, stringifyOne) {\n    const summaryLines = [];\n    const remainingTreesAndDepth = [];\n    for (const tree of executionTrees.slice().reverse()) {\n        remainingTreesAndDepth.push({ depth: 1, tree });\n    }\n    while (remainingTreesAndDepth.length !== 0) {\n        const currentTreeAndDepth = remainingTreesAndDepth.pop();\n        const currentTree = currentTreeAndDepth.tree;\n        const currentDepth = currentTreeAndDepth.depth;\n        const statusIcon = currentTree.status === ExecutionStatus.Success\n            ? '\\x1b[32m\\u221A\\x1b[0m'\n            : currentTree.status === ExecutionStatus.Failure\n                ? '\\x1b[31m\\xD7\\x1b[0m'\n                : '\\x1b[33m!\\x1b[0m';\n        const leftPadding = Array(currentDepth).join('. ');\n        summaryLines.push(`${leftPadding}${statusIcon} ${stringifyOne(currentTree.value)}`);\n        for (const tree of currentTree.children.slice().reverse()) {\n            remainingTreesAndDepth.push({ depth: currentDepth + 1, tree });\n        }\n    }\n    return `Execution summary:\\n${summaryLines.join('\\n')}`;\n}\nfunction preFormatTooManySkipped(out, stringifyOne) {\n    const message = `Failed to run property, too many pre-condition failures encountered\\n{ seed: ${out.seed} }\\n\\nRan ${out.numRuns} time(s)\\nSkipped ${out.numSkips} time(s)`;\n    let details = null;\n    const hints = [\n        'Try to reduce the number of rejected values by combining map, flatMap and built-in arbitraries',\n        'Increase failure tolerance by setting maxSkipsPerRun to an higher value',\n    ];\n    if (out.verbose >= VerbosityLevel.VeryVerbose) {\n        details = formatExecutionSummary(out.executionSummary, stringifyOne);\n    }\n    else {\n        hints.push('Enable verbose mode at level VeryVerbose in order to check all generated values and their associated status');\n    }\n    return { message, details, hints };\n}\nfunction preFormatFailure(out, stringifyOne) {\n    const message = `Property failed after ${out.numRuns} tests\\n{ seed: ${out.seed}, path: \"${out.counterexamplePath}\", endOnFailure: true }\\nCounterexample: ${stringifyOne(out.counterexample)}\\nShrunk ${out.numShrinks} time(s)\\nGot error: ${out.error}`;\n    let details = null;\n    const hints = [];\n    if (out.verbose >= VerbosityLevel.VeryVerbose) {\n        details = formatExecutionSummary(out.executionSummary, stringifyOne);\n    }\n    else if (out.verbose === VerbosityLevel.Verbose) {\n        details = formatFailures(out.failures, stringifyOne);\n    }\n    else {\n        hints.push('Enable verbose mode in order to have the list of all failing values encountered during the run');\n    }\n    return { message, details, hints };\n}\nfunction preFormatEarlyInterrupted(out, stringifyOne) {\n    const message = `Property interrupted after ${out.numRuns} tests\\n{ seed: ${out.seed} }`;\n    let details = null;\n    const hints = [];\n    if (out.verbose >= VerbosityLevel.VeryVerbose) {\n        details = formatExecutionSummary(out.executionSummary, stringifyOne);\n    }\n    else {\n        hints.push('Enable verbose mode at level VeryVerbose in order to check all generated values and their associated status');\n    }\n    return { message, details, hints };\n}\nfunction defaultReportMessageInternal(out, stringifyOne) {\n    if (!out.failed)\n        return;\n    const { message, details, hints } = out.counterexamplePath === null\n        ? out.interrupted\n            ? preFormatEarlyInterrupted(out, stringifyOne)\n            : preFormatTooManySkipped(out, stringifyOne)\n        : preFormatFailure(out, stringifyOne);\n    let errorMessage = message;\n    if (details != null)\n        errorMessage += `\\n\\n${details}`;\n    if (hints.length > 0)\n        errorMessage += `\\n\\n${formatHints(hints)}`;\n    return errorMessage;\n}\nfunction defaultReportMessage(out) {\n    return defaultReportMessageInternal(out, stringify);\n}\nasync function asyncDefaultReportMessage(out) {\n    const pendingStringifieds = [];\n    function stringifyOne(value) {\n        const stringified = possiblyAsyncStringify(value);\n        if (typeof stringified === 'string') {\n            return stringified;\n        }\n        pendingStringifieds.push(Promise.all([value, stringified]));\n        return '\\u2026';\n    }\n    const firstTryMessage = defaultReportMessageInternal(out, stringifyOne);\n    if (pendingStringifieds.length === 0) {\n        return firstTryMessage;\n    }\n    const registeredValues = new Map(await Promise.all(pendingStringifieds));\n    function stringifySecond(value) {\n        const asyncStringifiedIfRegistered = registeredValues.get(value);\n        if (asyncStringifiedIfRegistered !== undefined) {\n            return asyncStringifiedIfRegistered;\n        }\n        return stringify(value);\n    }\n    return defaultReportMessageInternal(out, stringifySecond);\n}\nfunction throwIfFailed(out) {\n    if (!out.failed)\n        return;\n    throw new Error(defaultReportMessage(out));\n}\nasync function asyncThrowIfFailed(out) {\n    if (!out.failed)\n        return;\n    throw new Error(await asyncDefaultReportMessage(out));\n}\nexport function reportRunDetails(out) {\n    if (out.runConfiguration.asyncReporter)\n        return out.runConfiguration.asyncReporter(out);\n    else if (out.runConfiguration.reporter)\n        return out.runConfiguration.reporter(out);\n    else\n        return throwIfFailed(out);\n}\nexport async function asyncReportRunDetails(out) {\n    if (out.runConfiguration.asyncReporter)\n        return out.runConfiguration.asyncReporter(out);\n    else if (out.runConfiguration.reporter)\n        return out.runConfiguration.reporter(out);\n    else\n        return asyncThrowIfFailed(out);\n}\nexport { defaultReportMessage, asyncDefaultReportMessage };\n", "import { stream } from '../../stream/Stream.js';\nimport { Shrinkable } from '../arbitrary/definition/Shrinkable.js';\nimport { readConfigureGlobal } from './configuration/GlobalParameters.js';\nimport { QualifiedParameters } from './configuration/QualifiedParameters.js';\nimport { decorateProperty } from './DecorateProperty.js';\nimport { RunnerIterator } from './RunnerIterator.js';\nimport { SourceValuesIterator } from './SourceValuesIterator.js';\nimport { toss } from './Tosser.js';\nimport { pathWalk } from './utils/PathWalker.js';\nimport { asyncReportRunDetails, reportRunDetails } from './utils/RunDetailsFormatter.js';\nfunction runIt(property, sourceValues, verbose, interruptedAsFailure) {\n    const runner = new RunnerIterator(sourceValues, verbose, interruptedAsFailure);\n    for (const v of runner) {\n        const out = property.run(v);\n        runner.handleResult(out);\n    }\n    return runner.runExecution;\n}\nasync function asyncRunIt(property, sourceValues, verbose, interruptedAsFailure) {\n    const runner = new RunnerIterator(sourceValues, verbose, interruptedAsFailure);\n    for (const v of runner) {\n        const out = await property.run(v);\n        runner.handleResult(out);\n    }\n    return runner.runExecution;\n}\nfunction runnerPathWalker(valueProducers, path) {\n    const pathPoints = path.split(':');\n    const pathStream = stream(valueProducers)\n        .drop(pathPoints.length > 0 ? +pathPoints[0] : 0)\n        .map((producer) => producer());\n    const adaptedPath = ['0', ...pathPoints.slice(1)].join(':');\n    return stream(pathWalk(adaptedPath, pathStream)).map((v) => () => v);\n}\nfunction buildInitialValues(valueProducers, qParams) {\n    const rawValues = qParams.path.length === 0 ? stream(valueProducers) : runnerPathWalker(valueProducers, qParams.path);\n    if (!qParams.endOnFailure)\n        return rawValues;\n    return rawValues.map((shrinkableGen) => {\n        return () => {\n            const s = shrinkableGen();\n            return new Shrinkable(s.value_);\n        };\n    });\n}\nfunction check(rawProperty, params) {\n    if (rawProperty == null || rawProperty.generate == null)\n        throw new Error('Invalid property encountered, please use a valid property');\n    if (rawProperty.run == null)\n        throw new Error('Invalid property encountered, please use a valid property not an arbitrary');\n    const qParams = QualifiedParameters.read(Object.assign(Object.assign({}, readConfigureGlobal()), params));\n    if (qParams.reporter !== null && qParams.asyncReporter !== null)\n        throw new Error('Invalid parameters encountered, reporter and asyncReporter cannot be specified together');\n    if (qParams.asyncReporter !== null && !rawProperty.isAsync())\n        throw new Error('Invalid parameters encountered, only asyncProperty can be used when asyncReporter specified');\n    const property = decorateProperty(rawProperty, qParams);\n    const generator = toss(property, qParams.seed, qParams.randomType, qParams.examples);\n    const maxInitialIterations = qParams.path.indexOf(':') === -1 ? qParams.numRuns : -1;\n    const maxSkips = qParams.numRuns * qParams.maxSkipsPerRun;\n    const initialValues = buildInitialValues(generator, qParams);\n    const sourceValues = new SourceValuesIterator(initialValues, maxInitialIterations, maxSkips);\n    return property.isAsync()\n        ? asyncRunIt(property, sourceValues, qParams.verbose, qParams.markInterruptAsFailure).then((e) => e.toRunDetails(qParams.seed, qParams.path, maxSkips, qParams))\n        : runIt(property, sourceValues, qParams.verbose, qParams.markInterruptAsFailure).toRunDetails(qParams.seed, qParams.path, maxSkips, qParams);\n}\nfunction assert(property, params) {\n    const out = check(property, params);\n    if (property.isAsync())\n        return out.then(asyncReportRunDetails);\n    else\n        reportRunDetails(out);\n}\nexport { check, assert };\n", "import { stream } from '../../stream/Stream.js';\nimport { Property } from '../property/Property.generic.js';\nimport { UnbiasedProperty } from '../property/UnbiasedProperty.js';\nimport { readConfigureGlobal } from './configuration/GlobalParameters.js';\nimport { QualifiedParameters } from './configuration/QualifiedParameters.js';\nimport { toss } from './Tosser.js';\nimport { pathWalk } from './utils/PathWalker.js';\nfunction toProperty(generator, qParams) {\n    const prop = !Object.prototype.hasOwnProperty.call(generator, 'isAsync')\n        ? new Property(generator, () => true)\n        : generator;\n    return qParams.unbiased === true ? new UnbiasedProperty(prop) : prop;\n}\nfunction streamSample(generator, params) {\n    const extendedParams = typeof params === 'number'\n        ? Object.assign(Object.assign({}, readConfigureGlobal()), { numRuns: params }) : Object.assign(Object.assign({}, readConfigureGlobal()), params);\n    const qParams = QualifiedParameters.read(extendedParams);\n    const tossedValues = stream(toss(toProperty(generator, qParams), qParams.seed, qParams.randomType, qParams.examples));\n    if (qParams.path.length === 0) {\n        return tossedValues.take(qParams.numRuns).map((s) => s().value_);\n    }\n    return stream(pathWalk(qParams.path, tossedValues.map((s) => s())))\n        .take(qParams.numRuns)\n        .map((s) => s.value_);\n}\nfunction sample(generator, params) {\n    return [...streamSample(generator, params)];\n}\nfunction statistics(generator, classify, params) {\n    const extendedParams = typeof params === 'number'\n        ? Object.assign(Object.assign({}, readConfigureGlobal()), { numRuns: params }) : Object.assign(Object.assign({}, readConfigureGlobal()), params);\n    const qParams = QualifiedParameters.read(extendedParams);\n    const recorded = {};\n    for (const g of streamSample(generator, params)) {\n        const out = classify(g);\n        const categories = Array.isArray(out) ? out : [out];\n        for (const c of categories) {\n            recorded[c] = (recorded[c] || 0) + 1;\n        }\n    }\n    const data = Object.entries(recorded)\n        .sort((a, b) => b[1] - a[1])\n        .map((i) => [i[0], `${((i[1] * 100.0) / qParams.numRuns).toFixed(2)}%`]);\n    const longestName = data.map((i) => i[0].length).reduce((p, c) => Math.max(p, c), 0);\n    const longestPercent = data.map((i) => i[1].length).reduce((p, c) => Math.max(p, c), 0);\n    for (const item of data) {\n        qParams.logger(`${item[0].padEnd(longestName, '.')}..${item[1].padStart(longestPercent, '.')}`);\n    }\n}\nexport { sample, statistics };\n", "export function integerLogLike(v) {\n    return Math.floor(Math.log(v) / Math.log(2));\n}\nexport function bigIntLogLike(v) {\n    if (v === BigInt(0))\n        return BigInt(0);\n    return BigInt(v.toString().length);\n}\nfunction biasNumericRange(min, max, logLike) {\n    if (min === max) {\n        return [{ min: min, max: max }];\n    }\n    if (min < 0 && max > 0) {\n        const logMin = logLike(-min);\n        const logMax = logLike(max);\n        return [\n            { min: -logMin, max: logMax },\n            { min: (max - logMax), max: max },\n            { min: min, max: min + logMin },\n        ];\n    }\n    const logGap = logLike((max - min));\n    const arbCloseToMin = { min: min, max: min + logGap };\n    const arbCloseToMax = { min: (max - logGap), max: max };\n    return min < 0\n        ? [arbCloseToMax, arbCloseToMin]\n        : [arbCloseToMin, arbCloseToMax];\n}\nexport { biasNumericRange };\n", "import { NextValue } from '../../../check/arbitrary/definition/NextValue.js';\nimport { stream } from '../../../stream/Stream.js';\nfunction halvePosInteger(n) {\n    return Math.floor(n / 2);\n}\nfunction halveNegInteger(n) {\n    return Math.ceil(n / 2);\n}\nexport function shrinkInteger(current, target, tryTargetAsap) {\n    const realGap = current - target;\n    function* shrinkDecr() {\n        let previous = tryTargetAsap ? undefined : target;\n        const gap = tryTargetAsap ? realGap : halvePosInteger(realGap);\n        for (let toremove = gap; toremove > 0; toremove = halvePosInteger(toremove)) {\n            const next = toremove === realGap ? target : current - toremove;\n            yield new NextValue(next, previous);\n            previous = next;\n        }\n    }\n    function* shrinkIncr() {\n        let previous = tryTargetAsap ? undefined : target;\n        const gap = tryTargetAsap ? realGap : halveNegInteger(realGap);\n        for (let toremove = gap; toremove < 0; toremove = halveNegInteger(toremove)) {\n            const next = toremove === realGap ? target : current - toremove;\n            yield new NextValue(next, previous);\n            previous = next;\n        }\n    }\n    return realGap > 0 ? stream(shrinkDecr()) : stream(shrinkIncr());\n}\n", "import { NextArbitrary } from '../../check/arbitrary/definition/NextArbitrary.js';\nimport { NextValue } from '../../check/arbitrary/definition/NextValue.js';\nimport { Stream } from '../../stream/Stream.js';\nimport { integerLogLike, biasNumericRange } from './helpers/BiasNumericRange.js';\nimport { shrinkInteger } from './helpers/ShrinkInteger.js';\nexport class IntegerArbitrary extends NextArbitrary {\n    constructor(min, max) {\n        super();\n        this.min = min;\n        this.max = max;\n    }\n    generate(mrng, biasFactor) {\n        const range = this.computeGenerateRange(mrng, biasFactor);\n        return new NextValue(mrng.nextInt(range.min, range.max), undefined);\n    }\n    canShrinkWithoutContext(value) {\n        return (typeof value === 'number' &&\n            Number.isInteger(value) &&\n            !Object.is(value, -0) &&\n            this.min <= value &&\n            value <= this.max);\n    }\n    shrink(current, context) {\n        if (!IntegerArbitrary.isValidContext(current, context)) {\n            const target = this.defaultTarget();\n            return shrinkInteger(current, target, true);\n        }\n        if (this.isLastChanceTry(current, context)) {\n            return Stream.of(new NextValue(context, undefined));\n        }\n        return shrinkInteger(current, context, false);\n    }\n    defaultTarget() {\n        if (this.min <= 0 && this.max >= 0) {\n            return 0;\n        }\n        return this.min < 0 ? this.max : this.min;\n    }\n    computeGenerateRange(mrng, biasFactor) {\n        if (biasFactor === undefined || mrng.nextInt(1, biasFactor) !== 1) {\n            return { min: this.min, max: this.max };\n        }\n        const ranges = biasNumericRange(this.min, this.max, integerLogLike);\n        if (ranges.length === 1) {\n            return ranges[0];\n        }\n        const id = mrng.nextInt(-2 * (ranges.length - 1), ranges.length - 2);\n        return id < 0 ? ranges[0] : ranges[id + 1];\n    }\n    isLastChanceTry(current, context) {\n        if (current > 0)\n            return current === context + 1 && current > this.min;\n        if (current < 0)\n            return current === context - 1 && current < this.max;\n        return false;\n    }\n    static isValidContext(current, context) {\n        if (context === undefined) {\n            return false;\n        }\n        if (typeof context !== 'number') {\n            throw new Error(`Invalid context type passed to IntegerArbitrary (#1)`);\n        }\n        if (context !== 0 && Math.sign(current) !== Math.sign(context)) {\n            throw new Error(`Invalid context value passed to IntegerArbitrary (#2)`);\n        }\n        return true;\n    }\n}\n", "import { convertFromNextWithShrunkOnce } from '../check/arbitrary/definition/Converters.js';\nimport { IntegerArbitrary } from './_internals/IntegerArbitrary.js';\nfunction buildCompleteIntegerConstraints(constraints) {\n    const min = constraints.min !== undefined ? constraints.min : -0x80000000;\n    const max = constraints.max !== undefined ? constraints.max : 0x7fffffff;\n    return { min, max };\n}\nfunction extractIntegerConstraints(args) {\n    if (args[0] === undefined) {\n        return {};\n    }\n    if (args[1] === undefined) {\n        const sargs = args;\n        if (typeof sargs[0] === 'number')\n            return { max: sargs[0] };\n        return sargs[0];\n    }\n    const sargs = args;\n    return { min: sargs[0], max: sargs[1] };\n}\nfunction integer(...args) {\n    const constraints = buildCompleteIntegerConstraints(extractIntegerConstraints(args));\n    if (constraints.min > constraints.max) {\n        throw new Error('fc.integer maximum value should be equal or greater than the minimum one');\n    }\n    const arb = new IntegerArbitrary(constraints.min, constraints.max);\n    return convertFromNextWithShrunkOnce(arb, arb.defaultTarget());\n}\nexport { integer };\n", "class LazyIterableIterator {\n    constructor(producer) {\n        this.producer = producer;\n    }\n    [Symbol.iterator]() {\n        if (this.it === undefined) {\n            this.it = this.producer();\n        }\n        return this.it;\n    }\n    next() {\n        if (this.it === undefined) {\n            this.it = this.producer();\n        }\n        return this.it.next();\n    }\n}\nexport function makeLazy(producer) {\n    return new LazyIterableIterator(producer);\n}\n", "function subArrayContains(tab, upperBound, includeValue) {\n    for (let idx = 0; idx < upperBound; ++idx) {\n        if (includeValue(tab[idx]))\n            return true;\n    }\n    return false;\n}\nfunction swap(tab, idx1, idx2) {\n    const temp = tab[idx1];\n    tab[idx1] = tab[idx2];\n    tab[idx2] = temp;\n}\nexport function buildCompareFilter(compare) {\n    return (tab) => {\n        let finalLength = tab.length;\n        for (let idx = tab.length - 1; idx !== -1; --idx) {\n            if (subArrayContains(tab, idx, (t) => compare(t.value_, tab[idx].value_))) {\n                --finalLength;\n                swap(tab, idx, finalLength);\n            }\n        }\n        return tab.slice(0, finalLength);\n    };\n}\n", "import { Stream } from '../../stream/Stream.js';\nimport { cloneIfNeeded, cloneMethod } from '../../check/symbols.js';\nimport { integer } from '../integer.js';\nimport { makeLazy } from '../../stream/LazyIterableIterator.js';\nimport { buildCompareFilter } from './helpers/BuildCompareFilter.js';\nimport { NextArbitrary } from '../../check/arbitrary/definition/NextArbitrary.js';\nimport { convertToNext } from '../../check/arbitrary/definition/Converters.js';\nimport { NextValue } from '../../check/arbitrary/definition/NextValue.js';\nexport class ArrayArbitrary extends NextArbitrary {\n    constructor(arb, minLength, maxLength, isEqual) {\n        super();\n        this.arb = arb;\n        this.minLength = minLength;\n        this.maxLength = maxLength;\n        this.isEqual = isEqual;\n        this.lengthArb = convertToNext(integer(minLength, maxLength));\n        this.preFilter = this.isEqual !== undefined ? buildCompareFilter(this.isEqual) : (tab) => tab;\n    }\n    static makeItCloneable(vs, shrinkables) {\n        vs[cloneMethod] = () => {\n            const cloned = [];\n            for (let idx = 0; idx !== shrinkables.length; ++idx) {\n                cloned.push(shrinkables[idx].value);\n            }\n            this.makeItCloneable(cloned, shrinkables);\n            return cloned;\n        };\n        return vs;\n    }\n    static canAppendItem(items, newItem, isEqual) {\n        for (let idx = 0; idx !== items.length; ++idx) {\n            if (isEqual(items[idx].value_, newItem.value_)) {\n                return false;\n            }\n        }\n        return true;\n    }\n    generateNItemsNoDuplicates(N, mrng, biasFactorItems) {\n        let numSkippedInRow = 0;\n        const items = [];\n        while (items.length < N && numSkippedInRow < this.maxLength) {\n            const current = this.arb.generate(mrng, biasFactorItems);\n            if (this.isEqual === undefined || ArrayArbitrary.canAppendItem(items, current, this.isEqual)) {\n                numSkippedInRow = 0;\n                items.push(current);\n            }\n            else {\n                numSkippedInRow += 1;\n            }\n        }\n        return items;\n    }\n    generateNItems(N, mrng, biasFactorItems) {\n        const items = [];\n        for (let index = 0; index !== N; ++index) {\n            const current = this.arb.generate(mrng, biasFactorItems);\n            items.push(current);\n        }\n        return items;\n    }\n    wrapper(itemsRaw, shrunkOnce, itemsRawLengthContext) {\n        const items = shrunkOnce ? this.preFilter(itemsRaw) : itemsRaw;\n        let cloneable = false;\n        const vs = [];\n        const itemsContexts = [];\n        for (let idx = 0; idx !== items.length; ++idx) {\n            const s = items[idx];\n            cloneable = cloneable || s.hasToBeCloned;\n            vs.push(s.value);\n            itemsContexts.push(s.context);\n        }\n        if (cloneable) {\n            ArrayArbitrary.makeItCloneable(vs, items);\n        }\n        const context = {\n            shrunkOnce,\n            lengthContext: itemsRaw.length === items.length && itemsRawLengthContext !== undefined\n                ? itemsRawLengthContext\n                : undefined,\n            itemsContexts,\n        };\n        return new NextValue(vs, context);\n    }\n    generate(mrng, biasFactor) {\n        const biasMeta = this.applyBias(mrng, biasFactor);\n        const targetSize = biasMeta.size;\n        const items = this.isEqual !== undefined\n            ? this.generateNItemsNoDuplicates(targetSize, mrng, biasMeta.biasFactorItems)\n            : this.generateNItems(targetSize, mrng, biasMeta.biasFactorItems);\n        return this.wrapper(items, false, undefined);\n    }\n    applyBias(mrng, biasFactor) {\n        if (biasFactor === undefined || mrng.nextInt(1, biasFactor) !== 1) {\n            return { size: this.lengthArb.generate(mrng, undefined).value };\n        }\n        if (mrng.nextInt(1, biasFactor) !== 1 || this.minLength === this.maxLength) {\n            return { size: this.lengthArb.generate(mrng, undefined).value, biasFactorItems: biasFactor };\n        }\n        const maxBiasedLength = this.minLength + Math.floor(Math.log(this.maxLength - this.minLength) / Math.log(2));\n        const targetSizeValue = convertToNext(integer(this.minLength, maxBiasedLength)).generate(mrng, undefined);\n        return { size: targetSizeValue.value, biasFactorItems: biasFactor };\n    }\n    canShrinkWithoutContext(value) {\n        if (!Array.isArray(value) || this.minLength > value.length || value.length > this.maxLength) {\n            return false;\n        }\n        for (let index = 0; index !== value.length; ++index) {\n            if (!(index in value)) {\n                return false;\n            }\n            if (!this.arb.canShrinkWithoutContext(value[index])) {\n                return false;\n            }\n        }\n        const filtered = this.preFilter(value.map((item) => new NextValue(item, undefined)));\n        return filtered.length === value.length;\n    }\n    shrinkImpl(value, context) {\n        if (value.length === 0) {\n            return Stream.nil();\n        }\n        const safeContext = context !== undefined\n            ? context\n            : { shrunkOnce: false, lengthContext: undefined, itemsContexts: [] };\n        return (this.lengthArb\n            .shrink(value.length, safeContext.lengthContext)\n            .drop(safeContext.shrunkOnce && safeContext.lengthContext === undefined && value.length > this.minLength + 1 ? 1 : 0)\n            .map((lengthValue) => {\n            const sliceStart = value.length - lengthValue.value;\n            return [\n                value\n                    .slice(sliceStart)\n                    .map((v, index) => new NextValue(cloneIfNeeded(v), safeContext.itemsContexts[index + sliceStart])),\n                lengthValue.context,\n            ];\n        })\n            .join(this.arb.shrink(value[0], safeContext.itemsContexts[0]).map((v) => {\n            return [\n                [v].concat(value.slice(1).map((v, index) => new NextValue(cloneIfNeeded(v), safeContext.itemsContexts[index + 1]))),\n                undefined,\n            ];\n        }))\n            .join(value.length > this.minLength\n            ? makeLazy(() => this.shrinkImpl(value.slice(1), {\n                shrunkOnce: false,\n                lengthContext: undefined,\n                itemsContexts: safeContext.itemsContexts.slice(1),\n            })\n                .filter((v) => this.minLength <= v[0].length + 1)\n                .map((v) => {\n                return [\n                    [new NextValue(cloneIfNeeded(value[0]), safeContext.itemsContexts[0])].concat(v[0]),\n                    undefined,\n                ];\n            }))\n            : Stream.nil()));\n    }\n    shrink(value, context) {\n        return this.shrinkImpl(value, context).map((contextualValue) => this.wrapper(contextualValue[0], true, contextualValue[1]));\n    }\n}\n", "export function maxLengthFromMinLength(minLength) {\n    return 2 * minLength + 10;\n}\n", "import { convertFromNext, convertToNext } from '../check/arbitrary/definition/Converters.js';\nimport { ArrayArbitrary } from './_internals/ArrayArbitrary.js';\nimport { maxLengthFromMinLength } from './_internals/helpers/MaxLengthFromMinLength.js';\nfunction array(arb, ...args) {\n    const nextArb = convertToNext(arb);\n    if (args[0] === undefined)\n        return convertFromNext(new ArrayArbitrary(nextArb, 0, maxLengthFromMinLength(0)));\n    if (typeof args[0] === 'object') {\n        const minLength = args[0].minLength || 0;\n        const specifiedMaxLength = args[0].maxLength;\n        const maxLength = specifiedMaxLength !== undefined ? specifiedMaxLength : maxLengthFromMinLength(minLength);\n        return convertFromNext(new ArrayArbitrary(nextArb, minLength, maxLength));\n    }\n    if (args[1] !== undefined)\n        return convertFromNext(new ArrayArbitrary(nextArb, args[0], args[1]));\n    return convertFromNext(new ArrayArbitrary(nextArb, 0, args[0]));\n}\nexport { array };\n", "import { stream } from '../../../stream/Stream.js';\nimport { NextValue } from '../../../check/arbitrary/definition/NextValue.js';\nfunction halveBigInt(n) {\n    return n / BigInt(2);\n}\nexport function shrinkBigInt(current, target, tryTargetAsap) {\n    const realGap = current - target;\n    function* shrinkDecr() {\n        let previous = tryTargetAsap ? undefined : target;\n        const gap = tryTargetAsap ? realGap : halveBigInt(realGap);\n        for (let toremove = gap; toremove > 0; toremove = halveBigInt(toremove)) {\n            const next = current - toremove;\n            yield new NextValue(next, previous);\n            previous = next;\n        }\n    }\n    function* shrinkIncr() {\n        let previous = tryTargetAsap ? undefined : target;\n        const gap = tryTargetAsap ? realGap : halveBigInt(realGap);\n        for (let toremove = gap; toremove < 0; toremove = halveBigInt(toremove)) {\n            const next = current - toremove;\n            yield new NextValue(next, previous);\n            previous = next;\n        }\n    }\n    return realGap > 0 ? stream(shrinkDecr()) : stream(shrinkIncr());\n}\n", "import { Stream } from '../../stream/Stream.js';\nimport { NextArbitrary } from '../../check/arbitrary/definition/NextArbitrary.js';\nimport { NextValue } from '../../check/arbitrary/definition/NextValue.js';\nimport { biasNumericRange, bigIntLogLike } from './helpers/BiasNumericRange.js';\nimport { shrinkBigInt } from './helpers/ShrinkBigInt.js';\nexport class BigIntArbitrary extends NextArbitrary {\n    constructor(min, max) {\n        super();\n        this.min = min;\n        this.max = max;\n    }\n    generate(mrng, biasFactor) {\n        const range = this.computeGenerateRange(mrng, biasFactor);\n        return new NextValue(mrng.nextBigInt(range.min, range.max), undefined);\n    }\n    computeGenerateRange(mrng, biasFactor) {\n        if (biasFactor === undefined || mrng.nextInt(1, biasFactor) !== 1) {\n            return { min: this.min, max: this.max };\n        }\n        const ranges = biasNumericRange(this.min, this.max, bigIntLogLike);\n        if (ranges.length === 1) {\n            return ranges[0];\n        }\n        const id = mrng.nextInt(-2 * (ranges.length - 1), ranges.length - 2);\n        return id < 0 ? ranges[0] : ranges[id + 1];\n    }\n    canShrinkWithoutContext(value) {\n        return typeof value === 'bigint' && this.min <= value && value <= this.max;\n    }\n    shrink(current, context) {\n        if (!BigIntArbitrary.isValidContext(current, context)) {\n            const target = this.defaultTarget();\n            return shrinkBigInt(current, target, true);\n        }\n        if (this.isLastChanceTry(current, context)) {\n            return Stream.of(new NextValue(context, undefined));\n        }\n        return shrinkBigInt(current, context, false);\n    }\n    defaultTarget() {\n        if (this.min <= 0 && this.max >= 0) {\n            return BigInt(0);\n        }\n        return this.min < 0 ? this.max : this.min;\n    }\n    isLastChanceTry(current, context) {\n        if (current > 0)\n            return current === context + BigInt(1) && current > this.min;\n        if (current < 0)\n            return current === context - BigInt(1) && current < this.max;\n        return false;\n    }\n    static isValidContext(current, context) {\n        if (context === undefined) {\n            return false;\n        }\n        if (typeof context !== 'bigint') {\n            throw new Error(`Invalid context type passed to BigIntArbitrary (#1)`);\n        }\n        const differentSigns = (current > 0 && context < 0) || (current < 0 && context > 0);\n        if (context !== BigInt(0) && differentSigns) {\n            throw new Error(`Invalid context value passed to BigIntArbitrary (#2)`);\n        }\n        return true;\n    }\n}\n", "import { convertFromNextWithShrunkOnce } from '../check/arbitrary/definition/Converters.js';\nimport { BigIntArbitrary } from './_internals/BigIntArbitrary.js';\nfunction buildCompleteBigIntConstraints(constraints) {\n    const DefaultPow = 256;\n    const DefaultMin = BigInt(-1) << BigInt(DefaultPow - 1);\n    const DefaultMax = (BigInt(1) << BigInt(DefaultPow - 1)) - BigInt(1);\n    const min = constraints.min;\n    const max = constraints.max;\n    return {\n        min: min !== undefined ? min : DefaultMin - (max !== undefined && max < BigInt(0) ? max * max : BigInt(0)),\n        max: max !== undefined ? max : DefaultMax + (min !== undefined && min > BigInt(0) ? min * min : BigInt(0)),\n    };\n}\nfunction extractBigIntConstraints(args) {\n    if (args[0] === undefined) {\n        return {};\n    }\n    if (args[1] === undefined) {\n        const constraints = args[0];\n        return constraints;\n    }\n    return { min: args[0], max: args[1] };\n}\nfunction bigInt(...args) {\n    const constraints = buildCompleteBigIntConstraints(extractBigIntConstraints(args));\n    if (constraints.min > constraints.max) {\n        throw new Error('fc.bigInt expects max to be greater than or equal to min');\n    }\n    const arb = new BigIntArbitrary(constraints.min, constraints.max);\n    return convertFromNextWithShrunkOnce(arb, arb.defaultTarget());\n}\nexport { bigInt };\n", "import { convertFromNextWithShrunkOnce } from '../check/arbitrary/definition/Converters.js';\nimport { BigIntArbitrary } from './_internals/BigIntArbitrary.js';\nexport function bigIntN(n) {\n    if (n < 1) {\n        throw new Error('fc.bigIntN expects requested number of bits to be superior or equal to 1');\n    }\n    const min = BigInt(-1) << BigInt(n - 1);\n    const max = (BigInt(1) << BigInt(n - 1)) - BigInt(1);\n    const arb = new BigIntArbitrary(min, max);\n    return convertFromNextWithShrunkOnce(arb, arb.defaultTarget());\n}\n", "import { convertFromNextWithShrunkOnce } from '../check/arbitrary/definition/Converters.js';\nimport { BigIntArbitrary } from './_internals/BigIntArbitrary.js';\nfunction computeDefaultMax() {\n    return (BigInt(1) << BigInt(256)) - BigInt(1);\n}\nfunction bigUint(constraints) {\n    const requestedMax = typeof constraints === 'object' ? constraints.max : constraints;\n    const max = requestedMax !== undefined ? requestedMax : computeDefaultMax();\n    if (max < 0) {\n        throw new Error('fc.bigUint expects max to be greater than or equal to zero');\n    }\n    const arb = new BigIntArbitrary(BigInt(0), max);\n    return convertFromNextWithShrunkOnce(arb, arb.defaultTarget());\n}\nexport { bigUint };\n", "import { convertFromNextWithShrunkOnce } from '../check/arbitrary/definition/Converters.js';\nimport { BigIntArbitrary } from './_internals/BigIntArbitrary.js';\nexport function bigUintN(n) {\n    if (n < 0) {\n        throw new Error('fc.bigUintN expects requested number of bits to be superior or equal to 0');\n    }\n    const min = BigInt(0);\n    const max = (BigInt(1) << BigInt(n)) - BigInt(1);\n    const arb = new BigIntArbitrary(min, max);\n    return convertFromNextWithShrunkOnce(arb, arb.defaultTarget());\n}\n", "import { convertFromNext, convertToNext } from '../check/arbitrary/definition/Converters.js';\nimport { integer } from './integer.js';\nfunction booleanMapper(v) {\n    return v === 1;\n}\nfunction booleanUnmapper(v) {\n    if (typeof v !== 'boolean')\n        throw new Error('Unsupported input type');\n    return v === true ? 1 : 0;\n}\nfunction boolean() {\n    return convertFromNext(convertToNext(integer({ min: 0, max: 1 }))\n        .map(booleanMapper, booleanUnmapper)\n        .noBias());\n}\nexport { boolean };\n", "import { Stream } from '../../stream/Stream.js';\nimport { NextArbitrary } from '../../check/arbitrary/definition/NextArbitrary.js';\nimport { NextValue } from '../../check/arbitrary/definition/NextValue.js';\nimport { cloneMethod, hasCloneMethod } from '../../check/symbols.js';\nexport class ConstantArbitrary extends NextArbitrary {\n    constructor(values) {\n        super();\n        this.values = values;\n    }\n    generate(mrng, _biasFactor) {\n        const idx = this.values.length === 1 ? 0 : mrng.nextInt(0, this.values.length - 1);\n        const value = this.values[idx];\n        if (!hasCloneMethod(value)) {\n            return new NextValue(value, idx);\n        }\n        return new NextValue(value, idx, () => value[cloneMethod]());\n    }\n    canShrinkWithoutContext(value) {\n        for (let idx = 0; idx !== this.values.length; ++idx) {\n            if (Object.is(this.values[idx], value)) {\n                return true;\n            }\n        }\n        return false;\n    }\n    shrink(value, context) {\n        if (context === 0 || Object.is(value, this.values[0])) {\n            return Stream.nil();\n        }\n        return Stream.of(new NextValue(this.values[0], 0));\n    }\n}\n", "import { convertFromNext } from '../check/arbitrary/definition/Converters.js';\nimport { ConstantArbitrary } from './_internals/ConstantArbitrary.js';\nfunction constantFrom(...values) {\n    if (values.length === 0) {\n        throw new Error('fc.constantFrom expects at least one parameter');\n    }\n    return convertFromNext(new ConstantArbitrary(values));\n}\nexport { constantFrom };\n", "import { constantFrom } from './constantFrom.js';\nexport function falsy(constraints) {\n    if (!constraints || !constraints.withBigInt) {\n        return constantFrom(false, null, undefined, 0, '', NaN);\n    }\n    return constantFrom(false, null, undefined, 0, '', NaN, BigInt(0));\n}\n", "export const indexToCharStringMapper = String.fromCodePoint;\nexport function indexToCharStringUnmapper(c) {\n    if (typeof c !== 'string') {\n        throw new Error('Cannot unmap non-string');\n    }\n    if (c.length === 0 || c.length > 2) {\n        throw new Error('Cannot unmap string with more or less than one character');\n    }\n    const c1 = c.charCodeAt(0);\n    if (c.length === 1) {\n        return c1;\n    }\n    const c2 = c.charCodeAt(1);\n    if (c1 < 0xd800 || c1 > 0xdbff || c2 < 0xdc00 || c2 > 0xdfff) {\n        throw new Error('Cannot unmap invalid surrogate pairs');\n    }\n    return c.codePointAt(0);\n}\n", "import { convertFromNext, convertToNext } from '../../../check/arbitrary/definition/Converters.js';\nimport { integer } from '../../integer.js';\nimport { indexToCharStringMapper, indexToCharStringUnmapper } from '../mappers/IndexToCharString.js';\nexport function buildCharacterArbitrary(min, max, mapToCode, unmapFromCode) {\n    return convertFromNext(convertToNext(integer(min, max)).map((n) => indexToCharStringMapper(mapToCode(n)), (c) => unmapFromCode(indexToCharStringUnmapper(c))));\n}\n", "export function indexToPrintableIndexMapper(v) {\n    if (v < 95)\n        return v + 0x20;\n    if (v <= 0x7e)\n        return v - 95;\n    return v;\n}\nexport function indexToPrintableIndexUnmapper(v) {\n    if (v >= 0x20 && v <= 0x7e)\n        return v - 0x20;\n    if (v >= 0 && v <= 0x1f)\n        return v + 95;\n    return v;\n}\n", "import { buildCharacterArbitrary } from './_internals/builders/CharacterArbitraryBuilder.js';\nimport { indexToPrintableIndexMapper, indexToPrintableIndexUnmapper } from './_internals/mappers/IndexToPrintableIndex.js';\nexport function ascii() {\n    return buildCharacterArbitrary(0x00, 0x7f, indexToPrintableIndexMapper, indexToPrintableIndexUnmapper);\n}\n", "import { buildCharacterArbitrary } from './_internals/builders/CharacterArbitraryBuilder.js';\nfunction base64Mapper(v) {\n    if (v < 26)\n        return v + 65;\n    if (v < 52)\n        return v + 97 - 26;\n    if (v < 62)\n        return v + 48 - 52;\n    return v === 62 ? 43 : 47;\n}\nfunction base64Unmapper(v) {\n    if (v >= 65 && v <= 90)\n        return v - 65;\n    if (v >= 97 && v <= 122)\n        return v - 97 + 26;\n    if (v >= 48 && v <= 57)\n        return v - 48 + 52;\n    return v === 43 ? 62 : v === 47 ? 63 : -1;\n}\nexport function base64() {\n    return buildCharacterArbitrary(0, 63, base64Mapper, base64Unmapper);\n}\n", "import { buildCharacterArbitrary } from './_internals/builders/CharacterArbitraryBuilder.js';\nfunction identity(v) {\n    return v;\n}\nexport function char() {\n    return buildCharacterArbitrary(0x20, 0x7e, identity, identity);\n}\n", "import { buildCharacterArbitrary } from './_internals/builders/CharacterArbitraryBuilder.js';\nimport { indexToPrintableIndexMapper, indexToPrintableIndexUnmapper } from './_internals/mappers/IndexToPrintableIndex.js';\nexport function char16bits() {\n    return buildCharacterArbitrary(0x0000, 0xffff, indexToPrintableIndexMapper, indexToPrintableIndexUnmapper);\n}\n", "import { buildCharacterArbitrary } from './_internals/builders/CharacterArbitraryBuilder.js';\nimport { indexToPrintableIndexMapper, indexToPrintableIndexUnmapper } from './_internals/mappers/IndexToPrintableIndex.js';\nconst gapSize = 0xdfff + 1 - 0xd800;\nfunction unicodeMapper(v) {\n    if (v < 0xd800)\n        return indexToPrintableIndexMapper(v);\n    return v + gapSize;\n}\nfunction unicodeUnmapper(v) {\n    if (v < 0xd800)\n        return indexToPrintableIndexUnmapper(v);\n    if (v <= 0xdfff)\n        return -1;\n    return v - gapSize;\n}\nexport function fullUnicode() {\n    return buildCharacterArbitrary(0x0000, 0x10ffff - gapSize, unicodeMapper, unicodeUnmapper);\n}\n", "import { buildCharacterArbitrary } from './_internals/builders/CharacterArbitraryBuilder.js';\nfunction hexaMapper(v) {\n    return v < 10\n        ? v + 48\n        : v + 97 - 10;\n}\nfunction hexaUnmapper(v) {\n    return v < 58\n        ? v - 48\n        : v < 103\n            ? v - 97 + 10\n            : -1;\n}\nexport function hexa() {\n    return buildCharacterArbitrary(0, 15, hexaMapper, hexaUnmapper);\n}\n", "import { buildCharacterArbitrary } from './_internals/builders/CharacterArbitraryBuilder.js';\nimport { indexToPrintableIndexMapper, indexToPrintableIndexUnmapper } from './_internals/mappers/IndexToPrintableIndex.js';\nconst gapSize = 0xdfff + 1 - 0xd800;\nfunction unicodeMapper(v) {\n    if (v < 0xd800)\n        return indexToPrintableIndexMapper(v);\n    return v + gapSize;\n}\nfunction unicodeUnmapper(v) {\n    if (v < 0xd800)\n        return indexToPrintableIndexUnmapper(v);\n    if (v <= 0xdfff)\n        return -1;\n    return v - gapSize;\n}\nexport function unicode() {\n    return buildCharacterArbitrary(0x0000, 0xffff - gapSize, unicodeMapper, unicodeUnmapper);\n}\n", "import { convertFromNext } from '../check/arbitrary/definition/Converters.js';\nimport { ConstantArbitrary } from './_internals/ConstantArbitrary.js';\nexport function constant(value) {\n    return convertFromNext(new ConstantArbitrary([value]));\n}\n", "import { constant } from './constant.js';\nexport const clonedConstant = constant;\n", "import { cloneMethod } from '../check/symbols.js';\nimport { constant } from './constant.js';\nclass ContextImplem {\n    constructor() {\n        this.receivedLogs = [];\n    }\n    log(data) {\n        this.receivedLogs.push(data);\n    }\n    size() {\n        return this.receivedLogs.length;\n    }\n    toString() {\n        return JSON.stringify({ logs: this.receivedLogs });\n    }\n    [cloneMethod]() {\n        return new ContextImplem();\n    }\n}\nexport function context() {\n    return constant(new ContextImplem());\n}\n", "export function timeToDateMapper(time) {\n    return new Date(time);\n}\nexport function timeToDateUnmapper(value) {\n    if (!(value instanceof Date) || value.constructor !== Date) {\n        throw new Error('Not a valid value for date unmapper');\n    }\n    return value.getTime();\n}\n", "import { convertFromNext, convertToNext } from '../check/arbitrary/definition/Converters.js';\nimport { integer } from './integer.js';\nimport { timeToDateMapper, timeToDateUnmapper } from './_internals/mappers/TimeToDate.js';\nexport function date(constraints) {\n    const intMin = constraints && constraints.min !== undefined ? constraints.min.getTime() : -8640000000000000;\n    const intMax = constraints && constraints.max !== undefined ? constraints.max.getTime() : 8640000000000000;\n    if (Number.isNaN(intMin))\n        throw new Error('fc.date min must be valid instance of Date');\n    if (Number.isNaN(intMax))\n        throw new Error('fc.date max must be valid instance of Date');\n    if (intMin > intMax)\n        throw new Error('fc.date max must be greater or equal to min');\n    return convertFromNext(convertToNext(integer(intMin, intMax)).map(timeToDateMapper, timeToDateUnmapper));\n}\n", "import { NextArbitrary } from '../../check/arbitrary/definition/NextArbitrary.js';\nimport { NextValue } from '../../check/arbitrary/definition/NextValue.js';\nimport { cloneMethod } from '../../check/symbols.js';\nimport { Stream } from '../../stream/Stream.js';\nexport class CloneArbitrary extends NextArbitrary {\n    constructor(arb, numValues) {\n        super();\n        this.arb = arb;\n        this.numValues = numValues;\n    }\n    generate(mrng, biasFactor) {\n        const items = [];\n        if (this.numValues <= 0) {\n            return this.wrapper(items);\n        }\n        for (let idx = 0; idx !== this.numValues - 1; ++idx) {\n            items.push(this.arb.generate(mrng.clone(), biasFactor));\n        }\n        items.push(this.arb.generate(mrng, biasFactor));\n        return this.wrapper(items);\n    }\n    canShrinkWithoutContext(value) {\n        if (!Array.isArray(value) || value.length !== this.numValues) {\n            return false;\n        }\n        if (value.length === 0) {\n            return true;\n        }\n        for (let index = 1; index < value.length; ++index) {\n            if (!Object.is(value[0], value[index])) {\n                return false;\n            }\n        }\n        return this.arb.canShrinkWithoutContext(value[0]);\n    }\n    shrink(value, context) {\n        if (value.length === 0) {\n            return Stream.nil();\n        }\n        return new Stream(this.shrinkImpl(value, context !== undefined ? context : [])).map((v) => this.wrapper(v));\n    }\n    *shrinkImpl(value, contexts) {\n        const its = value.map((v, idx) => this.arb.shrink(v, contexts[idx])[Symbol.iterator]());\n        let cur = its.map((it) => it.next());\n        while (!cur[0].done) {\n            yield cur.map((c) => c.value);\n            cur = its.map((it) => it.next());\n        }\n    }\n    static makeItCloneable(vs, shrinkables) {\n        vs[cloneMethod] = () => {\n            const cloned = [];\n            for (let idx = 0; idx !== shrinkables.length; ++idx) {\n                cloned.push(shrinkables[idx].value);\n            }\n            this.makeItCloneable(cloned, shrinkables);\n            return cloned;\n        };\n        return vs;\n    }\n    wrapper(items) {\n        let cloneable = false;\n        const vs = [];\n        const contexts = [];\n        for (let idx = 0; idx !== items.length; ++idx) {\n            const s = items[idx];\n            cloneable = cloneable || s.hasToBeCloned;\n            vs.push(s.value);\n            contexts.push(s.context);\n        }\n        if (cloneable) {\n            CloneArbitrary.makeItCloneable(vs, items);\n        }\n        return new NextValue(vs, contexts);\n    }\n}\n", "import { convertFromNext, convertToNext } from '../check/arbitrary/definition/Converters.js';\nimport { CloneArbitrary } from './_internals/CloneArbitrary.js';\nfunction clone(arb, numValues) {\n    return convertFromNext(new CloneArbitrary(convertToNext(arb), numValues));\n}\nexport { clone };\n", "import { clone } from './clone.js';\nexport const dedup = clone;\n", "import { ArrayArbitrary } from './_internals/ArrayArbitrary.js';\nimport { convertFromNext, convertToNext } from '../check/arbitrary/definition/Converters.js';\nimport { maxLengthFromMinLength } from './_internals/helpers/MaxLengthFromMinLength.js';\nfunction buildCompleteSetConstraints(constraints) {\n    const minLength = constraints.minLength !== undefined ? constraints.minLength : 0;\n    const maxLength = constraints.maxLength !== undefined ? constraints.maxLength : maxLengthFromMinLength(minLength);\n    const compare = constraints.compare !== undefined ? constraints.compare : (a, b) => a === b;\n    return { minLength, maxLength, compare };\n}\nfunction extractSetConstraints(args) {\n    if (args[0] === undefined) {\n        return {};\n    }\n    if (args[1] === undefined) {\n        const sargs = args;\n        if (typeof sargs[0] === 'number')\n            return { maxLength: sargs[0] };\n        if (typeof sargs[0] === 'function')\n            return { compare: sargs[0] };\n        return sargs[0];\n    }\n    if (args[2] === undefined) {\n        const sargs = args;\n        if (typeof sargs[1] === 'number')\n            return { minLength: sargs[0], maxLength: sargs[1] };\n        return { maxLength: sargs[0], compare: sargs[1] };\n    }\n    const sargs = args;\n    return { minLength: sargs[0], maxLength: sargs[1], compare: sargs[2] };\n}\nfunction set(arb, ...args) {\n    const constraints = buildCompleteSetConstraints(extractSetConstraints(args));\n    const minLength = constraints.minLength;\n    const maxLength = constraints.maxLength;\n    const compare = constraints.compare;\n    const nextArb = convertToNext(arb);\n    const arrayArb = convertFromNext(new ArrayArbitrary(nextArb, minLength, maxLength, compare));\n    if (minLength === 0)\n        return arrayArb;\n    return arrayArb.filter((tab) => tab.length >= minLength);\n}\nexport { set };\n", "import { convertFromNext, convertToNext } from '../check/arbitrary/definition/Converters.js';\nimport { TupleArbitrary } from './_internals/TupleArbitrary.js';\nexport function tuple(...arbs) {\n    const nextArbs = arbs.map((arb) => convertToNext(arb));\n    return convertFromNext(new TupleArbitrary(nextArbs));\n}\n", "export function keyValuePairsToObjectMapper(items) {\n    const obj = {};\n    for (const keyValue of items) {\n        obj[keyValue[0]] = keyValue[1];\n    }\n    return obj;\n}\nfunction buildInvalidPropertyNameFilter(obj) {\n    return function invalidPropertyNameFilter(key) {\n        const descriptor = Object.getOwnPropertyDescriptor(obj, key);\n        return (descriptor === undefined ||\n            !descriptor.configurable ||\n            !descriptor.enumerable ||\n            !descriptor.writable ||\n            descriptor.get !== undefined ||\n            descriptor.set !== undefined);\n    };\n}\nexport function keyValuePairsToObjectUnmapper(value) {\n    if (typeof value !== 'object' || value === null) {\n        throw new Error('Incompatible instance received: should be a non-null object');\n    }\n    if (!('constructor' in value) || value.constructor !== Object) {\n        throw new Error('Incompatible instance received: should be of exact type Object');\n    }\n    if (Object.getOwnPropertySymbols(value).length > 0) {\n        throw new Error('Incompatible instance received: should contain symbols');\n    }\n    if (Object.getOwnPropertyNames(value).find(buildInvalidPropertyNameFilter(value)) !== undefined) {\n        throw new Error('Incompatible instance received: should contain only c/e/w properties without get/set');\n    }\n    return Object.entries(value);\n}\n", "import { convertFromNext, convertToNext } from '../check/arbitrary/definition/Converters.js';\nimport { set } from './set.js';\nimport { tuple } from './tuple.js';\nimport { keyValuePairsToObjectMapper, keyValuePairsToObjectUnmapper } from './_internals/mappers/KeyValuePairsToObject.js';\nexport function dictionary(keyArb, valueArb) {\n    return convertFromNext(convertToNext(set(tuple(keyArb, valueArb), { compare: (t1, t2) => t1[0] === t2[0] })).map(keyValuePairsToObjectMapper, keyValuePairsToObjectUnmapper));\n}\n", "const depthContextCache = new Map();\nexport function getDepthContextFor(contextMeta) {\n    if (contextMeta === undefined) {\n        return { depth: 0 };\n    }\n    if (typeof contextMeta !== 'string') {\n        return contextMeta;\n    }\n    const cachedContext = depthContextCache.get(contextMeta);\n    if (cachedContext !== undefined) {\n        return cachedContext;\n    }\n    const context = { depth: 0 };\n    depthContextCache.set(contextMeta, context);\n    return context;\n}\n", "import { Stream } from '../../stream/Stream.js';\nimport { convertFromNext, convertToNext } from '../../check/arbitrary/definition/Converters.js';\nimport { NextArbitrary } from '../../check/arbitrary/definition/NextArbitrary.js';\nimport { NextValue } from '../../check/arbitrary/definition/NextValue.js';\nimport { getDepthContextFor } from './helpers/DepthContext.js';\nexport class FrequencyArbitrary extends NextArbitrary {\n    constructor(warbs, constraints, context) {\n        super();\n        this.warbs = warbs;\n        this.constraints = constraints;\n        this.context = context;\n        let currentWeight = 0;\n        this.cumulatedWeights = [];\n        for (let idx = 0; idx !== warbs.length; ++idx) {\n            currentWeight += warbs[idx].weight;\n            this.cumulatedWeights.push(currentWeight);\n        }\n        this.totalWeight = currentWeight;\n    }\n    static fromOld(warbs, constraints, label) {\n        return convertFromNext(FrequencyArbitrary.from(warbs.map((w) => (Object.assign(Object.assign({}, w), { arbitrary: convertToNext(w.arbitrary) }))), constraints, label));\n    }\n    static from(warbs, constraints, label) {\n        if (warbs.length === 0) {\n            throw new Error(`${label} expects at least one weigthed arbitrary`);\n        }\n        let totalWeight = 0;\n        for (let idx = 0; idx !== warbs.length; ++idx) {\n            const currentArbitrary = warbs[idx].arbitrary;\n            if (currentArbitrary === undefined) {\n                throw new Error(`${label} expects arbitraries to be specified`);\n            }\n            const currentWeight = warbs[idx].weight;\n            totalWeight += currentWeight;\n            if (!Number.isInteger(currentWeight)) {\n                throw new Error(`${label} expects weights to be integer values`);\n            }\n            if (currentWeight < 0) {\n                throw new Error(`${label} expects weights to be superior or equal to 0`);\n            }\n        }\n        if (totalWeight <= 0) {\n            throw new Error(`${label} expects the sum of weights to be strictly superior to 0`);\n        }\n        return new FrequencyArbitrary(warbs, constraints, getDepthContextFor(constraints.depthIdentifier));\n    }\n    generate(mrng, biasFactor) {\n        if (this.mustGenerateFirst()) {\n            return this.safeGenerateForIndex(mrng, 0, biasFactor);\n        }\n        const selected = mrng.nextInt(this.computeNegDepthBenefit(), this.totalWeight - 1);\n        for (let idx = 0; idx !== this.cumulatedWeights.length; ++idx) {\n            if (selected < this.cumulatedWeights[idx]) {\n                return this.safeGenerateForIndex(mrng, idx, biasFactor);\n            }\n        }\n        throw new Error(`Unable to generate from fc.frequency`);\n    }\n    canShrinkWithoutContext(value) {\n        return this.canShrinkWithoutContextIndex(value) !== -1;\n    }\n    shrink(value, context) {\n        if (context !== undefined) {\n            const safeContext = context;\n            const selectedIndex = safeContext.selectedIndex;\n            const originalBias = safeContext.originalBias;\n            const originalArbitrary = this.warbs[selectedIndex].arbitrary;\n            const originalShrinks = originalArbitrary\n                .shrink(value, safeContext.originalContext)\n                .map((v) => this.mapIntoNextValue(selectedIndex, v, null, originalBias));\n            if (safeContext.clonedMrngForFallbackFirst !== null) {\n                if (safeContext.cachedGeneratedForFirst === undefined) {\n                    safeContext.cachedGeneratedForFirst = this.safeGenerateForIndex(safeContext.clonedMrngForFallbackFirst, 0, originalBias);\n                }\n                const valueFromFirst = safeContext.cachedGeneratedForFirst;\n                return Stream.of(valueFromFirst).join(originalShrinks);\n            }\n            return originalShrinks;\n        }\n        const potentialSelectedIndex = this.canShrinkWithoutContextIndex(value);\n        if (potentialSelectedIndex === -1) {\n            return Stream.nil();\n        }\n        return this.defaultShrinkForFirst(potentialSelectedIndex).join(this.warbs[potentialSelectedIndex].arbitrary\n            .shrink(value, undefined)\n            .map((v) => this.mapIntoNextValue(potentialSelectedIndex, v, null, undefined)));\n    }\n    defaultShrinkForFirst(selectedIndex) {\n        ++this.context.depth;\n        try {\n            if (!this.mustFallbackToFirstInShrink(selectedIndex) || this.warbs[0].fallbackValue === undefined) {\n                return Stream.nil();\n            }\n        }\n        finally {\n            --this.context.depth;\n        }\n        const rawShrinkValue = new NextValue(this.warbs[0].fallbackValue.default, undefined);\n        return Stream.of(this.mapIntoNextValue(0, rawShrinkValue, null, undefined));\n    }\n    canShrinkWithoutContextIndex(value) {\n        if (this.mustGenerateFirst()) {\n            return this.warbs[0].arbitrary.canShrinkWithoutContext(value) ? 0 : -1;\n        }\n        try {\n            ++this.context.depth;\n            for (let idx = 0; idx !== this.warbs.length; ++idx) {\n                const warb = this.warbs[idx];\n                if (warb.weight !== 0 && warb.arbitrary.canShrinkWithoutContext(value)) {\n                    return idx;\n                }\n            }\n            return -1;\n        }\n        finally {\n            --this.context.depth;\n        }\n    }\n    mapIntoNextValue(idx, value, clonedMrngForFallbackFirst, biasFactor) {\n        const context = {\n            selectedIndex: idx,\n            originalBias: biasFactor,\n            originalContext: value.context,\n            clonedMrngForFallbackFirst,\n        };\n        return new NextValue(value.value, context);\n    }\n    safeGenerateForIndex(mrng, idx, biasFactor) {\n        ++this.context.depth;\n        try {\n            const value = this.warbs[idx].arbitrary.generate(mrng, biasFactor);\n            const clonedMrngForFallbackFirst = this.mustFallbackToFirstInShrink(idx) ? mrng.clone() : null;\n            return this.mapIntoNextValue(idx, value, clonedMrngForFallbackFirst, biasFactor);\n        }\n        finally {\n            --this.context.depth;\n        }\n    }\n    mustGenerateFirst() {\n        return this.constraints.maxDepth !== undefined && this.constraints.maxDepth <= this.context.depth;\n    }\n    mustFallbackToFirstInShrink(idx) {\n        return idx !== 0 && !!this.constraints.withCrossShrink && this.warbs[0].weight !== 0;\n    }\n    computeNegDepthBenefit() {\n        const depthFactor = this.constraints.depthFactor;\n        if (depthFactor === undefined || depthFactor <= 0) {\n            return 0;\n        }\n        const depthBenefit = Math.floor(Math.pow(1 + depthFactor, this.context.depth)) - 1;\n        return -Math.min(this.warbs[0].weight * depthBenefit, Number.MAX_SAFE_INTEGER) || 0;\n    }\n}\n", "import { FrequencyArbitrary } from './_internals/FrequencyArbitrary.js';\nfunction isFrequencyContraints(param) {\n    return param != null && typeof param === 'object' && !('arbitrary' in param);\n}\nfunction frequency(...args) {\n    const label = 'fc.frequency';\n    const constraints = args[0];\n    if (isFrequencyContraints(constraints)) {\n        return FrequencyArbitrary.fromOld(args.slice(1), constraints, label);\n    }\n    return FrequencyArbitrary.fromOld(args, {}, label);\n}\nexport { frequency };\n", "import { convertFromNextWithShrunkOnce } from '../check/arbitrary/definition/Converters.js';\nimport { IntegerArbitrary } from './_internals/IntegerArbitrary.js';\nfunction nat(arg) {\n    const max = typeof arg === 'number' ? arg : arg && arg.max !== undefined ? arg.max : 0x7fffffff;\n    if (max < 0) {\n        throw new Error('fc.nat value should be greater than or equal to 0');\n    }\n    const arb = new IntegerArbitrary(0, max);\n    return convertFromNextWithShrunkOnce(arb, arb.defaultTarget());\n}\nexport { nat };\n", "export function indexToMappedConstantMapperFor(entries) {\n    return function indexToMappedConstantMapper(choiceIndex) {\n        let idx = -1;\n        let numSkips = 0;\n        while (choiceIndex >= numSkips) {\n            numSkips += entries[++idx].num;\n        }\n        return entries[idx].build(choiceIndex - numSkips + entries[idx].num);\n    };\n}\nfunction buildReverseMapping(entries) {\n    const reverseMapping = { mapping: new Map(), negativeZeroIndex: undefined };\n    let choiceIndex = 0;\n    for (let entryIdx = 0; entryIdx !== entries.length; ++entryIdx) {\n        const entry = entries[entryIdx];\n        for (let idxInEntry = 0; idxInEntry !== entry.num; ++idxInEntry) {\n            const value = entry.build(idxInEntry);\n            if (value === 0 && 1 / value === Number.NEGATIVE_INFINITY) {\n                reverseMapping.negativeZeroIndex = choiceIndex;\n            }\n            else {\n                reverseMapping.mapping.set(value, choiceIndex);\n            }\n            ++choiceIndex;\n        }\n    }\n    return reverseMapping;\n}\nexport function indexToMappedConstantUnmapperFor(entries) {\n    let reverseMapping = null;\n    return function indexToMappedConstantUnmapper(value) {\n        if (reverseMapping === null) {\n            reverseMapping = buildReverseMapping(entries);\n        }\n        const choiceIndex = Object.is(value, -0) ? reverseMapping.negativeZeroIndex : reverseMapping.mapping.get(value);\n        if (choiceIndex === undefined) {\n            throw new Error('Unknown value encountered cannot be built using this mapToConstant');\n        }\n        return choiceIndex;\n    };\n}\n", "import { convertFromNext, convertToNext } from '../check/arbitrary/definition/Converters.js';\nimport { nat } from './nat.js';\nimport { indexToMappedConstantMapperFor, indexToMappedConstantUnmapperFor, } from './_internals/mappers/IndexToMappedConstant.js';\nfunction computeNumChoices(options) {\n    if (options.length === 0)\n        throw new Error(`fc.mapToConstant expects at least one option`);\n    let numChoices = 0;\n    for (let idx = 0; idx !== options.length; ++idx) {\n        if (options[idx].num < 0)\n            throw new Error(`fc.mapToConstant expects all options to have a number of entries greater or equal to zero`);\n        numChoices += options[idx].num;\n    }\n    if (numChoices === 0)\n        throw new Error(`fc.mapToConstant expects at least one choice among options`);\n    return numChoices;\n}\nexport function mapToConstant(...entries) {\n    const numChoices = computeNumChoices(entries);\n    return convertFromNext(convertToNext(nat({ max: numChoices - 1 })).map(indexToMappedConstantMapperFor(entries), indexToMappedConstantUnmapperFor(entries)));\n}\n", "import { fullUnicode } from '../../../arbitrary/fullUnicode.js';\nimport { frequency } from '../../../arbitrary/frequency.js';\nimport { mapToConstant } from '../../../arbitrary/mapToConstant.js';\nconst lowerCaseMapper = { num: 26, build: (v) => String.fromCharCode(v + 0x61) };\nconst upperCaseMapper = { num: 26, build: (v) => String.fromCharCode(v + 0x41) };\nconst numericMapper = { num: 10, build: (v) => String.fromCharCode(v + 0x30) };\nconst percentCharArb = fullUnicode().map((c) => {\n    const encoded = encodeURIComponent(c);\n    return c !== encoded ? encoded : `%${c.charCodeAt(0).toString(16)}`;\n});\nexport const buildLowerAlphaArb = (others) => mapToConstant(lowerCaseMapper, { num: others.length, build: (v) => others[v] });\nexport const buildLowerAlphaNumericArb = (others) => mapToConstant(lowerCaseMapper, numericMapper, { num: others.length, build: (v) => others[v] });\nexport const buildAlphaNumericArb = (others) => mapToConstant(lowerCaseMapper, upperCaseMapper, numericMapper, { num: others.length, build: (v) => others[v] });\nexport const buildAlphaNumericPercentArb = (others) => frequency({\n    weight: 10,\n    arbitrary: buildAlphaNumericArb(others),\n}, {\n    weight: 1,\n    arbitrary: percentCharArb,\n});\n", "import { constant } from './constant.js';\nimport { FrequencyArbitrary } from './_internals/FrequencyArbitrary.js';\nfunction extractOptionConstraints(constraints) {\n    if (typeof constraints === 'number')\n        return { freq: constraints };\n    if (!constraints)\n        return {};\n    return constraints;\n}\nfunction option(arb, rawConstraints) {\n    const constraints = extractOptionConstraints(rawConstraints);\n    const freq = constraints.freq == null ? 5 : constraints.freq;\n    const nilValue = Object.prototype.hasOwnProperty.call(constraints, 'nil') ? constraints.nil : null;\n    const nilArb = constant(nilValue);\n    const weightedArbs = [\n        { arbitrary: nilArb, weight: 1, fallbackValue: { default: nilValue } },\n        { arbitrary: arb, weight: freq },\n    ];\n    const frequencyConstraints = {\n        withCrossShrink: true,\n        depthFactor: constraints.depthFactor,\n        maxDepth: constraints.maxDepth,\n        depthIdentifier: constraints.depthIdentifier,\n    };\n    return FrequencyArbitrary.fromOld(weightedArbs, frequencyConstraints, 'fc.option');\n}\nexport { option };\n", "export function extractStringConstraints(options) {\n    return options[0] !== undefined\n        ? typeof options[0] === 'number'\n            ? typeof options[1] === 'number'\n                ? { minLength: options[0], maxLength: options[1] }\n                : { maxLength: options[0] }\n            : options[0]\n        : {};\n}\n", "import { maxLengthFromMinLength } from '../helpers/MaxLengthFromMinLength.js';\nexport function patternsToStringMapper(tab) {\n    return tab.join('');\n}\nexport function patternsToStringUnmapperFor(patternsArb, constraints) {\n    return function patternsToStringUnmapper(value) {\n        if (typeof value !== 'string') {\n            throw new Error('Unsupported value');\n        }\n        const minLength = constraints.minLength !== undefined ? constraints.minLength : 0;\n        const maxLength = constraints.maxLength !== undefined ? constraints.maxLength : maxLengthFromMinLength(minLength);\n        if (value.length === 0) {\n            if (minLength > 0) {\n                throw new Error('Unable to unmap received string');\n            }\n            return [];\n        }\n        const stack = [{ endIndexChunks: 0, nextStartIndex: 1, chunks: [] }];\n        while (stack.length > 0) {\n            const last = stack.pop();\n            for (let index = last.nextStartIndex; index <= value.length; ++index) {\n                const chunk = value.substring(last.endIndexChunks, index);\n                if (patternsArb.canShrinkWithoutContext(chunk)) {\n                    const newChunks = last.chunks.concat([chunk]);\n                    if (index === value.length) {\n                        if (newChunks.length < minLength || newChunks.length > maxLength) {\n                            break;\n                        }\n                        return newChunks;\n                    }\n                    stack.push({ endIndexChunks: last.endIndexChunks, nextStartIndex: index + 1, chunks: last.chunks });\n                    stack.push({ endIndexChunks: index, nextStartIndex: index + 1, chunks: newChunks });\n                    break;\n                }\n            }\n        }\n        throw new Error('Unable to unmap received string');\n    };\n}\n", "import { convertFromNext, convertToNext } from '../check/arbitrary/definition/Converters.js';\nimport { array } from './array.js';\nimport { extractStringConstraints, } from './_internals/helpers/StringConstraintsExtractor.js';\nimport { patternsToStringMapper, patternsToStringUnmapperFor } from './_internals/mappers/PatternsToString.js';\nfunction stringOf(charArb, ...args) {\n    const constraints = extractStringConstraints(args);\n    return convertFromNext(convertToNext(array(charArb, constraints)).map(patternsToStringMapper, patternsToStringUnmapperFor(convertToNext(charArb), constraints)));\n}\nexport { stringOf };\n", "import { array } from '../../arbitrary/array.js';\nimport { buildAlphaNumericPercentArb, buildLowerAlphaArb, buildLowerAlphaNumericArb, } from './helpers/SpecificCharacterRange.js';\nimport { option } from '../../arbitrary/option.js';\nimport { stringOf } from '../../arbitrary/stringOf.js';\nimport { tuple } from '../../arbitrary/tuple.js';\nexport function filterInvalidSubdomainLabel(subdomainLabel) {\n    if (subdomainLabel.length > 63) {\n        return false;\n    }\n    return (subdomainLabel.length < 4 ||\n        subdomainLabel[0] !== 'x' ||\n        subdomainLabel[1] !== 'n' ||\n        subdomainLabel[2] !== '-' ||\n        subdomainLabel[3] !== '-');\n}\nfunction subdomainLabel() {\n    const alphaNumericArb = buildLowerAlphaNumericArb([]);\n    const alphaNumericHyphenArb = buildLowerAlphaNumericArb(['-']);\n    return tuple(alphaNumericArb, option(tuple(stringOf(alphaNumericHyphenArb, { maxLength: 61 }), alphaNumericArb)))\n        .map(([f, d]) => (d === null ? f : `${f}${d[0]}${d[1]}`))\n        .filter(filterInvalidSubdomainLabel);\n}\nexport function domain() {\n    const alphaNumericArb = buildLowerAlphaArb([]);\n    const publicSuffixArb = stringOf(alphaNumericArb, { minLength: 2, maxLength: 10 });\n    return (tuple(array(subdomainLabel(), { minLength: 1, maxLength: 5 }), publicSuffixArb)\n        .map(([mid, ext]) => `${mid.join('.')}.${ext}`)\n        .filter((d) => d.length <= 255));\n}\nexport function hostUserInfo() {\n    const others = ['-', '.', '_', '~', '!', '$', '&', \"'\", '(', ')', '*', '+', ',', ';', '=', ':'];\n    return stringOf(buildAlphaNumericPercentArb(others));\n}\n", "import { array } from '../../arbitrary/array.js';\nimport { buildLowerAlphaNumericArb } from './helpers/SpecificCharacterRange.js';\nimport { domain } from './HostArbitrary.js';\nimport { stringOf } from '../../arbitrary/stringOf.js';\nimport { tuple } from '../../arbitrary/tuple.js';\nexport function emailAddress() {\n    const others = ['!', '#', '$', '%', '&', \"'\", '*', '+', '-', '/', '=', '?', '^', '_', '`', '{', '|', '}', '~'];\n    const atextArb = buildLowerAlphaNumericArb(others);\n    const localPartArb = array(stringOf(atextArb, { minLength: 1, maxLength: 10 }), { minLength: 1, maxLength: 5 })\n        .map((a) => a.join('.'))\n        .filter((lp) => lp.length <= 64);\n    return tuple(localPartArb, domain()).map(([lp, d]) => `${lp}@${d}`);\n}\n", "export const Zero64 = { sign: 1, data: [0, 0] };\nexport const Unit64 = { sign: 1, data: [0, 1] };\nexport function isZero64(a) {\n    return a.data[0] === 0 && a.data[1] === 0;\n}\nexport function isStrictlyNegative64(a) {\n    return a.sign === -1 && !isZero64(a);\n}\nexport function isStrictlyPositive64(a) {\n    return a.sign === 1 && !isZero64(a);\n}\nexport function isEqual64(a, b) {\n    if (a.data[0] === b.data[0] && a.data[1] === b.data[1]) {\n        return a.sign === b.sign || (a.data[0] === 0 && a.data[1] === 0);\n    }\n    return false;\n}\nfunction isStrictlySmaller64Internal(a, b) {\n    return a[0] < b[0] || (a[0] === b[0] && a[1] < b[1]);\n}\nexport function isStrictlySmaller64(a, b) {\n    if (a.sign === b.sign) {\n        return a.sign === 1\n            ? isStrictlySmaller64Internal(a.data, b.data)\n            : isStrictlySmaller64Internal(b.data, a.data);\n    }\n    return a.sign === -1 && (!isZero64(a) || !isZero64(b));\n}\nexport function clone64(a) {\n    return { sign: a.sign, data: [a.data[0], a.data[1]] };\n}\nfunction substract64DataInternal(a, b) {\n    let reminderLow = 0;\n    let low = a[1] - b[1];\n    if (low < 0) {\n        reminderLow = 1;\n        low = low >>> 0;\n    }\n    return [a[0] - b[0] - reminderLow, low];\n}\nfunction substract64Internal(a, b) {\n    if (a.sign === 1 && b.sign === -1) {\n        const low = a.data[1] + b.data[1];\n        const high = a.data[0] + b.data[0] + (low > 0xffffffff ? 1 : 0);\n        return { sign: 1, data: [high >>> 0, low >>> 0] };\n    }\n    return {\n        sign: 1,\n        data: a.sign === 1 ? substract64DataInternal(a.data, b.data) : substract64DataInternal(b.data, a.data),\n    };\n}\nexport function substract64(arrayIntA, arrayIntB) {\n    if (isStrictlySmaller64(arrayIntA, arrayIntB)) {\n        const out = substract64Internal(arrayIntB, arrayIntA);\n        out.sign = -1;\n        return out;\n    }\n    return substract64Internal(arrayIntA, arrayIntB);\n}\nexport function negative64(arrayIntA) {\n    return {\n        sign: -arrayIntA.sign,\n        data: [arrayIntA.data[0], arrayIntA.data[1]],\n    };\n}\nexport function add64(arrayIntA, arrayIntB) {\n    if (isZero64(arrayIntB)) {\n        if (isZero64(arrayIntA)) {\n            return clone64(Zero64);\n        }\n        return clone64(arrayIntA);\n    }\n    return substract64(arrayIntA, negative64(arrayIntB));\n}\nexport function halve64(a) {\n    return {\n        sign: a.sign,\n        data: [Math.floor(a.data[0] / 2), (a.data[0] % 2 === 1 ? 0x80000000 : 0) + Math.floor(a.data[1] / 2)],\n    };\n}\nexport function logLike64(a) {\n    return {\n        sign: a.sign,\n        data: [0, Math.floor(Math.log(a.data[0] * 0x100000000 + a.data[1]) / Math.log(2))],\n    };\n}\n", "import { stream, Stream } from '../../../stream/Stream.js';\nimport { convertFromNextWithShrunkOnce } from '../definition/Converters.js';\nimport { NextArbitrary } from '../definition/NextArbitrary.js';\nimport { NextValue } from '../definition/NextValue.js';\nimport { add64, halve64, isEqual64, isStrictlyNegative64, isStrictlyPositive64, isStrictlySmaller64, isZero64, logLike64, substract64, Unit64, Zero64, } from './ArrayInt64.js';\nclass ArrayInt64Arbitrary extends NextArbitrary {\n    constructor(min, max) {\n        super();\n        this.min = min;\n        this.max = max;\n        this.biasedRanges = null;\n    }\n    generate(mrng, biasFactor) {\n        const range = this.computeGenerateRange(mrng, biasFactor);\n        const uncheckedValue = mrng.nextArrayInt(range.min, range.max);\n        if (uncheckedValue.data.length === 1) {\n            uncheckedValue.data.unshift(0);\n        }\n        return new NextValue(uncheckedValue, undefined);\n    }\n    computeGenerateRange(mrng, biasFactor) {\n        if (biasFactor === undefined || mrng.nextInt(1, biasFactor) !== 1) {\n            return { min: this.min, max: this.max };\n        }\n        const ranges = this.retrieveBiasedRanges();\n        if (ranges.length === 1) {\n            return ranges[0];\n        }\n        const id = mrng.nextInt(-2 * (ranges.length - 1), ranges.length - 2);\n        return id < 0 ? ranges[0] : ranges[id + 1];\n    }\n    canShrinkWithoutContext(value) {\n        const unsafeValue = value;\n        return (typeof value === 'object' &&\n            value !== null &&\n            (unsafeValue.sign === -1 || unsafeValue.sign === 1) &&\n            Array.isArray(unsafeValue.data) &&\n            unsafeValue.data.length === 2 &&\n            ((isStrictlySmaller64(this.min, unsafeValue) && isStrictlySmaller64(unsafeValue, this.max)) ||\n                isEqual64(this.min, unsafeValue) ||\n                isEqual64(this.max, unsafeValue)));\n    }\n    shrinkArrayInt64(value, target, tryTargetAsap) {\n        const realGap = substract64(value, target);\n        function* shrinkGen() {\n            let previous = tryTargetAsap ? undefined : target;\n            const gap = tryTargetAsap ? realGap : halve64(realGap);\n            for (let toremove = gap; !isZero64(toremove); toremove = halve64(toremove)) {\n                const next = substract64(value, toremove);\n                yield new NextValue(next, previous);\n                previous = next;\n            }\n        }\n        return stream(shrinkGen());\n    }\n    shrink(current, context) {\n        if (!ArrayInt64Arbitrary.isValidContext(current, context)) {\n            const target = this.defaultTarget();\n            return this.shrinkArrayInt64(current, target, true);\n        }\n        if (this.isLastChanceTry(current, context)) {\n            return Stream.of(new NextValue(context, undefined));\n        }\n        return this.shrinkArrayInt64(current, context, false);\n    }\n    defaultTarget() {\n        if (!isStrictlyPositive64(this.min) && !isStrictlyNegative64(this.max)) {\n            return Zero64;\n        }\n        return isStrictlyNegative64(this.min) ? this.max : this.min;\n    }\n    isLastChanceTry(current, context) {\n        if (isZero64(current)) {\n            return false;\n        }\n        if (current.sign === 1) {\n            return isEqual64(current, add64(context, Unit64)) && isStrictlyPositive64(substract64(current, this.min));\n        }\n        else {\n            return isEqual64(current, substract64(context, Unit64)) && isStrictlyNegative64(substract64(current, this.max));\n        }\n    }\n    static isValidContext(_current, context) {\n        if (context === undefined) {\n            return false;\n        }\n        if (typeof context !== 'object' || context === null || !('sign' in context) || !('data' in context)) {\n            throw new Error(`Invalid context type passed to ArrayInt64Arbitrary (#1)`);\n        }\n        return true;\n    }\n    retrieveBiasedRanges() {\n        if (this.biasedRanges != null) {\n            return this.biasedRanges;\n        }\n        if (isEqual64(this.min, this.max)) {\n            this.biasedRanges = [{ min: this.min, max: this.max }];\n            return this.biasedRanges;\n        }\n        const minStrictlySmallerZero = isStrictlyNegative64(this.min);\n        const maxStrictlyGreaterZero = isStrictlyPositive64(this.max);\n        if (minStrictlySmallerZero && maxStrictlyGreaterZero) {\n            const logMin = logLike64(this.min);\n            const logMax = logLike64(this.max);\n            this.biasedRanges = [\n                { min: logMin, max: logMax },\n                { min: substract64(this.max, logMax), max: this.max },\n                { min: this.min, max: substract64(this.min, logMin) },\n            ];\n        }\n        else {\n            const logGap = logLike64(substract64(this.max, this.min));\n            const arbCloseToMin = { min: this.min, max: add64(this.min, logGap) };\n            const arbCloseToMax = { min: substract64(this.max, logGap), max: this.max };\n            this.biasedRanges = minStrictlySmallerZero\n                ? [arbCloseToMax, arbCloseToMin]\n                : [arbCloseToMin, arbCloseToMax];\n        }\n        return this.biasedRanges;\n    }\n}\nexport function arrayInt64(min, max) {\n    const arb = new ArrayInt64Arbitrary(min, max);\n    return convertFromNextWithShrunkOnce(arb, arb.defaultTarget());\n}\n", "import { add64, clone64, isEqual64, isStrictlyPositive64, isStrictlySmaller64, substract64, Unit64, } from './helpers/ArrayInt64.js';\nimport { arrayInt64 } from './helpers/ArrayInt64Arbitrary.js';\nconst INDEX_POSITIVE_INFINITY = { sign: 1, data: [2146435072, 0] };\nconst INDEX_NEGATIVE_INFINITY = { sign: -1, data: [2146435072, 1] };\nexport function decomposeDouble(d) {\n    const maxSignificand = 2 - Number.EPSILON;\n    for (let exponent = -1022; exponent !== 1024; ++exponent) {\n        const powExponent = 2 ** exponent;\n        const maxForExponent = maxSignificand * powExponent;\n        if (Math.abs(d) <= maxForExponent) {\n            return { exponent, significand: d / powExponent };\n        }\n    }\n    return { exponent: Number.NaN, significand: Number.NaN };\n}\nfunction positiveNumberToInt64(n) {\n    return [~~(n / 0x100000000), n >>> 0];\n}\nfunction indexInDoubleFromDecomp(exponent, significand) {\n    if (exponent === -1022) {\n        const rescaledSignificand = significand * 2 ** 52;\n        return positiveNumberToInt64(rescaledSignificand);\n    }\n    const rescaledSignificand = (significand - 1) * 2 ** 52;\n    const exponentOnlyHigh = (exponent + 1023) * 2 ** 20;\n    const index = positiveNumberToInt64(rescaledSignificand);\n    index[0] += exponentOnlyHigh;\n    return index;\n}\nexport function doubleToIndex(d) {\n    if (d === Number.POSITIVE_INFINITY) {\n        return clone64(INDEX_POSITIVE_INFINITY);\n    }\n    if (d === Number.NEGATIVE_INFINITY) {\n        return clone64(INDEX_NEGATIVE_INFINITY);\n    }\n    const decomp = decomposeDouble(d);\n    const exponent = decomp.exponent;\n    const significand = decomp.significand;\n    if (d > 0 || (d === 0 && 1 / d === Number.POSITIVE_INFINITY)) {\n        return { sign: 1, data: indexInDoubleFromDecomp(exponent, significand) };\n    }\n    else {\n        const indexOpposite = indexInDoubleFromDecomp(exponent, -significand);\n        if (indexOpposite[1] === 0xffffffff) {\n            indexOpposite[0] += 1;\n            indexOpposite[1] = 0;\n        }\n        else {\n            indexOpposite[1] += 1;\n        }\n        return { sign: -1, data: indexOpposite };\n    }\n}\nexport function indexToDouble(index) {\n    if (index.sign === -1) {\n        const indexOpposite = { sign: 1, data: [index.data[0], index.data[1]] };\n        if (indexOpposite.data[1] === 0) {\n            indexOpposite.data[0] -= 1;\n            indexOpposite.data[1] = 0xffffffff;\n        }\n        else {\n            indexOpposite.data[1] -= 1;\n        }\n        return -indexToDouble(indexOpposite);\n    }\n    if (isEqual64(index, INDEX_POSITIVE_INFINITY)) {\n        return Number.POSITIVE_INFINITY;\n    }\n    if (index.data[0] < 0x200000) {\n        return (index.data[0] * 0x100000000 + index.data[1]) * 2 ** -1074;\n    }\n    const postIndexHigh = index.data[0] - 0x200000;\n    const exponent = -1021 + (postIndexHigh >> 20);\n    const significand = 1 + ((postIndexHigh & 0xfffff) * 2 ** 32 + index.data[1]) * Number.EPSILON;\n    return significand * 2 ** exponent;\n}\nfunction safeDoubleToIndex(d, constraintsLabel) {\n    if (Number.isNaN(d)) {\n        throw new Error('fc.doubleNext constraints.' + constraintsLabel + ' must be a 32-bit float');\n    }\n    return doubleToIndex(d);\n}\nexport function doubleNext(constraints = {}) {\n    const { noDefaultInfinity = false, noNaN = false, min = noDefaultInfinity ? -Number.MAX_VALUE : Number.NEGATIVE_INFINITY, max = noDefaultInfinity ? Number.MAX_VALUE : Number.POSITIVE_INFINITY, } = constraints;\n    const minIndex = safeDoubleToIndex(min, 'min');\n    const maxIndex = safeDoubleToIndex(max, 'max');\n    if (isStrictlySmaller64(maxIndex, minIndex)) {\n        throw new Error('fc.doubleNext constraints.min must be smaller or equal to constraints.max');\n    }\n    if (noNaN) {\n        return arrayInt64(minIndex, maxIndex).map(indexToDouble);\n    }\n    const positiveMaxIdx = isStrictlyPositive64(maxIndex);\n    const minIndexWithNaN = positiveMaxIdx ? minIndex : substract64(minIndex, Unit64);\n    const maxIndexWithNaN = positiveMaxIdx ? add64(maxIndex, Unit64) : maxIndex;\n    return arrayInt64(minIndexWithNaN, maxIndexWithNaN).map((index) => {\n        if (isStrictlySmaller64(maxIndex, index) || isStrictlySmaller64(index, minIndex))\n            return Number.NaN;\n        else\n            return indexToDouble(index);\n    });\n}\n", "import { integer } from '../../arbitrary/integer.js';\nexport const MIN_VALUE_32 = 2 ** -126 * 2 ** -23;\nexport const MAX_VALUE_32 = 2 ** 127 * (1 + (2 ** 23 - 1) / 2 ** 23);\nexport const EPSILON_32 = 2 ** -23;\nconst INDEX_POSITIVE_INFINITY = 2139095040;\nconst INDEX_NEGATIVE_INFINITY = -2139095041;\nexport function decomposeFloat(f) {\n    const maxSignificand = 1 + (2 ** 23 - 1) / 2 ** 23;\n    for (let exponent = -126; exponent !== 128; ++exponent) {\n        const powExponent = 2 ** exponent;\n        const maxForExponent = maxSignificand * powExponent;\n        if (Math.abs(f) <= maxForExponent) {\n            return { exponent, significand: f / powExponent };\n        }\n    }\n    return { exponent: Number.NaN, significand: Number.NaN };\n}\nfunction indexInFloatFromDecomp(exponent, significand) {\n    if (exponent === -126) {\n        return significand * 0x800000;\n    }\n    return (exponent + 127) * 0x800000 + (significand - 1) * 0x800000;\n}\nexport function floatToIndex(f) {\n    if (f === Number.POSITIVE_INFINITY) {\n        return INDEX_POSITIVE_INFINITY;\n    }\n    if (f === Number.NEGATIVE_INFINITY) {\n        return INDEX_NEGATIVE_INFINITY;\n    }\n    const decomp = decomposeFloat(f);\n    const exponent = decomp.exponent;\n    const significand = decomp.significand;\n    if (Number.isNaN(exponent) || Number.isNaN(significand) || !Number.isInteger(significand * 0x800000)) {\n        return Number.NaN;\n    }\n    if (f > 0 || (f === 0 && 1 / f === Number.POSITIVE_INFINITY)) {\n        return indexInFloatFromDecomp(exponent, significand);\n    }\n    else {\n        return -indexInFloatFromDecomp(exponent, -significand) - 1;\n    }\n}\nexport function indexToFloat(index) {\n    if (index < 0) {\n        return -indexToFloat(-index - 1);\n    }\n    if (index === INDEX_POSITIVE_INFINITY) {\n        return Number.POSITIVE_INFINITY;\n    }\n    if (index < 0x1000000) {\n        return index * 2 ** -149;\n    }\n    const postIndex = index - 0x1000000;\n    const exponent = -125 + (postIndex >> 23);\n    const significand = 1 + (postIndex & 0x7fffff) / 0x800000;\n    return significand * 2 ** exponent;\n}\nfunction safeFloatToIndex(f, constraintsLabel) {\n    const conversionTrick = 'you can convert any double to a 32-bit float by using `new Float32Array([myDouble])[0]`';\n    const errorMessage = 'fc.floatNext constraints.' + constraintsLabel + ' must be a 32-bit float - ' + conversionTrick;\n    if (Number.isNaN(f) || (Number.isFinite(f) && (f < -MAX_VALUE_32 || f > MAX_VALUE_32))) {\n        throw new Error(errorMessage);\n    }\n    const index = floatToIndex(f);\n    if (!Number.isInteger(index)) {\n        throw new Error(errorMessage);\n    }\n    return index;\n}\nexport function floatNext(constraints = {}) {\n    const { noDefaultInfinity = false, noNaN = false, min = noDefaultInfinity ? -MAX_VALUE_32 : Number.NEGATIVE_INFINITY, max = noDefaultInfinity ? MAX_VALUE_32 : Number.POSITIVE_INFINITY, } = constraints;\n    const minIndex = safeFloatToIndex(min, 'min');\n    const maxIndex = safeFloatToIndex(max, 'max');\n    if (minIndex > maxIndex) {\n        throw new Error('fc.floatNext constraints.min must be smaller or equal to constraints.max');\n    }\n    if (noNaN) {\n        return integer({ min: minIndex, max: maxIndex }).map(indexToFloat);\n    }\n    const minIndexWithNaN = maxIndex > 0 ? minIndex : minIndex - 1;\n    const maxIndexWithNaN = maxIndex > 0 ? maxIndex + 1 : maxIndex;\n    return integer({ min: minIndexWithNaN, max: maxIndexWithNaN }).map((index) => {\n        if (index > maxIndex || index < minIndex)\n            return Number.NaN;\n        else\n            return indexToFloat(index);\n    });\n}\n", "import { doubleNext } from './DoubleNextArbitrary.js';\nimport { floatNext } from './FloatNextArbitrary.js';\nimport { integer } from '../../arbitrary/integer.js';\nimport { tuple } from '../../arbitrary/tuple.js';\nfunction next(n) {\n    return integer(0, (1 << n) - 1);\n}\nconst floatInternal = () => {\n    return next(24).map((v) => v / (1 << 24));\n};\nfunction float(...args) {\n    if (typeof args[0] === 'object') {\n        if (args[0].next) {\n            return floatNext(args[0]);\n        }\n        const min = args[0].min !== undefined ? args[0].min : 0;\n        const max = args[0].max !== undefined ? args[0].max : 1;\n        return (floatInternal()\n            .map((v) => min + v * (max - min))\n            .filter((g) => g !== max || g === min));\n    }\n    else {\n        const a = args[0];\n        const b = args[1];\n        if (a === undefined)\n            return floatInternal();\n        if (b === undefined)\n            return (floatInternal()\n                .map((v) => v * a)\n                .filter((g) => g !== a || g === 0));\n        return (floatInternal()\n            .map((v) => a + v * (b - a))\n            .filter((g) => g !== b || g === a));\n    }\n}\nconst doubleFactor = Math.pow(2, 27);\nconst doubleDivisor = Math.pow(2, -53);\nconst doubleInternal = () => {\n    return tuple(next(26), next(27)).map((v) => (v[0] * doubleFactor + v[1]) * doubleDivisor);\n};\nfunction double(...args) {\n    if (typeof args[0] === 'object') {\n        if (args[0].next) {\n            return doubleNext(args[0]);\n        }\n        const min = args[0].min !== undefined ? args[0].min : 0;\n        const max = args[0].max !== undefined ? args[0].max : 1;\n        return (doubleInternal()\n            .map((v) => min + v * (max - min))\n            .filter((g) => g !== max || g === min));\n    }\n    else {\n        const a = args[0];\n        const b = args[1];\n        if (a === undefined)\n            return doubleInternal();\n        if (b === undefined)\n            return (doubleInternal()\n                .map((v) => v * a)\n                .filter((g) => g !== a || g === 0));\n        return (doubleInternal()\n            .map((v) => a + v * (b - a))\n            .filter((g) => g !== b || g === a));\n    }\n}\nexport { float, double };\n", "export function escapeForTemplateString(originalText) {\n    return originalText.replace(/([$`\\\\])/g, '\\\\$1').replace(/\\r/g, '\\\\r');\n}\nexport function escapeForMultilineComments(originalText) {\n    return originalText.replace(/\\*\\//g, '*\\\\/');\n}\n", "const crc32Table = [\n    0x00000000, 0x77073096, 0xee0e612c, 0x990951ba, 0x076dc419, 0x706af48f, 0xe963a535, 0x9e6495a3, 0x0edb8832,\n    0x79dcb8a4, 0xe0d5e91e, 0x97d2d988, 0x09b64c2b, 0x7eb17cbd, 0xe7b82d07, 0x90bf1d91, 0x1db71064, 0x6ab020f2,\n    0xf3b97148, 0x84be41de, 0x1adad47d, 0x6ddde4eb, 0xf4d4b551, 0x83d385c7, 0x136c9856, 0x646ba8c0, 0xfd62f97a,\n    0x8a65c9ec, 0x14015c4f, 0x63066cd9, 0xfa0f3d63, 0x8d080df5, 0x3b6e20c8, 0x4c69105e, 0xd56041e4, 0xa2677172,\n    0x3c03e4d1, 0x4b04d447, 0xd20d85fd, 0xa50ab56b, 0x35b5a8fa, 0x42b2986c, 0xdbbbc9d6, 0xacbcf940, 0x32d86ce3,\n    0x45df5c75, 0xdcd60dcf, 0xabd13d59, 0x26d930ac, 0x51de003a, 0xc8d75180, 0xbfd06116, 0x21b4f4b5, 0x56b3c423,\n    0xcfba9599, 0xb8bda50f, 0x2802b89e, 0x5f058808, 0xc60cd9b2, 0xb10be924, 0x2f6f7c87, 0x58684c11, 0xc1611dab,\n    0xb6662d3d, 0x76dc4190, 0x01db7106, 0x98d220bc, 0xefd5102a, 0x71b18589, 0x06b6b51f, 0x9fbfe4a5, 0xe8b8d433,\n    0x7807c9a2, 0x0f00f934, 0x9609a88e, 0xe10e9818, 0x7f6a0dbb, 0x086d3d2d, 0x91646c97, 0xe6635c01, 0x6b6b51f4,\n    0x1c6c6162, 0x856530d8, 0xf262004e, 0x6c0695ed, 0x1b01a57b, 0x8208f4c1, 0xf50fc457, 0x65b0d9c6, 0x12b7e950,\n    0x8bbeb8ea, 0xfcb9887c, 0x62dd1ddf, 0x15da2d49, 0x8cd37cf3, 0xfbd44c65, 0x4db26158, 0x3ab551ce, 0xa3bc0074,\n    0xd4bb30e2, 0x4adfa541, 0x3dd895d7, 0xa4d1c46d, 0xd3d6f4fb, 0x4369e96a, 0x346ed9fc, 0xad678846, 0xda60b8d0,\n    0x44042d73, 0x33031de5, 0xaa0a4c5f, 0xdd0d7cc9, 0x5005713c, 0x270241aa, 0xbe0b1010, 0xc90c2086, 0x5768b525,\n    0x206f85b3, 0xb966d409, 0xce61e49f, 0x5edef90e, 0x29d9c998, 0xb0d09822, 0xc7d7a8b4, 0x59b33d17, 0x2eb40d81,\n    0xb7bd5c3b, 0xc0ba6cad, 0xedb88320, 0x9abfb3b6, 0x03b6e20c, 0x74b1d29a, 0xead54739, 0x9dd277af, 0x04db2615,\n    0x73dc1683, 0xe3630b12, 0x94643b84, 0x0d6d6a3e, 0x7a6a5aa8, 0xe40ecf0b, 0x9309ff9d, 0x0a00ae27, 0x7d079eb1,\n    0xf00f9344, 0x8708a3d2, 0x1e01f268, 0x6906c2fe, 0xf762575d, 0x806567cb, 0x196c3671, 0x6e6b06e7, 0xfed41b76,\n    0x89d32be0, 0x10da7a5a, 0x67dd4acc, 0xf9b9df6f, 0x8ebeeff9, 0x17b7be43, 0x60b08ed5, 0xd6d6a3e8, 0xa1d1937e,\n    0x38d8c2c4, 0x4fdff252, 0xd1bb67f1, 0xa6bc5767, 0x3fb506dd, 0x48b2364b, 0xd80d2bda, 0xaf0a1b4c, 0x36034af6,\n    0x41047a60, 0xdf60efc3, 0xa867df55, 0x316e8eef, 0x4669be79, 0xcb61b38c, 0xbc66831a, 0x256fd2a0, 0x5268e236,\n    0xcc0c7795, 0xbb0b4703, 0x220216b9, 0x5505262f, 0xc5ba3bbe, 0xb2bd0b28, 0x2bb45a92, 0x5cb36a04, 0xc2d7ffa7,\n    0xb5d0cf31, 0x2cd99e8b, 0x5bdeae1d, 0x9b64c2b0, 0xec63f226, 0x756aa39c, 0x026d930a, 0x9c0906a9, 0xeb0e363f,\n    0x72076785, 0x05005713, 0x95bf4a82, 0xe2b87a14, 0x7bb12bae, 0x0cb61b38, 0x92d28e9b, 0xe5d5be0d, 0x7cdcefb7,\n    0x0bdbdf21, 0x86d3d2d4, 0xf1d4e242, 0x68ddb3f8, 0x1fda836e, 0x81be16cd, 0xf6b9265b, 0x6fb077e1, 0x18b74777,\n    0x88085ae6, 0xff0f6a70, 0x66063bca, 0x11010b5c, 0x8f659eff, 0xf862ae69, 0x616bffd3, 0x166ccf45, 0xa00ae278,\n    0xd70dd2ee, 0x4e048354, 0x3903b3c2, 0xa7672661, 0xd06016f7, 0x4969474d, 0x3e6e77db, 0xaed16a4a, 0xd9d65adc,\n    0x40df0b66, 0x37d83bf0, 0xa9bcae53, 0xdebb9ec5, 0x47b2cf7f, 0x30b5ffe9, 0xbdbdf21c, 0xcabac28a, 0x53b39330,\n    0x24b4a3a6, 0xbad03605, 0xcdd70693, 0x54de5729, 0x23d967bf, 0xb3667a2e, 0xc4614ab8, 0x5d681b02, 0x2a6f2b94,\n    0xb40bbe37, 0xc30c8ea1, 0x5a05df1b, 0x2d02ef8d,\n];\nexport function hash(repr) {\n    let crc = 0xffffffff;\n    for (let idx = 0; idx < repr.length; ++idx) {\n        const c = repr.charCodeAt(idx);\n        if (c < 0x80) {\n            crc = crc32Table[(crc & 0xff) ^ c] ^ (crc >> 8);\n        }\n        else if (c < 0x800) {\n            crc = crc32Table[(crc & 0xff) ^ (192 | ((c >> 6) & 31))] ^ (crc >> 8);\n            crc = crc32Table[(crc & 0xff) ^ (128 | (c & 63))] ^ (crc >> 8);\n        }\n        else if (c >= 0xd800 && c < 0xe000) {\n            const cNext = repr.charCodeAt(++idx);\n            if (c >= 0xdc00 || cNext < 0xdc00 || cNext > 0xdfff || Number.isNaN(cNext)) {\n                idx -= 1;\n                crc = crc32Table[(crc & 0xff) ^ 0xef] ^ (crc >> 8);\n                crc = crc32Table[(crc & 0xff) ^ 0xbf] ^ (crc >> 8);\n                crc = crc32Table[(crc & 0xff) ^ 0xbd] ^ (crc >> 8);\n            }\n            else {\n                const c1 = (c & 1023) + 64;\n                const c2 = cNext & 1023;\n                crc = crc32Table[(crc & 0xff) ^ (240 | ((c1 >> 8) & 7))] ^ (crc >> 8);\n                crc = crc32Table[(crc & 0xff) ^ (128 | ((c1 >> 2) & 63))] ^ (crc >> 8);\n                crc = crc32Table[(crc & 0xff) ^ (128 | ((c2 >> 6) & 15) | ((c1 & 3) << 4))] ^ (crc >> 8);\n                crc = crc32Table[(crc & 0xff) ^ (128 | (c2 & 63))] ^ (crc >> 8);\n            }\n        }\n        else {\n            crc = crc32Table[(crc & 0xff) ^ (224 | ((c >> 12) & 15))] ^ (crc >> 8);\n            crc = crc32Table[(crc & 0xff) ^ (128 | ((c >> 6) & 63))] ^ (crc >> 8);\n            crc = crc32Table[(crc & 0xff) ^ (128 | (c & 63))] ^ (crc >> 8);\n        }\n    }\n    return (crc | 0) + 0x80000000;\n}\n", "import { escapeForMultilineComments } from '../../../check/arbitrary/helpers/TextEscaper.js';\nimport { cloneMethod } from '../../../check/symbols.js';\nimport { hash } from '../../../utils/hash.js';\nimport { stringify } from '../../../utils/stringify.js';\nimport { integer } from '../../integer.js';\nimport { tuple } from '../../tuple.js';\nexport function buildCompareFunctionArbitrary(cmp) {\n    return tuple(integer().noShrink(), integer(1, 0xffffffff).noShrink()).map(([seed, hashEnvSize]) => {\n        const producer = () => {\n            const recorded = {};\n            const f = (a, b) => {\n                const reprA = stringify(a);\n                const reprB = stringify(b);\n                const hA = hash(`${seed}${reprA}`) % hashEnvSize;\n                const hB = hash(`${seed}${reprB}`) % hashEnvSize;\n                const val = cmp(hA, hB);\n                recorded[`[${reprA},${reprB}]`] = val;\n                return val;\n            };\n            return Object.assign(f, {\n                toString: () => {\n                    const seenValues = Object.keys(recorded)\n                        .sort()\n                        .map((k) => `${k} => ${stringify(recorded[k])}`)\n                        .map((line) => `/* ${escapeForMultilineComments(line)} */`);\n                    return `function(a, b) {\n  // With hash and stringify coming from fast-check${seenValues.length !== 0 ? `\\n  ${seenValues.join('\\n  ')}` : ''}\n  const cmp = ${cmp};\n  const hA = hash('${seed}' + stringify(a)) % ${hashEnvSize};\n  const hB = hash('${seed}' + stringify(b)) % ${hashEnvSize};\n  return cmp(hA, hB);\n}`;\n                },\n                [cloneMethod]: producer,\n            });\n        };\n        return producer();\n    });\n}\n", "import { buildCompareFunctionArbitrary } from './_internals/builders/CompareFunctionArbitraryBuilder.js';\nexport function compareBooleanFunc() {\n    return buildCompareFunctionArbitrary(Object.assign((hA, hB) => hA < hB, {\n        toString() {\n            return '(hA, hB) => hA < hB';\n        },\n    }));\n}\n", "import { buildCompareFunctionArbitrary } from './_internals/builders/CompareFunctionArbitraryBuilder.js';\nexport function compareFunc() {\n    return buildCompareFunctionArbitrary(Object.assign((hA, hB) => hA - hB, {\n        toString() {\n            return '(hA, hB) => hA - hB';\n        },\n    }));\n}\n", "import { hash } from '../utils/hash.js';\nimport { asyncStringify, asyncToStringMethod, stringify, toStringMethod } from '../utils/stringify.js';\nimport { cloneMethod, hasCloneMethod } from '../check/symbols.js';\nimport { array } from './array.js';\nimport { integer } from './integer.js';\nimport { tuple } from './tuple.js';\nimport { escapeForMultilineComments } from '../check/arbitrary/helpers/TextEscaper.js';\nexport function func(arb) {\n    return tuple(array(arb, { minLength: 1 }), integer().noShrink()).map(([outs, seed]) => {\n        const producer = () => {\n            const recorded = {};\n            const f = (...args) => {\n                const repr = stringify(args);\n                const val = outs[hash(`${seed}${repr}`) % outs.length];\n                recorded[repr] = val;\n                return hasCloneMethod(val) ? val[cloneMethod]() : val;\n            };\n            function prettyPrint(stringifiedOuts) {\n                const seenValues = Object.keys(recorded)\n                    .sort()\n                    .map((k) => `${k} => ${stringify(recorded[k])}`)\n                    .map((line) => `/* ${escapeForMultilineComments(line)} */`);\n                return `function(...args) {\n  // With hash and stringify coming from fast-check${seenValues.length !== 0 ? `\\n  ${seenValues.join('\\n  ')}` : ''}\n  const outs = ${stringifiedOuts};\n  return outs[hash('${seed}' + stringify(args)) % outs.length];\n}`;\n            }\n            return Object.defineProperties(f, {\n                toString: { value: () => prettyPrint(stringify(outs)) },\n                [toStringMethod]: { value: () => prettyPrint(stringify(outs)) },\n                [asyncToStringMethod]: { value: async () => prettyPrint(await asyncStringify(outs)) },\n                [cloneMethod]: { value: producer, configurable: true },\n            });\n        };\n        return producer();\n    });\n}\n", "import { convertFromNextWithShrunkOnce } from '../check/arbitrary/definition/Converters.js';\nimport { IntegerArbitrary } from './_internals/IntegerArbitrary.js';\nexport function maxSafeInteger() {\n    const arb = new IntegerArbitrary(Number.MIN_SAFE_INTEGER, Number.MAX_SAFE_INTEGER);\n    return convertFromNextWithShrunkOnce(arb, arb.defaultTarget());\n}\n", "import { convertFromNextWithShrunkOnce } from '../check/arbitrary/definition/Converters.js';\nimport { IntegerArbitrary } from './_internals/IntegerArbitrary.js';\nexport function maxSafeNat() {\n    const arb = new IntegerArbitrary(0, Number.MAX_SAFE_INTEGER);\n    return convertFromNextWithShrunkOnce(arb, arb.defaultTarget());\n}\n", "export function natToStringifiedNatMapper(options) {\n    const [style, v] = options;\n    switch (style) {\n        case 'oct':\n            return `0${Number(v).toString(8)}`;\n        case 'hex':\n            return `0x${Number(v).toString(16)}`;\n        case 'dec':\n        default:\n            return `${v}`;\n    }\n}\nexport function tryParseStringifiedNat(stringValue, radix) {\n    const parsedNat = Number.parseInt(stringValue, radix);\n    if (parsedNat.toString(radix) !== stringValue) {\n        throw new Error('Invalid value');\n    }\n    return parsedNat;\n}\nexport function natToStringifiedNatUnmapper(value) {\n    if (typeof value !== 'string') {\n        throw new Error('Invalid type');\n    }\n    if (value.length >= 2 && value[0] === '0') {\n        if (value[1] === 'x') {\n            return ['hex', tryParseStringifiedNat(value.substr(2), 16)];\n        }\n        return ['oct', tryParseStringifiedNat(value.substr(1), 8)];\n    }\n    return ['dec', tryParseStringifiedNat(value, 10)];\n}\n", "import { convertFromNext, convertToNext } from '../check/arbitrary/definition/Converters.js';\nimport { nat } from './nat.js';\nimport { tuple } from './tuple.js';\nimport { tryParseStringifiedNat } from './_internals/mappers/NatToStringifiedNat.js';\nfunction dotJoinerMapper(data) {\n    return data.join('.');\n}\nfunction dotJoinerUnmapper(value) {\n    if (typeof value !== 'string') {\n        throw new Error('Invalid type');\n    }\n    return value.split('.').map((v) => tryParseStringifiedNat(v, 10));\n}\nexport function ipV4() {\n    return convertFromNext(convertToNext(tuple(nat(255), nat(255), nat(255), nat(255))).map(dotJoinerMapper, dotJoinerUnmapper));\n}\n", "import { FrequencyArbitrary } from './_internals/FrequencyArbitrary.js';\nfunction isOneOfContraints(param) {\n    return param != null && typeof param === 'object' && !('generate' in param);\n}\nfunction oneof(...args) {\n    const constraints = args[0];\n    if (isOneOfContraints(constraints)) {\n        const weightedArbs = args.slice(1).map((arbitrary) => ({ arbitrary, weight: 1 }));\n        return FrequencyArbitrary.fromOld(weightedArbs, constraints, 'fc.oneof');\n    }\n    const weightedArbs = args.map((arbitrary) => ({ arbitrary, weight: 1 }));\n    return FrequencyArbitrary.fromOld(weightedArbs, {}, 'fc.oneof');\n}\nexport { oneof };\n", "import { convertFromNext, convertToNext } from '../../../check/arbitrary/definition/Converters.js';\nimport { constantFrom } from '../../constantFrom.js';\nimport { nat } from '../../nat.js';\nimport { tuple } from '../../tuple.js';\nimport { natToStringifiedNatMapper, natToStringifiedNatUnmapper } from '../mappers/NatToStringifiedNat.js';\nexport function buildStringifiedNatArbitrary(maxValue) {\n    return convertFromNext(convertToNext(tuple(constantFrom('dec', 'oct', 'hex'), nat(maxValue))).map(natToStringifiedNatMapper, natToStringifiedNatUnmapper));\n}\n", "import { oneof } from './oneof.js';\nimport { tuple } from './tuple.js';\nimport { buildStringifiedNatArbitrary } from './_internals/builders/StringifiedNatArbitraryBuilder.js';\nimport { convertFromNext, convertToNext } from '../check/arbitrary/definition/Converters.js';\nfunction dotJoinerMapper(data) {\n    return data.join('.');\n}\nfunction dotJoinerUnmapper(value) {\n    if (typeof value !== 'string') {\n        throw new Error('Invalid type');\n    }\n    return value.split('.');\n}\nexport function ipV4Extended() {\n    return oneof(convertFromNext(convertToNext(tuple(buildStringifiedNatArbitrary(255), buildStringifiedNatArbitrary(255), buildStringifiedNatArbitrary(255), buildStringifiedNatArbitrary(255))).map(dotJoinerMapper, dotJoinerUnmapper)), convertFromNext(convertToNext(tuple(buildStringifiedNatArbitrary(255), buildStringifiedNatArbitrary(255), buildStringifiedNatArbitrary(65535))).map(dotJoinerMapper, dotJoinerUnmapper)), convertFromNext(convertToNext(tuple(buildStringifiedNatArbitrary(255), buildStringifiedNatArbitrary(16777215))).map(dotJoinerMapper, dotJoinerUnmapper)), buildStringifiedNatArbitrary(4294967295));\n}\n", "export function codePointsToStringMapper(tab) {\n    return tab.join('');\n}\nexport function codePointsToStringUnmapper(value) {\n    if (typeof value !== 'string') {\n        throw new Error('Cannot unmap the passed value');\n    }\n    return [...value];\n}\n", "import { convertFromNext, convertToNext } from '../check/arbitrary/definition/Converters.js';\nimport { array } from './array.js';\nimport { hexa } from './hexa.js';\nimport { extractStringConstraints, } from './_internals/helpers/StringConstraintsExtractor.js';\nimport { codePointsToStringMapper, codePointsToStringUnmapper } from './_internals/mappers/CodePointsToString.js';\nfunction hexaString(...args) {\n    const constraints = extractStringConstraints(args);\n    return convertFromNext(convertToNext(array(hexa(), constraints)).map(codePointsToStringMapper, codePointsToStringUnmapper));\n}\nexport { hexaString };\n", "function readBh(value) {\n    if (value.length === 0)\n        return [];\n    else\n        return value.split(':');\n}\nfunction extractEhAndL(value) {\n    const valueSplits = value.split(':');\n    if (valueSplits.length >= 2 && valueSplits[valueSplits.length - 1].length <= 4) {\n        return [\n            valueSplits.slice(0, valueSplits.length - 2),\n            `${valueSplits[valueSplits.length - 2]}:${valueSplits[valueSplits.length - 1]}`,\n        ];\n    }\n    return [valueSplits.slice(0, valueSplits.length - 1), valueSplits[valueSplits.length - 1]];\n}\nexport function fullySpecifiedMapper(data) {\n    return `${data[0].join(':')}:${data[1]}`;\n}\nexport function fullySpecifiedUnmapper(value) {\n    if (typeof value !== 'string')\n        throw new Error('Invalid type');\n    return extractEhAndL(value);\n}\nexport function onlyTrailingMapper(data) {\n    return `::${data[0].join(':')}:${data[1]}`;\n}\nexport function onlyTrailingUnmapper(value) {\n    if (typeof value !== 'string')\n        throw new Error('Invalid type');\n    if (!value.startsWith('::'))\n        throw new Error('Invalid value');\n    return extractEhAndL(value.substring(2));\n}\nexport function multiTrailingMapper(data) {\n    return `${data[0].join(':')}::${data[1].join(':')}:${data[2]}`;\n}\nexport function multiTrailingUnmapper(value) {\n    if (typeof value !== 'string')\n        throw new Error('Invalid type');\n    const [bhString, trailingString] = value.split('::', 2);\n    const [eh, l] = extractEhAndL(trailingString);\n    return [readBh(bhString), eh, l];\n}\nexport function multiTrailingMapperOne(data) {\n    return multiTrailingMapper([data[0], [data[1]], data[2]]);\n}\nexport function multiTrailingUnmapperOne(value) {\n    const out = multiTrailingUnmapper(value);\n    return [out[0], out[1].join(':'), out[2]];\n}\nexport function singleTrailingMapper(data) {\n    return `${data[0].join(':')}::${data[1]}`;\n}\nexport function singleTrailingUnmapper(value) {\n    if (typeof value !== 'string')\n        throw new Error('Invalid type');\n    const [bhString, trailing] = value.split('::', 2);\n    return [readBh(bhString), trailing];\n}\nexport function noTrailingMapper(data) {\n    return `${data[0].join(':')}::`;\n}\nexport function noTrailingUnmapper(value) {\n    if (typeof value !== 'string')\n        throw new Error('Invalid type');\n    if (!value.endsWith('::'))\n        throw new Error('Invalid value');\n    return [readBh(value.substring(0, value.length - 2))];\n}\n", "import { array } from './array.js';\nimport { convertFromNext, convertToNext } from '../check/arbitrary/definition/Converters.js';\nimport { oneof } from './oneof.js';\nimport { hexaString } from './hexaString.js';\nimport { tuple } from './tuple.js';\nimport { ipV4 } from './ipV4.js';\nimport { fullySpecifiedMapper, fullySpecifiedUnmapper, onlyTrailingMapper, onlyTrailingUnmapper, multiTrailingMapper, multiTrailingUnmapper, multiTrailingMapperOne, multiTrailingUnmapperOne, singleTrailingMapper, singleTrailingUnmapper, noTrailingMapper, noTrailingUnmapper, } from './_internals/mappers/EntitiesToIPv6.js';\nfunction h16sTol32Mapper([a, b]) {\n    return `${a}:${b}`;\n}\nfunction h16sTol32Unmapper(value) {\n    if (typeof value !== 'string')\n        throw new Error('Invalid type');\n    if (!value.includes(':'))\n        throw new Error('Invalid value');\n    return value.split(':', 2);\n}\nexport function ipV6() {\n    const h16Arb = hexaString({ minLength: 1, maxLength: 4 });\n    const ls32Arb = oneof(convertFromNext(convertToNext(tuple(h16Arb, h16Arb)).map(h16sTol32Mapper, h16sTol32Unmapper)), ipV4());\n    return oneof(convertFromNext(convertToNext(tuple(array(h16Arb, { minLength: 6, maxLength: 6 }), ls32Arb)).map(fullySpecifiedMapper, fullySpecifiedUnmapper)), convertFromNext(convertToNext(tuple(array(h16Arb, { minLength: 5, maxLength: 5 }), ls32Arb)).map(onlyTrailingMapper, onlyTrailingUnmapper)), convertFromNext(convertToNext(tuple(array(h16Arb, { minLength: 0, maxLength: 1 }), array(h16Arb, { minLength: 4, maxLength: 4 }), ls32Arb)).map(multiTrailingMapper, multiTrailingUnmapper)), convertFromNext(convertToNext(tuple(array(h16Arb, { minLength: 0, maxLength: 2 }), array(h16Arb, { minLength: 3, maxLength: 3 }), ls32Arb)).map(multiTrailingMapper, multiTrailingUnmapper)), convertFromNext(convertToNext(tuple(array(h16Arb, { minLength: 0, maxLength: 3 }), array(h16Arb, { minLength: 2, maxLength: 2 }), ls32Arb)).map(multiTrailingMapper, multiTrailingUnmapper)), convertFromNext(convertToNext(tuple(array(h16Arb, { minLength: 0, maxLength: 4 }), h16Arb, ls32Arb)).map(multiTrailingMapperOne, multiTrailingUnmapperOne)), convertFromNext(convertToNext(tuple(array(h16Arb, { minLength: 0, maxLength: 5 }), ls32Arb)).map(singleTrailingMapper, singleTrailingUnmapper)), convertFromNext(convertToNext(tuple(array(h16Arb, { minLength: 0, maxLength: 6 }), h16Arb)).map(singleTrailingMapper, singleTrailingUnmapper)), convertFromNext(convertToNext(tuple(array(h16Arb, { minLength: 0, maxLength: 7 }))).map(noTrailingMapper, noTrailingUnmapper)));\n}\n", "import { NextArbitrary } from '../../check/arbitrary/definition/NextArbitrary.js';\nexport class LazyArbitrary extends NextArbitrary {\n    constructor(name) {\n        super();\n        this.name = name;\n        this.underlying = null;\n    }\n    generate(mrng, biasFactor) {\n        if (!this.underlying) {\n            throw new Error(`Lazy arbitrary ${JSON.stringify(this.name)} not correctly initialized`);\n        }\n        return this.underlying.generate(mrng, biasFactor);\n    }\n    canShrinkWithoutContext(value) {\n        if (!this.underlying) {\n            throw new Error(`Lazy arbitrary ${JSON.stringify(this.name)} not correctly initialized`);\n        }\n        return this.underlying.canShrinkWithoutContext(value);\n    }\n    shrink(value, context) {\n        if (!this.underlying) {\n            throw new Error(`Lazy arbitrary ${JSON.stringify(this.name)} not correctly initialized`);\n        }\n        return this.underlying.shrink(value, context);\n    }\n}\n", "import { LazyArbitrary } from './_internals/LazyArbitrary.js';\nimport { convertFromNext, convertToNext } from '../check/arbitrary/definition/Converters.js';\nexport function letrec(builder) {\n    const lazyArbs = Object.create(null);\n    const tie = (key) => {\n        if (!Object.prototype.hasOwnProperty.call(lazyArbs, key)) {\n            lazyArbs[key] = new LazyArbitrary(String(key));\n        }\n        return convertFromNext(lazyArbs[key]);\n    };\n    const strictArbs = builder(tie);\n    for (const key in strictArbs) {\n        if (!Object.prototype.hasOwnProperty.call(strictArbs, key)) {\n            continue;\n        }\n        const lazyAtKey = lazyArbs[key];\n        const lazyArb = lazyAtKey !== undefined ? lazyAtKey : new LazyArbitrary(key);\n        lazyArb.underlying = convertToNext(strictArbs[key]);\n        lazyArbs[key] = lazyArb;\n    }\n    return strictArbs;\n}\n", "export function wordsToJoinedStringMapper(words) {\n    return words.map((w) => (w[w.length - 1] === ',' ? w.substr(0, w.length - 1) : w)).join(' ');\n}\nexport function wordsToJoinedStringUnmapperFor(wordsArbitrary) {\n    return function wordsToJoinedStringUnmapper(value) {\n        if (typeof value !== 'string') {\n            throw new Error('Unsupported type');\n        }\n        const words = [];\n        for (const candidate of value.split(' ')) {\n            if (wordsArbitrary.canShrinkWithoutContext(candidate))\n                words.push(candidate);\n            else if (wordsArbitrary.canShrinkWithoutContext(candidate + ','))\n                words.push(candidate + ',');\n            else\n                throw new Error('Unsupported word');\n        }\n        return words;\n    };\n}\nexport function wordsToSentenceMapper(words) {\n    let sentence = words.join(' ');\n    if (sentence[sentence.length - 1] === ',') {\n        sentence = sentence.substr(0, sentence.length - 1);\n    }\n    return sentence[0].toUpperCase() + sentence.substring(1) + '.';\n}\nexport function wordsToSentenceUnmapperFor(wordsArbitrary) {\n    return function wordsToSentenceUnmapper(value) {\n        if (typeof value !== 'string') {\n            throw new Error('Unsupported type');\n        }\n        if (value.length < 2 ||\n            value[value.length - 1] !== '.' ||\n            value[value.length - 2] === ',' ||\n            value[0].toLowerCase().toUpperCase() !== value[0]) {\n            throw new Error('Unsupported value');\n        }\n        const adaptedValue = value[0].toLowerCase() + value.substring(1, value.length - 1);\n        const words = [];\n        const candidates = adaptedValue.split(' ');\n        for (let idx = 0; idx !== candidates.length; ++idx) {\n            const candidate = candidates[idx];\n            if (wordsArbitrary.canShrinkWithoutContext(candidate))\n                words.push(candidate);\n            else if (idx === candidates.length - 1 && wordsArbitrary.canShrinkWithoutContext(candidate + ','))\n                words.push(candidate + ',');\n            else\n                throw new Error('Unsupported word');\n        }\n        return words;\n    };\n}\nexport function sentencesToParagraphMapper(sentences) {\n    return sentences.join(' ');\n}\nexport function sentencesToParagraphUnmapper(value) {\n    if (typeof value !== 'string') {\n        throw new Error('Unsupported type');\n    }\n    const sentences = value.split('. ');\n    for (let idx = 0; idx < sentences.length - 1; ++idx) {\n        sentences[idx] += '.';\n    }\n    return sentences;\n}\n", "import { array } from './array.js';\nimport { constant } from './constant.js';\nimport { frequency } from './frequency.js';\nimport { sentencesToParagraphMapper, sentencesToParagraphUnmapper, wordsToJoinedStringMapper, wordsToJoinedStringUnmapperFor, wordsToSentenceMapper, wordsToSentenceUnmapperFor, } from './_internals/mappers/WordsToLorem.js';\nimport { convertFromNext, convertToNext } from '../check/arbitrary/definition/Converters.js';\nconst h = (v, w) => {\n    return { arbitrary: constant(v), weight: w };\n};\nfunction loremWord() {\n    return frequency(h('non', 6), h('adipiscing', 5), h('ligula', 5), h('enim', 5), h('pellentesque', 5), h('in', 5), h('augue', 5), h('et', 5), h('nulla', 5), h('lorem', 4), h('sit', 4), h('sed', 4), h('diam', 4), h('fermentum', 4), h('ut', 4), h('eu', 4), h('aliquam', 4), h('mauris', 4), h('vitae', 4), h('felis', 4), h('ipsum', 3), h('dolor', 3), h('amet,', 3), h('elit', 3), h('euismod', 3), h('mi', 3), h('orci', 3), h('erat', 3), h('praesent', 3), h('egestas', 3), h('leo', 3), h('vel', 3), h('sapien', 3), h('integer', 3), h('curabitur', 3), h('convallis', 3), h('purus', 3), h('risus', 2), h('suspendisse', 2), h('lectus', 2), h('nec,', 2), h('ultricies', 2), h('sed,', 2), h('cras', 2), h('elementum', 2), h('ultrices', 2), h('maecenas', 2), h('massa,', 2), h('varius', 2), h('a,', 2), h('semper', 2), h('proin', 2), h('nec', 2), h('nisl', 2), h('amet', 2), h('duis', 2), h('congue', 2), h('libero', 2), h('vestibulum', 2), h('pede', 2), h('blandit', 2), h('sodales', 2), h('ante', 2), h('nibh', 2), h('ac', 2), h('aenean', 2), h('massa', 2), h('suscipit', 2), h('sollicitudin', 2), h('fusce', 2), h('tempus', 2), h('aliquam,', 2), h('nunc', 2), h('ullamcorper', 2), h('rhoncus', 2), h('metus', 2), h('faucibus,', 2), h('justo', 2), h('magna', 2), h('at', 2), h('tincidunt', 2), h('consectetur', 1), h('tortor,', 1), h('dignissim', 1), h('congue,', 1), h('non,', 1), h('porttitor,', 1), h('nonummy', 1), h('molestie,', 1), h('est', 1), h('eleifend', 1), h('mi,', 1), h('arcu', 1), h('scelerisque', 1), h('vitae,', 1), h('consequat', 1), h('in,', 1), h('pretium', 1), h('volutpat', 1), h('pharetra', 1), h('tempor', 1), h('bibendum', 1), h('odio', 1), h('dui', 1), h('primis', 1), h('faucibus', 1), h('luctus', 1), h('posuere', 1), h('cubilia', 1), h('curae,', 1), h('hendrerit', 1), h('velit', 1), h('mauris,', 1), h('gravida', 1), h('ornare', 1), h('ut,', 1), h('pulvinar', 1), h('varius,', 1), h('turpis', 1), h('nibh,', 1), h('eros', 1), h('id', 1), h('aliquet', 1), h('quis', 1), h('lobortis', 1), h('consectetuer', 1), h('morbi', 1), h('vehicula', 1), h('tortor', 1), h('tellus,', 1), h('id,', 1), h('eu,', 1), h('quam', 1), h('feugiat,', 1), h('posuere,', 1), h('iaculis', 1), h('lectus,', 1), h('tristique', 1), h('mollis,', 1), h('nisl,', 1), h('vulputate', 1), h('sem', 1), h('vivamus', 1), h('placerat', 1), h('imperdiet', 1), h('cursus', 1), h('rutrum', 1), h('iaculis,', 1), h('augue,', 1), h('lacus', 1));\n}\nfunction lorem(...args) {\n    const maxWordsCount = typeof args[0] === 'object' ? args[0].maxCount : args[0];\n    const sentencesMode = typeof args[0] === 'object' ? args[0].mode === 'sentences' : args[1];\n    const maxCount = maxWordsCount !== undefined ? maxWordsCount : 5;\n    if (maxCount < 1) {\n        throw new Error(`lorem has to produce at least one word/sentence`);\n    }\n    const wordArbitrary = loremWord();\n    const wordArbitraryNext = convertToNext(wordArbitrary);\n    if (sentencesMode) {\n        const sentence = convertToNext(array(wordArbitrary, { minLength: 1 })).map(wordsToSentenceMapper, wordsToSentenceUnmapperFor(wordArbitraryNext));\n        return convertFromNext(convertToNext(array(convertFromNext(sentence), { minLength: 1, maxLength: maxCount })).map(sentencesToParagraphMapper, sentencesToParagraphUnmapper));\n    }\n    else {\n        return convertFromNext(convertToNext(array(wordArbitrary, { minLength: 1, maxLength: maxCount })).map(wordsToJoinedStringMapper, wordsToJoinedStringUnmapperFor(wordArbitraryNext)));\n    }\n}\nexport { lorem };\n", "let contextRemainingDepth = 10;\nexport function memo(builder) {\n    const previous = {};\n    return ((maxDepth) => {\n        const n = maxDepth !== undefined ? maxDepth : contextRemainingDepth;\n        if (!Object.prototype.hasOwnProperty.call(previous, n)) {\n            const prev = contextRemainingDepth;\n            contextRemainingDepth = n - 1;\n            previous[n] = builder(n);\n            contextRemainingDepth = prev;\n        }\n        return previous[n];\n    });\n}\n", "import { Stream } from '../../stream/Stream.js';\nimport { bigUintN } from '../bigUintN.js';\nimport { NextArbitrary } from '../../check/arbitrary/definition/NextArbitrary.js';\nimport { convertToNext } from '../../check/arbitrary/definition/Converters.js';\nimport { NextValue } from '../../check/arbitrary/definition/NextValue.js';\nimport { makeLazy } from '../../stream/LazyIterableIterator.js';\nexport function countToggledBits(n) {\n    let count = 0;\n    while (n > BigInt(0)) {\n        if (n & BigInt(1))\n            ++count;\n        n >>= BigInt(1);\n    }\n    return count;\n}\nexport function computeNextFlags(flags, nextSize) {\n    const allowedMask = (BigInt(1) << BigInt(nextSize)) - BigInt(1);\n    const preservedFlags = flags & allowedMask;\n    let numMissingFlags = countToggledBits(flags - preservedFlags);\n    let nFlags = preservedFlags;\n    for (let mask = BigInt(1); mask <= allowedMask && numMissingFlags !== 0; mask <<= BigInt(1)) {\n        if (!(nFlags & mask)) {\n            nFlags |= mask;\n            --numMissingFlags;\n        }\n    }\n    return nFlags;\n}\nexport class MixedCaseArbitrary extends NextArbitrary {\n    constructor(stringArb, toggleCase) {\n        super();\n        this.stringArb = stringArb;\n        this.toggleCase = toggleCase;\n    }\n    computeTogglePositions(chars) {\n        const positions = [];\n        for (let idx = 0; idx !== chars.length; ++idx) {\n            if (this.toggleCase(chars[idx]) !== chars[idx])\n                positions.push(idx);\n        }\n        return positions;\n    }\n    applyFlagsOnChars(chars, flags, togglePositions) {\n        for (let idx = 0, mask = BigInt(1); idx !== togglePositions.length; ++idx, mask <<= BigInt(1)) {\n            if (flags & mask)\n                chars[togglePositions[idx]] = this.toggleCase(chars[togglePositions[idx]]);\n        }\n        return chars;\n    }\n    buildContextFor(rawStringNextValue, flagsNextValue) {\n        return {\n            rawString: rawStringNextValue.value,\n            rawStringContext: rawStringNextValue.context,\n            flags: flagsNextValue.value,\n            flagsContext: flagsNextValue.context,\n        };\n    }\n    generate(mrng, biasFactor) {\n        const rawStringNextValue = this.stringArb.generate(mrng, biasFactor);\n        const chars = [...rawStringNextValue.value];\n        const togglePositions = this.computeTogglePositions(chars);\n        const flagsArb = convertToNext(bigUintN(togglePositions.length));\n        const flagsNextValue = flagsArb.generate(mrng, undefined);\n        this.applyFlagsOnChars(chars, flagsNextValue.value, togglePositions);\n        return new NextValue(chars.join(''), this.buildContextFor(rawStringNextValue, flagsNextValue));\n    }\n    canShrinkWithoutContext(value) {\n        return false;\n    }\n    shrink(_value, context) {\n        if (context === undefined) {\n            return Stream.nil();\n        }\n        const contextSafe = context;\n        const rawString = contextSafe.rawString;\n        const flags = contextSafe.flags;\n        return this.stringArb\n            .shrink(rawString, contextSafe.rawStringContext)\n            .map((nRawStringNextValue) => {\n            const nChars = [...nRawStringNextValue.value];\n            const nTogglePositions = this.computeTogglePositions(nChars);\n            const nFlags = computeNextFlags(flags, nTogglePositions.length);\n            this.applyFlagsOnChars(nChars, nFlags, nTogglePositions);\n            return new NextValue(nChars.join(''), this.buildContextFor(nRawStringNextValue, new NextValue(nFlags, undefined)));\n        })\n            .join(makeLazy(() => {\n            const chars = [...rawString];\n            const togglePositions = this.computeTogglePositions(chars);\n            return convertToNext(bigUintN(togglePositions.length))\n                .shrink(flags, contextSafe.flagsContext)\n                .map((nFlagsNextValue) => {\n                const nChars = chars.slice();\n                this.applyFlagsOnChars(nChars, nFlagsNextValue.value, togglePositions);\n                return new NextValue(nChars.join(''), this.buildContextFor(new NextValue(rawString, contextSafe.rawStringContext), nFlagsNextValue));\n            });\n        }));\n    }\n}\n", "import { convertFromNext, convertToNext } from '../check/arbitrary/definition/Converters.js';\nimport { MixedCaseArbitrary } from './_internals/MixedCaseArbitrary.js';\nfunction defaultToggleCase(rawChar) {\n    const upper = rawChar.toUpperCase();\n    if (upper !== rawChar)\n        return upper;\n    return rawChar.toLowerCase();\n}\nexport function mixedCase(stringArb, constraints) {\n    if (typeof BigInt === 'undefined') {\n        throw new Error(`mixedCase requires BigInt support`);\n    }\n    const toggleCase = (constraints && constraints.toggleCase) || defaultToggleCase;\n    return convertFromNext(new MixedCaseArbitrary(convertToNext(stringArb), toggleCase));\n}\n", "import { convertFromNext, convertToNext } from '../check/arbitrary/definition/Converters.js';\nimport { array } from './array.js';\nimport { char } from './char.js';\nimport { extractStringConstraints, } from './_internals/helpers/StringConstraintsExtractor.js';\nimport { codePointsToStringMapper, codePointsToStringUnmapper } from './_internals/mappers/CodePointsToString.js';\nfunction string(...args) {\n    const constraints = extractStringConstraints(args);\n    return convertFromNext(convertToNext(array(char(), constraints)).map(codePointsToStringMapper, codePointsToStringUnmapper));\n}\nexport { string };\n", "import { convertFromNext, convertToNext } from '../check/arbitrary/definition/Converters.js';\nimport { array } from './array.js';\nimport { unicode } from './unicode.js';\nimport { extractStringConstraints, } from './_internals/helpers/StringConstraintsExtractor.js';\nimport { codePointsToStringMapper, codePointsToStringUnmapper } from './_internals/mappers/CodePointsToString.js';\nfunction unicodeString(...args) {\n    const constraints = extractStringConstraints(args);\n    return convertFromNext(convertToNext(array(unicode(), constraints)).map(codePointsToStringMapper, codePointsToStringUnmapper));\n}\nexport { unicodeString };\n", "import { float } from '../check/arbitrary/FloatingPointArbitrary.js';\nimport { array } from './array.js';\nexport function float32Array(constraints = {}) {\n    return array(float(Object.assign(Object.assign({}, constraints), { next: true })), constraints).map((data) => Float32Array.from(data));\n}\n", "import { double } from '../check/arbitrary/FloatingPointArbitrary.js';\nimport { array } from './array.js';\nexport function float64Array(constraints = {}) {\n    return array(double(Object.assign(Object.assign({}, constraints), { next: true })), constraints).map((data) => Float64Array.from(data));\n}\n", "var __rest = (this && this.__rest) || function (s, e) {\n    var t = {};\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\n        t[p] = s[p];\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\n                t[p[i]] = s[p[i]];\n        }\n    return t;\n};\nimport { array } from '../../array.js';\nexport function typedIntArrayArbitraryArbitraryBuilder(constraints, defaultMin, defaultMax, TypedArrayClass, arbitraryBuilder) {\n    const generatorName = TypedArrayClass.name;\n    const { min = defaultMin, max = defaultMax } = constraints, arrayConstraints = __rest(constraints, [\"min\", \"max\"]);\n    if (min > max) {\n        throw new Error(`Invalid range passed to ${generatorName}: min must be lower than or equal to max`);\n    }\n    if (min < defaultMin) {\n        throw new Error(`Invalid min value passed to ${generatorName}: min must be greater than or equal to ${defaultMin}`);\n    }\n    if (max > defaultMax) {\n        throw new Error(`Invalid max value passed to ${generatorName}: max must be lower than or equal to ${defaultMax}`);\n    }\n    return array(arbitraryBuilder({ min, max }), arrayConstraints).map((data) => TypedArrayClass.from(data));\n}\n", "import { integer } from './integer.js';\nimport { typedIntArrayArbitraryArbitraryBuilder, } from './_internals/builders/TypedIntArrayArbitraryBuilder.js';\nexport function int16Array(constraints = {}) {\n    return typedIntArrayArbitraryArbitraryBuilder(constraints, -32768, 32767, Int16Array, integer);\n}\n", "import { integer } from './integer.js';\nimport { typedIntArrayArbitraryArbitraryBuilder, } from './_internals/builders/TypedIntArrayArbitraryBuilder.js';\nexport function int32Array(constraints = {}) {\n    return typedIntArrayArbitraryArbitraryBuilder(constraints, -0x80000000, 0x7fffffff, Int32Array, integer);\n}\n", "import { integer } from './integer.js';\nimport { typedIntArrayArbitraryArbitraryBuilder, } from './_internals/builders/TypedIntArrayArbitraryBuilder.js';\nexport function int8Array(constraints = {}) {\n    return typedIntArrayArbitraryArbitraryBuilder(constraints, -128, 127, Int8Array, integer);\n}\n", "import { integer } from './integer.js';\nimport { typedIntArrayArbitraryArbitraryBuilder, } from './_internals/builders/TypedIntArrayArbitraryBuilder.js';\nexport function uint16Array(constraints = {}) {\n    return typedIntArrayArbitraryArbitraryBuilder(constraints, 0, 65535, Uint16Array, integer);\n}\n", "import { integer } from './integer.js';\nimport { typedIntArrayArbitraryArbitraryBuilder, } from './_internals/builders/TypedIntArrayArbitraryBuilder.js';\nexport function uint32Array(constraints = {}) {\n    return typedIntArrayArbitraryArbitraryBuilder(constraints, 0, 0xffffffff, Uint32Array, integer);\n}\n", "import { integer } from './integer.js';\nimport { typedIntArrayArbitraryArbitraryBuilder, } from './_internals/builders/TypedIntArrayArbitraryBuilder.js';\nexport function uint8Array(constraints = {}) {\n    return typedIntArrayArbitraryArbitraryBuilder(constraints, 0, 255, Uint8Array, integer);\n}\n", "import { integer } from './integer.js';\nimport { typedIntArrayArbitraryArbitraryBuilder, } from './_internals/builders/TypedIntArrayArbitraryBuilder.js';\nexport function uint8ClampedArray(constraints = {}) {\n    return typedIntArrayArbitraryArbitraryBuilder(constraints, 0, 255, Uint8ClampedArray, integer);\n}\n", "import { nat } from '../../arbitrary/nat.js';\nimport { set } from '../../arbitrary/set.js';\nimport { tuple } from '../../arbitrary/tuple.js';\nimport { maxLengthFromMinLength } from '../../arbitrary/_internals/helpers/MaxLengthFromMinLength.js';\nfunction extractMaxIndex(indexesAndValues) {\n    let maxIndex = -1;\n    for (let index = 0; index !== indexesAndValues.length; ++index) {\n        maxIndex = Math.max(maxIndex, indexesAndValues[index][0]);\n    }\n    return maxIndex;\n}\nfunction arrayFromItems(length, indexesAndValues) {\n    const array = Array(length);\n    for (let index = 0; index !== indexesAndValues.length; ++index) {\n        const it = indexesAndValues[index];\n        if (it[0] < length)\n            array[it[0]] = it[1];\n    }\n    return array;\n}\nexport function sparseArray(arb, constraints = {}) {\n    const { minNumElements = 0, maxNumElements = maxLengthFromMinLength(minNumElements), maxLength = Math.min(maxLengthFromMinLength(maxNumElements), 4294967295), noTrailingHole, } = constraints;\n    if (minNumElements > maxLength) {\n        throw new Error(`The minimal number of non-hole elements cannot be higher than the maximal length of the array`);\n    }\n    if (minNumElements > maxNumElements) {\n        throw new Error(`The minimal number of non-hole elements cannot be higher than the maximal number of non-holes`);\n    }\n    const resultedMaxNumElements = Math.min(maxNumElements, maxLength);\n    if (noTrailingHole) {\n        const maxIndexAuthorized = Math.max(maxLength - 1, 0);\n        return set(tuple(nat(maxIndexAuthorized), arb), {\n            minLength: minNumElements,\n            maxLength: resultedMaxNumElements,\n            compare: (itemA, itemB) => itemA[0] === itemB[0],\n        }).map((items) => {\n            const lastIndex = extractMaxIndex(items);\n            return arrayFromItems(lastIndex + 1, items);\n        });\n    }\n    return set(tuple(nat(maxLength), arb), {\n        minLength: minNumElements + 1,\n        maxLength: resultedMaxNumElements + 1,\n        compare: (itemA, itemB) => itemA[0] === itemB[0],\n    }).map((items) => {\n        const length = extractMaxIndex(items);\n        return arrayFromItems(length, items);\n    });\n}\n", "import { stringify } from '../../utils/stringify.js';\nimport { array } from '../../arbitrary/array.js';\nimport { boolean } from '../../arbitrary/boolean.js';\nimport { constant } from '../../arbitrary/constant.js';\nimport { dictionary } from '../../arbitrary/dictionary.js';\nimport { double } from './FloatingPointArbitrary.js';\nimport { frequency } from '../../arbitrary/frequency.js';\nimport { maxSafeInteger } from '../../arbitrary/maxSafeInteger.js';\nimport { memo } from '../../arbitrary/memo.js';\nimport { oneof } from '../../arbitrary/oneof.js';\nimport { set } from '../../arbitrary/set.js';\nimport { string } from '../../arbitrary/string.js';\nimport { unicodeString } from '../../arbitrary/unicodeString.js';\nimport { tuple } from '../../arbitrary/tuple.js';\nimport { bigInt } from '../../arbitrary/bigInt.js';\nimport { date } from '../../arbitrary/date.js';\nimport { float32Array } from '../../arbitrary/float32Array.js';\nimport { float64Array } from '../../arbitrary/float64Array.js';\nimport { int16Array } from '../../arbitrary/int16Array.js';\nimport { int32Array } from '../../arbitrary/int32Array.js';\nimport { int8Array } from '../../arbitrary/int8Array.js';\nimport { uint16Array } from '../../arbitrary/uint16Array.js';\nimport { uint32Array } from '../../arbitrary/uint32Array.js';\nimport { uint8Array } from '../../arbitrary/uint8Array.js';\nimport { uint8ClampedArray } from '../../arbitrary/uint8ClampedArray.js';\nimport { sparseArray } from './SparseArrayArbitrary.js';\nimport { keyValuePairsToObjectMapper } from '../../arbitrary/_internals/mappers/KeyValuePairsToObject.js';\nexport function boxArbitrary(arb) {\n    return arb.map((v) => {\n        switch (typeof v) {\n            case 'boolean':\n                return new Boolean(v);\n            case 'number':\n                return new Number(v);\n            case 'string':\n                return new String(v);\n            default:\n                return v;\n        }\n    });\n}\nclass QualifiedObjectConstraints {\n    constructor(key, values, maxDepth, maxKeys, withSet, withMap, withObjectString, withNullPrototype, withBigInt, withDate, withTypedArray, withSparseArray) {\n        this.key = key;\n        this.values = values;\n        this.maxDepth = maxDepth;\n        this.maxKeys = maxKeys;\n        this.withSet = withSet;\n        this.withMap = withMap;\n        this.withObjectString = withObjectString;\n        this.withNullPrototype = withNullPrototype;\n        this.withBigInt = withBigInt;\n        this.withDate = withDate;\n        this.withTypedArray = withTypedArray;\n        this.withSparseArray = withSparseArray;\n    }\n    static defaultValues() {\n        return [\n            boolean(),\n            maxSafeInteger(),\n            double({ next: true }),\n            string(),\n            oneof(string(), constant(null), constant(undefined)),\n        ];\n    }\n    static boxArbitraries(arbs) {\n        return arbs.map((arb) => boxArbitrary(arb));\n    }\n    static boxArbitrariesIfNeeded(arbs, boxEnabled) {\n        return boxEnabled ? QualifiedObjectConstraints.boxArbitraries(arbs).concat(arbs) : arbs;\n    }\n    static from(settings = {}) {\n        function orDefault(optionalValue, defaultValue) {\n            return optionalValue !== undefined ? optionalValue : defaultValue;\n        }\n        return new QualifiedObjectConstraints(orDefault(settings.key, string()), QualifiedObjectConstraints.boxArbitrariesIfNeeded(orDefault(settings.values, QualifiedObjectConstraints.defaultValues()), orDefault(settings.withBoxedValues, false)), orDefault(settings.maxDepth, 2), orDefault(settings.maxKeys, 5), orDefault(settings.withSet, false), orDefault(settings.withMap, false), orDefault(settings.withObjectString, false), orDefault(settings.withNullPrototype, false), orDefault(settings.withBigInt, false), orDefault(settings.withDate, false), orDefault(settings.withTypedArray, false), orDefault(settings.withSparseArray, false));\n    }\n}\nconst anythingInternal = (constraints) => {\n    const arbKeys = constraints.withObjectString\n        ? memo((n) => frequency({ arbitrary: constraints.key, weight: 10 }, { arbitrary: anythingArb(n).map((o) => stringify(o)), weight: 1 }))\n        : memo(() => constraints.key);\n    const arbitrariesForBase = constraints.values;\n    const maxDepth = constraints.maxDepth;\n    const maxKeys = constraints.maxKeys;\n    const entriesOf = (keyArb, valueArb) => set(tuple(keyArb, valueArb), { maxLength: maxKeys, compare: (t1, t2) => t1[0] === t2[0] });\n    const mapOf = (ka, va) => entriesOf(ka, va).map((v) => new Map(v));\n    const dictOf = (ka, va) => entriesOf(ka, va).map((v) => keyValuePairsToObjectMapper(v));\n    const baseArb = oneof(...arbitrariesForBase);\n    const arrayBaseArb = oneof(...arbitrariesForBase.map((arb) => array(arb, { maxLength: maxKeys })));\n    const objectBaseArb = (n) => oneof(...arbitrariesForBase.map((arb) => dictOf(arbKeys(n), arb)));\n    const setBaseArb = () => oneof(...arbitrariesForBase.map((arb) => set(arb, { maxLength: maxKeys }).map((v) => new Set(v))));\n    const mapBaseArb = (n) => oneof(...arbitrariesForBase.map((arb) => mapOf(arbKeys(n), arb)));\n    const arrayArb = memo((n) => oneof(arrayBaseArb, array(anythingArb(n), { maxLength: maxKeys })));\n    const setArb = memo((n) => oneof(setBaseArb(), set(anythingArb(n), { maxLength: maxKeys }).map((v) => new Set(v))));\n    const mapArb = memo((n) => oneof(mapBaseArb(n), oneof(mapOf(arbKeys(n), anythingArb(n)), mapOf(anythingArb(n), anythingArb(n)))));\n    const objectArb = memo((n) => oneof(objectBaseArb(n), dictOf(arbKeys(n), anythingArb(n))));\n    const anythingArb = memo((n) => {\n        if (n <= 0)\n            return oneof(baseArb);\n        return oneof(baseArb, arrayArb(), objectArb(), ...(constraints.withMap ? [mapArb()] : []), ...(constraints.withSet ? [setArb()] : []), ...(constraints.withObjectString ? [anythingArb().map((o) => stringify(o))] : []), ...(constraints.withNullPrototype ? [objectArb().map((o) => Object.assign(Object.create(null), o))] : []), ...(constraints.withBigInt ? [bigInt()] : []), ...(constraints.withDate ? [date()] : []), ...(constraints.withTypedArray\n            ? [\n                oneof(int8Array(), uint8Array(), uint8ClampedArray(), int16Array(), uint16Array(), int32Array(), uint32Array(), float32Array(), float64Array()),\n            ]\n            : []), ...(constraints.withSparseArray ? [sparseArray(anythingArb())] : []));\n    });\n    return anythingArb(maxDepth);\n};\nconst objectInternal = (constraints) => {\n    return dictionary(constraints.key, anythingInternal(constraints));\n};\nfunction anything(constraints) {\n    return anythingInternal(QualifiedObjectConstraints.from(constraints));\n}\nfunction object(constraints) {\n    return objectInternal(QualifiedObjectConstraints.from(constraints));\n}\nfunction jsonSettings(stringArbitrary, constraints) {\n    const key = stringArbitrary;\n    const values = [\n        boolean(),\n        maxSafeInteger(),\n        double({ next: true, noDefaultInfinity: true, noNaN: true }),\n        stringArbitrary,\n        constant(null),\n    ];\n    return constraints != null\n        ? typeof constraints === 'number'\n            ? { key, values, maxDepth: constraints }\n            : { key, values, maxDepth: constraints.maxDepth }\n        : { key, values };\n}\nfunction jsonObject(constraints) {\n    return anything(jsonSettings(string(), constraints));\n}\nfunction unicodeJsonObject(constraints) {\n    return anything(jsonSettings(unicodeString(), constraints));\n}\nfunction json(constraints) {\n    const arb = constraints != null ? jsonObject(constraints) : jsonObject();\n    return arb.map(JSON.stringify);\n}\nfunction unicodeJson(constraints) {\n    const arb = constraints != null ? unicodeJsonObject(constraints) : unicodeJsonObject();\n    return arb.map(JSON.stringify);\n}\nexport { anything, object, jsonObject, unicodeJsonObject, json, unicodeJson };\n", "export function extractEnumerableKeys(instance) {\n    const keys = Object.keys(instance);\n    const symbols = Object.getOwnPropertySymbols(instance);\n    for (let index = 0; index !== symbols.length; ++index) {\n        const symbol = symbols[index];\n        const descriptor = Object.getOwnPropertyDescriptor(instance, symbol);\n        if (descriptor && descriptor.enumerable) {\n            keys.push(symbol);\n        }\n    }\n    return keys;\n}\n", "export function buildValuesAndSeparateKeysToObjectMapper(keys, noKeyValue) {\n    return function valuesAndSeparateKeysToObjectMapper(gs) {\n        const obj = {};\n        for (let idx = 0; idx !== keys.length; ++idx) {\n            const valueWrapper = gs[idx];\n            if (valueWrapper !== noKeyValue) {\n                obj[keys[idx]] = valueWrapper;\n            }\n        }\n        return obj;\n    };\n}\nexport function buildValuesAndSeparateKeysToObjectUnmapper(keys, noKeyValue) {\n    return function valuesAndSeparateKeysToObjectUnmapper(value) {\n        if (typeof value !== 'object' || value === null) {\n            throw new Error('Incompatible instance received: should be a non-null object');\n        }\n        if (!('constructor' in value) || value.constructor !== Object) {\n            throw new Error('Incompatible instance received: should be of exact type Object');\n        }\n        let extractedPropertiesCount = 0;\n        const extractedValues = [];\n        for (let idx = 0; idx !== keys.length; ++idx) {\n            const descriptor = Object.getOwnPropertyDescriptor(value, keys[idx]);\n            if (descriptor !== undefined) {\n                if (!descriptor.configurable || !descriptor.enumerable || !descriptor.writable) {\n                    throw new Error('Incompatible instance received: should contain only c/e/w properties');\n                }\n                if (descriptor.get !== undefined || descriptor.set !== undefined) {\n                    throw new Error('Incompatible instance received: should contain only no get/set properties');\n                }\n                ++extractedPropertiesCount;\n                extractedValues.push(descriptor.value);\n            }\n            else {\n                extractedValues.push(noKeyValue);\n            }\n        }\n        const namePropertiesCount = Object.getOwnPropertyNames(value).length;\n        const symbolPropertiesCount = Object.getOwnPropertySymbols(value).length;\n        if (extractedPropertiesCount !== namePropertiesCount + symbolPropertiesCount) {\n            throw new Error('Incompatible instance received: should not contain extra properties');\n        }\n        return extractedValues;\n    };\n}\n", "import { convertFromNext, convertToNext } from '../../../check/arbitrary/definition/Converters.js';\nimport { option } from '../../option.js';\nimport { tuple } from '../../tuple.js';\nimport { extractEnumerableKeys } from '../helpers/EnumerableKeysExtractor.js';\nimport { buildValuesAndSeparateKeysToObjectMapper, buildValuesAndSeparateKeysToObjectUnmapper, } from '../mappers/ValuesAndSeparateKeysToObject.js';\nconst noKeyValue = Symbol('no-key');\nexport function buildPartialRecordArbitrary(recordModel, requiredKeys) {\n    const keys = extractEnumerableKeys(recordModel);\n    const arbs = [];\n    for (let index = 0; index !== keys.length; ++index) {\n        const k = keys[index];\n        const requiredArbitrary = recordModel[k];\n        if (requiredKeys === undefined || requiredKeys.indexOf(k) !== -1)\n            arbs.push(requiredArbitrary);\n        else\n            arbs.push(option(requiredArbitrary, { nil: noKeyValue }));\n    }\n    return convertFromNext(convertToNext(tuple(...arbs)).map(buildValuesAndSeparateKeysToObjectMapper(keys, noKeyValue), buildValuesAndSeparateKeysToObjectUnmapper(keys, noKeyValue)));\n}\n", "import { buildPartialRecordArbitrary } from './_internals/builders/PartialRecordArbitraryBuilder.js';\nfunction record(recordModel, constraints) {\n    if (constraints == null) {\n        return buildPartialRecordArbitrary(recordModel, undefined);\n    }\n    if ('withDeletedKeys' in constraints && 'requiredKeys' in constraints) {\n        throw new Error(`requiredKeys and withDeletedKeys cannot be used together in fc.record`);\n    }\n    const requireDeletedKeys = ('requiredKeys' in constraints && constraints.requiredKeys !== undefined) ||\n        ('withDeletedKeys' in constraints && !!constraints.withDeletedKeys);\n    if (!requireDeletedKeys) {\n        return buildPartialRecordArbitrary(recordModel, undefined);\n    }\n    const requiredKeys = ('requiredKeys' in constraints ? constraints.requiredKeys : undefined) || [];\n    for (let idx = 0; idx !== requiredKeys.length; ++idx) {\n        const descriptor = Object.getOwnPropertyDescriptor(recordModel, requiredKeys[idx]);\n        if (descriptor === undefined) {\n            throw new Error(`requiredKeys cannot reference keys that have not been defined in recordModel`);\n        }\n        if (!descriptor.enumerable) {\n            throw new Error(`requiredKeys cannot reference keys that have are enumerable in recordModel`);\n        }\n    }\n    return buildPartialRecordArbitrary(recordModel, requiredKeys);\n}\nexport { record };\n", "import { NextArbitrary } from '../../check/arbitrary/definition/NextArbitrary.js';\nimport { NextValue } from '../../check/arbitrary/definition/NextValue.js';\nimport { cloneMethod } from '../../check/symbols.js';\nimport { Stream } from '../../stream/Stream.js';\nimport { asyncStringify, asyncToStringMethod, stringify, toStringMethod } from '../../utils/stringify.js';\nfunction prettyPrint(seenValuesStrings) {\n    return `Stream(${seenValuesStrings.join(',')}\u2026)`;\n}\nexport class StreamArbitrary extends NextArbitrary {\n    constructor(arb) {\n        super();\n        this.arb = arb;\n    }\n    generate(mrng, biasFactor) {\n        const appliedBiasFactor = biasFactor !== undefined && mrng.nextInt(1, biasFactor) === 1 ? biasFactor : undefined;\n        const enrichedProducer = () => {\n            const seenValues = [];\n            const g = function* (arb, clonedMrng) {\n                while (true) {\n                    const value = arb.generate(clonedMrng, appliedBiasFactor).value;\n                    seenValues.push(value);\n                    yield value;\n                }\n            };\n            const s = new Stream(g(this.arb, mrng.clone()));\n            return Object.defineProperties(s, {\n                toString: { value: () => prettyPrint(seenValues.map(stringify)) },\n                [toStringMethod]: { value: () => prettyPrint(seenValues.map(stringify)) },\n                [asyncToStringMethod]: { value: async () => prettyPrint(await Promise.all(seenValues.map(asyncStringify))) },\n                [cloneMethod]: { value: enrichedProducer, enumerable: true },\n            });\n        };\n        return new NextValue(enrichedProducer(), undefined);\n    }\n    canShrinkWithoutContext(value) {\n        return false;\n    }\n    shrink(_value, _context) {\n        return Stream.nil();\n    }\n}\n", "import { convertFromNext, convertToNext } from '../check/arbitrary/definition/Converters.js';\nimport { StreamArbitrary } from './_internals/StreamArbitrary.js';\nfunction infiniteStream(arb) {\n    return convertFromNext(new StreamArbitrary(convertToNext(arb)));\n}\nexport { infiniteStream };\n", "import { convertFromNext, convertToNext } from '../check/arbitrary/definition/Converters.js';\nimport { array } from './array.js';\nimport { ascii } from './ascii.js';\nimport { extractStringConstraints, } from './_internals/helpers/StringConstraintsExtractor.js';\nimport { codePointsToStringMapper, codePointsToStringUnmapper } from './_internals/mappers/CodePointsToString.js';\nfunction asciiString(...args) {\n    const constraints = extractStringConstraints(args);\n    return convertFromNext(convertToNext(array(ascii(), constraints)).map(codePointsToStringMapper, codePointsToStringUnmapper));\n}\nexport { asciiString };\n", "export function stringToBase64Mapper(s) {\n    switch (s.length % 4) {\n        case 0:\n            return s;\n        case 3:\n            return `${s}=`;\n        case 2:\n            return `${s}==`;\n        default:\n            return s.slice(1);\n    }\n}\nexport function stringToBase64Unmapper(value) {\n    if (typeof value !== 'string' || value.length % 4 !== 0) {\n        throw new Error('Invalid string received');\n    }\n    const lastTrailingIndex = value.indexOf('=');\n    if (lastTrailingIndex === -1) {\n        return value;\n    }\n    const numTrailings = value.length - lastTrailingIndex;\n    if (numTrailings > 2) {\n        throw new Error('Cannot unmap the passed value');\n    }\n    return value.substring(0, lastTrailingIndex);\n}\n", "import { convertFromNext, convertToNext } from '../check/arbitrary/definition/Converters.js';\nimport { array } from './array.js';\nimport { base64 } from './base64.js';\nimport { maxLengthFromMinLength } from './_internals/helpers/MaxLengthFromMinLength.js';\nimport { extractStringConstraints, } from './_internals/helpers/StringConstraintsExtractor.js';\nimport { codePointsToStringMapper, codePointsToStringUnmapper } from './_internals/mappers/CodePointsToString.js';\nimport { stringToBase64Mapper, stringToBase64Unmapper } from './_internals/mappers/StringToBase64.js';\nfunction extractMinMaxConstraints(args) {\n    const constraints = extractStringConstraints(args);\n    const minLength = constraints.minLength !== undefined ? constraints.minLength : 0;\n    const maxLength = constraints.maxLength !== undefined ? constraints.maxLength : maxLengthFromMinLength(minLength);\n    return { minLength, maxLength };\n}\nfunction base64String(...args) {\n    const constraints = extractMinMaxConstraints(args);\n    const unscaledMinLength = constraints.minLength;\n    const unscaledMaxLength = constraints.maxLength;\n    const minLength = unscaledMinLength + 3 - ((unscaledMinLength + 3) % 4);\n    const maxLength = unscaledMaxLength - (unscaledMaxLength % 4);\n    if (minLength > maxLength)\n        throw new Error('Minimal length should be inferior or equal to maximal length');\n    if (minLength % 4 !== 0)\n        throw new Error('Minimal length of base64 strings must be a multiple of 4');\n    if (maxLength % 4 !== 0)\n        throw new Error('Maximal length of base64 strings must be a multiple of 4');\n    return convertFromNext(convertToNext(array(base64(), { minLength, maxLength }))\n        .map(codePointsToStringMapper, codePointsToStringUnmapper)\n        .map(stringToBase64Mapper, stringToBase64Unmapper));\n}\nexport { base64String };\n", "import { convertFromNext, convertToNext } from '../check/arbitrary/definition/Converters.js';\nimport { array } from './array.js';\nimport { fullUnicode } from './fullUnicode.js';\nimport { extractStringConstraints, } from './_internals/helpers/StringConstraintsExtractor.js';\nimport { codePointsToStringMapper, codePointsToStringUnmapper } from './_internals/mappers/CodePointsToString.js';\nfunction fullUnicodeString(...args) {\n    const constraints = extractStringConstraints(args);\n    return convertFromNext(convertToNext(array(fullUnicode(), constraints)).map(codePointsToStringMapper, codePointsToStringUnmapper));\n}\nexport { fullUnicodeString };\n", "export function charsToStringMapper(tab) {\n    return tab.join('');\n}\nexport function charsToStringUnmapper(value) {\n    if (typeof value !== 'string') {\n        throw new Error('Cannot unmap the passed value');\n    }\n    return value.split('');\n}\n", "import { convertFromNext, convertToNext } from '../check/arbitrary/definition/Converters.js';\nimport { array } from './array.js';\nimport { char16bits } from './char16bits.js';\nimport { extractStringConstraints, } from './_internals/helpers/StringConstraintsExtractor.js';\nimport { charsToStringMapper, charsToStringUnmapper } from './_internals/mappers/CharsToString.js';\nfunction string16bits(...args) {\n    const constraints = extractStringConstraints(args);\n    return convertFromNext(convertToNext(array(char16bits(), constraints)).map(charsToStringMapper, charsToStringUnmapper));\n}\nexport { string16bits };\n", "import { Arbitrary } from './Arbitrary.js';\nclass BiasedArbitraryWrapper extends Arbitrary {\n    constructor(freq, arb, biasedArbBuilder) {\n        super();\n        this.freq = freq;\n        this.arb = arb;\n        this.biasedArbBuilder = biasedArbBuilder;\n    }\n    generate(mrng) {\n        return mrng.nextInt(1, this.freq) === 1 ? this.biasedArbBuilder(this.arb).generate(mrng) : this.arb.generate(mrng);\n    }\n}\nexport function biasWrapper(freq, arb, biasedArbBuilder) {\n    return new BiasedArbitraryWrapper(freq, arb, biasedArbBuilder);\n}\n", "import { Stream } from '../../stream/Stream.js';\nimport { Arbitrary } from './definition/Arbitrary.js';\nimport { biasWrapper } from './definition/BiasedArbitraryWrapper.js';\nimport { Shrinkable } from './definition/Shrinkable.js';\nimport { integer } from '../../arbitrary/integer.js';\nimport { makeLazy } from '../../stream/LazyIterableIterator.js';\nclass SubarrayArbitrary extends Arbitrary {\n    constructor(originalArray, isOrdered, minLength, maxLength) {\n        super();\n        this.originalArray = originalArray;\n        this.isOrdered = isOrdered;\n        this.minLength = minLength;\n        this.maxLength = maxLength;\n        if (minLength < 0 || minLength > originalArray.length)\n            throw new Error('fc.*{s|S}ubarrayOf expects the minimal length to be between 0 and the size of the original array');\n        if (maxLength < 0 || maxLength > originalArray.length)\n            throw new Error('fc.*{s|S}ubarrayOf expects the maximal length to be between 0 and the size of the original array');\n        if (minLength > maxLength)\n            throw new Error('fc.*{s|S}ubarrayOf expects the minimal length to be inferior or equal to the maximal length');\n        this.lengthArb = integer(minLength, maxLength);\n    }\n    wrapper(items, itemsLengthContext) {\n        return new Shrinkable(items, () => this.shrinkImpl(items, itemsLengthContext).map((contextualValue) => this.wrapper(contextualValue[0], contextualValue[1])));\n    }\n    generate(mrng) {\n        const remainingElements = this.originalArray.map((_v, idx) => idx);\n        const size = this.lengthArb.generate(mrng).value;\n        const ids = [];\n        for (let idx = 0; idx !== size; ++idx) {\n            const selectedIdIndex = mrng.nextInt(0, remainingElements.length - 1);\n            ids.push(remainingElements[selectedIdIndex]);\n            remainingElements.splice(selectedIdIndex, 1);\n        }\n        if (this.isOrdered)\n            ids.sort((a, b) => a - b);\n        return this.wrapper(ids.map((i) => this.originalArray[i]), undefined);\n    }\n    shrinkImpl(items, itemsLengthContext) {\n        if (items.length === 0) {\n            return Stream.nil();\n        }\n        return this.lengthArb\n            .contextualShrink(items.length, itemsLengthContext)\n            .map((contextualValue) => {\n            return [\n                items.slice(items.length - contextualValue[0]),\n                contextualValue[1],\n            ];\n        })\n            .join(items.length > this.minLength\n            ? makeLazy(() => this.shrinkImpl(items.slice(1), undefined)\n                .filter((contextualValue) => this.minLength <= contextualValue[0].length + 1)\n                .map((contextualValue) => [[items[0]].concat(contextualValue[0]), undefined]))\n            : Stream.nil());\n    }\n    withBias(freq) {\n        return this.minLength !== this.maxLength\n            ? biasWrapper(freq, this, (originalArbitrary) => {\n                return new SubarrayArbitrary(originalArbitrary.originalArray, originalArbitrary.isOrdered, originalArbitrary.minLength, originalArbitrary.minLength +\n                    Math.floor(Math.log(originalArbitrary.maxLength - originalArbitrary.minLength) / Math.log(2)));\n            })\n            : this;\n    }\n}\nfunction subarray(originalArray, ...args) {\n    if (typeof args[0] === 'number' && typeof args[1] === 'number') {\n        return new SubarrayArbitrary(originalArray, true, args[0], args[1]);\n    }\n    const ct = args[0];\n    const minLength = ct !== undefined && ct.minLength !== undefined ? ct.minLength : 0;\n    const maxLength = ct !== undefined && ct.maxLength !== undefined ? ct.maxLength : originalArray.length;\n    return new SubarrayArbitrary(originalArray, true, minLength, maxLength);\n}\nfunction shuffledSubarray(originalArray, ...args) {\n    if (typeof args[0] === 'number' && typeof args[1] === 'number') {\n        return new SubarrayArbitrary(originalArray, false, args[0], args[1]);\n    }\n    const ct = args[0];\n    const minLength = ct !== undefined && ct.minLength !== undefined ? ct.minLength : 0;\n    const maxLength = ct !== undefined && ct.maxLength !== undefined ? ct.maxLength : originalArray.length;\n    return new SubarrayArbitrary(originalArray, false, minLength, maxLength);\n}\nexport { subarray, shuffledSubarray };\n", "import { integer } from '../../arbitrary/integer.js';\nimport { nat } from '../../arbitrary/nat.js';\nimport { tuple } from '../../arbitrary/tuple.js';\nconst padEight = (arb) => arb.map((n) => n.toString(16).padStart(8, '0'));\nexport function uuid() {\n    const padded = padEight(nat(0xffffffff));\n    const secondPadded = padEight(integer(0x10000000, 0x5fffffff));\n    const thirdPadded = padEight(integer(0x80000000, 0xbfffffff));\n    return tuple(padded, secondPadded, thirdPadded, padded).map((t) => {\n        return `${t[0]}-${t[1].substring(4)}-${t[1].substring(0, 4)}-${t[2].substring(0, 4)}-${t[2].substring(4)}${t[3]}`;\n    });\n}\nexport function uuidV(versionNumber) {\n    const padded = padEight(nat(0xffffffff));\n    const secondPadded = padEight(nat(0x0fffffff));\n    const thirdPadded = padEight(integer(0x80000000, 0xbfffffff));\n    return tuple(padded, secondPadded, thirdPadded, padded).map((t) => {\n        return `${t[0]}-${t[1].substring(4)}-${versionNumber}${t[1].substring(1, 4)}-${t[2].substring(0, 4)}-${t[2].substring(4)}${t[3]}`;\n    });\n}\n", "import { array } from '../../arbitrary/array.js';\nimport { constantFrom } from '../../arbitrary/constantFrom.js';\nimport { constant } from '../../arbitrary/constant.js';\nimport { buildAlphaNumericPercentArb } from './helpers/SpecificCharacterRange.js';\nimport { domain, hostUserInfo } from './HostArbitrary.js';\nimport { nat } from '../../arbitrary/nat.js';\nimport { ipV4 } from '../../arbitrary/ipV4.js';\nimport { ipV4Extended } from '../../arbitrary/ipV4Extended.js';\nimport { ipV6 } from '../../arbitrary/ipV6.js';\nimport { oneof } from '../../arbitrary/oneof.js';\nimport { option } from '../../arbitrary/option.js';\nimport { stringOf } from '../../arbitrary/stringOf.js';\nimport { tuple } from '../../arbitrary/tuple.js';\nexport function webAuthority(constraints) {\n    const c = constraints || {};\n    const hostnameArbs = [domain()]\n        .concat(c.withIPv4 === true ? [ipV4()] : [])\n        .concat(c.withIPv6 === true ? [ipV6().map((ip) => `[${ip}]`)] : [])\n        .concat(c.withIPv4Extended === true ? [ipV4Extended()] : []);\n    return tuple(c.withUserInfo === true ? option(hostUserInfo()) : constant(null), oneof(...hostnameArbs), c.withPort === true ? option(nat(65535)) : constant(null)).map(([u, h, p]) => (u === null ? '' : `${u}@`) + h + (p === null ? '' : `:${p}`));\n}\nexport function webSegment() {\n    const others = ['-', '.', '_', '~', '!', '$', '&', \"'\", '(', ')', '*', '+', ',', ';', '=', ':', '@'];\n    return stringOf(buildAlphaNumericPercentArb(others));\n}\nfunction uriQueryOrFragment() {\n    const others = ['-', '.', '_', '~', '!', '$', '&', \"'\", '(', ')', '*', '+', ',', ';', '=', ':', '@', '/', '?'];\n    return stringOf(buildAlphaNumericPercentArb(others));\n}\nexport function webQueryParameters() {\n    return uriQueryOrFragment();\n}\nexport function webFragments() {\n    return uriQueryOrFragment();\n}\nexport function webUrl(constraints) {\n    const c = constraints || {};\n    const validSchemes = c.validSchemes || ['http', 'https'];\n    const schemeArb = constantFrom(...validSchemes);\n    const authorityArb = webAuthority(c.authoritySettings);\n    const pathArb = array(webSegment()).map((p) => p.map((v) => `/${v}`).join(''));\n    return tuple(schemeArb, authorityArb, pathArb, c.withQueryParameters === true ? option(webQueryParameters()) : constant(null), c.withFragments === true ? option(webFragments()) : constant(null)).map(([s, a, p, q, f]) => `${s}://${a}${p}${q === null ? '' : `?${q}`}${f === null ? '' : `#${f}`}`);\n}\n", "export class ReplayPath {\n    static parse(replayPathStr) {\n        const [serializedCount, serializedChanges] = replayPathStr.split(':');\n        const counts = this.parseCounts(serializedCount);\n        const changes = this.parseChanges(serializedChanges);\n        return this.parseOccurences(counts, changes);\n    }\n    static stringify(replayPath) {\n        const occurences = this.countOccurences(replayPath);\n        const serializedCount = this.stringifyCounts(occurences);\n        const serializedChanges = this.stringifyChanges(occurences);\n        return `${serializedCount}:${serializedChanges}`;\n    }\n    static intToB64(n) {\n        if (n < 26)\n            return String.fromCharCode(n + 65);\n        if (n < 52)\n            return String.fromCharCode(n + 97 - 26);\n        if (n < 62)\n            return String.fromCharCode(n + 48 - 52);\n        return String.fromCharCode(n === 62 ? 43 : 47);\n    }\n    static b64ToInt(c) {\n        if (c >= 'a')\n            return c.charCodeAt(0) - 97 + 26;\n        if (c >= 'A')\n            return c.charCodeAt(0) - 65;\n        if (c >= '0')\n            return c.charCodeAt(0) - 48 + 52;\n        return c === '+' ? 62 : 63;\n    }\n    static countOccurences(replayPath) {\n        return replayPath.reduce((counts, cur) => {\n            if (counts.length === 0 || counts[counts.length - 1].count === 64 || counts[counts.length - 1].value !== cur)\n                counts.push({ value: cur, count: 1 });\n            else\n                counts[counts.length - 1].count += 1;\n            return counts;\n        }, []);\n    }\n    static parseOccurences(counts, changes) {\n        const replayPath = [];\n        for (let idx = 0; idx !== counts.length; ++idx) {\n            const count = counts[idx];\n            const value = changes[idx];\n            for (let num = 0; num !== count; ++num)\n                replayPath.push(value);\n        }\n        return replayPath;\n    }\n    static stringifyChanges(occurences) {\n        let serializedChanges = '';\n        for (let idx = 0; idx < occurences.length; idx += 6) {\n            const changesInt = occurences\n                .slice(idx, idx + 6)\n                .reduceRight((prev, cur) => prev * 2 + (cur.value ? 1 : 0), 0);\n            serializedChanges += this.intToB64(changesInt);\n        }\n        return serializedChanges;\n    }\n    static parseChanges(serializedChanges) {\n        const changesInt = serializedChanges.split('').map((c) => this.b64ToInt(c));\n        const changes = [];\n        for (let idx = 0; idx !== changesInt.length; ++idx) {\n            let current = changesInt[idx];\n            for (let n = 0; n !== 6; ++n, current >>= 1) {\n                changes.push(current % 2 === 1);\n            }\n        }\n        return changes;\n    }\n    static stringifyCounts(occurences) {\n        return occurences.map(({ count }) => this.intToB64(count - 1)).join('');\n    }\n    static parseCounts(serializedCount) {\n        return serializedCount.split('').map((c) => this.b64ToInt(c) + 1);\n    }\n}\n", "import { cloneMethod } from '../../symbols.js';\nexport class CommandsIterable {\n    constructor(commands, metadataForReplay) {\n        this.commands = commands;\n        this.metadataForReplay = metadataForReplay;\n    }\n    [Symbol.iterator]() {\n        return this.commands[Symbol.iterator]();\n    }\n    [cloneMethod]() {\n        return new CommandsIterable(this.commands.map((c) => c.clone()), this.metadataForReplay);\n    }\n    toString() {\n        const serializedCommands = this.commands\n            .filter((c) => c.hasRan)\n            .map((c) => c.toString())\n            .join(',');\n        const metadata = this.metadataForReplay();\n        return metadata.length !== 0 ? `${serializedCommands} /*${metadata}*/` : serializedCommands;\n    }\n}\n", "import { asyncToStringMethod, hasAsyncToStringMethod, hasToStringMethod, toStringMethod, } from '../../../utils/stringify.js';\nimport { cloneMethod, hasCloneMethod } from '../../symbols.js';\nexport class CommandWrapper {\n    constructor(cmd) {\n        this.cmd = cmd;\n        this.hasRan = false;\n        if (hasToStringMethod(cmd)) {\n            const method = cmd[toStringMethod];\n            this[toStringMethod] = function toStringMethod() {\n                return method.call(cmd);\n            };\n        }\n        if (hasAsyncToStringMethod(cmd)) {\n            const method = cmd[asyncToStringMethod];\n            this[asyncToStringMethod] = function asyncToStringMethod() {\n                return method.call(cmd);\n            };\n        }\n    }\n    check(m) {\n        return this.cmd.check(m);\n    }\n    run(m, r) {\n        this.hasRan = true;\n        return this.cmd.run(m, r);\n    }\n    clone() {\n        if (hasCloneMethod(this.cmd))\n            return new CommandWrapper(this.cmd[cloneMethod]());\n        return new CommandWrapper(this.cmd);\n    }\n    toString() {\n        return this.cmd.toString();\n    }\n}\n", "import { Stream } from '../../../stream/Stream.js';\nimport { Arbitrary } from '../../arbitrary/definition/Arbitrary.js';\nimport { Shrinkable } from '../../arbitrary/definition/Shrinkable.js';\nimport { nat } from '../../../arbitrary/nat.js';\nimport { oneof } from '../../../arbitrary/oneof.js';\nimport { ReplayPath } from '../ReplayPath.js';\nimport { CommandsIterable } from './CommandsIterable.js';\nimport { CommandWrapper } from './CommandWrapper.js';\nimport { makeLazy } from '../../../stream/LazyIterableIterator.js';\nclass CommandsArbitrary extends Arbitrary {\n    constructor(commandArbs, maxCommands, sourceReplayPath, disableReplayLog) {\n        super();\n        this.sourceReplayPath = sourceReplayPath;\n        this.disableReplayLog = disableReplayLog;\n        this.oneCommandArb = oneof(...commandArbs).map((c) => new CommandWrapper(c));\n        this.lengthArb = nat(maxCommands);\n        this.replayPath = [];\n        this.replayPathPosition = 0;\n    }\n    metadataForReplay() {\n        return this.disableReplayLog ? '' : `replayPath=${JSON.stringify(ReplayPath.stringify(this.replayPath))}`;\n    }\n    wrapper(items, shrunkOnce) {\n        return new Shrinkable(new CommandsIterable(items.map((s) => s.value_), () => this.metadataForReplay()), () => this.shrinkImpl(items, shrunkOnce).map((v) => this.wrapper(v, true)));\n    }\n    generate(mrng) {\n        const size = this.lengthArb.generate(mrng);\n        const items = Array(size.value_);\n        for (let idx = 0; idx !== size.value_; ++idx) {\n            const item = this.oneCommandArb.generate(mrng);\n            items[idx] = item;\n        }\n        this.replayPathPosition = 0;\n        return this.wrapper(items, false);\n    }\n    filterOnExecution(itemsRaw) {\n        const items = [];\n        for (const c of itemsRaw) {\n            if (c.value_.hasRan) {\n                this.replayPath.push(true);\n                items.push(c);\n            }\n            else\n                this.replayPath.push(false);\n        }\n        return items;\n    }\n    filterOnReplay(itemsRaw) {\n        return itemsRaw.filter((c, idx) => {\n            const state = this.replayPath[this.replayPathPosition + idx];\n            if (state === undefined)\n                throw new Error(`Too short replayPath`);\n            if (!state && c.value_.hasRan)\n                throw new Error(`Mismatch between replayPath and real execution`);\n            return state;\n        });\n    }\n    filterForShrinkImpl(itemsRaw) {\n        if (this.replayPathPosition === 0) {\n            this.replayPath = this.sourceReplayPath !== null ? ReplayPath.parse(this.sourceReplayPath) : [];\n        }\n        const items = this.replayPathPosition < this.replayPath.length\n            ? this.filterOnReplay(itemsRaw)\n            : this.filterOnExecution(itemsRaw);\n        this.replayPathPosition += itemsRaw.length;\n        return items;\n    }\n    shrinkImpl(itemsRaw, shrunkOnce) {\n        const items = this.filterForShrinkImpl(itemsRaw);\n        if (items.length === 0) {\n            return Stream.nil();\n        }\n        const rootShrink = shrunkOnce\n            ? Stream.nil()\n            : new Stream([[]][Symbol.iterator]());\n        const nextShrinks = [];\n        for (let numToKeep = 0; numToKeep !== items.length; ++numToKeep) {\n            nextShrinks.push(makeLazy(() => {\n                const size = this.lengthArb.contextualShrinkableFor(items.length - 1 - numToKeep);\n                const fixedStart = items.slice(0, numToKeep);\n                return size.shrink().map((l) => fixedStart.concat(items.slice(items.length - (l.value + 1))));\n            }));\n        }\n        for (let itemAt = 0; itemAt !== items.length; ++itemAt) {\n            nextShrinks.push(makeLazy(() => items[itemAt].shrink().map((v) => items.slice(0, itemAt).concat([v], items.slice(itemAt + 1)))));\n        }\n        return rootShrink.join(...nextShrinks).map((shrinkables) => {\n            return shrinkables.map((c) => {\n                return new Shrinkable(c.value_.clone(), c.shrink);\n            });\n        });\n    }\n}\nfunction commands(commandArbs, constraints) {\n    const config = constraints == null ? {} : typeof constraints === 'number' ? { maxCommands: constraints } : constraints;\n    return new CommandsArbitrary(commandArbs, config.maxCommands != null ? config.maxCommands : 10, config.replayPath != null ? config.replayPath : null, !!config.disableReplayLog);\n}\nexport { commands };\n", "export class ScheduledCommand {\n    constructor(s, cmd) {\n        this.s = s;\n        this.cmd = cmd;\n    }\n    async check(m) {\n        let error = null;\n        let checkPassed = false;\n        const status = await this.s.scheduleSequence([\n            {\n                label: `check@${this.cmd.toString()}`,\n                builder: async () => {\n                    try {\n                        checkPassed = await Promise.resolve(this.cmd.check(m));\n                    }\n                    catch (err) {\n                        error = err;\n                        throw err;\n                    }\n                },\n            },\n        ]).task;\n        if (status.faulty) {\n            throw error;\n        }\n        return checkPassed;\n    }\n    async run(m, r) {\n        let error = null;\n        const status = await this.s.scheduleSequence([\n            {\n                label: `run@${this.cmd.toString()}`,\n                builder: async () => {\n                    try {\n                        await this.cmd.run(m, r);\n                    }\n                    catch (err) {\n                        error = err;\n                        throw err;\n                    }\n                },\n            },\n        ]).task;\n        if (status.faulty) {\n            throw error;\n        }\n    }\n}\nexport const scheduleCommands = function* (s, cmds) {\n    for (const cmd of cmds) {\n        yield new ScheduledCommand(s, cmd);\n    }\n};\n", "import { scheduleCommands } from './commands/ScheduledCommand.js';\nconst genericModelRun = (s, cmds, initialValue, runCmd, then) => {\n    return s.then((o) => {\n        const { model, real } = o;\n        let state = initialValue;\n        for (const c of cmds) {\n            state = then(state, () => {\n                return runCmd(c, model, real);\n            });\n        }\n        return state;\n    });\n};\nconst internalModelRun = (s, cmds) => {\n    const then = (_p, c) => c();\n    const setupProducer = {\n        then: (fun) => {\n            fun(s());\n            return undefined;\n        },\n    };\n    const runSync = (cmd, m, r) => {\n        if (cmd.check(m))\n            cmd.run(m, r);\n        return undefined;\n    };\n    return genericModelRun(setupProducer, cmds, undefined, runSync, then);\n};\nconst isAsyncSetup = (s) => {\n    return typeof s.then === 'function';\n};\nconst internalAsyncModelRun = async (s, cmds, defaultPromise = Promise.resolve()) => {\n    const then = (p, c) => p.then(c);\n    const setupProducer = {\n        then: (fun) => {\n            const out = s();\n            if (isAsyncSetup(out))\n                return out.then(fun);\n            else\n                return fun(out);\n        },\n    };\n    const runAsync = async (cmd, m, r) => {\n        if (await cmd.check(m))\n            await cmd.run(m, r);\n    };\n    return await genericModelRun(setupProducer, cmds, defaultPromise, runAsync, then);\n};\nexport function modelRun(s, cmds) {\n    internalModelRun(s, cmds);\n}\nexport async function asyncModelRun(s, cmds) {\n    await internalAsyncModelRun(s, cmds);\n}\nexport async function scheduledModelRun(scheduler, s, cmds) {\n    const scheduledCommands = scheduleCommands(scheduler, cmds);\n    const out = internalAsyncModelRun(s, scheduledCommands, scheduler.schedule(Promise.resolve(), 'startModel'));\n    await scheduler.waitAll();\n    await out;\n}\n", "import { escapeForTemplateString } from '../../../check/arbitrary/helpers/TextEscaper.js';\nimport { cloneMethod } from '../../../check/symbols.js';\nimport { stringify } from '../../../utils/stringify.js';\nexport class SchedulerImplem {\n    constructor(act, taskSelector) {\n        this.act = act;\n        this.taskSelector = taskSelector;\n        this.lastTaskId = 0;\n        this.sourceTaskSelector = taskSelector.clone();\n        this.scheduledTasks = [];\n        this.triggeredTasks = [];\n    }\n    static buildLog(reportItem) {\n        return `[task\\${${reportItem.taskId}}] ${reportItem.label.length !== 0 ? `${reportItem.schedulingType}::${reportItem.label}` : reportItem.schedulingType} ${reportItem.status}${reportItem.outputValue !== undefined ? ` with value ${escapeForTemplateString(reportItem.outputValue)}` : ''}`;\n    }\n    log(schedulingType, taskId, label, metadata, status, data) {\n        this.triggeredTasks.push({\n            status,\n            schedulingType,\n            taskId,\n            label,\n            metadata,\n            outputValue: data !== undefined ? stringify(data) : undefined,\n        });\n    }\n    scheduleInternal(schedulingType, label, task, metadata, thenTaskToBeAwaited) {\n        let trigger = null;\n        const taskId = ++this.lastTaskId;\n        const scheduledPromise = new Promise((resolve, reject) => {\n            trigger = () => {\n                (thenTaskToBeAwaited ? task.then(() => thenTaskToBeAwaited()) : task).then((data) => {\n                    this.log(schedulingType, taskId, label, metadata, 'resolved', data);\n                    return resolve(data);\n                }, (err) => {\n                    this.log(schedulingType, taskId, label, metadata, 'rejected', err);\n                    return reject(err);\n                });\n            };\n        });\n        this.scheduledTasks.push({\n            original: task,\n            scheduled: scheduledPromise,\n            trigger: trigger,\n            schedulingType,\n            taskId,\n            label,\n            metadata,\n        });\n        return scheduledPromise;\n    }\n    schedule(task, label, metadata) {\n        return this.scheduleInternal('promise', label || '', task, metadata);\n    }\n    scheduleFunction(asyncFunction) {\n        return (...args) => this.scheduleInternal('function', `${asyncFunction.name}(${args.map(stringify).join(',')})`, asyncFunction(...args), undefined);\n    }\n    scheduleSequence(sequenceBuilders) {\n        const status = { done: false, faulty: false };\n        const dummyResolvedPromise = { then: (f) => f() };\n        let resolveSequenceTask = () => { };\n        const sequenceTask = new Promise((resolve) => (resolveSequenceTask = resolve));\n        sequenceBuilders\n            .reduce((previouslyScheduled, item) => {\n            const [builder, label, metadata] = typeof item === 'function' ? [item, item.name, undefined] : [item.builder, item.label, item.metadata];\n            return previouslyScheduled.then(() => {\n                const scheduled = this.scheduleInternal('sequence', label, dummyResolvedPromise, metadata, () => builder());\n                scheduled.catch(() => {\n                    status.faulty = true;\n                    resolveSequenceTask();\n                });\n                return scheduled;\n            });\n        }, dummyResolvedPromise)\n            .then(() => {\n            status.done = true;\n            resolveSequenceTask();\n        }, () => {\n        });\n        return Object.assign(status, {\n            task: Promise.resolve(sequenceTask).then(() => {\n                return { done: status.done, faulty: status.faulty };\n            }),\n        });\n    }\n    count() {\n        return this.scheduledTasks.length;\n    }\n    async internalWaitOne() {\n        if (this.scheduledTasks.length === 0) {\n            throw new Error('No task scheduled');\n        }\n        const taskIndex = this.taskSelector.nextTaskIndex(this.scheduledTasks);\n        const [scheduledTask] = this.scheduledTasks.splice(taskIndex, 1);\n        scheduledTask.trigger();\n        try {\n            await scheduledTask.scheduled;\n        }\n        catch (_err) {\n        }\n    }\n    async waitOne() {\n        await this.act(async () => await this.internalWaitOne());\n    }\n    async waitAll() {\n        while (this.scheduledTasks.length > 0) {\n            await this.waitOne();\n        }\n    }\n    report() {\n        return [\n            ...this.triggeredTasks,\n            ...this.scheduledTasks.map((t) => ({\n                status: 'pending',\n                schedulingType: t.schedulingType,\n                taskId: t.taskId,\n                label: t.label,\n                metadata: t.metadata,\n            })),\n        ];\n    }\n    toString() {\n        return ('schedulerFor()`\\n' +\n            this.report()\n                .map(SchedulerImplem.buildLog)\n                .map((log) => `-> ${log}`)\n                .join('\\n') +\n            '`');\n    }\n    [cloneMethod]() {\n        return new SchedulerImplem(this.act, this.sourceTaskSelector);\n    }\n}\n", "import { SchedulerImplem } from '../implementations/SchedulerImplem.js';\nfunction buildNextTaskIndex(ordering) {\n    let numTasks = 0;\n    return {\n        clone: () => buildNextTaskIndex(ordering),\n        nextTaskIndex: (scheduledTasks) => {\n            if (ordering.length <= numTasks) {\n                throw new Error(`Invalid schedulerFor defined: too many tasks have been scheduled`);\n            }\n            const taskIndex = scheduledTasks.findIndex((t) => t.taskId === ordering[numTasks]);\n            if (taskIndex === -1) {\n                throw new Error(`Invalid schedulerFor defined: unable to find next task`);\n            }\n            ++numTasks;\n            return taskIndex;\n        },\n    };\n}\nexport function buildSchedulerFor(act, ordering) {\n    return new SchedulerImplem(act, buildNextTaskIndex(ordering));\n}\n", "import { NextArbitrary } from '../../check/arbitrary/definition/NextArbitrary.js';\nimport { NextValue } from '../../check/arbitrary/definition/NextValue.js';\nimport { Stream } from '../../stream/Stream.js';\nimport { SchedulerImplem } from './implementations/SchedulerImplem.js';\nfunction buildNextTaskIndex(mrng) {\n    const clonedMrng = mrng.clone();\n    return {\n        clone: () => buildNextTaskIndex(clonedMrng),\n        nextTaskIndex: (scheduledTasks) => {\n            return mrng.nextInt(0, scheduledTasks.length - 1);\n        },\n    };\n}\nexport class SchedulerArbitrary extends NextArbitrary {\n    constructor(act) {\n        super();\n        this.act = act;\n    }\n    generate(mrng, _biasFactor) {\n        return new NextValue(new SchedulerImplem(this.act, buildNextTaskIndex(mrng.clone())), undefined);\n    }\n    canShrinkWithoutContext(value) {\n        return false;\n    }\n    shrink(_value, _context) {\n        return Stream.nil();\n    }\n}\n", "import { convertFromNext } from '../check/arbitrary/definition/Converters.js';\nimport { buildSchedulerFor } from './_internals/helpers/BuildSchedulerFor.js';\nimport { SchedulerArbitrary } from './_internals/SchedulerArbitrary.js';\nexport function scheduler(constraints) {\n    const { act = (f) => f() } = constraints || {};\n    return convertFromNext(new SchedulerArbitrary(act));\n}\nfunction schedulerFor(customOrderingOrConstraints, constraintsOrUndefined) {\n    const { act = (f) => f() } = Array.isArray(customOrderingOrConstraints)\n        ? constraintsOrUndefined || {}\n        : customOrderingOrConstraints || {};\n    if (Array.isArray(customOrderingOrConstraints)) {\n        return buildSchedulerFor(act, customOrderingOrConstraints);\n    }\n    return function (_strs, ...ordering) {\n        return buildSchedulerFor(act, ordering);\n    };\n}\nexport { schedulerFor };\n", "import { Arbitrary } from './Arbitrary.js';\nimport { Shrinkable } from './Shrinkable.js';\nclass ArbitraryWithShrink extends Arbitrary {\n    shrinkableFor(value, shrunkOnce) {\n        return new Shrinkable(value, () => this.shrink(value, shrunkOnce === true).map((v) => this.shrinkableFor(v, true)));\n    }\n}\nexport { ArbitraryWithShrink };\n", "import { pre } from './check/precondition/Pre.js';\nimport { asyncProperty, } from './check/property/AsyncProperty.js';\nimport { property } from './check/property/Property.js';\nimport { assert, check } from './check/runner/Runner.js';\nimport { sample, statistics } from './check/runner/Sampler.js';\nimport { array } from './arbitrary/array.js';\nimport { bigInt } from './arbitrary/bigInt.js';\nimport { bigIntN } from './arbitrary/bigIntN.js';\nimport { bigUint } from './arbitrary/bigUint.js';\nimport { bigUintN } from './arbitrary/bigUintN.js';\nimport { boolean } from './arbitrary/boolean.js';\nimport { falsy } from './arbitrary/falsy.js';\nimport { ascii } from './arbitrary/ascii.js';\nimport { base64 } from './arbitrary/base64.js';\nimport { char } from './arbitrary/char.js';\nimport { char16bits } from './arbitrary/char16bits.js';\nimport { fullUnicode } from './arbitrary/fullUnicode.js';\nimport { hexa } from './arbitrary/hexa.js';\nimport { unicode } from './arbitrary/unicode.js';\nimport { clonedConstant } from './arbitrary/clonedConstant.js';\nimport { constant } from './arbitrary/constant.js';\nimport { constantFrom } from './arbitrary/constantFrom.js';\nimport { context } from './arbitrary/context.js';\nimport { date } from './arbitrary/date.js';\nimport { clone } from './arbitrary/clone.js';\nimport { dedup } from './arbitrary/dedup.js';\nimport { Arbitrary } from './check/arbitrary/definition/Arbitrary.js';\nimport { Shrinkable } from './check/arbitrary/definition/Shrinkable.js';\nimport { dictionary } from './arbitrary/dictionary.js';\nimport { emailAddress } from './check/arbitrary/EmailArbitrary.js';\nimport { double, float } from './check/arbitrary/FloatingPointArbitrary.js';\nimport { frequency } from './arbitrary/frequency.js';\nimport { compareBooleanFunc } from './arbitrary/compareBooleanFunc.js';\nimport { compareFunc } from './arbitrary/compareFunc.js';\nimport { func } from './arbitrary/func.js';\nimport { domain } from './check/arbitrary/HostArbitrary.js';\nimport { integer } from './arbitrary/integer.js';\nimport { maxSafeInteger } from './arbitrary/maxSafeInteger.js';\nimport { maxSafeNat } from './arbitrary/maxSafeNat.js';\nimport { nat } from './arbitrary/nat.js';\nimport { ipV4 } from './arbitrary/ipV4.js';\nimport { ipV4Extended } from './arbitrary/ipV4Extended.js';\nimport { ipV6 } from './arbitrary/ipV6.js';\nimport { letrec } from './arbitrary/letrec.js';\nimport { lorem } from './arbitrary/lorem.js';\nimport { mapToConstant } from './arbitrary/mapToConstant.js';\nimport { memo } from './arbitrary/memo.js';\nimport { mixedCase } from './arbitrary/mixedCase.js';\nimport { anything, json, jsonObject, object, unicodeJson, unicodeJsonObject, } from './check/arbitrary/ObjectArbitrary.js';\nimport { oneof } from './arbitrary/oneof.js';\nimport { option } from './arbitrary/option.js';\nimport { record } from './arbitrary/record.js';\nimport { set } from './arbitrary/set.js';\nimport { infiniteStream } from './arbitrary/infiniteStream.js';\nimport { asciiString } from './arbitrary/asciiString.js';\nimport { base64String } from './arbitrary/base64String.js';\nimport { fullUnicodeString } from './arbitrary/fullUnicodeString.js';\nimport { hexaString } from './arbitrary/hexaString.js';\nimport { string } from './arbitrary/string.js';\nimport { string16bits } from './arbitrary/string16bits.js';\nimport { stringOf } from './arbitrary/stringOf.js';\nimport { unicodeString } from './arbitrary/unicodeString.js';\nimport { shuffledSubarray, subarray } from './check/arbitrary/SubarrayArbitrary.js';\nimport { genericTuple } from './arbitrary/genericTuple.js';\nimport { tuple } from './arbitrary/tuple.js';\nimport { uuid, uuidV } from './check/arbitrary/UuidArbitrary.js';\nimport { webAuthority, webFragments, webQueryParameters, webSegment, webUrl, } from './check/arbitrary/WebArbitrary.js';\nimport { commands } from './check/model/commands/CommandsArbitrary.js';\nimport { asyncModelRun, modelRun, scheduledModelRun, } from './check/model/ModelRunner.js';\nimport { Random } from './random/generator/Random.js';\nimport { configureGlobal, readConfigureGlobal, resetConfigureGlobal, } from './check/runner/configuration/GlobalParameters.js';\nimport { VerbosityLevel } from './check/runner/configuration/VerbosityLevel.js';\nimport { ExecutionStatus } from './check/runner/reporter/ExecutionStatus.js';\nimport { cloneMethod, cloneIfNeeded, hasCloneMethod } from './check/symbols.js';\nimport { Stream, stream } from './stream/Stream.js';\nimport { hash } from './utils/hash.js';\nimport { stringify, asyncStringify, toStringMethod, hasToStringMethod, asyncToStringMethod, hasAsyncToStringMethod, } from './utils/stringify.js';\nimport { scheduler, schedulerFor, } from './arbitrary/scheduler.js';\nimport { defaultReportMessage, asyncDefaultReportMessage } from './check/runner/utils/RunDetailsFormatter.js';\nimport { ArbitraryWithShrink } from './check/arbitrary/definition/ArbitraryWithShrink.js';\nimport { ArbitraryWithContextualShrink } from './check/arbitrary/definition/ArbitraryWithContextualShrink.js';\nimport { PreconditionFailure } from './check/precondition/PreconditionFailure.js';\nimport { int8Array } from './arbitrary/int8Array.js';\nimport { int16Array } from './arbitrary/int16Array.js';\nimport { int32Array } from './arbitrary/int32Array.js';\nimport { uint8Array } from './arbitrary/uint8Array.js';\nimport { uint8ClampedArray } from './arbitrary/uint8ClampedArray.js';\nimport { uint16Array } from './arbitrary/uint16Array.js';\nimport { uint32Array } from './arbitrary/uint32Array.js';\nimport { float32Array } from './arbitrary/float32Array.js';\nimport { float64Array } from './arbitrary/float64Array.js';\nimport { sparseArray } from './check/arbitrary/SparseArrayArbitrary.js';\nimport { NextArbitrary } from './check/arbitrary/definition/NextArbitrary.js';\nimport { NextValue } from './check/arbitrary/definition/NextValue.js';\nimport { convertFromNext, convertFromNextWithShrunkOnce, convertToNext } from './check/arbitrary/definition/Converters.js';\nconst __type = 'module';\nconst __version = '2.17.0';\nconst __commitHash = 'b7064a21412eb9e68edb3aece74d45522c80bc77';\nexport { __type, __version, __commitHash, sample, statistics, check, assert, pre, PreconditionFailure, property, asyncProperty, boolean, falsy, float, double, integer, nat, maxSafeInteger, maxSafeNat, bigIntN, bigUintN, bigInt, bigUint, char, ascii, char16bits, unicode, fullUnicode, hexa, base64, mixedCase, string, asciiString, string16bits, stringOf, unicodeString, fullUnicodeString, hexaString, base64String, lorem, constant, constantFrom, clonedConstant, mapToConstant, option, oneof, frequency, clone, dedup, shuffledSubarray, subarray, array, sparseArray, infiniteStream, set, tuple, genericTuple, record, dictionary, anything, object, json, jsonObject, unicodeJson, unicodeJsonObject, letrec, memo, compareBooleanFunc, compareFunc, func, context, date, ipV4, ipV4Extended, ipV6, domain, webAuthority, webSegment, webFragments, webQueryParameters, webUrl, emailAddress, uuid, uuidV, int8Array, uint8Array, uint8ClampedArray, int16Array, uint16Array, int32Array, uint32Array, float32Array, float64Array, asyncModelRun, modelRun, scheduledModelRun, commands, scheduler, schedulerFor, Arbitrary, NextArbitrary, ArbitraryWithShrink, ArbitraryWithContextualShrink, Shrinkable, NextValue, cloneMethod, cloneIfNeeded, hasCloneMethod, convertFromNext, convertFromNextWithShrunkOnce, convertToNext, toStringMethod, hasToStringMethod, asyncToStringMethod, hasAsyncToStringMethod, stringify, asyncStringify, defaultReportMessage, asyncDefaultReportMessage, hash, VerbosityLevel, configureGlobal, readConfigureGlobal, resetConfigureGlobal, ExecutionStatus, Random, Stream, stream, };\n", "import * as fc from './fast-check-default.js';\nexport default fc;\nexport * from './fast-check-default.js';\n", "/**\r\n * ---\r\n * {\r\n *  \"modules\": [ \"./src/components/run-expr-tests.ts\" ]\r\n * }\r\n * ---\r\n * \r\n * # Testing the Expression Parser\r\n * \r\n * The easiest way to test our parser is to manually input some expressions \r\n * (press `Enter` to calculate).\r\n * \r\n * <calculator-tests></calculator-tests>\r\n * \r\n * But this becomes tedious soon, so let's write some automatic tests as well.\r\n * We use the `test` function from the **lits-extras** package.\r\n */\r\nimport { test } from \"lits-extras/lib/tester\"\r\nimport * as ep from \"./exprparser\"\r\nimport * as fc from \"fast-check\"\r\nimport * as pz from \"..\"\r\n/**\r\n * First, let's test some valid expressions. Since our expressions are valid\r\n * in JavaScript too, we can use the `eval` function as the baseline.\r\n */\r\ntest(\"Test parsing of predefined expressions\", async t => {\r\n    let testset: string[] = [\r\n        \"1 + -1\",\r\n        \"2 + 3 * 3\",\r\n        \"1 - 1 / 2\",\r\n        \"(1 - 1) / 2\",\r\n        \"(1) + (((2)) + 3)\"]\r\n    for (let i = 0; i < testset.length; i++) {\r\n        let expr = testset[i]\r\n        let res = eval(expr)\r\n        let calcres = ep.evaluateExpression(expr)\r\n        t.equal(calcres, res, `expression '${expr}' should evaluate to ${res}`)\r\n    }\r\n})\r\n/**\r\n * Then we test expression that should not be valid.\r\n */\r\ntest(\"Test failing expressions\", async t => {\r\n    let testset: string[] = [\r\n        \"1 + \",\r\n        \"2 ++ 3 * 3\",\r\n        \"- 1 - 1\",\r\n        \"\",\r\n        \"a + 1\"]\r\n    for (let i = 0; i < testset.length; i++) {\r\n        let expr = testset[i]\r\n        t.throws(() => ep.evaluateExpression(expr), pz.ParseError,\r\n            `expression '${expr}' should not parse`)\r\n    }\r\n})\r\n/**\r\n * ## Property Based Tests\r\n * \r\n * Coming up with test cases also becomes tedious quickly, so let's automate\r\n * test case generation with [fast-check][] library. This kind of approach is \r\n * called _property based testing_, and it helps us get confidence that our\r\n * implementation works correctly.\r\n * \r\n * [fast-check]: https://github.com/dubzzz/fast-check\r\n *\r\n * ### Running Tests\r\n * \r\n * When we run the tests, we can see how crazy input data we get when we \r\n * generate it with fast-check. It produces test cases we would very unlikely \r\n * come up with ourselves. You can press `F5` to rerun the tests.\r\n * \r\n * <test-runner name=\"Expression tests\"></test-runner>\r\n * \r\n * ### Generating Arbitrary Expressions\r\n * \r\n * So, how do we generate these arbitrary input expressions? We construct them \r\n * bottom-up starting from numbers and operators. Numbers we select randomly \r\n * from range [-1000, 1000].\r\n */\r\nconst arbNum = fc.integer(-1000, 1000).map(n => n.toString())\r\n/**\r\n * Operators are randomly selected from a predefined list.\r\n */\r\nconst arbOper = fc.constantFrom(\"+\", \"-\", \"*\", \"/\")\r\n/**\r\n * Since expression is a tree-like structure, we need to use a combinator that\r\n * constructs data recursively. In fast-check this combinator is called\r\n * `letrec`. It takes a recursive function that returns an object which \r\n * properties generate arbitrary element of different types. We can descend to \r\n * the next level in the expression tree by calling the `tie` function we get \r\n * as an argument. \r\n */\r\nconst arbExpr = fc.letrec(tie => (\r\n    {\r\n        num: arbNum,\r\n        oper: fc.tuple(tie('expr') as fc.Arbitrary<string>, arbOper,\r\n            tie('expr') as fc.Arbitrary<string>).map(t =>\r\n                `${t[0]} ${t[1]} ${t[2]}`),\r\n        par: tie('expr').map(e => \"(\" + e + \")\"),\r\n        expr: fc.oneof(tie('num'), tie('oper'), tie('par')) as\r\n            fc.Arbitrary<string>\r\n    }\r\n))\r\n/**\r\n * ### Defining Properties\r\n * \r\n * Armed with our arbitrary combinators, we can define the properties that our\r\n * data should have (hence the name \"property based testing\"). We do that simply\r\n * by checking that JS `eval` and our `evaluateExpression` functions return the\r\n * same result for all input data.\r\n */\r\ntest(\"Test arbitrary expressions\", async t =>\r\n    fc.assert(\r\n        fc.property(arbExpr.expr, e => {\r\n            let res1 = eval(e)\r\n            let res2 = ep.evaluateExpression(e)\r\n            t.equal(res1, res2, `expression '${e}' should evaluate to ${res1}`)\r\n        })))\r\n", "import { StyledElement } from 'litscript/lib/src/custom-elem'\r\nimport 'lits-extras/lib/test-runner'\r\nimport * as pz from '..'\r\nimport * as ep from '../test/exprparser'\r\nimport '../test/exprtests'\r\nimport './run-expr-tests.css'\r\n\r\nexport class CalculatorTests extends StyledElement {\r\n    private input: HTMLInputElement\r\n    private result: HTMLDivElement\r\n\r\n    constructor() {\r\n        super(\"run-expr-tests\")\r\n        this.body.classList.add(\"calculator\")\r\n        this.input = document.createElement('input')\r\n        this.result = document.createElement('div')\r\n        this.result.classList.add(\"result\")\r\n        this.body.append(this.input, this.result)\r\n    }\r\n    \r\n    protected override connect() {\r\n        this.input.addEventListener(\"change\",  _ => {\r\n            try {\r\n                this.result.innerText = ep.evaluateExpression(this.input.value)\r\n                    .toString()\r\n            }\r\n            catch(e) {\r\n                if (e instanceof pz.ParseError)\r\n                    this.result.innerText = e.message\r\n                else\r\n                    throw e\r\n            }\r\n        })\r\n    }\r\n}\r\n\r\ncustomElements.define(\"calculator-tests\", CalculatorTests)\r\n"],
  "mappings": "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",
  "names": ["StyledElement", "stream", "test", "counter", "skip", "assert", "start", "e", "equal", "i", "func", "stream", "id", "factory", "indent", "falsy", "fail", "e", "res", "i", "res", "lexer", "eof", "token", "t", "i", "res", "i", "token", "t", "parse", "res1", "res2", "expr", "t", "i", "t", "context", "value", "context", "ChainArbitrary", "MapArbitrary", "FilterArbitrary", "NoShrinkArbitrary", "NoBiasArbitrary", "context", "context", "t", "_a", "identifier", "context", "t", "context", "v", "idx", "t", "LinearCongruential", "LinearCongruential32", "MersenneTwister", "XorShift128Plus", "i", "XoroShiro128Plus", "i", "rng", "nextRng", "rng", "nextRng", "rng", "nextRng", "VerbosityLevel", "property", "property", "t", "property", "_a", "getAsyncContent", "property", "ExecutionStatus", "failed", "e", "property", "e", "context", "sargs", "context", "gapSize", "context", "context", "weightedArbs", "context", "commands", "t", "t", "testset", "i", "expr", "e", "e"]
}
